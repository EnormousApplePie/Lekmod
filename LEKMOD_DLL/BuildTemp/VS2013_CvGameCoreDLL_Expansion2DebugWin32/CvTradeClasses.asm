; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTradeClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
PUBLIC	?Reset@CvGameTrade@@QAEXXZ			; CvGameTrade::Reset
PUBLIC	??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
PUBLIC	??0CvGameTrade@@QAE@XZ				; CvGameTrade::CvGameTrade
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvGameTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvGameTrade@@QAE@XZ$0
__ehfuncinfo$??0CvGameTrade@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvGameTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvGameTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
__$EHRec$ = -12						; size = 12
??0CvGameTrade@@QAE@XZ PROC				; CvGameTrade::CvGameTrade, COMDAT
; _this$ = ecx

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvGameTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 38   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvGameTrade@@QAEXXZ		; CvGameTrade::Reset

; 39   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvGameTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__ehhandler$??0CvGameTrade@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvGameTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvGameTrade@@QAE@XZ ENDP				; CvGameTrade::CvGameTrade
PUBLIC	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
PUBLIC	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free
PUBLIC	??1CvGameTrade@@QAE@XZ				; CvGameTrade::~CvGameTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvGameTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGameTrade@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvGameTrade@@QAE@XZ$1
__ehfuncinfo$??1CvGameTrade@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvGameTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvGameTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
__$EHRec$ = -12						; size = 12
??1CvGameTrade@@QAE@XZ PROC				; CvGameTrade::~CvGameTrade, COMDAT
; _this$ = ecx

; 44   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvGameTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 45   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvGameTrade@@QAEXXZ		; CvGameTrade::Reset

; 46   : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvGameTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__unwindfunclet$??1CvGameTrade@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
__ehhandler$??1CvGameTrade@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvGameTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvGameTrade@@QAE@XZ ENDP				; CvGameTrade::~CvGameTrade
PUBLIC	?Init@CvGameTrade@@QAEXXZ			; CvGameTrade::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@CvGameTrade@@QAEXXZ PROC				; CvGameTrade::Init, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvGameTrade@@QAEXXZ		; CvGameTrade::Reset

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Init@CvGameTrade@@QAEXXZ ENDP				; CvGameTrade::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvGameTrade@@QAEXXZ			; CvGameTrade::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninit@CvGameTrade@@QAEXXZ PROC			; CvGameTrade::Uninit, COMDAT
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvGameTrade@@QAEXXZ		; CvGameTrade::Reset

; 60   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvGameTrade@@QAEXXZ ENDP			; CvGameTrade::Uninit
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ ; BaseVector<TradeConnection,0>::clear
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
?Reset@CvGameTrade@@QAEXXZ PROC				; CvGameTrade::Reset, COMDAT
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	m_aTradeConnections.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ ; BaseVector<TradeConnection,0>::clear

; 67   : 	m_iNextID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+74608], 0

; 68   : 	m_CurrentTemporaryPopupRoute.iPlotX = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76548], 0

; 69   : 	m_CurrentTemporaryPopupRoute.iPlotY = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76552], 0

; 70   : 	m_CurrentTemporaryPopupRoute.type = TRADE_CONNECTION_INTERNATIONAL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76556], 0

; 71   : #ifdef AUI_WARNING_FIXES
; 72   : 	ResetTechDifference();
; 73   : #endif
; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvGameTrade@@QAEXXZ ENDP				; CvGameTrade::Reset
_TEXT	ENDS
PUBLIC	?BuildTechDifference@CvGameTrade@@QAEXXZ	; CvGameTrade::BuildTechDifference
PUBLIC	?ResetTechDifference@CvGameTrade@@QAEXXZ	; CvGameTrade::ResetTechDifference
PUBLIC	?DoTurn@CvGameTrade@@QAEXXZ			; CvGameTrade::DoTurn
; Function compile flags: /Odtp
;	COMDAT ?DoTurn@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoTurn@CvGameTrade@@QAEXXZ PROC			; CvGameTrade::DoTurn, COMDAT
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	ResetTechDifference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetTechDifference@CvGameTrade@@QAEXXZ ; CvGameTrade::ResetTechDifference

; 87   : 	BuildTechDifference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildTechDifference@CvGameTrade@@QAEXXZ ; CvGameTrade::BuildTechDifference

; 88   : #endif
; 89   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTurn@CvGameTrade@@QAEXXZ ENDP			; CvGameTrade::DoTurn
_TEXT	ENDS
PUBLIC	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
PUBLIC	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
EXTRN	?IsRazing@CvCity@@QBE_NXZ:PROC			; CvCity::IsRazing
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::AllowsProductionTradeRoutes
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::AllowsFoodTradeRoutes
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Odtp
;	COMDAT ?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T227698 = -96						; size = 4
$T227662 = -92						; size = 4
$T227658 = -88						; size = 4
$T227654 = -84						; size = 4
$T227650 = -80						; size = 4
$T227646 = -76						; size = 4
$T227637 = -72						; size = 4
$T227633 = -68						; size = 4
$T227629 = -64						; size = 4
_i$219244 = -60						; size = 4
_iDestX$219242 = -56					; size = 4
_iOriginY$219241 = -52					; size = 4
_iOriginX$219240 = -48					; size = 4
_iDestY$219243 = -44					; size = 4
_pBuildingEntry$219229 = -40				; size = 4
_eBuilding$219226 = -36					; size = 4
_iI$219222 = -32					; size = 4
_bAllowsProductionConnection$219221 = -25		; size = 1
_pBuildingEntry$219213 = -24				; size = 4
_eBuilding$219210 = -20					; size = 4
_iI$219206 = -16					; size = 4
_bAllowsFoodConnection$219205 = -9			; size = 1
_eOriginTeam$ = -8					; size = 4
_eDestTeam$ = -4					; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
_bIgnoreExisting$ = 24					; size = 1
_bCheckPath$ = 28					; size = 1
?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z PROC ; CvGameTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	if (pOriginCity == NULL)

	cmp	DWORD PTR _pOriginCity$[ebp], 0
	jne	SHORT $LN38@CanCreateT

; 99   : 	{
; 100  : 		return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN38@CanCreateT:

; 101  : 	}
; 102  : 
; 103  : 	if (pDestCity == NULL)

	cmp	DWORD PTR _pDestCity$[ebp], 0
	jne	SHORT $LN37@CanCreateT

; 104  : 	{
; 105  : 		return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN37@CanCreateT:

; 106  : 	}
; 107  : 
; 108  : 	// A city may not trade with itself
; 109  : 	if (pOriginCity == pDestCity)

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	cmp	eax, DWORD PTR _pDestCity$[ebp]
	jne	SHORT $LN36@CanCreateT

; 110  : 	{
; 111  : 		return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN36@CanCreateT:

; 112  : 	}
; 113  : 
; 114  : 	TeamTypes eOriginTeam = pOriginCity->getTeam();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	DWORD PTR _eOriginTeam$[ebp], eax

; 115  : 	TeamTypes eDestTeam = pDestCity->getTeam();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	DWORD PTR _eDestTeam$[ebp], eax

; 116  : 
; 117  : 	if (eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	cmp	DWORD PTR _eConnectionType$[ebp], 0
	jne	SHORT $LN35@CanCreateT

; 118  : 	{
; 119  : 		// can't have an international trade route within the same team
; 120  : 		if (eOriginTeam == eDestTeam)

	mov	ecx, DWORD PTR _eOriginTeam$[ebp]
	cmp	ecx, DWORD PTR _eDestTeam$[ebp]
	jne	SHORT $LN34@CanCreateT

; 121  : 		{
; 122  : 			return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN34@CanCreateT:

; 123  : 		}
; 124  : 	}

	jmp	$LN33@CanCreateT
$LN35@CanCreateT:

; 125  : 	else if (eConnectionType == TRADE_CONNECTION_PRODUCTION || eConnectionType == TRADE_CONNECTION_FOOD)

	cmp	DWORD PTR _eConnectionType$[ebp], 2
	je	SHORT $LN31@CanCreateT
	cmp	DWORD PTR _eConnectionType$[ebp], 1
	jne	$LN33@CanCreateT
$LN31@CanCreateT:

; 126  : 	{
; 127  : 		// can't have production or food connections internationally
; 128  : 		if (eOriginTeam != eDestTeam)

	mov	edx, DWORD PTR _eOriginTeam$[ebp]
	cmp	edx, DWORD PTR _eDestTeam$[ebp]
	je	SHORT $LN30@CanCreateT

; 129  : 		{
; 130  : 			return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN30@CanCreateT:

; 131  : 		}
; 132  : 
; 133  : 		if (eConnectionType == TRADE_CONNECTION_FOOD)

	cmp	DWORD PTR _eConnectionType$[ebp], 1
	jne	$LN29@CanCreateT

; 134  : 		{
; 135  : 			bool bAllowsFoodConnection = false;

	mov	BYTE PTR _bAllowsFoodConnection$219205[ebp], 0

; 136  : #ifdef AUI_WARNING_FIXES
; 137  : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 138  : #else
; 139  : 			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$219206[ebp], 0
	jmp	SHORT $LN28@CanCreateT
$LN27@CanCreateT:
	mov	eax, DWORD PTR _iI$219206[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$219206[ebp], eax
$LN28@CanCreateT:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$219206[ebp], eax
	jge	$LN26@CanCreateT

; 140  : #endif
; 141  : 			{
; 142  : 				BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T227629[ebp], edx
	mov	eax, DWORD PTR $T227629[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227633[ebp], eax
	mov	ecx, DWORD PTR _iI$219206[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227633[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$219210[ebp], eax

; 143  : 				if(eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$219210[ebp], -1
	je	SHORT $LN25@CanCreateT

; 144  : 				{
; 145  : 					CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	mov	edx, DWORD PTR _eBuilding$219210[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pBuildingEntry$219213[ebp], eax

; 146  : #ifndef AUI_WARNING_FIXES
; 147  : 					if (!pBuildingEntry)

	cmp	DWORD PTR _pBuildingEntry$219213[ebp], 0
	jne	SHORT $LN24@CanCreateT

; 148  : 					{
; 149  : 						continue;

	jmp	SHORT $LN27@CanCreateT
$LN24@CanCreateT:

; 150  : 					}
; 151  : #endif
; 152  : 
; 153  : 					if (pBuildingEntry && pBuildingEntry->AllowsFoodTradeRoutes())

	cmp	DWORD PTR _pBuildingEntry$219213[ebp], 0
	je	SHORT $LN25@CanCreateT
	mov	ecx, DWORD PTR _pBuildingEntry$219213[ebp]
	call	?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::AllowsFoodTradeRoutes
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN25@CanCreateT

; 154  : 					{
; 155  : 						if (pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()) > 0)

	mov	ecx, DWORD PTR _pBuildingEntry$219213[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T227637[ebp], edx
	mov	eax, DWORD PTR $T227637[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN25@CanCreateT

; 156  : 						{
; 157  : 							bAllowsFoodConnection = true;

	mov	BYTE PTR _bAllowsFoodConnection$219205[ebp], 1
$LN25@CanCreateT:

; 158  : 						}
; 159  : 					}
; 160  : 				}
; 161  : 			}

	jmp	$LN27@CanCreateT
$LN26@CanCreateT:

; 162  : 
; 163  : 			if (!bAllowsFoodConnection)

	movzx	ecx, BYTE PTR _bAllowsFoodConnection$219205[ebp]
	test	ecx, ecx
	jne	SHORT $LN21@CanCreateT

; 164  : 			{
; 165  : 				return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN21@CanCreateT:

; 166  : 			}
; 167  : 		}

	jmp	$LN33@CanCreateT
$LN29@CanCreateT:

; 168  : 		else if (eConnectionType == TRADE_CONNECTION_PRODUCTION)

	cmp	DWORD PTR _eConnectionType$[ebp], 2
	jne	$LN33@CanCreateT

; 169  : 		{
; 170  : 			bool bAllowsProductionConnection = false;

	mov	BYTE PTR _bAllowsProductionConnection$219221[ebp], 0

; 171  : #ifdef AUI_WARNING_FIXES
; 172  : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 173  : #else
; 174  : 			for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$219222[ebp], 0
	jmp	SHORT $LN18@CanCreateT
$LN17@CanCreateT:
	mov	edx, DWORD PTR _iI$219222[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$219222[ebp], edx
$LN18@CanCreateT:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$219222[ebp], eax
	jge	$LN16@CanCreateT

; 175  : #endif
; 176  : 			{
; 177  : 				BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T227646[ebp], ecx
	mov	edx, DWORD PTR $T227646[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227650[ebp], edx
	mov	eax, DWORD PTR _iI$219222[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227650[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$219226[ebp], eax

; 178  : 				if(eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$219226[ebp], -1
	je	SHORT $LN15@CanCreateT

; 179  : 				{
; 180  : 					CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$219226[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pBuildingEntry$219229[ebp], eax

; 181  : #ifndef AUI_WARNING_FIXES
; 182  : 					if (!pBuildingEntry)

	cmp	DWORD PTR _pBuildingEntry$219229[ebp], 0
	jne	SHORT $LN14@CanCreateT

; 183  : 					{
; 184  : 						continue;

	jmp	SHORT $LN17@CanCreateT
$LN14@CanCreateT:

; 185  : 					}
; 186  : #endif
; 187  : 
; 188  : 					if (pBuildingEntry && pBuildingEntry->AllowsProductionTradeRoutes())

	cmp	DWORD PTR _pBuildingEntry$219229[ebp], 0
	je	SHORT $LN15@CanCreateT
	mov	ecx, DWORD PTR _pBuildingEntry$219229[ebp]
	call	?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::AllowsProductionTradeRoutes
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@CanCreateT

; 189  : 					{
; 190  : 						if (pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()) > 0)

	mov	eax, DWORD PTR _pBuildingEntry$219229[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227654[ebp], ecx
	mov	edx, DWORD PTR $T227654[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN15@CanCreateT

; 191  : 						{
; 192  : 							bAllowsProductionConnection = true;

	mov	BYTE PTR _bAllowsProductionConnection$219221[ebp], 1
$LN15@CanCreateT:

; 193  : 						}
; 194  : 					}
; 195  : 				}
; 196  : 			}

	jmp	$LN17@CanCreateT
$LN16@CanCreateT:

; 197  : 
; 198  : 			if (!bAllowsProductionConnection)

	movzx	eax, BYTE PTR _bAllowsProductionConnection$219221[ebp]
	test	eax, eax
	jne	SHORT $LN33@CanCreateT

; 199  : 			{
; 200  : 				return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN33@CanCreateT:

; 201  : 			}
; 202  : 		}
; 203  : 	}
; 204  : 
; 205  : 	// teams at war can't fight
; 206  : 	if (GET_TEAM(eOriginTeam).isAtWar(eDestTeam))

	mov	ecx, DWORD PTR _eOriginTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227658[ebp], ecx
	mov	edx, DWORD PTR _eDestTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227658[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@CanCreateT

; 207  : 	{
; 208  : 		return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN10@CanCreateT:

; 209  : 	}
; 210  : 
; 211  : 	// teams that have not met cannot trade
; 212  : 	if (!GET_TEAM(eOriginTeam).isHasMet(eDestTeam))

	mov	ecx, DWORD PTR _eOriginTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227662[ebp], ecx
	mov	edx, DWORD PTR _eDestTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227662[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@CanCreateT

; 213  : 	{
; 214  : 		return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN9@CanCreateT:

; 215  : 	}
; 216  : 
; 217  : 	if (pOriginCity->IsRazing() || pDestCity->IsRazing())

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?IsRazing@CvCity@@QBE_NXZ		; CvCity::IsRazing
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@CanCreateT
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?IsRazing@CvCity@@QBE_NXZ		; CvCity::IsRazing
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@CanCreateT
$LN7@CanCreateT:

; 218  : 	{
; 219  : 		return false;

	xor	al, al
	jmp	$LN39@CanCreateT
$LN8@CanCreateT:

; 220  : 	}
; 221  : 
; 222  : 	if (!bIgnoreExisting)

	movzx	eax, BYTE PTR _bIgnoreExisting$[ebp]
	test	eax, eax
	jne	$LN6@CanCreateT

; 223  : 	{
; 224  : 		int iOriginX = pOriginCity->getX();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _iOriginX$219240[ebp], edx

; 225  : 		int iOriginY = pOriginCity->getY();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iOriginY$219241[ebp], ecx

; 226  : 		int iDestX = pDestCity->getX();

	mov	edx, DWORD PTR _pDestCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iDestX$219242[ebp], eax

; 227  : 		int iDestY = pDestCity->getY();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iDestY$219243[ebp], edx

; 228  : 
; 229  : 		// check for duplicate routes
; 230  : 		for (uint i = 0; i < m_aTradeConnections.size(); i++)

	mov	DWORD PTR _i$219244[ebp], 0
	jmp	SHORT $LN5@CanCreateT
$LN4@CanCreateT:
	mov	eax, DWORD PTR _i$219244[ebp]
	add	eax, 1
	mov	DWORD PTR _i$219244[ebp], eax
$LN5@CanCreateT:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T227698[ebp], edx
	mov	eax, DWORD PTR _i$219244[ebp]
	cmp	eax, DWORD PTR $T227698[ebp]
	jae	SHORT $LN6@CanCreateT

; 231  : 		{
; 232  : 			if (m_aTradeConnections[i].m_iOriginX == iOriginX && m_aTradeConnections[i].m_iOriginY == iOriginY && m_aTradeConnections[i].m_iDestX == iDestX && m_aTradeConnections[i].m_iDestY == iDestY)

	mov	ecx, DWORD PTR _i$219244[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+4]
	cmp	ecx, DWORD PTR _iOriginX$219240[ebp]
	jne	SHORT $LN2@CanCreateT
	mov	edx, DWORD PTR _i$219244[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+8]
	cmp	edx, DWORD PTR _iOriginY$219241[ebp]
	jne	SHORT $LN2@CanCreateT
	mov	eax, DWORD PTR _i$219244[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+12]
	cmp	eax, DWORD PTR _iDestX$219242[ebp]
	jne	SHORT $LN2@CanCreateT
	mov	ecx, DWORD PTR _i$219244[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+16]
	cmp	ecx, DWORD PTR _iDestY$219243[ebp]
	jne	SHORT $LN2@CanCreateT

; 233  : 			{
; 234  : 				return false;

	xor	al, al
	jmp	SHORT $LN39@CanCreateT
$LN2@CanCreateT:

; 235  : 			}
; 236  : 		}

	jmp	SHORT $LN4@CanCreateT
$LN6@CanCreateT:

; 237  : 	}
; 238  : 
; 239  : 	if (bCheckPath && !IsValidTradeRoutePath(pOriginCity, pDestCity, eDomain))

	movzx	edx, BYTE PTR _bCheckPath$[ebp]
	test	edx, edx
	je	SHORT $LN1@CanCreateT
	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOriginCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@CanCreateT

; 240  : 	{
; 241  : 		return false;

	xor	al, al
	jmp	SHORT $LN39@CanCreateT
$LN1@CanCreateT:

; 242  : 	}
; 243  : 
; 244  : 	return true;

	mov	al, 1
$LN39@CanCreateT:

; 245  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ENDP ; CvGameTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z ; CvGameTrade::CanCreateTradeRoute
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
; Function compile flags: /Odtp
;	COMDAT ?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T227732 = -52						; size = 4
$T227728 = -48						; size = 4
$T227724 = -44						; size = 4
$T227720 = -40						; size = 4
$T227716 = -36						; size = 4
_uiConnectionTypes$219275 = -32				; size = 4
_eDomain$219271 = -28					; size = 4
_uiDomain$219267 = -24					; size = 4
_iDestCityLoop$219262 = -20				; size = 4
_pDestLoopCity$219263 = -16				; size = 4
_pGameTrade$ = -12					; size = 4
_iOriginCityLoop$ = -8					; size = 4
_pOriginLoopCity$ = -4					; size = 4
_eOriginPlayer$ = 8					; size = 4
_eDestPlayer$ = 12					; size = 4
_eDomainRestriction$ = 16				; size = 4
?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z PROC ; CvGameTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 253  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 254  : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227716[ebp], eax
	mov	ecx, DWORD PTR $T227716[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pGameTrade$[ebp], eax

; 255  : 
; 256  : 	int iOriginCityLoop;
; 257  : 	CvCity* pOriginLoopCity = NULL;

	mov	DWORD PTR _pOriginLoopCity$[ebp], 0

; 258  : 	for(pOriginLoopCity = GET_PLAYER(eOriginPlayer).firstCity(&iOriginCityLoop); pOriginLoopCity != NULL; pOriginLoopCity = GET_PLAYER(eOriginPlayer).nextCity(&iOriginCityLoop))

	mov	ecx, DWORD PTR _eOriginPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227720[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iOriginCityLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227720[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pOriginLoopCity$[ebp], eax
	jmp	SHORT $LN16@CanCreateT@2
$LN15@CanCreateT@2:
	mov	eax, DWORD PTR _eOriginPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227724[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iOriginCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227724[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pOriginLoopCity$[ebp], eax
$LN16@CanCreateT@2:
	cmp	DWORD PTR _pOriginLoopCity$[ebp], 0
	je	$LN14@CanCreateT@2

; 259  : 	{
; 260  : 		int iDestCityLoop;
; 261  : 		CvCity* pDestLoopCity = NULL;

	mov	DWORD PTR _pDestLoopCity$219263[ebp], 0

; 262  : 		for(pDestLoopCity = GET_PLAYER(eDestPlayer).firstCity(&iDestCityLoop); pDestLoopCity != NULL; pDestLoopCity = GET_PLAYER(eDestPlayer).nextCity(&iDestCityLoop))

	mov	edx, DWORD PTR _eDestPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227728[ebp], edx
	push	0
	lea	eax, DWORD PTR _iDestCityLoop$219262[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227728[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pDestLoopCity$219263[ebp], eax
	jmp	SHORT $LN13@CanCreateT@2
$LN12@CanCreateT@2:
	mov	ecx, DWORD PTR _eDestPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227732[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iDestCityLoop$219262[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227732[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pDestLoopCity$219263[ebp], eax
$LN13@CanCreateT@2:
	cmp	DWORD PTR _pDestLoopCity$219263[ebp], 0
	je	$LN11@CanCreateT@2

; 263  : 		{
; 264  : 			for (uint uiDomain = 0; uiDomain < NUM_DOMAIN_TYPES; uiDomain++)

	mov	DWORD PTR _uiDomain$219267[ebp], 0
	jmp	SHORT $LN10@CanCreateT@2
$LN9@CanCreateT@2:
	mov	eax, DWORD PTR _uiDomain$219267[ebp]
	add	eax, 1
	mov	DWORD PTR _uiDomain$219267[ebp], eax
$LN10@CanCreateT@2:
	cmp	DWORD PTR _uiDomain$219267[ebp], 5
	jae	$LN8@CanCreateT@2

; 265  : 			{
; 266  : 				DomainTypes eDomain = (DomainTypes)uiDomain;

	mov	ecx, DWORD PTR _uiDomain$219267[ebp]
	mov	DWORD PTR _eDomain$219271[ebp], ecx

; 267  : 				// check only the domain we want
; 268  : 				if (eDomainRestriction != NO_DOMAIN && eDomainRestriction != eDomain)

	cmp	DWORD PTR _eDomainRestriction$[ebp], -1
	je	SHORT $LN7@CanCreateT@2
	mov	edx, DWORD PTR _eDomainRestriction$[ebp]
	cmp	edx, DWORD PTR _eDomain$219271[ebp]
	je	SHORT $LN7@CanCreateT@2

; 269  : 				{
; 270  : 					continue;

	jmp	SHORT $LN9@CanCreateT@2
$LN7@CanCreateT@2:

; 271  : 				}
; 272  : 
; 273  : 				if (eDomain != DOMAIN_LAND && eDomain != DOMAIN_SEA)

	cmp	DWORD PTR _eDomain$219271[ebp], 2
	je	SHORT $LN6@CanCreateT@2
	cmp	DWORD PTR _eDomain$219271[ebp], 0
	je	SHORT $LN6@CanCreateT@2

; 274  : 				{
; 275  : 					continue;

	jmp	SHORT $LN9@CanCreateT@2
$LN6@CanCreateT@2:

; 276  : 				}
; 277  : 
; 278  : 				for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	mov	DWORD PTR _uiConnectionTypes$219275[ebp], 0
	jmp	SHORT $LN5@CanCreateT@2
$LN4@CanCreateT@2:
	mov	eax, DWORD PTR _uiConnectionTypes$219275[ebp]
	add	eax, 1
	mov	DWORD PTR _uiConnectionTypes$219275[ebp], eax
$LN5@CanCreateT@2:
	cmp	DWORD PTR _uiConnectionTypes$219275[ebp], 3
	jae	SHORT $LN3@CanCreateT@2

; 279  : 				{
; 280  : 					// Check the route, but not the path
; 281  : 					if (CanCreateTradeRoute(pOriginLoopCity, pDestLoopCity, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	push	0
	push	0
	mov	ecx, DWORD PTR _uiConnectionTypes$219275[ebp]
	push	ecx
	mov	edx, DWORD PTR _eDomain$219271[ebp]
	push	edx
	mov	eax, DWORD PTR _pDestLoopCity$219263[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOriginLoopCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@CanCreateT@2

; 282  : 					{
; 283  : 						// Check the path
; 284  : 						if (pGameTrade->IsValidTradeRoutePath(pOriginLoopCity, pDestLoopCity, eDomain))

	mov	eax, DWORD PTR _eDomain$219271[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestLoopCity$219263[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOriginLoopCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGameTrade$[ebp]
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@CanCreateT@2

; 285  : 							return true;

	mov	al, 1
	jmp	SHORT $LN17@CanCreateT@2
$LN1@CanCreateT@2:

; 286  : 
; 287  : 						// else we can just break out of the loop
; 288  : 						break;

	jmp	SHORT $LN3@CanCreateT@2
$LN2@CanCreateT@2:

; 289  : 					}
; 290  : 				}

	jmp	SHORT $LN4@CanCreateT@2
$LN3@CanCreateT@2:

; 291  : 			}

	jmp	$LN9@CanCreateT@2
$LN8@CanCreateT@2:

; 292  : 		}

	jmp	$LN12@CanCreateT@2
$LN11@CanCreateT@2:

; 293  : 	}

	jmp	$LN15@CanCreateT@2
$LN14@CanCreateT@2:

; 294  : 
; 295  : 	return false;

	xor	al, al
$LN17@CanCreateT@2:

; 296  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CanCreateTradeRoute@CvGameTrade@@QAE_NW4PlayerTypes@@0W4DomainTypes@@@Z ENDP ; CvGameTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??1TradeConnection@@QAE@XZ			; TradeConnection::~TradeConnection
PUBLIC	?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z	; CvGameTrade::LogTradeMsg
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0CI@NLNJLGKJ@?$CFs?0?5New?5Trade?5Route?0?5?$CFs?0?5?$CFs?0?5?$CFs?0@ ; `string'
PUBLIC	??_C@_0O@PDFDEAEC@international?$AA@		; `string'
PUBLIC	??_C@_0L@INCEBPLL@production?$AA@		; `string'
PUBLIC	??_C@_04OPAEPOE@food?$AA@			; `string'
PUBLIC	??_C@_03JFMLHMLM@sea?$AA@			; `string'
PUBLIC	??_C@_04KFFNEKEB@land?$AA@			; `string'
PUBLIC	?MoveUnit@CvGameTrade@@QAE_NH@Z			; CvGameTrade::MoveUnit
PUBLIC	?CreateVis@CvGameTrade@@QAEXH@Z			; CvGameTrade::CreateVis
PUBLIC	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues
PUBLIC	?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z ; CvPlayerTrade::GetTradeRouteSpeed
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection
PUBLIC	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
PUBLIC	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back
PUBLIC	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
PUBLIC	?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ	; CvGameTrade::GetEmptyTradeRouteIndex
PUBLIC	__$ArrayPad$
PUBLIC	?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z ; CvGameTrade::CreateTradeRoute
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
EXTRN	?UpdateNumTradeRouteConnections@CvCityReligions@@QAEXPAVCvCity@@@Z:PROC ; CvCityReligions::UpdateNumTradeRouteConnections
EXTRN	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ:PROC ; CvCity::GetCityReligions
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getCulturePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
EXTRN	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteLandFinder
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteWaterFinder
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
;	COMDAT ??_C@_0CI@NLNJLGKJ@?$CFs?0?5New?5Trade?5Route?0?5?$CFs?0?5?$CFs?0?5?$CFs?0@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CI@NLNJLGKJ@?$CFs?0?5New?5Trade?5Route?0?5?$CFs?0?5?$CFs?0?5?$CFs?0@ DB '%'
	DB	's, New Trade Route, %s, %s, %s, %i, %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDFDEAEC@international?$AA@
CONST	SEGMENT
??_C@_0O@PDFDEAEC@international?$AA@ DB 'international', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INCEBPLL@production?$AA@
CONST	SEGMENT
??_C@_0L@INCEBPLL@production?$AA@ DB 'production', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPAEPOE@food?$AA@
CONST	SEGMENT
??_C@_04OPAEPOE@food?$AA@ DB 'food', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFMLHMLM@sea?$AA@
CONST	SEGMENT
??_C@_03JFMLHMLM@sea?$AA@ DB 'sea', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KFFNEKEB@land?$AA@
CONST	SEGMENT
??_C@_04KFFNEKEB@land?$AA@ DB 'land', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
_TEXT	SEGMENT
tv574 = -884						; size = 4
tv735 = -880						; size = 4
tv572 = -876						; size = 4
tv798 = -872						; size = 4
tv489 = -868						; size = 4
tv479 = -864						; size = 4
tv385 = -860						; size = 4
tv712 = -856						; size = 4
_this$ = -852						; size = 4
$T228133 = -848						; size = 4
$T228129 = -844						; size = 4
$T228120 = -840						; size = 4
$T228116 = -836						; size = 4
$T228075 = -832						; size = 4
$T228071 = -828						; size = 4
$T228067 = -824						; size = 4
$T228063 = -820						; size = 4
$T228051 = -816						; size = 4
$T228044 = -812						; size = 4
$T228040 = -808						; size = 4
$T228036 = -804						; size = 4
$T228032 = -800						; size = 4
$T228028 = -796						; size = 4
$T228013 = -792						; size = 4
$T228012 = -788						; size = 4
$T228011 = -784						; size = 4
$T227980 = -780						; size = 4
$T227975 = -776						; size = 4
$T227971 = -769						; size = 1
$T227960 = -768						; size = 4
$T227956 = -761						; size = 1
_iMapY$228010 = -760					; size = 4
_iMapX$228009 = -756					; size = 4
$T227949 = -752						; size = 4
$T227945 = -748						; size = 4
$T227941 = -744						; size = 4
$T227937 = -740						; size = 4
$T227933 = -736						; size = 4
$T227929 = -732						; size = 4
$T227925 = -728						; size = 4
$T227913 = -724						; size = 4
$T227894 = -720						; size = 4
$T227882 = -716						; size = 4
$T227870 = -712						; size = 4
$T227858 = -708						; size = 4
$T227846 = -704						; size = 4
$T227834 = -700						; size = 4
$T227818 = -696						; size = 4
$T227801 = -684						; size = 4
$T227797 = -680						; size = 4
$T227739 = -676						; size = 28
$T227738 = -648						; size = 28
$T227737 = -620						; size = 4
$T227736 = -616						; size = 4
_strTRType$219333 = -612				; size = 28
_strMsg$219323 = -584					; size = 28
_strDomain$219324 = -556				; size = 28
_ui$219309 = -528					; size = 4
_kNewTradeConnection$219307 = -524			; size = 444
__$ArrayPad$ = -72					; size = 4
_iRouteSpeed$ = -68					; size = 4
_iTargetTurns$ = -64					; size = 4
_iDestX$ = -60						; size = 4
_iOriginY$ = -56					; size = 4
_iCircuitsToComplete$ = -52				; size = 4
_iOriginX$ = -48					; size = 4
_iNewTradeRouteIndex$ = -44				; size = 4
_iDestY$ = -40						; size = 4
_eOriginTeam$ = -36					; size = 4
_bSuccess$ = -29					; size = 1
_eOriginPlayer$ = -28					; size = 4
_pPathfinderNode$ = -24					; size = 4
_eDestPlayer$ = -20					; size = 4
_iTurnsPerCircuit$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
_iRouteID$ = 24						; size = 4
?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z PROC ; CvGameTrade::CreateTradeRoute, COMDAT
; _this$ = ecx

; 300  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 872				; 00000368H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 	iRouteID = -1;

	mov	eax, DWORD PTR _iRouteID$[ebp]
	mov	DWORD PTR [eax], -1

; 302  : 
; 303  : 	if (!CanCreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnectionType, false))

	push	1
	push	0
	mov	ecx, DWORD PTR _eConnectionType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDestCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN35@CreateTrad

; 304  : 	{
; 305  : 		return false;

	xor	al, al
	jmp	$LN25@CreateTrad

; 306  : 	}
; 307  : 
; 308  : 	PlayerTypes eOriginPlayer = pOriginCity->getOwner();

$LN35@CreateTrad:
	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _eOriginPlayer$[ebp], ecx

; 309  : 	PlayerTypes eDestPlayer = pDestCity->getOwner();

	mov	edx, DWORD PTR _pDestCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR _eDestPlayer$[ebp], eax

; 310  : 
; 311  : 	int iOriginX = pOriginCity->getX();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _iOriginX$[ebp], edx

; 312  : 	int iOriginY = pOriginCity->getY();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iOriginY$[ebp], ecx

; 313  : 	int iDestX = pDestCity->getX();

	mov	edx, DWORD PTR _pDestCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iDestX$[ebp], eax

; 314  : 	int iDestY = pDestCity->getY();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iDestY$[ebp], edx

; 315  : 
; 316  : 	bool bSuccess = false;

	mov	BYTE PTR _bSuccess$[ebp], 0

; 317  : 	CvAStarNode* pPathfinderNode = NULL;

	mov	DWORD PTR _pPathfinderNode$[ebp], 0

; 318  : 	if (eDomain == DOMAIN_SEA)

	cmp	DWORD PTR _eDomain$[ebp], 0
	jne	SHORT $LN23@CreateTrad

; 319  : 	{
; 320  : 		if (pOriginCity->isCoastal(0) && pDestCity->isCoastal(0))	// Both must be on the coast (a lake is ok)  A better check would be to see if they are adjacent to the same water body.

	push	0
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@CreateTrad
	push	0
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@CreateTrad

; 321  : 		{
; 322  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 323  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 324  : #else
; 325  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	0
	mov	edx, DWORD PTR _eOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDestY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDestX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iOriginY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iOriginX$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bSuccess$[ebp], al

; 326  : #endif
; 327  : 			pPathfinderNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	DWORD PTR $T227797[ebp], eax
	mov	ecx, DWORD PTR $T227797[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], edx
$LN22@CreateTrad:

; 328  : 		}
; 329  : 	}

	jmp	SHORT $LN21@CreateTrad
$LN23@CreateTrad:

; 330  : 	else if (eDomain == DOMAIN_LAND)

	cmp	DWORD PTR _eDomain$[ebp], 2
	jne	SHORT $LN21@CreateTrad

; 331  : 	{
; 332  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 333  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 334  : #else
; 335  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	0
	mov	eax, DWORD PTR _eOriginPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDestY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDestX$[ebp]
	push	edx
	mov	eax, DWORD PTR _iOriginY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iOriginX$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bSuccess$[ebp], al

; 336  : #endif
; 337  : 		pPathfinderNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	DWORD PTR $T227801[ebp], eax
	mov	edx, DWORD PTR $T227801[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], eax
$LN21@CreateTrad:

; 338  : 	}
; 339  : 
; 340  : 	if (!bSuccess)

	movzx	ecx, BYTE PTR _bSuccess$[ebp]
	test	ecx, ecx
	jne	SHORT $LN19@CreateTrad

; 341  : 	{
; 342  : 		return false;

	xor	al, al
	jmp	$LN25@CreateTrad
$LN19@CreateTrad:

; 343  : 	}
; 344  : 
; 345  : 	CvAssertMsg(pPathfinderNode, "pPathfinderNode is null. Whaa?");
; 346  : 	if (pPathfinderNode == NULL)

	cmp	DWORD PTR _pPathfinderNode$[ebp], 0
	jne	SHORT $LN18@CreateTrad

; 347  : 	{
; 348  : 		return false;

	xor	al, al
	jmp	$LN25@CreateTrad
$LN18@CreateTrad:

; 349  : 	}
; 350  : 
; 351  : 	int iNewTradeRouteIndex = GetEmptyTradeRouteIndex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ ; CvGameTrade::GetEmptyTradeRouteIndex
	mov	DWORD PTR _iNewTradeRouteIndex$[ebp], eax

; 352  : 	CvAssertMsg(iNewTradeRouteIndex < (int)m_aTradeConnections.size(), "iNewTradeRouteIndex out of bounds");
; 353  : 
; 354  : 	// couldn't find valid connection, bail out
; 355  : 	if (iNewTradeRouteIndex < 0)

	cmp	DWORD PTR _iNewTradeRouteIndex$[ebp], 0
	jge	SHORT $LN17@CreateTrad

; 356  : 	{
; 357  : 		TradeConnection kNewTradeConnection;

	lea	ecx, DWORD PTR _kNewTradeConnection$219307[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 358  : 		m_aTradeConnections.push_back(kNewTradeConnection);

	lea	edx, DWORD PTR _kNewTradeConnection$219307[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 359  : 		iNewTradeRouteIndex = m_aTradeConnections.size() - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227818[ebp], ecx
	mov	edx, DWORD PTR $T227818[ebp]
	sub	edx, 1
	mov	DWORD PTR _iNewTradeRouteIndex$[ebp], edx

; 360  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kNewTradeConnection$219307[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
$LN17@CreateTrad:

; 361  : 
; 362  : 	iRouteID = m_iNextID;

	mov	eax, DWORD PTR _iRouteID$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	mov	DWORD PTR [eax], edx

; 363  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iID = m_iNextID;

	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+74608]
	mov	DWORD PTR [eax+edx], ecx

; 364  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iOriginX = pOriginCity->getX();

	mov	edx, DWORD PTR _pOriginCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T227834[ebp], eax
	mov	ecx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR $T227834[ebp]
	mov	DWORD PTR [eax+ecx+4], edx

; 365  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iOriginY = pOriginCity->getY();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T227846[ebp], ecx
	mov	edx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T227846[ebp]
	mov	DWORD PTR [ecx+edx+8], eax

; 366  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eOriginOwner = pOriginCity->getOwner();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T227858[ebp], edx
	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T227858[ebp]
	mov	DWORD PTR [edx+eax+20], ecx

; 367  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iDestX = pDestCity->getX();

	mov	edx, DWORD PTR _pDestCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T227870[ebp], eax
	mov	ecx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR $T227870[ebp]
	mov	DWORD PTR [eax+ecx+12], edx

; 368  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iDestY = pDestCity->getY();

	mov	eax, DWORD PTR _pDestCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T227882[ebp], ecx
	mov	edx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T227882[ebp]
	mov	DWORD PTR [ecx+edx+16], eax

; 369  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eDestOwner = pDestCity->getOwner();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T227894[ebp], edx
	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T227894[ebp]
	mov	DWORD PTR [edx+eax+24], ecx

; 370  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eDomain = eDomain;

	mov	edx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _eDomain$[ebp]
	mov	DWORD PTR [ecx+edx+28], eax

; 371  : 	m_aTradeConnections[iNewTradeRouteIndex].m_eConnectionType = eConnectionType;

	mov	ecx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _eConnectionType$[ebp]
	mov	DWORD PTR [eax+ecx+32], edx

; 372  : 	m_aTradeConnections[iNewTradeRouteIndex].m_unitID = -1;

	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+380], -1

; 373  : 
; 374  : 	// increment m_iNextID for the next connection
; 375  : 	m_iNextID += 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+74608], ecx

; 376  : 
; 377  : 	CopyPathIntoTradeConnection(pPathfinderNode, &(m_aTradeConnections[iNewTradeRouteIndex]));

	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR _pPathfinderNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection

; 378  : 
; 379  : 	// reveal all plots to the player who created the trade route
; 380  : 	TeamTypes eOriginTeam = GET_PLAYER(eOriginPlayer).getTeam();

	mov	eax, DWORD PTR _eOriginPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227913[ebp], eax
	mov	ecx, DWORD PTR $T227913[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOriginTeam$[ebp], eax

; 381  : #ifdef AUI_ITERATORIZE
; 382  : 	for (TradeConnectionPlotList::const_iterator it = m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.begin(); it != m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.end(); ++it)
; 383  : 	{
; 384  : 		GC.getMap().plot(it->m_iX, it->m_iY)->setRevealed(eOriginTeam, true, true);
; 385  : #else
; 386  : 	for (uint ui = 0; ui < m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.size(); ui++)

	mov	DWORD PTR _ui$219309[ebp], 0
	jmp	SHORT $LN16@CreateTrad
$LN15@CreateTrad:
	mov	eax, DWORD PTR _ui$219309[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219309[ebp], eax
$LN16@CreateTrad:
	mov	ecx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T227925[ebp], ecx
	mov	eax, DWORD PTR $T227925[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T227929[ebp], ecx
	mov	edx, DWORD PTR _ui$219309[ebp]
	cmp	edx, DWORD PTR $T227929[ebp]
	jae	$LN167@CreateTrad

; 387  : 	{
; 388  : 		GC.getMap().plot(m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList[ui].m_iX, m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList[ui].m_iY)->setRevealed(eOriginTeam, true, true);

	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T227933[ebp], eax
	mov	edx, DWORD PTR $T227933[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _ui$219309[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T227937[ebp], edx
	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T227941[ebp], eax
	mov	edx, DWORD PTR $T227941[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _ui$219309[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T227945[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227949[ebp], eax
	mov	ecx, DWORD PTR $T227937[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228012[ebp], edx
	mov	eax, DWORD PTR $T227945[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T228011[ebp], ecx
	cmp	DWORD PTR $T228011[ebp], -2147483647	; 80000001H
	je	SHORT $LN143@CreateTrad
	cmp	DWORD PTR $T228012[ebp], -2147483647	; 80000001H
	jne	SHORT $LN144@CreateTrad
$LN143@CreateTrad:
	mov	DWORD PTR $T228013[ebp], 0
	jmp	$LN145@CreateTrad
$LN144@CreateTrad:
	mov	edx, DWORD PTR $T227949[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T227956[ebp], al
	mov	ecx, DWORD PTR $T227949[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T227960[ebp], edx
	movzx	eax, BYTE PTR $T227956[ebp]
	test	eax, eax
	je	SHORT $LN156@CreateTrad
	cmp	DWORD PTR $T228011[ebp], 0
	jge	SHORT $LN155@CreateTrad
	mov	eax, DWORD PTR $T228011[ebp]
	cdq
	idiv	DWORD PTR $T227960[ebp]
	add	edx, DWORD PTR $T227960[ebp]
	mov	DWORD PTR _iMapX$228009[ebp], edx
	jmp	SHORT $LN157@CreateTrad
	jmp	SHORT $LN156@CreateTrad
$LN155@CreateTrad:
	mov	ecx, DWORD PTR $T228011[ebp]
	cmp	ecx, DWORD PTR $T227960[ebp]
	jl	SHORT $LN156@CreateTrad
	mov	eax, DWORD PTR $T228011[ebp]
	cdq
	idiv	DWORD PTR $T227960[ebp]
	mov	DWORD PTR _iMapX$228009[ebp], edx
	jmp	SHORT $LN157@CreateTrad
$LN156@CreateTrad:
	mov	edx, DWORD PTR $T228011[ebp]
	mov	DWORD PTR _iMapX$228009[ebp], edx
$LN157@CreateTrad:
	mov	eax, DWORD PTR $T227949[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T227971[ebp], cl
	mov	edx, DWORD PTR $T227949[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T227975[ebp], eax
	movzx	ecx, BYTE PTR $T227971[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227975[ebp]
	push	edx
	mov	eax, DWORD PTR $T228012[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$228010[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228010[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$228009[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227949[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN147@CreateTrad
	mov	eax, DWORD PTR $T227949[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227980[ebp], ecx
	mov	edx, DWORD PTR _iMapY$228010[ebp]
	imul	edx, DWORD PTR $T227980[ebp]
	add	edx, DWORD PTR _iMapX$228009[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T227949[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv712[ebp], edx
	jmp	SHORT $LN148@CreateTrad
$LN147@CreateTrad:
	mov	DWORD PTR tv712[ebp], 0
$LN148@CreateTrad:
	mov	ecx, DWORD PTR tv712[ebp]
	mov	DWORD PTR $T228013[ebp], ecx
$LN145@CreateTrad:
	push	-1
	push	1
	push	1
	mov	edx, DWORD PTR _eOriginTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T228013[ebp]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed

; 389  : #endif
; 390  : 	}

	jmp	$LN15@CreateTrad

; 391  : 
; 392  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iTradeUnitLocationIndex = 0;

$LN167@CreateTrad:
	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax+36], 0

; 393  : 	m_aTradeConnections[iNewTradeRouteIndex].m_bTradeUnitMovingForward = true;

	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+eax+40], 1

; 394  : 
; 395  : 	int iRouteSpeed = GET_PLAYER(pOriginCity->getOwner()).GetTrade()->GetTradeRouteSpeed(eDomain);

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T228028[ebp], ecx
	mov	edx, DWORD PTR $T228028[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228032[ebp], edx
	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228032[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z ; CvPlayerTrade::GetTradeRouteSpeed
	mov	DWORD PTR _iRouteSpeed$[ebp], eax

; 396  : 	int iTurnsPerCircuit = 1;

	mov	DWORD PTR _iTurnsPerCircuit$[ebp], 1

; 397  : 	if (iRouteSpeed != 0)

	cmp	DWORD PTR _iRouteSpeed$[ebp], 0
	je	SHORT $LN13@CreateTrad

; 398  : 	{
; 399  : 		iTurnsPerCircuit = ((m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.size() - 1) * 2) / iRouteSpeed;

	mov	ecx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T228036[ebp], ecx
	mov	eax, DWORD PTR $T228036[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T228040[ebp], ecx
	mov	edx, DWORD PTR $T228040[ebp]
	lea	eax, DWORD PTR [edx+edx-2]
	xor	edx, edx
	div	DWORD PTR _iRouteSpeed$[ebp]
	mov	DWORD PTR _iTurnsPerCircuit$[ebp], eax
$LN13@CreateTrad:

; 400  : 	}
; 401  : 	
; 402  : 	int iTargetTurns = 30; // how many turns do we want the cycle to consume

	mov	DWORD PTR _iTargetTurns$[ebp], 30	; 0000001eH

; 403  : #ifdef NQ_TRADE_ROUTE_DURATION_SCALES_WITH_GAME_SPEED
; 404  : 	iTargetTurns = iTargetTurns * GC.getGame().getGameSpeedInfo().getCulturePercent() / 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T228044[ebp], eax
	mov	ecx, DWORD PTR $T228044[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getCulturePercent
	imul	eax, DWORD PTR _iTargetTurns$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iTargetTurns$[ebp], eax

; 405  : #endif
; 406  : 	int iCircuitsToComplete = 1; // how many circuits do we want this trade route to run to reach the target turns

	mov	DWORD PTR _iCircuitsToComplete$[ebp], 1

; 407  : 	if (iTurnsPerCircuit != 0)

	cmp	DWORD PTR _iTurnsPerCircuit$[ebp], 0
	je	SHORT $LN187@CreateTrad

; 408  : 	{
; 409  : 		iCircuitsToComplete = max(iTargetTurns / iTurnsPerCircuit, 2);

	mov	DWORD PTR $T227736[ebp], 2
	mov	eax, DWORD PTR _iTargetTurns$[ebp]
	cdq
	idiv	DWORD PTR _iTurnsPerCircuit$[ebp]
	mov	DWORD PTR $T227737[ebp], eax
	mov	edx, DWORD PTR $T227737[ebp]
	cmp	edx, DWORD PTR $T227736[ebp]
	jge	SHORT $LN185@CreateTrad
	lea	eax, DWORD PTR $T227736[ebp]
	mov	DWORD PTR tv385[ebp], eax
	jmp	SHORT $LN186@CreateTrad
$LN185@CreateTrad:
	lea	ecx, DWORD PTR $T227737[ebp]
	mov	DWORD PTR tv385[ebp], ecx
$LN186@CreateTrad:
	mov	edx, DWORD PTR tv385[ebp]
	mov	DWORD PTR $T228051[ebp], edx
	mov	eax, DWORD PTR $T228051[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iCircuitsToComplete$[ebp], ecx

; 410  : 	}
; 411  : 
; 412  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iCircuitsCompleted = 0;

$LN187@CreateTrad:
	mov	edx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx+384], 0

; 413  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iCircuitsToComplete = iCircuitsToComplete;

	mov	edx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _iCircuitsToComplete$[ebp]
	mov	DWORD PTR [ecx+edx+388], eax

; 414  : 	m_aTradeConnections[iNewTradeRouteIndex].m_iTurnRouteComplete = (iTurnsPerCircuit * iCircuitsToComplete) + GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T228063[ebp], ecx
	mov	edx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T228067[ebp], edx
	mov	esi, DWORD PTR _iTurnsPerCircuit$[ebp]
	imul	esi, DWORD PTR _iCircuitsToComplete$[ebp]
	mov	ecx, DWORD PTR $T228063[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	esi, eax
	mov	ecx, DWORD PTR $T228067[ebp]
	mov	DWORD PTR [ecx+392], esi

; 415  : 
; 416  : 	GET_PLAYER(eOriginPlayer).GetTrade()->UpdateTradeConnectionValues();

	mov	edx, DWORD PTR _eOriginPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228071[ebp], edx
	mov	ecx, DWORD PTR $T228071[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 417  : 	if (eDestPlayer != eOriginPlayer)

	mov	eax, DWORD PTR _eDestPlayer$[ebp]
	cmp	eax, DWORD PTR _eOriginPlayer$[ebp]
	je	SHORT $LN11@CreateTrad

; 418  : 	{
; 419  : 		GET_PLAYER(eDestPlayer).GetTrade()->UpdateTradeConnectionValues();

	mov	ecx, DWORD PTR _eDestPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228075[ebp], ecx
	mov	ecx, DWORD PTR $T228075[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues
$LN11@CreateTrad:

; 420  : 	}
; 421  : 
; 422  : 	pOriginCity->GetCityReligions()->UpdateNumTradeRouteConnections(pDestCity);

	mov	edx, DWORD PTR _pDestCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?UpdateNumTradeRouteConnections@CvCityReligions@@QAEXPAVCvCity@@@Z ; CvCityReligions::UpdateNumTradeRouteConnections

; 423  : 	pDestCity->GetCityReligions()->UpdateNumTradeRouteConnections(pOriginCity);

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?UpdateNumTradeRouteConnections@CvCityReligions@@QAEXPAVCvCity@@@Z ; CvCityReligions::UpdateNumTradeRouteConnections

; 424  : 
; 425  : 	CreateVis(iNewTradeRouteIndex);

	mov	ecx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateVis@CvGameTrade@@QAEXH@Z		; CvGameTrade::CreateVis

; 426  : 	MoveUnit(iNewTradeRouteIndex);

	mov	edx, DWORD PTR _iNewTradeRouteIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveUnit@CvGameTrade@@QAE_NH@Z		; CvGameTrade::MoveUnit

; 427  : 
; 428  : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN10@CreateTrad

; 429  : 	{
; 430  : 		CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$219323[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 431  : 		CvString strDomain;

	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 432  : 		switch (eDomain)

	mov	ecx, DWORD PTR _eDomain$[ebp]
	mov	DWORD PTR tv479[ebp], ecx
	cmp	DWORD PTR tv479[ebp], 0
	je	SHORT $LN6@CreateTrad
	cmp	DWORD PTR tv479[ebp], 2
	je	SHORT $LN7@CreateTrad
	jmp	SHORT $LN8@CreateTrad
$LN7@CreateTrad:

; 433  : 		{
; 434  : 		case DOMAIN_LAND:
; 435  : 			strDomain = "land";

	mov	edx, OFFSET ??_C@_04KFFNEKEB@land?$AA@
	test	edx, edx
	je	SHORT $LN206@CreateTrad
	push	OFFSET ??_C@_04KFFNEKEB@land?$AA@
	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN207@CreateTrad
$LN206@CreateTrad:
	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN207@CreateTrad:

; 436  : 			break;

	jmp	SHORT $LN8@CreateTrad
$LN6@CreateTrad:

; 437  : 		case DOMAIN_SEA:
; 438  : 			strDomain = "sea";

	mov	eax, OFFSET ??_C@_03JFMLHMLM@sea?$AA@
	test	eax, eax
	je	SHORT $LN210@CreateTrad
	push	OFFSET ??_C@_03JFMLHMLM@sea?$AA@
	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@CreateTrad
$LN210@CreateTrad:
	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@CreateTrad:

; 439  : 			break;
; 440  : 		}
; 441  : 
; 442  : 		CvString strTRType;

	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 443  : 		switch (eConnectionType)

	mov	ecx, DWORD PTR _eConnectionType$[ebp]
	mov	DWORD PTR tv489[ebp], ecx
	cmp	DWORD PTR tv489[ebp], 0
	je	SHORT $LN1@CreateTrad
	cmp	DWORD PTR tv489[ebp], 1
	je	SHORT $LN3@CreateTrad
	cmp	DWORD PTR tv489[ebp], 2
	je	SHORT $LN2@CreateTrad
	jmp	SHORT $LN4@CreateTrad
$LN3@CreateTrad:

; 444  : 		{
; 445  : 		case TRADE_CONNECTION_FOOD:
; 446  : 			strTRType = "food";

	mov	edx, OFFSET ??_C@_04OPAEPOE@food?$AA@
	test	edx, edx
	je	SHORT $LN217@CreateTrad
	push	OFFSET ??_C@_04OPAEPOE@food?$AA@
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN218@CreateTrad
$LN217@CreateTrad:
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN218@CreateTrad:

; 447  : 			break;

	jmp	SHORT $LN4@CreateTrad
$LN2@CreateTrad:

; 448  : 		case TRADE_CONNECTION_PRODUCTION:
; 449  : 			strTRType = "production";

	mov	eax, OFFSET ??_C@_0L@INCEBPLL@production?$AA@
	test	eax, eax
	je	SHORT $LN221@CreateTrad
	push	OFFSET ??_C@_0L@INCEBPLL@production?$AA@
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN222@CreateTrad
$LN221@CreateTrad:
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN222@CreateTrad:

; 450  : 			break;

	jmp	SHORT $LN4@CreateTrad
$LN1@CreateTrad:

; 451  : 		case TRADE_CONNECTION_INTERNATIONAL:
; 452  : 			strTRType = "international";

	mov	ecx, OFFSET ??_C@_0O@PDFDEAEC@international?$AA@
	test	ecx, ecx
	je	SHORT $LN225@CreateTrad
	push	OFFSET ??_C@_0O@PDFDEAEC@international?$AA@
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN4@CreateTrad
$LN225@CreateTrad:
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN4@CreateTrad:

; 453  : 			break;
; 454  : 		}
; 455  : 
; 456  : 		strMsg.Format("%s, New Trade Route, %s, %s, %s, %i, %s", GET_PLAYER(pOriginCity->getOwner()).getCivilizationShortDescription(), strDomain.c_str(), pOriginCity->getName().c_str(), pDestCity->getName().c_str(), m_aTradeConnections[iNewTradeRouteIndex].m_aPlotList.size(), strTRType.c_str());

	lea	edx, DWORD PTR $T227738[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv798[ebp], eax
	mov	eax, DWORD PTR tv798[ebp]
	mov	DWORD PTR tv572[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T227739[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv735[ebp], eax
	mov	edx, DWORD PTR tv735[ebp]
	mov	DWORD PTR tv574[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR _iNewTradeRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T228116[ebp], eax
	mov	edx, DWORD PTR $T228116[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T228120[ebp], eax
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T228129[ebp], edx
	mov	eax, DWORD PTR $T228129[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228133[ebp], eax
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR $T228120[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv572[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR tv574[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR $T228133[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	push	eax
	push	OFFSET ??_C@_0CI@NLNJLGKJ@?$CFs?0?5New?5Trade?5Route?0?5?$CFs?0?5?$CFs?0?5?$CFs?0@
	lea	edx, DWORD PTR _strMsg$219323[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T227739[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T227738[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 457  : 		LogTradeMsg(strMsg);

	lea	eax, DWORD PTR _strMsg$219323[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z ; CvGameTrade::LogTradeMsg

; 458  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$219323[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@CreateTrad:

; 459  : 
; 460  : 	
; 461  : 
; 462  : 	return true;

	mov	al, 1
$LN25@CreateTrad:

; 463  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$0:
	lea	ecx, DWORD PTR _kNewTradeConnection$219307[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$1:
	lea	ecx, DWORD PTR _strMsg$219323[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$2:
	lea	ecx, DWORD PTR _strDomain$219324[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$3:
	lea	ecx, DWORD PTR _strTRType$219333[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$4:
	lea	ecx, DWORD PTR $T227738[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z$5:
	lea	ecx, DWORD PTR $T227739[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-880]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z ENDP ; CvGameTrade::CreateTradeRoute
; Function compile flags: /Odtp
;	COMDAT ??1TradeConnection@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1TradeConnection@@QAE@XZ PROC				; TradeConnection::~TradeConnection, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1TradeConnection@@QAE@XZ ENDP				; TradeConnection::~TradeConnection
_TEXT	ENDS
PUBLIC	?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z ; CvPlayerTrade::GetTradeRouteRange
; Function compile flags: /Odtp
;	COMDAT ?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T228243 = -48						; size = 4
$T228239 = -44						; size = 4
$T228235 = -40						; size = 4
_iDestX$ = -36						; size = 4
_iOriginY$ = -32					; size = 4
_iRange$ = -28						; size = 4
_iOriginX$ = -24					; size = 4
_iDestY$ = -20						; size = 4
_iPathDistance$ = -16					; size = 4
_bSuccess$ = -9						; size = 1
_eOriginPlayer$ = -8					; size = 4
_pPathfinderNode$ = -4					; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z PROC ; CvGameTrade::IsValidTradeRoutePath, COMDAT
; _this$ = ecx

; 471  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 472  : 	// AI_PERF_FORMAT("Trade-route-perf.csv", ("CvGameTrade::IsValidTradeRoutePath, Turn %03d, %s, %s, %d, %d, %s, %d, %d", GC.getGame().getElapsedGameTurns(), pOriginCity->GetPlayer()->getCivilizationShortDescription(), pOriginCity->getName().c_str(), pOriginCity->getX(), pOriginCity->getY(), pDestCity->getName().c_str(), pDestCity->getX(), pDestCity->getY()) );
; 473  : 
; 474  : 	PlayerTypes eOriginPlayer = pOriginCity->getOwner();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _eOriginPlayer$[ebp], ecx

; 475  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 476  : 	PlayerTypes eDestPlayer = pDestCity->getOwner();
; 477  : #endif
; 478  : 
; 479  : 	int iOriginX = pOriginCity->getX();

	mov	edx, DWORD PTR _pOriginCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iOriginX$[ebp], eax

; 480  : 	int iOriginY = pOriginCity->getY();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iOriginY$[ebp], edx

; 481  : 	int iDestX = pDestCity->getX();

	mov	eax, DWORD PTR _pDestCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iDestX$[ebp], ecx

; 482  : 	int iDestY = pDestCity->getY();

	mov	edx, DWORD PTR _pDestCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iDestY$[ebp], eax

; 483  : 
; 484  : 	bool bSuccess = false;

	mov	BYTE PTR _bSuccess$[ebp], 0

; 485  : 	CvAStarNode* pPathfinderNode = NULL;

	mov	DWORD PTR _pPathfinderNode$[ebp], 0

; 486  : 	if (eDomain == DOMAIN_SEA)

	cmp	DWORD PTR _eDomain$[ebp], 0
	jne	SHORT $LN7@IsValidTra

; 487  : 	{
; 488  : 		if (pOriginCity->isCoastal(0) && pDestCity->isCoastal(0))	// Both must be on the coast (a lake is ok)  A better check would be to see if they are adjacent to the same water body.

	push	0
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@IsValidTra
	push	0
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@IsValidTra

; 489  : 		{
; 490  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 491  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 492  : #else
; 493  : 			bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	0
	mov	eax, DWORD PTR _eOriginPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDestY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDestX$[ebp]
	push	edx
	mov	eax, DWORD PTR _iOriginY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iOriginX$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bSuccess$[ebp], al

; 494  : #endif
; 495  : 			pPathfinderNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	DWORD PTR $T228235[ebp], eax
	mov	edx, DWORD PTR $T228235[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], eax
$LN6@IsValidTra:

; 496  : 		}
; 497  : 	}

	jmp	SHORT $LN5@IsValidTra
$LN7@IsValidTra:

; 498  : 	else if (eDomain == DOMAIN_LAND)

	cmp	DWORD PTR _eDomain$[ebp], 2
	jne	SHORT $LN5@IsValidTra

; 499  : 	{
; 500  : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 501  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 502  : #else
; 503  : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	0
	mov	ecx, DWORD PTR _eOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDestY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDestX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iOriginY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iOriginX$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bSuccess$[ebp], al

; 504  : #endif
; 505  : 		pPathfinderNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	DWORD PTR $T228239[ebp], eax
	mov	eax, DWORD PTR $T228239[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], ecx
$LN5@IsValidTra:

; 506  : 	}
; 507  : 
; 508  : 	if (!bSuccess)

	movzx	edx, BYTE PTR _bSuccess$[ebp]
	test	edx, edx
	jne	SHORT $LN3@IsValidTra

; 509  : 	{
; 510  : 		return false;

	xor	al, al
	jmp	SHORT $LN8@IsValidTra
$LN3@IsValidTra:

; 511  : 	}
; 512  : 
; 513  : 	CvAssertMsg(pPathfinderNode, "pPathfinderNode is null. Whaa?");
; 514  : 	if (pPathfinderNode == NULL)

	cmp	DWORD PTR _pPathfinderNode$[ebp], 0
	jne	SHORT $LN2@IsValidTra

; 515  : 	{
; 516  : 		return false;

	xor	al, al
	jmp	SHORT $LN8@IsValidTra
$LN2@IsValidTra:

; 517  : 	}
; 518  : 
; 519  : 	// beyond the origin player's trade range
; 520  : 	int iPathDistance = pPathfinderNode->m_iTotalCost;

	mov	eax, DWORD PTR _pPathfinderNode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iPathDistance$[ebp], ecx

; 521  : 	int iRange = GET_PLAYER(eOriginPlayer).GetTrade()->GetTradeRouteRange(eDomain, pOriginCity) * 100 + 99; // adding 99 so that any movement penalties are ignored

	mov	edx, DWORD PTR _eOriginPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228243[ebp], edx
	mov	eax, DWORD PTR _pOriginCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eDomain$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228243[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z ; CvPlayerTrade::GetTradeRouteRange
	imul	eax, 100				; 00000064H
	add	eax, 99					; 00000063H
	mov	DWORD PTR _iRange$[ebp], eax

; 522  : 	if (iPathDistance > iRange)

	mov	edx, DWORD PTR _iPathDistance$[ebp]
	cmp	edx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@IsValidTra

; 523  : 	{
; 524  : 		return false;

	xor	al, al
	jmp	SHORT $LN8@IsValidTra
$LN1@IsValidTra:

; 525  : 	}
; 526  : 
; 527  : 	return true;

	mov	al, 1
$LN8@IsValidTra:

; 528  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ENDP ; CvGameTrade::IsValidTradeRoutePath
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z ; CvGameTrade::GetPlotAdjacentToWater
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
; Function compile flags: /Odtp
;	COMDAT ?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z
_TEXT	SEGMENT
_this$ = -208						; size = 4
$T228439 = -124						; size = 4
$T228435 = -120						; size = 4
$T228431 = -116						; size = 4
$T228427 = -112						; size = 4
$T228253 = -28						; size = 4
$T228249 = -24						; size = 4
_iDistance$219387 = -20					; size = 4
_pAdjacentPlot$219384 = -16				; size = 4
_iDirectionLoop$219380 = -12				; size = 4
_iBestDistance$ = -8					; size = 4
_pCoastalPlot$ = -4					; size = 4
_pTargetLandPlot$ = 8					; size = 4
_pFromLandPlot$ = 12					; size = 4
?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z PROC ; CvGameTrade::GetPlotAdjacentToWater, COMDAT
; _this$ = ecx

; 536  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	DWORD PTR _this$[ebp], ecx

; 537  : 	CvPlot* pCoastalPlot = NULL;

	mov	DWORD PTR _pCoastalPlot$[ebp], 0

; 538  : 	int iBestDistance = MAX_INT;

	mov	DWORD PTR _iBestDistance$[ebp], 2147483647 ; 7fffffffH

; 539  : 
; 540  : 	// Find a coastal water tile adjacent to enemy city
; 541  : 	for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$219380[ebp], 0
	jmp	SHORT $LN5@GetPlotAdj
$LN4@GetPlotAdj:
	mov	eax, DWORD PTR _iDirectionLoop$219380[ebp]
	add	eax, 1
	mov	DWORD PTR _iDirectionLoop$219380[ebp], eax
$LN5@GetPlotAdj:
	cmp	DWORD PTR _iDirectionLoop$219380[ebp], 6
	jge	$LN3@GetPlotAdj

; 542  : 	{
; 543  : 		CvPlot* pAdjacentPlot = plotDirection(pFromLandPlot->getX(), pFromLandPlot->getY(), ((DirectionTypes)iDirectionLoop));

	mov	ecx, DWORD PTR _pFromLandPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T228249[ebp], edx
	mov	eax, DWORD PTR _pFromLandPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T228253[ebp], ecx
	mov	edx, DWORD PTR _iDirectionLoop$219380[ebp]
	push	edx
	mov	eax, DWORD PTR $T228249[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228253[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$219384[ebp], eax

; 544  : 		if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	cmp	DWORD PTR _pAdjacentPlot$219384[ebp], 0
	je	SHORT $LN2@GetPlotAdj
	mov	edx, DWORD PTR _pAdjacentPlot$219384[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@GetPlotAdj
	mov	ecx, DWORD PTR _pAdjacentPlot$219384[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetPlotAdj

; 545  : 		{
; 546  : 			int iDistance = plotDistance(pAdjacentPlot->getX(), pAdjacentPlot->getY(), pTargetLandPlot->getX(), pTargetLandPlot->getY());

	mov	ecx, DWORD PTR _pTargetLandPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T228427[ebp], edx
	mov	eax, DWORD PTR _pTargetLandPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T228431[ebp], ecx
	mov	edx, DWORD PTR _pAdjacentPlot$219384[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T228435[ebp], eax
	mov	ecx, DWORD PTR _pAdjacentPlot$219384[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T228439[ebp], edx
	mov	eax, DWORD PTR $T228427[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228431[ebp]
	push	ecx
	mov	edx, DWORD PTR $T228435[ebp]
	push	edx
	mov	eax, DWORD PTR $T228439[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$219387[ebp], eax

; 547  : 			if (iDistance < iBestDistance)

	mov	ecx, DWORD PTR _iDistance$219387[ebp]
	cmp	ecx, DWORD PTR _iBestDistance$[ebp]
	jge	SHORT $LN2@GetPlotAdj

; 548  : 			{
; 549  : 				iBestDistance = iDistance;

	mov	edx, DWORD PTR _iDistance$219387[ebp]
	mov	DWORD PTR _iBestDistance$[ebp], edx

; 550  : 				pCoastalPlot = pAdjacentPlot;

	mov	eax, DWORD PTR _pAdjacentPlot$219384[ebp]
	mov	DWORD PTR _pCoastalPlot$[ebp], eax
$LN2@GetPlotAdj:

; 551  : 			}
; 552  : 		}
; 553  : 	}

	jmp	$LN4@GetPlotAdj
$LN3@GetPlotAdj:

; 554  : 
; 555  : 	return pCoastalPlot;

	mov	eax, DWORD PTR _pCoastalPlot$[ebp]

; 556  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetPlotAdjacentToWater@CvGameTrade@@QAEPAVCvPlot@@PAV2@0@Z ENDP ; CvGameTrade::GetPlotAdjacentToWater
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T228607 = -80						; size = 4
$T228581 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T228581[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T228581[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T228581[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T228607[ebp], edx
	mov	eax, DWORD PTR $T228607[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T228631 = -16						; size = 4
$T228623 = -12						; size = 4
$T228619 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T228619[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228623[ebp], ecx
	movzx	edx, BYTE PTR $T228619[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T228623[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T228623[ebp]
	mov	DWORD PTR $T228631[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T228623[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T228623[ebp]
	mov	DWORD PTR $T228631[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T228631[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T228631[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T228652 = -16						; size = 4
$T228644 = -12						; size = 4
$T228640 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T228640[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T228644[ebp], ecx
	movzx	edx, BYTE PTR $T228640[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T228644[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T228644[ebp]
	mov	DWORD PTR $T228652[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T228644[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T228644[ebp]
	mov	DWORD PTR $T228652[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T228652[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T228652[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T228859 = -80						; size = 4
$T228814 = -76						; size = 4
$T228801 = -72						; size = 4
$T228797 = -68						; size = 4
$T228783 = -64						; size = 4
$T228779 = -57						; size = 1
$T228768 = -56						; size = 4
$T228764 = -49						; size = 1
_iMapY$228858 = -48					; size = 4
_iMapX$228857 = -44					; size = 4
$T228757 = -40						; size = 4
$T228733 = -36						; size = 4
$T228696 = -32						; size = 4
$T228684 = -28						; size = 4
$T228680 = -21						; size = 1
$T228669 = -20						; size = 4
$T228665 = -13						; size = 1
_iMapY$228732 = -12					; size = 4
_iMapX$228731 = -8					; size = 4
$T228658 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T228658[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T228733[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T228658[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T228665[ebp], dl
	mov	eax, DWORD PTR $T228658[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228669[ebp], ecx
	movzx	edx, BYTE PTR $T228665[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T228669[ebp]
	add	edx, DWORD PTR $T228669[ebp]
	mov	DWORD PTR _iMapX$228731[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T228669[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T228669[ebp]
	mov	DWORD PTR _iMapX$228731[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$228731[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T228658[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T228680[ebp], al
	mov	ecx, DWORD PTR $T228658[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T228684[ebp], edx
	movzx	eax, BYTE PTR $T228680[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T228684[ebp]
	add	edx, DWORD PTR $T228684[ebp]
	mov	DWORD PTR _iMapY$228732[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T228684[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T228684[ebp]
	mov	DWORD PTR _iMapY$228732[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$228732[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$228732[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$228731[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T228658[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T228658[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T228696[ebp], eax
	mov	ecx, DWORD PTR _iMapY$228732[ebp]
	imul	ecx, DWORD PTR $T228696[ebp]
	add	ecx, DWORD PTR _iMapX$228731[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T228658[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T228733[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T228733[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T228757[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T228859[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T228757[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T228764[ebp], dl
	mov	eax, DWORD PTR $T228757[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228768[ebp], ecx
	movzx	edx, BYTE PTR $T228764[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T228768[ebp]
	add	edx, DWORD PTR $T228768[ebp]
	mov	DWORD PTR _iMapX$228857[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T228768[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T228768[ebp]
	mov	DWORD PTR _iMapX$228857[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$228857[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T228757[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T228779[ebp], al
	mov	ecx, DWORD PTR $T228757[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T228783[ebp], edx
	movzx	eax, BYTE PTR $T228779[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T228783[ebp]
	add	edx, DWORD PTR $T228783[ebp]
	mov	DWORD PTR _iMapY$228858[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T228783[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T228783[ebp]
	mov	DWORD PTR _iMapY$228858[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$228858[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$228857[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T228757[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228797[ebp], ecx
	mov	edx, DWORD PTR _iMapX$228857[ebp]
	cmp	edx, DWORD PTR $T228797[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$228858[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T228757[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T228801[ebp], ecx
	mov	edx, DWORD PTR _iMapY$228858[ebp]
	cmp	edx, DWORD PTR $T228801[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T228757[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T228814[ebp], ecx
	mov	edx, DWORD PTR _iMapY$228858[ebp]
	imul	edx, DWORD PTR $T228814[ebp]
	add	edx, DWORD PTR _iMapX$228857[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T228757[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T228859[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T228859[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsDestinationExclusive
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
;	COMDAT ?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T228865 = -12						; size = 4
_ui$219394 = -8						; size = 4
_pConnection$ = -4					; size = 4
_kTradeConnection$ = 8					; size = 4
?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z PROC ; CvGameTrade::IsDestinationExclusive, COMDAT
; _this$ = ecx

; 565  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 	TradeConnection* pConnection = NULL;

	mov	DWORD PTR _pConnection$[ebp], 0

; 567  : #endif
; 568  : #ifdef AUI_ITERATORIZE
; 569  : 	for (pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 570  : 	{
; 571  : #else
; 572  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219394[ebp], 0
	jmp	SHORT $LN6@IsDestinat
$LN5@IsDestinat:
	mov	eax, DWORD PTR _ui$219394[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219394[ebp], eax
$LN6@IsDestinat:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228865[ebp], edx
	mov	eax, DWORD PTR _ui$219394[ebp]
	cmp	eax, DWORD PTR $T228865[ebp]
	jae	SHORT $LN4@IsDestinat

; 573  : 	{
; 574  : 		pConnection = &(m_aTradeConnections[ui]);

	mov	ecx, DWORD PTR _ui$219394[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _pConnection$[ebp], ecx

; 575  : #endif
; 576  : 		if (pConnection->m_iDestX == kTradeConnection.m_iDestX && pConnection->m_iDestY == kTradeConnection.m_iDestY)

	mov	eax, DWORD PTR _pConnection$[ebp]
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@IsDestinat
	mov	eax, DWORD PTR _pConnection$[ebp]
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN3@IsDestinat

; 577  : 		{
; 578  : 			// if we're double counting the same route, ignore
; 579  : 			if (pConnection->m_iOriginX == kTradeConnection.m_iOriginX && pConnection->m_iOriginY == kTradeConnection.m_iOriginY)

	mov	eax, DWORD PTR _pConnection$[ebp]
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@IsDestinat
	mov	eax, DWORD PTR _pConnection$[ebp]
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@IsDestinat

; 580  : 			{
; 581  : 				continue;

	jmp	SHORT $LN5@IsDestinat

; 582  : 			}
; 583  : 			else

	jmp	SHORT $LN3@IsDestinat
$LN2@IsDestinat:

; 584  : 			{
; 585  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@IsDestinat
$LN3@IsDestinat:

; 586  : 			}
; 587  : 		}
; 588  : 	}

	jmp	SHORT $LN5@IsDestinat
$LN4@IsDestinat:

; 589  : 
; 590  : 	return true;

	mov	al, 1
$LN7@IsDestinat:

; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z ENDP ; CvGameTrade::IsDestinationExclusive
_TEXT	ENDS
PUBLIC	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
; Function compile flags: /Odtp
;	COMDAT ?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T228886 = -16						; size = 4
$T228874 = -12						; size = 4
_eOriginTeam$ = -8					; size = 4
_eDestTeam$ = -4					; size = 4
_kConnection$ = 8					; size = 4
?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z PROC ; CvGameTrade::IsConnectionInternational, COMDAT
; _this$ = ecx

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 600  : 	TeamTypes eOriginTeam = NO_TEAM;

	mov	DWORD PTR _eOriginTeam$[ebp], -1

; 601  : 	TeamTypes eDestTeam = NO_TEAM;

	mov	DWORD PTR _eDestTeam$[ebp], -1

; 602  : 
; 603  : 	if (kConnection.m_eOriginOwner != NO_PLAYER)

	mov	eax, DWORD PTR _kConnection$[ebp]
	cmp	DWORD PTR [eax+20], -1
	je	SHORT $LN2@IsConnecti

; 604  : 	{
; 605  : 		eOriginTeam = GET_PLAYER(kConnection.m_eOriginOwner).getTeam();

	mov	ecx, DWORD PTR _kConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228874[ebp], edx
	mov	eax, DWORD PTR $T228874[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOriginTeam$[ebp], eax
$LN2@IsConnecti:

; 606  : 	}
; 607  : 
; 608  : 	if (kConnection.m_eDestOwner != NO_PLAYER)

	mov	edx, DWORD PTR _kConnection$[ebp]
	cmp	DWORD PTR [edx+24], -1
	je	SHORT $LN1@IsConnecti

; 609  : 	{
; 610  : 		eDestTeam = GET_PLAYER(kConnection.m_eDestOwner).getTeam();

	mov	eax, DWORD PTR _kConnection$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T228886[ebp], ecx
	mov	edx, DWORD PTR $T228886[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eDestTeam$[ebp], eax
$LN1@IsConnecti:

; 611  : 	}
; 612  : 
; 613  : 	return (eOriginTeam != eDestTeam);

	mov	ecx, DWORD PTR _eOriginTeam$[ebp]
	xor	eax, eax
	cmp	ecx, DWORD PTR _eDestTeam$[ebp]
	setne	al

; 614  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ENDP ; CvGameTrade::IsConnectionInternational
_TEXT	ENDS
PUBLIC	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z	; CvGameTrade::IsTradeRouteIndexEmpty
PUBLIC	?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z ; CvGameTrade::IsCityConnectedToPlayer
; Function compile flags: /Odtp
;	COMDAT ?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T228924 = -24						; size = 4
_pConnection$219423 = -20				; size = 4
_ui$219418 = -16					; size = 4
_iCityY$ = -12						; size = 4
_eCityOwnerPlayer$ = -8					; size = 4
_iCityX$ = -4						; size = 4
_pCity$ = 8						; size = 4
_eOtherPlayer$ = 12					; size = 4
_bOnlyOwnedByCityOwner$ = 16				; size = 1
?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z PROC ; CvGameTrade::IsCityConnectedToPlayer, COMDAT
; _this$ = ecx

; 622  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 623  : 	PlayerTypes eCityOwnerPlayer = pCity->getOwner();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _eCityOwnerPlayer$[ebp], ecx

; 624  : 	int iCityX = pCity->getX();

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iCityX$[ebp], eax

; 625  : 	int iCityY = pCity->getY();

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iCityY$[ebp], edx

; 626  : 
; 627  : #ifdef AUI_ITERATORIZE
; 628  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 629  : 	{
; 630  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 631  : #else
; 632  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219418[ebp], 0
	jmp	SHORT $LN9@IsCityConn
$LN8@IsCityConn:
	mov	eax, DWORD PTR _ui$219418[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219418[ebp], eax
$LN9@IsCityConn:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228924[ebp], edx
	mov	eax, DWORD PTR _ui$219418[ebp]
	cmp	eax, DWORD PTR $T228924[ebp]
	jae	$LN7@IsCityConn

; 633  : 	{
; 634  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$219418[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN26@IsCityConn

; 635  : #endif
; 636  : 		{
; 637  : 			continue;

	jmp	SHORT $LN8@IsCityConn

; 638  : 		}
; 639  : 		
; 640  : #ifndef AUI_ITERATORIZE
; 641  : #ifdef AUI_CONSTIFY
; 642  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 643  : #else
; 644  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);

$LN26@IsCityConn:
	mov	eax, DWORD PTR _ui$219418[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pConnection$219423[ebp], eax

; 645  : #endif
; 646  : #endif
; 647  : 
; 648  : 		if (pConnection->m_eOriginOwner == eCityOwnerPlayer && pConnection->m_eDestOwner == eOtherPlayer)

	mov	edx, DWORD PTR _pConnection$219423[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR _eCityOwnerPlayer$[ebp]
	jne	SHORT $LN5@IsCityConn
	mov	ecx, DWORD PTR _pConnection$219423[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR _eOtherPlayer$[ebp]
	jne	SHORT $LN5@IsCityConn

; 649  : 		{
; 650  : 			if (pConnection->m_iOriginX == iCityX && pConnection->m_iOriginY == iCityY)

	mov	eax, DWORD PTR _pConnection$219423[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iCityX$[ebp]
	jne	SHORT $LN4@IsCityConn
	mov	edx, DWORD PTR _pConnection$219423[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _iCityY$[ebp]
	jne	SHORT $LN4@IsCityConn

; 651  : 			{
; 652  : 				return true;

	mov	al, 1
	jmp	SHORT $LN10@IsCityConn
$LN4@IsCityConn:

; 653  : 			}
; 654  : 		}

	jmp	SHORT $LN3@IsCityConn
$LN5@IsCityConn:

; 655  : 		else if (!bOnlyOwnedByCityOwner && pConnection->m_eOriginOwner == eOtherPlayer && pConnection->m_eDestOwner == eCityOwnerPlayer)

	movzx	ecx, BYTE PTR _bOnlyOwnedByCityOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@IsCityConn
	mov	edx, DWORD PTR _pConnection$219423[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR _eOtherPlayer$[ebp]
	jne	SHORT $LN3@IsCityConn
	mov	ecx, DWORD PTR _pConnection$219423[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR _eCityOwnerPlayer$[ebp]
	jne	SHORT $LN3@IsCityConn

; 656  : 		{
; 657  : 			if (pConnection->m_iDestX == iCityX && pConnection->m_iDestY == iCityY)

	mov	eax, DWORD PTR _pConnection$219423[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _iCityX$[ebp]
	jne	SHORT $LN3@IsCityConn
	mov	edx, DWORD PTR _pConnection$219423[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _iCityY$[ebp]
	jne	SHORT $LN3@IsCityConn

; 658  : 			{
; 659  : 				return true;

	mov	al, 1
	jmp	SHORT $LN10@IsCityConn
$LN3@IsCityConn:

; 660  : 			}
; 661  : 		}
; 662  : 	}

	jmp	$LN8@IsCityConn
$LN7@IsCityConn:

; 663  : 
; 664  : 	return false;

	xor	al, al
$LN10@IsCityConn:

; 665  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IsCityConnectedToPlayer@CvGameTrade@@QAE_NPAVCvCity@@W4PlayerTypes@@_N@Z ENDP ; CvGameTrade::IsCityConnectedToPlayer
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back
; Function compile flags: /Odtp
;	COMDAT ?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T228948 = -32						; size = 4
_i$228943 = -28						; size = 4
_kTradeConnectionPlot$219443 = -24			; size = 8
_i$219439 = -16						; size = 4
_iPathSteps$ = -12					; size = 4
_iIndex$ = -8						; size = 4
_pWalkingPath$ = -4					; size = 4
_pNode$ = 8						; size = 4
_pTradeConnection$ = 12					; size = 4
?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z PROC ; CvGameTrade::CopyPathIntoTradeConnection, COMDAT
; _this$ = ecx

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 674  : 	// beyond the origin player's trade range
; 675  : #ifndef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 676  : 	int iPathSteps = 0;

	mov	DWORD PTR _iPathSteps$[ebp], 0

; 677  : #endif
; 678  : #ifdef AUI_CONSTIFY
; 679  : 	const CvAStarNode* pWalkingPath = pNode;
; 680  : #else
; 681  : 	CvAStarNode* pWalkingPath = pNode;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	DWORD PTR _pWalkingPath$[ebp], eax
$LN7@CopyPathIn:

; 682  : #endif
; 683  : 	while (pWalkingPath)

	cmp	DWORD PTR _pWalkingPath$[ebp], 0
	je	SHORT $LN6@CopyPathIn

; 684  : 	{
; 685  : #ifdef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 686  : 		TradeConnectionPlot kTradeConnectionPlot;
; 687  : 		pTradeConnection->m_aPlotList.push_back(kTradeConnectionPlot);
; 688  : #else
; 689  : 		iPathSteps++;

	mov	ecx, DWORD PTR _iPathSteps$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPathSteps$[ebp], ecx

; 690  : #endif
; 691  : 		pWalkingPath = pWalkingPath->m_pParent;

	mov	edx, DWORD PTR _pWalkingPath$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pWalkingPath$[ebp], eax

; 692  : 	}

	jmp	SHORT $LN7@CopyPathIn
$LN6@CopyPathIn:

; 693  : 
; 694  : #ifdef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 695  : 	int iIndex = pTradeConnection->m_aPlotList.size();
; 696  : #else
; 697  : 	pTradeConnection->m_aPlotList.clear();

	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T228948[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN16@CopyPathIn
	mov	DWORD PTR _i$228943[ebp], 0
	jmp	SHORT $LN14@CopyPathIn
$LN13@CopyPathIn:
	mov	eax, DWORD PTR _i$228943[ebp]
	add	eax, 1
	mov	DWORD PTR _i$228943[ebp], eax
$LN14@CopyPathIn:
	mov	ecx, DWORD PTR $T228948[ebp]
	mov	edx, DWORD PTR _i$228943[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN16@CopyPathIn
	jmp	SHORT $LN13@CopyPathIn
$LN16@CopyPathIn:
	mov	eax, DWORD PTR $T228948[ebp]
	mov	DWORD PTR [eax+4], 0

; 698  : 	for (int i = 0; i < iPathSteps; i++)

	mov	DWORD PTR _i$219439[ebp], 0
	jmp	SHORT $LN5@CopyPathIn
$LN4@CopyPathIn:
	mov	ecx, DWORD PTR _i$219439[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$219439[ebp], ecx
$LN5@CopyPathIn:
	mov	edx, DWORD PTR _i$219439[ebp]
	cmp	edx, DWORD PTR _iPathSteps$[ebp]
	jge	SHORT $LN3@CopyPathIn

; 699  : 	{
; 700  : 		TradeConnectionPlot kTradeConnectionPlot;
; 701  : 		pTradeConnection->m_aPlotList.push_back(kTradeConnectionPlot);

	lea	eax, DWORD PTR _kTradeConnectionPlot$219443[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	add	ecx, 44					; 0000002cH
	call	?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back

; 702  : 	}

	jmp	SHORT $LN4@CopyPathIn
$LN3@CopyPathIn:

; 703  : 
; 704  : 	int iIndex = iPathSteps - 1;

	mov	ecx, DWORD PTR _iPathSteps$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iIndex$[ebp], ecx
$LN2@CopyPathIn:

; 705  : #endif
; 706  : 	while (pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN8@CopyPathIn

; 707  : 	{
; 708  : #ifdef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 709  : 		iIndex--;
; 710  : #endif
; 711  : 		pTradeConnection->m_aPlotList[iIndex].m_iX = pNode->m_iX;

	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [edx+ecx*8], eax

; 712  : 		pTradeConnection->m_aPlotList[iIndex].m_iY = pNode->m_iY;

	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 713  : 		pNode = pNode->m_pParent;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pNode$[ebp], eax

; 714  : #ifndef AUI_TRADE_OPTIMIZE_COPY_PATH_INTO_TRADE_CONNECTION
; 715  : 		iIndex--;

	mov	ecx, DWORD PTR _iIndex$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iIndex$[ebp], ecx
	jmp	SHORT $LN2@CopyPathIn
$LN8@CopyPathIn:

; 716  : #endif
; 717  : 	}
; 718  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ENDP ; CvGameTrade::CopyPathIntoTradeConnection
_TEXT	ENDS
PUBLIC	?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z ; CvGameTrade::GetDomainModifierTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eDomain$ = 8						; size = 4
?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z PROC ; CvGameTrade::GetDomainModifierTimes100, COMDAT
; _this$ = ecx

; 726  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	if (eDomain == DOMAIN_SEA)

	cmp	DWORD PTR _eDomain$[ebp], 0
	jne	SHORT $LN2@GetDomainM

; 728  : 	{
; 729  : 		return 100;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN3@GetDomainM

; 730  : 	}
; 731  : 	else

	jmp	SHORT $LN3@GetDomainM
$LN2@GetDomainM:

; 732  : 	{
; 733  : 		return 0;

	xor	eax, eax
$LN3@GetDomainM:

; 734  : 	}
; 735  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z ENDP ; CvGameTrade::GetDomainModifierTimes100
_TEXT	ENDS
PUBLIC	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
; Function compile flags: /Odtp
;	COMDAT ?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T228969 = -12						; size = 4
_pConnection$219463 = -8				; size = 4
_ui$219459 = -4						; size = 4
_eFirstPlayer$ = 8					; size = 4
_eSecondPlayer$ = 12					; size = 4
?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z PROC ; CvGameTrade::IsPlayerConnectedToPlayer, COMDAT
; _this$ = ecx

; 743  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 744  : #ifdef AUI_ITERATORIZE
; 745  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 746  : 	{
; 747  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 748  : #else
; 749  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219459[ebp], 0
	jmp	SHORT $LN7@IsPlayerCo
$LN6@IsPlayerCo:
	mov	eax, DWORD PTR _ui$219459[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219459[ebp], eax
$LN7@IsPlayerCo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228969[ebp], edx
	mov	eax, DWORD PTR _ui$219459[ebp]
	cmp	eax, DWORD PTR $T228969[ebp]
	jae	SHORT $LN5@IsPlayerCo

; 750  : 	{
; 751  : #ifdef AUI_CONSTIFY
; 752  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 753  : #else
; 754  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);

	mov	ecx, DWORD PTR _ui$219459[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _pConnection$219463[ebp], ecx

; 755  : #endif
; 756  : 
; 757  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	eax, DWORD PTR _ui$219459[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsPlayerCo

; 758  : #endif
; 759  : 		{
; 760  : 			continue;

	jmp	SHORT $LN6@IsPlayerCo
$LN4@IsPlayerCo:

; 761  : 		}
; 762  : 
; 763  : 		if (pConnection->m_eOriginOwner == eFirstPlayer && pConnection->m_eDestOwner == eSecondPlayer)

	mov	edx, DWORD PTR _pConnection$219463[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR _eFirstPlayer$[ebp]
	jne	SHORT $LN3@IsPlayerCo
	mov	ecx, DWORD PTR _pConnection$219463[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR _eSecondPlayer$[ebp]
	jne	SHORT $LN3@IsPlayerCo

; 764  : 		{
; 765  : 			return true;

	mov	al, 1
	jmp	SHORT $LN8@IsPlayerCo
	jmp	SHORT $LN2@IsPlayerCo
$LN3@IsPlayerCo:

; 766  : 		}
; 767  : 		else if (pConnection->m_eOriginOwner == eSecondPlayer && pConnection->m_eDestOwner == eFirstPlayer)

	mov	eax, DWORD PTR _pConnection$219463[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _eSecondPlayer$[ebp]
	jne	SHORT $LN2@IsPlayerCo
	mov	edx, DWORD PTR _pConnection$219463[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _eFirstPlayer$[ebp]
	jne	SHORT $LN2@IsPlayerCo

; 768  : 		{
; 769  : 			return true;

	mov	al, 1
	jmp	SHORT $LN8@IsPlayerCo
$LN2@IsPlayerCo:

; 770  : 		}
; 771  : 	}

	jmp	SHORT $LN6@IsPlayerCo
$LN5@IsPlayerCo:

; 772  : 
; 773  : 	return false;

	xor	al, al
$LN8@IsPlayerCo:

; 774  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ENDP ; CvGameTrade::IsPlayerConnectedToPlayer
_TEXT	ENDS
PUBLIC	?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::CountNumPlayerConnectionsToPlayer
; Function compile flags: /Odtp
;	COMDAT ?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T228978 = -16						; size = 4
_pConnection$219478 = -12				; size = 4
_ui$219474 = -8						; size = 4
_iCount$ = -4						; size = 4
_eFirstPlayer$ = 8					; size = 4
_eSecondPlayer$ = 12					; size = 4
?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z PROC ; CvGameTrade::CountNumPlayerConnectionsToPlayer, COMDAT
; _this$ = ecx

; 782  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 783  : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 784  : 
; 785  : #ifdef AUI_ITERATORIZE
; 786  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 787  : 	{
; 788  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 789  : #else
; 790  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219474[ebp], 0
	jmp	SHORT $LN7@CountNumPl
$LN6@CountNumPl:
	mov	eax, DWORD PTR _ui$219474[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219474[ebp], eax
$LN7@CountNumPl:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228978[ebp], edx
	mov	eax, DWORD PTR _ui$219474[ebp]
	cmp	eax, DWORD PTR $T228978[ebp]
	jae	SHORT $LN5@CountNumPl

; 791  : 	{
; 792  : #ifdef AUI_CONSTIFY
; 793  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 794  : #else
; 795  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);

	mov	ecx, DWORD PTR _ui$219474[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _pConnection$219478[ebp], ecx

; 796  : #endif
; 797  : 
; 798  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	eax, DWORD PTR _ui$219474[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@CountNumPl

; 799  : #endif
; 800  : 		{
; 801  : 			continue;

	jmp	SHORT $LN6@CountNumPl
$LN4@CountNumPl:

; 802  : 		}
; 803  : 
; 804  : 		if (pConnection->m_eOriginOwner == eFirstPlayer && pConnection->m_eDestOwner == eSecondPlayer)

	mov	edx, DWORD PTR _pConnection$219478[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR _eFirstPlayer$[ebp]
	jne	SHORT $LN3@CountNumPl
	mov	ecx, DWORD PTR _pConnection$219478[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR _eSecondPlayer$[ebp]
	jne	SHORT $LN3@CountNumPl

; 805  : 		{
; 806  : 			iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
	jmp	SHORT $LN2@CountNumPl
$LN3@CountNumPl:

; 807  : 		}
; 808  : 		else if (pConnection->m_eOriginOwner == eSecondPlayer && pConnection->m_eDestOwner == eFirstPlayer)

	mov	ecx, DWORD PTR _pConnection$219478[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR _eSecondPlayer$[ebp]
	jne	SHORT $LN2@CountNumPl
	mov	eax, DWORD PTR _pConnection$219478[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _eFirstPlayer$[ebp]
	jne	SHORT $LN2@CountNumPl

; 809  : 		{
; 810  : 			iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$LN2@CountNumPl:

; 811  : 		}
; 812  : 	}

	jmp	$LN6@CountNumPl
$LN5@CountNumPl:

; 813  : 
; 814  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 815  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CountNumPlayerConnectionsToPlayer@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ENDP ; CvGameTrade::CountNumPlayerConnectionsToPlayer
_TEXT	ENDS
PUBLIC	?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ; CvGameTrade::IsCityConnectedToCity
; Function compile flags: /Odtp
;	COMDAT ?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T229019 = -28						; size = 4
_pConnection$219496 = -24				; size = 4
_ui$219492 = -20					; size = 4
_iFirstCityX$ = -16					; size = 4
_iSecondCityY$ = -12					; size = 4
_iSecondCityX$ = -8					; size = 4
_iFirstCityY$ = -4					; size = 4
_pFirstCity$ = 8					; size = 4
_pSecondCity$ = 12					; size = 4
?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z PROC ; CvGameTrade::IsCityConnectedToCity, COMDAT
; _this$ = ecx

; 823  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 824  : 	int iFirstCityX = pFirstCity->getX();

	mov	eax, DWORD PTR _pFirstCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iFirstCityX$[ebp], ecx

; 825  : 	int iFirstCityY = pFirstCity->getY();

	mov	edx, DWORD PTR _pFirstCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iFirstCityY$[ebp], eax

; 826  : 	int iSecondCityX = pSecondCity->getX();

	mov	ecx, DWORD PTR _pSecondCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _iSecondCityX$[ebp], edx

; 827  : 	int iSecondCityY = pSecondCity->getY();

	mov	eax, DWORD PTR _pSecondCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iSecondCityY$[ebp], ecx

; 828  : 
; 829  : #ifdef AUI_ITERATORIZE
; 830  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 831  : 	{
; 832  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 833  : #else
; 834  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219492[ebp], 0
	jmp	SHORT $LN7@IsCityConn@2
$LN6@IsCityConn@2:
	mov	edx, DWORD PTR _ui$219492[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$219492[ebp], edx
$LN7@IsCityConn@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229019[ebp], ecx
	mov	edx, DWORD PTR _ui$219492[ebp]
	cmp	edx, DWORD PTR $T229019[ebp]
	jae	$LN5@IsCityConn@2

; 835  : 	{
; 836  : #ifdef AUI_CONSTIFY
; 837  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 838  : #else
; 839  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);

	mov	eax, DWORD PTR _ui$219492[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pConnection$219496[ebp], eax

; 840  : #endif
; 841  : 
; 842  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$219492[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsCityConn@2

; 843  : #endif
; 844  : 		{
; 845  : 			continue;

	jmp	SHORT $LN6@IsCityConn@2
$LN4@IsCityConn@2:

; 846  : 		}
; 847  : 
; 848  : 		if (pConnection->m_iOriginX == iFirstCityX && pConnection->m_iOriginY == iFirstCityY && pConnection->m_iDestX == iSecondCityX && pConnection->m_iDestY == iSecondCityY)

	mov	ecx, DWORD PTR _pConnection$219496[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _iFirstCityX$[ebp]
	jne	SHORT $LN3@IsCityConn@2
	mov	eax, DWORD PTR _pConnection$219496[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _iFirstCityY$[ebp]
	jne	SHORT $LN3@IsCityConn@2
	mov	edx, DWORD PTR _pConnection$219496[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _iSecondCityX$[ebp]
	jne	SHORT $LN3@IsCityConn@2
	mov	ecx, DWORD PTR _pConnection$219496[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _iSecondCityY$[ebp]
	jne	SHORT $LN3@IsCityConn@2

; 849  : 		{
; 850  : 			return true;

	mov	al, 1
	jmp	SHORT $LN8@IsCityConn@2
	jmp	SHORT $LN2@IsCityConn@2
$LN3@IsCityConn@2:

; 851  : 		}
; 852  : 		else if (pConnection->m_iOriginX == iSecondCityX && pConnection->m_iOriginY == iSecondCityY && pConnection->m_iDestX == iFirstCityX && pConnection->m_iDestY == iFirstCityY)

	mov	eax, DWORD PTR _pConnection$219496[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iSecondCityX$[ebp]
	jne	SHORT $LN2@IsCityConn@2
	mov	edx, DWORD PTR _pConnection$219496[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _iSecondCityY$[ebp]
	jne	SHORT $LN2@IsCityConn@2
	mov	ecx, DWORD PTR _pConnection$219496[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _iFirstCityX$[ebp]
	jne	SHORT $LN2@IsCityConn@2
	mov	eax, DWORD PTR _pConnection$219496[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _iFirstCityY$[ebp]
	jne	SHORT $LN2@IsCityConn@2

; 853  : 		{
; 854  : 			return true;

	mov	al, 1
	jmp	SHORT $LN8@IsCityConn@2
$LN2@IsCityConn@2:

; 855  : 		}
; 856  : 	}

	jmp	$LN6@IsCityConn@2
$LN5@IsCityConn@2:

; 857  : 
; 858  : 	return false;	

	xor	al, al
$LN8@IsCityConn@2:

; 859  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsCityConnectedToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ENDP ; CvGameTrade::IsCityConnectedToCity
_TEXT	ENDS
PUBLIC	?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ; CvGameTrade::IsCityConnectedFromCityToCity
; Function compile flags: /Odtp
;	COMDAT ?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T229060 = -28						; size = 4
_pConnection$219514 = -24				; size = 4
_ui$219510 = -20					; size = 4
_iFirstCityX$ = -16					; size = 4
_iSecondCityY$ = -12					; size = 4
_iSecondCityX$ = -8					; size = 4
_iFirstCityY$ = -4					; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z PROC ; CvGameTrade::IsCityConnectedFromCityToCity, COMDAT
; _this$ = ecx

; 867  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 868  : 	int iFirstCityX = pOriginCity->getX();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iFirstCityX$[ebp], ecx

; 869  : 	int iFirstCityY = pOriginCity->getY();

	mov	edx, DWORD PTR _pOriginCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iFirstCityY$[ebp], eax

; 870  : 	int iSecondCityX = pDestCity->getX();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _iSecondCityX$[ebp], edx

; 871  : 	int iSecondCityY = pDestCity->getY();

	mov	eax, DWORD PTR _pDestCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iSecondCityY$[ebp], ecx

; 872  : 
; 873  : #ifdef AUI_ITERATORIZE
; 874  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 875  : 	{
; 876  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 877  : #else
; 878  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219510[ebp], 0
	jmp	SHORT $LN5@IsCityConn@3
$LN4@IsCityConn@3:
	mov	edx, DWORD PTR _ui$219510[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$219510[ebp], edx
$LN5@IsCityConn@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229060[ebp], ecx
	mov	edx, DWORD PTR _ui$219510[ebp]
	cmp	edx, DWORD PTR $T229060[ebp]
	jae	SHORT $LN3@IsCityConn@3

; 879  : 	{
; 880  : #ifdef AUI_CONSTIFY
; 881  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 882  : #else
; 883  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);

	mov	eax, DWORD PTR _ui$219510[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pConnection$219514[ebp], eax

; 884  : #endif
; 885  : 
; 886  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$219510[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@IsCityConn@3

; 887  : #endif
; 888  : 		{
; 889  : 			continue;

	jmp	SHORT $LN4@IsCityConn@3
$LN2@IsCityConn@3:

; 890  : 		}
; 891  : 
; 892  : 		if (pConnection->m_iOriginX == iFirstCityX && pConnection->m_iOriginY == iFirstCityY && pConnection->m_iDestX == iSecondCityX && pConnection->m_iDestY == iSecondCityY)

	mov	ecx, DWORD PTR _pConnection$219514[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _iFirstCityX$[ebp]
	jne	SHORT $LN1@IsCityConn@3
	mov	eax, DWORD PTR _pConnection$219514[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _iFirstCityY$[ebp]
	jne	SHORT $LN1@IsCityConn@3
	mov	edx, DWORD PTR _pConnection$219514[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _iSecondCityX$[ebp]
	jne	SHORT $LN1@IsCityConn@3
	mov	ecx, DWORD PTR _pConnection$219514[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR _iSecondCityY$[ebp]
	jne	SHORT $LN1@IsCityConn@3

; 893  : 		{
; 894  : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@IsCityConn@3
$LN1@IsCityConn@3:

; 895  : 		}
; 896  : 	}

	jmp	SHORT $LN4@IsCityConn@3
$LN3@IsCityConn@3:

; 897  : 
; 898  : 	return false;

	xor	al, al
$LN6@IsCityConn@3:

; 899  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsCityConnectedFromCityToCity@CvGameTrade@@QAE_NPAVCvCity@@0@Z ENDP ; CvGameTrade::IsCityConnectedFromCityToCity
_TEXT	ENDS
PUBLIC	?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesOriginCity
; Function compile flags: /Odtp
;	COMDAT ?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T229085 = -24						; size = 4
_pConnection$219529 = -20				; size = 4
_ui$219525 = -16					; size = 4
_iCount$ = -12						; size = 4
_iCityY$ = -8						; size = 4
_iCityX$ = -4						; size = 4
_pCity$ = 8						; size = 4
_bOnlyInternational$ = 12				; size = 1
?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z PROC ; CvGameTrade::GetNumTimesOriginCity, COMDAT
; _this$ = ecx

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 909  : 	int iCityX = pCity->getX();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iCityX$[ebp], ecx

; 910  : 	int iCityY = pCity->getY();

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iCityY$[ebp], eax

; 911  : 
; 912  : #ifdef AUI_ITERATORIZE
; 913  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 914  : 	{
; 915  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 916  : #else
; 917  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219525[ebp], 0
	jmp	SHORT $LN8@GetNumTime
$LN7@GetNumTime:
	mov	ecx, DWORD PTR _ui$219525[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$219525[ebp], ecx
$LN8@GetNumTime:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229085[ebp], eax
	mov	ecx, DWORD PTR _ui$219525[ebp]
	cmp	ecx, DWORD PTR $T229085[ebp]
	jae	SHORT $LN6@GetNumTime

; 918  : 	{
; 919  : #ifdef AUI_CONSTIFY
; 920  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 921  : #else
; 922  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);

	mov	edx, DWORD PTR _ui$219525[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pConnection$219529[ebp], edx

; 923  : #endif
; 924  : 
; 925  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$219525[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@GetNumTime

; 926  : #endif
; 927  : 		{
; 928  : 			continue;

	jmp	SHORT $LN7@GetNumTime
$LN5@GetNumTime:

; 929  : 		}
; 930  : 
; 931  : 		if (pConnection->m_iOriginX == iCityX && pConnection->m_iOriginY == iCityY)

	mov	eax, DWORD PTR _pConnection$219529[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iCityX$[ebp]
	jne	SHORT $LN4@GetNumTime
	mov	edx, DWORD PTR _pConnection$219529[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _iCityY$[ebp]
	jne	SHORT $LN4@GetNumTime

; 932  : 		{
; 933  : 			if (bOnlyInternational)

	movzx	ecx, BYTE PTR _bOnlyInternational$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@GetNumTime

; 934  : 			{
; 935  : 				if (pConnection->m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	mov	edx, DWORD PTR _pConnection$219529[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN2@GetNumTime

; 936  : 				{
; 937  : 					iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@GetNumTime:

; 938  : 				}
; 939  : 			}
; 940  : 			else

	jmp	SHORT $LN4@GetNumTime
$LN3@GetNumTime:

; 941  : 			{
; 942  : 				iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN4@GetNumTime:

; 943  : 			}
; 944  : 		}
; 945  : 	}

	jmp	SHORT $LN7@GetNumTime
$LN6@GetNumTime:

; 946  : 
; 947  : 	return iCount;	

	mov	eax, DWORD PTR _iCount$[ebp]

; 948  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNumTimesOriginCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ENDP ; CvGameTrade::GetNumTimesOriginCity
_TEXT	ENDS
PUBLIC	?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ; CvGameTrade::GetNumTimesDestinationCity
; Function compile flags: /Odtp
;	COMDAT ?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T229110 = -24						; size = 4
_pConnection$219547 = -20				; size = 4
_ui$219543 = -16					; size = 4
_iCount$ = -12						; size = 4
_iCityY$ = -8						; size = 4
_iCityX$ = -4						; size = 4
_pCity$ = 8						; size = 4
_bOnlyInternational$ = 12				; size = 1
?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z PROC ; CvGameTrade::GetNumTimesDestinationCity, COMDAT
; _this$ = ecx

; 956  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 957  : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 958  : 	int iCityX = pCity->getX();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iCityX$[ebp], ecx

; 959  : 	int iCityY = pCity->getY();

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iCityY$[ebp], eax

; 960  : 
; 961  : #ifdef AUI_ITERATORIZE
; 962  : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 963  : 	{
; 964  : 		if (IsTradeRouteIndexEmpty(pConnection))
; 965  : #else
; 966  : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219543[ebp], 0
	jmp	SHORT $LN8@GetNumTime@2
$LN7@GetNumTime@2:
	mov	ecx, DWORD PTR _ui$219543[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$219543[ebp], ecx
$LN8@GetNumTime@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229110[ebp], eax
	mov	ecx, DWORD PTR _ui$219543[ebp]
	cmp	ecx, DWORD PTR $T229110[ebp]
	jae	SHORT $LN6@GetNumTime@2

; 967  : 	{
; 968  : #ifdef AUI_CONSTIFY
; 969  : 		const TradeConnection* pConnection = &(m_aTradeConnections[ui]);
; 970  : #else
; 971  : 		TradeConnection* pConnection = &(m_aTradeConnections[ui]);

	mov	edx, DWORD PTR _ui$219543[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pConnection$219547[ebp], edx

; 972  : #endif
; 973  : 
; 974  : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$219543[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@GetNumTime@2

; 975  : #endif
; 976  : 		{
; 977  : 			continue;

	jmp	SHORT $LN7@GetNumTime@2
$LN5@GetNumTime@2:

; 978  : 		}
; 979  : 
; 980  : 		if (pConnection->m_iDestX == iCityX && pConnection->m_iDestY == iCityY)

	mov	eax, DWORD PTR _pConnection$219547[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _iCityX$[ebp]
	jne	SHORT $LN4@GetNumTime@2
	mov	edx, DWORD PTR _pConnection$219547[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _iCityY$[ebp]
	jne	SHORT $LN4@GetNumTime@2

; 981  : 		{
; 982  : 			if (bOnlyInternational)

	movzx	ecx, BYTE PTR _bOnlyInternational$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@GetNumTime@2

; 983  : 			{
; 984  : 				if (pConnection->m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	mov	edx, DWORD PTR _pConnection$219547[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $LN2@GetNumTime@2

; 985  : 				{
; 986  : 					iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@GetNumTime@2:

; 987  : 				}
; 988  : 			}
; 989  : 			else

	jmp	SHORT $LN4@GetNumTime@2
$LN3@GetNumTime@2:

; 990  : 			{
; 991  : 				iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN4@GetNumTime@2:

; 992  : 			}
; 993  : 		}
; 994  : 	}

	jmp	SHORT $LN7@GetNumTime@2
$LN6@GetNumTime@2:

; 995  : 
; 996  : 	return iCount;	

	mov	eax, DWORD PTR _iCount$[ebp]

; 997  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNumTimesDestinationCity@CvGameTrade@@QAEHPAVCvCity@@_N@Z ENDP ; CvGameTrade::GetNumTimesDestinationCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T229119 = -8						; size = 4
_i$219557 = -4						; size = 4
?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ PROC	; CvGameTrade::GetEmptyTradeRouteIndex, COMDAT
; _this$ = ecx

; 1005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1006 : 	for (uint i = 0; i < m_aTradeConnections.size(); i++)

	mov	DWORD PTR _i$219557[ebp], 0
	jmp	SHORT $LN4@GetEmptyTr
$LN3@GetEmptyTr:
	mov	eax, DWORD PTR _i$219557[ebp]
	add	eax, 1
	mov	DWORD PTR _i$219557[ebp], eax
$LN4@GetEmptyTr:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229119[ebp], edx
	mov	eax, DWORD PTR _i$219557[ebp]
	cmp	eax, DWORD PTR $T229119[ebp]
	jae	SHORT $LN2@GetEmptyTr

; 1007 : 	{
; 1008 : 		if (IsTradeRouteIndexEmpty(i))

	mov	ecx, DWORD PTR _i$219557[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetEmptyTr

; 1009 : 		{
; 1010 : 			return i;

	mov	eax, DWORD PTR _i$219557[ebp]
	jmp	SHORT $LN5@GetEmptyTr
$LN1@GetEmptyTr:

; 1011 : 		}
; 1012 : 	}

	jmp	SHORT $LN3@GetEmptyTr
$LN2@GetEmptyTr:

; 1013 : 
; 1014 : 	return -1;

	or	eax, -1
$LN5@GetEmptyTr:

; 1015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEmptyTradeRouteIndex@CvGameTrade@@QAEHXZ ENDP	; CvGameTrade::GetEmptyTradeRouteIndex
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z PROC	; CvGameTrade::IsTradeRouteIndexEmpty, COMDAT
; _this$ = ecx

; 1023 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1024 : 	if (m_aTradeConnections[iIndex].m_iOriginX == -1 && m_aTradeConnections[iIndex].m_iOriginY == -1 && m_aTradeConnections[iIndex].m_iDestX == -1 && m_aTradeConnections[iIndex].m_iDestY == -1)

	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax+4], -1
	jne	SHORT $LN2@IsTradeRou
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax+8], -1
	jne	SHORT $LN2@IsTradeRou
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax+12], -1
	jne	SHORT $LN2@IsTradeRou
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+eax+16], -1
	jne	SHORT $LN2@IsTradeRou

; 1025 : 	{
; 1026 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTradeRou

; 1027 : 	}
; 1028 : 	else

	jmp	SHORT $LN3@IsTradeRou
$LN2@IsTradeRou:

; 1029 : 	{
; 1030 : 		return false;

	xor	al, al
$LN3@IsTradeRou:

; 1031 : 	}
; 1032 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ENDP	; CvGameTrade::IsTradeRouteIndexEmpty
_TEXT	ENDS
PUBLIC	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z		; CvGameTrade::EmptyTradeRoute
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
; Function compile flags: /Odtp
;	COMDAT ?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
tv183 = -56						; size = 4
_this$ = -52						; size = 4
$T229177 = -48						; size = 4
$T229173 = -44						; size = 4
$T229169 = -40						; size = 4
$T229165 = -36						; size = 4
_i$229161 = -32						; size = 4
$T229146 = -28						; size = 4
$T229139 = -24						; size = 4
_ui$219581 = -20					; size = 4
_pkUnit$219579 = -16					; size = 4
_kTradeConnection$ = -12				; size = 4
_eOriginPlayer$ = -8					; size = 4
_eDestPlayer$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z PROC		; CvGameTrade::EmptyTradeRoute, COMDAT
; _this$ = ecx

; 1036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1037 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1038 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN6@EmptyTrade
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229139[ebp], ecx
	mov	edx, DWORD PTR _iIndex$[ebp]
	cmp	edx, DWORD PTR $T229139[ebp]
	jl	SHORT $LN12@EmptyTrade
$LN6@EmptyTrade:

; 1039 : 	{
; 1040 : 		return false;

	xor	al, al
	jmp	$LN8@EmptyTrade

; 1041 : 	}
; 1042 : 
; 1043 : 	TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];

$LN12@EmptyTrade:
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _kTradeConnection$[ebp], eax

; 1044 : 	PlayerTypes eOriginPlayer = kTradeConnection.m_eOriginOwner;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _eOriginPlayer$[ebp], eax

; 1045 : 	PlayerTypes eDestPlayer = kTradeConnection.m_eDestOwner;

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _eDestPlayer$[ebp], edx

; 1046 : 
; 1047 : 	// Remove any visualization
; 1048 : 	if (kTradeConnection.m_unitID != -1)

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [eax+380], -1
	je	SHORT $LN5@EmptyTrade

; 1049 : 	{
; 1050 : 		CvUnit* pkUnit = GET_PLAYER(kTradeConnection.m_eOriginOwner).getUnit(kTradeConnection.m_unitID);

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229146[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+380]
	push	ecx
	mov	ecx, DWORD PTR $T229146[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pkUnit$219579[ebp], eax

; 1051 : 		if (pkUnit)

	cmp	DWORD PTR _pkUnit$219579[ebp], 0
	je	SHORT $LN5@EmptyTrade

; 1052 : 		{
; 1053 : 			pkUnit->kill(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pkUnit$219579[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN5@EmptyTrade:

; 1054 : 		}
; 1055 : 	}
; 1056 : 
; 1057 : 	kTradeConnection.m_iID = -1;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [edx], -1

; 1058 : 	kTradeConnection.m_iDestX = -1;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [eax+12], -1

; 1059 : 	kTradeConnection.m_iDestY = -1;

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+16], -1

; 1060 : 	kTradeConnection.m_eDestOwner = NO_PLAYER;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [edx+24], -1

; 1061 : 	kTradeConnection.m_iOriginX = -1;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [eax+4], -1

; 1062 : 	kTradeConnection.m_iOriginY = -1;

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+8], -1

; 1063 : 	kTradeConnection.m_eOriginOwner = NO_PLAYER;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [edx+20], -1

; 1064 : 	kTradeConnection.m_eDomain = NO_DOMAIN;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [eax+28], -1

; 1065 : 	kTradeConnection.m_eConnectionType = NUM_TRADE_CONNECTION_TYPES;

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+32], 3

; 1066 : #ifdef AUI_WARNING_FIXES
; 1067 : 	kTradeConnection.m_iTradeUnitLocationIndex = MAX_UNSIGNED_INT;
; 1068 : #else
; 1069 : 	kTradeConnection.m_iTradeUnitLocationIndex = -1;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [edx+36], -1

; 1070 : #endif
; 1071 : 	kTradeConnection.m_bTradeUnitMovingForward = false;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	BYTE PTR [eax+40], 0

; 1072 : 	kTradeConnection.m_iCircuitsCompleted = 0;

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+384], 0

; 1073 : 	kTradeConnection.m_iCircuitsToComplete = 0;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [edx+388], 0

; 1074 : 	kTradeConnection.m_iTurnRouteComplete = 0;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [eax+392], 0

; 1075 : 	kTradeConnection.m_aPlotList.clear();

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T229165[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN22@EmptyTrade
	mov	DWORD PTR _i$229161[ebp], 0
	jmp	SHORT $LN20@EmptyTrade
$LN19@EmptyTrade:
	mov	eax, DWORD PTR _i$229161[ebp]
	add	eax, 1
	mov	DWORD PTR _i$229161[ebp], eax
$LN20@EmptyTrade:
	mov	ecx, DWORD PTR $T229165[ebp]
	mov	edx, DWORD PTR _i$229161[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN22@EmptyTrade
	jmp	SHORT $LN19@EmptyTrade
$LN22@EmptyTrade:
	mov	eax, DWORD PTR $T229165[ebp]
	mov	DWORD PTR [eax+4], 0

; 1076 : 	kTradeConnection.m_unitID = -1;

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+380], -1

; 1077 : 
; 1078 : 	for (uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$219581[ebp], 0
	jmp	SHORT $LN3@EmptyTrade
$LN2@EmptyTrade:
	mov	edx, DWORD PTR _ui$219581[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$219581[ebp], edx
$LN3@EmptyTrade:
	cmp	DWORD PTR _ui$219581[ebp], 6
	jae	SHORT $LN1@EmptyTrade

; 1079 : 	{
; 1080 : 		kTradeConnection.m_aiOriginYields[ui] = 0;

	mov	eax, DWORD PTR _ui$219581[ebp]
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+eax*4+396], 0

; 1081 : 		kTradeConnection.m_aiDestYields[ui] = 0;

	mov	edx, DWORD PTR _ui$219581[ebp]
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [eax+edx*4+420], 0

; 1082 : 	}

	jmp	SHORT $LN2@EmptyTrade
$LN1@EmptyTrade:

; 1083 : 
; 1084 : 	GET_PLAYER(eOriginPlayer).GetTrade()->UpdateTradeConnectionValues();

	mov	ecx, DWORD PTR _eOriginPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229169[ebp], ecx
	mov	ecx, DWORD PTR $T229169[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 1085 : 	GET_PLAYER(eDestPlayer).GetTrade()->UpdateTradeConnectionValues();

	mov	edx, DWORD PTR _eDestPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229173[ebp], edx
	mov	ecx, DWORD PTR $T229173[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 1086 : 
; 1087 : 	gDLL->TradeVisuals_DestroyRoute(iIndex, eOriginPlayer);

	mov	eax, DWORD PTR $T229177[ebp]
	mov	DWORD PTR tv183[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv183[ebp], ecx
	mov	edx, DWORD PTR _eOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _iIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv183[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv183[ebp]
	mov	eax, DWORD PTR [edx+980]
	call	eax

; 1088 : 	return true;

	mov	al, 1
$LN8@EmptyTrade:

; 1089 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z ENDP		; CvGameTrade::EmptyTradeRoute
_TEXT	ENDS
PUBLIC	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
PUBLIC	?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z ; CvGameTrade::ClearAllCityTradeRoutes
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
; Function compile flags: /Odtp
;	COMDAT ?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
tv152 = -68						; size = 4
tv132 = -64						; size = 4
_this$ = -60						; size = 4
$T229245 = -56						; size = 4
$T229241 = -52						; size = 4
$T229237 = -48						; size = 4
$T229233 = -44						; size = 4
$T229226 = -40						; size = 4
$T229222 = -33						; size = 1
$T229213 = -32						; size = 4
$T229209 = -28						; size = 4
$T229193 = -24						; size = 4
_eUnitType$219602 = -20					; size = 4
_bMatchesOrigin$219597 = -14				; size = 1
_bMatchesDest$219598 = -13				; size = 1
_ui$219592 = -12					; size = 4
_iX$219590 = -8						; size = 4
_iY$219591 = -4						; size = 4
_pPlot$ = 8						; size = 4
?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z PROC ; CvGameTrade::ClearAllCityTradeRoutes, COMDAT
; _this$ = ecx

; 1132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1133 : 	CvAssert(pPlot != NULL);
; 1134 : 
; 1135 : 	if (pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	$LN10@ClearAllCi

; 1136 : 	{
; 1137 : 		int iX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iX$219590[ebp], ecx

; 1138 : 		int iY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iY$219591[ebp], eax

; 1139 : 		for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219592[ebp], 0
	jmp	SHORT $LN8@ClearAllCi
$LN7@ClearAllCi:
	mov	ecx, DWORD PTR _ui$219592[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$219592[ebp], ecx
$LN8@ClearAllCi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229193[ebp], eax
	mov	ecx, DWORD PTR _ui$219592[ebp]
	cmp	ecx, DWORD PTR $T229193[ebp]
	jae	$LN10@ClearAllCi

; 1140 : 		{
; 1141 : 			if (IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$219592[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@ClearAllCi

; 1142 : 			{
; 1143 : 				continue;

	jmp	SHORT $LN7@ClearAllCi

; 1144 : 			}
; 1145 : 
; 1146 : 			bool bMatchesOrigin = (m_aTradeConnections[ui].m_iOriginX == iX && m_aTradeConnections[ui].m_iOriginY == iY);

$LN22@ClearAllCi:
	mov	ecx, DWORD PTR _ui$219592[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+4]
	cmp	ecx, DWORD PTR _iX$219590[ebp]
	jne	SHORT $LN12@ClearAllCi
	mov	edx, DWORD PTR _ui$219592[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+8]
	cmp	edx, DWORD PTR _iY$219591[ebp]
	jne	SHORT $LN12@ClearAllCi
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN13@ClearAllCi
$LN12@ClearAllCi:
	mov	DWORD PTR tv132[ebp], 0
$LN13@ClearAllCi:
	mov	al, BYTE PTR tv132[ebp]
	mov	BYTE PTR _bMatchesOrigin$219597[ebp], al

; 1147 : 			bool bMatchesDest = (m_aTradeConnections[ui].m_iDestX == iX && m_aTradeConnections[ui].m_iDestY == iY);

	mov	ecx, DWORD PTR _ui$219592[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+12]
	cmp	ecx, DWORD PTR _iX$219590[ebp]
	jne	SHORT $LN14@ClearAllCi
	mov	edx, DWORD PTR _ui$219592[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+16]
	cmp	edx, DWORD PTR _iY$219591[ebp]
	jne	SHORT $LN14@ClearAllCi
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN15@ClearAllCi
$LN14@ClearAllCi:
	mov	DWORD PTR tv152[ebp], 0
$LN15@ClearAllCi:
	mov	al, BYTE PTR tv152[ebp]
	mov	BYTE PTR _bMatchesDest$219598[ebp], al

; 1148 : 
; 1149 : 			if (bMatchesOrigin || bMatchesDest)

	movzx	ecx, BYTE PTR _bMatchesOrigin$219597[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@ClearAllCi
	movzx	edx, BYTE PTR _bMatchesDest$219598[ebp]
	test	edx, edx
	je	$LN4@ClearAllCi
$LN3@ClearAllCi:

; 1150 : 			{
; 1151 : 				// if the destination was wiped, the origin gets a trade unit back
; 1152 : 				if (bMatchesDest && GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isAlive())

	movzx	eax, BYTE PTR _bMatchesDest$219598[ebp]
	test	eax, eax
	je	$LN2@ClearAllCi
	mov	ecx, DWORD PTR _ui$219592[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229209[ebp], ecx
	mov	eax, DWORD PTR $T229209[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229213[ebp], ecx
	mov	edx, DWORD PTR $T229213[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T229222[ebp], al
	movzx	ecx, BYTE PTR $T229222[ebp]
	test	ecx, ecx
	je	$LN2@ClearAllCi

; 1153 : 				{
; 1154 : 					UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	mov	edx, DWORD PTR _ui$219592[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229226[ebp], edx
	mov	ecx, DWORD PTR $T229226[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	edx, DWORD PTR _ui$219592[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229233[ebp], edx
	mov	ecx, DWORD PTR $T229233[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	mov	DWORD PTR _eUnitType$219602[ebp], eax

; 1155 : 					CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1156 : 					if (eUnitType != NO_UNIT)

	cmp	DWORD PTR _eUnitType$219602[ebp], -1
	je	SHORT $LN2@ClearAllCi

; 1157 : 					{
; 1158 : 						GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	eax, DWORD PTR _ui$219592[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229237[ebp], eax
	mov	edx, DWORD PTR _ui$219592[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229241[ebp], edx
	mov	ecx, DWORD PTR _ui$219592[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229245[ebp], ecx
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	38					; 00000026H
	mov	eax, DWORD PTR $T229237[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR $T229241[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _eUnitType$219602[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229245[ebp]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN2@ClearAllCi:

; 1159 : 					}
; 1160 : 				}
; 1161 : 
; 1162 : 				EmptyTradeRoute(ui);

	mov	eax, DWORD PTR _ui$219592[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN4@ClearAllCi:

; 1163 : 			}		
; 1164 : 		}

	jmp	$LN7@ClearAllCi
$LN10@ClearAllCi:

; 1165 : 	}
; 1166 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z ENDP ; CvGameTrade::ClearAllCityTradeRoutes
_TEXT	ENDS
PUBLIC	?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z ; CvGameTrade::ClearAllCivTradeRoutes
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Odtp
;	COMDAT ?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv167 = -72						; size = 4
_this$ = -68						; size = 4
$T229318 = -64						; size = 4
$T229314 = -60						; size = 4
$T229310 = -56						; size = 4
$T229306 = -52						; size = 4
$T229299 = -48						; size = 4
$T229295 = -41						; size = 1
$T229286 = -40						; size = 4
$T229282 = -36						; size = 4
$T229278 = -32						; size = 4
$T229274 = -28						; size = 4
$T229270 = -24						; size = 4
$T229266 = -20						; size = 4
$T229256 = -16						; size = 4
_eUnitType$219622 = -12					; size = 4
_bMatchesOrigin$219613 = -7				; size = 1
_bMatchesDest$219614 = -6				; size = 1
_bCityStateRoute$219615 = -5				; size = 1
_ui$219608 = -4						; size = 4
_ePlayer$ = 8						; size = 4
?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z PROC ; CvGameTrade::ClearAllCivTradeRoutes, COMDAT
; _this$ = ecx

; 1171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 1172 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219608[ebp], 0
	jmp	SHORT $LN11@ClearAllCi@2
$LN10@ClearAllCi@2:
	mov	eax, DWORD PTR _ui$219608[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219608[ebp], eax
$LN11@ClearAllCi@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229256[ebp], edx
	mov	eax, DWORD PTR _ui$219608[ebp]
	cmp	eax, DWORD PTR $T229256[ebp]
	jae	$LN12@ClearAllCi@2

; 1173 : 	{
; 1174 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$219608[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@ClearAllCi@2

; 1175 : 		{
; 1176 : 			continue;

	jmp	SHORT $LN10@ClearAllCi@2

; 1177 : 		}
; 1178 : 
; 1179 : 		bool bMatchesOrigin = (m_aTradeConnections[ui].m_eOriginOwner == ePlayer);

$LN18@ClearAllCi@2:
	mov	eax, DWORD PTR _ui$219608[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+20]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	sete	cl
	mov	BYTE PTR _bMatchesOrigin$219613[ebp], cl

; 1180 : 		bool bMatchesDest = (m_aTradeConnections[ui].m_eDestOwner == ePlayer);

	mov	edx, DWORD PTR _ui$219608[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+24]
	xor	eax, eax
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	sete	al
	mov	BYTE PTR _bMatchesDest$219614[ebp], al

; 1181 : 		bool bCityStateRoute = (GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isMinorCiv() || GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).isMinorCiv());

	mov	ecx, DWORD PTR _ui$219608[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229266[ebp], ecx
	mov	eax, DWORD PTR $T229266[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229270[ebp], ecx
	mov	ecx, DWORD PTR $T229270[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@ClearAllCi@2
	mov	eax, DWORD PTR _ui$219608[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229274[ebp], eax
	mov	edx, DWORD PTR $T229274[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229278[ebp], eax
	mov	ecx, DWORD PTR $T229278[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN14@ClearAllCi@2
	mov	DWORD PTR tv167[ebp], 0
	jmp	SHORT $LN15@ClearAllCi@2
$LN14@ClearAllCi@2:
	mov	DWORD PTR tv167[ebp], 1
$LN15@ClearAllCi@2:
	mov	dl, BYTE PTR tv167[ebp]
	mov	BYTE PTR _bCityStateRoute$219615[ebp], dl

; 1182 : 
; 1183 : 		if (!bCityStateRoute)

	movzx	eax, BYTE PTR _bCityStateRoute$219615[ebp]
	test	eax, eax
	jne	$LN7@ClearAllCi@2

; 1184 : 		{
; 1185 : 			if (bMatchesOrigin && bMatchesDest)

	movzx	ecx, BYTE PTR _bMatchesOrigin$219613[ebp]
	test	ecx, ecx
	je	SHORT $LN6@ClearAllCi@2
	movzx	edx, BYTE PTR _bMatchesDest$219614[ebp]
	test	edx, edx
	je	SHORT $LN6@ClearAllCi@2
	jmp	$LN10@ClearAllCi@2

; 1186 : 			{
; 1187 : 				// Internal trade route - don't wipe it
; 1188 : 				continue;

	jmp	$LN7@ClearAllCi@2
$LN6@ClearAllCi@2:

; 1189 : 			}
; 1190 : 			else if (bMatchesOrigin || bMatchesDest)

	movzx	eax, BYTE PTR _bMatchesOrigin$219613[ebp]
	test	eax, eax
	jne	SHORT $LN3@ClearAllCi@2
	movzx	ecx, BYTE PTR _bMatchesDest$219614[ebp]
	test	ecx, ecx
	je	$LN7@ClearAllCi@2
$LN3@ClearAllCi@2:

; 1191 : 			{
; 1192 : 				// if the destination was wiped, the origin gets a trade unit back
; 1193 : 				if (GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isAlive())

	mov	edx, DWORD PTR _ui$219608[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229282[ebp], edx
	mov	ecx, DWORD PTR $T229282[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229286[ebp], edx
	mov	eax, DWORD PTR $T229286[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T229295[ebp], cl
	movzx	edx, BYTE PTR $T229295[ebp]
	test	edx, edx
	je	$LN2@ClearAllCi@2

; 1194 : 				{
; 1195 : 					UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	mov	eax, DWORD PTR _ui$219608[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229299[ebp], eax
	mov	edx, DWORD PTR $T229299[ebp]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	eax, DWORD PTR _ui$219608[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229306[ebp], eax
	mov	edx, DWORD PTR $T229306[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	mov	DWORD PTR _eUnitType$219622[ebp], eax

; 1196 : 					CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1197 : 					if (eUnitType != NO_UNIT)

	cmp	DWORD PTR _eUnitType$219622[ebp], -1
	je	SHORT $LN2@ClearAllCi@2

; 1198 : 					{
; 1199 : 						GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	ecx, DWORD PTR _ui$219608[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229310[ebp], ecx
	mov	eax, DWORD PTR _ui$219608[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229314[ebp], eax
	mov	edx, DWORD PTR _ui$219608[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229318[ebp], edx
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	38					; 00000026H
	mov	ecx, DWORD PTR $T229310[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR $T229314[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eUnitType$219622[ebp]
	push	edx
	mov	eax, DWORD PTR $T229318[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN2@ClearAllCi@2:

; 1200 : 					}
; 1201 : 				}
; 1202 : 
; 1203 : 				EmptyTradeRoute(ui);

	mov	ecx, DWORD PTR _ui$219608[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN7@ClearAllCi@2:

; 1204 : 			}
; 1205 : 		}

	jmp	$LN10@ClearAllCi@2
$LN12@ClearAllCi@2:

; 1206 : 	}
; 1207 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearAllCivTradeRoutes@CvGameTrade@@QAEXW4PlayerTypes@@@Z ENDP ; CvGameTrade::ClearAllCivTradeRoutes
_TEXT	ENDS
PUBLIC	?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ ; CvGameTrade::ClearAllCityStateTradeRoutes
; Function compile flags: /Odtp
;	COMDAT ?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T229375 = -56						; size = 4
$T229371 = -52						; size = 4
$T229367 = -48						; size = 4
$T229363 = -44						; size = 4
$T229356 = -40						; size = 4
$T229352 = -33						; size = 1
$T229343 = -32						; size = 4
$T229339 = -28						; size = 4
$T229335 = -24						; size = 4
$T229331 = -20						; size = 4
$T229327 = -16						; size = 4
_eUnitType$219636 = -12					; size = 4
_bMatchesDest$219633 = -5				; size = 1
_ui$219628 = -4						; size = 4
?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ PROC	; CvGameTrade::ClearAllCityStateTradeRoutes, COMDAT
; _this$ = ecx

; 1212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1213 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219628[ebp], 0
	jmp	SHORT $LN7@ClearAllCi@3
$LN6@ClearAllCi@3:
	mov	eax, DWORD PTR _ui$219628[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219628[ebp], eax
$LN7@ClearAllCi@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229327[ebp], edx
	mov	eax, DWORD PTR _ui$219628[ebp]
	cmp	eax, DWORD PTR $T229327[ebp]
	jae	$LN8@ClearAllCi@3

; 1214 : 	{
; 1215 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$219628[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@ClearAllCi@3

; 1216 : 		{
; 1217 : 			continue;

	jmp	SHORT $LN6@ClearAllCi@3
$LN4@ClearAllCi@3:

; 1218 : 		}
; 1219 : 
; 1220 : 		bool bMatchesDest = (GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).isMinorCiv());

	mov	eax, DWORD PTR _ui$219628[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229331[ebp], eax
	mov	edx, DWORD PTR $T229331[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229335[ebp], eax
	mov	ecx, DWORD PTR $T229335[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bMatchesDest$219633[ebp], al

; 1221 : 		if (bMatchesDest)

	movzx	ecx, BYTE PTR _bMatchesDest$219633[ebp]
	test	ecx, ecx
	je	$LN3@ClearAllCi@3

; 1222 : 		{
; 1223 : 			// if the destination was wiped, the origin gets a trade unit back
; 1224 : 			if (GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).isAlive())

	mov	edx, DWORD PTR _ui$219628[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229339[ebp], edx
	mov	ecx, DWORD PTR $T229339[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229343[ebp], edx
	mov	eax, DWORD PTR $T229343[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T229352[ebp], cl
	movzx	edx, BYTE PTR $T229352[ebp]
	test	edx, edx
	je	$LN2@ClearAllCi@3

; 1225 : 			{
; 1226 : 				UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	mov	eax, DWORD PTR _ui$219628[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229356[ebp], eax
	mov	edx, DWORD PTR $T229356[ebp]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	eax, DWORD PTR _ui$219628[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229363[ebp], eax
	mov	edx, DWORD PTR $T229363[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	mov	DWORD PTR _eUnitType$219636[ebp], eax

; 1227 : 				CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1228 : 				if (eUnitType != NO_UNIT)

	cmp	DWORD PTR _eUnitType$219636[ebp], -1
	je	SHORT $LN2@ClearAllCi@3

; 1229 : 				{
; 1230 : 					GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	ecx, DWORD PTR _ui$219628[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229367[ebp], ecx
	mov	eax, DWORD PTR _ui$219628[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229371[ebp], eax
	mov	edx, DWORD PTR _ui$219628[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229375[ebp], edx
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	38					; 00000026H
	mov	ecx, DWORD PTR $T229367[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR $T229371[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eUnitType$219636[ebp]
	push	edx
	mov	eax, DWORD PTR $T229375[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN2@ClearAllCi@3:

; 1231 : 				}
; 1232 : 			}
; 1233 : 
; 1234 : 			EmptyTradeRoute(ui);

	mov	ecx, DWORD PTR _ui$219628[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN3@ClearAllCi@3:

; 1235 : 		}		

	jmp	$LN6@ClearAllCi@3
$LN8@ClearAllCi@3:

; 1236 : 	}
; 1237 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearAllCityStateTradeRoutes@CvGameTrade@@QAEXXZ ENDP	; CvGameTrade::ClearAllCityStateTradeRoutes
_TEXT	ENDS
PUBLIC	?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ; CvGameTrade::CancelTradeBetweenTeams
; Function compile flags: /Odtp
;	COMDAT ?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T229439 = -56						; size = 4
$T229435 = -52						; size = 4
$T229431 = -48						; size = 4
$T229427 = -44						; size = 4
$T229420 = -40						; size = 4
$T229408 = -36						; size = 4
$T229404 = -32						; size = 4
$T229392 = -28						; size = 4
$T229388 = -24						; size = 4
$T229384 = -20						; size = 4
_eUnitType$219656 = -16					; size = 4
_eOriginTeam$219650 = -12				; size = 4
_eDestTeam$219651 = -8					; size = 4
_ui$219645 = -4						; size = 4
_eTeam1$ = 8						; size = 4
_eTeam2$ = 12						; size = 4
_bReturnUnits$ = 16					; size = 1
?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z PROC ; CvGameTrade::CancelTradeBetweenTeams, COMDAT
; _this$ = ecx

; 1246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1247 : 	// there shouldn't be trade routes between the same team
; 1248 : 	if (eTeam1 == eTeam2)

	mov	eax, DWORD PTR _eTeam1$[ebp]
	cmp	eax, DWORD PTR _eTeam2$[ebp]
	jne	SHORT $LN10@CancelTrad

; 1249 : 	{
; 1250 : 		return;

	jmp	$LN11@CancelTrad
$LN10@CancelTrad:

; 1251 : 	}
; 1252 : 
; 1253 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219645[ebp], 0
	jmp	SHORT $LN9@CancelTrad
$LN8@CancelTrad:
	mov	ecx, DWORD PTR _ui$219645[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$219645[ebp], ecx
$LN9@CancelTrad:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229384[ebp], eax
	mov	ecx, DWORD PTR _ui$219645[ebp]
	cmp	ecx, DWORD PTR $T229384[ebp]
	jae	$LN11@CancelTrad

; 1254 : 	{
; 1255 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$219645[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@CancelTrad

; 1256 : 		{
; 1257 : 			continue;

	jmp	SHORT $LN8@CancelTrad
$LN6@CancelTrad:

; 1258 : 		}
; 1259 : 
; 1260 : 		TeamTypes eOriginTeam = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).getTeam();

	mov	ecx, DWORD PTR _ui$219645[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229388[ebp], ecx
	mov	eax, DWORD PTR $T229388[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229392[ebp], ecx
	mov	edx, DWORD PTR $T229392[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOriginTeam$219650[ebp], eax

; 1261 : 		TeamTypes eDestTeam = GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).getTeam();

	mov	ecx, DWORD PTR _ui$219645[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229404[ebp], ecx
	mov	eax, DWORD PTR $T229404[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229408[ebp], ecx
	mov	edx, DWORD PTR $T229408[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eDestTeam$219651[ebp], eax

; 1262 : 		if ((eOriginTeam == eTeam1 && eDestTeam == eTeam2) || (eOriginTeam == eTeam2 && eDestTeam == eTeam1)) 

	mov	ecx, DWORD PTR _eOriginTeam$219650[ebp]
	cmp	ecx, DWORD PTR _eTeam1$[ebp]
	jne	SHORT $LN3@CancelTrad
	mov	edx, DWORD PTR _eDestTeam$219651[ebp]
	cmp	edx, DWORD PTR _eTeam2$[ebp]
	je	SHORT $LN4@CancelTrad
$LN3@CancelTrad:
	mov	eax, DWORD PTR _eOriginTeam$219650[ebp]
	cmp	eax, DWORD PTR _eTeam2$[ebp]
	jne	$LN5@CancelTrad
	mov	ecx, DWORD PTR _eDestTeam$219651[ebp]
	cmp	ecx, DWORD PTR _eTeam1$[ebp]
	jne	$LN5@CancelTrad
$LN4@CancelTrad:

; 1263 : 		{
; 1264 : #ifdef NQM_TEAM_TRADE_ROUTES_CANCELLED_NOT_DESTROYED_FOR_WAR_DEFENDER_ON_DOW
; 1265 : 			if (bReturnUnits)

	movzx	edx, BYTE PTR _bReturnUnits$[ebp]
	test	edx, edx
	je	$LN2@CancelTrad

; 1266 : 			{
; 1267 : 				UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	mov	eax, DWORD PTR _ui$219645[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229420[ebp], eax
	mov	edx, DWORD PTR $T229420[ebp]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	eax, DWORD PTR _ui$219645[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229427[ebp], eax
	mov	edx, DWORD PTR $T229427[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	mov	DWORD PTR _eUnitType$219656[ebp], eax

; 1268 : 				CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1269 : 				if (eUnitType != NO_UNIT)

	cmp	DWORD PTR _eUnitType$219656[ebp], -1
	je	SHORT $LN2@CancelTrad

; 1270 : 				{
; 1271 : 					GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	ecx, DWORD PTR _ui$219645[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229431[ebp], ecx
	mov	eax, DWORD PTR _ui$219645[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229435[ebp], eax
	mov	edx, DWORD PTR _ui$219645[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229439[ebp], edx
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	38					; 00000026H
	mov	ecx, DWORD PTR $T229431[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR $T229435[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eUnitType$219656[ebp]
	push	edx
	mov	eax, DWORD PTR $T229439[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN2@CancelTrad:

; 1272 : 				}
; 1273 : 			}
; 1274 : #endif
; 1275 : 			EmptyTradeRoute(ui);

	mov	ecx, DWORD PTR _ui$219645[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN5@CancelTrad:

; 1276 : 		}

	jmp	$LN8@CancelTrad
$LN11@CancelTrad:

; 1277 : 	}
; 1278 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CancelTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0_N@Z ENDP ; CvGameTrade::CancelTradeBetweenTeams
_TEXT	ENDS
PUBLIC	?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::InvalidateTradeBetweenTeams
; Function compile flags: /Odtp
;	COMDAT ?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T229503 = -56						; size = 4
$T229499 = -52						; size = 4
$T229495 = -48						; size = 4
$T229491 = -44						; size = 4
$T229484 = -40						; size = 4
$T229472 = -36						; size = 4
$T229468 = -32						; size = 4
$T229456 = -28						; size = 4
$T229452 = -24						; size = 4
$T229448 = -20						; size = 4
_eUnitType$219672 = -16					; size = 4
_eLoopDestTeam$219670 = -12				; size = 4
_eLoopOriginTeam$219669 = -8				; size = 4
_ui$219664 = -4						; size = 4
_eOriginTeam$ = 8					; size = 4
_eDestinationTeam$ = 12					; size = 4
?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z PROC ; CvGameTrade::InvalidateTradeBetweenTeams, COMDAT
; _this$ = ecx

; 1283 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1284 : 	// there shouldn't be trade routes between the same team
; 1285 : 	if (eOriginTeam == eDestinationTeam)

	mov	eax, DWORD PTR _eOriginTeam$[ebp]
	cmp	eax, DWORD PTR _eDestinationTeam$[ebp]
	jne	SHORT $LN7@Invalidate

; 1286 : 	{
; 1287 : 		return;

	jmp	$LN8@Invalidate
$LN7@Invalidate:

; 1288 : 	}
; 1289 : 
; 1290 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219664[ebp], 0
	jmp	SHORT $LN6@Invalidate
$LN5@Invalidate:
	mov	ecx, DWORD PTR _ui$219664[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$219664[ebp], ecx
$LN6@Invalidate:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229448[ebp], eax
	mov	ecx, DWORD PTR _ui$219664[ebp]
	cmp	ecx, DWORD PTR $T229448[ebp]
	jae	$LN8@Invalidate

; 1291 : 	{
; 1292 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$219664[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Invalidate

; 1293 : 		{
; 1294 : 			continue;

	jmp	SHORT $LN5@Invalidate
$LN3@Invalidate:

; 1295 : 		}
; 1296 : 
; 1297 : 		TeamTypes eLoopOriginTeam = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).getTeam();

	mov	ecx, DWORD PTR _ui$219664[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229452[ebp], ecx
	mov	eax, DWORD PTR $T229452[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229456[ebp], ecx
	mov	edx, DWORD PTR $T229456[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eLoopOriginTeam$219669[ebp], eax

; 1298 : 		TeamTypes eLoopDestTeam = GET_PLAYER(m_aTradeConnections[ui].m_eDestOwner).getTeam();

	mov	ecx, DWORD PTR _ui$219664[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229468[ebp], ecx
	mov	eax, DWORD PTR $T229468[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229472[ebp], ecx
	mov	edx, DWORD PTR $T229472[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eLoopDestTeam$219670[ebp], eax

; 1299 : 		if (eOriginTeam == eLoopOriginTeam && eLoopDestTeam == eDestinationTeam)

	mov	ecx, DWORD PTR _eOriginTeam$[ebp]
	cmp	ecx, DWORD PTR _eLoopOriginTeam$219669[ebp]
	jne	$LN2@Invalidate
	mov	edx, DWORD PTR _eLoopDestTeam$219670[ebp]
	cmp	edx, DWORD PTR _eDestinationTeam$[ebp]
	jne	$LN2@Invalidate

; 1300 : 		{
; 1301 : 			UnitTypes eUnitType = GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).GetTrade()->GetTradeUnit(m_aTradeConnections[ui].m_eDomain);

	mov	eax, DWORD PTR _ui$219664[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229484[ebp], eax
	mov	edx, DWORD PTR $T229484[ebp]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	eax, DWORD PTR _ui$219664[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229491[ebp], eax
	mov	edx, DWORD PTR $T229491[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	mov	DWORD PTR _eUnitType$219672[ebp], eax

; 1302 : 			CvAssertMsg(eUnitType != NO_UNIT, "No trade unit found");
; 1303 : 			if (eUnitType != NO_UNIT)

	cmp	DWORD PTR _eUnitType$219672[ebp], -1
	je	SHORT $LN1@Invalidate

; 1304 : 			{
; 1305 : 				GET_PLAYER(m_aTradeConnections[ui].m_eOriginOwner).initUnit(eUnitType, m_aTradeConnections[ui].m_iOriginX, m_aTradeConnections[ui].m_iOriginY, UNITAI_TRADE_UNIT);

	mov	ecx, DWORD PTR _ui$219664[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229495[ebp], ecx
	mov	eax, DWORD PTR _ui$219664[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229499[ebp], eax
	mov	edx, DWORD PTR _ui$219664[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229503[ebp], edx
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	38					; 00000026H
	mov	ecx, DWORD PTR $T229495[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR $T229499[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eUnitType$219672[ebp]
	push	edx
	mov	eax, DWORD PTR $T229503[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN1@Invalidate:

; 1306 : 			}
; 1307 : 			EmptyTradeRoute(ui);

	mov	ecx, DWORD PTR _ui$219664[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
$LN2@Invalidate:

; 1308 : 		}

	jmp	$LN5@Invalidate
$LN8@Invalidate:

; 1309 : 	}
; 1310 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?InvalidateTradeBetweenTeams@CvGameTrade@@QAEXW4TeamTypes@@0@Z ENDP ; CvGameTrade::InvalidateTradeBetweenTeams
_TEXT	ENDS
PUBLIC	?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z	; CvPlayerTrade::PlunderTradeRoute
PUBLIC	?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z ; CvGameTrade::DoAutoWarPlundering
EXTRN	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canPlunderTradeRoute
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
; Function compile flags: /Odtp
;	COMDAT ?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z
_TEXT	SEGMENT
tv331 = -140						; size = 4
tv281 = -136						; size = 4
tv66 = -132						; size = 4
_this$ = -128						; size = 4
$T229685 = -124						; size = 4
$T229681 = -120						; size = 4
$T229672 = -116						; size = 4
$T229660 = -112						; size = 4
$T229656 = -108						; size = 4
$T229602 = -104						; size = 4
$T229590 = -100						; size = 4
$T229586 = -93						; size = 1
$T229575 = -92						; size = 4
$T229571 = -85						; size = 1
_iMapY$229638 = -84					; size = 4
_iMapX$229637 = -80					; size = 4
$T229564 = -76						; size = 4
$T229557 = -72						; size = 4
$T229550 = -68						; size = 4
$T229535 = -64						; size = 4
$T229531 = -60						; size = 4
$T229524 = -56						; size = 4
$T229512 = -52						; size = 4
_pLoopUnit$219713 = -48					; size = 4
_iPlotY$219707 = -44					; size = 4
_pPlot$219708 = -40					; size = 4
_iLocationIndex$219705 = -36				; size = 4
_pUnitNode$219709 = -32					; size = 4
_iPlotX$219706 = -28					; size = 4
_uiTradeRoute$219698 = -24				; size = 4
_ePlayer$219695 = -20					; size = 4
_uiPlayer$219691 = -16					; size = 4
_eTRTeam$219683 = -12					; size = 4
_ePlunderTeam$219684 = -8				; size = 4
_uiTeam$219679 = -4					; size = 4
_eTeam1$ = 8						; size = 4
_eTeam2$ = 12						; size = 4
?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z PROC ; CvGameTrade::DoAutoWarPlundering, COMDAT
; _this$ = ecx

; 1316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	DWORD PTR _this$[ebp], ecx

; 1317 : 	// walk through each team
; 1318 : 	for (uint uiTeam = 0; uiTeam < 2; uiTeam++)

	mov	DWORD PTR _uiTeam$219679[ebp], 0
	jmp	SHORT $LN22@DoAutoWarP
$LN21@DoAutoWarP:
	mov	eax, DWORD PTR _uiTeam$219679[ebp]
	add	eax, 1
	mov	DWORD PTR _uiTeam$219679[ebp], eax
$LN22@DoAutoWarP:
	cmp	DWORD PTR _uiTeam$219679[ebp], 2
	jae	$LN23@DoAutoWarP

; 1319 : 	{
; 1320 : 		TeamTypes eTRTeam = NO_TEAM;

	mov	DWORD PTR _eTRTeam$219683[ebp], -1

; 1321 : 		TeamTypes ePlunderTeam = NO_TEAM;

	mov	DWORD PTR _ePlunderTeam$219684[ebp], -1

; 1322 : 		switch (uiTeam)

	mov	ecx, DWORD PTR _uiTeam$219679[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN17@DoAutoWarP
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN16@DoAutoWarP
	jmp	SHORT $LN18@DoAutoWarP
$LN17@DoAutoWarP:

; 1323 : 		{
; 1324 : 		case 0:
; 1325 : 			eTRTeam = eTeam1;

	mov	edx, DWORD PTR _eTeam1$[ebp]
	mov	DWORD PTR _eTRTeam$219683[ebp], edx

; 1326 : 			ePlunderTeam = eTeam2;

	mov	eax, DWORD PTR _eTeam2$[ebp]
	mov	DWORD PTR _ePlunderTeam$219684[ebp], eax

; 1327 : 			break;

	jmp	SHORT $LN18@DoAutoWarP
$LN16@DoAutoWarP:

; 1328 : 		case 1:
; 1329 : 			eTRTeam = eTeam2;

	mov	ecx, DWORD PTR _eTeam2$[ebp]
	mov	DWORD PTR _eTRTeam$219683[ebp], ecx

; 1330 : 			ePlunderTeam = eTeam1;

	mov	edx, DWORD PTR _eTeam1$[ebp]
	mov	DWORD PTR _ePlunderTeam$219684[ebp], edx
$LN18@DoAutoWarP:

; 1331 : 		}
; 1332 : 
; 1333 : 		// walk through each player on the team
; 1334 : 		for (uint uiPlayer = 0; uiPlayer < MAX_MAJOR_CIVS; uiPlayer++)

	mov	DWORD PTR _uiPlayer$219691[ebp], 0
	jmp	SHORT $LN15@DoAutoWarP
$LN14@DoAutoWarP:
	mov	eax, DWORD PTR _uiPlayer$219691[ebp]
	add	eax, 1
	mov	DWORD PTR _uiPlayer$219691[ebp], eax
$LN15@DoAutoWarP:
	cmp	DWORD PTR _uiPlayer$219691[ebp], 22	; 00000016H
	jae	$LN13@DoAutoWarP

; 1335 : 		{
; 1336 : 			PlayerTypes ePlayer = (PlayerTypes)uiPlayer;

	mov	ecx, DWORD PTR _uiPlayer$219691[ebp]
	mov	DWORD PTR _ePlayer$219695[ebp], ecx

; 1337 : 			if (GET_PLAYER(ePlayer).getTeam() != eTRTeam)

	mov	edx, DWORD PTR _ePlayer$219695[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229512[ebp], edx
	mov	eax, DWORD PTR $T229512[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTRTeam$219683[ebp]
	je	SHORT $LN12@DoAutoWarP

; 1338 : 			{
; 1339 : 				continue;

	jmp	SHORT $LN14@DoAutoWarP
$LN12@DoAutoWarP:

; 1340 : 			}
; 1341 : 			
; 1342 : 			// walk through each of the trade routes
; 1343 : 			for (uint uiTradeRoute = 0; uiTradeRoute < m_aTradeConnections.size(); uiTradeRoute++)

	mov	DWORD PTR _uiTradeRoute$219698[ebp], 0
	jmp	SHORT $LN11@DoAutoWarP
$LN10@DoAutoWarP:
	mov	edx, DWORD PTR _uiTradeRoute$219698[ebp]
	add	edx, 1
	mov	DWORD PTR _uiTradeRoute$219698[ebp], edx
$LN11@DoAutoWarP:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229524[ebp], ecx
	mov	edx, DWORD PTR _uiTradeRoute$219698[ebp]
	cmp	edx, DWORD PTR $T229524[ebp]
	jae	$LN9@DoAutoWarP

; 1344 : 			{
; 1345 : 				if (IsTradeRouteIndexEmpty(uiTradeRoute))

	mov	eax, DWORD PTR _uiTradeRoute$219698[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@DoAutoWarP

; 1346 : 				{
; 1347 : 					continue;

	jmp	SHORT $LN10@DoAutoWarP

; 1348 : 				}
; 1349 : 
; 1350 : 				// if it's not my trade route
; 1351 : 				if (m_aTradeConnections[uiTradeRoute].m_eOriginOwner != ePlayer)

$LN33@DoAutoWarP:
	mov	edx, DWORD PTR _uiTradeRoute$219698[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+20]
	cmp	edx, DWORD PTR _ePlayer$219695[ebp]
	je	SHORT $LN7@DoAutoWarP

; 1352 : 				{
; 1353 : 					continue;

	jmp	SHORT $LN10@DoAutoWarP
$LN7@DoAutoWarP:

; 1354 : 				}
; 1355 : 
; 1356 : 				// if the destination is not the civ I'm going to war with
; 1357 : 				if (GET_PLAYER(m_aTradeConnections[uiTradeRoute].m_eDestOwner).getTeam() != ePlunderTeam)

	mov	eax, DWORD PTR _uiTradeRoute$219698[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T229531[ebp], eax
	mov	edx, DWORD PTR $T229531[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229535[ebp], eax
	mov	ecx, DWORD PTR $T229535[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _ePlunderTeam$219684[ebp]
	je	SHORT $LN43@DoAutoWarP

; 1358 : 				{
; 1359 : 					continue;

	jmp	$LN10@DoAutoWarP

; 1360 : 				}
; 1361 : 
; 1362 : 				// get the plot where the trade route is
; 1363 : 				int iLocationIndex = m_aTradeConnections[uiTradeRoute].m_iTradeUnitLocationIndex;

$LN43@DoAutoWarP:
	mov	eax, DWORD PTR _uiTradeRoute$219698[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _iLocationIndex$219705[ebp], eax

; 1364 : 				int iPlotX = m_aTradeConnections[uiTradeRoute].m_aPlotList[iLocationIndex].m_iX;

	mov	ecx, DWORD PTR _uiTradeRoute$219698[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229550[ebp], ecx
	mov	eax, DWORD PTR $T229550[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iLocationIndex$219705[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _iPlotX$219706[ebp], eax

; 1365 : 				int iPlotY = m_aTradeConnections[uiTradeRoute].m_aPlotList[iLocationIndex].m_iY;

	mov	ecx, DWORD PTR _uiTradeRoute$219698[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229557[ebp], ecx
	mov	eax, DWORD PTR $T229557[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iLocationIndex$219705[ebp]
	mov	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _iPlotY$219707[ebp], eax

; 1366 : 				CvPlot* pPlot = GC.getMap().plot(iPlotX, iPlotY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229564[ebp], ecx
	cmp	DWORD PTR _iPlotX$219706[ebp], -2147483647 ; 80000001H
	je	SHORT $LN55@DoAutoWarP
	cmp	DWORD PTR _iPlotY$219707[ebp], -2147483647 ; 80000001H
	jne	SHORT $LN56@DoAutoWarP
$LN55@DoAutoWarP:
	mov	DWORD PTR _pPlot$219708[ebp], 0
	jmp	$LN57@DoAutoWarP
$LN56@DoAutoWarP:
	mov	edx, DWORD PTR $T229564[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T229571[ebp], al
	mov	ecx, DWORD PTR $T229564[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229575[ebp], edx
	movzx	eax, BYTE PTR $T229571[ebp]
	test	eax, eax
	je	SHORT $LN68@DoAutoWarP
	cmp	DWORD PTR _iPlotX$219706[ebp], 0
	jge	SHORT $LN67@DoAutoWarP
	mov	eax, DWORD PTR _iPlotX$219706[ebp]
	cdq
	idiv	DWORD PTR $T229575[ebp]
	add	edx, DWORD PTR $T229575[ebp]
	mov	DWORD PTR _iMapX$229637[ebp], edx
	jmp	SHORT $LN69@DoAutoWarP
	jmp	SHORT $LN68@DoAutoWarP
$LN67@DoAutoWarP:
	mov	ecx, DWORD PTR _iPlotX$219706[ebp]
	cmp	ecx, DWORD PTR $T229575[ebp]
	jl	SHORT $LN68@DoAutoWarP
	mov	eax, DWORD PTR _iPlotX$219706[ebp]
	cdq
	idiv	DWORD PTR $T229575[ebp]
	mov	DWORD PTR _iMapX$229637[ebp], edx
	jmp	SHORT $LN69@DoAutoWarP
$LN68@DoAutoWarP:
	mov	edx, DWORD PTR _iPlotX$219706[ebp]
	mov	DWORD PTR _iMapX$229637[ebp], edx
$LN69@DoAutoWarP:
	mov	eax, DWORD PTR $T229564[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T229586[ebp], cl
	mov	edx, DWORD PTR $T229564[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T229590[ebp], eax
	movzx	ecx, BYTE PTR $T229586[ebp]
	test	ecx, ecx
	je	SHORT $LN78@DoAutoWarP
	cmp	DWORD PTR _iPlotY$219707[ebp], 0
	jge	SHORT $LN77@DoAutoWarP
	mov	eax, DWORD PTR _iPlotY$219707[ebp]
	cdq
	idiv	DWORD PTR $T229590[ebp]
	add	edx, DWORD PTR $T229590[ebp]
	mov	DWORD PTR _iMapY$229638[ebp], edx
	jmp	SHORT $LN79@DoAutoWarP
	jmp	SHORT $LN78@DoAutoWarP
$LN77@DoAutoWarP:
	mov	edx, DWORD PTR _iPlotY$219707[ebp]
	cmp	edx, DWORD PTR $T229590[ebp]
	jl	SHORT $LN78@DoAutoWarP
	mov	eax, DWORD PTR _iPlotY$219707[ebp]
	cdq
	idiv	DWORD PTR $T229590[ebp]
	mov	DWORD PTR _iMapY$229638[ebp], edx
	jmp	SHORT $LN79@DoAutoWarP
$LN78@DoAutoWarP:
	mov	eax, DWORD PTR _iPlotY$219707[ebp]
	mov	DWORD PTR _iMapY$229638[ebp], eax
$LN79@DoAutoWarP:
	mov	ecx, DWORD PTR _iMapY$229638[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$229637[ebp]
	push	edx
	mov	ecx, DWORD PTR $T229564[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN59@DoAutoWarP
	mov	eax, DWORD PTR $T229564[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229602[ebp], ecx
	mov	edx, DWORD PTR _iMapY$229638[ebp]
	imul	edx, DWORD PTR $T229602[ebp]
	add	edx, DWORD PTR _iMapX$229637[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T229564[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv281[ebp], edx
	jmp	SHORT $LN60@DoAutoWarP
$LN59@DoAutoWarP:
	mov	DWORD PTR tv281[ebp], 0
$LN60@DoAutoWarP:
	mov	ecx, DWORD PTR tv281[ebp]
	mov	DWORD PTR _pPlot$219708[ebp], ecx
$LN57@DoAutoWarP:

; 1367 : 
; 1368 : 				// see if there is unit from the other team above it
; 1369 : 				IDInfo* pUnitNode = pPlot->headUnitNode();

	mov	ecx, DWORD PTR _pPlot$219708[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$219709[ebp], eax
$LN5@DoAutoWarP:

; 1370 : 				while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$219709[ebp], 0
	je	$LN4@DoAutoWarP

; 1371 : 				{
; 1372 : 					CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$219709[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN85@DoAutoWarP
	mov	eax, DWORD PTR _pUnitNode$219709[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN85@DoAutoWarP
	mov	ecx, DWORD PTR _pUnitNode$219709[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv331[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$219709[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv331[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv331[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$219713[ebp], eax
	jmp	SHORT $LN86@DoAutoWarP
$LN85@DoAutoWarP:
	mov	DWORD PTR _pLoopUnit$219713[ebp], 0
$LN86@DoAutoWarP:

; 1373 : 					if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$219713[ebp], 0
	je	$LN3@DoAutoWarP

; 1374 : 					{
; 1375 : 						if (GET_PLAYER(pLoopUnit->getOwner()).getTeam() == ePlunderTeam)

	mov	ecx, DWORD PTR _pLoopUnit$219713[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T229656[ebp], edx
	mov	eax, DWORD PTR $T229656[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229660[ebp], eax
	mov	ecx, DWORD PTR $T229660[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _ePlunderTeam$219684[ebp]
	jne	SHORT $LN3@DoAutoWarP

; 1376 : 						{
; 1377 : 							if (pLoopUnit->canPlunderTradeRoute(pPlot, true))

	push	1
	mov	eax, DWORD PTR _pPlot$219708[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$219713[ebp]
	call	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canPlunderTradeRoute
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@DoAutoWarP

; 1378 : 							{
; 1379 : 								// cheating to get around war!
; 1380 : 								GET_PLAYER(pLoopUnit->getOwner()).GetTrade()->PlunderTradeRoute(m_aTradeConnections[uiTradeRoute].m_iID);

	mov	edx, DWORD PTR _uiTradeRoute$219698[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229672[ebp], edx
	mov	ecx, DWORD PTR _pLoopUnit$219713[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T229681[ebp], edx
	mov	eax, DWORD PTR $T229681[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229685[ebp], eax
	mov	ecx, DWORD PTR $T229672[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T229685[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z ; CvPlayerTrade::PlunderTradeRoute

; 1381 : 								break;

	jmp	SHORT $LN4@DoAutoWarP
$LN3@DoAutoWarP:

; 1382 : 							}
; 1383 : 						}
; 1384 : 					}
; 1385 : 
; 1386 : 					pUnitNode = pPlot->nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$219709[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$219708[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$219709[ebp], eax

; 1387 : 				}

	jmp	$LN5@DoAutoWarP
$LN4@DoAutoWarP:

; 1388 : 			}

	jmp	$LN10@DoAutoWarP
$LN9@DoAutoWarP:

; 1389 : 		}

	jmp	$LN14@DoAutoWarP
$LN13@DoAutoWarP:

; 1390 : 	}

	jmp	$LN21@DoAutoWarP
$LN23@DoAutoWarP:

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DoAutoWarPlundering@CvGameTrade@@QAEXW4TeamTypes@@0@Z ENDP ; CvGameTrade::DoAutoWarPlundering
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z ; CvGameTrade::GetNumTradeRoutesInPlot
; Function compile flags: /Odtp
;	COMDAT ?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T229716 = -40						; size = 4
$T229709 = -36						; size = 4
$T229705 = -32						; size = 4
$T229701 = -28						; size = 4
$T229697 = -24						; size = 4
_uiPlot$219729 = -20					; size = 4
_ui$219724 = -16					; size = 4
_iX$ = -12						; size = 4
_iResult$ = -8						; size = 4
_iY$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z PROC ; CvGameTrade::GetNumTradeRoutesInPlot, COMDAT
; _this$ = ecx

; 1399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1400 : 	int iResult = 0;

	mov	DWORD PTR _iResult$[ebp], 0

; 1401 : 	int iX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iX$[ebp], ecx

; 1402 : 	int iY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iY$[ebp], eax

; 1403 : #ifdef AUI_ITERATORIZE
; 1404 : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 1405 : 	{
; 1406 : 		if (IsTradeRouteIndexEmpty(pConnection))
; 1407 : #else
; 1408 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219724[ebp], 0
	jmp	SHORT $LN8@GetNumTrad
$LN7@GetNumTrad:
	mov	ecx, DWORD PTR _ui$219724[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$219724[ebp], ecx
$LN8@GetNumTrad:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229697[ebp], eax
	mov	ecx, DWORD PTR _ui$219724[ebp]
	cmp	ecx, DWORD PTR $T229697[ebp]
	jae	$LN6@GetNumTrad

; 1409 : 	{
; 1410 : 		if (IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$219724[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@GetNumTrad

; 1411 : #endif
; 1412 : 		{
; 1413 : 			continue;

	jmp	SHORT $LN7@GetNumTrad
$LN5@GetNumTrad:

; 1414 : 		}
; 1415 : 
; 1416 : #ifdef AUI_ITERATORIZE
; 1417 : 		for (TradeConnectionPlotList::const_iterator it = pConnection->m_aPlotList.begin(); it != pConnection->m_aPlotList.end(); ++it)
; 1418 : 		{
; 1419 : 			if (it->m_iX == iX && it->m_iY == iY)
; 1420 : #else
; 1421 : 		for (uint uiPlot = 0; uiPlot < m_aTradeConnections[ui].m_aPlotList.size(); uiPlot++)

	mov	DWORD PTR _uiPlot$219729[ebp], 0
	jmp	SHORT $LN4@GetNumTrad
$LN3@GetNumTrad:
	mov	ecx, DWORD PTR _uiPlot$219729[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiPlot$219729[ebp], ecx
$LN4@GetNumTrad:
	mov	edx, DWORD PTR _ui$219724[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229701[ebp], edx
	mov	ecx, DWORD PTR $T229701[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T229705[ebp], edx
	mov	eax, DWORD PTR _uiPlot$219729[ebp]
	cmp	eax, DWORD PTR $T229705[ebp]
	jae	SHORT $LN2@GetNumTrad

; 1422 : 		{
; 1423 : 			if (m_aTradeConnections[ui].m_aPlotList[uiPlot].m_iX == iX && m_aTradeConnections[ui].m_aPlotList[uiPlot].m_iY == iY)

	mov	ecx, DWORD PTR _ui$219724[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229709[ebp], ecx
	mov	eax, DWORD PTR $T229709[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _uiPlot$219729[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	cmp	eax, DWORD PTR _iX$[ebp]
	jne	SHORT $LN1@GetNumTrad
	mov	ecx, DWORD PTR _ui$219724[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T229716[ebp], ecx
	mov	eax, DWORD PTR $T229716[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _uiPlot$219729[ebp]
	mov	eax, DWORD PTR [ecx+edx*8+4]
	cmp	eax, DWORD PTR _iY$[ebp]
	jne	SHORT $LN1@GetNumTrad

; 1424 : #endif
; 1425 : 			{
; 1426 : 				iResult++;

	mov	ecx, DWORD PTR _iResult$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResult$[ebp], ecx
$LN1@GetNumTrad:

; 1427 : 			}
; 1428 : 		}

	jmp	SHORT $LN3@GetNumTrad
$LN2@GetNumTrad:

; 1429 : 	}

	jmp	$LN7@GetNumTrad
$LN6@GetNumTrad:

; 1430 : 
; 1431 : 	return iResult;

	mov	eax, DWORD PTR _iResult$[ebp]

; 1432 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumTradeRoutesInPlot@CvGameTrade@@QAEHPAVCvPlot@@@Z ENDP ; CvGameTrade::GetNumTradeRoutesInPlot
_TEXT	ENDS
PUBLIC	?GetIndexFromID@CvGameTrade@@QAEHH@Z		; CvGameTrade::GetIndexFromID
; Function compile flags: /Odtp
;	COMDAT ?GetIndexFromID@CvGameTrade@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T229725 = -8						; size = 4
_ui$219738 = -4						; size = 4
_iID$ = 8						; size = 4
?GetIndexFromID@CvGameTrade@@QAEHH@Z PROC		; CvGameTrade::GetIndexFromID, COMDAT
; _this$ = ecx

; 1441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1442 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219738[ebp], 0
	jmp	SHORT $LN4@GetIndexFr
$LN3@GetIndexFr:
	mov	eax, DWORD PTR _ui$219738[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219738[ebp], eax
$LN4@GetIndexFr:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229725[ebp], edx
	mov	eax, DWORD PTR _ui$219738[ebp]
	cmp	eax, DWORD PTR $T229725[ebp]
	jae	SHORT $LN2@GetIndexFr

; 1443 : 	{
; 1444 : 		if (m_aTradeConnections[ui].m_iID == iID)

	mov	ecx, DWORD PTR _ui$219738[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax]
	cmp	ecx, DWORD PTR _iID$[ebp]
	jne	SHORT $LN1@GetIndexFr

; 1445 : 		{
; 1446 : 			return ui;

	mov	eax, DWORD PTR _ui$219738[ebp]
	jmp	SHORT $LN5@GetIndexFr
$LN1@GetIndexFr:

; 1447 : 		}
; 1448 : 	}

	jmp	SHORT $LN3@GetIndexFr
$LN2@GetIndexFr:

; 1449 : 
; 1450 : 	return -1;

	or	eax, -1
$LN5@GetIndexFr:

; 1451 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetIndexFromID@CvGameTrade@@QAEHH@Z ENDP		; CvGameTrade::GetIndexFromID
_TEXT	ENDS
PUBLIC	?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ; CvGameTrade::GetOwnerFromID
; Function compile flags: /Odtp
;	COMDAT ?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z PROC ; CvGameTrade::GetOwnerFromID, COMDAT
; _this$ = ecx

; 1460 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1461 : 	int iIndex = GetIndexFromID(iID);

	mov	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromID@CvGameTrade@@QAEHH@Z	; CvGameTrade::GetIndexFromID
	mov	DWORD PTR _iIndex$[ebp], eax

; 1462 : 	if (iIndex < -1)

	cmp	DWORD PTR _iIndex$[ebp], -1
	jge	SHORT $LN4@GetOwnerFr

; 1463 : 	{
; 1464 : 		return NO_PLAYER;

	or	eax, -1
	jmp	SHORT $LN2@GetOwnerFr

; 1465 : 	}
; 1466 : 
; 1467 : 	return m_aTradeConnections[iIndex].m_eOriginOwner;

$LN4@GetOwnerFr:
	mov	ecx, DWORD PTR _iIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx+20]
$LN2@GetOwnerFr:

; 1468 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOwnerFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ENDP ; CvGameTrade::GetOwnerFromID
_TEXT	ENDS
PUBLIC	?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ; CvGameTrade::GetDestFromID
; Function compile flags: /Odtp
;	COMDAT ?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z PROC ; CvGameTrade::GetDestFromID, COMDAT
; _this$ = ecx

; 1477 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1478 : 	int iIndex = GetIndexFromID(iID);

	mov	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromID@CvGameTrade@@QAEHH@Z	; CvGameTrade::GetIndexFromID
	mov	DWORD PTR _iIndex$[ebp], eax

; 1479 : 	if (iIndex < -1)

	cmp	DWORD PTR _iIndex$[ebp], -1
	jge	SHORT $LN4@GetDestFro

; 1480 : 	{
; 1481 : 		return NO_PLAYER;

	or	eax, -1
	jmp	SHORT $LN2@GetDestFro

; 1482 : 	}
; 1483 : 
; 1484 : 	return m_aTradeConnections[iIndex].m_eDestOwner;

$LN4@GetDestFro:
	mov	ecx, DWORD PTR _iIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx+24]
$LN2@GetDestFro:

; 1485 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDestFromID@CvGameTrade@@QAE?AW4PlayerTypes@@H@Z ENDP ; CvGameTrade::GetDestFromID
_TEXT	ENDS
PUBLIC	?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z ; CvGameTrade::GetDomainFromID
; Function compile flags: /Odtp
;	COMDAT ?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z PROC ; CvGameTrade::GetDomainFromID, COMDAT
; _this$ = ecx

; 1491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1492 : 	int iIndex = GetIndexFromID(iID);

	mov	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIndexFromID@CvGameTrade@@QAEHH@Z	; CvGameTrade::GetIndexFromID
	mov	DWORD PTR _iIndex$[ebp], eax

; 1493 : 	if (iIndex < -1)

	cmp	DWORD PTR _iIndex$[ebp], -1
	jge	SHORT $LN4@GetDomainF

; 1494 : 	{
; 1495 : 		return NO_DOMAIN;

	or	eax, -1
	jmp	SHORT $LN2@GetDomainF

; 1496 : 	}
; 1497 : 
; 1498 : 	return m_aTradeConnections[iIndex].m_eDomain;

$LN4@GetDomainF:
	mov	ecx, DWORD PTR _iIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+ecx+28]
$LN2@GetDomainF:

; 1499 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDomainFromID@CvGameTrade@@QAE?AW4DomainTypes@@H@Z ENDP ; CvGameTrade::GetDomainFromID
_TEXT	ENDS
PUBLIC	?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z ; CvGameTrade::GetIndexFromUnitID
; Function compile flags: /Odtp
;	COMDAT ?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T229749 = -8						; size = 4
_ui$219766 = -4						; size = 4
_iUnitID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z PROC ; CvGameTrade::GetIndexFromUnitID, COMDAT
; _this$ = ecx

; 1509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219766[ebp], 0
	jmp	SHORT $LN4@GetIndexFr@2
$LN3@GetIndexFr@2:
	mov	eax, DWORD PTR _ui$219766[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219766[ebp], eax
$LN4@GetIndexFr@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229749[ebp], edx
	mov	eax, DWORD PTR _ui$219766[ebp]
	cmp	eax, DWORD PTR $T229749[ebp]
	jae	SHORT $LN2@GetIndexFr@2

; 1511 : 		if (m_aTradeConnections[ui].m_unitID == iUnitID && m_aTradeConnections[ui].m_eOriginOwner == eOwner)

	mov	ecx, DWORD PTR _ui$219766[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+380]
	cmp	ecx, DWORD PTR _iUnitID$[ebp]
	jne	SHORT $LN1@GetIndexFr@2
	mov	edx, DWORD PTR _ui$219766[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+20]
	cmp	edx, DWORD PTR _eOwner$[ebp]
	jne	SHORT $LN1@GetIndexFr@2

; 1512 : 			return ui;

	mov	eax, DWORD PTR _ui$219766[ebp]
	jmp	SHORT $LN5@GetIndexFr@2
$LN1@GetIndexFr@2:

; 1513 : 	return -1;

	jmp	SHORT $LN3@GetIndexFr@2
$LN2@GetIndexFr@2:
	or	eax, -1
$LN5@GetIndexFr@2:

; 1514 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetIndexFromUnitID@CvGameTrade@@QAEHHW4PlayerTypes@@@Z ENDP ; CvGameTrade::GetIndexFromUnitID
_TEXT	ENDS
PUBLIC	?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z		; CvGameTrade::IsUnitIDUsed
; Function compile flags: /Odtp
;	COMDAT ?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T229761 = -8						; size = 4
_ui$219775 = -4						; size = 4
_iUnitID$ = 8						; size = 4
?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z PROC		; CvGameTrade::IsUnitIDUsed, COMDAT
; _this$ = ecx

; 1523 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1524 : #ifdef AUI_ITERATORIZE
; 1525 : 	for (TradeConnectionList::const_iterator pConnection = m_aTradeConnections.begin(); pConnection != m_aTradeConnections.end(); ++pConnection)
; 1526 : 	{
; 1527 : 		if (pConnection->m_unitID == iUnitID)
; 1528 : #else
; 1529 : 	for (uint ui = 0; ui < m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$219775[ebp], 0
	jmp	SHORT $LN4@IsUnitIDUs
$LN3@IsUnitIDUs:
	mov	eax, DWORD PTR _ui$219775[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219775[ebp], eax
$LN4@IsUnitIDUs:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229761[ebp], edx
	mov	eax, DWORD PTR _ui$219775[ebp]
	cmp	eax, DWORD PTR $T229761[ebp]
	jae	SHORT $LN2@IsUnitIDUs

; 1530 : 	{
; 1531 : 		if (m_aTradeConnections[ui].m_unitID == iUnitID)

	mov	ecx, DWORD PTR _ui$219775[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+380]
	cmp	ecx, DWORD PTR _iUnitID$[ebp]
	jne	SHORT $LN1@IsUnitIDUs

; 1532 : #endif
; 1533 : 		{
; 1534 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@IsUnitIDUs
$LN1@IsUnitIDUs:

; 1535 : 		}
; 1536 : 	}

	jmp	SHORT $LN3@IsUnitIDUs
$LN2@IsUnitIDUs:

; 1537 : 
; 1538 : 	return false;

	xor	al, al
$LN5@IsUnitIDUs:

; 1539 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsUnitIDUsed@CvGameTrade@@QAE_NH@Z ENDP		; CvGameTrade::IsUnitIDUsed
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
; Function compile flags: /Odtp
;	COMDAT ?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z
_TEXT	SEGMENT
tv137 = -64						; size = 4
tv152 = -60						; size = 4
$T229873 = -52						; size = 4
$T229872 = -48						; size = 4
$T229827 = -44						; size = 4
$T229814 = -40						; size = 4
$T229810 = -36						; size = 4
$T229796 = -32						; size = 4
$T229792 = -25						; size = 1
$T229781 = -24						; size = 4
$T229777 = -17						; size = 1
_iMapY$229871 = -16					; size = 4
_iMapX$229870 = -12					; size = 4
$T229770 = -8						; size = 4
_pPlot$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z PROC ; CvGameTrade::GetOriginCity, COMDAT

; 1543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1544 : 	CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229770[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T229873[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229872[ebp], ecx
	cmp	DWORD PTR $T229872[ebp], -2147483647	; 80000001H
	je	SHORT $LN6@GetOriginC
	cmp	DWORD PTR $T229873[ebp], -2147483647	; 80000001H
	jne	SHORT $LN7@GetOriginC
$LN6@GetOriginC:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN8@GetOriginC
$LN7@GetOriginC:
	mov	edx, DWORD PTR $T229770[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T229777[ebp], al
	mov	ecx, DWORD PTR $T229770[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229781[ebp], edx
	movzx	eax, BYTE PTR $T229777[ebp]
	test	eax, eax
	je	SHORT $LN19@GetOriginC
	cmp	DWORD PTR $T229872[ebp], 0
	jge	SHORT $LN18@GetOriginC
	mov	eax, DWORD PTR $T229872[ebp]
	cdq
	idiv	DWORD PTR $T229781[ebp]
	add	edx, DWORD PTR $T229781[ebp]
	mov	DWORD PTR _iMapX$229870[ebp], edx
	jmp	SHORT $LN20@GetOriginC
	jmp	SHORT $LN19@GetOriginC
$LN18@GetOriginC:
	mov	ecx, DWORD PTR $T229872[ebp]
	cmp	ecx, DWORD PTR $T229781[ebp]
	jl	SHORT $LN19@GetOriginC
	mov	eax, DWORD PTR $T229872[ebp]
	cdq
	idiv	DWORD PTR $T229781[ebp]
	mov	DWORD PTR _iMapX$229870[ebp], edx
	jmp	SHORT $LN20@GetOriginC
$LN19@GetOriginC:
	mov	edx, DWORD PTR $T229872[ebp]
	mov	DWORD PTR _iMapX$229870[ebp], edx
$LN20@GetOriginC:
	mov	eax, DWORD PTR $T229770[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T229792[ebp], cl
	mov	edx, DWORD PTR $T229770[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T229796[ebp], eax
	movzx	ecx, BYTE PTR $T229792[ebp]
	test	ecx, ecx
	je	SHORT $LN29@GetOriginC
	cmp	DWORD PTR $T229873[ebp], 0
	jge	SHORT $LN28@GetOriginC
	mov	eax, DWORD PTR $T229873[ebp]
	cdq
	idiv	DWORD PTR $T229796[ebp]
	add	edx, DWORD PTR $T229796[ebp]
	mov	DWORD PTR _iMapY$229871[ebp], edx
	jmp	SHORT $LN30@GetOriginC
	jmp	SHORT $LN29@GetOriginC
$LN28@GetOriginC:
	mov	edx, DWORD PTR $T229873[ebp]
	cmp	edx, DWORD PTR $T229796[ebp]
	jl	SHORT $LN29@GetOriginC
	mov	eax, DWORD PTR $T229873[ebp]
	cdq
	idiv	DWORD PTR $T229796[ebp]
	mov	DWORD PTR _iMapY$229871[ebp], edx
	jmp	SHORT $LN30@GetOriginC
$LN29@GetOriginC:
	mov	eax, DWORD PTR $T229873[ebp]
	mov	DWORD PTR _iMapY$229871[ebp], eax
$LN30@GetOriginC:
	cmp	DWORD PTR _iMapX$229870[ebp], 0
	jl	SHORT $LN34@GetOriginC
	mov	ecx, DWORD PTR $T229770[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229810[ebp], edx
	mov	eax, DWORD PTR _iMapX$229870[ebp]
	cmp	eax, DWORD PTR $T229810[ebp]
	jge	SHORT $LN34@GetOriginC
	cmp	DWORD PTR _iMapY$229871[ebp], 0
	jl	SHORT $LN34@GetOriginC
	mov	ecx, DWORD PTR $T229770[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T229814[ebp], edx
	mov	eax, DWORD PTR _iMapY$229871[ebp]
	cmp	eax, DWORD PTR $T229814[ebp]
	jge	SHORT $LN34@GetOriginC
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN32@GetOriginC
$LN34@GetOriginC:
	mov	DWORD PTR tv152[ebp], 0
$LN32@GetOriginC:
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN10@GetOriginC
	mov	ecx, DWORD PTR $T229770[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229827[ebp], edx
	mov	eax, DWORD PTR _iMapY$229871[ebp]
	imul	eax, DWORD PTR $T229827[ebp]
	add	eax, DWORD PTR _iMapX$229870[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T229770[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN11@GetOriginC
$LN10@GetOriginC:
	mov	DWORD PTR tv137[ebp], 0
$LN11@GetOriginC:
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR _pPlot$[ebp], edx
$LN8@GetOriginC:

; 1545 : 
; 1546 : 	CvAssertMsg(pPlot, "CvPlayerTrade - plot is null");
; 1547 : 	if (!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN1@GetOriginC

; 1548 : 	{
; 1549 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN2@GetOriginC
$LN1@GetOriginC:

; 1550 : 	}
; 1551 : 
; 1552 : 	return pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
$LN2@GetOriginC:

; 1553 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ENDP ; CvGameTrade::GetOriginCity
_TEXT	ENDS
PUBLIC	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity
; Function compile flags: /Odtp
;	COMDAT ?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z
_TEXT	SEGMENT
tv137 = -64						; size = 4
tv152 = -60						; size = 4
$T229987 = -52						; size = 4
$T229986 = -48						; size = 4
$T229941 = -44						; size = 4
$T229928 = -40						; size = 4
$T229924 = -36						; size = 4
$T229910 = -32						; size = 4
$T229906 = -25						; size = 1
$T229895 = -24						; size = 4
$T229891 = -17						; size = 1
_iMapY$229985 = -16					; size = 4
_iMapX$229984 = -12					; size = 4
$T229884 = -8						; size = 4
_pPlot$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z PROC ; CvGameTrade::GetDestCity, COMDAT

; 1557 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1558 : 	CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T229884[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T229987[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T229986[ebp], ecx
	cmp	DWORD PTR $T229986[ebp], -2147483647	; 80000001H
	je	SHORT $LN6@GetDestCit
	cmp	DWORD PTR $T229987[ebp], -2147483647	; 80000001H
	jne	SHORT $LN7@GetDestCit
$LN6@GetDestCit:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN8@GetDestCit
$LN7@GetDestCit:
	mov	edx, DWORD PTR $T229884[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T229891[ebp], al
	mov	ecx, DWORD PTR $T229884[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229895[ebp], edx
	movzx	eax, BYTE PTR $T229891[ebp]
	test	eax, eax
	je	SHORT $LN19@GetDestCit
	cmp	DWORD PTR $T229986[ebp], 0
	jge	SHORT $LN18@GetDestCit
	mov	eax, DWORD PTR $T229986[ebp]
	cdq
	idiv	DWORD PTR $T229895[ebp]
	add	edx, DWORD PTR $T229895[ebp]
	mov	DWORD PTR _iMapX$229984[ebp], edx
	jmp	SHORT $LN20@GetDestCit
	jmp	SHORT $LN19@GetDestCit
$LN18@GetDestCit:
	mov	ecx, DWORD PTR $T229986[ebp]
	cmp	ecx, DWORD PTR $T229895[ebp]
	jl	SHORT $LN19@GetDestCit
	mov	eax, DWORD PTR $T229986[ebp]
	cdq
	idiv	DWORD PTR $T229895[ebp]
	mov	DWORD PTR _iMapX$229984[ebp], edx
	jmp	SHORT $LN20@GetDestCit
$LN19@GetDestCit:
	mov	edx, DWORD PTR $T229986[ebp]
	mov	DWORD PTR _iMapX$229984[ebp], edx
$LN20@GetDestCit:
	mov	eax, DWORD PTR $T229884[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T229906[ebp], cl
	mov	edx, DWORD PTR $T229884[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T229910[ebp], eax
	movzx	ecx, BYTE PTR $T229906[ebp]
	test	ecx, ecx
	je	SHORT $LN29@GetDestCit
	cmp	DWORD PTR $T229987[ebp], 0
	jge	SHORT $LN28@GetDestCit
	mov	eax, DWORD PTR $T229987[ebp]
	cdq
	idiv	DWORD PTR $T229910[ebp]
	add	edx, DWORD PTR $T229910[ebp]
	mov	DWORD PTR _iMapY$229985[ebp], edx
	jmp	SHORT $LN30@GetDestCit
	jmp	SHORT $LN29@GetDestCit
$LN28@GetDestCit:
	mov	edx, DWORD PTR $T229987[ebp]
	cmp	edx, DWORD PTR $T229910[ebp]
	jl	SHORT $LN29@GetDestCit
	mov	eax, DWORD PTR $T229987[ebp]
	cdq
	idiv	DWORD PTR $T229910[ebp]
	mov	DWORD PTR _iMapY$229985[ebp], edx
	jmp	SHORT $LN30@GetDestCit
$LN29@GetDestCit:
	mov	eax, DWORD PTR $T229987[ebp]
	mov	DWORD PTR _iMapY$229985[ebp], eax
$LN30@GetDestCit:
	cmp	DWORD PTR _iMapX$229984[ebp], 0
	jl	SHORT $LN34@GetDestCit
	mov	ecx, DWORD PTR $T229884[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229924[ebp], edx
	mov	eax, DWORD PTR _iMapX$229984[ebp]
	cmp	eax, DWORD PTR $T229924[ebp]
	jge	SHORT $LN34@GetDestCit
	cmp	DWORD PTR _iMapY$229985[ebp], 0
	jl	SHORT $LN34@GetDestCit
	mov	ecx, DWORD PTR $T229884[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T229928[ebp], edx
	mov	eax, DWORD PTR _iMapY$229985[ebp]
	cmp	eax, DWORD PTR $T229928[ebp]
	jge	SHORT $LN34@GetDestCit
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN32@GetDestCit
$LN34@GetDestCit:
	mov	DWORD PTR tv152[ebp], 0
$LN32@GetDestCit:
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN10@GetDestCit
	mov	ecx, DWORD PTR $T229884[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T229941[ebp], edx
	mov	eax, DWORD PTR _iMapY$229985[ebp]
	imul	eax, DWORD PTR $T229941[ebp]
	add	eax, DWORD PTR _iMapX$229984[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T229884[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN11@GetDestCit
$LN10@GetDestCit:
	mov	DWORD PTR tv137[ebp], 0
$LN11@GetDestCit:
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR _pPlot$[ebp], edx
$LN8@GetDestCit:

; 1559 : 
; 1560 : 	CvAssertMsg(pPlot, "CvPlayerTrade - plot is null");
; 1561 : 	if (!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN1@GetDestCit

; 1562 : 	{
; 1563 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN2@GetDestCit
$LN1@GetDestCit:

; 1564 : 	}
; 1565 : 
; 1566 : 	return pPlot->getPlotCity();	

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
$LN2@GetDestCit:

; 1567 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ENDP ; CvGameTrade::GetDestCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ResetTechDifference@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_ui2$219797 = -8					; size = 4
_ui$219793 = -4						; size = 4
?ResetTechDifference@CvGameTrade@@QAEXXZ PROC		; CvGameTrade::ResetTechDifference, COMDAT
; _this$ = ecx

; 1590 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1591 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$219793[ebp], 0
	jmp	SHORT $LN6@ResetTechD
$LN5@ResetTechD:
	mov	eax, DWORD PTR _ui$219793[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$219793[ebp], eax
$LN6@ResetTechD:
	cmp	DWORD PTR _ui$219793[ebp], 22		; 00000016H
	jae	SHORT $LN7@ResetTechD

; 1592 : 	{
; 1593 : 		for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)

	mov	DWORD PTR _ui2$219797[ebp], 0
	jmp	SHORT $LN3@ResetTechD
$LN2@ResetTechD:
	mov	ecx, DWORD PTR _ui2$219797[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui2$219797[ebp], ecx
$LN3@ResetTechD:
	cmp	DWORD PTR _ui2$219797[ebp], 22		; 00000016H
	jae	SHORT $LN1@ResetTechD

; 1594 : 		{
; 1595 : 			m_aaiTechDifference[ui][ui2] = -1; // undefined

	mov	edx, DWORD PTR _ui$219793[ebp]
	imul	edx, 88					; 00000058H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+74612]
	mov	edx, DWORD PTR _ui2$219797[ebp]
	mov	DWORD PTR [ecx+edx*4], -1

; 1596 : #endif
; 1597 : 		}

	jmp	SHORT $LN2@ResetTechD
$LN1@ResetTechD:

; 1598 : 	}

	jmp	SHORT $LN5@ResetTechD
$LN7@ResetTechD:

; 1599 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResetTechDifference@CvGameTrade@@QAEXXZ ENDP		; CvGameTrade::ResetTechDifference
_TEXT	ENDS
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?GetNumTechs@CvTechXMLEntries@@QAEHXZ:PROC	; CvTechXMLEntries::GetNumTechs
EXTRN	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ:PROC ; CvPlayerTechs::GetTechs
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
; Function compile flags: /Odtp
;	COMDAT ?BuildTechDifference@CvGameTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T230062 = -88						; size = 4
$T230058 = -84						; size = 4
$T230054 = -80						; size = 4
$T230050 = -73						; size = 1
$T230041 = -72						; size = 4
$T230037 = -65						; size = 1
$T230028 = -64						; size = 4
$T230016 = -60						; size = 4
$T230004 = -56						; size = 4
$T230000 = -52						; size = 4
_bPlayer2Knows$219833 = -45				; size = 1
_eTech$219830 = -44					; size = 4
_bPlayer1Knows$219832 = -37				; size = 1
_iTechLoop$219826 = -36					; size = 4
_iTechDifference$219824 = -32				; size = 4
_pPlayerTechs$219825 = -28				; size = 4
_eTeam2$219818 = -24					; size = 4
_ePlayer2$219816 = -20					; size = 4
_uiPlayer2$219812 = -16					; size = 4
_ePlayer1$219809 = -12					; size = 4
_eTeam1$219811 = -8					; size = 4
_uiPlayer1$219805 = -4					; size = 4
?BuildTechDifference@CvGameTrade@@QAEXXZ PROC		; CvGameTrade::BuildTechDifference, COMDAT
; _this$ = ecx

; 1607 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1608 : 	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230000[ebp], eax
	push	17					; 00000011H
	mov	ecx, DWORD PTR $T230000[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@BuildTechD

; 1609 : 	{
; 1610 : 		return;

	jmp	$LN17@BuildTechD
$LN16@BuildTechD:

; 1611 : 	}
; 1612 : 
; 1613 : 	// for each major civ
; 1614 : #ifdef AUI_YIELDS_APPLIED_AFTER_TURN_NOT_BEFORE
; 1615 : 	if (eForPlayer == NO_PLAYER)
; 1616 : 	{
; 1617 : 		for (uint uiPlayer1 = 0; uiPlayer1 < MAX_MAJOR_CIVS; uiPlayer1++)
; 1618 : 		{
; 1619 : 			PlayerTypes ePlayer1 = (PlayerTypes)uiPlayer1;
; 1620 : 			TeamTypes eTeam1 = GET_PLAYER(ePlayer1).getTeam();
; 1621 : 
; 1622 : 			for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)
; 1623 : 			{
; 1624 : 				PlayerTypes ePlayer2 = (PlayerTypes)uiPlayer2;
; 1625 : 				TeamTypes eTeam2 = GET_PLAYER(ePlayer2).getTeam();
; 1626 : 
; 1627 : 				if (eTeam1 == eTeam2)
; 1628 : 				{
; 1629 : 					m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;
; 1630 : 				}
; 1631 : 				else if (!GET_PLAYER(ePlayer1).isAlive() || !GET_PLAYER(ePlayer2).isAlive())
; 1632 : 				{
; 1633 : 					m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;
; 1634 : 				}
; 1635 : 				else
; 1636 : 				{
; 1637 : 					int iTechDifference = 0;
; 1638 : 
; 1639 : 					CvPlayerTechs* pPlayerTechs = GET_PLAYER(ePlayer1).GetPlayerTechs();
; 1640 : 					for (uint iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 1641 : 					{
; 1642 : 						TechTypes eTech = (TechTypes)iTechLoop;
; 1643 : 						bool bPlayer1Knows = GET_TEAM(eTeam1).GetTeamTechs()->HasTech(eTech);
; 1644 : 						bool bPlayer2Knows = GET_TEAM(eTeam2).GetTeamTechs()->HasTech(eTech);
; 1645 : 						if (bPlayer2Knows && !bPlayer1Knows)
; 1646 : 						{
; 1647 : 							iTechDifference++;
; 1648 : 						}
; 1649 : 					}
; 1650 : 
; 1651 : 					m_aaiTechDifference[uiPlayer1][uiPlayer2] = iTechDifference;
; 1652 : 				}
; 1653 : 			}
; 1654 : 		}
; 1655 : 	}
; 1656 : 	else
; 1657 : 	{
; 1658 : 		TeamTypes eTeam1 = GET_PLAYER(eForPlayer).getTeam();
; 1659 : 
; 1660 : 		for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)
; 1661 : 		{
; 1662 : 			PlayerTypes ePlayer2 = (PlayerTypes)uiPlayer2;
; 1663 : 			TeamTypes eTeam2 = GET_PLAYER(ePlayer2).getTeam();
; 1664 : 
; 1665 : 			if (eTeam1 == eTeam2)
; 1666 : 			{
; 1667 : 				m_aaiTechDifference[eForPlayer][uiPlayer2] = 0;
; 1668 : 			}
; 1669 : 			else if (!GET_PLAYER(eForPlayer).isAlive() || !GET_PLAYER(ePlayer2).isAlive())
; 1670 : 			{
; 1671 : 				m_aaiTechDifference[eForPlayer][uiPlayer2] = 0;
; 1672 : 			}
; 1673 : 			else
; 1674 : 			{
; 1675 : 				int iTechDifference = 0;
; 1676 : 
; 1677 : 				CvPlayerTechs* pPlayerTechs = GET_PLAYER(eForPlayer).GetPlayerTechs();
; 1678 : 				for (uint iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 1679 : 				{
; 1680 : 					TechTypes eTech = (TechTypes)iTechLoop;
; 1681 : 					bool bPlayer1Knows = GET_TEAM(eTeam1).GetTeamTechs()->HasTech(eTech);
; 1682 : 					bool bPlayer2Knows = GET_TEAM(eTeam2).GetTeamTechs()->HasTech(eTech);
; 1683 : 					if (bPlayer2Knows && !bPlayer1Knows)
; 1684 : 					{
; 1685 : 						iTechDifference++;
; 1686 : 					}
; 1687 : 				}
; 1688 : 
; 1689 : 				m_aaiTechDifference[eForPlayer][uiPlayer2] = iTechDifference;
; 1690 : 			}
; 1691 : 		}
; 1692 : 	}
; 1693 : #else
; 1694 : 	for (uint uiPlayer1 = 0; uiPlayer1 < MAX_MAJOR_CIVS; uiPlayer1++)

	mov	DWORD PTR _uiPlayer1$219805[ebp], 0
	jmp	SHORT $LN15@BuildTechD
$LN14@BuildTechD:
	mov	edx, DWORD PTR _uiPlayer1$219805[ebp]
	add	edx, 1
	mov	DWORD PTR _uiPlayer1$219805[ebp], edx
$LN15@BuildTechD:
	cmp	DWORD PTR _uiPlayer1$219805[ebp], 22	; 00000016H
	jae	$LN17@BuildTechD

; 1695 : 	{
; 1696 : 		PlayerTypes ePlayer1 = (PlayerTypes)uiPlayer1;

	mov	eax, DWORD PTR _uiPlayer1$219805[ebp]
	mov	DWORD PTR _ePlayer1$219809[ebp], eax

; 1697 : 		TeamTypes eTeam1 = GET_PLAYER(ePlayer1).getTeam();

	mov	ecx, DWORD PTR _ePlayer1$219809[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230004[ebp], ecx
	mov	edx, DWORD PTR $T230004[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam1$219811[ebp], eax

; 1698 : 
; 1699 : 		for (uint uiPlayer2 = 0; uiPlayer2 < MAX_MAJOR_CIVS; uiPlayer2++)

	mov	DWORD PTR _uiPlayer2$219812[ebp], 0
	jmp	SHORT $LN12@BuildTechD
$LN11@BuildTechD:
	mov	ecx, DWORD PTR _uiPlayer2$219812[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiPlayer2$219812[ebp], ecx
$LN12@BuildTechD:
	cmp	DWORD PTR _uiPlayer2$219812[ebp], 22	; 00000016H
	jae	$LN10@BuildTechD

; 1700 : 		{	
; 1701 : 			PlayerTypes ePlayer2 = (PlayerTypes)uiPlayer2;

	mov	edx, DWORD PTR _uiPlayer2$219812[ebp]
	mov	DWORD PTR _ePlayer2$219816[ebp], edx

; 1702 : 			TeamTypes eTeam2 = GET_PLAYER(ePlayer2).getTeam();

	mov	eax, DWORD PTR _ePlayer2$219816[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230016[ebp], eax
	mov	ecx, DWORD PTR $T230016[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam2$219818[ebp], eax

; 1703 : 
; 1704 : 			if (eTeam1 == eTeam2) 

	mov	eax, DWORD PTR _eTeam1$219811[ebp]
	cmp	eax, DWORD PTR _eTeam2$219818[ebp]
	jne	SHORT $LN9@BuildTechD

; 1705 : 			{
; 1706 : 				m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;

	mov	ecx, DWORD PTR _uiPlayer1$219805[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+74612]
	mov	ecx, DWORD PTR _uiPlayer2$219812[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
	jmp	$LN8@BuildTechD
$LN9@BuildTechD:

; 1707 : 			}
; 1708 : 			else if (!GET_PLAYER(ePlayer1).isAlive() || !GET_PLAYER(ePlayer2).isAlive())

	mov	edx, DWORD PTR _ePlayer1$219809[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230028[ebp], edx
	mov	eax, DWORD PTR $T230028[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T230037[ebp], cl
	movzx	edx, BYTE PTR $T230037[ebp]
	test	edx, edx
	je	SHORT $LN6@BuildTechD
	mov	eax, DWORD PTR _ePlayer2$219816[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230041[ebp], eax
	mov	ecx, DWORD PTR $T230041[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T230050[ebp], dl
	movzx	eax, BYTE PTR $T230050[ebp]
	test	eax, eax
	jne	SHORT $LN7@BuildTechD
$LN6@BuildTechD:

; 1709 : 			{
; 1710 : 				m_aaiTechDifference[uiPlayer1][uiPlayer2] = 0;

	mov	ecx, DWORD PTR _uiPlayer1$219805[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+74612]
	mov	ecx, DWORD PTR _uiPlayer2$219812[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 1711 : 			}
; 1712 : 			else

	jmp	$LN8@BuildTechD
$LN7@BuildTechD:

; 1713 : 			{
; 1714 : 				int iTechDifference = 0;

	mov	DWORD PTR _iTechDifference$219824[ebp], 0

; 1715 : 				
; 1716 : 				CvPlayerTechs* pPlayerTechs = GET_PLAYER(ePlayer1).GetPlayerTechs();

	mov	edx, DWORD PTR _ePlayer1$219809[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230054[ebp], edx
	mov	ecx, DWORD PTR $T230054[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	DWORD PTR _pPlayerTechs$219825[ebp], eax

; 1717 : #ifdef AUI_WARNING_FIXES
; 1718 : 				for (uint iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 1719 : #else
; 1720 : 				for(int iTechLoop = 0; iTechLoop < pPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$219826[ebp], 0
	jmp	SHORT $LN4@BuildTechD
$LN3@BuildTechD:
	mov	eax, DWORD PTR _iTechLoop$219826[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$219826[ebp], eax
$LN4@BuildTechD:
	mov	ecx, DWORD PTR _pPlayerTechs$219825[ebp]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTechLoop$219826[ebp], eax
	jge	SHORT $LN2@BuildTechD

; 1721 : #endif
; 1722 : 				{
; 1723 : 					TechTypes eTech = (TechTypes)iTechLoop;

	mov	ecx, DWORD PTR _iTechLoop$219826[ebp]
	mov	DWORD PTR _eTech$219830[ebp], ecx

; 1724 : 					bool bPlayer1Knows = GET_TEAM(eTeam1).GetTeamTechs()->HasTech(eTech);

	mov	edx, DWORD PTR _eTeam1$219811[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T230058[ebp], edx
	mov	eax, DWORD PTR _eTech$219830[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230058[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	mov	BYTE PTR _bPlayer1Knows$219832[ebp], al

; 1725 : 					bool bPlayer2Knows = GET_TEAM(eTeam2).GetTeamTechs()->HasTech(eTech);

	mov	ecx, DWORD PTR _eTeam2$219818[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T230062[ebp], ecx
	mov	edx, DWORD PTR _eTech$219830[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230062[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	mov	BYTE PTR _bPlayer2Knows$219833[ebp], al

; 1726 : 					if (bPlayer2Knows && !bPlayer1Knows)

	movzx	eax, BYTE PTR _bPlayer2Knows$219833[ebp]
	test	eax, eax
	je	SHORT $LN1@BuildTechD
	movzx	ecx, BYTE PTR _bPlayer1Knows$219832[ebp]
	test	ecx, ecx
	jne	SHORT $LN1@BuildTechD

; 1727 : 					{
; 1728 : 						iTechDifference++;

	mov	edx, DWORD PTR _iTechDifference$219824[ebp]
	add	edx, 1
	mov	DWORD PTR _iTechDifference$219824[ebp], edx
$LN1@BuildTechD:

; 1729 : 					}
; 1730 : 				}

	jmp	$LN3@BuildTechD
$LN2@BuildTechD:

; 1731 : 
; 1732 : 				m_aaiTechDifference[uiPlayer1][uiPlayer2] = iTechDifference;

	mov	eax, DWORD PTR _uiPlayer1$219805[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+74612]
	mov	eax, DWORD PTR _uiPlayer2$219812[ebp]
	mov	ecx, DWORD PTR _iTechDifference$219824[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN8@BuildTechD:

; 1733 : 			}
; 1734 : 		}

	jmp	$LN11@BuildTechD
$LN10@BuildTechD:

; 1735 : 	}

	jmp	$LN14@BuildTechD
$LN17@BuildTechD:

; 1736 : #endif
; 1737 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildTechDifference@CvGameTrade@@QAEXXZ ENDP		; CvGameTrade::BuildTechDifference
_TEXT	ENDS
PUBLIC	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T230084 = -20						; size = 4
$T230080 = -16						; size = 4
$T230076 = -12						; size = 4
$T230072 = -8						; size = 4
$T230068 = -4						; size = 4
_ePlayer$ = 8						; size = 4
_ePlayer2$ = 12						; size = 4
?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z PROC ; CvGameTrade::GetTechDifference, COMDAT
; _this$ = ecx

; 1745 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1746 : 	if(GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230068[ebp], eax
	push	17					; 00000011H
	mov	ecx, DWORD PTR $T230068[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@GetTechDif

; 1747 : 	{
; 1748 : 		return 0;

	xor	eax, eax
	jmp	$LN6@GetTechDif
$LN5@GetTechDif:

; 1749 : 	}
; 1750 : 
; 1751 : 	if (GET_PLAYER(ePlayer).isMinorCiv() || GET_PLAYER(ePlayer).isBarbarian())

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230072[ebp], edx
	mov	ecx, DWORD PTR $T230072[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@GetTechDif
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230076[ebp], ecx
	mov	ecx, DWORD PTR $T230076[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@GetTechDif
$LN3@GetTechDif:

; 1752 : 	{
; 1753 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN6@GetTechDif
$LN4@GetTechDif:

; 1754 : 	}
; 1755 : 
; 1756 : 	if (GET_PLAYER(ePlayer2).isMinorCiv() || GET_PLAYER(ePlayer2).isBarbarian())

	mov	eax, DWORD PTR _ePlayer2$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230080[ebp], eax
	mov	ecx, DWORD PTR $T230080[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetTechDif
	mov	edx, DWORD PTR _ePlayer2$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230084[ebp], edx
	mov	ecx, DWORD PTR $T230084[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetTechDif
$LN1@GetTechDif:

; 1757 : 	{
; 1758 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN6@GetTechDif
$LN2@GetTechDif:

; 1759 : 	}
; 1760 : 
; 1761 : 	return m_aaiTechDifference[ePlayer][ePlayer2];

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+74612]
	mov	ecx, DWORD PTR _ePlayer2$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
$LN6@GetTechDif:

; 1762 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ENDP ; CvGameTrade::GetTechDifference
_TEXT	ENDS
PUBLIC	?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z		; CvGameTrade::GetVis
PUBLIC	?StepUnit@CvGameTrade@@QAE_NH@Z			; CvGameTrade::StepUnit
EXTRN	?setMoves@CvUnit@@QAEXH@Z:PROC			; CvUnit::setMoves
EXTRN	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z:PROC ; CvUnit::UnitMove
; Function compile flags: /Odtp
;	COMDAT ?MoveUnit@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
tv141 = -40						; size = 4
_this$ = -36						; size = 4
$T230101 = -32						; size = 4
$T230097 = -28						; size = 4
$T230090 = -24						; size = 4
_bAbleToStep$219859 = -17				; size = 1
_i$219854 = -16						; size = 4
_pkUnit$ = -12						; size = 4
_iMoves$ = -8						; size = 4
_kTradeConnection$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?MoveUnit@CvGameTrade@@QAE_NH@Z PROC			; CvGameTrade::MoveUnit, COMDAT
; _this$ = ecx

; 1767 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1768 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1769 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN7@MoveUnit
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230090[ebp], ecx
	mov	edx, DWORD PTR _iIndex$[ebp]
	cmp	edx, DWORD PTR $T230090[ebp]
	jl	SHORT $LN13@MoveUnit
$LN7@MoveUnit:

; 1770 : 	{
; 1771 : 		return false;

	xor	al, al
	jmp	$LN9@MoveUnit

; 1772 : 	}
; 1773 : 
; 1774 : 	TradeConnection &kTradeConnection = m_aTradeConnections[iIndex];

$LN13@MoveUnit:
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _kTradeConnection$[ebp], eax

; 1775 : 	int iMoves = GET_PLAYER(kTradeConnection.m_eOriginOwner).GetTrade()->GetTradeRouteSpeed(kTradeConnection.m_eDomain);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230097[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	ecx, DWORD PTR $T230097[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z ; CvPlayerTrade::GetTradeRouteSpeed
	mov	DWORD PTR _iMoves$[ebp], eax

; 1776 : 	for (int i = 0; i < iMoves; i++)

	mov	DWORD PTR _i$219854[ebp], 0
	jmp	SHORT $LN6@MoveUnit
$LN5@MoveUnit:
	mov	eax, DWORD PTR _i$219854[ebp]
	add	eax, 1
	mov	DWORD PTR _i$219854[ebp], eax
$LN6@MoveUnit:
	mov	ecx, DWORD PTR _i$219854[ebp]
	cmp	ecx, DWORD PTR _iMoves$[ebp]
	jge	SHORT $LN4@MoveUnit

; 1777 : 	{
; 1778 : 		if (kTradeConnection.m_iCircuitsCompleted >= kTradeConnection.m_iCircuitsToComplete)

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [edx+384]
	cmp	ecx, DWORD PTR [eax+388]
	jl	SHORT $LN3@MoveUnit

; 1779 : 		{
; 1780 : 			break;

	jmp	SHORT $LN4@MoveUnit
$LN3@MoveUnit:

; 1781 : 		}
; 1782 : 
; 1783 : 		bool bAbleToStep = StepUnit(iIndex);

	mov	edx, DWORD PTR _iIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StepUnit@CvGameTrade@@QAE_NH@Z		; CvGameTrade::StepUnit
	mov	BYTE PTR _bAbleToStep$219859[ebp], al

; 1784 : 		if (!bAbleToStep)

	movzx	eax, BYTE PTR _bAbleToStep$219859[ebp]
	test	eax, eax
	jne	SHORT $LN2@MoveUnit

; 1785 : 		{
; 1786 : 			break;

	jmp	SHORT $LN4@MoveUnit
$LN2@MoveUnit:

; 1787 : 		}
; 1788 : 	}

	jmp	SHORT $LN5@MoveUnit
$LN4@MoveUnit:

; 1789 : 
; 1790 : 	gDLL->TradeVisuals_UpdateRouteDirection(iIndex, kTradeConnection.m_bTradeUnitMovingForward);

	mov	ecx, DWORD PTR $T230101[ebp]
	mov	DWORD PTR tv141[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _iIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR tv141[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv141[ebp]
	mov	eax, DWORD PTR [edx+976]
	call	eax

; 1791 : 
; 1792 : 	// Send a NULL plot move to say we are complete to the vis unit.
; 1793 : 	CvUnit *pkUnit = GetVis(iIndex);

	mov	ecx, DWORD PTR _iIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z	; CvGameTrade::GetVis
	mov	DWORD PTR _pkUnit$[ebp], eax

; 1794 : 	if (pkUnit)

	cmp	DWORD PTR _pkUnit$[ebp], 0
	je	SHORT $LN1@MoveUnit

; 1795 : 	{
; 1796 : 		pkUnit->UnitMove(NULL, false, NULL);

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pkUnit$[ebp]
	call	?UnitMove@CvUnit@@QAE_NPAVCvPlot@@_NPAV1@1@Z ; CvUnit::UnitMove

; 1797 : 		pkUnit->setMoves(0);

	push	0
	mov	ecx, DWORD PTR _pkUnit$[ebp]
	call	?setMoves@CvUnit@@QAEXH@Z		; CvUnit::setMoves
$LN1@MoveUnit:

; 1798 : 	}
; 1799 : 
; 1800 : 	return true;

	mov	al, 1
$LN9@MoveUnit:

; 1801 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MoveUnit@CvGameTrade@@QAE_NH@Z ENDP			; CvGameTrade::MoveUnit
_TEXT	ENDS
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
EXTRN	?setXY@CvUnit@@QAEXHH_N0000@Z:PROC		; CvUnit::setXY
; Function compile flags: /Odtp
;	COMDAT ?StepUnit@CvGameTrade@@QAE_NH@Z
_TEXT	SEGMENT
tv267 = -120						; size = 4
tv282 = -116						; size = 4
tv131 = -112						; size = 4
tv92 = -108						; size = 4
_this$ = -104						; size = 4
$T230253 = -100						; size = 4
$T230249 = -96						; size = 4
$T230240 = -92						; size = 4
$T230239 = -88						; size = 4
$T230194 = -84						; size = 4
$T230181 = -80						; size = 4
$T230177 = -76						; size = 4
$T230163 = -72						; size = 4
$T230159 = -65						; size = 1
$T230148 = -64						; size = 4
$T230144 = -57						; size = 1
_iMapY$230203 = -56					; size = 4
_iMapX$230202 = -52					; size = 4
$T230137 = -48						; size = 4
$T230133 = -44						; size = 4
$T230129 = -40						; size = 4
$T230122 = -36						; size = 4
$T230118 = -32						; size = 4
$T230111 = -28						; size = 4
_pEnemyUnit$219883 = -24				; size = 4
_pkUnit$ = -20						; size = 4
_bAtEndGoingForward$ = -13				; size = 1
_pPlot$ = -12						; size = 4
_kTradeConnection$ = -8					; size = 4
_bAtEndGoingBackward$ = -1				; size = 1
_iIndex$ = 8						; size = 4
?StepUnit@CvGameTrade@@QAE_NH@Z PROC			; CvGameTrade::StepUnit, COMDAT
; _this$ = ecx

; 1806 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 1807 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1808 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN10@StepUnit
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230111[ebp], ecx
	mov	edx, DWORD PTR _iIndex$[ebp]
	cmp	edx, DWORD PTR $T230111[ebp]
	jl	SHORT $LN20@StepUnit
$LN10@StepUnit:

; 1809 : 	{
; 1810 : 		return false;

	xor	al, al
	jmp	$LN12@StepUnit

; 1811 : 	}
; 1812 : 
; 1813 : 	// if the unit needs to turn around
; 1814 : 	TradeConnection &kTradeConnection = m_aTradeConnections[iIndex];

$LN20@StepUnit:
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _kTradeConnection$[ebp], eax

; 1815 : #ifdef AUI_WARNING_FIXES
; 1816 : 	bool bAtEndGoingForward = (kTradeConnection.m_bTradeUnitMovingForward && kTradeConnection.m_iTradeUnitLocationIndex + 1 >= kTradeConnection.m_aPlotList.size());
; 1817 : #else
; 1818 : 	bool bAtEndGoingForward = (kTradeConnection.m_bTradeUnitMovingForward && kTradeConnection.m_iTradeUnitLocationIndex >= ((int)kTradeConnection.m_aPlotList.size() - 1));

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	movzx	eax, BYTE PTR [edx+40]
	test	eax, eax
	je	SHORT $LN14@StepUnit
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T230118[ebp], edx
	mov	eax, DWORD PTR $T230118[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [ecx+36], eax
	jl	SHORT $LN14@StepUnit
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN15@StepUnit
$LN14@StepUnit:
	mov	DWORD PTR tv92[ebp], 0
$LN15@StepUnit:
	mov	dl, BYTE PTR tv92[ebp]
	mov	BYTE PTR _bAtEndGoingForward$[ebp], dl

; 1819 : #endif
; 1820 : 	bool bAtEndGoingBackward = (!kTradeConnection.m_bTradeUnitMovingForward && kTradeConnection.m_iTradeUnitLocationIndex <= 0);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	test	ecx, ecx
	jne	SHORT $LN16@StepUnit
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jg	SHORT $LN16@StepUnit
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $LN17@StepUnit
$LN16@StepUnit:
	mov	DWORD PTR tv131[ebp], 0
$LN17@StepUnit:
	mov	al, BYTE PTR tv131[ebp]
	mov	BYTE PTR _bAtEndGoingBackward$[ebp], al

; 1821 : 	if (bAtEndGoingForward || bAtEndGoingBackward)

	movzx	ecx, BYTE PTR _bAtEndGoingForward$[ebp]
	test	ecx, ecx
	jne	SHORT $LN8@StepUnit
	movzx	edx, BYTE PTR _bAtEndGoingBackward$[ebp]
	test	edx, edx
	je	SHORT $LN9@StepUnit
$LN8@StepUnit:

; 1822 : 	{
; 1823 : 		kTradeConnection.m_bTradeUnitMovingForward = !kTradeConnection.m_bTradeUnitMovingForward;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	BYTE PTR [edx+40], cl
$LN9@StepUnit:

; 1824 : 	}
; 1825 : 
; 1826 : 	// if moving forward
; 1827 : 	if (kTradeConnection.m_bTradeUnitMovingForward)

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	test	ecx, ecx
	je	SHORT $LN7@StepUnit

; 1828 : 	{
; 1829 : 		kTradeConnection.m_iTradeUnitLocationIndex += 1;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, 1
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1830 : 	}
; 1831 : 	else // if moving back

	jmp	SHORT $LN6@StepUnit
$LN7@StepUnit:

; 1832 : 	{
; 1833 : 		kTradeConnection.m_iTradeUnitLocationIndex -= 1;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+36]
	sub	eax, 1
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1834 : 		if (kTradeConnection.m_iTradeUnitLocationIndex == 0)

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jne	SHORT $LN6@StepUnit

; 1835 : 		{
; 1836 : 			kTradeConnection.m_iCircuitsCompleted += 1;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+384]
	add	ecx, 1
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	DWORD PTR [edx+384], ecx
$LN6@StepUnit:

; 1837 : 		}
; 1838 : 	}
; 1839 : 
; 1840 : 	// Move the visualization
; 1841 : 	CvUnit *pkUnit = GetVis(iIndex);

	mov	eax, DWORD PTR _iIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z	; CvGameTrade::GetVis
	mov	DWORD PTR _pkUnit$[ebp], eax

; 1842 : 	if (pkUnit)

	cmp	DWORD PTR _pkUnit$[ebp], 0
	je	SHORT $LN4@StepUnit

; 1843 : 	{
; 1844 : 		pkUnit->setXY(kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iX, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iY, true, false, true, true);

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T230122[ebp], edx
	push	0
	push	1
	push	1
	push	0
	push	1
	mov	eax, DWORD PTR $T230122[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax*8]
	push	eax
	mov	ecx, DWORD PTR _pkUnit$[ebp]
	call	?setXY@CvUnit@@QAEXHH_N0000@Z		; CvUnit::setXY
$LN4@StepUnit:

; 1845 : 	}
; 1846 : 
; 1847 : 	// auto-pillage when a trade unit moves under an enemy unit
; 1848 : 	CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iX, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iY);

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T230129[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T230133[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230137[ebp], edx
	mov	eax, DWORD PTR $T230129[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230240[ebp], ecx
	mov	edx, DWORD PTR $T230133[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230239[ebp], eax
	cmp	DWORD PTR $T230239[ebp], -2147483647	; 80000001H
	je	SHORT $LN34@StepUnit
	cmp	DWORD PTR $T230240[ebp], -2147483647	; 80000001H
	jne	SHORT $LN35@StepUnit
$LN34@StepUnit:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN36@StepUnit
$LN35@StepUnit:
	mov	ecx, DWORD PTR $T230137[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T230144[ebp], dl
	mov	eax, DWORD PTR $T230137[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230148[ebp], ecx
	movzx	edx, BYTE PTR $T230144[ebp]
	test	edx, edx
	je	SHORT $LN47@StepUnit
	cmp	DWORD PTR $T230239[ebp], 0
	jge	SHORT $LN46@StepUnit
	mov	eax, DWORD PTR $T230239[ebp]
	cdq
	idiv	DWORD PTR $T230148[ebp]
	add	edx, DWORD PTR $T230148[ebp]
	mov	DWORD PTR _iMapX$230202[ebp], edx
	jmp	SHORT $LN48@StepUnit
	jmp	SHORT $LN47@StepUnit
$LN46@StepUnit:
	mov	eax, DWORD PTR $T230239[ebp]
	cmp	eax, DWORD PTR $T230148[ebp]
	jl	SHORT $LN47@StepUnit
	mov	eax, DWORD PTR $T230239[ebp]
	cdq
	idiv	DWORD PTR $T230148[ebp]
	mov	DWORD PTR _iMapX$230202[ebp], edx
	jmp	SHORT $LN48@StepUnit
$LN47@StepUnit:
	mov	ecx, DWORD PTR $T230239[ebp]
	mov	DWORD PTR _iMapX$230202[ebp], ecx
$LN48@StepUnit:
	mov	edx, DWORD PTR $T230137[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T230159[ebp], al
	mov	ecx, DWORD PTR $T230137[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T230163[ebp], edx
	movzx	eax, BYTE PTR $T230159[ebp]
	test	eax, eax
	je	SHORT $LN57@StepUnit
	cmp	DWORD PTR $T230240[ebp], 0
	jge	SHORT $LN56@StepUnit
	mov	eax, DWORD PTR $T230240[ebp]
	cdq
	idiv	DWORD PTR $T230163[ebp]
	add	edx, DWORD PTR $T230163[ebp]
	mov	DWORD PTR _iMapY$230203[ebp], edx
	jmp	SHORT $LN58@StepUnit
	jmp	SHORT $LN57@StepUnit
$LN56@StepUnit:
	mov	ecx, DWORD PTR $T230240[ebp]
	cmp	ecx, DWORD PTR $T230163[ebp]
	jl	SHORT $LN57@StepUnit
	mov	eax, DWORD PTR $T230240[ebp]
	cdq
	idiv	DWORD PTR $T230163[ebp]
	mov	DWORD PTR _iMapY$230203[ebp], edx
	jmp	SHORT $LN58@StepUnit
$LN57@StepUnit:
	mov	edx, DWORD PTR $T230240[ebp]
	mov	DWORD PTR _iMapY$230203[ebp], edx
$LN58@StepUnit:
	cmp	DWORD PTR _iMapX$230202[ebp], 0
	jl	SHORT $LN62@StepUnit
	mov	eax, DWORD PTR $T230137[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230177[ebp], ecx
	mov	edx, DWORD PTR _iMapX$230202[ebp]
	cmp	edx, DWORD PTR $T230177[ebp]
	jge	SHORT $LN62@StepUnit
	cmp	DWORD PTR _iMapY$230203[ebp], 0
	jl	SHORT $LN62@StepUnit
	mov	eax, DWORD PTR $T230137[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T230181[ebp], ecx
	mov	edx, DWORD PTR _iMapY$230203[ebp]
	cmp	edx, DWORD PTR $T230181[ebp]
	jge	SHORT $LN62@StepUnit
	mov	DWORD PTR tv282[ebp], 1
	jmp	SHORT $LN60@StepUnit
$LN62@StepUnit:
	mov	DWORD PTR tv282[ebp], 0
$LN60@StepUnit:
	cmp	DWORD PTR tv282[ebp], 0
	je	SHORT $LN38@StepUnit
	mov	eax, DWORD PTR $T230137[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230194[ebp], ecx
	mov	edx, DWORD PTR _iMapY$230203[ebp]
	imul	edx, DWORD PTR $T230194[ebp]
	add	edx, DWORD PTR _iMapX$230202[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T230137[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv267[ebp], edx
	jmp	SHORT $LN39@StepUnit
$LN38@StepUnit:
	mov	DWORD PTR tv267[ebp], 0
$LN39@StepUnit:
	mov	ecx, DWORD PTR tv267[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx
$LN36@StepUnit:

; 1849 : 	if (pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN3@StepUnit

; 1850 : 	{
; 1851 : 		CvUnit* pEnemyUnit = pPlot->getVisibleEnemyDefender(kTradeConnection.m_eOriginOwner);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	DWORD PTR _pEnemyUnit$219883[ebp], eax

; 1852 : 		if (pEnemyUnit)

	cmp	DWORD PTR _pEnemyUnit$219883[ebp], 0
	je	SHORT $LN3@StepUnit

; 1853 : 		{
; 1854 : 			if (pEnemyUnit->canPlunderTradeRoute(pPlot, false))

	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEnemyUnit$219883[ebp]
	call	?canPlunderTradeRoute@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canPlunderTradeRoute
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@StepUnit

; 1855 : 			{
; 1856 : 				GET_PLAYER(pEnemyUnit->getOwner()).GetTrade()->PlunderTradeRoute(kTradeConnection.m_iID);

	mov	eax, DWORD PTR _pEnemyUnit$219883[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T230249[ebp], ecx
	mov	edx, DWORD PTR $T230249[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230253[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T230253[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z ; CvPlayerTrade::PlunderTradeRoute

; 1857 : 				// done died!
; 1858 : 				return false;

	xor	al, al
	jmp	SHORT $LN12@StepUnit
$LN3@StepUnit:

; 1859 : 			}
; 1860 : 		}
; 1861 : 	}
; 1862 : 
; 1863 : 	return true;

	mov	al, 1
$LN12@StepUnit:

; 1864 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StepUnit@CvGameTrade@@QAE_NH@Z ENDP			; CvGameTrade::StepUnit
_TEXT	ENDS
EXTRN	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z:PROC ; CvUnit::SetAutomateType
; Function compile flags: /Odtp
;	COMDAT ?CreateVis@CvGameTrade@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T230282 = -32						; size = 4
$T230273 = -28						; size = 4
$T230269 = -24						; size = 4
$T230259 = -20						; size = 4
_pkUnit$219898 = -16					; size = 4
_kPlayer$219897 = -12					; size = 4
_eUnitType$219895 = -8					; size = 4
_kTradeConnection$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?CreateVis@CvGameTrade@@QAEXH@Z PROC			; CvGameTrade::CreateVis, COMDAT
; _this$ = ecx

; 1868 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1869 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1870 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN4@CreateVis
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230259[ebp], ecx
	mov	edx, DWORD PTR _iIndex$[ebp]
	cmp	edx, DWORD PTR $T230259[ebp]
	jl	SHORT $LN10@CreateVis
$LN4@CreateVis:

; 1871 : 	{
; 1872 : 		return;

	jmp	$LN6@CreateVis

; 1873 : 	}
; 1874 : 
; 1875 : 	TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];

$LN10@CreateVis:
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _kTradeConnection$[ebp], eax

; 1876 : 
; 1877 : 	if (kTradeConnection.m_unitID == -1)

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [edx+380], -1
	jne	$LN6@CreateVis

; 1878 : 	{
; 1879 : 		UnitTypes eUnitType = CvPlayerTrade::GetTradeUnit(kTradeConnection.m_eDomain);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	mov	DWORD PTR _eUnitType$219895[ebp], eax

; 1880 : 		if (eUnitType != NO_UNIT)

	cmp	DWORD PTR _eUnitType$219895[ebp], -1
	je	$LN6@CreateVis

; 1881 : 		{
; 1882 : 			CvPlayer& kPlayer = GET_PLAYER(kTradeConnection.m_eOriginOwner);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$219897[ebp], eax

; 1883 : 			CvUnit* pkUnit = kPlayer.initUnit(eUnitType, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iX, kTradeConnection.m_aPlotList[kTradeConnection.m_iTradeUnitLocationIndex].m_iY, NO_UNITAI, NO_DIRECTION, false, true, TRADE_UNIT_MAP_LAYER);

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T230269[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T230273[ebp], ecx
	push	0
	push	1
	push	1
	push	0
	push	-1
	push	-1
	mov	edx, DWORD PTR $T230269[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T230273[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _eUnitType$219895[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$219897[ebp]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	DWORD PTR _pkUnit$219898[ebp], eax

; 1884 : 			if (pkUnit)

	cmp	DWORD PTR _pkUnit$219898[ebp], 0
	je	SHORT $LN6@CreateVis

; 1885 : 			{
; 1886 : 				pkUnit->SetAutomateType(AUTOMATE_TRADE);

	push	1272735960				; 4bdc68d8H
	mov	ecx, DWORD PTR _pkUnit$219898[ebp]
	call	?SetAutomateType@CvUnit@@QAEXW4AutomateTypes@@@Z ; CvUnit::SetAutomateType

; 1887 : 				kTradeConnection.m_unitID = pkUnit->GetID();

	mov	ecx, DWORD PTR _pkUnit$219898[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T230282[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR $T230282[ebp]
	mov	DWORD PTR [eax+380], ecx
$LN6@CreateVis:

; 1888 : 			}
; 1889 : 		}
; 1890 : 	}
; 1891 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CreateVis@CvGameTrade@@QAEXH@Z ENDP			; CvGameTrade::CreateVis
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T230288 = -12						; size = 4
_kPlayer$219909 = -8					; size = 4
_kTradeConnection$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z PROC		; CvGameTrade::GetVis, COMDAT
; _this$ = ecx

; 1901 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1902 : 	CvAssertMsg(iIndex >= 0 && iIndex < (int)m_aTradeConnections.size(), "iIndex out of bounds");
; 1903 : 	if (iIndex < 0 || iIndex >= (int)m_aTradeConnections.size())

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN2@GetVis
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230288[ebp], ecx
	mov	edx, DWORD PTR _iIndex$[ebp]
	cmp	edx, DWORD PTR $T230288[ebp]
	jl	SHORT $LN8@GetVis
$LN2@GetVis:

; 1904 : #endif
; 1905 : 	{
; 1906 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@GetVis

; 1907 : 	}
; 1908 : 
; 1909 : #ifdef AUI_WARNING_FIXES
; 1910 : 	const TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];
; 1911 : #else
; 1912 : 	TradeConnection& kTradeConnection = m_aTradeConnections[iIndex];

$LN8@GetVis:
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _kTradeConnection$[ebp], eax

; 1913 : #endif
; 1914 : 	if (kTradeConnection.m_unitID != -1)

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [edx+380], -1
	je	SHORT $LN1@GetVis

; 1915 : 	{
; 1916 : #ifdef AUI_WARNING_FIXES
; 1917 : 		return GET_PLAYER(kTradeConnection.m_eOriginOwner).getUnit(kTradeConnection.m_unitID);
; 1918 : #else
; 1919 : 		CvPlayer& kPlayer = GET_PLAYER(kTradeConnection.m_eOriginOwner);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$219909[ebp], ecx

; 1920 : 		return kPlayer.getUnit(kTradeConnection.m_unitID);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+380]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$219909[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	jmp	SHORT $LN4@GetVis
$LN1@GetVis:

; 1921 : #endif
; 1922 : 	}
; 1923 : 
; 1924 : 	return NULL;

	xor	eax, eax
$LN4@GetVis:

; 1925 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetVis@CvGameTrade@@QAEPAVCvUnit@@H@Z ENDP		; CvGameTrade::GetVis
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
PUBLIC	?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free
PUBLIC	__$ArrayPad$
PUBLIC	?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z ; CvGameTrade::DisplayTemporaryPopupTradeRoute
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z:PROC ; CvGlobals::UnwrapUnitPointer
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$4
__ehfuncinfo$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
_TEXT	SEGMENT
tv231 = -2644						; size = 4
tv215 = -2640						; size = 4
tv164 = -2636						; size = 4
tv94 = -2632						; size = 4
tv76 = -2628						; size = 4
_this$ = -2624						; size = 4
$T230419 = -2608					; size = 4
$T230415 = -2604					; size = 4
$T230405 = -2600					; size = 4
$T230401 = -2596					; size = 4
$T230397 = -2592					; size = 4
$T230393 = -2588					; size = 4
$T230389 = -2584					; size = 4
_inst$230384 = -2580					; size = 4
$T230381 = -2576					; size = 4
$T230365 = -2572					; size = 4
_inst$230352 = -2568					; size = 4
$T230349 = -2564					; size = 4
$T230315 = -2560					; size = 4
$T230311 = -2556					; size = 4
$T230307 = -2552					; size = 4
_pkSelectedUnit$219984 = -2548				; size = 4
_pSelectedUnit$219974 = -2544				; size = 4
_plotsY$ = -2540					; size = 1024
_iOriginY$ = -1516					; size = 4
_iOriginX$ = -1512					; size = 4
_bSuccess$ = -1505					; size = 1
_eOriginPlayer$ = -1504					; size = 4
_tempTradeConnection$ = -1500				; size = 444
__$ArrayPad$ = -1052					; size = 4
_i$ = -1048						; size = 4
_n$ = -1044						; size = 4
_pPathfinderNode$ = -1040				; size = 4
_plotsX$ = -1036					; size = 1024
__$EHRec$ = -12						; size = 12
_iDestX$ = 8						; size = 4
_iDestY$ = 12						; size = 4
_type$ = 16						; size = 4
_eDomain$ = 20						; size = 4
?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z PROC ; CvGameTrade::DisplayTemporaryPopupTradeRoute, COMDAT
; _this$ = ecx

; 1929 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2632				; 00000a48H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1930 : 	int i,n;
; 1931 : 	int plotsX[MAX_PLOTS_TO_DISPLAY], plotsY[MAX_PLOTS_TO_DISPLAY];
; 1932 : 
; 1933 : 	int iOriginX,iOriginY;
; 1934 : 	PlayerTypes eOriginPlayer;
; 1935 : 	bool bSuccess = false;

	mov	BYTE PTR _bSuccess$[ebp], 0

; 1936 : 	CvAStarNode* pPathfinderNode = NULL;

	mov	DWORD PTR _pPathfinderNode$[ebp], 0

; 1937 : 	TradeConnection tempTradeConnection;

	lea	ecx, DWORD PTR _tempTradeConnection$[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1938 : 
; 1939 : 	{
; 1940 : 		auto_ptr<ICvUnit1> pSelectedUnit(GC.GetEngineUserInterface()->GetHeadSelectedUnit());

	mov	eax, DWORD PTR $T230307[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR tv76[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv76[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR $T230311[ebp], eax
	mov	eax, DWORD PTR $T230311[ebp]
	mov	DWORD PTR _pSelectedUnit$219974[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1941 : 		CvUnit* pkSelectedUnit = GC.UnwrapUnitPointer(pSelectedUnit.get());

	mov	ecx, DWORD PTR _pSelectedUnit$219974[ebp]
	mov	DWORD PTR $T230315[ebp], ecx
	mov	edx, DWORD PTR $T230315[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z ; CvGlobals::UnwrapUnitPointer
	mov	DWORD PTR _pkSelectedUnit$219984[ebp], eax

; 1942 : 		CvAssert(pkSelectedUnit != NULL);
; 1943 : 		if (pkSelectedUnit)

	cmp	DWORD PTR _pkSelectedUnit$219984[ebp], 0
	je	SHORT $LN11@DisplayTem

; 1944 : 		{
; 1945 : 			iOriginX = pkSelectedUnit->getX();

	mov	eax, DWORD PTR _pkSelectedUnit$219984[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _iOriginX$[ebp], ecx

; 1946 : 			iOriginY = pkSelectedUnit->getY();

	mov	edx, DWORD PTR _pkSelectedUnit$219984[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR _iOriginY$[ebp], eax

; 1947 : 			eOriginPlayer = pkSelectedUnit->getOwner();

	mov	ecx, DWORD PTR _pkSelectedUnit$219984[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _eOriginPlayer$[ebp], edx

; 1948 : 		}
; 1949 : 		else

	jmp	SHORT $LN10@DisplayTem
$LN11@DisplayTem:

; 1950 : 		{
; 1951 : 			return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _pSelectedUnit$219974[ebp]
	mov	DWORD PTR $T230349[ebp], eax
	cmp	DWORD PTR $T230349[ebp], 0
	je	SHORT $LN37@DisplayTem
	mov	ecx, DWORD PTR $T230349[ebp]
	mov	DWORD PTR _inst$230352[ebp], ecx
	mov	edx, DWORD PTR _inst$230352[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$230352[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN37@DisplayTem:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	eax, DWORD PTR _tempTradeConnection$[ebp+44]
	mov	DWORD PTR $T230365[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T230365[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T230365[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T230365[ebp]
	call	?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	$LN12@DisplayTem
$LN10@DisplayTem:

; 1952 : 		}
; 1953 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _pSelectedUnit$219974[ebp]
	mov	DWORD PTR $T230381[ebp], edx
	cmp	DWORD PTR $T230381[ebp], 0
	je	SHORT $LN50@DisplayTem
	mov	eax, DWORD PTR $T230381[ebp]
	mov	DWORD PTR _inst$230384[ebp], eax
	mov	ecx, DWORD PTR _inst$230384[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _inst$230384[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+4]
	call	ecx
$LN50@DisplayTem:

; 1954 : 
; 1955 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 1956 : 	PlayerTypes eDestPlayer = NO_PLAYER;
; 1957 : 	CvPlot* pDestPlot = GC.getMap().plot(iDestX, iDestY);
; 1958 : 	if (pDestPlot)
; 1959 : 	{
; 1960 : 		CvCity* pDestCity = pDestPlot->getPlotCity();
; 1961 : 		if (pDestCity)
; 1962 : 		{
; 1963 : 			eDestPlayer = pDestCity->getOwner();
; 1964 : 		}
; 1965 : 	}
; 1966 : #endif
; 1967 : 
; 1968 : 	switch (eDomain)

	mov	edx, DWORD PTR _eDomain$[ebp]
	mov	DWORD PTR tv94[ebp], edx
	cmp	DWORD PTR tv94[ebp], 0
	je	SHORT $LN6@DisplayTem
	cmp	DWORD PTR tv94[ebp], 2
	je	SHORT $LN7@DisplayTem
	jmp	$LN8@DisplayTem
$LN7@DisplayTem:

; 1969 : 	{
; 1970 : 	case DOMAIN_LAND:
; 1971 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 1972 : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 1973 : #else
; 1974 : 		bSuccess = GC.GetInternationalTradeRouteLandFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	0
	mov	eax, DWORD PTR _eOriginPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDestY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDestX$[ebp]
	push	edx
	mov	eax, DWORD PTR _iOriginY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iOriginX$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bSuccess$[ebp], al

; 1975 : #endif
; 1976 : 		pPathfinderNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	DWORD PTR $T230389[ebp], eax
	mov	edx, DWORD PTR $T230389[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], eax

; 1977 : 		break;

	jmp	SHORT $LN8@DisplayTem
$LN6@DisplayTem:

; 1978 : 	case DOMAIN_SEA:
; 1979 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 1980 : 		bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer + (eDestPlayer << 8), false);
; 1981 : #else
; 1982 : 		bSuccess = GC.GetInternationalTradeRouteWaterFinder().GeneratePath(iOriginX, iOriginY, iDestX, iDestY, eOriginPlayer, false);

	push	0
	mov	ecx, DWORD PTR _eOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDestY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDestX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iOriginY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iOriginX$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bSuccess$[ebp], al

; 1983 : #endif
; 1984 : 		pPathfinderNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	DWORD PTR $T230393[ebp], eax
	mov	eax, DWORD PTR $T230393[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], ecx
$LN8@DisplayTem:

; 1985 : 		break;
; 1986 : 	}
; 1987 : 
; 1988 : 	gDLL->TradeVisuals_DestroyRoute(TEMPORARY_POPUPROUTE_ID,GC.getGame().getActivePlayer());

	mov	edx, DWORD PTR $T230397[ebp]
	mov	DWORD PTR tv164[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv164[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230401[ebp], ecx
	mov	ecx, DWORD PTR $T230401[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	push	-1
	mov	edx, DWORD PTR tv164[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv164[ebp]
	mov	edx, DWORD PTR [eax+980]
	call	edx

; 1989 : 	if (bSuccess && pPathfinderNode != NULL) {

	movzx	eax, BYTE PTR _bSuccess$[ebp]
	test	eax, eax
	je	$LN5@DisplayTem
	cmp	DWORD PTR _pPathfinderNode$[ebp], 0
	je	$LN5@DisplayTem

; 1990 : 		CopyPathIntoTradeConnection(pPathfinderNode, &tempTradeConnection);

	lea	ecx, DWORD PTR _tempTradeConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPathfinderNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection

; 1991 : 		n = tempTradeConnection.m_aPlotList.size();

	mov	eax, DWORD PTR _tempTradeConnection$[ebp+48]
	mov	DWORD PTR $T230405[ebp], eax
	mov	ecx, DWORD PTR $T230405[ebp]
	mov	DWORD PTR _n$[ebp], ecx

; 1992 : 		if (n>0 && n <=MAX_PLOTS_TO_DISPLAY) {

	cmp	DWORD PTR _n$[ebp], 0
	jle	$LN5@DisplayTem
	cmp	DWORD PTR _n$[ebp], 256			; 00000100H
	jg	$LN5@DisplayTem

; 1993 : 			for (i=0;i<n;++i) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@DisplayTem
$LN2@DisplayTem:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@DisplayTem:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN1@DisplayTem

; 1994 : 				plotsX[i] = tempTradeConnection.m_aPlotList[i].m_iX;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _tempTradeConnection$[ebp+44]
	mov	edx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _plotsX$[ebp+ecx*4], edx

; 1995 : 				plotsY[i] = tempTradeConnection.m_aPlotList[i].m_iY;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _tempTradeConnection$[ebp+44]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	DWORD PTR _plotsY$[ebp+eax*4], ecx

; 1996 : 			}

	jmp	SHORT $LN2@DisplayTem
$LN1@DisplayTem:

; 1997 : 			gDLL->TradeVisuals_NewRoute(TEMPORARY_POPUPROUTE_ID,eOriginPlayer,type,n,plotsX,plotsY);

	mov	edx, DWORD PTR $T230415[ebp]
	mov	DWORD PTR tv215[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv215[ebp], eax
	lea	ecx, DWORD PTR _plotsY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _plotsX$[ebp]
	push	edx
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOriginPlayer$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR tv215[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	eax, DWORD PTR [edx+972]
	call	eax

; 1998 : 			gDLL->TradeVisuals_ActivatePopupRoute(TEMPORARY_POPUPROUTE_ID);

	mov	ecx, DWORD PTR $T230419[ebp]
	mov	DWORD PTR tv231[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv231[ebp], edx
	push	-1
	mov	eax, DWORD PTR tv231[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv231[ebp]
	mov	eax, DWORD PTR [edx+984]
	call	eax
$LN5@DisplayTem:

; 1999 : 		}
; 2000 : 	}
; 2001 : 	m_CurrentTemporaryPopupRoute.iPlotX = iDestX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iDestX$[ebp]
	mov	DWORD PTR [ecx+76548], edx

; 2002 : 	m_CurrentTemporaryPopupRoute.iPlotY = iDestY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iDestY$[ebp]
	mov	DWORD PTR [eax+76552], ecx

; 2003 : 	m_CurrentTemporaryPopupRoute.type = type;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx+76556], eax

; 2004 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempTradeConnection$[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
$LN12@DisplayTem:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$0:
	lea	ecx, DWORD PTR _tempTradeConnection$[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$1:
	lea	ecx, DWORD PTR _pSelectedUnit$219974[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z$4:
	mov	ecx, DWORD PTR $T230365[ebp]
	jmp	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
__ehhandler$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2636]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-1040]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DisplayTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@W4DomainTypes@@@Z ENDP ; CvGameTrade::DisplayTemporaryPopupTradeRoute
PUBLIC	?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z ; CvGameTrade::HideTemporaryPopupTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z
_TEXT	SEGMENT
tv90 = -24						; size = 4
tv80 = -20						; size = 4
_this$ = -16						; size = 4
$T230470 = -12						; size = 4
$T230466 = -8						; size = 4
$T230462 = -4						; size = 4
_iPlotX$ = 8						; size = 4
_iPlotY$ = 12						; size = 4
_type$ = 16						; size = 4
?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z PROC ; CvGameTrade::HideTemporaryPopupTradeRoute, COMDAT
; _this$ = ecx

; 2008 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2009 : 	if (iPlotX == m_CurrentTemporaryPopupRoute.iPlotX &&
; 2010 : 		iPlotY == m_CurrentTemporaryPopupRoute.iPlotY &&
; 2011 : 		type == m_CurrentTemporaryPopupRoute.type) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iPlotX$[ebp]
	cmp	ecx, DWORD PTR [eax+76548]
	jne	SHORT $LN2@HideTempor
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cmp	eax, DWORD PTR [edx+76552]
	jne	SHORT $LN2@HideTempor
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _type$[ebp]
	cmp	edx, DWORD PTR [ecx+76556]
	jne	SHORT $LN2@HideTempor

; 2012 : 	{
; 2013 : 		gDLL->TradeVisuals_DeactivatePopupRoute();

	mov	eax, DWORD PTR $T230462[ebp]
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv80[ebp], ecx
	mov	edx, DWORD PTR tv80[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv80[ebp]
	mov	edx, DWORD PTR [eax+988]
	call	edx

; 2014 : 		gDLL->TradeVisuals_DestroyRoute(TEMPORARY_POPUPROUTE_ID,GC.getGame().getActivePlayer());

	mov	eax, DWORD PTR $T230466[ebp]
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv90[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230470[ebp], edx
	mov	ecx, DWORD PTR $T230470[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	push	-1
	mov	eax, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv90[ebp]
	mov	eax, DWORD PTR [edx+980]
	call	eax
$LN2@HideTempor:

; 2015 : 	}
; 2016 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HideTemporaryPopupTradeRoute@CvGameTrade@@QAEXHHW4TradeConnectionType@@@Z ENDP ; CvGameTrade::HideTemporaryPopupTradeRoute
_TEXT	ENDS
PUBLIC	??_C@_0BC@NLEBDDOM@TradeRouteLog?4csv?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ	; CvGameTrade::GetLogFileName
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT ??_C@_0BC@NLEBDDOM@TradeRouteLog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BC@NLEBDDOM@TradeRouteLog?4csv?$AA@ DB 'TradeRouteLog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T230476 = -48						; size = 4
_strLogName$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ PROC	; CvGameTrade::GetLogFileName, COMDAT
; _this$ = ecx

; 2020 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T230476[ebp], 0

; 2021 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2022 : 	strLogName = "TradeRouteLog.csv";

	mov	eax, OFFSET ??_C@_0BC@NLEBDDOM@TradeRouteLog?4csv?$AA@
	test	eax, eax
	je	SHORT $LN10@GetLogFile
	push	OFFSET ??_C@_0BC@NLEBDDOM@TradeRouteLog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN11@GetLogFile
$LN10@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN11@GetLogFile:

; 2023 : 	return strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T230476[ebp]
	or	edx, 1
	mov	DWORD PTR $T230476[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2024 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ$0:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ$1:
	mov	eax, DWORD PTR $T230476[ebp]
	and	eax, 1
	je	$LN5@GetLogFile
	and	DWORD PTR $T230476[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ ENDP	; CvGameTrade::GetLogFileName
PUBLIC	??_C@_05CMAMCNEC@?$CF03d?0?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
;	COMDAT ??_C@_05CMAMCNEC@?$CF03d?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_05CMAMCNEC@?$CF03d?0?$AA@ DB '%03d,', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$3
__ehfuncinfo$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
_TEXT	SEGMENT
tv162 = -168						; size = 4
tv173 = -164						; size = 4
tv76 = -160						; size = 4
_this$ = -156						; size = 4
$T230538 = -152						; size = 4
$T230534 = -148						; size = 4
$T230530 = -144						; size = 4
$T230522 = -140						; size = 4
$T230521 = -136						; size = 4
$T230505 = -132						; size = 28
$T230504 = -104						; size = 28
_strOutBuf$220016 = -76					; size = 28
_pLog$220018 = -48					; size = 4
_strBaseString$220017 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z PROC	; CvGameTrade::LogTradeMsg, COMDAT
; _this$ = ecx

; 2028 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2029 : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogTradeMs

; 2030 : 	{
; 2031 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$220016[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2032 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$220017[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2033 : 		FILogFile* pLog;
; 2034 : 
; 2035 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv76[ebp], eax
	lea	ecx, DWORD PTR $T230504[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvGameTrade@@QBE?AVCvString@@XZ ; CvGameTrade::GetLogFileName
	mov	DWORD PTR tv173[ebp], eax
	mov	edx, DWORD PTR tv173[ebp]
	mov	DWORD PTR $T230521[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T230521[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T230522[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T230522[ebp]
	push	eax
	mov	ecx, DWORD PTR tv76[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv76[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$220018[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T230504[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2036 : 
; 2037 : 		// Get the leading info for this line
; 2038 : 		strBaseString.Format("%03d,", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230530[ebp], ecx
	mov	ecx, DWORD PTR $T230530[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_05CMAMCNEC@?$CF03d?0?$AA@
	lea	edx, DWORD PTR _strBaseString$220017[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2039 : 		strOutBuf = strBaseString + strMsg;

	mov	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$220017[ebp]
	push	ecx
	lea	edx, DWORD PTR $T230505[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv162[ebp], eax
	mov	eax, DWORD PTR tv162[ebp]
	mov	DWORD PTR $T230534[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T230534[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$220016[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T230505[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2040 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$220016[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T230538[ebp], eax
	mov	ecx, DWORD PTR $T230538[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$220018[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$220018[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 2041 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$220017[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$220016[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogTradeMs:

; 2042 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$220016[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$220017[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$2:
	lea	ecx, DWORD PTR $T230504[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z$3:
	lea	ecx, DWORD PTR $T230505[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogTradeMsg@CvGameTrade@@QAEXAAVCvString@@@Z ENDP	; CvGameTrade::LogTradeMsg
PUBLIC	__$ArrayPad$
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z	; operator>>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z$0
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
_TEXT	SEGMENT
tv399 = -2700						; size = 4
tv367 = -2696						; size = 4
$T230757 = -2680					; size = 4
$T230750 = -2676					; size = 4
$T230740 = -2672					; size = 4
$T230733 = -2668					; size = 4
$T230729 = -2664					; size = 4
$T230722 = -2660					; size = 4
$T230715 = -2656					; size = 4
$T230711 = -2652					; size = 4
$T230704 = -2648					; size = 4
$T230700 = -2644					; size = 4
$T230693 = -2640					; size = 4
$T230673 = -2632					; size = 4
$T230666 = -2628					; size = 4
$T230659 = -2624					; size = 4
$T230652 = -2620					; size = 4
$T230645 = -2616					; size = 4
$T230638 = -2612					; size = 4
$T230613 = -2608					; size = 4
$T230606 = -2604					; size = 4
$T230599 = -2600					; size = 4
$T230592 = -2596					; size = 4
$T230582 = -2592					; size = 4
_ui2$220071 = -2580					; size = 4
_ui$220067 = -2576					; size = 4
_ui2$220062 = -2572					; size = 4
_ui$220058 = -2568					; size = 4
_ui$220053 = -2564					; size = 4
_kTradeConnectionPlot$220049 = -2560			; size = 8
_i2$220045 = -2552					; size = 4
_iNum2$220044 = -2548					; size = 4
_iConnectionType$220040 = -2544				; size = 4
_kTradeConnection$220035 = -2540			; size = 444
__$ArrayPad$ = -2088					; size = 4
_iDomain$220038 = -2084					; size = 4
_i$220031 = -2080					; size = 4
_nPlots$ = -2076					; size = 4
_iNum$ = -2072						; size = 4
_plotsY$ = -2068					; size = 1024
_uiVersion$ = -1040					; size = 4
_plotsX$ = -1036					; size = 1024
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z PROC	; operator>>, COMDAT

; 2047 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2688				; 00000a80H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2048 : 	int plotsX[MAX_PLOTS_TO_DISPLAY];
; 2049 : 	int plotsY[MAX_PLOTS_TO_DISPLAY];
; 2050 : 	int nPlots;
; 2051 : 
; 2052 : 	uint uiVersion;
; 2053 : 	loadFrom >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2054 : 
; 2055 : 	int iNum = 0;

	mov	DWORD PTR _iNum$[ebp], 0

; 2056 : 	loadFrom >> iNum;

	lea	ecx, DWORD PTR _iNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2057 : 	for (int i = 0; i < iNum; i++)

	mov	DWORD PTR _i$220031[ebp], 0
	jmp	SHORT $LN30@operator
$LN29@operator:
	mov	edx, DWORD PTR _i$220031[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220031[ebp], edx
$LN30@operator:
	mov	eax, DWORD PTR _i$220031[ebp]
	cmp	eax, DWORD PTR _iNum$[ebp]
	jge	$LN28@operator

; 2058 : 	{
; 2059 : 		TradeConnection kTradeConnection;

	lea	ecx, DWORD PTR _kTradeConnection$220035[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2060 : 		writeTo.m_aTradeConnections.push_back(kTradeConnection);

	lea	ecx, DWORD PTR _kTradeConnection$220035[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 2061 : 		if (uiVersion >= 1)

	cmp	DWORD PTR _uiVersion$[ebp], 1
	jb	SHORT $LN53@operator

; 2062 : 		{
; 2063 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_iID;

	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T230582[ebp], edx
	mov	ecx, DWORD PTR $T230582[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2064 : 		}
; 2065 : 		else

	jmp	SHORT $LN55@operator

; 2066 : 		{
; 2067 : 			writeTo.m_aTradeConnections[i].m_iID = MAX_INT;

$LN53@operator:
	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx], 2147483647		; 7fffffffH

; 2068 : 		}
; 2069 : 
; 2070 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iOriginX;

$LN55@operator:
	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR $T230592[ebp], edx
	mov	eax, DWORD PTR $T230592[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2071 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iOriginY;

	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T230599[ebp], ecx
	mov	edx, DWORD PTR $T230599[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2072 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iDestX;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+12]
	mov	DWORD PTR $T230606[ebp], eax
	mov	ecx, DWORD PTR $T230606[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2073 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iDestY;

	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR $T230613[ebp], edx
	mov	eax, DWORD PTR $T230613[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2074 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_eOriginOwner;

	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+20]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2075 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_eDestOwner;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+24]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 2076 : 		int iDomain;
; 2077 : 		loadFrom >> iDomain;

	lea	edx, DWORD PTR _iDomain$220038[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2078 : 		writeTo.m_aTradeConnections[i].m_eDomain = (DomainTypes)iDomain;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iDomain$220038[ebp]
	mov	DWORD PTR [edx+eax+28], ecx

; 2079 : 		int iConnectionType;
; 2080 : 		loadFrom >> iConnectionType;

	lea	edx, DWORD PTR _iConnectionType$220040[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2081 : 		writeTo.m_aTradeConnections[i].m_eConnectionType = (TradeConnectionType)iConnectionType;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iConnectionType$220040[ebp]
	mov	DWORD PTR [edx+eax+32], ecx

; 2082 : 
; 2083 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iTradeUnitLocationIndex;

	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR $T230638[ebp], edx
	mov	eax, DWORD PTR $T230638[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2084 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_bTradeUnitMovingForward;

	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+40]
	mov	DWORD PTR $T230645[ebp], ecx
	mov	edx, DWORD PTR $T230645[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2085 : 
; 2086 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_unitID;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+380]
	mov	DWORD PTR $T230652[ebp], eax
	mov	ecx, DWORD PTR $T230652[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2087 : 
; 2088 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iCircuitsCompleted;

	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+384]
	mov	DWORD PTR $T230659[ebp], edx
	mov	eax, DWORD PTR $T230659[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2089 : 		loadFrom >> writeTo.m_aTradeConnections[i].m_iCircuitsToComplete;

	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+388]
	mov	DWORD PTR $T230666[ebp], ecx
	mov	edx, DWORD PTR $T230666[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2090 : 
; 2091 : 		if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	SHORT $LN107@operator

; 2092 : 		{
; 2093 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_iTurnRouteComplete;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+392]
	mov	DWORD PTR $T230673[ebp], eax
	mov	ecx, DWORD PTR $T230673[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2094 : 		}
; 2095 : 		else

	jmp	SHORT $LN24@operator

; 2096 : 		{
; 2097 : 			writeTo.m_aTradeConnections[i].m_iTurnRouteComplete = 0;

$LN107@operator:
	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx+392], 0
$LN24@operator:

; 2098 : 		}
; 2099 : 
; 2100 : 		int iNum2 = 0;

	mov	DWORD PTR _iNum2$220044[ebp], 0

; 2101 : 		loadFrom >> iNum2;

	lea	edx, DWORD PTR _iNum2$220044[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2102 : 
; 2103 : 		for (int i2 = 0; i2 < iNum2; i2++)

	mov	DWORD PTR _i2$220045[ebp], 0
	jmp	SHORT $LN23@operator
$LN22@operator:
	mov	eax, DWORD PTR _i2$220045[ebp]
	add	eax, 1
	mov	DWORD PTR _i2$220045[ebp], eax
$LN23@operator:
	mov	ecx, DWORD PTR _i2$220045[ebp]
	cmp	ecx, DWORD PTR _iNum2$220044[ebp]
	jge	$LN21@operator

; 2104 : 		{
; 2105 : 			TradeConnectionPlot kTradeConnectionPlot;
; 2106 : 			writeTo.m_aTradeConnections[i].m_aPlotList.push_back(kTradeConnectionPlot);

	lea	edx, DWORD PTR _kTradeConnectionPlot$220049[ebp]
	push	edx
	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [edx+eax+44]
	call	?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back

; 2107 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iX;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T230693[ebp], eax
	mov	edx, DWORD PTR $T230693[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _i2$220045[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T230700[ebp], edx
	mov	eax, DWORD PTR $T230700[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2108 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iY;

	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T230704[ebp], ecx
	mov	eax, DWORD PTR $T230704[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _i2$220045[ebp]
	lea	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR $T230711[ebp], eax
	mov	ecx, DWORD PTR $T230711[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2109 : 			
; 2110 : 			if (i2 < MAX_PLOTS_TO_DISPLAY) {

	cmp	DWORD PTR _i2$220045[ebp], 256		; 00000100H
	jge	SHORT $LN20@operator

; 2111 : 				plotsX[i2] = writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iX;

	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T230715[ebp], edx
	mov	ecx, DWORD PTR $T230715[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _i2$220045[ebp]
	mov	ecx, DWORD PTR _i2$220045[ebp]
	mov	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _plotsX$[ebp+eax*4], edx

; 2112 : 				plotsY[i2] = writeTo.m_aTradeConnections[i].m_aPlotList[i2].m_iY;

	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T230722[ebp], eax
	mov	edx, DWORD PTR $T230722[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _i2$220045[ebp]
	mov	edx, DWORD PTR _i2$220045[ebp]
	mov	eax, DWORD PTR [eax+edx*8+4]
	mov	DWORD PTR _plotsY$[ebp+ecx*4], eax
$LN20@operator:

; 2113 : 			}
; 2114 : 		}

	jmp	$LN22@operator
$LN21@operator:

; 2115 : 
; 2116 : 		nPlots = iNum2;

	mov	ecx, DWORD PTR _iNum2$220044[ebp]
	mov	DWORD PTR _nPlots$[ebp], ecx

; 2117 : 		if (nPlots > 0)

	cmp	DWORD PTR _nPlots$[ebp], 0
	jle	$LN19@operator

; 2118 : 		{
; 2119 : 			if (nPlots > MAX_PLOTS_TO_DISPLAY)

	cmp	DWORD PTR _nPlots$[ebp], 256		; 00000100H
	jle	SHORT $LN18@operator

; 2120 : 				nPlots = MAX_PLOTS_TO_DISPLAY;

	mov	DWORD PTR _nPlots$[ebp], 256		; 00000100H
$LN18@operator:

; 2121 : 			gDLL->TradeVisuals_NewRoute(i,writeTo.m_aTradeConnections[i].m_eOriginOwner,writeTo.m_aTradeConnections[i].m_eConnectionType,nPlots,plotsX,plotsY);

	mov	edx, DWORD PTR $T230729[ebp]
	mov	DWORD PTR tv367[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv367[ebp], eax
	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T230733[ebp], ecx
	lea	eax, DWORD PTR _plotsY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _plotsX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nPlots$[ebp]
	push	edx
	mov	eax, DWORD PTR $T230733[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _i$220031[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+20]
	push	edx
	mov	eax, DWORD PTR _i$220031[ebp]
	push	eax
	mov	ecx, DWORD PTR tv367[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv367[ebp]
	mov	eax, DWORD PTR [edx+972]
	call	eax

; 2122 : 			gDLL->TradeVisuals_UpdateRouteDirection(i, writeTo.m_aTradeConnections[i].m_bTradeUnitMovingForward);

	mov	ecx, DWORD PTR $T230740[ebp]
	mov	DWORD PTR tv399[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv399[ebp], edx
	mov	eax, DWORD PTR _i$220031[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax+40]
	push	eax
	mov	ecx, DWORD PTR _i$220031[ebp]
	push	ecx
	mov	edx, DWORD PTR tv399[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv399[ebp]
	mov	edx, DWORD PTR [eax+976]
	call	edx
$LN19@operator:

; 2123 : 		}
; 2124 : 
; 2125 : 		for (uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$220053[ebp], 0
	jmp	SHORT $LN17@operator
$LN16@operator:
	mov	eax, DWORD PTR _ui$220053[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$220053[ebp], eax
$LN17@operator:
	cmp	DWORD PTR _ui$220053[ebp], 6
	jae	SHORT $LN15@operator

; 2126 : 		{
; 2127 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aiOriginYields[ui];

	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _ui$220053[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+396]
	mov	DWORD PTR $T230750[ebp], edx
	mov	eax, DWORD PTR $T230750[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2128 : 			loadFrom >> writeTo.m_aTradeConnections[i].m_aiDestYields[ui];

	mov	ecx, DWORD PTR _i$220031[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _ui$220053[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+420]
	mov	DWORD PTR $T230757[ebp], edx
	mov	eax, DWORD PTR $T230757[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2129 : 		}

	jmp	$LN16@operator
$LN15@operator:

; 2130 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kTradeConnection$220035[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN29@operator
$LN28@operator:

; 2131 : 
; 2132 : 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[ebp], 3
	jb	SHORT $LN14@operator

; 2133 : 	{
; 2134 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$220058[ebp], 0
	jmp	SHORT $LN13@operator
$LN12@operator:
	mov	ecx, DWORD PTR _ui$220058[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220058[ebp], ecx
$LN13@operator:
	cmp	DWORD PTR _ui$220058[ebp], 22		; 00000016H
	jae	SHORT $LN11@operator

; 2135 : 		{
; 2136 : 			for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)

	mov	DWORD PTR _ui2$220062[ebp], 0
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	edx, DWORD PTR _ui2$220062[ebp]
	add	edx, 1
	mov	DWORD PTR _ui2$220062[ebp], edx
$LN10@operator:
	cmp	DWORD PTR _ui2$220062[ebp], 22		; 00000016H
	jae	SHORT $LN8@operator

; 2137 : 			{
; 2138 : 				loadFrom >> writeTo.m_aaiTechDifference[ui][ui2];

	mov	eax, DWORD PTR _ui$220058[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _writeTo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+74612]
	mov	eax, DWORD PTR _ui2$220062[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2139 : 			}

	jmp	SHORT $LN9@operator
$LN8@operator:

; 2140 : 		}

	jmp	SHORT $LN12@operator
$LN11@operator:

; 2141 : 	}
; 2142 : 	else

	jmp	SHORT $LN7@operator
$LN14@operator:

; 2143 : 	{
; 2144 : 		for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$220067[ebp], 0
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	edx, DWORD PTR _ui$220067[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$220067[ebp], edx
$LN6@operator:
	cmp	DWORD PTR _ui$220067[ebp], 22		; 00000016H
	jae	SHORT $LN7@operator

; 2145 : 		{
; 2146 : 			for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)

	mov	DWORD PTR _ui2$220071[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	eax, DWORD PTR _ui2$220071[ebp]
	add	eax, 1
	mov	DWORD PTR _ui2$220071[ebp], eax
$LN3@operator:
	cmp	DWORD PTR _ui2$220071[ebp], 22		; 00000016H
	jae	SHORT $LN1@operator

; 2147 : 			{
; 2148 : 				writeTo.m_aaiTechDifference[ui][ui2] = 0;

	mov	ecx, DWORD PTR _ui$220067[ebp]
	imul	ecx, 88					; 00000058H
	mov	edx, DWORD PTR _writeTo$[ebp]
	lea	eax, DWORD PTR [edx+ecx+74612]
	mov	ecx, DWORD PTR _ui2$220071[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 2149 : 			}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 2150 : 		}

	jmp	SHORT $LN5@operator
$LN7@operator:

; 2151 : 	}
; 2152 : 
; 2153 : 	loadFrom >> writeTo.m_iNextID;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 74608				; 00012370H
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2154 : 
; 2155 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 2156 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z$0:
	lea	ecx, DWORD PTR _kTradeConnection$220035[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2692]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-2076]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvGameTrade@@@Z ENDP	; operator>>
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z	; operator<<
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z
_TEXT	SEGMENT
$T230970 = -132						; size = 4
$T230963 = -128						; size = 4
$T230956 = -124						; size = 4
$T230949 = -120						; size = 4
$T230945 = -116						; size = 4
$T230938 = -112						; size = 4
$T230934 = -108						; size = 4
$T230930 = -104						; size = 4
$T230923 = -100						; size = 4
$T230919 = -96						; size = 4
$T230915 = -92						; size = 4
$T230908 = -88						; size = 4
$T230901 = -84						; size = 4
$T230894 = -80						; size = 4
$T230887 = -76						; size = 4
$T230880 = -72						; size = 4
$T230855 = -68						; size = 4
$T230848 = -64						; size = 4
$T230841 = -60						; size = 4
$T230834 = -56						; size = 4
$T230827 = -52						; size = 4
$T230820 = -48						; size = 4
$T230813 = -44						; size = 4
$T230806 = -40						; size = 4
$T230805 = -36						; size = 4
$T230804 = -32						; size = 4
$T230803 = -28						; size = 4
_ui2$220102 = -24					; size = 4
_ui$220098 = -20					; size = 4
_ui2$220094 = -16					; size = 4
_ui2$220090 = -12					; size = 4
_ui$220081 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z PROC	; operator<<, COMDAT

; 2160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H

; 2161 : 	uint uiVersion = 3;

	mov	DWORD PTR _uiVersion$[ebp], 3

; 2162 : 	saveTo << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2163 : 
; 2164 : 	saveTo << readFrom.m_aTradeConnections.size();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T230813[ebp], edx
	mov	eax, DWORD PTR $T230813[ebp]
	mov	DWORD PTR $T230803[ebp], eax
	lea	ecx, DWORD PTR $T230803[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2165 : #ifdef AUI_ITERATORIZE
; 2166 : 	for (TradeConnectionList::const_iterator it = readFrom.m_aTradeConnections.begin(); it != readFrom.m_aTradeConnections.end(); ++it)
; 2167 : 	{
; 2168 : 		saveTo << it->m_iID;
; 2169 : 
; 2170 : 		saveTo << it->m_iOriginX;
; 2171 : 		saveTo << it->m_iOriginY;
; 2172 : 		saveTo << it->m_iDestX;
; 2173 : 		saveTo << it->m_iDestY;
; 2174 : 		saveTo << it->m_eOriginOwner;
; 2175 : 		saveTo << it->m_eDestOwner;
; 2176 : 		saveTo << (int)it->m_eDomain;
; 2177 : 		saveTo << (int)it->m_eConnectionType;
; 2178 : 		saveTo << it->m_iTradeUnitLocationIndex;
; 2179 : 		saveTo << it->m_bTradeUnitMovingForward;
; 2180 : 		saveTo << it->m_unitID;
; 2181 : 		saveTo << it->m_iCircuitsCompleted;
; 2182 : 		saveTo << it->m_iCircuitsToComplete;
; 2183 : 		saveTo << it->m_iTurnRouteComplete;
; 2184 : 
; 2185 : 		saveTo << it->m_aPlotList.size();
; 2186 : 		for (TradeConnectionPlotList::const_iterator it2 = it->m_aPlotList.begin(); it2 != it->m_aPlotList.end(); ++it2)
; 2187 : 		{
; 2188 : 			saveTo << it2->m_iX;
; 2189 : 			saveTo << it2->m_iY;
; 2190 : 		}
; 2191 : 
; 2192 : 		for (uint ui = 0; ui < NUM_YIELD_TYPES; ui++)
; 2193 : 		{
; 2194 : 			saveTo << it->m_aiOriginYields[ui];
; 2195 : 			saveTo << it->m_aiDestYields[ui];
; 2196 : #else
; 2197 : 	for (uint ui = 0; ui < readFrom.m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$220081[ebp], 0
	jmp	SHORT $LN15@operator@2
$LN14@operator@2:
	mov	edx, DWORD PTR _ui$220081[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$220081[ebp], edx
$LN15@operator@2:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230820[ebp], ecx
	mov	edx, DWORD PTR _ui$220081[ebp]
	cmp	edx, DWORD PTR $T230820[ebp]
	jae	$LN13@operator@2

; 2198 : 	{
; 2199 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iID;

	mov	eax, DWORD PTR _ui$220081[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T230827[ebp], eax
	mov	edx, DWORD PTR $T230827[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2200 : 
; 2201 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iOriginX;

	mov	eax, DWORD PTR _ui$220081[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR $T230834[ebp], eax
	mov	ecx, DWORD PTR $T230834[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2202 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iOriginY;

	mov	edx, DWORD PTR _ui$220081[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T230841[ebp], edx
	mov	eax, DWORD PTR $T230841[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2203 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iDestX;

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+12]
	mov	DWORD PTR $T230848[ebp], ecx
	mov	edx, DWORD PTR $T230848[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2204 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iDestY;

	mov	eax, DWORD PTR _ui$220081[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR $T230855[ebp], eax
	mov	ecx, DWORD PTR $T230855[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2205 : 		saveTo << readFrom.m_aTradeConnections[ui].m_eOriginOwner;

	mov	edx, DWORD PTR _ui$220081[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+20]
	push	edx
	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 2206 : 		saveTo << readFrom.m_aTradeConnections[ui].m_eDestOwner;

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+24]
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 2207 : 		saveTo << (int)readFrom.m_aTradeConnections[ui].m_eDomain;

	mov	eax, DWORD PTR _ui$220081[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+28]
	mov	DWORD PTR $T230804[ebp], eax
	lea	ecx, DWORD PTR $T230804[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2208 : 		saveTo << (int)readFrom.m_aTradeConnections[ui].m_eConnectionType;

	mov	edx, DWORD PTR _ui$220081[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+32]
	mov	DWORD PTR $T230805[ebp], edx
	lea	eax, DWORD PTR $T230805[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2209 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+36]
	mov	DWORD PTR $T230880[ebp], ecx
	mov	edx, DWORD PTR $T230880[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2210 : 		saveTo << readFrom.m_aTradeConnections[ui].m_bTradeUnitMovingForward;

	mov	eax, DWORD PTR _ui$220081[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+40]
	mov	DWORD PTR $T230887[ebp], eax
	mov	ecx, DWORD PTR $T230887[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2211 : 		saveTo << readFrom.m_aTradeConnections[ui].m_unitID;

	mov	edx, DWORD PTR _ui$220081[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+380]
	mov	DWORD PTR $T230894[ebp], edx
	mov	eax, DWORD PTR $T230894[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2212 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iCircuitsCompleted;

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+384]
	mov	DWORD PTR $T230901[ebp], ecx
	mov	edx, DWORD PTR $T230901[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2213 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iCircuitsToComplete;

	mov	eax, DWORD PTR _ui$220081[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+388]
	mov	DWORD PTR $T230908[ebp], eax
	mov	ecx, DWORD PTR $T230908[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2214 : 		saveTo << readFrom.m_aTradeConnections[ui].m_iTurnRouteComplete;

	mov	edx, DWORD PTR _ui$220081[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+392]
	mov	DWORD PTR $T230915[ebp], edx
	mov	eax, DWORD PTR $T230915[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2215 : 
; 2216 : 		saveTo << readFrom.m_aTradeConnections[ui].m_aPlotList.size();

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T230919[ebp], ecx
	mov	eax, DWORD PTR $T230919[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T230923[ebp], ecx
	mov	edx, DWORD PTR $T230923[ebp]
	mov	DWORD PTR $T230806[ebp], edx
	lea	eax, DWORD PTR $T230806[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2217 : 		for (uint ui2 = 0; ui2 < readFrom.m_aTradeConnections[ui].m_aPlotList.size(); ui2++)

	mov	DWORD PTR _ui2$220090[ebp], 0
	jmp	SHORT $LN12@operator@2
$LN11@operator@2:
	mov	ecx, DWORD PTR _ui2$220090[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui2$220090[ebp], ecx
$LN12@operator@2:
	mov	edx, DWORD PTR _ui$220081[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T230930[ebp], edx
	mov	ecx, DWORD PTR $T230930[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T230934[ebp], edx
	mov	eax, DWORD PTR _ui2$220090[ebp]
	cmp	eax, DWORD PTR $T230934[ebp]
	jae	SHORT $LN10@operator@2

; 2218 : 		{
; 2219 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aPlotList[ui2].m_iX;

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T230938[ebp], ecx
	mov	eax, DWORD PTR $T230938[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _ui2$220090[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T230945[ebp], eax
	mov	ecx, DWORD PTR $T230945[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2220 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aPlotList[ui2].m_iY;

	mov	edx, DWORD PTR _ui$220081[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T230949[ebp], edx
	mov	ecx, DWORD PTR $T230949[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _ui2$220090[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR $T230956[ebp], ecx
	mov	edx, DWORD PTR $T230956[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2221 : 		}

	jmp	$LN11@operator@2
$LN10@operator@2:

; 2222 : 
; 2223 : 		for (uint ui2 = 0; ui2 < NUM_YIELD_TYPES; ui2++)

	mov	DWORD PTR _ui2$220094[ebp], 0
	jmp	SHORT $LN9@operator@2
$LN8@operator@2:
	mov	eax, DWORD PTR _ui2$220094[ebp]
	add	eax, 1
	mov	DWORD PTR _ui2$220094[ebp], eax
$LN9@operator@2:
	cmp	DWORD PTR _ui2$220094[ebp], 6
	jae	SHORT $LN7@operator@2

; 2224 : 		{
; 2225 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aiOriginYields[ui2];

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _ui2$220094[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+396]
	mov	DWORD PTR $T230963[ebp], edx
	mov	eax, DWORD PTR $T230963[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2226 : 			saveTo << readFrom.m_aTradeConnections[ui].m_aiDestYields[ui2];

	mov	ecx, DWORD PTR _ui$220081[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _ui2$220094[ebp]
	lea	edx, DWORD PTR [eax+ecx*4+420]
	mov	DWORD PTR $T230970[ebp], edx
	mov	eax, DWORD PTR $T230970[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2227 : #endif
; 2228 : 		}

	jmp	SHORT $LN8@operator@2
$LN7@operator@2:

; 2229 : 	}

	jmp	$LN14@operator@2
$LN13@operator@2:

; 2230 : 
; 2231 : 	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$220098[ebp], 0
	jmp	SHORT $LN6@operator@2
$LN5@operator@2:
	mov	ecx, DWORD PTR _ui$220098[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220098[ebp], ecx
$LN6@operator@2:
	cmp	DWORD PTR _ui$220098[ebp], 22		; 00000016H
	jae	SHORT $LN4@operator@2

; 2232 : 	{
; 2233 : 		for (uint ui2 = 0; ui2 < MAX_MAJOR_CIVS; ui2++)

	mov	DWORD PTR _ui2$220102[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	edx, DWORD PTR _ui2$220102[ebp]
	add	edx, 1
	mov	DWORD PTR _ui2$220102[ebp], edx
$LN3@operator@2:
	cmp	DWORD PTR _ui2$220102[ebp], 22		; 00000016H
	jae	SHORT $LN1@operator@2

; 2234 : 		{
; 2235 : 			saveTo << readFrom.m_aaiTechDifference[ui][ui2];

	mov	eax, DWORD PTR _ui$220098[ebp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR _readFrom$[ebp]
	lea	edx, DWORD PTR [ecx+eax+74612]
	mov	eax, DWORD PTR _ui2$220102[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2236 : 		}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 2237 : 	}

	jmp	SHORT $LN5@operator@2
$LN4@operator@2:

; 2238 : 
; 2239 : 	saveTo << readFrom.m_iNextID;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 74608				; 00012370H
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2240 : 
; 2241 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 2242 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvGameTrade@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
PUBLIC	?Reset@CvPlayerTrade@@QAEXXZ			; CvPlayerTrade::Reset
PUBLIC	??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
PUBLIC	??0CvPlayerTrade@@QAE@XZ			; CvPlayerTrade::CvPlayerTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvPlayerTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$1
__ehfuncinfo$??0CvPlayerTrade@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvPlayerTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlayerTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlayerTrade@@QAE@XZ PROC				; CvPlayerTrade::CvPlayerTrade, COMDAT
; _this$ = ecx

; 2250 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPlayerTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 74608				; 00012370H
	call	??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2251 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvPlayerTrade@@QAEXXZ		; CvPlayerTrade::Reset

; 2252 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__unwindfunclet$??0CvPlayerTrade@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 74608				; 00012370H
	jmp	??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
__ehhandler$??0CvPlayerTrade@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPlayerTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlayerTrade@@QAE@XZ ENDP				; CvPlayerTrade::CvPlayerTrade
PUBLIC	??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>
PUBLIC	?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free
PUBLIC	??1CvPlayerTrade@@QAE@XZ			; CvPlayerTrade::~CvPlayerTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPlayerTrade@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$6
__ehfuncinfo$??1CvPlayerTrade@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvPlayerTrade@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlayerTrade@@QAE@XZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T231071 = -32						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlayerTrade@@QAE@XZ PROC				; CvPlayerTrade::~CvPlayerTrade, COMDAT
; _this$ = ecx

; 2257 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPlayerTrade@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2258 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvPlayerTrade@@QAEXXZ		; CvPlayerTrade::Reset

; 2259 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 74608				; 00012370H
	mov	DWORD PTR $T231071[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T231071[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T231071[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T231071[ebp]
	call	?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 74608				; 00012370H
	jmp	??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T231071[ebp]
	jmp	??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>
__unwindfunclet$??1CvPlayerTrade@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
__ehhandler$??1CvPlayerTrade@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPlayerTrade@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlayerTrade@@QAE@XZ ENDP				; CvPlayerTrade::~CvPlayerTrade
PUBLIC	?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z	; CvPlayerTrade::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z PROC		; CvPlayerTrade::Init, COMDAT
; _this$ = ecx

; 2264 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2265 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvPlayerTrade@@QAEXXZ		; CvPlayerTrade::Reset

; 2266 : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+79104], ecx

; 2267 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvPlayerTrade@@QAEXPAVCvPlayer@@@Z ENDP		; CvPlayerTrade::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvPlayerTrade@@QAEXXZ			; CvPlayerTrade::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninit@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::Uninit, COMDAT
; _this$ = ecx

; 2272 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2273 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvPlayerTrade@@QAEXXZ		; CvPlayerTrade::Reset

; 2274 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::Uninit
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ ; BaseVector<TradeConnectionWasPlundered,0>::clear
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
?Reset@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::Reset, COMDAT
; _this$ = ecx

; 2278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 2279 : 	m_pPlayer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+79104], 0

; 2280 : 	m_aRecentlyExpiredConnections.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ ; BaseVector<TradeConnection,0>::clear

; 2281 : 	m_aTradeConnectionWasPlundered.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 74608				; 00012370H
	call	?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ ; BaseVector<TradeConnectionWasPlundered,0>::clear

; 2282 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::Reset
_TEXT	ENDS
PUBLIC	?MoveUnits@CvPlayerTrade@@QAEXXZ		; CvPlayerTrade::MoveUnits
PUBLIC	?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionWasPlundered
PUBLIC	?DoTurn@CvPlayerTrade@@QAEXXZ			; CvPlayerTrade::DoTurn
; Function compile flags: /Odtp
;	COMDAT ?DoTurn@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
?DoTurn@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::DoTurn, COMDAT
; _this$ = ecx

; 2287 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2288 : 	m_aRecentlyExpiredConnections.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ ; BaseVector<TradeConnection,0>::clear

; 2289 : 	UpdateTradeConnectionValues();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionValues

; 2290 : 	UpdateTradeConnectionWasPlundered();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ ; CvPlayerTrade::UpdateTradeConnectionWasPlundered

; 2291 : 	MoveUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveUnits@CvPlayerTrade@@QAEXXZ	; CvPlayerTrade::MoveUnits

; 2292 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTurn@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::DoTurn
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?MoveUnits@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T231340 = -40						; size = 4
$T231328 = -36						; size = 4
$T231324 = -32						; size = 4
_iOriginY$220142 = -28					; size = 4
_iOriginX$220141 = -24					; size = 4
_eDomain$220143 = -20					; size = 4
_eUnitType$220144 = -16					; size = 4
_pTradeConnection$220138 = -12				; size = 4
_ui$220134 = -8						; size = 4
_pTrade$ = -4						; size = 4
?MoveUnits@CvPlayerTrade@@QAEXXZ PROC			; CvPlayerTrade::MoveUnits, COMDAT
; _this$ = ecx

; 2297 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 2298 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231324[ebp], eax
	mov	ecx, DWORD PTR $T231324[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 2299 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$220134[ebp], 0
	jmp	SHORT $LN5@MoveUnits
$LN4@MoveUnits:
	mov	ecx, DWORD PTR _ui$220134[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220134[ebp], ecx
$LN5@MoveUnits:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231328[ebp], eax
	mov	ecx, DWORD PTR _ui$220134[ebp]
	cmp	ecx, DWORD PTR $T231328[ebp]
	jae	$LN6@MoveUnits

; 2300 : 	{
; 2301 : 		TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	edx, DWORD PTR _ui$220134[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pTradeConnection$220138[ebp], edx

; 2302 : 		if (pTradeConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T231340[ebp], eax
	mov	ecx, DWORD PTR _pTradeConnection$220138[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR $T231340[ebp]
	jne	$LN2@MoveUnits

; 2303 : 		{
; 2304 : 			pTrade->MoveUnit(ui);

	mov	eax, DWORD PTR _ui$220134[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?MoveUnit@CvGameTrade@@QAE_NH@Z		; CvGameTrade::MoveUnit

; 2305 : 
; 2306 : 			// check to see if the trade route is still active but the circuit is completed
; 2307 : 			if (!pTrade->IsTradeRouteIndexEmpty(ui) && pTradeConnection->m_iCircuitsCompleted >= pTradeConnection->m_iCircuitsToComplete)

	mov	ecx, DWORD PTR _ui$220134[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@MoveUnits
	mov	eax, DWORD PTR _pTradeConnection$220138[ebp]
	mov	ecx, DWORD PTR _pTradeConnection$220138[ebp]
	mov	edx, DWORD PTR [eax+384]
	cmp	edx, DWORD PTR [ecx+388]
	jl	SHORT $LN2@MoveUnits

; 2308 : 			{
; 2309 : 				m_aRecentlyExpiredConnections.push_back(*pTradeConnection);

	mov	eax, DWORD PTR _pTradeConnection$220138[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 2310 : 
; 2311 : 				// get data before we wipe the trade route
; 2312 : 				int iOriginX = pTradeConnection->m_iOriginX;

	mov	ecx, DWORD PTR _pTradeConnection$220138[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _iOriginX$220141[ebp], edx

; 2313 : 				int iOriginY = pTradeConnection->m_iOriginY;

	mov	eax, DWORD PTR _pTradeConnection$220138[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _iOriginY$220142[ebp], ecx

; 2314 : 				DomainTypes eDomain = pTradeConnection->m_eDomain;

	mov	edx, DWORD PTR _pTradeConnection$220138[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _eDomain$220143[ebp], eax

; 2315 : 
; 2316 : 				// wipe trade route
; 2317 : 				pTrade->EmptyTradeRoute(ui);

	mov	ecx, DWORD PTR _ui$220134[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute

; 2318 : 				
; 2319 : 				// create new unit
; 2320 : 				UnitTypes eUnitType = GetTradeUnit(eDomain);

	mov	edx, DWORD PTR _eDomain$220143[ebp]
	push	edx
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	mov	DWORD PTR _eUnitType$220144[ebp], eax

; 2321 : #ifdef CVASSERT_ENABLE
; 2322 : 				CvUnit* pRebornUnit = m_pPlayer->initUnit(eUnitType, iOriginX, iOriginY, UNITAI_TRADE_UNIT);
; 2323 : 
; 2324 : 				DEBUG_VARIABLE(pRebornUnit);
; 2325 : 				CvAssertMsg(pRebornUnit, "pRebornUnit is null. This is bad!!");
; 2326 : #else
; 2327 : 				m_pPlayer->initUnit(eUnitType, iOriginX, iOriginY, UNITAI_TRADE_UNIT);

	push	0
	push	0
	push	1
	push	0
	push	-1
	push	38					; 00000026H
	mov	eax, DWORD PTR _iOriginY$220142[ebp]
	push	eax
	mov	ecx, DWORD PTR _iOriginX$220141[ebp]
	push	ecx
	mov	edx, DWORD PTR _eUnitType$220144[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN2@MoveUnits:

; 2328 : #endif
; 2329 : 			}
; 2330 : 		}

	jmp	$LN4@MoveUnits
$LN6@MoveUnits:

; 2331 : 	}
; 2332 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MoveUnits@CvPlayerTrade@@QAEXXZ ENDP			; CvPlayerTrade::MoveUnits
_TEXT	ENDS
PUBLIC	__real@40000000
PUBLIC	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
EXTRN	?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceTradeRouteScienceBonus
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	__imp__ceil:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@40000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
CONST	ENDS
;	COMDAT ?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
tv173 = -88						; size = 4
tv227 = -84						; size = 4
tv76 = -80						; size = 4
tv195 = -76						; size = 4
_this$ = -72						; size = 4
$T231433 = -68						; size = 4
$T231419 = -64						; size = 4
$T231415 = -60						; size = 4
$T231409 = -56						; size = 4
$T231394 = -52						; size = 4
$T231387 = -48						; size = 4
$T231383 = -44						; size = 4
$T231382 = -40						; size = 4
_iCeilTechDifference$220170 = -36			; size = 4
_iTechDifference$220167 = -32				; size = 4
_iAdjustedTechDifference$220168 = -28			; size = 4
_iCeilTechDifference$220161 = -24			; size = 4
_iInfluenceBoost$220164 = -20				; size = 4
_iTechDifference$220158 = -16				; size = 4
_iAdjustedTechDifference$220159 = -12			; size = 4
_iResult$220154 = -8					; size = 4
_iBase$220155 = -4					; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100, COMDAT
; _this$ = ecx

; 2340 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 2341 : 	if (bAsOriginPlayer)

	movzx	eax, BYTE PTR _bAsOriginPlayer$[ebp]
	test	eax, eax
	je	$LN10@GetTradeCo

; 2342 : 	{
; 2343 : 		if (GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231387[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231387[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	movzx	eax, al
	test	eax, eax
	je	$LN6@GetTradeCo

; 2344 : 		{
; 2345 : 			if (eYield == YIELD_GOLD)

	cmp	DWORD PTR _eYield$[ebp], 2
	jne	SHORT $LN8@GetTradeCo

; 2346 : 			{
; 2347 : 				int iResult = 0;

	mov	DWORD PTR _iResult$220154[ebp], 0

; 2348 : 				int iBase = GC.getINTERNATIONAL_TRADE_BASE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7956
	mov	DWORD PTR _iBase$220155[ebp], ecx

; 2349 : 				iResult = iBase;

	mov	edx, DWORD PTR _iBase$220155[ebp]
	mov	DWORD PTR _iResult$220154[ebp], edx

; 2350 : 				return iResult;

	mov	eax, DWORD PTR _iResult$220154[ebp]
	jmp	$LN11@GetTradeCo
	jmp	$LN6@GetTradeCo
$LN8@GetTradeCo:

; 2351 : 			}
; 2352 : 			else if (eYield == YIELD_SCIENCE)

	cmp	DWORD PTR _eYield$[ebp], 3
	jne	$LN6@GetTradeCo

; 2353 : 			{
; 2354 : 				int iTechDifference = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eOriginOwner, kTradeConnection.m_eDestOwner);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231394[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR $T231394[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference
	mov	DWORD PTR _iTechDifference$220158[ebp], eax

; 2355 : 				int iAdjustedTechDifference = 0;

	mov	DWORD PTR _iAdjustedTechDifference$220159[ebp], 0

; 2356 : 				if (iTechDifference > 0)

	cmp	DWORD PTR _iTechDifference$220158[ebp], 0
	jle	SHORT $LN5@GetTradeCo

; 2357 : 				{
; 2358 : 					int iCeilTechDifference = (int)ceil(iTechDifference / 2.0f);

	cvtsi2ss xmm0, DWORD PTR _iTechDifference$220158[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	fstp	DWORD PTR tv195[ebp]
	fld	DWORD PTR tv195[ebp]
	call	__ftol2_sse
	mov	DWORD PTR _iCeilTechDifference$220161[ebp], eax

; 2359 : 					iAdjustedTechDifference = max(iCeilTechDifference, 1);

	mov	DWORD PTR $T231382[ebp], 1
	mov	edx, DWORD PTR _iCeilTechDifference$220161[ebp]
	cmp	edx, DWORD PTR $T231382[ebp]
	jge	SHORT $LN25@GetTradeCo
	lea	eax, DWORD PTR $T231382[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN26@GetTradeCo
$LN25@GetTradeCo:
	lea	ecx, DWORD PTR _iCeilTechDifference$220161[ebp]
	mov	DWORD PTR tv76[ebp], ecx
$LN26@GetTradeCo:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T231409[ebp], edx
	mov	eax, DWORD PTR $T231409[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iAdjustedTechDifference$220159[ebp], ecx
$LN5@GetTradeCo:

; 2360 : 				}
; 2361 : 
; 2362 : 				// Cultural influence bump
; 2363 : 				int iInfluenceBoost = GET_PLAYER(kTradeConnection.m_eOriginOwner).GetCulture()->GetInfluenceTradeRouteScienceBonus(kTradeConnection.m_eDestOwner);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231415[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR $T231415[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceTradeRouteScienceBonus@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceTradeRouteScienceBonus
	mov	DWORD PTR _iInfluenceBoost$220164[ebp], eax

; 2364 : 				iAdjustedTechDifference += iInfluenceBoost;

	mov	eax, DWORD PTR _iAdjustedTechDifference$220159[ebp]
	add	eax, DWORD PTR _iInfluenceBoost$220164[ebp]
	mov	DWORD PTR _iAdjustedTechDifference$220159[ebp], eax

; 2365 : 
; 2366 : 				return iAdjustedTechDifference * 100;

	mov	eax, DWORD PTR _iAdjustedTechDifference$220159[ebp]
	imul	eax, 100				; 00000064H
	jmp	$LN11@GetTradeCo
$LN6@GetTradeCo:

; 2367 : 			}
; 2368 : 		}
; 2369 : 	}
; 2370 : 	else

	jmp	$LN1@GetTradeCo
$LN10@GetTradeCo:

; 2371 : 	{
; 2372 : 		if (eYield == YIELD_SCIENCE)

	cmp	DWORD PTR _eYield$[ebp], 3
	jne	$LN3@GetTradeCo

; 2373 : 		{
; 2374 : 			int iTechDifference = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eDestOwner, kTradeConnection.m_eOriginOwner);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231419[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR $T231419[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference
	mov	DWORD PTR _iTechDifference$220167[ebp], eax

; 2375 : 			int iAdjustedTechDifference = 0;

	mov	DWORD PTR _iAdjustedTechDifference$220168[ebp], 0

; 2376 : 			if (iTechDifference > 0)

	cmp	DWORD PTR _iTechDifference$220167[ebp], 0
	jle	SHORT $LN2@GetTradeCo

; 2377 : 			{
; 2378 : 				int iCeilTechDifference = (int)ceil(iTechDifference / 2.0f);

	cvtsi2ss xmm0, DWORD PTR _iTechDifference$220167[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__ceil
	add	esp, 8
	fstp	DWORD PTR tv227[ebp]
	fld	DWORD PTR tv227[ebp]
	call	__ftol2_sse
	mov	DWORD PTR _iCeilTechDifference$220170[ebp], eax

; 2379 : 				iAdjustedTechDifference = max(iCeilTechDifference, 1);

	mov	DWORD PTR $T231383[ebp], 1
	mov	eax, DWORD PTR _iCeilTechDifference$220170[ebp]
	cmp	eax, DWORD PTR $T231383[ebp]
	jge	SHORT $LN37@GetTradeCo
	lea	ecx, DWORD PTR $T231383[ebp]
	mov	DWORD PTR tv173[ebp], ecx
	jmp	SHORT $LN38@GetTradeCo
$LN37@GetTradeCo:
	lea	edx, DWORD PTR _iCeilTechDifference$220170[ebp]
	mov	DWORD PTR tv173[ebp], edx
$LN38@GetTradeCo:
	mov	eax, DWORD PTR tv173[ebp]
	mov	DWORD PTR $T231433[ebp], eax
	mov	ecx, DWORD PTR $T231433[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iAdjustedTechDifference$220168[ebp], edx
$LN2@GetTradeCo:

; 2380 : 			}
; 2381 : 
; 2382 : 			return  iAdjustedTechDifference * 100;

	mov	eax, DWORD PTR _iAdjustedTechDifference$220168[ebp]
	imul	eax, 100				; 00000064H
	jmp	SHORT $LN11@GetTradeCo

; 2383 : 		}
; 2384 : 		else

	jmp	SHORT $LN1@GetTradeCo
$LN3@GetTradeCo:

; 2385 : 		{
; 2386 : 			return 100;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN11@GetTradeCo
$LN1@GetTradeCo:

; 2387 : 		}
; 2388 : 	}
; 2389 : 
; 2390 : 	return 0;

	xor	eax, eax
$LN11@GetTradeCo:

; 2391 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100
EXTRN	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRateTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z
_TEXT	SEGMENT
tv162 = -80						; size = 4
tv177 = -76						; size = 4
_this$ = -72						; size = 4
$T231507 = -64						; size = 4
$T231494 = -60						; size = 4
$T231490 = -56						; size = 4
$T231476 = -52						; size = 4
$T231472 = -45						; size = 1
$T231461 = -44						; size = 4
$T231457 = -37						; size = 1
_iMapY$231551 = -36					; size = 4
_iMapX$231550 = -32					; size = 4
$T231450 = -28						; size = 4
$T231446 = -24						; size = 4
_iDivisor$220192 = -20					; size = 4
_pPlot$220188 = -16					; size = 4
_iX$220184 = -12					; size = 4
_pCity$220190 = -8					; size = 4
_iY$220185 = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
_bOriginCity$ = 20					; size = 1
?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z PROC ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100, COMDAT
; _this$ = ecx

; 2399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 2400 : 	if (bAsOriginPlayer)

	movzx	eax, BYTE PTR _bAsOriginPlayer$[ebp]
	test	eax, eax
	je	$LN9@GetTradeCo@2

; 2401 : 	{
; 2402 : 		if (GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231446[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231446[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	movzx	eax, al
	test	eax, eax
	je	$LN8@GetTradeCo@2

; 2403 : 		{
; 2404 : 			if (eYield == YIELD_GOLD)

	cmp	DWORD PTR _eYield$[ebp], 2
	jne	$LN8@GetTradeCo@2

; 2405 : 			{
; 2406 : 				int iX, iY;
; 2407 : 				if (bOriginCity)

	movzx	ecx, BYTE PTR _bOriginCity$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@GetTradeCo@2

; 2408 : 				{
; 2409 : 					iX = kTradeConnection.m_iOriginX;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iX$220184[ebp], eax

; 2410 : 					iY = kTradeConnection.m_iOriginY;

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _iY$220185[ebp], edx

; 2411 : 				}
; 2412 : 				else

	jmp	SHORT $LN5@GetTradeCo@2
$LN6@GetTradeCo@2:

; 2413 : 				{
; 2414 : 					iX = kTradeConnection.m_iDestX;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iX$220184[ebp], ecx

; 2415 : 					iY = kTradeConnection.m_iDestY;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iY$220185[ebp], eax
$LN5@GetTradeCo@2:

; 2416 : 				}
; 2417 : 
; 2418 : 				CvPlot* pPlot = GC.getMap().plot(iX, iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231450[ebp], ecx
	cmp	DWORD PTR _iX$220184[ebp], -2147483647	; 80000001H
	je	SHORT $LN16@GetTradeCo@2
	cmp	DWORD PTR _iY$220185[ebp], -2147483647	; 80000001H
	jne	SHORT $LN17@GetTradeCo@2
$LN16@GetTradeCo@2:
	mov	DWORD PTR _pPlot$220188[ebp], 0
	jmp	$LN18@GetTradeCo@2
$LN17@GetTradeCo@2:
	mov	edx, DWORD PTR $T231450[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T231457[ebp], al
	mov	ecx, DWORD PTR $T231450[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231461[ebp], edx
	movzx	eax, BYTE PTR $T231457[ebp]
	test	eax, eax
	je	SHORT $LN29@GetTradeCo@2
	cmp	DWORD PTR _iX$220184[ebp], 0
	jge	SHORT $LN28@GetTradeCo@2
	mov	eax, DWORD PTR _iX$220184[ebp]
	cdq
	idiv	DWORD PTR $T231461[ebp]
	add	edx, DWORD PTR $T231461[ebp]
	mov	DWORD PTR _iMapX$231550[ebp], edx
	jmp	SHORT $LN30@GetTradeCo@2
	jmp	SHORT $LN29@GetTradeCo@2
$LN28@GetTradeCo@2:
	mov	ecx, DWORD PTR _iX$220184[ebp]
	cmp	ecx, DWORD PTR $T231461[ebp]
	jl	SHORT $LN29@GetTradeCo@2
	mov	eax, DWORD PTR _iX$220184[ebp]
	cdq
	idiv	DWORD PTR $T231461[ebp]
	mov	DWORD PTR _iMapX$231550[ebp], edx
	jmp	SHORT $LN30@GetTradeCo@2
$LN29@GetTradeCo@2:
	mov	edx, DWORD PTR _iX$220184[ebp]
	mov	DWORD PTR _iMapX$231550[ebp], edx
$LN30@GetTradeCo@2:
	mov	eax, DWORD PTR $T231450[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T231472[ebp], cl
	mov	edx, DWORD PTR $T231450[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T231476[ebp], eax
	movzx	ecx, BYTE PTR $T231472[ebp]
	test	ecx, ecx
	je	SHORT $LN39@GetTradeCo@2
	cmp	DWORD PTR _iY$220185[ebp], 0
	jge	SHORT $LN38@GetTradeCo@2
	mov	eax, DWORD PTR _iY$220185[ebp]
	cdq
	idiv	DWORD PTR $T231476[ebp]
	add	edx, DWORD PTR $T231476[ebp]
	mov	DWORD PTR _iMapY$231551[ebp], edx
	jmp	SHORT $LN40@GetTradeCo@2
	jmp	SHORT $LN39@GetTradeCo@2
$LN38@GetTradeCo@2:
	mov	edx, DWORD PTR _iY$220185[ebp]
	cmp	edx, DWORD PTR $T231476[ebp]
	jl	SHORT $LN39@GetTradeCo@2
	mov	eax, DWORD PTR _iY$220185[ebp]
	cdq
	idiv	DWORD PTR $T231476[ebp]
	mov	DWORD PTR _iMapY$231551[ebp], edx
	jmp	SHORT $LN40@GetTradeCo@2
$LN39@GetTradeCo@2:
	mov	eax, DWORD PTR _iY$220185[ebp]
	mov	DWORD PTR _iMapY$231551[ebp], eax
$LN40@GetTradeCo@2:
	cmp	DWORD PTR _iMapX$231550[ebp], 0
	jl	SHORT $LN44@GetTradeCo@2
	mov	ecx, DWORD PTR $T231450[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231490[ebp], edx
	mov	eax, DWORD PTR _iMapX$231550[ebp]
	cmp	eax, DWORD PTR $T231490[ebp]
	jge	SHORT $LN44@GetTradeCo@2
	cmp	DWORD PTR _iMapY$231551[ebp], 0
	jl	SHORT $LN44@GetTradeCo@2
	mov	ecx, DWORD PTR $T231450[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231494[ebp], edx
	mov	eax, DWORD PTR _iMapY$231551[ebp]
	cmp	eax, DWORD PTR $T231494[ebp]
	jge	SHORT $LN44@GetTradeCo@2
	mov	DWORD PTR tv177[ebp], 1
	jmp	SHORT $LN42@GetTradeCo@2
$LN44@GetTradeCo@2:
	mov	DWORD PTR tv177[ebp], 0
$LN42@GetTradeCo@2:
	cmp	DWORD PTR tv177[ebp], 0
	je	SHORT $LN20@GetTradeCo@2
	mov	ecx, DWORD PTR $T231450[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231507[ebp], edx
	mov	eax, DWORD PTR _iMapY$231551[ebp]
	imul	eax, DWORD PTR $T231507[ebp]
	add	eax, DWORD PTR _iMapX$231550[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T231450[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN21@GetTradeCo@2
$LN20@GetTradeCo@2:
	mov	DWORD PTR tv162[ebp], 0
$LN21@GetTradeCo@2:
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR _pPlot$220188[ebp], edx
$LN18@GetTradeCo@2:

; 2419 : 
; 2420 : 				CvAssertMsg(pPlot, "CvPlayerTrade - plot is null");
; 2421 : 				if (!pPlot)

	cmp	DWORD PTR _pPlot$220188[ebp], 0
	jne	SHORT $LN4@GetTradeCo@2

; 2422 : 				{
; 2423 : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN10@GetTradeCo@2
$LN4@GetTradeCo@2:

; 2424 : 				}
; 2425 : 
; 2426 : 				CvCity* pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$220188[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$220190[ebp], eax

; 2427 : 				CvAssertMsg(pCity, "CvPlayerTrade - pCity is null");	
; 2428 : 				if (!pCity)

	cmp	DWORD PTR _pCity$220190[ebp], 0
	jne	SHORT $LN3@GetTradeCo@2

; 2429 : 				{
; 2430 : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN10@GetTradeCo@2
$LN3@GetTradeCo@2:

; 2431 : 				}
; 2432 : 
; 2433 : 				int iDivisor = GC.getINTERNATIONAL_TRADE_CITY_GPT_DIVISOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7964
	mov	DWORD PTR _iDivisor$220192[ebp], eax

; 2434 : 				if (iDivisor == 0)

	cmp	DWORD PTR _iDivisor$220192[ebp], 0
	jne	SHORT $LN2@GetTradeCo@2

; 2435 : 				{
; 2436 : 					iDivisor = 1;

	mov	DWORD PTR _iDivisor$220192[ebp], 1
$LN2@GetTradeCo@2:

; 2437 : 				}
; 2438 : 				return pCity->getYieldRateTimes100(eYield, true) / iDivisor;

	push	1
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$220190[ebp]
	call	?getYieldRateTimes100@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRateTimes100
	cdq
	idiv	DWORD PTR _iDivisor$220192[ebp]
	jmp	SHORT $LN10@GetTradeCo@2
$LN8@GetTradeCo@2:

; 2439 : 			}
; 2440 : 		}
; 2441 : 	}
; 2442 : 	else

	jmp	SHORT $LN1@GetTradeCo@2
$LN9@GetTradeCo@2:

; 2443 : 	{
; 2444 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN10@GetTradeCo@2
$LN1@GetTradeCo@2:

; 2445 : 	}
; 2446 : 
; 2447 : 	return 0;

	xor	eax, eax
$LN10@GetTradeCo@2:

; 2448 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ENDP ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?IsHasResourceLocal@CvCity@@QBE_NW4ResourceTypes@@_N@Z:PROC ; CvCity::IsHasResourceLocal
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
tv236 = -164						; size = 4
tv251 = -160						; size = 4
tv202 = -156						; size = 4
_this$ = -152						; size = 4
$T231771 = -148						; size = 4
$T231770 = -144						; size = 4
$T231766 = -140						; size = 4
$T231752 = -128						; size = 4
$T231751 = -124						; size = 4
$T231706 = -120						; size = 4
$T231693 = -116						; size = 4
$T231689 = -112						; size = 4
$T231675 = -108						; size = 4
$T231671 = -101						; size = 1
$T231660 = -100						; size = 4
$T231656 = -93						; size = 1
_iMapY$231750 = -92					; size = 4
_iMapX$231749 = -88					; size = 4
$T231649 = -84						; size = 4
$T231645 = -80						; size = 4
$T231644 = -76						; size = 4
$T231607 = -72						; size = 4
$T231595 = -68						; size = 4
$T231591 = -61						; size = 1
$T231580 = -60						; size = 4
$T231576 = -53						; size = 1
_iMapY$231643 = -52					; size = 4
_iMapX$231642 = -48					; size = 4
$T231569 = -44						; size = 4
$T231565 = -40						; size = 4
_eResource$220217 = -36					; size = 4
_pkResourceInfo$220219 = -32				; size = 4
_i$220213 = -28						; size = 4
_pOriginPlot$220204 = -24				; size = 4
_pDestPlot$220205 = -20					; size = 4
_pDestCity$220209 = -16					; size = 4
_iModifer$220224 = -12					; size = 4
_pOriginCity$220208 = -8				; size = 4
_iValue$220212 = -4					; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100, COMDAT
; _this$ = ecx

; 2456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2457 : 	if (bAsOriginPlayer)

	movzx	eax, BYTE PTR _bAsOriginPlayer$[ebp]
	test	eax, eax
	je	$LN15@GetTradeCo@3

; 2458 : 	{
; 2459 : 		if (GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231565[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231565[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	movzx	eax, al
	test	eax, eax
	je	$LN14@GetTradeCo@3

; 2460 : 		{
; 2461 : 			if (eYield == YIELD_GOLD)

	cmp	DWORD PTR _eYield$[ebp], 2
	jne	$LN14@GetTradeCo@3

; 2462 : 			{
; 2463 : 				CvPlot* pOriginPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231569[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T231645[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231644[ebp], edx
	cmp	DWORD PTR $T231644[ebp], -2147483647	; 80000001H
	je	SHORT $LN22@GetTradeCo@3
	cmp	DWORD PTR $T231645[ebp], -2147483647	; 80000001H
	jne	SHORT $LN23@GetTradeCo@3
$LN22@GetTradeCo@3:
	mov	DWORD PTR _pOriginPlot$220204[ebp], 0
	jmp	$LN24@GetTradeCo@3
$LN23@GetTradeCo@3:
	mov	eax, DWORD PTR $T231569[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T231576[ebp], cl
	mov	edx, DWORD PTR $T231569[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T231580[ebp], eax
	movzx	ecx, BYTE PTR $T231576[ebp]
	test	ecx, ecx
	je	SHORT $LN35@GetTradeCo@3
	cmp	DWORD PTR $T231644[ebp], 0
	jge	SHORT $LN34@GetTradeCo@3
	mov	eax, DWORD PTR $T231644[ebp]
	cdq
	idiv	DWORD PTR $T231580[ebp]
	add	edx, DWORD PTR $T231580[ebp]
	mov	DWORD PTR _iMapX$231642[ebp], edx
	jmp	SHORT $LN36@GetTradeCo@3
	jmp	SHORT $LN35@GetTradeCo@3
$LN34@GetTradeCo@3:
	mov	edx, DWORD PTR $T231644[ebp]
	cmp	edx, DWORD PTR $T231580[ebp]
	jl	SHORT $LN35@GetTradeCo@3
	mov	eax, DWORD PTR $T231644[ebp]
	cdq
	idiv	DWORD PTR $T231580[ebp]
	mov	DWORD PTR _iMapX$231642[ebp], edx
	jmp	SHORT $LN36@GetTradeCo@3
$LN35@GetTradeCo@3:
	mov	eax, DWORD PTR $T231644[ebp]
	mov	DWORD PTR _iMapX$231642[ebp], eax
$LN36@GetTradeCo@3:
	mov	ecx, DWORD PTR $T231569[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T231591[ebp], dl
	mov	eax, DWORD PTR $T231569[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T231595[ebp], ecx
	movzx	edx, BYTE PTR $T231591[ebp]
	test	edx, edx
	je	SHORT $LN45@GetTradeCo@3
	cmp	DWORD PTR $T231645[ebp], 0
	jge	SHORT $LN44@GetTradeCo@3
	mov	eax, DWORD PTR $T231645[ebp]
	cdq
	idiv	DWORD PTR $T231595[ebp]
	add	edx, DWORD PTR $T231595[ebp]
	mov	DWORD PTR _iMapY$231643[ebp], edx
	jmp	SHORT $LN46@GetTradeCo@3
	jmp	SHORT $LN45@GetTradeCo@3
$LN44@GetTradeCo@3:
	mov	eax, DWORD PTR $T231645[ebp]
	cmp	eax, DWORD PTR $T231595[ebp]
	jl	SHORT $LN45@GetTradeCo@3
	mov	eax, DWORD PTR $T231645[ebp]
	cdq
	idiv	DWORD PTR $T231595[ebp]
	mov	DWORD PTR _iMapY$231643[ebp], edx
	jmp	SHORT $LN46@GetTradeCo@3
$LN45@GetTradeCo@3:
	mov	ecx, DWORD PTR $T231645[ebp]
	mov	DWORD PTR _iMapY$231643[ebp], ecx
$LN46@GetTradeCo@3:
	mov	edx, DWORD PTR _iMapY$231643[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$231642[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231569[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN26@GetTradeCo@3
	mov	ecx, DWORD PTR $T231569[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231607[ebp], edx
	mov	eax, DWORD PTR _iMapY$231643[ebp]
	imul	eax, DWORD PTR $T231607[ebp]
	add	eax, DWORD PTR _iMapX$231642[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T231569[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv202[ebp], eax
	jmp	SHORT $LN27@GetTradeCo@3
$LN26@GetTradeCo@3:
	mov	DWORD PTR tv202[ebp], 0
$LN27@GetTradeCo@3:
	mov	edx, DWORD PTR tv202[ebp]
	mov	DWORD PTR _pOriginPlot$220204[ebp], edx
$LN24@GetTradeCo@3:

; 2464 : 				CvPlot* pDestPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231649[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T231752[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T231751[ebp], ecx
	cmp	DWORD PTR $T231751[ebp], -2147483647	; 80000001H
	je	SHORT $LN54@GetTradeCo@3
	cmp	DWORD PTR $T231752[ebp], -2147483647	; 80000001H
	jne	SHORT $LN55@GetTradeCo@3
$LN54@GetTradeCo@3:
	mov	DWORD PTR _pDestPlot$220205[ebp], 0
	jmp	$LN56@GetTradeCo@3
$LN55@GetTradeCo@3:
	mov	edx, DWORD PTR $T231649[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T231656[ebp], al
	mov	ecx, DWORD PTR $T231649[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231660[ebp], edx
	movzx	eax, BYTE PTR $T231656[ebp]
	test	eax, eax
	je	SHORT $LN67@GetTradeCo@3
	cmp	DWORD PTR $T231751[ebp], 0
	jge	SHORT $LN66@GetTradeCo@3
	mov	eax, DWORD PTR $T231751[ebp]
	cdq
	idiv	DWORD PTR $T231660[ebp]
	add	edx, DWORD PTR $T231660[ebp]
	mov	DWORD PTR _iMapX$231749[ebp], edx
	jmp	SHORT $LN68@GetTradeCo@3
	jmp	SHORT $LN67@GetTradeCo@3
$LN66@GetTradeCo@3:
	mov	ecx, DWORD PTR $T231751[ebp]
	cmp	ecx, DWORD PTR $T231660[ebp]
	jl	SHORT $LN67@GetTradeCo@3
	mov	eax, DWORD PTR $T231751[ebp]
	cdq
	idiv	DWORD PTR $T231660[ebp]
	mov	DWORD PTR _iMapX$231749[ebp], edx
	jmp	SHORT $LN68@GetTradeCo@3
$LN67@GetTradeCo@3:
	mov	edx, DWORD PTR $T231751[ebp]
	mov	DWORD PTR _iMapX$231749[ebp], edx
$LN68@GetTradeCo@3:
	mov	eax, DWORD PTR $T231649[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T231671[ebp], cl
	mov	edx, DWORD PTR $T231649[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T231675[ebp], eax
	movzx	ecx, BYTE PTR $T231671[ebp]
	test	ecx, ecx
	je	SHORT $LN77@GetTradeCo@3
	cmp	DWORD PTR $T231752[ebp], 0
	jge	SHORT $LN76@GetTradeCo@3
	mov	eax, DWORD PTR $T231752[ebp]
	cdq
	idiv	DWORD PTR $T231675[ebp]
	add	edx, DWORD PTR $T231675[ebp]
	mov	DWORD PTR _iMapY$231750[ebp], edx
	jmp	SHORT $LN78@GetTradeCo@3
	jmp	SHORT $LN77@GetTradeCo@3
$LN76@GetTradeCo@3:
	mov	edx, DWORD PTR $T231752[ebp]
	cmp	edx, DWORD PTR $T231675[ebp]
	jl	SHORT $LN77@GetTradeCo@3
	mov	eax, DWORD PTR $T231752[ebp]
	cdq
	idiv	DWORD PTR $T231675[ebp]
	mov	DWORD PTR _iMapY$231750[ebp], edx
	jmp	SHORT $LN78@GetTradeCo@3
$LN77@GetTradeCo@3:
	mov	eax, DWORD PTR $T231752[ebp]
	mov	DWORD PTR _iMapY$231750[ebp], eax
$LN78@GetTradeCo@3:
	cmp	DWORD PTR _iMapX$231749[ebp], 0
	jl	SHORT $LN82@GetTradeCo@3
	mov	ecx, DWORD PTR $T231649[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231689[ebp], edx
	mov	eax, DWORD PTR _iMapX$231749[ebp]
	cmp	eax, DWORD PTR $T231689[ebp]
	jge	SHORT $LN82@GetTradeCo@3
	cmp	DWORD PTR _iMapY$231750[ebp], 0
	jl	SHORT $LN82@GetTradeCo@3
	mov	ecx, DWORD PTR $T231649[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231693[ebp], edx
	mov	eax, DWORD PTR _iMapY$231750[ebp]
	cmp	eax, DWORD PTR $T231693[ebp]
	jge	SHORT $LN82@GetTradeCo@3
	mov	DWORD PTR tv251[ebp], 1
	jmp	SHORT $LN80@GetTradeCo@3
$LN82@GetTradeCo@3:
	mov	DWORD PTR tv251[ebp], 0
$LN80@GetTradeCo@3:
	cmp	DWORD PTR tv251[ebp], 0
	je	SHORT $LN58@GetTradeCo@3
	mov	ecx, DWORD PTR $T231649[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231706[ebp], edx
	mov	eax, DWORD PTR _iMapY$231750[ebp]
	imul	eax, DWORD PTR $T231706[ebp]
	add	eax, DWORD PTR _iMapX$231749[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T231649[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv236[ebp], eax
	jmp	SHORT $LN59@GetTradeCo@3
$LN58@GetTradeCo@3:
	mov	DWORD PTR tv236[ebp], 0
$LN59@GetTradeCo@3:
	mov	edx, DWORD PTR tv236[ebp]
	mov	DWORD PTR _pDestPlot$220205[ebp], edx
$LN56@GetTradeCo@3:

; 2465 : 
; 2466 : 				CvAssertMsg(pOriginPlot && pDestPlot, "pOriginPlot or pDestPlot are null");
; 2467 : 				if (!pOriginPlot || !pDestPlot)

	cmp	DWORD PTR _pOriginPlot$220204[ebp], 0
	je	SHORT $LN11@GetTradeCo@3
	cmp	DWORD PTR _pDestPlot$220205[ebp], 0
	jne	SHORT $LN12@GetTradeCo@3
$LN11@GetTradeCo@3:

; 2468 : 				{
; 2469 : 					return 0;

	xor	eax, eax
	jmp	$LN16@GetTradeCo@3
$LN12@GetTradeCo@3:

; 2470 : 				}
; 2471 : 
; 2472 : 				CvCity* pOriginCity = pOriginPlot->getPlotCity();

	mov	ecx, DWORD PTR _pOriginPlot$220204[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pOriginCity$220208[ebp], eax

; 2473 : 				CvCity* pDestCity = pDestPlot->getPlotCity();

	mov	ecx, DWORD PTR _pDestPlot$220205[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pDestCity$220209[ebp], eax

; 2474 : 
; 2475 : 				CvAssertMsg(pOriginCity && pDestCity, "pOriginCity or pDestCity are null");
; 2476 : 				if (!pOriginCity || !pDestCity)

	cmp	DWORD PTR _pOriginCity$220208[ebp], 0
	je	SHORT $LN9@GetTradeCo@3
	cmp	DWORD PTR _pDestCity$220209[ebp], 0
	jne	SHORT $LN10@GetTradeCo@3
$LN9@GetTradeCo@3:

; 2477 : 				{
; 2478 : 					return 0;

	xor	eax, eax
	jmp	$LN16@GetTradeCo@3
$LN10@GetTradeCo@3:

; 2479 : 				}
; 2480 : 
; 2481 : 				int iValue = 0;

	mov	DWORD PTR _iValue$220212[ebp], 0

; 2482 : #ifdef AUI_WARNING_FIXES
; 2483 : 				for (uint i = 0; i < GC.getNumResourceInfos(); i++)
; 2484 : #else
; 2485 : 				for(int i = 0; i < GC.getNumResourceInfos(); i++)

	mov	DWORD PTR _i$220213[ebp], 0
	jmp	SHORT $LN8@GetTradeCo@3
$LN7@GetTradeCo@3:
	mov	eax, DWORD PTR _i$220213[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220213[ebp], eax
$LN8@GetTradeCo@3:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _i$220213[ebp], eax
	jge	SHORT $LN6@GetTradeCo@3

; 2486 : #endif
; 2487 : 				{
; 2488 : 					ResourceTypes eResource = (ResourceTypes)i;

	mov	ecx, DWORD PTR _i$220213[ebp]
	mov	DWORD PTR _eResource$220217[ebp], ecx

; 2489 : 					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	edx, DWORD PTR _eResource$220217[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$220219[ebp], eax

; 2490 : 					if (pkResourceInfo)

	cmp	DWORD PTR _pkResourceInfo$220219[ebp], 0
	je	SHORT $LN5@GetTradeCo@3

; 2491 : 					{
; 2492 : 						if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY || pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ecx, DWORD PTR _pkResourceInfo$220219[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	je	SHORT $LN3@GetTradeCo@3
	mov	ecx, DWORD PTR _pkResourceInfo$220219[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN5@GetTradeCo@3
$LN3@GetTradeCo@3:

; 2493 : 						{
; 2494 : 							if (pOriginCity->IsHasResourceLocal(eResource, false) != pDestCity->IsHasResourceLocal(eResource, false))

	push	0
	mov	eax, DWORD PTR _eResource$220217[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOriginCity$220208[ebp]
	call	?IsHasResourceLocal@CvCity@@QBE_NW4ResourceTypes@@_N@Z ; CvCity::IsHasResourceLocal
	movzx	esi, al
	push	0
	mov	ecx, DWORD PTR _eResource$220217[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDestCity$220209[ebp]
	call	?IsHasResourceLocal@CvCity@@QBE_NW4ResourceTypes@@_N@Z ; CvCity::IsHasResourceLocal
	movzx	edx, al
	cmp	esi, edx
	je	SHORT $LN5@GetTradeCo@3

; 2495 : 							{
; 2496 : 								iValue += 50;

	mov	eax, DWORD PTR _iValue$220212[ebp]
	add	eax, 50					; 00000032H
	mov	DWORD PTR _iValue$220212[ebp], eax
$LN5@GetTradeCo@3:

; 2497 : 							}
; 2498 : 						}
; 2499 : 					}
; 2500 : 				}

	jmp	SHORT $LN7@GetTradeCo@3
$LN6@GetTradeCo@3:

; 2501 : 
; 2502 : 				int iModifer = 100 + GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerTraits()->GetTradeRouteResourceModifier();

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231766[ebp], edx
	mov	ecx, DWORD PTR $T231766[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T231770[ebp], eax
	mov	eax, DWORD PTR $T231770[ebp]
	mov	ecx, DWORD PTR [eax+296]
	mov	DWORD PTR $T231771[ebp], ecx
	mov	edx, DWORD PTR $T231771[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _iModifer$220224[ebp], edx

; 2503 : 				iValue *= iModifer;

	mov	eax, DWORD PTR _iValue$220212[ebp]
	imul	eax, DWORD PTR _iModifer$220224[ebp]
	mov	DWORD PTR _iValue$220212[ebp], eax

; 2504 : 				iValue /= 100;

	mov	eax, DWORD PTR _iValue$220212[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$220212[ebp], eax

; 2505 : 
; 2506 : 				return iValue;

	mov	eax, DWORD PTR _iValue$220212[ebp]
	jmp	SHORT $LN16@GetTradeCo@3
$LN14@GetTradeCo@3:

; 2507 : 			}
; 2508 : 		}
; 2509 : 	}
; 2510 : 	else

	jmp	SHORT $LN1@GetTradeCo@3
$LN15@GetTradeCo@3:

; 2511 : 	{
; 2512 : 		return 0;	

	xor	eax, eax
	jmp	SHORT $LN16@GetTradeCo@3
$LN1@GetTradeCo@3:

; 2513 : 	}
; 2514 : 
; 2515 : 	return 0;

	xor	eax, eax
$LN16@GetTradeCo@3:

; 2516 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100
EXTRN	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteLandGoldBonus
EXTRN	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
tv275 = -180						; size = 4
tv287 = -176						; size = 4
tv244 = -172						; size = 4
_this$ = -168						; size = 4
$T231978 = -164						; size = 4
$T231977 = -160						; size = 4
$T231973 = -156						; size = 4
$T231969 = -152						; size = 4
$T231968 = -148						; size = 4
$T231964 = -144						; size = 4
$T231960 = -140						; size = 4
$T231956 = -136						; size = 4
$T231952 = -132						; size = 4
$T231938 = -124						; size = 4
$T231937 = -120						; size = 4
$T231898 = -116						; size = 4
$T231885 = -112						; size = 4
$T231881 = -108						; size = 4
$T231874 = -104						; size = 4
$T231870 = -97						; size = 1
$T231859 = -96						; size = 4
$T231855 = -89						; size = 1
_iMapY$231936 = -88					; size = 4
_iMapX$231935 = -84					; size = 4
$T231848 = -80						; size = 4
$T231844 = -76						; size = 4
$T231843 = -72						; size = 4
$T231812 = -68						; size = 4
$T231807 = -64						; size = 4
$T231803 = -57						; size = 1
$T231792 = -56						; size = 4
$T231788 = -49						; size = 1
_iMapY$231842 = -48					; size = 4
_iMapX$231841 = -44					; size = 4
$T231781 = -40						; size = 4
$T231777 = -36						; size = 4
_pBuildingEntry$220250 = -32				; size = 4
_eBuilding$220247 = -28					; size = 4
_iI$220243 = -24					; size = 4
_pOriginCity$220242 = -20				; size = 4
_pOriginPlot$ = -16					; size = 4
_iBonus$ = -12						; size = 4
_pDestPlot$ = -8					; size = 4
_pDestCity$ = -4					; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100, COMDAT
; _this$ = ecx

; 2524 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	DWORD PTR _this$[ebp], ecx

; 2525 : 	// this only applies to international trade routes, so otherwise, buzz off!
; 2526 : 	if (!GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231777[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231777[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN17@GetTradeCo@4

; 2527 : 	{
; 2528 : 		return 0;

	xor	eax, eax
	jmp	$LN18@GetTradeCo@4
$LN17@GetTradeCo@4:

; 2529 : 	}
; 2530 : 	
; 2531 : 	if (eYield != YIELD_GOLD)

	cmp	DWORD PTR _eYield$[ebp], 2
	je	SHORT $LN16@GetTradeCo@4

; 2532 : 	{
; 2533 : 		return 0;

	xor	eax, eax
	jmp	$LN18@GetTradeCo@4
$LN16@GetTradeCo@4:

; 2534 : 	}
; 2535 : 
; 2536 : 	CvPlot* pOriginPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231781[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231844[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T231843[ebp], ecx
	cmp	DWORD PTR $T231843[ebp], -2147483647	; 80000001H
	je	SHORT $LN24@GetTradeCo@4
	cmp	DWORD PTR $T231844[ebp], -2147483647	; 80000001H
	jne	SHORT $LN25@GetTradeCo@4
$LN24@GetTradeCo@4:
	mov	DWORD PTR _pOriginPlot$[ebp], 0
	jmp	$LN26@GetTradeCo@4
$LN25@GetTradeCo@4:
	mov	edx, DWORD PTR $T231781[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T231788[ebp], al
	mov	ecx, DWORD PTR $T231781[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231792[ebp], edx
	movzx	eax, BYTE PTR $T231788[ebp]
	test	eax, eax
	je	SHORT $LN37@GetTradeCo@4
	cmp	DWORD PTR $T231843[ebp], 0
	jge	SHORT $LN36@GetTradeCo@4
	mov	eax, DWORD PTR $T231843[ebp]
	cdq
	idiv	DWORD PTR $T231792[ebp]
	add	edx, DWORD PTR $T231792[ebp]
	mov	DWORD PTR _iMapX$231841[ebp], edx
	jmp	SHORT $LN38@GetTradeCo@4
	jmp	SHORT $LN37@GetTradeCo@4
$LN36@GetTradeCo@4:
	mov	ecx, DWORD PTR $T231843[ebp]
	cmp	ecx, DWORD PTR $T231792[ebp]
	jl	SHORT $LN37@GetTradeCo@4
	mov	eax, DWORD PTR $T231843[ebp]
	cdq
	idiv	DWORD PTR $T231792[ebp]
	mov	DWORD PTR _iMapX$231841[ebp], edx
	jmp	SHORT $LN38@GetTradeCo@4
$LN37@GetTradeCo@4:
	mov	edx, DWORD PTR $T231843[ebp]
	mov	DWORD PTR _iMapX$231841[ebp], edx
$LN38@GetTradeCo@4:
	mov	eax, DWORD PTR $T231781[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T231803[ebp], cl
	mov	edx, DWORD PTR $T231781[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T231807[ebp], eax
	movzx	ecx, BYTE PTR $T231803[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231807[ebp]
	push	edx
	mov	eax, DWORD PTR $T231844[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$231842[ebp], eax
	mov	ecx, DWORD PTR _iMapY$231842[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$231841[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231781[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN28@GetTradeCo@4
	mov	eax, DWORD PTR $T231781[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231812[ebp], ecx
	mov	edx, DWORD PTR _iMapY$231842[ebp]
	imul	edx, DWORD PTR $T231812[ebp]
	add	edx, DWORD PTR _iMapX$231841[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T231781[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv244[ebp], edx
	jmp	SHORT $LN29@GetTradeCo@4
$LN28@GetTradeCo@4:
	mov	DWORD PTR tv244[ebp], 0
$LN29@GetTradeCo@4:
	mov	ecx, DWORD PTR tv244[ebp]
	mov	DWORD PTR _pOriginPlot$[ebp], ecx
$LN26@GetTradeCo@4:

; 2537 : 	CvPlot* pDestPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231848[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T231938[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T231937[ebp], eax
	cmp	DWORD PTR $T231937[ebp], -2147483647	; 80000001H
	je	SHORT $LN50@GetTradeCo@4
	cmp	DWORD PTR $T231938[ebp], -2147483647	; 80000001H
	jne	SHORT $LN51@GetTradeCo@4
$LN50@GetTradeCo@4:
	mov	DWORD PTR _pDestPlot$[ebp], 0
	jmp	$LN52@GetTradeCo@4
$LN51@GetTradeCo@4:
	mov	ecx, DWORD PTR $T231848[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T231855[ebp], dl
	mov	eax, DWORD PTR $T231848[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231859[ebp], ecx
	movzx	edx, BYTE PTR $T231855[ebp]
	test	edx, edx
	je	SHORT $LN63@GetTradeCo@4
	cmp	DWORD PTR $T231937[ebp], 0
	jge	SHORT $LN62@GetTradeCo@4
	mov	eax, DWORD PTR $T231937[ebp]
	cdq
	idiv	DWORD PTR $T231859[ebp]
	add	edx, DWORD PTR $T231859[ebp]
	mov	DWORD PTR _iMapX$231935[ebp], edx
	jmp	SHORT $LN64@GetTradeCo@4
	jmp	SHORT $LN63@GetTradeCo@4
$LN62@GetTradeCo@4:
	mov	eax, DWORD PTR $T231937[ebp]
	cmp	eax, DWORD PTR $T231859[ebp]
	jl	SHORT $LN63@GetTradeCo@4
	mov	eax, DWORD PTR $T231937[ebp]
	cdq
	idiv	DWORD PTR $T231859[ebp]
	mov	DWORD PTR _iMapX$231935[ebp], edx
	jmp	SHORT $LN64@GetTradeCo@4
$LN63@GetTradeCo@4:
	mov	ecx, DWORD PTR $T231937[ebp]
	mov	DWORD PTR _iMapX$231935[ebp], ecx
$LN64@GetTradeCo@4:
	mov	edx, DWORD PTR $T231848[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T231870[ebp], al
	mov	ecx, DWORD PTR $T231848[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231874[ebp], edx
	movzx	eax, BYTE PTR $T231870[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231874[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231938[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$231936[ebp], eax
	cmp	DWORD PTR _iMapX$231935[ebp], 0
	jl	SHORT $LN72@GetTradeCo@4
	mov	eax, DWORD PTR $T231848[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231881[ebp], ecx
	mov	edx, DWORD PTR _iMapX$231935[ebp]
	cmp	edx, DWORD PTR $T231881[ebp]
	jge	SHORT $LN72@GetTradeCo@4
	cmp	DWORD PTR _iMapY$231936[ebp], 0
	jl	SHORT $LN72@GetTradeCo@4
	mov	eax, DWORD PTR $T231848[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T231885[ebp], ecx
	mov	edx, DWORD PTR _iMapY$231936[ebp]
	cmp	edx, DWORD PTR $T231885[ebp]
	jge	SHORT $LN72@GetTradeCo@4
	mov	DWORD PTR tv287[ebp], 1
	jmp	SHORT $LN70@GetTradeCo@4
$LN72@GetTradeCo@4:
	mov	DWORD PTR tv287[ebp], 0
$LN70@GetTradeCo@4:
	cmp	DWORD PTR tv287[ebp], 0
	je	SHORT $LN54@GetTradeCo@4
	mov	eax, DWORD PTR $T231848[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231898[ebp], ecx
	mov	edx, DWORD PTR _iMapY$231936[ebp]
	imul	edx, DWORD PTR $T231898[ebp]
	add	edx, DWORD PTR _iMapX$231935[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T231848[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv275[ebp], edx
	jmp	SHORT $LN55@GetTradeCo@4
$LN54@GetTradeCo@4:
	mov	DWORD PTR tv275[ebp], 0
$LN55@GetTradeCo@4:
	mov	ecx, DWORD PTR tv275[ebp]
	mov	DWORD PTR _pDestPlot$[ebp], ecx
$LN52@GetTradeCo@4:

; 2538 : 
; 2539 : 	CvAssertMsg(pOriginPlot && pDestPlot, "pOriginPlot or pDestPlot are null");
; 2540 : 	if (!pOriginPlot || !pDestPlot)

	cmp	DWORD PTR _pOriginPlot$[ebp], 0
	je	SHORT $LN14@GetTradeCo@4
	cmp	DWORD PTR _pDestPlot$[ebp], 0
	jne	SHORT $LN15@GetTradeCo@4
$LN14@GetTradeCo@4:

; 2541 : 	{
; 2542 : 		return 0;

	xor	eax, eax
	jmp	$LN18@GetTradeCo@4
$LN15@GetTradeCo@4:

; 2543 : 	}
; 2544 : 
; 2545 : 	CvCity* pDestCity = pDestPlot->getPlotCity();

	mov	ecx, DWORD PTR _pDestPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pDestCity$[ebp], eax

; 2546 : 	if (!pDestCity)

	cmp	DWORD PTR _pDestCity$[ebp], 0
	jne	SHORT $LN13@GetTradeCo@4

; 2547 : 	{
; 2548 : 		return 0;

	xor	eax, eax
	jmp	$LN18@GetTradeCo@4
$LN13@GetTradeCo@4:

; 2549 : 	}
; 2550 : 
; 2551 : 	int iBonus = 0;

	mov	DWORD PTR _iBonus$[ebp], 0

; 2552 : 	if (bAsOriginPlayer)

	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	test	edx, edx
	je	$LN12@GetTradeCo@4

; 2553 : 	{
; 2554 : 		CvCity* pOriginCity = CvGameTrade::GetOriginCity(kTradeConnection);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	call	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
	add	esp, 4
	mov	DWORD PTR _pOriginCity$220242[ebp], eax

; 2555 : #ifdef AUI_WARNING_FIXES
; 2556 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 2557 : #else
; 2558 : 		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220243[ebp], 0
	jmp	SHORT $LN11@GetTradeCo@4
$LN10@GetTradeCo@4:
	mov	ecx, DWORD PTR _iI$220243[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$220243[ebp], ecx
$LN11@GetTradeCo@4:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220243[ebp], eax
	jge	$LN12@GetTradeCo@4

; 2559 : #endif
; 2560 : 		{
; 2561 : 			BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	edx, DWORD PTR _pOriginCity$220242[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T231952[ebp], eax
	mov	ecx, DWORD PTR $T231952[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231956[ebp], ecx
	mov	edx, DWORD PTR _iI$220243[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231956[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220247[ebp], eax

; 2562 : 			if(eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$220247[ebp], -1
	je	$LN8@GetTradeCo@4

; 2563 : 			{
; 2564 : 				CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	mov	eax, DWORD PTR _eBuilding$220247[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pBuildingEntry$220250[ebp], eax

; 2565 : 				if (!pBuildingEntry)

	cmp	DWORD PTR _pBuildingEntry$220250[ebp], 0
	jne	SHORT $LN7@GetTradeCo@4

; 2566 : 				{
; 2567 : 					continue;

	jmp	$LN10@GetTradeCo@4
$LN7@GetTradeCo@4:

; 2568 : 				}
; 2569 : 
; 2570 : 				if (pBuildingEntry && pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()))

	cmp	DWORD PTR _pBuildingEntry$220250[ebp], 0
	je	SHORT $LN8@GetTradeCo@4
	mov	ecx, DWORD PTR _pBuildingEntry$220250[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231960[ebp], edx
	mov	eax, DWORD PTR $T231960[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOriginCity$220242[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	je	SHORT $LN8@GetTradeCo@4

; 2571 : 				{
; 2572 : 					if (pBuildingEntry->GetTradeRouteSeaGoldBonus() > 0 && kTradeConnection.m_eDomain == DOMAIN_SEA)

	mov	ecx, DWORD PTR _pBuildingEntry$220250[ebp]
	call	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
	test	eax, eax
	jle	SHORT $LN5@GetTradeCo@4
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN5@GetTradeCo@4

; 2573 : 					{
; 2574 : 						iBonus += pBuildingEntry->GetTradeRouteSeaGoldBonus();

	mov	ecx, DWORD PTR _pBuildingEntry$220250[ebp]
	call	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
	add	eax, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], eax
	jmp	SHORT $LN8@GetTradeCo@4
$LN5@GetTradeCo@4:

; 2575 : 					}
; 2576 : 					else if (pBuildingEntry->GetTradeRouteLandGoldBonus() > 0 && kTradeConnection.m_eDomain == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pBuildingEntry$220250[ebp]
	call	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandGoldBonus
	test	eax, eax
	jle	SHORT $LN8@GetTradeCo@4
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [edx+28], 2
	jne	SHORT $LN8@GetTradeCo@4

; 2577 : 					{
; 2578 : 						iBonus += pBuildingEntry->GetTradeRouteLandGoldBonus();

	mov	ecx, DWORD PTR _pBuildingEntry$220250[ebp]
	call	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandGoldBonus
	add	eax, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], eax
$LN8@GetTradeCo@4:

; 2579 : 					}
; 2580 : 				}
; 2581 : 			}
; 2582 : 		}

	jmp	$LN10@GetTradeCo@4
$LN12@GetTradeCo@4:

; 2583 : 	}
; 2584 : 
; 2585 : 	if (bAsOriginPlayer)

	movzx	eax, BYTE PTR _bAsOriginPlayer$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetTradeCo@4

; 2586 : 	{
; 2587 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231964[ebp], edx
	mov	ecx, DWORD PTR $T231964[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T231968[ebp], eax
	mov	eax, DWORD PTR $T231968[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR $T231969[ebp], ecx
	mov	edx, DWORD PTR $T231969[ebp]
	add	edx, 100				; 00000064H
	imul	edx, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], edx

; 2588 : 		iBonus /= 100;

	mov	eax, DWORD PTR _iBonus$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iBonus$[ebp], eax

; 2589 : 	}
; 2590 : 	else

	jmp	SHORT $LN1@GetTradeCo@4
$LN2@GetTradeCo@4:

; 2591 : 	{
; 2592 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231973[ebp], eax
	mov	ecx, DWORD PTR $T231973[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T231977[ebp], eax
	mov	ecx, DWORD PTR $T231977[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR $T231978[ebp], edx
	mov	eax, DWORD PTR $T231978[ebp]
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], eax

; 2593 : 		iBonus /= 100;

	mov	eax, DWORD PTR _iBonus$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iBonus$[ebp], eax
$LN1@GetTradeCo@4:

; 2594 : 	}	
; 2595 : 
; 2596 : 	return iBonus;

	mov	eax, DWORD PTR _iBonus$[ebp]
$LN18@GetTradeCo@4:

; 2597 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100
EXTRN	?GetTradeRouteRecipientBonus@CvCity@@QBEHXZ:PROC ; CvCity::GetTradeRouteRecipientBonus
EXTRN	?GetTradeRouteTargetBonus@CvCity@@QBEHXZ:PROC	; CvCity::GetTradeRouteTargetBonus
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
tv258 = -156						; size = 4
tv227 = -152						; size = 4
_this$ = -148						; size = 4
$T232167 = -144						; size = 4
$T232166 = -140						; size = 4
$T232162 = -136						; size = 4
$T232158 = -132						; size = 4
$T232157 = -128						; size = 4
$T232153 = -124						; size = 4
$T232149 = -120						; size = 4
$T232140 = -116						; size = 4
$T232131 = -112						; size = 4
$T232127 = -108						; size = 4
$T232118 = -100						; size = 4
$T232117 = -96						; size = 4
$T232086 = -92						; size = 4
$T232081 = -88						; size = 4
$T232077 = -81						; size = 1
$T232066 = -80						; size = 4
$T232062 = -73						; size = 1
_iMapY$232116 = -72					; size = 4
_iMapX$232115 = -68					; size = 4
$T232055 = -64						; size = 4
$T232051 = -60						; size = 4
$T232050 = -56						; size = 4
$T232019 = -52						; size = 4
$T232014 = -48						; size = 4
$T232010 = -41						; size = 1
$T231999 = -40						; size = 4
$T231995 = -33						; size = 1
_iMapY$232049 = -32					; size = 4
_iMapX$232048 = -28					; size = 4
$T231988 = -24						; size = 4
$T231984 = -20						; size = 4
_pOriginPlot$ = -16					; size = 4
_iBonus$ = -12						; size = 4
_pDestPlot$ = -8					; size = 4
_pDestCity$ = -4					; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100, COMDAT
; _this$ = ecx

; 2605 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 2606 : 	// this only applies to international trade routes, so otherwise, buzz off!
; 2607 : 	if (!GC.getGame().GetGameTrade()->IsConnectionInternational(kTradeConnection))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231984[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231984[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@GetTradeCo@5

; 2608 : 	{
; 2609 : 		return 0;

	xor	eax, eax
	jmp	$LN11@GetTradeCo@5
$LN10@GetTradeCo@5:

; 2610 : 	}
; 2611 : 
; 2612 : 	if (eYield != YIELD_GOLD)

	cmp	DWORD PTR _eYield$[ebp], 2
	je	SHORT $LN9@GetTradeCo@5

; 2613 : 	{
; 2614 : 		return 0;

	xor	eax, eax
	jmp	$LN11@GetTradeCo@5
$LN9@GetTradeCo@5:

; 2615 : 	}
; 2616 : 
; 2617 : 	CvPlot* pOriginPlot = GC.getMap().plot(kTradeConnection.m_iOriginX, kTradeConnection.m_iOriginY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231988[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T232051[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232050[ebp], ecx
	cmp	DWORD PTR $T232050[ebp], -2147483647	; 80000001H
	je	SHORT $LN17@GetTradeCo@5
	cmp	DWORD PTR $T232051[ebp], -2147483647	; 80000001H
	jne	SHORT $LN18@GetTradeCo@5
$LN17@GetTradeCo@5:
	mov	DWORD PTR _pOriginPlot$[ebp], 0
	jmp	$LN19@GetTradeCo@5
$LN18@GetTradeCo@5:
	mov	edx, DWORD PTR $T231988[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T231995[ebp], al
	mov	ecx, DWORD PTR $T231988[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231999[ebp], edx
	movzx	eax, BYTE PTR $T231995[ebp]
	test	eax, eax
	je	SHORT $LN30@GetTradeCo@5
	cmp	DWORD PTR $T232050[ebp], 0
	jge	SHORT $LN29@GetTradeCo@5
	mov	eax, DWORD PTR $T232050[ebp]
	cdq
	idiv	DWORD PTR $T231999[ebp]
	add	edx, DWORD PTR $T231999[ebp]
	mov	DWORD PTR _iMapX$232048[ebp], edx
	jmp	SHORT $LN31@GetTradeCo@5
	jmp	SHORT $LN30@GetTradeCo@5
$LN29@GetTradeCo@5:
	mov	ecx, DWORD PTR $T232050[ebp]
	cmp	ecx, DWORD PTR $T231999[ebp]
	jl	SHORT $LN30@GetTradeCo@5
	mov	eax, DWORD PTR $T232050[ebp]
	cdq
	idiv	DWORD PTR $T231999[ebp]
	mov	DWORD PTR _iMapX$232048[ebp], edx
	jmp	SHORT $LN31@GetTradeCo@5
$LN30@GetTradeCo@5:
	mov	edx, DWORD PTR $T232050[ebp]
	mov	DWORD PTR _iMapX$232048[ebp], edx
$LN31@GetTradeCo@5:
	mov	eax, DWORD PTR $T231988[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T232010[ebp], cl
	mov	edx, DWORD PTR $T231988[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T232014[ebp], eax
	movzx	ecx, BYTE PTR $T232010[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232014[ebp]
	push	edx
	mov	eax, DWORD PTR $T232051[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$232049[ebp], eax
	mov	ecx, DWORD PTR _iMapY$232049[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$232048[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231988[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN21@GetTradeCo@5
	mov	eax, DWORD PTR $T231988[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232019[ebp], ecx
	mov	edx, DWORD PTR _iMapY$232049[ebp]
	imul	edx, DWORD PTR $T232019[ebp]
	add	edx, DWORD PTR _iMapX$232048[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T231988[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv227[ebp], edx
	jmp	SHORT $LN22@GetTradeCo@5
$LN21@GetTradeCo@5:
	mov	DWORD PTR tv227[ebp], 0
$LN22@GetTradeCo@5:
	mov	ecx, DWORD PTR tv227[ebp]
	mov	DWORD PTR _pOriginPlot$[ebp], ecx
$LN19@GetTradeCo@5:

; 2618 : 	CvPlot* pDestPlot = GC.getMap().plot(kTradeConnection.m_iDestX, kTradeConnection.m_iDestY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T232055[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T232118[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T232117[ebp], eax
	cmp	DWORD PTR $T232117[ebp], -2147483647	; 80000001H
	je	SHORT $LN43@GetTradeCo@5
	cmp	DWORD PTR $T232118[ebp], -2147483647	; 80000001H
	jne	SHORT $LN44@GetTradeCo@5
$LN43@GetTradeCo@5:
	mov	DWORD PTR _pDestPlot$[ebp], 0
	jmp	$LN45@GetTradeCo@5
$LN44@GetTradeCo@5:
	mov	ecx, DWORD PTR $T232055[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T232062[ebp], dl
	mov	eax, DWORD PTR $T232055[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232066[ebp], ecx
	movzx	edx, BYTE PTR $T232062[ebp]
	test	edx, edx
	je	SHORT $LN56@GetTradeCo@5
	cmp	DWORD PTR $T232117[ebp], 0
	jge	SHORT $LN55@GetTradeCo@5
	mov	eax, DWORD PTR $T232117[ebp]
	cdq
	idiv	DWORD PTR $T232066[ebp]
	add	edx, DWORD PTR $T232066[ebp]
	mov	DWORD PTR _iMapX$232115[ebp], edx
	jmp	SHORT $LN57@GetTradeCo@5
	jmp	SHORT $LN56@GetTradeCo@5
$LN55@GetTradeCo@5:
	mov	eax, DWORD PTR $T232117[ebp]
	cmp	eax, DWORD PTR $T232066[ebp]
	jl	SHORT $LN56@GetTradeCo@5
	mov	eax, DWORD PTR $T232117[ebp]
	cdq
	idiv	DWORD PTR $T232066[ebp]
	mov	DWORD PTR _iMapX$232115[ebp], edx
	jmp	SHORT $LN57@GetTradeCo@5
$LN56@GetTradeCo@5:
	mov	ecx, DWORD PTR $T232117[ebp]
	mov	DWORD PTR _iMapX$232115[ebp], ecx
$LN57@GetTradeCo@5:
	mov	edx, DWORD PTR $T232055[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T232077[ebp], al
	mov	ecx, DWORD PTR $T232055[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T232081[ebp], edx
	movzx	eax, BYTE PTR $T232077[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232081[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232118[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$232116[ebp], eax
	mov	eax, DWORD PTR _iMapY$232116[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$232115[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232055[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN47@GetTradeCo@5
	mov	edx, DWORD PTR $T232055[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T232086[ebp], eax
	mov	ecx, DWORD PTR _iMapY$232116[ebp]
	imul	ecx, DWORD PTR $T232086[ebp]
	add	ecx, DWORD PTR _iMapX$232115[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T232055[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv258[ebp], ecx
	jmp	SHORT $LN48@GetTradeCo@5
$LN47@GetTradeCo@5:
	mov	DWORD PTR tv258[ebp], 0
$LN48@GetTradeCo@5:
	mov	eax, DWORD PTR tv258[ebp]
	mov	DWORD PTR _pDestPlot$[ebp], eax
$LN45@GetTradeCo@5:

; 2619 : 
; 2620 : 	CvAssertMsg(pOriginPlot && pDestPlot, "pOriginPlot or pDestPlot are null");
; 2621 : 	if (!pOriginPlot || !pDestPlot)

	cmp	DWORD PTR _pOriginPlot$[ebp], 0
	je	SHORT $LN7@GetTradeCo@5
	cmp	DWORD PTR _pDestPlot$[ebp], 0
	jne	SHORT $LN8@GetTradeCo@5
$LN7@GetTradeCo@5:

; 2622 : 	{
; 2623 : 		return 0;

	xor	eax, eax
	jmp	$LN11@GetTradeCo@5
$LN8@GetTradeCo@5:

; 2624 : 	}
; 2625 : 
; 2626 : 	CvCity* pDestCity = pDestPlot->getPlotCity();

	mov	ecx, DWORD PTR _pDestPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pDestCity$[ebp], eax

; 2627 : 	if (!pDestCity)

	cmp	DWORD PTR _pDestCity$[ebp], 0
	jne	SHORT $LN6@GetTradeCo@5

; 2628 : 	{
; 2629 : 		return 0;

	xor	eax, eax
	jmp	$LN11@GetTradeCo@5
$LN6@GetTradeCo@5:

; 2630 : 	}
; 2631 : 
; 2632 : 	int iBonus = 0;

	mov	DWORD PTR _iBonus$[ebp], 0

; 2633 : 
; 2634 : 	// minor civs should not get bonuses for others trading with them
; 2635 : 	if (!GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv() && !GET_PLAYER(kTradeConnection.m_eOriginOwner).isMinorCiv())

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232127[ebp], edx
	mov	ecx, DWORD PTR $T232127[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	$LN5@GetTradeCo@5
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232131[ebp], edx
	mov	ecx, DWORD PTR $T232131[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@GetTradeCo@5

; 2636 : 	{
; 2637 : 		if (kTradeConnection.m_eOriginOwner == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T232140[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR $T232140[ebp]
	jne	SHORT $LN82@GetTradeCo@5

; 2638 : 		{
; 2639 : 			iBonus += pDestCity->GetTradeRouteTargetBonus() * 100;

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?GetTradeRouteTargetBonus@CvCity@@QBEHXZ ; CvCity::GetTradeRouteTargetBonus
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], eax

; 2640 : 		}
; 2641 : 
; 2642 : 		if (kTradeConnection.m_eDestOwner == m_pPlayer->GetID())

$LN82@GetTradeCo@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232149[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR $T232149[ebp]
	jne	SHORT $LN5@GetTradeCo@5

; 2643 : 		{
; 2644 : 			iBonus += pDestCity->GetTradeRouteRecipientBonus() * 100;

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?GetTradeRouteRecipientBonus@CvCity@@QBEHXZ ; CvCity::GetTradeRouteRecipientBonus
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], eax
$LN5@GetTradeCo@5:

; 2645 : 		}
; 2646 : 	}
; 2647 : 
; 2648 : 	if (bAsOriginPlayer)

	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	test	edx, edx
	je	SHORT $LN2@GetTradeCo@5

; 2649 : 	{
; 2650 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232153[ebp], ecx
	mov	ecx, DWORD PTR $T232153[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T232157[ebp], eax
	mov	edx, DWORD PTR $T232157[ebp]
	mov	eax, DWORD PTR [edx+328]
	mov	DWORD PTR $T232158[ebp], eax
	mov	ecx, DWORD PTR $T232158[ebp]
	add	ecx, 100				; 00000064H
	imul	ecx, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], ecx

; 2651 : 		iBonus /= 100;

	mov	eax, DWORD PTR _iBonus$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iBonus$[ebp], eax

; 2652 : 	}
; 2653 : 	else

	jmp	SHORT $LN1@GetTradeCo@5
$LN2@GetTradeCo@5:

; 2654 : 	{
; 2655 : 		iBonus *= (100 + GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerTraits()->GetTradeBuildingModifier());

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232162[ebp], eax
	mov	ecx, DWORD PTR $T232162[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T232166[ebp], eax
	mov	ecx, DWORD PTR $T232166[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR $T232167[ebp], edx
	mov	eax, DWORD PTR $T232167[ebp]
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], eax

; 2656 : 		iBonus /= 100;

	mov	eax, DWORD PTR _iBonus$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iBonus$[ebp], eax
$LN1@GetTradeCo@5:

; 2657 : 	}	
; 2658 : 
; 2659 : 	return iBonus;

	mov	eax, DWORD PTR _iBonus$[ebp]
$LN11@GetTradeCo@5:

; 2660 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T232177 = -12						; size = 4
$T232173 = -8						; size = 4
_pTrade$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100, COMDAT
; _this$ = ecx

; 2668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2669 : 	// unnecessary code to make it compile for now
; 2670 : 	if (eYield != NO_YIELD)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN3@GetTradeCo@6

; 2671 : 	{
; 2672 : 		eYield = eYield;

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR _eYield$[ebp], eax
$LN3@GetTradeCo@6:

; 2673 : 	}
; 2674 : 
; 2675 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232173[ebp], ecx
	mov	ecx, DWORD PTR $T232173[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 2676 : 	if (pTrade->IsDestinationExclusive(kTradeConnection))

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsDestinationExclusive@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsDestinationExclusive
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetTradeCo@6

; 2677 : 	{
; 2678 : 		return GC.getINTERNATIONAL_TRADE_EXCLUSIVE_CONNECTION();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7960
	mov	DWORD PTR $T232177[ebp], ecx
	mov	eax, DWORD PTR $T232177[ebp]
	jmp	SHORT $LN4@GetTradeCo@6

; 2679 : 	}
; 2680 : 	else

	jmp	SHORT $LN4@GetTradeCo@6
$LN2@GetTradeCo@6:

; 2681 : 	{
; 2682 : 		return 0;

	xor	eax, eax
$LN4@GetTradeCo@6:

; 2683 : 	}
; 2684 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z
_TEXT	SEGMENT
tv192 = -80						; size = 4
tv179 = -76						; size = 4
tv166 = -72						; size = 4
_this$ = -68						; size = 4
$T232222 = -64						; size = 4
$T232218 = -60						; size = 4
$T232214 = -56						; size = 4
$T232201 = -52						; size = 4
$T232197 = -48						; size = 4
$T232193 = -44						; size = 4
$T232189 = -40						; size = 4
_pDestPlayerPolicies$220300 = -36			; size = 4
_eAutocracy$220303 = -32				; size = 4
_eOrder$220305 = -28					; size = 4
_bBothOrder$220308 = -21				; size = 1
_pOwnerPlayerPolicies$220299 = -20			; size = 4
_bBothFreedom$220309 = -13				; size = 1
_eFreedom$220301 = -12					; size = 4
_bBothAutocracy$220307 = -5				; size = 1
_iValue$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100, COMDAT
; _this$ = ecx

; 2692 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 2693 : 	// unnecessary code to make it compile for now
; 2694 : 	if (eYield != NO_YIELD)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN11@GetTradeCo@7

; 2695 : 	{
; 2696 : 		eYield = eYield;

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR _eYield$[ebp], eax
$LN11@GetTradeCo@7:

; 2697 : 	}
; 2698 : 
; 2699 : 	int iValue = 0;

	mov	DWORD PTR _iValue$[ebp], 0

; 2700 : 	if (kTradeConnection.m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	jne	$LN10@GetTradeCo@7

; 2701 : 	{
; 2702 : 		// domain type bonuses
; 2703 : 		if (kTradeConnection.m_eDomain == DOMAIN_LAND 
; 2704 : 			&& eYield == YIELD_GOLD) // NQMP GJS - Merchant Confederacy

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [edx+28], 2
	jne	SHORT $LN9@GetTradeCo@7
	cmp	DWORD PTR _eYield$[ebp], 2
	jne	SHORT $LN9@GetTradeCo@7

; 2705 : 		{
; 2706 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_LAND_TRADE_GOLD_CHANGE);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232189[ebp], ecx
	push	32					; 00000020H
	mov	ecx, DWORD PTR $T232189[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2707 : 		}
; 2708 : 		else if (kTradeConnection.m_eDomain == DOMAIN_SEA

	jmp	SHORT $LN8@GetTradeCo@7
$LN9@GetTradeCo@7:

; 2709 : 			&& eYield == YIELD_GOLD) // NQMP GJS - Merchant Confederacy

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN8@GetTradeCo@7
	cmp	DWORD PTR _eYield$[ebp], 2
	jne	SHORT $LN8@GetTradeCo@7

; 2710 : 		{
; 2711 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_SEA_TRADE_GOLD_CHANGE);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232193[ebp], ecx
	push	33					; 00000021H
	mov	ecx, DWORD PTR $T232193[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax
$LN8@GetTradeCo@7:

; 2712 : 		}
; 2713 : 
; 2714 : 		// policy tree bonuses
; 2715 : 		CvPlayerPolicies* pOwnerPlayerPolicies = GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies();

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232197[ebp], eax
	mov	ecx, DWORD PTR $T232197[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	DWORD PTR _pOwnerPlayerPolicies$220299[ebp], eax

; 2716 : 		CvPlayerPolicies* pDestPlayerPolicies = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies();

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232201[ebp], edx
	mov	ecx, DWORD PTR $T232201[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	DWORD PTR _pDestPlayerPolicies$220300[ebp], eax

; 2717 : 
; 2718 : 		PolicyBranchTypes eFreedom = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	mov	DWORD PTR _eFreedom$220301[ebp], eax

; 2719 : 		PolicyBranchTypes eAutocracy = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380
	mov	DWORD PTR _eAutocracy$220303[ebp], ecx

; 2720 : 		PolicyBranchTypes eOrder = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	mov	DWORD PTR _eOrder$220305[ebp], edx

; 2721 : 
; 2722 : 		bool bBothAutocracy = false;

	mov	BYTE PTR _bBothAutocracy$220307[ebp], 0

; 2723 : 		bool bBothOrder = false;

	mov	BYTE PTR _bBothOrder$220308[ebp], 0

; 2724 : 		bool bBothFreedom = false;

	mov	BYTE PTR _bBothFreedom$220309[ebp], 0

; 2725 : 		if (eAutocracy != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eAutocracy$220303[ebp], -1
	je	SHORT $LN6@GetTradeCo@7

; 2726 : 		{
; 2727 : 			bBothAutocracy = pOwnerPlayerPolicies->IsPolicyBranchUnlocked(eAutocracy) && pDestPlayerPolicies->IsPolicyBranchUnlocked(eAutocracy);

	mov	eax, DWORD PTR _eAutocracy$220303[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOwnerPlayerPolicies$220299[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@GetTradeCo@7
	mov	edx, DWORD PTR _eAutocracy$220303[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDestPlayerPolicies$220300[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@GetTradeCo@7
	mov	DWORD PTR tv166[ebp], 1
	jmp	SHORT $LN15@GetTradeCo@7
$LN14@GetTradeCo@7:
	mov	DWORD PTR tv166[ebp], 0
$LN15@GetTradeCo@7:
	mov	cl, BYTE PTR tv166[ebp]
	mov	BYTE PTR _bBothAutocracy$220307[ebp], cl
$LN6@GetTradeCo@7:

; 2728 : 		}
; 2729 : 		if (eOrder != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eOrder$220305[ebp], -1
	je	SHORT $LN5@GetTradeCo@7

; 2730 : 		{
; 2731 : 			bBothOrder = pOwnerPlayerPolicies->IsPolicyBranchUnlocked(eOrder) && pDestPlayerPolicies->IsPolicyBranchUnlocked(eOrder);

	mov	edx, DWORD PTR _eOrder$220305[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOwnerPlayerPolicies$220299[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@GetTradeCo@7
	mov	ecx, DWORD PTR _eOrder$220305[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDestPlayerPolicies$220300[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN16@GetTradeCo@7
	mov	DWORD PTR tv179[ebp], 1
	jmp	SHORT $LN17@GetTradeCo@7
$LN16@GetTradeCo@7:
	mov	DWORD PTR tv179[ebp], 0
$LN17@GetTradeCo@7:
	mov	al, BYTE PTR tv179[ebp]
	mov	BYTE PTR _bBothOrder$220308[ebp], al
$LN5@GetTradeCo@7:

; 2732 : 		}
; 2733 : 		if (eFreedom != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eFreedom$220301[ebp], -1
	je	SHORT $LN4@GetTradeCo@7

; 2734 : 		{
; 2735 : 			bBothFreedom = pOwnerPlayerPolicies->IsPolicyBranchUnlocked(eFreedom) && pDestPlayerPolicies->IsPolicyBranchUnlocked(eFreedom);

	mov	ecx, DWORD PTR _eFreedom$220301[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOwnerPlayerPolicies$220299[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@GetTradeCo@7
	mov	eax, DWORD PTR _eFreedom$220301[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestPlayerPolicies$220300[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@GetTradeCo@7
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN19@GetTradeCo@7
$LN18@GetTradeCo@7:
	mov	DWORD PTR tv192[ebp], 0
$LN19@GetTradeCo@7:
	mov	dl, BYTE PTR tv192[ebp]
	mov	BYTE PTR _bBothFreedom$220309[ebp], dl
$LN4@GetTradeCo@7:

; 2736 : 		}
; 2737 : 	
; 2738 : 		if ((bBothAutocracy || bBothOrder || bBothFreedom)
; 2739 : 			&& eYield == YIELD_GOLD) // NQMP GJS - Merchant Confederacy

	movzx	eax, BYTE PTR _bBothAutocracy$220307[ebp]
	test	eax, eax
	jne	SHORT $LN2@GetTradeCo@7
	movzx	ecx, BYTE PTR _bBothOrder$220308[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@GetTradeCo@7
	movzx	edx, BYTE PTR _bBothFreedom$220309[ebp]
	test	edx, edx
	je	SHORT $LN3@GetTradeCo@7
$LN2@GetTradeCo@7:
	cmp	DWORD PTR _eYield$[ebp], 2
	jne	SHORT $LN3@GetTradeCo@7

; 2740 : 		{
; 2741 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_SHARED_IDEOLOGY_TRADE_CHANGE) * 100;

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232214[ebp], ecx
	push	34					; 00000022H
	mov	ecx, DWORD PTR $T232214[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax
$LN3@GetTradeCo@7:

; 2742 : 		}
; 2743 : 
; 2744 : 		// city state bonus
; 2745 : 		if (GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv())

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232218[ebp], eax
	mov	ecx, DWORD PTR $T232218[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@GetTradeCo@7

; 2746 : 		{
; 2747 : 			iValue += GET_PLAYER(kTradeConnection.m_eOriginOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_CITY_STATE_TRADE_CHANGE);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232222[ebp], eax
	push	42					; 0000002aH
	mov	ecx, DWORD PTR $T232222[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax
$LN10@GetTradeCo@7:

; 2748 : 		}
; 2749 : 	}
; 2750 : 
; 2751 : 	return iValue;

	mov	eax, DWORD PTR _iValue$[ebp]

; 2752 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T232233 = -16						; size = 4
$T232232 = -12						; size = 4
$T232228 = -8						; size = 4
_iValue$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100, COMDAT
; _this$ = ecx

; 2760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2761 : 	int iValue = 0;

	mov	DWORD PTR _iValue$[ebp], 0

; 2762 : 	if (kTradeConnection.m_eConnectionType == TRADE_CONNECTION_INTERNATIONAL)

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $LN2@GetTradeCo@8

; 2763 : 	{
; 2764 : 		if (bAsOriginPlayer)

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetTradeCo@8

; 2765 : 		{
; 2766 : 			iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerTraits()->GetYieldChangeIncomingTradeRoute(eYield) * 100;

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232228[ebp], eax
	mov	ecx, DWORD PTR $T232228[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T232232[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR $T232232[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+528]
	mov	DWORD PTR $T232233[ebp], eax
	mov	ecx, DWORD PTR $T232233[ebp]
	imul	ecx, 100				; 00000064H
	add	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx
$LN2@GetTradeCo@8:

; 2767 : 		}
; 2768 : 	}
; 2769 : 
; 2770 : 	return iValue;

	mov	eax, DWORD PTR _iValue$[ebp]

; 2771 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T232239 = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100, COMDAT
; _this$ = ecx

; 2779 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2780 : 	// unnecessary code to make it compile for now
; 2781 : 	if (eYield != NO_YIELD)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN1@GetTradeCo@9

; 2782 : 	{
; 2783 : 		eYield = eYield;

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR _eYield$[ebp], eax
$LN1@GetTradeCo@9:

; 2784 : 	}
; 2785 : 
; 2786 : 	return GC.getGame().GetGameTrade()->GetDomainModifierTimes100(kTradeConnection.m_eDomain);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232239[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR $T232239[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetDomainModifierTimes100@CvGameTrade@@QAEHW4DomainTypes@@@Z ; CvGameTrade::GetDomainModifierTimes100

; 2787 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_pDestCityPlot$220348 = -20				; size = 4
_pDestCity$220346 = -16					; size = 4
_pOriginCityPlot$220343 = -12				; size = 4
_pOriginCity$220341 = -8				; size = 4
_iModifier$ = -4					; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100, COMDAT
; _this$ = ecx

; 2795 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2796 : 	// unnecessary code to make it compile for now
; 2797 : 	if (eYield != NO_YIELD)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN8@GetTradeCo@10

; 2798 : 	{
; 2799 : 		eYield = eYield;

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR _eYield$[ebp], eax
$LN8@GetTradeCo@10:

; 2800 : 	}
; 2801 : 
; 2802 : 	int iModifier = 0;

	mov	DWORD PTR _iModifier$[ebp], 0

; 2803 : 	if (eYield == YIELD_GOLD && kTradeConnection.m_eDomain == DOMAIN_LAND)

	cmp	DWORD PTR _eYield$[ebp], 2
	jne	$LN7@GetTradeCo@10
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [ecx+28], 2
	jne	$LN7@GetTradeCo@10

; 2804 : 	{
; 2805 : 		if (bAsOriginPlayer)

	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	test	edx, edx
	je	SHORT $LN6@GetTradeCo@10

; 2806 : 		{
; 2807 : 			CvCity* pOriginCity = CvGameTrade::GetOriginCity(kTradeConnection);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	call	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
	add	esp, 4
	mov	DWORD PTR _pOriginCity$220341[ebp], eax

; 2808 : 			CvAssert(pOriginCity != NULL);
; 2809 : 			if (pOriginCity)

	cmp	DWORD PTR _pOriginCity$220341[ebp], 0
	je	SHORT $LN5@GetTradeCo@10

; 2810 : 			{
; 2811 : 				CvPlot* pOriginCityPlot = pOriginCity->plot();

	mov	ecx, DWORD PTR _pOriginCity$220341[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pOriginCityPlot$220343[ebp], eax

; 2812 : 				if (pOriginCityPlot->isRiver())

	mov	ecx, DWORD PTR _pOriginCityPlot$220343[ebp]
	movsx	edx, BYTE PTR [ecx+457]
	xor	eax, eax
	test	edx, edx
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@GetTradeCo@10

; 2813 : 				{
; 2814 : 					iModifier = 25;

	mov	DWORD PTR _iModifier$[ebp], 25		; 00000019H
$LN5@GetTradeCo@10:

; 2815 : 				}
; 2816 : 			}
; 2817 : 		}
; 2818 : 		else

	jmp	SHORT $LN7@GetTradeCo@10
$LN6@GetTradeCo@10:

; 2819 : 		{
; 2820 : 			CvCity* pDestCity = CvGameTrade::GetDestCity(kTradeConnection);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	call	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity
	add	esp, 4
	mov	DWORD PTR _pDestCity$220346[ebp], eax

; 2821 : 			CvAssert(pDestCity != NULL);
; 2822 : 			if (pDestCity)

	cmp	DWORD PTR _pDestCity$220346[ebp], 0
	je	SHORT $LN7@GetTradeCo@10

; 2823 : 			{
; 2824 : 				CvPlot* pDestCityPlot = pDestCity->plot();

	mov	ecx, DWORD PTR _pDestCity$220346[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pDestCityPlot$220348[ebp], eax

; 2825 : 				if (pDestCityPlot->isRiver())

	mov	eax, DWORD PTR _pDestCityPlot$220348[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN7@GetTradeCo@10

; 2826 : 				{
; 2827 : 					iModifier = 25;

	mov	DWORD PTR _iModifier$[ebp], 25		; 00000019H
$LN7@GetTradeCo@10:

; 2828 : 				}
; 2829 : 			}
; 2830 : 		}
; 2831 : 	}
; 2832 : 
; 2833 : 	return iModifier;

	mov	eax, DWORD PTR _iModifier$[ebp]

; 2834 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100
_TEXT	ENDS
PUBLIC	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
EXTRN	?getTrainPercent@CvEraInfo@@QBEHXZ:PROC		; CvEraInfo::getTrainPercent
EXTRN	?getConstructPercent@CvEraInfo@@QBEHXZ:PROC	; CvEraInfo::getConstructPercent
EXTRN	?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getTradeRouteProductionBonusTimes100
EXTRN	?getGrowthPercent@CvEraInfo@@QBEHXZ:PROC	; CvEraInfo::getGrowthPercent
EXTRN	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getStartEra
EXTRN	?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ:PROC ; CvEraInfo::getTradeRouteFoodBonusTimes100
EXTRN	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z:PROC ; CvGlobals::getEraInfo
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
tv254 = -188						; size = 4
tv194 = -184						; size = 4
tv422 = -180						; size = 4
tv75 = -176						; size = 4
_this$ = -172						; size = 4
$T232312 = -168						; size = 4
$T232308 = -164						; size = 4
$T232304 = -160						; size = 4
$T232300 = -156						; size = 4
$T232296 = -152						; size = 4
$T232292 = -148						; size = 4
$T232288 = -144						; size = 4
$T232284 = -140						; size = 4
$T232280 = -136						; size = 4
$T232276 = -132						; size = 4
$T232272 = -128						; size = 4
$T232261 = -124						; size = 4
$T232254 = -120						; size = 4
$T232250 = -116						; size = 4
_iDomainModifier$220413 = -112				; size = 4
_iModifier$220412 = -108				; size = 4
_iDomainModifier$220408 = -104				; size = 4
_iModifier$220407 = -100				; size = 4
_iBaseValue$220397 = -96				; size = 4
_iModifier$220398 = -92					; size = 4
_iDestRiverModifier$220394 = -88			; size = 4
_iDomainModifier$220393 = -84				; size = 4
_iTheirBuildingBonus$220391 = -80			; size = 4
_iBaseValue$220389 = -76				; size = 4
_iYourBuildingBonus$220390 = -72			; size = 4
_iModifier$220392 = -68					; size = 4
_iTraitBonus$220395 = -64				; size = 4
_iOriginRiverModifier$220376 = -60			; size = 4
_iDestPerTurnBonus$220368 = -56				; size = 4
_iExclusiveBonus$220370 = -52				; size = 4
_iDomainModifier$220375 = -48				; size = 4
_iTheirBuildingBonus$220372 = -44			; size = 4
_iBaseValue$220366 = -40				; size = 4
_iOriginPerTurnBonus$220367 = -36			; size = 4
_iResourceBonus$220369 = -32				; size = 4
_iYourBuildingBonus$220371 = -28			; size = 4
_iModifier$220374 = -24					; size = 4
_iTraitBonus$220373 = -20				; size = 4
_iBaseValue$220379 = -16				; size = 4
_iModifier$220380 = -12					; size = 4
_pTrade$ = -8						; size = 4
_iValue$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
_eYield$ = 12						; size = 4
_bAsOriginPlayer$ = 16					; size = 1
?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z PROC ; CvPlayerTrade::GetTradeConnectionValueTimes100, COMDAT
; _this$ = ecx

; 2842 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2843 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232254[ebp], eax
	mov	ecx, DWORD PTR $T232254[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 2844 : 	int iValue = 0;

	mov	DWORD PTR _iValue$[ebp], 0

; 2845 : 
; 2846 : 	if (bAsOriginPlayer)

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	test	ecx, ecx
	je	$LN23@GetTradeCo@11

; 2847 : 	{
; 2848 : 		if (pTrade->IsConnectionInternational(kTradeConnection))

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	movzx	eax, al
	test	eax, eax
	je	$LN22@GetTradeCo@11

; 2849 : 		{
; 2850 : 			
; 2851 : 			switch (eYield)

	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 3
	ja	$LN22@GetTradeCo@11
	mov	edx, DWORD PTR tv75[ebp]
	jmp	DWORD PTR $LN56@GetTradeCo@11[edx*4]
$LN19@GetTradeCo@11:

; 2852 : 			{
; 2853 : 			// NQMP GJS - New Merchant Confederacy begin
; 2854 : 			case YIELD_PRODUCTION:
; 2855 : 			case YIELD_FOOD:
; 2856 : 			//case YIELD_CULTURE: // this doesn't work yet with JONSCulture stuff, figure it out later
; 2857 : 				iValue = GetTradeConnectionPolicyValueTimes100(kTradeConnection, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionPolicyValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionPolicyValueTimes100
	mov	DWORD PTR _iValue$[ebp], eax

; 2858 : 				break;

	jmp	$LN22@GetTradeCo@11
$LN18@GetTradeCo@11:

; 2859 : 			// NQMP GJS - New Merchant Confederacy end
; 2860 : 			case YIELD_GOLD:
; 2861 : 				{
; 2862 : 					int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
	mov	DWORD PTR _iBaseValue$220366[ebp], eax

; 2863 : 					int iOriginPerTurnBonus = GetTradeConnectionGPTValueTimes100(kTradeConnection, eYield, bAsOriginPlayer, true);

	push	1
	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100
	mov	DWORD PTR _iOriginPerTurnBonus$220367[ebp], eax

; 2864 : 					int iDestPerTurnBonus = GetTradeConnectionGPTValueTimes100(kTradeConnection, eYield, bAsOriginPlayer, false);

	push	0
	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionGPTValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N2@Z ; CvPlayerTrade::GetTradeConnectionGPTValueTimes100
	mov	DWORD PTR _iDestPerTurnBonus$220368[ebp], eax

; 2865 : 					int iResourceBonus = GetTradeConnectionResourceValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionResourceValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionResourceValueTimes100
	mov	DWORD PTR _iResourceBonus$220369[ebp], eax

; 2866 : 					int iExclusiveBonus = GetTradeConnectionExclusiveValueTimes100(kTradeConnection, eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionExclusiveValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionExclusiveValueTimes100
	mov	DWORD PTR _iExclusiveBonus$220370[ebp], eax

; 2867 : 					//int iPolicyBonus = GetTradeConnectionPolicyValueTimes100(kTradeConnection, eYield); -- Sike, nerfing this ~EAP
; 2868 : 					int iYourBuildingBonus = GetTradeConnectionYourBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100
	mov	DWORD PTR _iYourBuildingBonus$220371[ebp], eax

; 2869 : 					int iTheirBuildingBonus = GetTradeConnectionTheirBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100
	mov	DWORD PTR _iTheirBuildingBonus$220372[ebp], eax

; 2870 : 					int iTraitBonus = GetTradeConnectionOtherTraitValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100
	mov	DWORD PTR _iTraitBonus$220373[ebp], eax

; 2871 : 
; 2872 : 					int iModifier = 100;

	mov	DWORD PTR _iModifier$220374[ebp], 100	; 00000064H

; 2873 : 					int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
	mov	DWORD PTR _iDomainModifier$220375[ebp], eax

; 2874 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2875 : 					iValue *= iDomainModifier + 100;
; 2876 : 					iValue /= 100;
; 2877 : #endif
; 2878 : 					int iOriginRiverModifier = GetTradeConnectionRiverValueModifierTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	eax, BYTE PTR _bAsOriginPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100
	mov	DWORD PTR _iOriginRiverModifier$220376[ebp], eax

; 2879 : 
; 2880 : 					iValue = iBaseValue;

	mov	eax, DWORD PTR _iBaseValue$220366[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2881 : 					iValue += iOriginPerTurnBonus;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, DWORD PTR _iOriginPerTurnBonus$220367[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2882 : 					iValue += iDestPerTurnBonus;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, DWORD PTR _iDestPerTurnBonus$220368[ebp]
	mov	DWORD PTR _iValue$[ebp], edx

; 2883 : 					iValue += iExclusiveBonus;

	mov	eax, DWORD PTR _iValue$[ebp]
	add	eax, DWORD PTR _iExclusiveBonus$220370[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2884 : 					iValue += iYourBuildingBonus;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, DWORD PTR _iYourBuildingBonus$220371[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2885 : 					iValue += iTheirBuildingBonus;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, DWORD PTR _iTheirBuildingBonus$220372[ebp]
	mov	DWORD PTR _iValue$[ebp], edx

; 2886 : 					iValue += iResourceBonus;

	mov	eax, DWORD PTR _iValue$[ebp]
	add	eax, DWORD PTR _iResourceBonus$220369[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2887 : 					//iValue += iPolicyBonus;
; 2888 : 					iValue += iTraitBonus;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, DWORD PTR _iTraitBonus$220373[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2889 : 
; 2890 : #ifndef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2891 : 					iModifier += iDomainModifier;

	mov	edx, DWORD PTR _iModifier$220374[ebp]
	add	edx, DWORD PTR _iDomainModifier$220375[ebp]
	mov	DWORD PTR _iModifier$220374[ebp], edx

; 2892 : #endif
; 2893 : 					iModifier += iOriginRiverModifier;

	mov	eax, DWORD PTR _iModifier$220374[ebp]
	add	eax, DWORD PTR _iOriginRiverModifier$220376[ebp]
	mov	DWORD PTR _iModifier$220374[ebp], eax

; 2894 : 
; 2895 : 					iValue *= iModifier;

	mov	ecx, DWORD PTR _iValue$[ebp]
	imul	ecx, DWORD PTR _iModifier$220374[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2896 : 					iValue /= 100;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax

; 2897 : 					iValue = max(100, iValue);

	mov	DWORD PTR $T232250[ebp], 100		; 00000064H
	mov	edx, DWORD PTR $T232250[ebp]
	cmp	edx, DWORD PTR _iValue$[ebp]
	jge	SHORT $LN30@GetTradeCo@11
	lea	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR tv422[ebp], eax
	jmp	SHORT $LN31@GetTradeCo@11
$LN30@GetTradeCo@11:
	lea	ecx, DWORD PTR $T232250[ebp]
	mov	DWORD PTR tv422[ebp], ecx
$LN31@GetTradeCo@11:
	mov	edx, DWORD PTR tv422[ebp]
	mov	DWORD PTR $T232261[ebp], edx
	mov	eax, DWORD PTR $T232261[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2898 : 				}
; 2899 : 				break;

	jmp	SHORT $LN22@GetTradeCo@11
$LN17@GetTradeCo@11:

; 2900 : 			case YIELD_SCIENCE:
; 2901 : 				int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
	mov	DWORD PTR _iBaseValue$220379[ebp], eax

; 2902 : 
; 2903 : 				iValue = iBaseValue;

	mov	edx, DWORD PTR _iBaseValue$220379[ebp]
	mov	DWORD PTR _iValue$[ebp], edx

; 2904 : 
; 2905 : 				int iModifier = 100;

	mov	DWORD PTR _iModifier$220380[ebp], 100	; 00000064H

; 2906 : 				
; 2907 : 				iValue *= iModifier;

	mov	eax, DWORD PTR _iValue$[ebp]
	imul	eax, DWORD PTR _iModifier$220380[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2908 : 				iValue /= 100;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax
$LN22@GetTradeCo@11:

; 2909 : 				break;
; 2910 : 			}
; 2911 : 		}
; 2912 : 	}
; 2913 : 	else

	jmp	$LN16@GetTradeCo@11
$LN23@GetTradeCo@11:

; 2914 : 	{
; 2915 : 		if (pTrade->IsConnectionInternational(kTradeConnection))

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsConnectionInternational@CvGameTrade@@QAE_NABUTradeConnection@@@Z ; CvGameTrade::IsConnectionInternational
	movzx	eax, al
	test	eax, eax
	je	$LN15@GetTradeCo@11

; 2916 : 		{
; 2917 : 			if (kTradeConnection.m_eDestOwner == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T232272[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR $T232272[ebp]
	jne	$LN14@GetTradeCo@11

; 2918 : 			{
; 2919 : 				switch (eYield)

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR tv194[ebp], eax
	cmp	DWORD PTR tv194[ebp], 2
	je	SHORT $LN11@GetTradeCo@11
	cmp	DWORD PTR tv194[ebp], 3
	je	$LN10@GetTradeCo@11
	jmp	$LN14@GetTradeCo@11
$LN11@GetTradeCo@11:

; 2920 : 				{
; 2921 : 				case YIELD_GOLD:
; 2922 : 					{
; 2923 : 						int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
	mov	DWORD PTR _iBaseValue$220389[ebp], eax

; 2924 : 						int iYourBuildingBonus = GetTradeConnectionYourBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionYourBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionYourBuildingValueTimes100
	mov	DWORD PTR _iYourBuildingBonus$220390[ebp], eax

; 2925 : 						int iTheirBuildingBonus = GetTradeConnectionTheirBuildingValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	ecx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionTheirBuildingValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionTheirBuildingValueTimes100
	mov	DWORD PTR _iTheirBuildingBonus$220391[ebp], eax

; 2926 : 
; 2927 : 						int iModifier = 100;

	mov	DWORD PTR _iModifier$220392[ebp], 100	; 00000064H

; 2928 : 						int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
	mov	DWORD PTR _iDomainModifier$220393[ebp], eax

; 2929 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2930 : 						iValue *= iDomainModifier + 100;
; 2931 : 						iValue /= 100;
; 2932 : #endif
; 2933 : 						int iDestRiverModifier = GetTradeConnectionRiverValueModifierTimes100(kTradeConnection, eYield, false);

	push	0
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionRiverValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionRiverValueModifierTimes100
	mov	DWORD PTR _iDestRiverModifier$220394[ebp], eax

; 2934 : 						int iTraitBonus = GetTradeConnectionOtherTraitValueTimes100(kTradeConnection, eYield, false);

	push	0
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionOtherTraitValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionOtherTraitValueTimes100
	mov	DWORD PTR _iTraitBonus$220395[ebp], eax

; 2935 : 
; 2936 : 						iValue = iBaseValue;

	mov	ecx, DWORD PTR _iBaseValue$220389[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2937 : 						iValue += iYourBuildingBonus;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, DWORD PTR _iYourBuildingBonus$220390[ebp]
	mov	DWORD PTR _iValue$[ebp], edx

; 2938 : 						iValue += iTheirBuildingBonus;

	mov	eax, DWORD PTR _iValue$[ebp]
	add	eax, DWORD PTR _iTheirBuildingBonus$220391[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2939 : 						iValue += iTraitBonus;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, DWORD PTR _iTraitBonus$220395[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2940 : 
; 2941 : #ifndef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2942 : 						iModifier += iDomainModifier;

	mov	edx, DWORD PTR _iModifier$220392[ebp]
	add	edx, DWORD PTR _iDomainModifier$220393[ebp]
	mov	DWORD PTR _iModifier$220392[ebp], edx

; 2943 : #endif
; 2944 : 						iModifier += iDestRiverModifier;

	mov	eax, DWORD PTR _iModifier$220392[ebp]
	add	eax, DWORD PTR _iDestRiverModifier$220394[ebp]
	mov	DWORD PTR _iModifier$220392[ebp], eax

; 2945 : 
; 2946 : 						iValue *= iModifier;

	mov	ecx, DWORD PTR _iValue$[ebp]
	imul	ecx, DWORD PTR _iModifier$220392[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2947 : 						iValue /= 100;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax

; 2948 : 					}
; 2949 : 					break;

	jmp	SHORT $LN14@GetTradeCo@11
$LN10@GetTradeCo@11:

; 2950 : 				case YIELD_SCIENCE:
; 2951 : 					{
; 2952 : 						int iBaseValue = GetTradeConnectionBaseValueTimes100(kTradeConnection, eYield, bAsOriginPlayer);

	movzx	edx, BYTE PTR _bAsOriginPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionBaseValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionBaseValueTimes100
	mov	DWORD PTR _iBaseValue$220397[ebp], eax

; 2953 : 
; 2954 : 						int iModifier = 100;

	mov	DWORD PTR _iModifier$220398[ebp], 100	; 00000064H

; 2955 : 
; 2956 : 						iValue = iBaseValue;

	mov	edx, DWORD PTR _iBaseValue$220397[ebp]
	mov	DWORD PTR _iValue$[ebp], edx

; 2957 : 
; 2958 : 						iValue *= iModifier;

	mov	eax, DWORD PTR _iValue$[ebp]
	imul	eax, DWORD PTR _iModifier$220398[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2959 : 						iValue /= 100;						

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax
$LN14@GetTradeCo@11:

; 2960 : 					}
; 2961 : 					break;
; 2962 : 				}
; 2963 : 			}
; 2964 : 		}
; 2965 : 		else

	jmp	$LN16@GetTradeCo@11
$LN15@GetTradeCo@11:

; 2966 : 		{
; 2967 : 			// NQMP GJS - Silk Road begin
; 2968 : 			if (eYield == YIELD_GOLD)

	cmp	DWORD PTR _eYield$[ebp], 2
	jne	SHORT $LN8@GetTradeCo@11

; 2969 : 			{
; 2970 : 				iValue = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_GOLD_CHANGE);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232276[ebp], eax
	push	67					; 00000043H
	mov	ecx, DWORD PTR $T232276[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	mov	DWORD PTR _iValue$[ebp], eax
$LN8@GetTradeCo@11:

; 2971 : 			}
; 2972 : 			// NQMP GJS - Silk Road end
; 2973 : 			switch (kTradeConnection.m_eConnectionType)

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR tv254[ebp], edx
	cmp	DWORD PTR tv254[ebp], 1
	je	SHORT $LN5@GetTradeCo@11
	cmp	DWORD PTR tv254[ebp], 2
	je	$LN2@GetTradeCo@11
	jmp	$LN16@GetTradeCo@11
$LN5@GetTradeCo@11:

; 2974 : 			{
; 2975 : 			case TRADE_CONNECTION_FOOD:
; 2976 : 				if (eYield == YIELD_FOOD)

	cmp	DWORD PTR _eYield$[ebp], 0
	jne	$LN4@GetTradeCo@11

; 2977 : 				{
; 2978 : 					iValue = 300;

	mov	DWORD PTR _iValue$[ebp], 300		; 0000012cH

; 2979 : 					iValue += GC.getEraInfo(GET_PLAYER(kTradeConnection.m_eDestOwner).GetCurrentEra())->getTradeRouteFoodBonusTimes100();

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232280[ebp], ecx
	mov	ecx, DWORD PTR $T232280[ebp]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getTradeRouteFoodBonusTimes100@CvEraInfo@@QBEHXZ ; CvEraInfo::getTradeRouteFoodBonusTimes100
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2980 : 					iValue *= GC.getEraInfo(GC.getGame().getStartEra())->getGrowthPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232284[ebp], edx
	mov	ecx, DWORD PTR $T232284[ebp]
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getGrowthPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getGrowthPercent
	imul	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2981 : 					iValue /= 100;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax

; 2982 : 
; 2983 : 					int iModifier = 100;

	mov	DWORD PTR _iModifier$220407[ebp], 100	; 00000064H

; 2984 : 					int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
	mov	DWORD PTR _iDomainModifier$220408[ebp], eax

; 2985 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 2986 : 					iValue *= iDomainModifier + 100;
; 2987 : 					iValue /= 100;
; 2988 : #else
; 2989 : 					iModifier += iDomainModifier;

	mov	ecx, DWORD PTR _iModifier$220407[ebp]
	add	ecx, DWORD PTR _iDomainModifier$220408[ebp]
	mov	DWORD PTR _iModifier$220407[ebp], ecx

; 2990 : #endif
; 2991 : 					iModifier += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_MODIFIER);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232288[ebp], eax
	push	43					; 0000002bH
	mov	ecx, DWORD PTR $T232288[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iModifier$220407[ebp]
	mov	DWORD PTR _iModifier$220407[ebp], eax

; 2992 : 					iValue *= iModifier;

	mov	ecx, DWORD PTR _iValue$[ebp]
	imul	ecx, DWORD PTR _iModifier$220407[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2993 : 					iValue /= 100;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax
$LN4@GetTradeCo@11:

; 2994 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 2995 : 					iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE);
; 2996 : #endif
; 2997 : 				}
; 2998 : 
; 2999 : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 3000 : 				if (eYield == YIELD_PRODUCTION)

	cmp	DWORD PTR _eYield$[ebp], 1
	jne	SHORT $LN3@GetTradeCo@11

; 3001 : 				{
; 3002 : 					iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_PRODUCTION_YIELD_CHANGE);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232292[ebp], eax
	push	44					; 0000002cH
	mov	ecx, DWORD PTR $T232292[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax
$LN3@GetTradeCo@11:

; 3003 : 				}
; 3004 : #endif
; 3005 : 
; 3006 : 				break;

	jmp	$LN16@GetTradeCo@11
$LN2@GetTradeCo@11:

; 3007 : 			case TRADE_CONNECTION_PRODUCTION:
; 3008 : 				if (eYield == YIELD_PRODUCTION)

	cmp	DWORD PTR _eYield$[ebp], 1
	jne	$LN16@GetTradeCo@11

; 3009 : 				{
; 3010 : 					iValue = 300;

	mov	DWORD PTR _iValue$[ebp], 300		; 0000012cH

; 3011 : 					iValue += GC.getEraInfo(GET_PLAYER(kTradeConnection.m_eDestOwner).GetCurrentEra())->getTradeRouteProductionBonusTimes100();

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232296[ebp], edx
	mov	ecx, DWORD PTR $T232296[ebp]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getTradeRouteProductionBonusTimes100@CvEraInfo@@QBEHXZ ; CvEraInfo::getTradeRouteProductionBonusTimes100
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 3012 : 					iValue *= (GC.getEraInfo(GC.getGame().getStartEra())->getConstructPercent() + GC.getEraInfo(GC.getGame().getStartEra())->getTrainPercent()) / 2;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232300[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232304[ebp], ecx
	mov	ecx, DWORD PTR $T232300[ebp]
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getConstructPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getConstructPercent
	mov	esi, eax
	mov	ecx, DWORD PTR $T232304[ebp]
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEraInfo@CvGlobals@@QAEPAVCvEraInfo@@W4EraTypes@@@Z ; CvGlobals::getEraInfo
	mov	ecx, eax
	call	?getTrainPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getTrainPercent
	add	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	imul	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 3013 : 					iValue /= 100;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax

; 3014 : 
; 3015 : 					int iModifier = 100;

	mov	DWORD PTR _iModifier$220412[ebp], 100	; 00000064H

; 3016 : 					int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(kTradeConnection, eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
	mov	DWORD PTR _iDomainModifier$220413[ebp], eax

; 3017 : #ifdef AUI_TRADE_FIX_CONNECTION_VALUE_MULTIPLICATIVE_STACKING_DOMAIN_MODIFIERS
; 3018 : 					iValue *= iDomainModifier + 100;
; 3019 : 					iValue /= 100;
; 3020 : #else
; 3021 : 					iModifier += iDomainModifier;

	mov	ecx, DWORD PTR _iModifier$220412[ebp]
	add	ecx, DWORD PTR _iDomainModifier$220413[ebp]
	mov	DWORD PTR _iModifier$220412[ebp], ecx

; 3022 : #endif
; 3023 : 					iModifier += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_MODIFIER);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232308[ebp], eax
	push	43					; 0000002bH
	mov	ecx, DWORD PTR $T232308[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iModifier$220412[ebp]
	mov	DWORD PTR _iModifier$220412[ebp], eax

; 3024 : 					iValue *= iModifier;

	mov	ecx, DWORD PTR _iValue$[ebp]
	imul	ecx, DWORD PTR _iModifier$220412[ebp]
	mov	DWORD PTR _iValue$[ebp], ecx

; 3025 : 					iValue /= 100;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValue$[ebp], eax

; 3026 : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 3027 : 					iValue += GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_PRODUCTION_YIELD_CHANGE);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232312[ebp], eax
	push	44					; 0000002cH
	mov	ecx, DWORD PTR $T232312[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax
$LN16@GetTradeCo@11:

; 3028 : #endif
; 3029 : 				}
; 3030 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 3031 : 				if (eYield == YIELD_FOOD)
; 3032 : 				{
; 3033 : 					iValue = GET_PLAYER(kTradeConnection.m_eDestOwner).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE);
; 3034 : 				}
; 3035 : #endif
; 3036 : 
; 3037 : 				break;
; 3038 : 			}
; 3039 : 		}
; 3040 : 	}
; 3041 : 
; 3042 : 	return iValue;	

	mov	eax, DWORD PTR _iValue$[ebp]

; 3043 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN56@GetTradeCo@11:
	DD	$LN19@GetTradeCo@11
	DD	$LN19@GetTradeCo@11
	DD	$LN18@GetTradeCo@11
	DD	$LN17@GetTradeCo@11
?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ENDP ; CvPlayerTrade::GetTradeConnectionValueTimes100
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T232344 = -36						; size = 4
$T232335 = -32						; size = 4
$T232323 = -28						; size = 4
$T232319 = -24						; size = 4
_uiYields$220432 = -20					; size = 4
_uiYields$220426 = -16					; size = 4
_pConnection$220423 = -12				; size = 4
_ui$220419 = -8						; size = 4
_pTrade$ = -4						; size = 4
?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ PROC	; CvPlayerTrade::UpdateTradeConnectionValues, COMDAT
; _this$ = ecx

; 3047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3048 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232319[ebp], eax
	mov	ecx, DWORD PTR $T232319[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3049 : #ifdef AUI_ITERATORIZE
; 3050 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3051 : 	{
; 3052 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3053 : #else
; 3054 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$220419[ebp], 0
	jmp	SHORT $LN12@UpdateTrad
$LN11@UpdateTrad:
	mov	ecx, DWORD PTR _ui$220419[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220419[ebp], ecx
$LN12@UpdateTrad:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232323[ebp], eax
	mov	ecx, DWORD PTR _ui$220419[ebp]
	cmp	ecx, DWORD PTR $T232323[ebp]
	jae	$LN13@UpdateTrad

; 3055 : 	{
; 3056 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	edx, DWORD PTR _ui$220419[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pConnection$220423[ebp], edx

; 3057 : 
; 3058 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$220419[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN23@UpdateTrad

; 3059 : #endif
; 3060 : 		{
; 3061 : 			continue;

	jmp	SHORT $LN11@UpdateTrad

; 3062 : 		}
; 3063 : 
; 3064 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

$LN23@UpdateTrad:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232335[ebp], edx
	mov	eax, DWORD PTR _pConnection$220423[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR $T232335[ebp]
	jne	SHORT $LN27@UpdateTrad

; 3065 : 		{
; 3066 : 			for (uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	mov	DWORD PTR _uiYields$220426[ebp], 0
	jmp	SHORT $LN7@UpdateTrad
$LN6@UpdateTrad:
	mov	edx, DWORD PTR _uiYields$220426[ebp]
	add	edx, 1
	mov	DWORD PTR _uiYields$220426[ebp], edx
$LN7@UpdateTrad:
	cmp	DWORD PTR _uiYields$220426[ebp], 6
	jae	SHORT $LN27@UpdateTrad

; 3067 : 			{
; 3068 : 				pConnection->m_aiOriginYields[uiYields] = GetTradeConnectionValueTimes100(*pConnection, (YieldTypes)uiYields, true);

	push	1
	mov	eax, DWORD PTR _uiYields$220426[ebp]
	push	eax
	mov	ecx, DWORD PTR _pConnection$220423[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
	mov	edx, DWORD PTR _uiYields$220426[ebp]
	mov	ecx, DWORD PTR _pConnection$220423[ebp]
	mov	DWORD PTR [ecx+edx*4+396], eax
	jmp	SHORT $LN6@UpdateTrad

; 3069 : 			}
; 3070 : 		}
; 3071 : 
; 3072 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID())

$LN27@UpdateTrad:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+79104]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232344[ebp], ecx
	mov	edx, DWORD PTR _pConnection$220423[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR $T232344[ebp]
	jne	SHORT $LN4@UpdateTrad

; 3073 : 		{
; 3074 : 			for (uint uiYields = 0; uiYields < NUM_YIELD_TYPES; uiYields++)

	mov	DWORD PTR _uiYields$220432[ebp], 0
	jmp	SHORT $LN3@UpdateTrad
$LN2@UpdateTrad:
	mov	ecx, DWORD PTR _uiYields$220432[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiYields$220432[ebp], ecx
$LN3@UpdateTrad:
	cmp	DWORD PTR _uiYields$220432[ebp], 6
	jae	SHORT $LN4@UpdateTrad

; 3075 : 			{
; 3076 : 				pConnection->m_aiDestYields[uiYields] = GetTradeConnectionValueTimes100(*pConnection, (YieldTypes)uiYields, false);

	push	0
	mov	edx, DWORD PTR _uiYields$220432[ebp]
	push	edx
	mov	eax, DWORD PTR _pConnection$220423[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
	mov	ecx, DWORD PTR _uiYields$220432[ebp]
	mov	edx, DWORD PTR _pConnection$220423[ebp]
	mov	DWORD PTR [edx+ecx*4+420], eax
	jmp	SHORT $LN2@UpdateTrad
$LN4@UpdateTrad:

; 3077 : 			}

	jmp	$LN11@UpdateTrad
$LN13@UpdateTrad:

; 3078 : 		}
; 3079 : 	}
; 3080 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTradeConnectionValues@CvPlayerTrade@@QAEXXZ ENDP	; CvPlayerTrade::UpdateTradeConnectionValues
_TEXT	ENDS
PUBLIC	?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeValuesAtCityTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T232391 = -40						; size = 4
$T232382 = -36						; size = 4
$T232370 = -32						; size = 4
$T232366 = -28						; size = 4
_pConnection$220450 = -24				; size = 4
_ui$220446 = -20					; size = 4
_iCityY$ = -16						; size = 4
_iResult$ = -12						; size = 4
_pTrade$ = -8						; size = 4
_iCityX$ = -4						; size = 4
_pCity$ = 8						; size = 4
_eYield$ = 12						; size = 4
?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z PROC ; CvPlayerTrade::GetTradeValuesAtCityTimes100, COMDAT
; _this$ = ecx

; 3088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 3089 : 	int iResult = 0;

	mov	DWORD PTR _iResult$[ebp], 0

; 3090 : 	int iCityX = pCity->getX();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iCityX$[ebp], ecx

; 3091 : 	int iCityY = pCity->getY();

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iCityY$[ebp], eax

; 3092 : 
; 3093 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232366[ebp], ecx
	mov	ecx, DWORD PTR $T232366[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3094 : #ifdef AUI_ITERATORIZE
; 3095 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3096 : 	{
; 3097 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3098 : #else
; 3099 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$220446[ebp], 0
	jmp	SHORT $LN8@GetTradeVa
$LN7@GetTradeVa:
	mov	edx, DWORD PTR _ui$220446[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$220446[ebp], edx
$LN8@GetTradeVa:
	mov	eax, DWORD PTR _pTrade$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232370[ebp], ecx
	mov	edx, DWORD PTR _ui$220446[ebp]
	cmp	edx, DWORD PTR $T232370[ebp]
	jae	$LN6@GetTradeVa

; 3100 : 	{
; 3101 : #ifdef AUI_CONSTIFY
; 3102 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3103 : #else
; 3104 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	eax, DWORD PTR _ui$220446[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _pTrade$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pConnection$220450[ebp], eax

; 3105 : #endif
; 3106 : 
; 3107 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$220446[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@GetTradeVa

; 3108 : #endif
; 3109 : 		{
; 3110 : 			continue;

	jmp	SHORT $LN7@GetTradeVa

; 3111 : 		}
; 3112 : 
; 3113 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

$LN27@GetTradeVa:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T232382[ebp], eax
	mov	ecx, DWORD PTR _pConnection$220450[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR $T232382[ebp]
	jne	SHORT $LN31@GetTradeVa

; 3114 : 		{
; 3115 : 			if (pConnection->m_iOriginX == iCityX && pConnection->m_iOriginY == iCityY)

	mov	eax, DWORD PTR _pConnection$220450[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iCityX$[ebp]
	jne	SHORT $LN31@GetTradeVa
	mov	edx, DWORD PTR _pConnection$220450[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _iCityY$[ebp]
	jne	SHORT $LN31@GetTradeVa

; 3116 : 			{
; 3117 : 				iResult += pConnection->m_aiOriginYields[eYield];

	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR _pConnection$220450[ebp]
	mov	eax, DWORD PTR _iResult$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+396]
	mov	DWORD PTR _iResult$[ebp], eax

; 3118 : 			}
; 3119 : 		}
; 3120 : 		
; 3121 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID())

$LN31@GetTradeVa:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T232391[ebp], eax
	mov	ecx, DWORD PTR _pConnection$220450[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR $T232391[ebp]
	jne	SHORT $LN2@GetTradeVa

; 3122 : 		{
; 3123 : 			if (pConnection->m_iDestX == iCityX && pConnection->m_iDestY == iCityY)

	mov	eax, DWORD PTR _pConnection$220450[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _iCityX$[ebp]
	jne	SHORT $LN2@GetTradeVa
	mov	edx, DWORD PTR _pConnection$220450[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _iCityY$[ebp]
	jne	SHORT $LN2@GetTradeVa

; 3124 : 			{
; 3125 : 				iResult += pConnection->m_aiDestYields[eYield];

	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR _pConnection$220450[ebp]
	mov	eax, DWORD PTR _iResult$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+420]
	mov	DWORD PTR _iResult$[ebp], eax
$LN2@GetTradeVa:

; 3126 : 			}
; 3127 : 		}
; 3128 : 	}

	jmp	$LN7@GetTradeVa
$LN6@GetTradeVa:

; 3129 : 
; 3130 : 	return iResult;

	mov	eax, DWORD PTR _iResult$[ebp]

; 3131 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTradeValuesAtCityTimes100@CvPlayerTrade@@QAEHQBVCvCity@@W4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetTradeValuesAtCityTimes100
_TEXT	ENDS
PUBLIC	?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z ; CvPlayerTrade::GetAllTradeValueTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T232422 = -32						; size = 4
$T232413 = -28						; size = 4
$T232401 = -24						; size = 4
$T232397 = -20						; size = 4
_pConnection$220466 = -16				; size = 4
_ui$220462 = -12					; size = 4
_iTotal$ = -8						; size = 4
_pTrade$ = -4						; size = 4
_eYield$ = 8						; size = 4
?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z PROC ; CvPlayerTrade::GetAllTradeValueTimes100, COMDAT
; _this$ = ecx

; 3139 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3140 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232397[ebp], eax
	mov	ecx, DWORD PTR $T232397[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3141 : 	int iTotal = 0;

	mov	DWORD PTR _iTotal$[ebp], 0

; 3142 : #ifdef AUI_ITERATORIZE
; 3143 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3144 : 	{
; 3145 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3146 : #else
; 3147 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$220462[ebp], 0
	jmp	SHORT $LN6@GetAllTrad
$LN5@GetAllTrad:
	mov	ecx, DWORD PTR _ui$220462[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220462[ebp], ecx
$LN6@GetAllTrad:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232401[ebp], eax
	mov	ecx, DWORD PTR _ui$220462[ebp]
	cmp	ecx, DWORD PTR $T232401[ebp]
	jae	$LN4@GetAllTrad

; 3148 : 	{
; 3149 : #ifdef AUI_CONSTIFY
; 3150 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3151 : #else
; 3152 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	edx, DWORD PTR _ui$220462[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pConnection$220466[ebp], edx

; 3153 : #endif
; 3154 : 
; 3155 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$220462[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@GetAllTrad

; 3156 : #endif
; 3157 : 		{
; 3158 : 			continue;

	jmp	SHORT $LN5@GetAllTrad

; 3159 : 		}
; 3160 : 
; 3161 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

$LN17@GetAllTrad:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232413[ebp], edx
	mov	eax, DWORD PTR _pConnection$220466[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR $T232413[ebp]
	jne	SHORT $LN21@GetAllTrad

; 3162 : 		{
; 3163 : 			iTotal += pConnection->m_aiOriginYields[eYield];

	mov	edx, DWORD PTR _eYield$[ebp]
	mov	eax, DWORD PTR _pConnection$220466[ebp]
	mov	ecx, DWORD PTR _iTotal$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+396]
	mov	DWORD PTR _iTotal$[ebp], ecx

; 3164 : 		}
; 3165 : 
; 3166 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID())

$LN21@GetAllTrad:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+79104]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232422[ebp], ecx
	mov	edx, DWORD PTR _pConnection$220466[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR $T232422[ebp]
	jne	SHORT $LN1@GetAllTrad

; 3167 : 		{
; 3168 : 			iTotal += pConnection->m_aiDestYields[eYield];

	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR _pConnection$220466[ebp]
	mov	eax, DWORD PTR _iTotal$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+420]
	mov	DWORD PTR _iTotal$[ebp], eax
$LN1@GetAllTrad:

; 3169 : 		}
; 3170 : 	}

	jmp	$LN5@GetAllTrad
$LN4@GetAllTrad:

; 3171 : 
; 3172 : 	return iTotal;

	mov	eax, DWORD PTR _iTotal$[ebp]

; 3173 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAllTradeValueTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@@Z ENDP ; CvPlayerTrade::GetAllTradeValueTimes100
_TEXT	ENDS
PUBLIC	?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z ; CvPlayerTrade::GetAllTradeValueFromPlayerTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T232453 = -32						; size = 4
$T232444 = -28						; size = 4
$T232432 = -24						; size = 4
$T232428 = -20						; size = 4
_pConnection$220481 = -16				; size = 4
_ui$220477 = -12					; size = 4
_iTotal$ = -8						; size = 4
_pTrade$ = -4						; size = 4
_eYield$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z PROC ; CvPlayerTrade::GetAllTradeValueFromPlayerTimes100, COMDAT
; _this$ = ecx

; 3181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3182 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232428[ebp], eax
	mov	ecx, DWORD PTR $T232428[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3183 : 	int iTotal = 0;

	mov	DWORD PTR _iTotal$[ebp], 0

; 3184 : #ifdef AUI_ITERATORIZE
; 3185 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3186 : 	{
; 3187 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3188 : #else
; 3189 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$220477[ebp], 0
	jmp	SHORT $LN6@GetAllTrad@2
$LN5@GetAllTrad@2:
	mov	ecx, DWORD PTR _ui$220477[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220477[ebp], ecx
$LN6@GetAllTrad@2:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232432[ebp], eax
	mov	ecx, DWORD PTR _ui$220477[ebp]
	cmp	ecx, DWORD PTR $T232432[ebp]
	jae	$LN4@GetAllTrad@2

; 3190 : 	{
; 3191 : #ifdef AUI_CONSTIFY
; 3192 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3193 : #else
; 3194 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	edx, DWORD PTR _ui$220477[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pConnection$220481[ebp], edx

; 3195 : #endif
; 3196 : 
; 3197 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$220477[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@GetAllTrad@2

; 3198 : #endif
; 3199 : 		{
; 3200 : 			continue;

	jmp	SHORT $LN5@GetAllTrad@2

; 3201 : 		}
; 3202 : 
; 3203 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID() && pConnection->m_eDestOwner == ePlayer)

$LN17@GetAllTrad@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232444[ebp], edx
	mov	eax, DWORD PTR _pConnection$220481[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR $T232444[ebp]
	jne	SHORT $LN21@GetAllTrad@2
	mov	edx, DWORD PTR _pConnection$220481[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN21@GetAllTrad@2

; 3204 : 		{
; 3205 : 			iTotal += pConnection->m_aiOriginYields[eYield];

	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR _pConnection$220481[ebp]
	mov	eax, DWORD PTR _iTotal$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+396]
	mov	DWORD PTR _iTotal$[ebp], eax

; 3206 : 		}
; 3207 : 
; 3208 : 		if (pConnection->m_eDestOwner == m_pPlayer->GetID() && pConnection->m_eOriginOwner == ePlayer)

$LN21@GetAllTrad@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T232453[ebp], eax
	mov	ecx, DWORD PTR _pConnection$220481[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR $T232453[ebp]
	jne	SHORT $LN1@GetAllTrad@2
	mov	eax, DWORD PTR _pConnection$220481[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN1@GetAllTrad@2

; 3209 : 		{
; 3210 : 			iTotal += pConnection->m_aiDestYields[eYield];

	mov	edx, DWORD PTR _eYield$[ebp]
	mov	eax, DWORD PTR _pConnection$220481[ebp]
	mov	ecx, DWORD PTR _iTotal$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+420]
	mov	DWORD PTR _iTotal$[ebp], ecx
$LN1@GetAllTrad@2:

; 3211 : 		}
; 3212 : 	}

	jmp	$LN5@GetAllTrad@2
$LN4@GetAllTrad@2:

; 3213 : 
; 3214 : 	return iTotal;

	mov	eax, DWORD PTR _iTotal$[ebp]

; 3215 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetAllTradeValueFromPlayerTimes100@CvPlayerTrade@@QAEHW4YieldTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayerTrade::GetAllTradeValueFromPlayerTimes100
_TEXT	ENDS
PUBLIC	?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z ; CvPlayerTrade::IsConnectedToPlayer
; Function compile flags: /Odtp
;	COMDAT ?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T232468 = -8						; size = 4
$T232464 = -4						; size = 4
_eOtherPlayer$ = 8					; size = 4
?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlayerTrade::IsConnectedToPlayer, COMDAT
; _this$ = ecx

; 3223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3224 : 	return GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pPlayer->GetID(), eOtherPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232464[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232468[ebp], eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232464[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232468[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer

; 3225 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsConnectedToPlayer@CvPlayerTrade@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlayerTrade::IsConnectedToPlayer
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isRevealed
PUBLIC	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
EXTRN	?IsAllowedToTradeWith@CvPlayer@@QAE_NW4PlayerTypes@@@Z:PROC ; CvPlayer::IsAllowedToTradeWith
; Function compile flags: /Odtp
;	COMDAT ?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T232502 = -28						; size = 4
$T232484 = -16						; size = 4
$T232483 = -12						; size = 4
$T232474 = -8						; size = 4
_pTrade$ = -4						; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
_bIgnoreExisting$ = 24					; size = 1
_bCheckPath$ = 28					; size = 1
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z PROC ; CvPlayerTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 3234 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 3235 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232474[ebp], eax
	mov	ecx, DWORD PTR $T232474[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3236 : 
; 3237 : 	// if you can't see the plot, you're not allowed to connect it
; 3238 : 	if (!pDestCity->plot()->isRevealed(m_pPlayer->getTeam(), false))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	DWORD PTR $T232483[ebp], edx
	mov	eax, DWORD PTR $T232483[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232484[ebp], eax
	push	0
	mov	edx, DWORD PTR $T232484[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isRevealed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN22@CanCreateT@3

; 3239 : 	{
; 3240 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@CanCreateT@3

; 3241 : 	}
; 3242 : 
; 3243 : 	if (!m_pPlayer->IsAllowedToTradeWith(pDestCity->getOwner()))

$LN22@CanCreateT@3:
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T232502[ebp], edx
	mov	eax, DWORD PTR $T232502[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?IsAllowedToTradeWith@CvPlayer@@QAE_NW4PlayerTypes@@@Z ; CvPlayer::IsAllowedToTradeWith
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@CanCreateT@3

; 3244 : 	{
; 3245 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@CanCreateT@3
$LN3@CanCreateT@3:

; 3246 : 	}
; 3247 : 
; 3248 : 	if (pTrade->CanCreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnectionType, bIgnoreExisting, bCheckPath))

	movzx	eax, BYTE PTR _bCheckPath$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bIgnoreExisting$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eConnectionType$[ebp]
	push	edx
	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOriginCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?CanCreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvGameTrade::CanCreateTradeRoute
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@CanCreateT@3

; 3249 : 	{
; 3250 : 		return true;

	mov	al, 1
	jmp	SHORT $LN5@CanCreateT@3

; 3251 : 	}
; 3252 : 	else

	jmp	SHORT $LN5@CanCreateT@3
$LN2@CanCreateT@3:

; 3253 : 	{
; 3254 : 		return false;

	xor	al, al
$LN5@CanCreateT@3:

; 3255 : 	}
; 3256 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ENDP ; CvPlayerTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::CanCreateTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T232516 = -36						; size = 4
$T232512 = -32						; size = 4
$T232508 = -28						; size = 4
_uiConnectionTypes$220519 = -24				; size = 4
_pLoopCity2$220515 = -20				; size = 4
_iCityLoop2$220514 = -16				; size = 4
_iCityLoop$ = -12					; size = 4
_pGameTrade$ = -8					; size = 4
_pLoopCity$ = -4					; size = 4
_eOtherPlayer$ = 8					; size = 4
_eDomain$ = 12						; size = 4
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z PROC ; CvPlayerTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 3264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3265 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232508[ebp], eax
	mov	ecx, DWORD PTR $T232508[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pGameTrade$[ebp], eax

; 3266 : 
; 3267 : 	int iCityLoop;
; 3268 : 	CvCity* pLoopCity;
; 3269 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN11@CanCreateT@4
$LN10@CanCreateT@4:
	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN11@CanCreateT@4:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN9@CanCreateT@4

; 3270 : 	{
; 3271 : 		int iCityLoop2;
; 3272 : 		CvCity* pLoopCity2;
; 3273 : 		for (pLoopCity2 = GET_PLAYER(eOtherPlayer).firstCity(&iCityLoop2); pLoopCity2 != NULL; pLoopCity2 = GET_PLAYER(eOtherPlayer).nextCity(&iCityLoop2))

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232512[ebp], edx
	push	0
	lea	eax, DWORD PTR _iCityLoop2$220514[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232512[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity2$220515[ebp], eax
	jmp	SHORT $LN8@CanCreateT@4
$LN7@CanCreateT@4:
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232516[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iCityLoop2$220514[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232516[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity2$220515[ebp], eax
$LN8@CanCreateT@4:
	cmp	DWORD PTR _pLoopCity2$220515[ebp], 0
	je	SHORT $LN6@CanCreateT@4

; 3274 : 		{
; 3275 : 			for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	mov	DWORD PTR _uiConnectionTypes$220519[ebp], 0
	jmp	SHORT $LN5@CanCreateT@4
$LN4@CanCreateT@4:
	mov	eax, DWORD PTR _uiConnectionTypes$220519[ebp]
	add	eax, 1
	mov	DWORD PTR _uiConnectionTypes$220519[ebp], eax
$LN5@CanCreateT@4:
	cmp	DWORD PTR _uiConnectionTypes$220519[ebp], 3
	jae	SHORT $LN3@CanCreateT@4

; 3276 : 			{
; 3277 : 				// Check the route, but not the path
; 3278 : 				if (CanCreateTradeRoute(pLoopCity, pLoopCity2, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	push	0
	push	0
	mov	ecx, DWORD PTR _uiConnectionTypes$220519[ebp]
	push	ecx
	mov	edx, DWORD PTR _eDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopCity2$220515[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@CanCreateT@4

; 3279 : 				{
; 3280 : 					// Check the path
; 3281 : 					if (pGameTrade->IsValidTradeRoutePath(pLoopCity, pLoopCity2, eDomain))

	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity2$220515[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGameTrade$[ebp]
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@CanCreateT@4

; 3282 : 						return true;

	mov	al, 1
	jmp	SHORT $LN12@CanCreateT@4
$LN1@CanCreateT@4:

; 3283 : 
; 3284 : 					// else we can just break out of the loop
; 3285 : 					break;

	jmp	SHORT $LN3@CanCreateT@4
$LN2@CanCreateT@4:

; 3286 : 				}
; 3287 : 			}

	jmp	SHORT $LN4@CanCreateT@4
$LN3@CanCreateT@4:

; 3288 : 		}

	jmp	$LN7@CanCreateT@4
$LN6@CanCreateT@4:

; 3289 : 	}

	jmp	$LN10@CanCreateT@4
$LN9@CanCreateT@4:

; 3290 : 
; 3291 : 	return false;

	xor	al, al
$LN12@CanCreateT@4:

; 3292 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4PlayerTypes@@W4DomainTypes@@@Z ENDP ; CvPlayerTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z ; CvPlayerTrade::CanCreateTradeRoute
EXTRN	?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z:PROC ; CvCityManager::GetNearbyCities
; Function compile flags: /Odtp
;	COMDAT ?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T232540 = -44						; size = 4
$T232528 = -40						; size = 4
$T232523 = -36						; size = 4
$T232519 = -32						; size = 4
_uiConnectionTypes$220943 = -28				; size = 4
_pLoopCity2$220942 = -24				; size = 4
_itr$220936 = -20					; size = 4
_kNearbyCities$220536 = -16				; size = 4
_iCityLoop$ = -12					; size = 4
_pGameTrade$ = -8					; size = 4
_pLoopCity$ = -4					; size = 4
_eDomain$ = 8						; size = 4
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z PROC ; CvPlayerTrade::CanCreateTradeRoute, COMDAT
; _this$ = ecx

; 3301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 3302 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232523[ebp], eax
	mov	ecx, DWORD PTR $T232523[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pGameTrade$[ebp], eax

; 3303 : 
; 3304 : 	int iCityLoop;
; 3305 : 	CvCity* pLoopCity;
; 3306 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN11@CanCreateT@5
$LN10@CanCreateT@5:
	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN11@CanCreateT@5:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN9@CanCreateT@5

; 3307 : 	{
; 3308 : 		// Get a sorted list of nearby cities 
; 3309 : 		const CvCityManager::CityList& kNearbyCities = CvCityManager::GetNearbyCities(pLoopCity);

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	push	edx
	call	?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z ; CvCityManager::GetNearbyCities
	add	esp, 4
	mov	DWORD PTR _kNearbyCities$220536[ebp], eax

; 3310 : 		for (CvCityManager::CityList::const_iterator itr = kNearbyCities.begin(); itr != kNearbyCities.end(); ++itr)

	mov	eax, DWORD PTR _kNearbyCities$220536[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232528[ebp], ecx
	mov	edx, DWORD PTR $T232528[ebp]
	mov	DWORD PTR _itr$220936[ebp], edx
	jmp	SHORT $LN8@CanCreateT@5
$LN7@CanCreateT@5:
	mov	eax, DWORD PTR _itr$220936[ebp]
	add	eax, 4
	mov	DWORD PTR _itr$220936[ebp], eax
$LN8@CanCreateT@5:
	mov	ecx, DWORD PTR _kNearbyCities$220536[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T232540[ebp], edx
	mov	eax, DWORD PTR $T232540[ebp]
	mov	DWORD PTR $T232519[ebp], eax
	mov	ecx, DWORD PTR _itr$220936[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T232519[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@CanCreateT@5

; 3311 : 		{
; 3312 : 			CvCity* pLoopCity2 = (*itr);

	mov	edx, DWORD PTR _itr$220936[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pLoopCity2$220942[ebp], eax

; 3313 : 			for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	mov	DWORD PTR _uiConnectionTypes$220943[ebp], 0
	jmp	SHORT $LN5@CanCreateT@5
$LN4@CanCreateT@5:
	mov	ecx, DWORD PTR _uiConnectionTypes$220943[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiConnectionTypes$220943[ebp], ecx
$LN5@CanCreateT@5:
	cmp	DWORD PTR _uiConnectionTypes$220943[ebp], 3
	jae	SHORT $LN3@CanCreateT@5

; 3314 : 			{
; 3315 : 				// Check the route, but not the path
; 3316 : 				if (CanCreateTradeRoute(pLoopCity, pLoopCity2, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	push	0
	push	0
	mov	edx, DWORD PTR _uiConnectionTypes$220943[ebp]
	push	edx
	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity2$220942[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@CanCreateT@5

; 3317 : 				{
; 3318 : 					// Check the path
; 3319 : 					if (pGameTrade->IsValidTradeRoutePath(pLoopCity, pLoopCity2, eDomain))

	mov	ecx, DWORD PTR _eDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopCity2$220942[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGameTrade$[ebp]
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@CanCreateT@5

; 3320 : 						return true;

	mov	al, 1
	jmp	SHORT $LN12@CanCreateT@5
$LN1@CanCreateT@5:

; 3321 : 
; 3322 : 					// else we can just break out of the loop
; 3323 : 					break;

	jmp	SHORT $LN3@CanCreateT@5
$LN2@CanCreateT@5:

; 3324 : 				}
; 3325 : 			}

	jmp	SHORT $LN4@CanCreateT@5
$LN3@CanCreateT@5:

; 3326 : 		}

	jmp	$LN7@CanCreateT@5
$LN6@CanCreateT@5:

; 3327 : 	}

	jmp	$LN10@CanCreateT@5
$LN9@CanCreateT@5:

; 3328 : 
; 3329 : 	return false;

	xor	al, al
$LN12@CanCreateT@5:

; 3330 : 
; 3331 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CanCreateTradeRoute@CvPlayerTrade@@QAE_NW4DomainTypes@@@Z ENDP ; CvPlayerTrade::CanCreateTradeRoute
_TEXT	ENDS
PUBLIC	??_C@_0BD@GAFBEKKP@CIVILIZATION_INDIA?$AA@	; `string'
PUBLIC	??_C@_0BD@LJKPFCDB@CIVILIZATION_CHINA?$AA@	; `string'
PUBLIC	??_C@_0BE@IFCHFKBE@CIVILIZATION_MONGOL?$AA@	; `string'
PUBLIC	??_C@_0BE@OJPNDMMI@CIVILIZATION_PERSIA?$AA@	; `string'
PUBLIC	??_C@_0BE@PJGCEEDJ@CIVILIZATION_ARABIA?$AA@	; `string'
PUBLIC	??0TradeConnection@@QAE@ABU0@@Z			; TradeConnection::TradeConnection
PUBLIC	__$ArrayPad$
PUBLIC	?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ; CvPlayerTrade::CreateTradeRoute
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
;	COMDAT ??_C@_0BD@GAFBEKKP@CIVILIZATION_INDIA?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BD@GAFBEKKP@CIVILIZATION_INDIA?$AA@ DB 'CIVILIZATION_INDIA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LJKPFCDB@CIVILIZATION_CHINA?$AA@
CONST	SEGMENT
??_C@_0BD@LJKPFCDB@CIVILIZATION_CHINA?$AA@ DB 'CIVILIZATION_CHINA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IFCHFKBE@CIVILIZATION_MONGOL?$AA@
CONST	SEGMENT
??_C@_0BE@IFCHFKBE@CIVILIZATION_MONGOL?$AA@ DB 'CIVILIZATION_MONGOL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OJPNDMMI@CIVILIZATION_PERSIA?$AA@
CONST	SEGMENT
??_C@_0BE@OJPNDMMI@CIVILIZATION_PERSIA?$AA@ DB 'CIVILIZATION_PERSIA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PJGCEEDJ@CIVILIZATION_ARABIA?$AA@
CONST	SEGMENT
??_C@_0BE@PJGCEEDJ@CIVILIZATION_ARABIA?$AA@ DB 'CIVILIZATION_ARABIA', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z$0
__ehfuncinfo$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
_TEXT	SEGMENT
tv339 = -2788						; size = 4
tv320 = -2784						; size = 4
tv655 = -2780						; size = 4
tv650 = -2774						; size = 1
tv643 = -2773						; size = 1
tv639 = -2772						; size = 4
tv640 = -2768						; size = 4
tv307 = -2764						; size = 4
tv632 = -2760						; size = 4
tv627 = -2754						; size = 1
tv620 = -2753						; size = 1
tv616 = -2752						; size = 4
tv617 = -2748						; size = 4
tv294 = -2744						; size = 4
tv609 = -2740						; size = 4
tv604 = -2734						; size = 1
tv597 = -2733						; size = 1
tv593 = -2732						; size = 4
tv594 = -2728						; size = 4
tv281 = -2724						; size = 4
tv586 = -2720						; size = 4
tv581 = -2714						; size = 1
tv574 = -2713						; size = 1
tv570 = -2712						; size = 4
tv571 = -2708						; size = 4
tv268 = -2704						; size = 4
tv563 = -2700						; size = 4
tv558 = -2694						; size = 1
tv551 = -2693						; size = 1
tv547 = -2692						; size = 4
tv548 = -2688						; size = 4
tv200 = -2684						; size = 4
tv173 = -2680						; size = 4
_this$ = -2676						; size = 4
$T232723 = -2672					; size = 4
$T232688 = -2656					; size = 4
$T232684 = -2652					; size = 4
$T232680 = -2648					; size = 4
$T232676 = -2644					; size = 4
$T232672 = -2640					; size = 4
$T232636 = -2620					; size = 4
$T232625 = -2616					; size = 4
$T232621 = -2612					; size = 4
$T232617 = -2608					; size = 4
$T232613 = -2604					; size = 4
$T232606 = -2600					; size = 4
$T232602 = -2596					; size = 4
$T232593 = -2592					; size = 4
$T232589 = -2588					; size = 4
$T232582 = -2584					; size = 4
$T232575 = -2580					; size = 4
$T232571 = -2576					; size = 4
$T232567 = -2572					; size = 4
$T232563 = -2568					; size = 4
_kConnection$220985 = -2564				; size = 444
__$ArrayPad$ = -2112					; size = 4
_ui$220980 = -2108					; size = 4
_bConnectedToIndia$220978 = -2101			; size = 1
_bConnectedToChina$220977 = -2100			; size = 1
_bConnectedToPersia$220975 = -2099			; size = 1
_bConnectedToMongols$220976 = -2098			; size = 1
_bConnectedToArabs$220974 = -2097			; size = 1
_pGameTrade$220979 = -2096				; size = 4
_ui$220968 = -2092					; size = 4
_nPlots$220965 = -2088					; size = 4
_plotsY$ = -2084					; size = 1024
_iRouteID$ = -1056					; size = 4
_bResult$ = -1049					; size = 1
_pTrade$ = -1048					; size = 4
_plotsX$ = -1044					; size = 1024
_iRouteIndex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z PROC ; CvPlayerTrade::CreateTradeRoute, COMDAT
; _this$ = ecx

; 3335 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2776				; 00000ad8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3336 : 	int plotsX[MAX_PLOTS_TO_DISPLAY], plotsY[MAX_PLOTS_TO_DISPLAY];
; 3337 : 
; 3338 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232563[ebp], eax
	mov	ecx, DWORD PTR $T232563[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3339 : 	int iRouteID = -1;

	mov	DWORD PTR _iRouteID$[ebp], -1

; 3340 : 	bool bResult = pTrade->CreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnectionType, iRouteID);

	lea	ecx, DWORD PTR _iRouteID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eConnectionType$[ebp]
	push	edx
	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOriginCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?CreateTradeRoute@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@AAH@Z ; CvGameTrade::CreateTradeRoute
	mov	BYTE PTR _bResult$[ebp], al

; 3341 : 	if (!bResult)

	movzx	eax, BYTE PTR _bResult$[ebp]
	test	eax, eax
	jne	SHORT $LN24@CreateTrad@2

; 3342 : 	{
; 3343 : 		return false;

	xor	al, al
	jmp	$LN25@CreateTrad@2
$LN24@CreateTrad@2:

; 3344 : 	}
; 3345 : 
; 3346 : 	int iRouteIndex = pTrade->GetIndexFromID(iRouteID);

	mov	ecx, DWORD PTR _iRouteID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?GetIndexFromID@CvGameTrade@@QAEHH@Z	; CvGameTrade::GetIndexFromID
	mov	DWORD PTR _iRouteIndex$[ebp], eax

; 3347 : 	if (iRouteIndex != -1)

	cmp	DWORD PTR _iRouteIndex$[ebp], -1
	je	$LN23@CreateTrad@2

; 3348 : 	{
; 3349 : 		int nPlots = pTrade->m_aTradeConnections[iRouteIndex].m_aPlotList.size();

	mov	edx, DWORD PTR _iRouteIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T232567[ebp], edx
	mov	ecx, DWORD PTR $T232567[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T232571[ebp], edx
	mov	eax, DWORD PTR $T232571[ebp]
	mov	DWORD PTR _nPlots$220965[ebp], eax

; 3350 : 		if (nPlots > 0) {

	cmp	DWORD PTR _nPlots$220965[ebp], 0
	jle	$LN23@CreateTrad@2

; 3351 : 			if (nPlots > MAX_PLOTS_TO_DISPLAY)

	cmp	DWORD PTR _nPlots$220965[ebp], 256	; 00000100H
	jle	SHORT $LN21@CreateTrad@2

; 3352 : 				nPlots = MAX_PLOTS_TO_DISPLAY;

	mov	DWORD PTR _nPlots$220965[ebp], 256	; 00000100H
$LN21@CreateTrad@2:

; 3353 : 			for (uint ui = 0; ui < (uint)nPlots; ui++) 

	mov	DWORD PTR _ui$220968[ebp], 0
	jmp	SHORT $LN20@CreateTrad@2
$LN19@CreateTrad@2:
	mov	ecx, DWORD PTR _ui$220968[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$220968[ebp], ecx
$LN20@CreateTrad@2:
	mov	edx, DWORD PTR _ui$220968[ebp]
	cmp	edx, DWORD PTR _nPlots$220965[ebp]
	jae	SHORT $LN18@CreateTrad@2

; 3354 : 			{
; 3355 : 				plotsX[ui] = pTrade->m_aTradeConnections[iRouteIndex].m_aPlotList[ui].m_iX;

	mov	eax, DWORD PTR _iRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _pTrade$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T232575[ebp], eax
	mov	edx, DWORD PTR $T232575[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _ui$220968[ebp]
	mov	edx, DWORD PTR _ui$220968[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _plotsX$[ebp+ecx*4], eax

; 3356 : 				plotsY[ui] = pTrade->m_aTradeConnections[iRouteIndex].m_aPlotList[ui].m_iY;

	mov	ecx, DWORD PTR _iRouteIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _pTrade$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T232582[ebp], ecx
	mov	eax, DWORD PTR $T232582[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _ui$220968[ebp]
	mov	eax, DWORD PTR _ui$220968[ebp]
	mov	ecx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _plotsY$[ebp+edx*4], ecx

; 3357 : 			}

	jmp	$LN19@CreateTrad@2
$LN18@CreateTrad@2:

; 3358 : 			gDLL->TradeVisuals_NewRoute(iRouteIndex, m_pPlayer->GetID(),pTrade->m_aTradeConnections[iRouteIndex].m_eConnectionType, nPlots, plotsX, plotsY);

	mov	edx, DWORD PTR $T232589[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _iRouteIndex$[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _pTrade$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T232593[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232602[ebp], edx
	lea	eax, DWORD PTR _plotsY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _plotsX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nPlots$220965[ebp]
	push	edx
	mov	eax, DWORD PTR $T232593[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR $T232602[ebp]
	push	edx
	mov	eax, DWORD PTR _iRouteIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx+972]
	call	eax

; 3359 : 			gDLL->TradeVisuals_UpdateRouteDirection(iRouteIndex, pTrade->m_aTradeConnections[iRouteIndex].m_bTradeUnitMovingForward);

	mov	ecx, DWORD PTR $T232606[ebp]
	mov	DWORD PTR tv200[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv200[ebp], edx
	mov	eax, DWORD PTR _iRouteIndex$[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _pTrade$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+eax+40]
	push	eax
	mov	ecx, DWORD PTR _iRouteIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv200[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv200[ebp]
	mov	edx, DWORD PTR [eax+976]
	call	edx
$LN23@CreateTrad@2:

; 3360 : 		}
; 3361 : 	}
; 3362 : 
; 3363 : 	if (m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	$LN17@CreateTrad@2
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232613[ebp], edx
	mov	ecx, DWORD PTR $T232613[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	eax, al
	test	eax, eax
	jne	$LN17@CreateTrad@2

; 3364 : 	{
; 3365 : 		bool bConnectedToArabs = false;

	mov	BYTE PTR _bConnectedToArabs$220974[ebp], 0

; 3366 : 		bool bConnectedToPersia = false;

	mov	BYTE PTR _bConnectedToPersia$220975[ebp], 0

; 3367 : 		bool bConnectedToMongols = false;

	mov	BYTE PTR _bConnectedToMongols$220976[ebp], 0

; 3368 : 		bool bConnectedToChina = false;

	mov	BYTE PTR _bConnectedToChina$220977[ebp], 0

; 3369 : 		bool bConnectedToIndia = false;

	mov	BYTE PTR _bConnectedToIndia$220978[ebp], 0

; 3370 : 
; 3371 : #ifdef AUI_ITERATORIZE
; 3372 : 		for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3373 : 		{
; 3374 : 			if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3375 : #else
; 3376 : 		CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232617[ebp], ecx
	mov	ecx, DWORD PTR $T232617[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pGameTrade$220979[ebp], eax

; 3377 : 		for (uint ui = 0; ui < pGameTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$220980[ebp], 0
	jmp	SHORT $LN16@CreateTrad@2
$LN15@CreateTrad@2:
	mov	edx, DWORD PTR _ui$220980[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$220980[ebp], edx
$LN16@CreateTrad@2:
	mov	eax, DWORD PTR _pGameTrade$220979[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232621[ebp], ecx
	mov	edx, DWORD PTR _ui$220980[ebp]
	cmp	edx, DWORD PTR $T232621[ebp]
	jae	$LN14@CreateTrad@2

; 3378 : 		{
; 3379 : 			if (pGameTrade->IsTradeRouteIndexEmpty(ui))

	mov	eax, DWORD PTR _ui$220980[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGameTrade$220979[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@CreateTrad@2

; 3380 : #endif
; 3381 : 			{
; 3382 : 				continue;

	jmp	SHORT $LN15@CreateTrad@2
$LN13@CreateTrad@2:

; 3383 : 			}
; 3384 : 
; 3385 : #ifdef AUI_ITERATORIZE
; 3386 : 			TradeConnection kConnection = *pConnection;
; 3387 : #else
; 3388 : 			TradeConnection kConnection = pGameTrade->m_aTradeConnections[ui];

	mov	edx, DWORD PTR _ui$220980[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pGameTrade$220979[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T232625[ebp], edx
	mov	ecx, DWORD PTR $T232625[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kConnection$220985[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3389 : #endif
; 3390 : 			if (kConnection.m_eOriginOwner != m_pPlayer->GetID())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+79104]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232636[ebp], ecx
	mov	edx, DWORD PTR _kConnection$220985[ebp+20]
	cmp	edx, DWORD PTR $T232636[ebp]
	je	SHORT $LN12@CreateTrad@2

; 3391 : 			{
; 3392 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kConnection$220985[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN15@CreateTrad@2
$LN12@CreateTrad@2:

; 3393 : 			}
; 3394 : 
; 3395 : 			if (kConnection.m_eDomain != DOMAIN_LAND)

	cmp	DWORD PTR _kConnection$220985[ebp+28], 2
	je	SHORT $LN11@CreateTrad@2

; 3396 : 			{
; 3397 : 				continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kConnection$220985[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN15@CreateTrad@2
$LN11@CreateTrad@2:

; 3398 : 			}
; 3399 : 
; 3400 : 			if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_ARABIA") == 0)

	mov	eax, DWORD PTR _kConnection$220985[ebp+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232672[ebp], eax
	mov	DWORD PTR tv548[ebp], OFFSET ??_C@_0BE@PJGCEEDJ@CIVILIZATION_ARABIA?$AA@
	mov	ecx, DWORD PTR $T232672[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR tv547[ebp], eax
$LL123@CreateTrad@2:
	mov	ecx, DWORD PTR tv547[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv551[ebp], dl
	mov	eax, DWORD PTR tv548[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN124@CreateTrad@2
	cmp	BYTE PTR tv551[ebp], 0
	je	SHORT $LN125@CreateTrad@2
	mov	ecx, DWORD PTR tv547[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv558[ebp], dl
	mov	eax, DWORD PTR tv548[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN124@CreateTrad@2
	add	DWORD PTR tv547[ebp], 2
	add	DWORD PTR tv548[ebp], 2
	cmp	BYTE PTR tv558[ebp], 0
	jne	SHORT $LL123@CreateTrad@2
$LN125@CreateTrad@2:
	mov	DWORD PTR tv563[ebp], 0
	jmp	SHORT $LN126@CreateTrad@2
$LN124@CreateTrad@2:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv563[ebp], ecx
$LN126@CreateTrad@2:
	mov	edx, DWORD PTR tv563[ebp]
	mov	DWORD PTR tv268[ebp], edx
	cmp	DWORD PTR tv268[ebp], 0
	jne	SHORT $LN10@CreateTrad@2

; 3401 : 			{
; 3402 : 				bConnectedToArabs = true;

	mov	BYTE PTR _bConnectedToArabs$220974[ebp], 1
	jmp	$LN9@CreateTrad@2
$LN10@CreateTrad@2:

; 3403 : 			}
; 3404 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_PERSIA") == 0)

	mov	eax, DWORD PTR _kConnection$220985[ebp+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232676[ebp], eax
	mov	DWORD PTR tv571[ebp], OFFSET ??_C@_0BE@OJPNDMMI@CIVILIZATION_PERSIA?$AA@
	mov	ecx, DWORD PTR $T232676[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR tv570[ebp], eax
$LL127@CreateTrad@2:
	mov	ecx, DWORD PTR tv570[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv574[ebp], dl
	mov	eax, DWORD PTR tv571[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN128@CreateTrad@2
	cmp	BYTE PTR tv574[ebp], 0
	je	SHORT $LN129@CreateTrad@2
	mov	ecx, DWORD PTR tv570[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv581[ebp], dl
	mov	eax, DWORD PTR tv571[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN128@CreateTrad@2
	add	DWORD PTR tv570[ebp], 2
	add	DWORD PTR tv571[ebp], 2
	cmp	BYTE PTR tv581[ebp], 0
	jne	SHORT $LL127@CreateTrad@2
$LN129@CreateTrad@2:
	mov	DWORD PTR tv586[ebp], 0
	jmp	SHORT $LN130@CreateTrad@2
$LN128@CreateTrad@2:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv586[ebp], ecx
$LN130@CreateTrad@2:
	mov	edx, DWORD PTR tv586[ebp]
	mov	DWORD PTR tv281[ebp], edx
	cmp	DWORD PTR tv281[ebp], 0
	jne	SHORT $LN8@CreateTrad@2

; 3405 : 			{
; 3406 : 				bConnectedToPersia = true;

	mov	BYTE PTR _bConnectedToPersia$220975[ebp], 1
	jmp	$LN9@CreateTrad@2
$LN8@CreateTrad@2:

; 3407 : 			}
; 3408 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_MONGOL") == 0)

	mov	eax, DWORD PTR _kConnection$220985[ebp+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232680[ebp], eax
	mov	DWORD PTR tv594[ebp], OFFSET ??_C@_0BE@IFCHFKBE@CIVILIZATION_MONGOL?$AA@
	mov	ecx, DWORD PTR $T232680[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR tv593[ebp], eax
$LL131@CreateTrad@2:
	mov	ecx, DWORD PTR tv593[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv597[ebp], dl
	mov	eax, DWORD PTR tv594[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN132@CreateTrad@2
	cmp	BYTE PTR tv597[ebp], 0
	je	SHORT $LN133@CreateTrad@2
	mov	ecx, DWORD PTR tv593[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv604[ebp], dl
	mov	eax, DWORD PTR tv594[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN132@CreateTrad@2
	add	DWORD PTR tv593[ebp], 2
	add	DWORD PTR tv594[ebp], 2
	cmp	BYTE PTR tv604[ebp], 0
	jne	SHORT $LL131@CreateTrad@2
$LN133@CreateTrad@2:
	mov	DWORD PTR tv609[ebp], 0
	jmp	SHORT $LN134@CreateTrad@2
$LN132@CreateTrad@2:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv609[ebp], ecx
$LN134@CreateTrad@2:
	mov	edx, DWORD PTR tv609[ebp]
	mov	DWORD PTR tv294[ebp], edx
	cmp	DWORD PTR tv294[ebp], 0
	jne	SHORT $LN6@CreateTrad@2

; 3409 : 			{
; 3410 : 				bConnectedToMongols = true;

	mov	BYTE PTR _bConnectedToMongols$220976[ebp], 1
	jmp	$LN9@CreateTrad@2
$LN6@CreateTrad@2:

; 3411 : 			}
; 3412 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_CHINA") == 0)

	mov	eax, DWORD PTR _kConnection$220985[ebp+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232684[ebp], eax
	mov	DWORD PTR tv617[ebp], OFFSET ??_C@_0BD@LJKPFCDB@CIVILIZATION_CHINA?$AA@
	mov	ecx, DWORD PTR $T232684[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR tv616[ebp], eax
$LL135@CreateTrad@2:
	mov	ecx, DWORD PTR tv616[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv620[ebp], dl
	mov	eax, DWORD PTR tv617[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN136@CreateTrad@2
	cmp	BYTE PTR tv620[ebp], 0
	je	SHORT $LN137@CreateTrad@2
	mov	ecx, DWORD PTR tv616[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv627[ebp], dl
	mov	eax, DWORD PTR tv617[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN136@CreateTrad@2
	add	DWORD PTR tv616[ebp], 2
	add	DWORD PTR tv617[ebp], 2
	cmp	BYTE PTR tv627[ebp], 0
	jne	SHORT $LL135@CreateTrad@2
$LN137@CreateTrad@2:
	mov	DWORD PTR tv632[ebp], 0
	jmp	SHORT $LN138@CreateTrad@2
$LN136@CreateTrad@2:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv632[ebp], ecx
$LN138@CreateTrad@2:
	mov	edx, DWORD PTR tv632[ebp]
	mov	DWORD PTR tv307[ebp], edx
	cmp	DWORD PTR tv307[ebp], 0
	jne	SHORT $LN4@CreateTrad@2

; 3413 : 			{
; 3414 : 				bConnectedToChina = true;

	mov	BYTE PTR _bConnectedToChina$220977[ebp], 1
	jmp	$LN9@CreateTrad@2
$LN4@CreateTrad@2:

; 3415 : 			}
; 3416 : 			else if (strcmp(GET_PLAYER(kConnection.m_eDestOwner).getCivilizationTypeKey(), "CIVILIZATION_INDIA") == 0)

	mov	eax, DWORD PTR _kConnection$220985[ebp+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232688[ebp], eax
	mov	DWORD PTR tv640[ebp], OFFSET ??_C@_0BD@GAFBEKKP@CIVILIZATION_INDIA?$AA@
	mov	ecx, DWORD PTR $T232688[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR tv639[ebp], eax
$LL139@CreateTrad@2:
	mov	ecx, DWORD PTR tv639[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv643[ebp], dl
	mov	eax, DWORD PTR tv640[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN140@CreateTrad@2
	cmp	BYTE PTR tv643[ebp], 0
	je	SHORT $LN141@CreateTrad@2
	mov	ecx, DWORD PTR tv639[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv650[ebp], dl
	mov	eax, DWORD PTR tv640[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN140@CreateTrad@2
	add	DWORD PTR tv639[ebp], 2
	add	DWORD PTR tv640[ebp], 2
	cmp	BYTE PTR tv650[ebp], 0
	jne	SHORT $LL139@CreateTrad@2
$LN141@CreateTrad@2:
	mov	DWORD PTR tv655[ebp], 0
	jmp	SHORT $LN142@CreateTrad@2
$LN140@CreateTrad@2:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv655[ebp], ecx
$LN142@CreateTrad@2:
	mov	edx, DWORD PTR tv655[ebp]
	mov	DWORD PTR tv320[ebp], edx
	cmp	DWORD PTR tv320[ebp], 0
	jne	SHORT $LN9@CreateTrad@2

; 3417 : 			{
; 3418 : 				bConnectedToIndia = true;

	mov	BYTE PTR _bConnectedToIndia$220978[ebp], 1
$LN9@CreateTrad@2:

; 3419 : 			}
; 3420 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kConnection$220985[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN15@CreateTrad@2
$LN14@CreateTrad@2:

; 3421 : 
; 3422 : 		if (bConnectedToArabs && bConnectedToPersia && bConnectedToMongols && bConnectedToChina && bConnectedToIndia)

	movzx	eax, BYTE PTR _bConnectedToArabs$220974[ebp]
	test	eax, eax
	je	SHORT $LN17@CreateTrad@2
	movzx	ecx, BYTE PTR _bConnectedToPersia$220975[ebp]
	test	ecx, ecx
	je	SHORT $LN17@CreateTrad@2
	movzx	edx, BYTE PTR _bConnectedToMongols$220976[ebp]
	test	edx, edx
	je	SHORT $LN17@CreateTrad@2
	movzx	eax, BYTE PTR _bConnectedToChina$220977[ebp]
	test	eax, eax
	je	SHORT $LN17@CreateTrad@2
	movzx	ecx, BYTE PTR _bConnectedToIndia$220978[ebp]
	test	ecx, ecx
	je	SHORT $LN17@CreateTrad@2

; 3423 : 		{
; 3424 : 			gDLL->UnlockAchievement(ACHIEVEMENT_XP2_29);

	mov	edx, DWORD PTR $T232723[ebp]
	mov	DWORD PTR tv339[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv339[ebp], eax
	push	271					; 0000010fH
	mov	ecx, DWORD PTR tv339[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv339[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN17@CreateTrad@2:

; 3425 : 		}
; 3426 : 	}
; 3427 : 
; 3428 : 	return true;

	mov	al, 1
$LN25@CreateTrad@2:

; 3429 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z$0:
	lea	ecx, DWORD PTR _kConnection$220985[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__ehhandler$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2780]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-2100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ENDP ; CvPlayerTrade::CreateTradeRoute
PUBLIC	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Odtp
;	COMDAT ??0TradeConnection@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
___that$ = 8						; size = 4
??0TradeConnection@@QAE@ABU0@@Z PROC			; TradeConnection::TradeConnection, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+40]
	mov	BYTE PTR [eax+40], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+380]
	mov	DWORD PTR [ecx+380], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+384]
	mov	DWORD PTR [ecx+384], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR [ecx+388], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	DWORD PTR [ecx+392], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 396				; 0000018cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 396				; 0000018cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 420				; 000001a4H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 420				; 000001a4H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0TradeConnection@@QAE@ABU0@@Z ENDP			; TradeConnection::TradeConnection
_TEXT	ENDS
PUBLIC	?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z ; CvPlayerTrade::GetTradeConnection
; Function compile flags: /Odtp
;	COMDAT ?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T232825 = -40						; size = 4
$T232813 = -36						; size = 4
$T232809 = -32						; size = 4
_pConnection$221020 = -28				; size = 4
_ui$221016 = -24					; size = 4
_iDestX$ = -20						; size = 4
_iOriginY$ = -16					; size = 4
_iOriginX$ = -12					; size = 4
_iDestY$ = -8						; size = 4
_pTrade$ = -4						; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z PROC ; CvPlayerTrade::GetTradeConnection, COMDAT
; _this$ = ecx

; 3437 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 3438 : 	int iOriginX = pOriginCity->getX();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iOriginX$[ebp], ecx

; 3439 : 	int iOriginY = pOriginCity->getY();

	mov	edx, DWORD PTR _pOriginCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iOriginY$[ebp], eax

; 3440 : 	int iDestX = pDestCity->getX();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _iDestX$[ebp], edx

; 3441 : 	int iDestY = pDestCity->getY();

	mov	eax, DWORD PTR _pDestCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iDestY$[ebp], ecx

; 3442 : 
; 3443 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232809[ebp], edx
	mov	ecx, DWORD PTR $T232809[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3444 : #ifdef AUI_ITERATORIZE
; 3445 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3446 : 	{
; 3447 : #else
; 3448 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$221016[ebp], 0
	jmp	SHORT $LN5@GetTradeCo@12
$LN4@GetTradeCo@12:
	mov	eax, DWORD PTR _ui$221016[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$221016[ebp], eax
$LN5@GetTradeCo@12:
	mov	ecx, DWORD PTR _pTrade$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T232813[ebp], edx
	mov	eax, DWORD PTR _ui$221016[ebp]
	cmp	eax, DWORD PTR $T232813[ebp]
	jae	SHORT $LN3@GetTradeCo@12

; 3449 : 	{
; 3450 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	ecx, DWORD PTR _ui$221016[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _pTrade$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _pConnection$221020[ebp], ecx

; 3451 : #endif
; 3452 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232825[ebp], edx
	mov	eax, DWORD PTR _pConnection$221020[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR $T232825[ebp]
	jne	SHORT $LN2@GetTradeCo@12

; 3453 : 		{
; 3454 : 			if (pConnection->m_iOriginX == iOriginX && pConnection->m_iOriginY == iOriginY && pConnection->m_iDestX == iDestX && pConnection->m_iDestY == iDestY)

	mov	edx, DWORD PTR _pConnection$221020[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _iOriginX$[ebp]
	jne	SHORT $LN2@GetTradeCo@12
	mov	ecx, DWORD PTR _pConnection$221020[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _iOriginY$[ebp]
	jne	SHORT $LN2@GetTradeCo@12
	mov	eax, DWORD PTR _pConnection$221020[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _iDestX$[ebp]
	jne	SHORT $LN2@GetTradeCo@12
	mov	edx, DWORD PTR _pConnection$221020[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _iDestY$[ebp]
	jne	SHORT $LN2@GetTradeCo@12

; 3455 : 			{
; 3456 : 				return pConnection;

	mov	eax, DWORD PTR _pConnection$221020[ebp]
	jmp	SHORT $LN6@GetTradeCo@12
$LN2@GetTradeCo@12:

; 3457 : 			}
; 3458 : 		}
; 3459 : 	}

	jmp	SHORT $LN4@GetTradeCo@12
$LN3@GetTradeCo@12:

; 3460 : 
; 3461 : 	return NULL;

	xor	eax, eax
$LN6@GetTradeCo@12:

; 3462 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTradeConnection@CvPlayerTrade@@QAEPAUTradeConnection@@PAVCvCity@@0@Z ENDP ; CvPlayerTrade::GetTradeConnection
_TEXT	ENDS
PUBLIC	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
; Function compile flags: /Odtp
;	COMDAT ?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T232851 = -32						; size = 4
$T232847 = -28						; size = 4
$T232835 = -24						; size = 4
$T232831 = -20						; size = 4
_pConnection$221032 = -16				; size = 4
_ui$221028 = -12					; size = 4
_iNumConnections$ = -8					; size = 4
_pTrade$ = -4						; size = 4
?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ PROC ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes, COMDAT
; _this$ = ecx

; 3470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3471 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232831[ebp], eax
	mov	ecx, DWORD PTR $T232831[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3472 : 	int iNumConnections = 0;

	mov	DWORD PTR _iNumConnections$[ebp], 0

; 3473 : #ifdef AUI_ITERATORIZE
; 3474 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3475 : 	{
; 3476 : #else
; 3477 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$221028[ebp], 0
	jmp	SHORT $LN5@GetNumberO
$LN4@GetNumberO:
	mov	ecx, DWORD PTR _ui$221028[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$221028[ebp], ecx
$LN5@GetNumberO:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232835[ebp], eax
	mov	ecx, DWORD PTR _ui$221028[ebp]
	cmp	ecx, DWORD PTR $T232835[ebp]
	jae	SHORT $LN3@GetNumberO

; 3478 : 	{
; 3479 : #ifdef AUI_CONSTIFY
; 3480 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);
; 3481 : #else
; 3482 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[ui]);

	mov	edx, DWORD PTR _ui$221028[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pConnection$221032[ebp], edx

; 3483 : #endif
; 3484 : #endif
; 3485 : 
; 3486 : 		if (pConnection->m_eOriginOwner == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T232847[ebp], eax
	mov	ecx, DWORD PTR _pConnection$221032[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR $T232847[ebp]
	jne	SHORT $LN2@GetNumberO

; 3487 : 		{
; 3488 : 			if(GET_PLAYER(pConnection->m_eDestOwner).isMinorCiv())

	mov	eax, DWORD PTR _pConnection$221032[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232851[ebp], ecx
	mov	ecx, DWORD PTR $T232851[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetNumberO

; 3489 : 			{
; 3490 : 				iNumConnections++;

	mov	eax, DWORD PTR _iNumConnections$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumConnections$[ebp], eax
$LN2@GetNumberO:

; 3491 : 			}
; 3492 : 		}
; 3493 : 	}

	jmp	SHORT $LN4@GetNumberO
$LN3@GetNumberO:

; 3494 : 
; 3495 : 	return iNumConnections;

	mov	eax, DWORD PTR _iNumConnections$[ebp]

; 3496 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ENDP ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
_TEXT	ENDS
PUBLIC	?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ; CvPlayerTrade::IsPreviousTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T232889 = -24						; size = 4
_ui$221046 = -20					; size = 4
_iOriginCityX$ = -16					; size = 4
_iDestCityX$ = -12					; size = 4
_iOriginCityY$ = -8					; size = 4
_iDestCityY$ = -4					; size = 4
_pOriginCity$ = 8					; size = 4
_pDestCity$ = 12					; size = 4
_eDomain$ = 16						; size = 4
_eConnectionType$ = 20					; size = 4
?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z PROC ; CvPlayerTrade::IsPreviousTradeRoute, COMDAT
; _this$ = ecx

; 3504 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 3505 : 	int iOriginCityX = pOriginCity->getX();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iOriginCityX$[ebp], ecx

; 3506 : 	int iOriginCityY = pOriginCity->getY();

	mov	edx, DWORD PTR _pOriginCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iOriginCityY$[ebp], eax

; 3507 : 	int iDestCityX = pDestCity->getX();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _iDestCityX$[ebp], edx

; 3508 : 	int iDestCityY = pDestCity->getY();

	mov	eax, DWORD PTR _pDestCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR _iDestCityY$[ebp], ecx

; 3509 : 
; 3510 : #ifdef AUI_ITERATORIZE
; 3511 : 	for (TradeConnectionList::const_iterator it = m_aRecentlyExpiredConnections.begin(); it != m_aRecentlyExpiredConnections.end(); ++it)
; 3512 : 	{
; 3513 : 		if (it->m_iOriginX == iOriginCityX &&
; 3514 : 			it->m_iOriginY == iOriginCityY &&
; 3515 : 			it->m_iDestX == iDestCityX &&
; 3516 : 			it->m_iDestY == iDestCityY &&
; 3517 : 			it->m_eDomain == eDomain &&
; 3518 : 			it->m_eConnectionType == eConnectionType)
; 3519 : #else
; 3520 : 	for (uint ui = 0; ui < m_aRecentlyExpiredConnections.size(); ui++)

	mov	DWORD PTR _ui$221046[ebp], 0
	jmp	SHORT $LN4@IsPrevious
$LN3@IsPrevious:
	mov	edx, DWORD PTR _ui$221046[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$221046[ebp], edx
$LN4@IsPrevious:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232889[ebp], ecx
	mov	edx, DWORD PTR _ui$221046[ebp]
	cmp	edx, DWORD PTR $T232889[ebp]
	jae	$LN2@IsPrevious

; 3521 : 	{
; 3522 : 		if (m_aRecentlyExpiredConnections[ui].m_iOriginX == iOriginCityX &&
; 3523 : 			m_aRecentlyExpiredConnections[ui].m_iOriginY == iOriginCityY &&
; 3524 : 			m_aRecentlyExpiredConnections[ui].m_iDestX == iDestCityX &&
; 3525 : 			m_aRecentlyExpiredConnections[ui].m_iDestY == iDestCityY &&
; 3526 : 			m_aRecentlyExpiredConnections[ui].m_eDomain == eDomain &&
; 3527 : 			m_aRecentlyExpiredConnections[ui].m_eConnectionType == eConnectionType) 

	mov	eax, DWORD PTR _ui$221046[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+4]
	cmp	eax, DWORD PTR _iOriginCityX$[ebp]
	jne	SHORT $LN1@IsPrevious
	mov	ecx, DWORD PTR _ui$221046[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+8]
	cmp	ecx, DWORD PTR _iOriginCityY$[ebp]
	jne	SHORT $LN1@IsPrevious
	mov	edx, DWORD PTR _ui$221046[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+12]
	cmp	edx, DWORD PTR _iDestCityX$[ebp]
	jne	SHORT $LN1@IsPrevious
	mov	eax, DWORD PTR _ui$221046[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+16]
	cmp	eax, DWORD PTR _iDestCityY$[ebp]
	jne	SHORT $LN1@IsPrevious
	mov	ecx, DWORD PTR _ui$221046[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+28]
	cmp	ecx, DWORD PTR _eDomain$[ebp]
	jne	SHORT $LN1@IsPrevious
	mov	edx, DWORD PTR _ui$221046[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+32]
	cmp	edx, DWORD PTR _eConnectionType$[ebp]
	jne	SHORT $LN1@IsPrevious

; 3528 : #endif
; 3529 : 		{
; 3530 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@IsPrevious
$LN1@IsPrevious:

; 3531 : 		}
; 3532 : 	}

	jmp	$LN3@IsPrevious
$LN2@IsPrevious:

; 3533 : 
; 3534 : 	return false;

	xor	al, al
$LN5@IsPrevious:

; 3535 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?IsPreviousTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@@Z ENDP ; CvPlayerTrade::IsPreviousTradeRoute
_TEXT	ENDS
PUBLIC	?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ; CvPlayerTrade::GetNumPotentialConnections
; Function compile flags: /Odtp
;	COMDAT ?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T232938 = -60						; size = 4
$T232934 = -56						; size = 4
$T232930 = -52						; size = 4
$T232926 = -45						; size = 1
$T232917 = -44						; size = 4
$T232913 = -40						; size = 4
_bTradeAvailable$221079 = -33				; size = 1
_uiConnectionTypes$221072 = -32				; size = 4
_bCheckPath$221071 = -25				; size = 1
_ePlayer$221062 = -24					; size = 4
_pLoopCity$221067 = -20					; size = 4
_iLoop$221066 = -16					; size = 4
_ui$221058 = -12					; size = 4
_pGameTrade$ = -8					; size = 4
_iNumValid$ = -4					; size = 4
_pFromCity$ = 8						; size = 4
_eDomain$ = 12						; size = 4
?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z PROC ; CvPlayerTrade::GetNumPotentialConnections, COMDAT
; _this$ = ecx

; 3543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 3544 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232913[ebp], eax
	mov	ecx, DWORD PTR $T232913[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pGameTrade$[ebp], eax

; 3545 : 
; 3546 : 	int iNumValid = 0;

	mov	DWORD PTR _iNumValid$[ebp], 0

; 3547 : 	for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	mov	DWORD PTR _ui$221058[ebp], 0
	jmp	SHORT $LN14@GetNumPote
$LN13@GetNumPote:
	mov	ecx, DWORD PTR _ui$221058[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$221058[ebp], ecx
$LN14@GetNumPote:
	cmp	DWORD PTR _ui$221058[ebp], 63		; 0000003fH
	jae	$LN12@GetNumPote

; 3548 : 	{
; 3549 : 		PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	edx, DWORD PTR _ui$221058[ebp]
	mov	DWORD PTR _ePlayer$221062[ebp], edx

; 3550 : 
; 3551 : 		if (!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR _ePlayer$221062[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232917[ebp], eax
	mov	ecx, DWORD PTR $T232917[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232926[ebp], dl
	movzx	eax, BYTE PTR $T232926[ebp]
	test	eax, eax
	jne	SHORT $LN11@GetNumPote

; 3552 : 		{
; 3553 : 			continue;

	jmp	SHORT $LN13@GetNumPote
$LN11@GetNumPote:

; 3554 : 		}
; 3555 : 
; 3556 : 		if (GET_PLAYER(ePlayer).isBarbarian())

	mov	ecx, DWORD PTR _ePlayer$221062[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232930[ebp], ecx
	mov	ecx, DWORD PTR $T232930[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@GetNumPote

; 3557 : 		{
; 3558 : 			continue;

	jmp	SHORT $LN13@GetNumPote
$LN10@GetNumPote:

; 3559 : 		}
; 3560 : 
; 3561 : 		int iLoop;
; 3562 : 		CvCity* pLoopCity;
; 3563 : 		for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iLoop))

	mov	eax, DWORD PTR _ePlayer$221062[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232934[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$221066[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232934[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$221067[ebp], eax
	jmp	SHORT $LN9@GetNumPote
$LN8@GetNumPote:
	mov	edx, DWORD PTR _ePlayer$221062[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232938[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$221066[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232938[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$221067[ebp], eax
$LN9@GetNumPote:
	cmp	DWORD PTR _pLoopCity$221067[ebp], 0
	je	SHORT $LN7@GetNumPote

; 3564 : 		{
; 3565 : 			bool bCheckPath = true;

	mov	BYTE PTR _bCheckPath$221071[ebp], 1

; 3566 : 			for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	mov	DWORD PTR _uiConnectionTypes$221072[ebp], 0
	jmp	SHORT $LN6@GetNumPote
$LN5@GetNumPote:
	mov	ecx, DWORD PTR _uiConnectionTypes$221072[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiConnectionTypes$221072[ebp], ecx
$LN6@GetNumPote:
	cmp	DWORD PTR _uiConnectionTypes$221072[ebp], 3
	jae	SHORT $LN4@GetNumPote

; 3567 : 			{
; 3568 : 				// Check the trade route, ignoring the path for now
; 3569 : 				if (CanCreateTradeRoute(pFromCity, pLoopCity, eDomain, (TradeConnectionType)uiConnectionTypes, false, false))

	push	0
	push	0
	mov	edx, DWORD PTR _uiConnectionTypes$221072[ebp]
	push	edx
	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$221067[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetNumPote

; 3570 : 				{
; 3571 : 					// Now test the path
; 3572 : 					if (bCheckPath)

	movzx	ecx, BYTE PTR _bCheckPath$221071[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetNumPote

; 3573 : 					{
; 3574 : 						bool bTradeAvailable = pGameTrade->IsValidTradeRoutePath(pFromCity, pLoopCity, eDomain);

	mov	edx, DWORD PTR _eDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopCity$221067[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pGameTrade$[ebp]
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	mov	BYTE PTR _bTradeAvailable$221079[ebp], al

; 3575 : 						if (!bTradeAvailable)

	movzx	edx, BYTE PTR _bTradeAvailable$221079[ebp]
	test	edx, edx
	jne	SHORT $LN1@GetNumPote

; 3576 : 							break;		// If there is no path for this domain, just skip the rest of the connection tests.

	jmp	SHORT $LN4@GetNumPote
$LN1@GetNumPote:

; 3577 : 
; 3578 : 						bCheckPath = false;		// No need to check the path for this domain again

	mov	BYTE PTR _bCheckPath$221071[ebp], 0
$LN2@GetNumPote:

; 3579 : 					}
; 3580 : 
; 3581 : 					iNumValid++;

	mov	eax, DWORD PTR _iNumValid$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumValid$[ebp], eax
$LN3@GetNumPote:

; 3582 : 				}
; 3583 : 			}

	jmp	SHORT $LN5@GetNumPote
$LN4@GetNumPote:

; 3584 : 		}

	jmp	$LN8@GetNumPote
$LN7@GetNumPote:

; 3585 : 	}

	jmp	$LN13@GetNumPote
$LN12@GetNumPote:

; 3586 : 
; 3587 : 	return iNumValid;

	mov	eax, DWORD PTR _iNumValid$[ebp]

; 3588 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNumPotentialConnections@CvPlayerTrade@@QAEHPAVCvCity@@W4DomainTypes@@@Z ENDP ; CvPlayerTrade::GetNumPotentialConnections
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradeUnitsAtPlot
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$5
__ehfuncinfo$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
_TEXT	SEGMENT
_this$ = -192						; size = 4
$T233010 = -92						; size = 4
$T232998 = -88						; size = 4
$T232991 = -84						; size = 4
$T232987 = -80						; size = 4
$T232983 = -76						; size = 4
$T232943 = -64						; size = 4
_pConnection$221107 = -60				; size = 4
_eOtherTeam$221109 = -56				; size = 4
_bIgnore$221110 = -49					; size = 1
_uiConnection$221103 = -48				; size = 4
_iX$ = -44						; size = 4
_eMyTeam$ = -40						; size = 4
_aiTradeConnectionIDs$ = -36				; size = 16
_pTrade$ = -20						; size = 4
_iY$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
_bExcludingMe$ = 20					; size = 1
_bOnlyWar$ = 24						; size = 1
?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z PROC ; CvPlayerTrade::GetTradeUnitsAtPlot, COMDAT
; _this$ = ecx

; 3596 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T232943[ebp], 0

; 3597 : 	std::vector<int> aiTradeConnectionIDs;

	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3598 : 
; 3599 : 	if (pPlot == NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN29@GetTradeUn

; 3600 : 	{
; 3601 : 		return aiTradeConnectionIDs;

	lea	eax, DWORD PTR _aiTradeConnectionIDs$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	ecx, DWORD PTR $T232943[ebp]
	or	ecx, 1
	mov	DWORD PTR $T232943[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@GetTradeUn

; 3602 : 	}
; 3603 : 
; 3604 : 	int iX = pPlot->getX();

$LN29@GetTradeUn:
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _iX$[ebp], eax

; 3605 : 	int iY = pPlot->getY();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _iY$[ebp], edx

; 3606 : 
; 3607 : 	TeamTypes eMyTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	DWORD PTR $T232983[ebp], ecx
	mov	edx, DWORD PTR $T232983[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMyTeam$[ebp], eax

; 3608 : 
; 3609 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232987[ebp], ecx
	mov	ecx, DWORD PTR $T232987[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3610 : #ifdef AUI_ITERATORIZE
; 3611 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3612 : 	{
; 3613 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3614 : #else
; 3615 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	DWORD PTR _uiConnection$221103[ebp], 0
	jmp	SHORT $LN9@GetTradeUn
$LN8@GetTradeUn:
	mov	edx, DWORD PTR _uiConnection$221103[ebp]
	add	edx, 1
	mov	DWORD PTR _uiConnection$221103[ebp], edx
$LN9@GetTradeUn:
	mov	eax, DWORD PTR _pTrade$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232991[ebp], ecx
	mov	edx, DWORD PTR _uiConnection$221103[ebp]
	cmp	edx, DWORD PTR $T232991[ebp]
	jae	$LN7@GetTradeUn

; 3616 : 	{
; 3617 : #ifdef AUI_CONSTIFY
; 3618 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);
; 3619 : #else
; 3620 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);

	mov	eax, DWORD PTR _uiConnection$221103[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _pTrade$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pConnection$221107[ebp], eax

; 3621 : #endif
; 3622 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	mov	edx, DWORD PTR _uiConnection$221103[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@GetTradeUn

; 3623 : #endif
; 3624 : 		{
; 3625 : 			continue;

	jmp	SHORT $LN8@GetTradeUn
$LN6@GetTradeUn:

; 3626 : 		}
; 3627 : 
; 3628 : 		TeamTypes eOtherTeam = GET_PLAYER(pConnection->m_eOriginOwner).getTeam();

	mov	ecx, DWORD PTR _pConnection$221107[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232998[ebp], edx
	mov	eax, DWORD PTR $T232998[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOtherTeam$221109[ebp], eax

; 3629 : 
; 3630 : 		bool bIgnore = false;

	mov	BYTE PTR _bIgnore$221110[ebp], 0

; 3631 : 		if (bExcludingMe && eOtherTeam == eMyTeam)

	movzx	edx, BYTE PTR _bExcludingMe$[ebp]
	test	edx, edx
	je	SHORT $LN5@GetTradeUn
	mov	eax, DWORD PTR _eOtherTeam$221109[ebp]
	cmp	eax, DWORD PTR _eMyTeam$[ebp]
	jne	SHORT $LN5@GetTradeUn

; 3632 : 		{
; 3633 : 			bIgnore = true;

	mov	BYTE PTR _bIgnore$221110[ebp], 1
$LN5@GetTradeUn:

; 3634 : 		}
; 3635 : 
; 3636 : 		if (bOnlyWar && !GET_TEAM(eMyTeam).isAtWar(eOtherTeam))

	movzx	ecx, BYTE PTR _bOnlyWar$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@GetTradeUn
	mov	edx, DWORD PTR _eMyTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233010[ebp], edx
	mov	eax, DWORD PTR _eOtherTeam$221109[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233010[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@GetTradeUn

; 3637 : 		{
; 3638 : 			bIgnore = true;

	mov	BYTE PTR _bIgnore$221110[ebp], 1
$LN4@GetTradeUn:

; 3639 : 		}
; 3640 : 
; 3641 : 		if (bIgnore)

	movzx	edx, BYTE PTR _bIgnore$221110[ebp]
	test	edx, edx
	je	SHORT $LN51@GetTradeUn

; 3642 : 		{
; 3643 : 			continue;

	jmp	$LN8@GetTradeUn

; 3644 : 		}
; 3645 : 
; 3646 : 		if (pConnection->m_aPlotList[pConnection->m_iTradeUnitLocationIndex].m_iX == iX && pConnection->m_aPlotList[pConnection->m_iTradeUnitLocationIndex].m_iY == iY)

$LN51@GetTradeUn:
	mov	eax, DWORD PTR _pConnection$221107[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _pConnection$221107[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax+ecx*8]
	cmp	ecx, DWORD PTR _iX$[ebp]
	jne	SHORT $LN2@GetTradeUn
	mov	edx, DWORD PTR _pConnection$221107[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _pConnection$221107[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx+eax*8+4]
	cmp	eax, DWORD PTR _iY$[ebp]
	jne	SHORT $LN2@GetTradeUn

; 3647 : 		{
; 3648 : 			aiTradeConnectionIDs.push_back(pConnection->m_iID);

	mov	ecx, DWORD PTR _pConnection$221107[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3649 : 			if (bFailAtFirstFound)

	movzx	edx, BYTE PTR _bFailAtFirstFound$[ebp]
	test	edx, edx
	je	SHORT $LN2@GetTradeUn

; 3650 : 			{
; 3651 : 				break;

	jmp	SHORT $LN7@GetTradeUn
$LN2@GetTradeUn:

; 3652 : 			}
; 3653 : 		}
; 3654 : 	}

	jmp	$LN8@GetTradeUn
$LN7@GetTradeUn:

; 3655 : 
; 3656 : 	return aiTradeConnectionIDs;	

	lea	eax, DWORD PTR _aiTradeConnectionIDs$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	ecx, DWORD PTR $T232943[ebp]
	or	ecx, 1
	mov	DWORD PTR $T232943[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@GetTradeUn:

; 3657 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$1:
	mov	eax, DWORD PTR $T232943[ebp]
	and	eax, 1
	je	$LN15@GetTradeUn
	and	DWORD PTR $T232943[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$LN15@GetTradeUn:
	ret	0
__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$3:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$5:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ENDP ; CvPlayerTrade::GetTradeUnitsAtPlot
PUBLIC	?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradePlotsAtPlot
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$5
__ehfuncinfo$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
_TEXT	SEGMENT
_this$ = -196						; size = 4
$T233295 = -100						; size = 4
$T233291 = -96						; size = 4
$T233279 = -92						; size = 4
$T233272 = -88						; size = 4
$T233268 = -84						; size = 4
$T233264 = -80						; size = 4
$T233224 = -68						; size = 4
_ui$221149 = -64					; size = 4
_pConnection$221142 = -60				; size = 4
_eOtherTeam$221144 = -56				; size = 4
_bIgnore$221145 = -49					; size = 1
_uiConnection$221138 = -48				; size = 4
_iX$ = -44						; size = 4
_eMyTeam$ = -40						; size = 4
_aiTradeConnectionIDs$ = -36				; size = 16
_pTrade$ = -20						; size = 4
_iY$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
_bExcludingMe$ = 20					; size = 1
_bOnlyWar$ = 24						; size = 1
?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z PROC ; CvPlayerTrade::GetTradePlotsAtPlot, COMDAT
; _this$ = ecx

; 3666 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T233224[ebp], 0

; 3667 : 	std::vector<int> aiTradeConnectionIDs;

	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3668 : 
; 3669 : 	if (pPlot == NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN33@GetTradePl

; 3670 : 	{
; 3671 : 		return aiTradeConnectionIDs;

	lea	eax, DWORD PTR _aiTradeConnectionIDs$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	ecx, DWORD PTR $T233224[ebp]
	or	ecx, 1
	mov	DWORD PTR $T233224[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN15@GetTradePl

; 3672 : 	}
; 3673 : 
; 3674 : 	int iX = pPlot->getX();

$LN33@GetTradePl:
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _iX$[ebp], eax

; 3675 : 	int iY = pPlot->getY();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _iY$[ebp], edx

; 3676 : 
; 3677 : 	TeamTypes eMyTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	DWORD PTR $T233264[ebp], ecx
	mov	edx, DWORD PTR $T233264[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMyTeam$[ebp], eax

; 3678 : 
; 3679 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233268[ebp], ecx
	mov	ecx, DWORD PTR $T233268[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3680 : #ifdef AUI_ITERATORIZE
; 3681 : 	for (TradeConnectionList::const_iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 3682 : 	{
; 3683 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 3684 : #else
; 3685 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	DWORD PTR _uiConnection$221138[ebp], 0
	jmp	SHORT $LN13@GetTradePl
$LN12@GetTradePl:
	mov	edx, DWORD PTR _uiConnection$221138[ebp]
	add	edx, 1
	mov	DWORD PTR _uiConnection$221138[ebp], edx
$LN13@GetTradePl:
	mov	eax, DWORD PTR _pTrade$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T233272[ebp], ecx
	mov	edx, DWORD PTR _uiConnection$221138[ebp]
	cmp	edx, DWORD PTR $T233272[ebp]
	jae	$LN11@GetTradePl

; 3686 : 	{
; 3687 : #ifdef AUI_CONSTIFY
; 3688 : 		const TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);
; 3689 : #else
; 3690 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);

	mov	eax, DWORD PTR _uiConnection$221138[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _pTrade$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pConnection$221142[ebp], eax

; 3691 : #endif
; 3692 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	mov	edx, DWORD PTR _uiConnection$221138[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@GetTradePl

; 3693 : #endif
; 3694 : 		{
; 3695 : 			continue;

	jmp	SHORT $LN12@GetTradePl
$LN10@GetTradePl:

; 3696 : 		}
; 3697 : 
; 3698 : 		TeamTypes eOtherTeam = GET_PLAYER(pConnection->m_eOriginOwner).getTeam();

	mov	ecx, DWORD PTR _pConnection$221142[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233279[ebp], edx
	mov	eax, DWORD PTR $T233279[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOtherTeam$221144[ebp], eax

; 3699 : 
; 3700 : 		bool bIgnore = false;

	mov	BYTE PTR _bIgnore$221145[ebp], 0

; 3701 : 		if (bExcludingMe && eOtherTeam == eMyTeam)

	movzx	edx, BYTE PTR _bExcludingMe$[ebp]
	test	edx, edx
	je	SHORT $LN9@GetTradePl
	mov	eax, DWORD PTR _eOtherTeam$221144[ebp]
	cmp	eax, DWORD PTR _eMyTeam$[ebp]
	jne	SHORT $LN9@GetTradePl

; 3702 : 		{
; 3703 : 			bIgnore = true;

	mov	BYTE PTR _bIgnore$221145[ebp], 1
$LN9@GetTradePl:

; 3704 : 		}
; 3705 : 
; 3706 : 		if (bOnlyWar && !GET_TEAM(eMyTeam).isAtWar(eOtherTeam))

	movzx	ecx, BYTE PTR _bOnlyWar$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@GetTradePl
	mov	edx, DWORD PTR _eMyTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T233291[ebp], edx
	mov	eax, DWORD PTR _eOtherTeam$221144[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233291[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@GetTradePl

; 3707 : 		{
; 3708 : 			bIgnore = true;

	mov	BYTE PTR _bIgnore$221145[ebp], 1
$LN8@GetTradePl:

; 3709 : 		}
; 3710 : 
; 3711 : 		if (bIgnore)

	movzx	edx, BYTE PTR _bIgnore$221145[ebp]
	test	edx, edx
	je	SHORT $LN7@GetTradePl

; 3712 : 		{
; 3713 : 			continue;

	jmp	$LN12@GetTradePl
$LN7@GetTradePl:

; 3714 : 		}
; 3715 : 
; 3716 : #ifdef AUI_ITERATORIZE
; 3717 : 		for (TradeConnectionPlotList::const_iterator it = pConnection->m_aPlotList.begin(); it != pConnection->m_aPlotList.end(); ++it)
; 3718 : 		{
; 3719 : 			if (it->m_iX == iX && it->m_iY == iY)
; 3720 : #else
; 3721 : 		for (uint ui = 0; ui < pConnection->m_aPlotList.size(); ui++)

	mov	DWORD PTR _ui$221149[ebp], 0
	jmp	SHORT $LN6@GetTradePl
$LN5@GetTradePl:
	mov	eax, DWORD PTR _ui$221149[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$221149[ebp], eax
$LN6@GetTradePl:
	mov	ecx, DWORD PTR _pConnection$221142[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T233295[ebp], edx
	mov	eax, DWORD PTR _ui$221149[ebp]
	cmp	eax, DWORD PTR $T233295[ebp]
	jae	SHORT $LN4@GetTradePl

; 3722 : 		{
; 3723 : 			if (pConnection->m_aPlotList[ui].m_iX == iX && pConnection->m_aPlotList[ui].m_iY == iY)

	mov	ecx, DWORD PTR _pConnection$221142[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _ui$221149[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	cmp	ecx, DWORD PTR _iX$[ebp]
	jne	SHORT $LN3@GetTradePl
	mov	edx, DWORD PTR _pConnection$221142[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _ui$221149[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	cmp	edx, DWORD PTR _iY$[ebp]
	jne	SHORT $LN3@GetTradePl

; 3724 : #endif
; 3725 : 			{
; 3726 : 				aiTradeConnectionIDs.push_back(pConnection->m_iID);

	mov	eax, DWORD PTR _pConnection$221142[ebp]
	push	eax
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3727 : 				if (bFailAtFirstFound)

	movzx	ecx, BYTE PTR _bFailAtFirstFound$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@GetTradePl

; 3728 : 				{
; 3729 : 					break;

	jmp	SHORT $LN4@GetTradePl
$LN3@GetTradePl:

; 3730 : 				}
; 3731 : 			}
; 3732 : 		}

	jmp	SHORT $LN5@GetTradePl
$LN4@GetTradePl:

; 3733 : 
; 3734 : 		if (bFailAtFirstFound && aiTradeConnectionIDs.size() > 0)

	movzx	edx, BYTE PTR _bFailAtFirstFound$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetTradePl
	mov	eax, DWORD PTR _aiTradeConnectionIDs$[ebp+8]
	sub	eax, DWORD PTR _aiTradeConnectionIDs$[ebp+4]
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN1@GetTradePl

; 3735 : 		{
; 3736 : 			break;

	jmp	SHORT $LN11@GetTradePl
$LN1@GetTradePl:

; 3737 : 		}
; 3738 : 	}

	jmp	$LN12@GetTradePl
$LN11@GetTradePl:

; 3739 : 
; 3740 : 	return aiTradeConnectionIDs;	

	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	edx, DWORD PTR $T233224[ebp]
	or	edx, 1
	mov	DWORD PTR $T233224[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN15@GetTradePl:

; 3741 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$1:
	mov	eax, DWORD PTR $T233224[ebp]
	and	eax, 1
	je	$LN19@GetTradePl
	and	DWORD PTR $T233224[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
$LN19@GetTradePl:
	ret	0
__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$3:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z$5:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ENDP ; CvPlayerTrade::GetTradePlotsAtPlot
PUBLIC	?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot
; Function compile flags: /Odtp
;	COMDAT ?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T233494 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z PROC ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot, COMDAT
; _this$ = ecx

; 3749 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T233494[ebp], 0

; 3750 : 	return GetTradeUnitsAtPlot(pPlot, bFailAtFirstFound, true, false);

	push	0
	push	1
	movzx	eax, BYTE PTR _bFailAtFirstFound$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradeUnitsAtPlot
	mov	eax, DWORD PTR $T233494[ebp]
	or	eax, 1
	mov	DWORD PTR $T233494[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3751 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ENDP ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot
_TEXT	ENDS
PUBLIC	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
PUBLIC	?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsOpposingPlayerTradeUnit
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
tv81 = -304						; size = 4
tv65 = -300						; size = 4
_this$ = -296						; size = 4
$T233500 = -46						; size = 1
$T233499 = -45						; size = 1
$T233498 = -44						; size = 16
_aiTradeConnectionIDs$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z PROC ; CvPlayerTrade::ContainsOpposingPlayerTradeUnit, COMDAT
; _this$ = ecx

; 3759 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3760 : 	std::vector<int> aiTradeConnectionIDs;

	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3761 : 	aiTradeConnectionIDs = GetOpposingTradeUnitsAtPlot(pPlot, true);

	push	1
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233498[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOpposingTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetOpposingTradeUnitsAtPlot
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv81[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv81[ebp]
	push	eax
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T233498[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 3762 : 	if (aiTradeConnectionIDs.size() > 0)

	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp+8]
	sub	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp+4]
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN2@ContainsOp

; 3763 : 	{
; 3764 : 		return true;

	mov	BYTE PTR $T233499[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233499[ebp]
	jmp	SHORT $LN3@ContainsOp

; 3765 : 	}
; 3766 : 	else

	jmp	SHORT $LN1@ContainsOp
$LN2@ContainsOp:

; 3767 : 	{
; 3768 : 		return false;

	mov	BYTE PTR $T233500[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233500[ebp]
	jmp	SHORT $LN3@ContainsOp
$LN1@ContainsOp:

; 3769 : 	}
; 3770 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN3@ContainsOp:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T233498[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR $T233498[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$8:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$10:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContainsOpposingPlayerTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ENDP ; CvPlayerTrade::ContainsOpposingPlayerTradeUnit
PUBLIC	?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot
; Function compile flags: /Odtp
;	COMDAT ?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T233934 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z PROC ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot, COMDAT
; _this$ = ecx

; 3778 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T233934[ebp], 0

; 3779 : 	return GetTradeUnitsAtPlot(pPlot, bFailAtFirstFound, true, true);

	push	1
	push	1
	movzx	eax, BYTE PTR _bFailAtFirstFound$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradeUnitsAtPlot
	mov	eax, DWORD PTR $T233934[ebp]
	or	eax, 1
	mov	DWORD PTR $T233934[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3780 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ENDP ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot
_TEXT	ENDS
PUBLIC	?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsEnemyTradeUnit
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
tv81 = -304						; size = 4
tv65 = -300						; size = 4
_this$ = -296						; size = 4
$T233940 = -46						; size = 1
$T233939 = -45						; size = 1
$T233938 = -44						; size = 16
_aiTradeConnectionIDs$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z PROC ; CvPlayerTrade::ContainsEnemyTradeUnit, COMDAT
; _this$ = ecx

; 3788 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3789 : 	std::vector<int> aiTradeConnectionIDs;

	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3790 : 	aiTradeConnectionIDs = GetEnemyTradeUnitsAtPlot(pPlot, true);

	push	1
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233938[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemyTradeUnitsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradeUnitsAtPlot
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv81[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv81[ebp]
	push	eax
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T233938[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 3791 : 	if (aiTradeConnectionIDs.size() > 0)

	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp+8]
	sub	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp+4]
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN2@ContainsEn

; 3792 : 	{
; 3793 : 		return true;

	mov	BYTE PTR $T233939[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233939[ebp]
	jmp	SHORT $LN3@ContainsEn

; 3794 : 	}
; 3795 : 	else

	jmp	SHORT $LN1@ContainsEn
$LN2@ContainsEn:

; 3796 : 	{
; 3797 : 		return false;

	mov	BYTE PTR $T233940[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T233940[ebp]
	jmp	SHORT $LN3@ContainsEn
$LN1@ContainsEn:

; 3798 : 	}
; 3799 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN3@ContainsEn:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T233938[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR $T233938[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$8:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$10:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContainsEnemyTradeUnit@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ENDP ; CvPlayerTrade::ContainsEnemyTradeUnit
PUBLIC	?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradePlotsAtPlot
; Function compile flags: /Odtp
;	COMDAT ?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T234374 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
_bFailAtFirstFound$ = 16				; size = 1
?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z PROC ; CvPlayerTrade::GetEnemyTradePlotsAtPlot, COMDAT
; _this$ = ecx

; 3807 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T234374[ebp], 0

; 3808 : 	return GetTradePlotsAtPlot(pPlot, bFailAtFirstFound, true, true);

	push	1
	push	1
	movzx	eax, BYTE PTR _bFailAtFirstFound$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N11@Z ; CvPlayerTrade::GetTradePlotsAtPlot
	mov	eax, DWORD PTR $T234374[ebp]
	or	eax, 1
	mov	DWORD PTR $T234374[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3809 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ENDP ; CvPlayerTrade::GetEnemyTradePlotsAtPlot
_TEXT	ENDS
PUBLIC	?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ; CvPlayerTrade::ContainsEnemyTradePlot
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
_TEXT	SEGMENT
tv81 = -304						; size = 4
tv65 = -300						; size = 4
_this$ = -296						; size = 4
$T234380 = -46						; size = 1
$T234379 = -45						; size = 1
$T234378 = -44						; size = 16
_aiTradeConnectionIDs$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z PROC ; CvPlayerTrade::ContainsEnemyTradePlot, COMDAT
; _this$ = ecx

; 3817 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3818 : 	std::vector<int> aiTradeConnectionIDs;

	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3819 : 	aiTradeConnectionIDs = GetEnemyTradePlotsAtPlot(pPlot, true);

	push	1
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234378[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemyTradePlotsAtPlot@CvPlayerTrade@@QAE?AV?$vector@HV?$allocator@H@std@@@std@@PBVCvPlot@@_N@Z ; CvPlayerTrade::GetEnemyTradePlotsAtPlot
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv81[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv81[ebp]
	push	eax
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<int,std::allocator<int> >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T234378[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 3820 : 	if (aiTradeConnectionIDs.size() > 0)

	mov	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp+8]
	sub	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp+4]
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN2@ContainsEn@2

; 3821 : 	{
; 3822 : 		return true;

	mov	BYTE PTR $T234379[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T234379[ebp]
	jmp	SHORT $LN3@ContainsEn@2

; 3823 : 	}
; 3824 : 	else

	jmp	SHORT $LN1@ContainsEn@2
$LN2@ContainsEn@2:

; 3825 : 	{
; 3826 : 		return false;

	mov	BYTE PTR $T234380[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T234380[ebp]
	jmp	SHORT $LN3@ContainsEn@2
$LN1@ContainsEn@2:

; 3827 : 	}
; 3828 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN3@ContainsEn@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T234378[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR $T234378[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$8:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z$10:
	lea	ecx, DWORD PTR _aiTradeConnectionIDs$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ContainsEnemyTradePlot@CvPlayerTrade@@QAE_NPBVCvPlot@@@Z ENDP ; CvPlayerTrade::ContainsEnemyTradePlot
PUBLIC	??_C@_0DJ@PPADKKD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??_C@_0DH@IFFJJEIL@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??_C@_0DM@BIMIADAI@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??_C@_0DJ@NOCIFDJD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??_C@_0DJ@MKICKADC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??_C@_0DH@PDCHKMLJ@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
PUBLIC	??_C@_0DL@PFKGHLOK@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??_C@_0DJ@BLFKMJAC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ ; `string'
PUBLIC	??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z ; GetLocalizedText<int,char const [24]>
PUBLIC	??_C@_0BI@CHNLLPJH@TXT_KEY_UNIT_CARGO_SHIP?$AA@	; `string'
PUBLIC	??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z ; GetLocalizedText<int,char const [21]>
PUBLIC	??_C@_0CF@OOCGGLEE@TXT_KEY_MISC_PLUNDERED_GOLD_FROM@ ; `string'
PUBLIC	??_C@_0BF@FGJHOBAA@TXT_KEY_UNIT_CARAVAN?$AA@	; `string'
PUBLIC	__real@00000000
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
PUBLIC	??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@ ; `string'
PUBLIC	?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z ; CvPlayerTrade::AddTradeConnectionWasPlundered
PUBLIC	__$ArrayPad$
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	?getNickName@CvPlayer@@QBEQBDXZ:PROC		; CvPlayer::getNickName
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z:PROC ; CvBarbarians::DoSpawnBarbarianUnit
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	_memset:PROC
;	COMDAT ??_C@_0DJ@PPADKKD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0DJ@PPADKKD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICAT'
	DB	'ION_TRADE_UNIT_PLUNDERED_TRADEE_UNKNOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IFFJJEIL@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
CONST	SEGMENT
??_C@_0DH@IFFJJEIL@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_TRADE_UNIT_PLUNDERED_TRADEE_KNOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BIMIADAI@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
CONST	SEGMENT
??_C@_0DM@BIMIADAI@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_TRADE_UNIT_PLUNDERED_TRADEE_BARBARIANS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NOCIFDJD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
CONST	SEGMENT
??_C@_0DJ@NOCIFDJD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_TRADE_UNIT_PLUNDERED_TRADEE_SUMMARY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MKICKADC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
CONST	SEGMENT
??_C@_0DJ@MKICKADC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_TRADE_UNIT_PLUNDERED_TRADER_UNKNOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PDCHKMLJ@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
CONST	SEGMENT
??_C@_0DH@PDCHKMLJ@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_TRADE_UNIT_PLUNDERED_TRADER_KNOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PFKGHLOK@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
CONST	SEGMENT
??_C@_0DL@PFKGHLOK@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_TRADE_UNIT_PLUNDERED_TRADER_BARBARIAN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BLFKMJAC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
CONST	SEGMENT
??_C@_0DJ@BLFKMJAC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_TRADE_UNIT_PLUNDERED_TRADER_SUMMARY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CHNLLPJH@TXT_KEY_UNIT_CARGO_SHIP?$AA@
CONST	SEGMENT
??_C@_0BI@CHNLLPJH@TXT_KEY_UNIT_CARGO_SHIP?$AA@ DB 'TXT_KEY_UNIT_CARGO_SH'
	DB	'IP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OOCGGLEE@TXT_KEY_MISC_PLUNDERED_GOLD_FROM@
CONST	SEGMENT
??_C@_0CF@OOCGGLEE@TXT_KEY_MISC_PLUNDERED_GOLD_FROM@ DB 'TXT_KEY_MISC_PLU'
	DB	'NDERED_GOLD_FROM_IMP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FGJHOBAA@TXT_KEY_UNIT_CARAVAN?$AA@
CONST	SEGMENT
??_C@_0BF@FGJHOBAA@TXT_KEY_UNIT_CARAVAN?$AA@ DB 'TXT_KEY_UNIT_CARAVAN', 00H ; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@
CONST	SEGMENT
??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@ DB '['
	DB	'COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$13
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$14
	DD	0bH
	DD	FLAT:__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$15
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
_TEXT	SEGMENT
tv734 = -1900						; size = 4
tv764 = -1896						; size = 4
tv1044 = -1892						; size = 4
tv762 = -1888						; size = 4
tv1043 = -1884						; size = 4
tv760 = -1880						; size = 4
tv502 = -1876						; size = 4
tv758 = -1872						; size = 4
tv505 = -1868						; size = 4
tv754 = -1864						; size = 4
tv1042 = -1860						; size = 4
tv752 = -1856						; size = 4
tv1041 = -1852						; size = 4
tv750 = -1848						; size = 4
tv336 = -1844						; size = 4
tv748 = -1840						; size = 4
tv339 = -1836						; size = 4
tv278 = -1832						; size = 4
tv730 = -1828						; size = 4
tv731 = -1824						; size = 4
tv238 = -1820						; size = 4
tv923 = -1816						; size = 4
tv832 = -1812						; size = 4
tv739 = -1808						; size = 4
tv919 = -1804						; size = 4
tv837 = -1800						; size = 4
_this$ = -1796						; size = 4
$T235308 = -1792					; size = 4
$T235304 = -1788					; size = 4
$T235300 = -1784					; size = 4
$T235296 = -1780					; size = 4
$T235292 = -1776					; size = 4
$T235288 = -1772					; size = 4
$T235284 = -1768					; size = 4
$T235280 = -1764					; size = 4
$T235276 = -1760					; size = 4
$T235272 = -1756					; size = 4
$T235268 = -1752					; size = 4
$T235264 = -1748					; size = 4
$T235260 = -1744					; size = 4
$T235259 = -1740					; size = 4
$T235250 = -1736					; size = 4
$T235246 = -1732					; size = 4
$T235242 = -1728					; size = 4
$T235238 = -1724					; size = 4
$T235234 = -1720					; size = 4
$T235230 = -1716					; size = 4
$T235221 = -1712					; size = 4
$T235217 = -1708					; size = 4
$T235213 = -1704					; size = 4
$T235209 = -1700					; size = 4
$T235205 = -1696					; size = 4
$T235201 = -1692					; size = 4
$T235200 = -1688					; size = 4
$T235191 = -1684					; size = 4
$T235183 = -1680					; size = 4
$T235174 = -1676					; size = 4
$T235170 = -1672					; size = 4
$T235166 = -1668					; size = 4
$T235158 = -1664					; size = 4
$T235150 = -1660					; size = 4
$T235139 = -1656					; size = 4
$T235135 = -1652					; size = 4
$T235131 = -1648					; size = 4
$T235122 = -1644					; size = 4
$T235113 = -1636					; size = 4
$T235112 = -1632					; size = 4
$T235081 = -1628					; size = 4
$T235076 = -1624					; size = 4
$T235072 = -1617					; size = 1
$T235061 = -1616					; size = 4
$T235057 = -1609					; size = 1
_iMapY$235111 = -1608					; size = 4
_iMapX$235110 = -1604					; size = 4
$T235050 = -1600					; size = 4
$T235041 = -1592					; size = 4
$T235040 = -1588					; size = 4
$T235009 = -1584					; size = 4
$T235004 = -1580					; size = 4
$T235000 = -1573					; size = 1
$T234989 = -1572					; size = 4
$T234985 = -1565					; size = 1
_iMapY$235039 = -1564					; size = 4
_iMapX$235038 = -1560					; size = 4
$T234978 = -1556					; size = 4
$T234974 = -1552					; size = 4
$T234968 = -1548					; size = 4
$T234967 = -1544					; size = 4
$T234936 = -1540					; size = 4
$T234931 = -1536					; size = 4
$T234927 = -1529					; size = 1
$T234916 = -1528					; size = 4
$T234912 = -1521					; size = 1
_iMapY$234966 = -1520					; size = 4
_iMapX$234965 = -1516					; size = 4
$T234905 = -1512					; size = 4
$T234901 = -1508					; size = 4
$T234897 = -1504					; size = 4
$T234885 = -1500					; size = 4
$T234873 = -1496					; size = 4
$T234866 = -1492					; size = 4
$T234846 = -1488					; size = 4
$T234845 = -1484					; size = 4
$T234844 = -1480					; size = 4
$T234843 = -1476					; size = 4
$T234842 = -1472					; size = 80
$T234841 = -1392					; size = 4
$T234840 = -1388					; size = 4
$T234839 = -1384					; size = 4
$T234838 = -1380					; size = 4
$T234837 = -1376					; size = 4
$T234836 = -1372					; size = 4
$T234835 = -1368					; size = 80
$T234834 = -1288					; size = 4
$T234833 = -1284					; size = 4
$T234832 = -1280					; size = 4
$T234831 = -1276					; size = 4
$T234830 = -1272					; size = 80
$T234829 = -1192					; size = 80
$T234828 = -1112					; size = 4
$T234827 = -1108					; size = 4
$T234826 = -1104					; size = 80
$T234825 = -1024					; size = 4
$T234824 = -1020					; size = 4
$T234823 = -1016					; size = 4
$T234822 = -1012					; size = 4
$T234821 = -1008					; size = 80
$T234820 = -928						; size = 4
$T234819 = -924						; size = 4
$T234818 = -920						; size = 80
$T234817 = -840						; size = 80
$T234816 = -760						; size = 28
$T234815 = -732						; size = 28
$T234814 = -704						; size = 4
_strMessage$221328 = -700				; size = 80
_strSummary$221327 = -620				; size = 80
_strMessage$221297 = -540				; size = 80
_strSummary$221296 = -460				; size = 80
_pNotifications$221294 = -376				; size = 4
_pLoopUnit$221288 = -372				; size = 4
_iLoop$221287 = -368					; size = 4
_strBuffer$221264 = -364				; size = 28
_fDelay$221263 = -336					; size = 4
_text$221256 = -332					; size = 256
__$ArrayPad$ = -76					; size = 4
_pTradeConnection$ = -72				; size = 4
_eOwningPlayer$ = -68					; size = 4
_bEmptyResult$ = -61					; size = 1
_iDomainModifier$ = -60					; size = 4
_iPlunderGoldValue$ = -56				; size = 4
_pPlot$ = -52						; size = 4
_eDomain$ = -48						; size = 4
_pDestCity$ = -44					; size = 4
_pTrade$ = -40						; size = 4
_iTradeConnectionIndex$ = -36				; size = 4
_eOwningTeam$ = -32					; size = 4
_eDestTeam$ = -28					; size = 4
_pPlunderPlot$ = -24					; size = 4
_pOriginCity$ = -20					; size = 4
_eDestPlayer$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iTradeConnectionID$ = 8				; size = 4
?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z PROC		; CvPlayerTrade::PlunderTradeRoute, COMDAT
; _this$ = ecx

; 3832 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1888				; 00000760H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3833 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234866[ebp], eax
	mov	ecx, DWORD PTR $T234866[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 3834 : 	int iTradeConnectionIndex = pTrade->GetIndexFromID(iTradeConnectionID);

	mov	ecx, DWORD PTR _iTradeConnectionID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?GetIndexFromID@CvGameTrade@@QAEHH@Z	; CvGameTrade::GetIndexFromID
	mov	DWORD PTR _iTradeConnectionIndex$[ebp], eax

; 3835 : 
; 3836 : 	CvAssertMsg(iTradeConnectionIndex >= 0, "iTradeConnectionIndex < 0");
; 3837 : 	if (iTradeConnectionIndex < 0)

	cmp	DWORD PTR _iTradeConnectionIndex$[ebp], 0
	jge	SHORT $LN35@PlunderTra

; 3838 : 	{
; 3839 : 		return false;

	xor	al, al
	jmp	$LN36@PlunderTra
$LN35@PlunderTra:

; 3840 : 	}
; 3841 : 
; 3842 : 	TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[iTradeConnectionIndex]);

	mov	edx, DWORD PTR _iTradeConnectionIndex$[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _pTradeConnection$[ebp], edx

; 3843 : 	DomainTypes eDomain = pTradeConnection->m_eDomain;

	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _eDomain$[ebp], edx

; 3844 : 	PlayerTypes eOwningPlayer = pTradeConnection->m_eOriginOwner;

	mov	eax, DWORD PTR _pTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _eOwningPlayer$[ebp], ecx

; 3845 : 	PlayerTypes eDestPlayer = pTradeConnection->m_eDestOwner;

	mov	edx, DWORD PTR _pTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _eDestPlayer$[ebp], eax

; 3846 : 	TeamTypes eOwningTeam = GET_PLAYER(eOwningPlayer).getTeam();

	mov	ecx, DWORD PTR _eOwningPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234873[ebp], ecx
	mov	edx, DWORD PTR $T234873[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOwningTeam$[ebp], eax

; 3847 : 	TeamTypes eDestTeam = GET_PLAYER(eDestPlayer).getTeam();

	mov	ecx, DWORD PTR _eDestPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234885[ebp], ecx
	mov	edx, DWORD PTR $T234885[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eDestTeam$[ebp], eax

; 3848 : 	CvPlot* pPlunderPlot = GC.getMap().plot(pTradeConnection->m_aPlotList[pTradeConnection->m_iTradeUnitLocationIndex].m_iX, pTradeConnection->m_aPlotList[pTradeConnection->m_iTradeUnitLocationIndex].m_iY);

	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _pTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T234897[ebp], edx
	mov	eax, DWORD PTR _pTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _pTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T234901[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234905[ebp], edx
	mov	eax, DWORD PTR $T234897[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234968[ebp], ecx
	mov	edx, DWORD PTR $T234901[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234967[ebp], eax
	cmp	DWORD PTR $T234967[ebp], -2147483647	; 80000001H
	je	SHORT $LN76@PlunderTra
	cmp	DWORD PTR $T234968[ebp], -2147483647	; 80000001H
	jne	SHORT $LN77@PlunderTra
$LN76@PlunderTra:
	mov	DWORD PTR _pPlunderPlot$[ebp], 0
	jmp	$LN78@PlunderTra
$LN77@PlunderTra:
	mov	ecx, DWORD PTR $T234905[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T234912[ebp], dl
	mov	eax, DWORD PTR $T234905[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234916[ebp], ecx
	movzx	edx, BYTE PTR $T234912[ebp]
	test	edx, edx
	je	SHORT $LN86@PlunderTra
	cmp	DWORD PTR $T234967[ebp], 0
	jge	SHORT $LN88@PlunderTra
	mov	eax, DWORD PTR $T234967[ebp]
	cdq
	idiv	DWORD PTR $T234916[ebp]
	add	edx, DWORD PTR $T234916[ebp]
	mov	DWORD PTR _iMapX$234965[ebp], edx
	jmp	SHORT $LN90@PlunderTra
	jmp	SHORT $LN86@PlunderTra
$LN88@PlunderTra:
	mov	eax, DWORD PTR $T234967[ebp]
	cmp	eax, DWORD PTR $T234916[ebp]
	jl	SHORT $LN86@PlunderTra
	mov	eax, DWORD PTR $T234967[ebp]
	cdq
	idiv	DWORD PTR $T234916[ebp]
	mov	DWORD PTR _iMapX$234965[ebp], edx
	jmp	SHORT $LN90@PlunderTra
$LN86@PlunderTra:
	mov	ecx, DWORD PTR $T234967[ebp]
	mov	DWORD PTR _iMapX$234965[ebp], ecx
$LN90@PlunderTra:
	mov	edx, DWORD PTR $T234905[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T234927[ebp], al
	mov	ecx, DWORD PTR $T234905[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T234931[ebp], edx
	movzx	eax, BYTE PTR $T234927[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234931[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234968[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$234966[ebp], eax
	mov	eax, DWORD PTR _iMapY$234966[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$234965[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234905[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN80@PlunderTra
	mov	edx, DWORD PTR $T234905[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T234936[ebp], eax
	mov	ecx, DWORD PTR _iMapY$234966[ebp]
	imul	ecx, DWORD PTR $T234936[ebp]
	add	ecx, DWORD PTR _iMapX$234965[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T234905[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv837[ebp], ecx
	jmp	SHORT $LN81@PlunderTra
$LN80@PlunderTra:
	mov	DWORD PTR tv837[ebp], 0
$LN81@PlunderTra:
	mov	eax, DWORD PTR tv837[ebp]
	mov	DWORD PTR _pPlunderPlot$[ebp], eax
$LN78@PlunderTra:

; 3849 : 	int iDomainModifier = GetTradeConnectionDomainValueModifierTimes100(*pTradeConnection, YIELD_GOLD);

	push	2
	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeConnectionDomainValueModifierTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@@Z ; CvPlayerTrade::GetTradeConnectionDomainValueModifierTimes100
	mov	DWORD PTR _iDomainModifier$[ebp], eax

; 3850 : 
; 3851 : 	// add trade connnection to broken list
; 3852 : 	GET_PLAYER(eOwningPlayer).GetTrade()->AddTradeConnectionWasPlundered(*pTradeConnection);

	sub	esp, 444				; 000001bcH
	mov	ecx, esp
	mov	DWORD PTR $T234814[ebp], esp
	mov	edx, DWORD PTR _pTradeConnection$[ebp]
	push	edx
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	DWORD PTR tv919[ebp], eax
	mov	eax, DWORD PTR tv919[ebp]
	mov	DWORD PTR tv739[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _eOwningPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234974[ebp], ecx
	mov	ecx, DWORD PTR $T234974[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, eax
	call	?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z ; CvPlayerTrade::AddTradeConnectionWasPlundered

; 3853 : 
; 3854 : 	CvCity* pOriginCity = NULL;

	mov	DWORD PTR _pOriginCity$[ebp], 0

; 3855 : 	CvCity* pDestCity = NULL;

	mov	DWORD PTR _pDestCity$[ebp], 0

; 3856 : 	CvPlot* pPlot = GC.getMap().plot(pTradeConnection->m_iOriginX, pTradeConnection->m_iOriginY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234978[ebp], edx
	mov	eax, DWORD PTR _pTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T235041[ebp], ecx
	mov	edx, DWORD PTR _pTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235040[ebp], eax
	cmp	DWORD PTR $T235040[ebp], -2147483647	; 80000001H
	je	SHORT $LN107@PlunderTra
	cmp	DWORD PTR $T235041[ebp], -2147483647	; 80000001H
	jne	SHORT $LN108@PlunderTra
$LN107@PlunderTra:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN109@PlunderTra
$LN108@PlunderTra:
	mov	ecx, DWORD PTR $T234978[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T234985[ebp], dl
	mov	eax, DWORD PTR $T234978[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234989[ebp], ecx
	movzx	edx, BYTE PTR $T234985[ebp]
	test	edx, edx
	je	SHORT $LN117@PlunderTra
	cmp	DWORD PTR $T235040[ebp], 0
	jge	SHORT $LN119@PlunderTra
	mov	eax, DWORD PTR $T235040[ebp]
	cdq
	idiv	DWORD PTR $T234989[ebp]
	add	edx, DWORD PTR $T234989[ebp]
	mov	DWORD PTR _iMapX$235038[ebp], edx
	jmp	SHORT $LN121@PlunderTra
	jmp	SHORT $LN117@PlunderTra
$LN119@PlunderTra:
	mov	eax, DWORD PTR $T235040[ebp]
	cmp	eax, DWORD PTR $T234989[ebp]
	jl	SHORT $LN117@PlunderTra
	mov	eax, DWORD PTR $T235040[ebp]
	cdq
	idiv	DWORD PTR $T234989[ebp]
	mov	DWORD PTR _iMapX$235038[ebp], edx
	jmp	SHORT $LN121@PlunderTra
$LN117@PlunderTra:
	mov	ecx, DWORD PTR $T235040[ebp]
	mov	DWORD PTR _iMapX$235038[ebp], ecx
$LN121@PlunderTra:
	mov	edx, DWORD PTR $T234978[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T235000[ebp], al
	mov	ecx, DWORD PTR $T234978[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T235004[ebp], edx
	movzx	eax, BYTE PTR $T235000[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235004[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235041[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$235039[ebp], eax
	mov	eax, DWORD PTR _iMapY$235039[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$235038[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234978[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN111@PlunderTra
	mov	edx, DWORD PTR $T234978[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T235009[ebp], eax
	mov	ecx, DWORD PTR _iMapY$235039[ebp]
	imul	ecx, DWORD PTR $T235009[ebp]
	add	ecx, DWORD PTR _iMapX$235038[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T234978[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv832[ebp], ecx
	jmp	SHORT $LN112@PlunderTra
$LN111@PlunderTra:
	mov	DWORD PTR tv832[ebp], 0
$LN112@PlunderTra:
	mov	eax, DWORD PTR tv832[ebp]
	mov	DWORD PTR _pPlot$[ebp], eax
$LN109@PlunderTra:

; 3857 : 	if (pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN34@PlunderTra

; 3858 : 	{
; 3859 : 		pOriginCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pOriginCity$[ebp], eax
$LN34@PlunderTra:

; 3860 : 	}
; 3861 : 	pPlot = GC.getMap().plot(pTradeConnection->m_iDestX, pTradeConnection->m_iDestY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235050[ebp], ecx
	mov	edx, DWORD PTR _pTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T235113[ebp], eax
	mov	ecx, DWORD PTR _pTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T235112[ebp], edx
	cmp	DWORD PTR $T235112[ebp], -2147483647	; 80000001H
	je	SHORT $LN138@PlunderTra
	cmp	DWORD PTR $T235113[ebp], -2147483647	; 80000001H
	jne	SHORT $LN139@PlunderTra
$LN138@PlunderTra:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN140@PlunderTra
$LN139@PlunderTra:
	mov	eax, DWORD PTR $T235050[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T235057[ebp], cl
	mov	edx, DWORD PTR $T235050[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T235061[ebp], eax
	movzx	ecx, BYTE PTR $T235057[ebp]
	test	ecx, ecx
	je	SHORT $LN148@PlunderTra
	cmp	DWORD PTR $T235112[ebp], 0
	jge	SHORT $LN150@PlunderTra
	mov	eax, DWORD PTR $T235112[ebp]
	cdq
	idiv	DWORD PTR $T235061[ebp]
	add	edx, DWORD PTR $T235061[ebp]
	mov	DWORD PTR _iMapX$235110[ebp], edx
	jmp	SHORT $LN152@PlunderTra
	jmp	SHORT $LN148@PlunderTra
$LN150@PlunderTra:
	mov	edx, DWORD PTR $T235112[ebp]
	cmp	edx, DWORD PTR $T235061[ebp]
	jl	SHORT $LN148@PlunderTra
	mov	eax, DWORD PTR $T235112[ebp]
	cdq
	idiv	DWORD PTR $T235061[ebp]
	mov	DWORD PTR _iMapX$235110[ebp], edx
	jmp	SHORT $LN152@PlunderTra
$LN148@PlunderTra:
	mov	eax, DWORD PTR $T235112[ebp]
	mov	DWORD PTR _iMapX$235110[ebp], eax
$LN152@PlunderTra:
	mov	ecx, DWORD PTR $T235050[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T235072[ebp], dl
	mov	eax, DWORD PTR $T235050[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T235076[ebp], ecx
	movzx	edx, BYTE PTR $T235072[ebp]
	push	edx
	mov	eax, DWORD PTR $T235076[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235113[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$235111[ebp], eax
	mov	edx, DWORD PTR _iMapY$235111[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$235110[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235050[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN142@PlunderTra
	mov	ecx, DWORD PTR $T235050[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T235081[ebp], edx
	mov	eax, DWORD PTR _iMapY$235111[ebp]
	imul	eax, DWORD PTR $T235081[ebp]
	add	eax, DWORD PTR _iMapX$235110[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T235050[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv923[ebp], eax
	jmp	SHORT $LN143@PlunderTra
$LN142@PlunderTra:
	mov	DWORD PTR tv923[ebp], 0
$LN143@PlunderTra:
	mov	edx, DWORD PTR tv923[ebp]
	mov	DWORD PTR _pPlot$[ebp], edx
$LN140@PlunderTra:

; 3862 : 	if (pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN33@PlunderTra

; 3863 : 	{
; 3864 : 		pDestCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pDestCity$[ebp], eax
$LN33@PlunderTra:

; 3865 : 	}
; 3866 : 	CvAssertMsg(pOriginCity, "pOriginCity doesn't exist");
; 3867 : 	CvAssertMsg(pDestCity, "pDestCity doesn't exist");
; 3868 : 
; 3869 : 	bool bEmptyResult = pTrade->EmptyTradeRoute(iTradeConnectionIndex);

	mov	eax, DWORD PTR _iTradeConnectionIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?EmptyTradeRoute@CvGameTrade@@QAE_NH@Z	; CvGameTrade::EmptyTradeRoute
	mov	BYTE PTR _bEmptyResult$[ebp], al

; 3870 : 
; 3871 : 	// if the trade route was not broken
; 3872 : 	if (!bEmptyResult)

	movzx	ecx, BYTE PTR _bEmptyResult$[ebp]
	test	ecx, ecx
	jne	SHORT $LN32@PlunderTra

; 3873 : 	{
; 3874 : 		return false;

	xor	al, al
	jmp	$LN36@PlunderTra
$LN32@PlunderTra:

; 3875 : 	}
; 3876 : 
; 3877 : 	int iPlunderGoldValue = 100;

	mov	DWORD PTR _iPlunderGoldValue$[ebp], 100	; 00000064H

; 3878 : 	iPlunderGoldValue *= 100 + iDomainModifier;

	mov	edx, DWORD PTR _iDomainModifier$[ebp]
	add	edx, 100				; 00000064H
	imul	edx, DWORD PTR _iPlunderGoldValue$[ebp]
	mov	DWORD PTR _iPlunderGoldValue$[ebp], edx

; 3879 : 	iPlunderGoldValue /= 100;

	mov	eax, DWORD PTR _iPlunderGoldValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iPlunderGoldValue$[ebp], eax

; 3880 : 	m_pPlayer->GetTreasury()->ChangeGold(iPlunderGoldValue);

	mov	edx, DWORD PTR _iPlunderGoldValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3881 : 
; 3882 : 	// do the floating popup
; 3883 : 	if (GC.getGame().getActivePlayer() == m_pPlayer->GetID())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235122[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+79104]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T235131[ebp], ecx
	mov	ecx, DWORD PTR $T235122[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR $T235131[ebp]
	jne	$LN31@PlunderTra

; 3884 : 	{
; 3885 : 		char text[256] = {0};

	mov	BYTE PTR _text$221256[ebp], 0
	push	255					; 000000ffH
	push	0
	lea	edx, DWORD PTR _text$221256[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3886 : 		sprintf_s(text, "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]", iPlunderGoldValue);

	mov	eax, DWORD PTR _iPlunderGoldValue$[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@
	lea	ecx, DWORD PTR _text$221256[ebp]
	push	ecx
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>
	add	esp, 12					; 0000000cH

; 3887 : 		float fDelay = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fDelay$221263[ebp], xmm0

; 3888 : 		DLLUI->AddPopupText(pPlunderPlot->getX(), pPlunderPlot->getY(), text, fDelay);

	mov	edx, DWORD PTR $T235135[ebp]
	mov	DWORD PTR tv238[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv238[ebp], eax
	mov	ecx, DWORD PTR _pPlunderPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235139[ebp], edx
	push	ecx
	fld	DWORD PTR _fDelay$221263[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _text$221256[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235139[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlunderPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv238[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv238[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax

; 3889 : 		CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$221264[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3890 : 		if (eDomain == DOMAIN_LAND)

	cmp	DWORD PTR _eDomain$[ebp], 2
	jne	SHORT $LN30@PlunderTra

; 3891 : 		{
; 3892 : 			strBuffer = GetLocalizedText("TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP", iPlunderGoldValue, "TXT_KEY_UNIT_CARAVAN");

	push	OFFSET ??_C@_0BF@FGJHOBAA@TXT_KEY_UNIT_CARAVAN?$AA@
	lea	ecx, DWORD PTR _iPlunderGoldValue$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CF@OOCGGLEE@TXT_KEY_MISC_PLUNDERED_GOLD_FROM@
	lea	edx, DWORD PTR $T234815[ebp]
	push	edx
	call	??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z ; GetLocalizedText<int,char const [21]>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv731[ebp], eax
	mov	eax, DWORD PTR tv731[ebp]
	mov	DWORD PTR $T235150[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T235150[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$221264[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T234815[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3893 : 		}
; 3894 : 		else

	jmp	SHORT $LN29@PlunderTra
$LN30@PlunderTra:

; 3895 : 		{
; 3896 : 			strBuffer = GetLocalizedText("TXT_KEY_MISC_PLUNDERED_GOLD_FROM_IMP", iPlunderGoldValue, "TXT_KEY_UNIT_CARGO_SHIP");

	push	OFFSET ??_C@_0BI@CHNLLPJH@TXT_KEY_UNIT_CARGO_SHIP?$AA@
	lea	edx, DWORD PTR _iPlunderGoldValue$[ebp]
	push	edx
	push	OFFSET ??_C@_0CF@OOCGGLEE@TXT_KEY_MISC_PLUNDERED_GOLD_FROM@
	lea	eax, DWORD PTR $T234816[ebp]
	push	eax
	call	??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z ; GetLocalizedText<int,char const [24]>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv730[ebp], eax
	mov	ecx, DWORD PTR tv730[ebp]
	mov	DWORD PTR $T235158[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR $T235158[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$221264[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T234816[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN29@PlunderTra:

; 3897 : 		}
; 3898 : 
; 3899 : 		
; 3900 : 		DLLUI->AddMessage(0, m_pPlayer->GetID(), true, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	eax, DWORD PTR $T235166[ebp]
	mov	DWORD PTR tv278[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv278[ebp], ecx
	lea	ecx, DWORD PTR _strBuffer$221264[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235170[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T235174[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T235183[ebp], edx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T235170[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235174[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T235183[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR tv278[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv278[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 3901 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$221264[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN31@PlunderTra:

; 3902 : 
; 3903 : 	// barbarians get a bonus unit out of the deal!
; 3904 : 	if (m_pPlayer->isBarbarian() && pPlot)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN25@PlunderTra
	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN25@PlunderTra

; 3905 : 	{
; 3906 : 		int iLoop = 0;

	mov	DWORD PTR _iLoop$221287[ebp], 0

; 3907 : 		for(CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$221287[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$221288[ebp], eax
	jmp	SHORT $LN27@PlunderTra
$LN26@PlunderTra:
	push	0
	lea	edx, DWORD PTR _iLoop$221287[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$221288[ebp], eax
$LN27@PlunderTra:
	cmp	DWORD PTR _pLoopUnit$221288[ebp], 0
	je	SHORT $LN25@PlunderTra

; 3908 : 		{
; 3909 : 			if (pLoopUnit->plot() == pPlunderPlot)

	mov	ecx, DWORD PTR _pLoopUnit$221288[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pPlunderPlot$[ebp]
	jne	SHORT $LN24@PlunderTra

; 3910 : 			{
; 3911 : 				CvBarbarians::DoSpawnBarbarianUnit(pPlunderPlot, true, true);

	push	1
	push	1
	mov	ecx, DWORD PTR _pPlunderPlot$[ebp]
	push	ecx
	call	?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z ; CvBarbarians::DoSpawnBarbarianUnit
	add	esp, 12					; 0000000cH

; 3912 : 				break;

	jmp	SHORT $LN25@PlunderTra
$LN24@PlunderTra:

; 3913 : 			}
; 3914 : 		}

	jmp	SHORT $LN26@PlunderTra
$LN25@PlunderTra:

; 3915 : 	}
; 3916 : 
; 3917 : 	// do the notification stuff
; 3918 : 	if (pOriginCity && pDestCity)

	cmp	DWORD PTR _pOriginCity$[ebp], 0
	je	$LN14@PlunderTra
	cmp	DWORD PTR _pDestCity$[ebp], 0
	je	$LN14@PlunderTra

; 3919 : 	{
; 3920 : 		// send notification to owner player
; 3921 : 		CvNotifications* pNotifications = GET_PLAYER(eOwningPlayer).GetNotifications();

	mov	edx, DWORD PTR _eOwningPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235191[ebp], edx
	mov	ecx, DWORD PTR $T235191[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$221294[ebp], eax

; 3922 : 		if(pNotifications)

	cmp	DWORD PTR _pNotifications$221294[ebp], 0
	je	$LN22@PlunderTra

; 3923 : 		{
; 3924 : 			Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$221296[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 3925 : 			Localization::String strMessage;

	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3926 : 
; 3927 : 			strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_SUMMARY");

	push	OFFSET ??_C@_0DJ@BLFKMJAC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	eax, DWORD PTR $T234817[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv339[ebp], eax
	mov	ecx, DWORD PTR tv339[ebp]
	mov	DWORD PTR tv748[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv748[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$221296[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T234817[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3928 : 			if (m_pPlayer->isBarbarian())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	je	$LN21@PlunderTra

; 3929 : 			{
; 3930 : 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_BARBARIAN");

	push	OFFSET ??_C@_0DL@PFKGHLOK@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	edx, DWORD PTR $T234818[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv336[ebp], eax
	mov	eax, DWORD PTR tv336[ebp]
	mov	DWORD PTR tv750[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR tv750[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T234818[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3931 : 				strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234819[ebp], eax
	lea	edx, DWORD PTR $T234819[ebp]
	push	edx
	lea	eax, DWORD PTR _strMessage$221297[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3932 : 				strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234820[ebp], eax
	lea	ecx, DWORD PTR $T234820[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221297[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	jmp	$LN16@PlunderTra
$LN21@PlunderTra:

; 3933 : 			}
; 3934 : 			else if (GET_TEAM(eOwningTeam).isHasMet(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	DWORD PTR $T235200[ebp], ecx
	mov	edx, DWORD PTR $T235200[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235201[ebp], eax
	mov	ecx, DWORD PTR _eOwningTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235205[ebp], ecx
	mov	edx, DWORD PTR $T235201[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235205[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	eax, al
	test	eax, eax
	je	$LN19@PlunderTra

; 3935 : 			{
; 3936 : 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_KNOWN");

	push	OFFSET ??_C@_0DH@PDCHKMLJ@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	ecx, DWORD PTR $T234821[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1041[ebp], eax
	mov	edx, DWORD PTR tv1041[ebp]
	mov	DWORD PTR tv752[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR tv752[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T234821[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3937 : 				if(GC.getGame().isGameMultiPlayer() && m_pPlayer->isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235209[ebp], ecx
	mov	ecx, DWORD PTR $T235209[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@PlunderTra
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@PlunderTra

; 3938 : 				{
; 3939 : 					strMessage << m_pPlayer->getNickName();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR $T234822[ebp], eax
	lea	eax, DWORD PTR $T234822[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3940 : 				}
; 3941 : 				else

	jmp	SHORT $LN17@PlunderTra
$LN18@PlunderTra:

; 3942 : 				{
; 3943 : 					strMessage << m_pPlayer->getNameKey();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T234823[ebp], eax
	lea	eax, DWORD PTR $T234823[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN17@PlunderTra:

; 3944 : 				}
; 3945 : 				strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234824[ebp], eax
	lea	edx, DWORD PTR $T234824[ebp]
	push	edx
	lea	eax, DWORD PTR _strMessage$221297[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3946 : 				strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234825[ebp], eax
	lea	ecx, DWORD PTR $T234825[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221297[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3947 : 			}
; 3948 : 			else

	jmp	$LN16@PlunderTra
$LN19@PlunderTra:

; 3949 : 			{
; 3950 : 				strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADER_UNKNOWN");

	push	OFFSET ??_C@_0DJ@MKICKADC@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	eax, DWORD PTR $T234826[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1042[ebp], eax
	mov	ecx, DWORD PTR tv1042[ebp]
	mov	DWORD PTR tv754[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR tv754[ebp]
	push	edx
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T234826[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3951 : 				strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234827[ebp], eax
	lea	eax, DWORD PTR $T234827[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3952 : 				strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234828[ebp], eax
	lea	edx, DWORD PTR $T234828[ebp]
	push	edx
	lea	eax, DWORD PTR _strMessage$221297[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN16@PlunderTra:

; 3953 : 			}
; 3954 : 
; 3955 : 			pNotifications->Add(NOTIFICATION_TRADE_ROUTE_BROKEN, strMessage.toUTF8(), strSummary.toUTF8(), pPlunderPlot->getX(), pPlunderPlot->getY(), -1);

	mov	ecx, DWORD PTR _pPlunderPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235213[ebp], edx
	mov	eax, DWORD PTR _pPlunderPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T235217[ebp], ecx
	push	-1
	push	-1
	mov	edx, DWORD PTR $T235213[ebp]
	push	edx
	mov	eax, DWORD PTR $T235217[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSummary$221296[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-344621894				; eb757cbaH
	mov	ecx, DWORD PTR _pNotifications$221294[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3956 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strSummary$221296[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN22@PlunderTra:

; 3957 : 
; 3958 : 		if (!GET_PLAYER(eDestPlayer).isMinorCiv() && eOwningPlayer != eDestPlayer && eDestPlayer != m_pPlayer->GetID())

	mov	ecx, DWORD PTR _eDestPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235221[ebp], ecx
	mov	ecx, DWORD PTR $T235221[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	$LN14@PlunderTra
	mov	eax, DWORD PTR _eOwningPlayer$[ebp]
	cmp	eax, DWORD PTR _eDestPlayer$[ebp]
	je	$LN14@PlunderTra
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235230[ebp], eax
	mov	ecx, DWORD PTR _eDestPlayer$[ebp]
	cmp	ecx, DWORD PTR $T235230[ebp]
	je	$LN14@PlunderTra

; 3959 : 		{
; 3960 : 			// send notification to destination player
; 3961 : 			pNotifications = GET_PLAYER(eDestPlayer).GetNotifications();

	mov	edx, DWORD PTR _eDestPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235234[ebp], edx
	mov	ecx, DWORD PTR $T235234[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$221294[ebp], eax

; 3962 : 			if (pNotifications)

	cmp	DWORD PTR _pNotifications$221294[ebp], 0
	je	$LN14@PlunderTra

; 3963 : 			{
; 3964 : 				Localization::String strSummary;

	lea	ecx, DWORD PTR _strSummary$221327[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 3965 : 				Localization::String strMessage;

	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 3966 : 
; 3967 : 				strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_SUMMARY");

	push	OFFSET ??_C@_0DJ@NOCIFDJD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	eax, DWORD PTR $T234829[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv505[ebp], eax
	mov	ecx, DWORD PTR tv505[ebp]
	mov	DWORD PTR tv758[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	edx, DWORD PTR tv758[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$221327[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T234829[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3968 : 				if (m_pPlayer->isBarbarian())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	je	$LN13@PlunderTra

; 3969 : 				{
; 3970 : 					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_BARBARIANS");

	push	OFFSET ??_C@_0DM@BIMIADAI@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	edx, DWORD PTR $T234830[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv502[ebp], eax
	mov	eax, DWORD PTR tv502[ebp]
	mov	DWORD PTR tv760[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR tv760[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T234830[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3971 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eOwningPlayer).isHuman())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235238[ebp], edx
	mov	ecx, DWORD PTR $T235238[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@PlunderTra
	mov	ecx, DWORD PTR _eOwningPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235242[ebp], ecx
	mov	ecx, DWORD PTR $T235242[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@PlunderTra

; 3972 : 					{
; 3973 : 						strMessage << GET_PLAYER(eOwningPlayer).getNickName();

	mov	eax, DWORD PTR _eOwningPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235246[ebp], eax
	mov	ecx, DWORD PTR $T235246[ebp]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR $T234831[ebp], eax
	lea	ecx, DWORD PTR $T234831[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221328[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3974 : 					}
; 3975 : 					else

	jmp	SHORT $LN11@PlunderTra
$LN12@PlunderTra:

; 3976 : 					{
; 3977 : 						strMessage << GET_PLAYER(eOwningPlayer).getNameKey();

	mov	eax, DWORD PTR _eOwningPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235250[ebp], eax
	mov	ecx, DWORD PTR $T235250[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T234832[ebp], eax
	lea	ecx, DWORD PTR $T234832[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221328[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN11@PlunderTra:

; 3978 : 					}
; 3979 : 					strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234833[ebp], eax
	lea	eax, DWORD PTR $T234833[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3980 : 					strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234834[ebp], eax
	lea	edx, DWORD PTR $T234834[ebp]
	push	edx
	lea	eax, DWORD PTR _strMessage$221328[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	jmp	$LN4@PlunderTra
$LN13@PlunderTra:

; 3981 : 				}
; 3982 : 				else if (GET_TEAM(eDestTeam).isHasMet(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	DWORD PTR $T235259[ebp], edx
	mov	eax, DWORD PTR $T235259[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235260[ebp], eax
	mov	edx, DWORD PTR _eDestTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235264[ebp], edx
	mov	eax, DWORD PTR $T235260[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235264[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@PlunderTra

; 3983 : 				{
; 3984 : 					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_KNOWN");

	push	OFFSET ??_C@_0DH@IFFJJEIL@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	edx, DWORD PTR $T234835[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1043[ebp], eax
	mov	eax, DWORD PTR tv1043[ebp]
	mov	DWORD PTR tv762[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR tv762[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T234835[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3985 : 					if(GC.getGame().isGameMultiPlayer() && m_pPlayer->isHuman())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235268[ebp], edx
	mov	ecx, DWORD PTR $T235268[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@PlunderTra
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@PlunderTra

; 3986 : 					{
; 3987 : 						strMessage << m_pPlayer->getNickName();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR $T234836[ebp], eax
	lea	ecx, DWORD PTR $T234836[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221328[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3988 : 					}
; 3989 : 					else

	jmp	SHORT $LN7@PlunderTra
$LN8@PlunderTra:

; 3990 : 					{
; 3991 : 						strMessage << m_pPlayer->getNameKey();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T234837[ebp], eax
	lea	ecx, DWORD PTR $T234837[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221328[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN7@PlunderTra:

; 3992 : 					}
; 3993 : 
; 3994 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eOwningPlayer).isHuman())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235272[ebp], eax
	mov	ecx, DWORD PTR $T235272[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@PlunderTra
	mov	edx, DWORD PTR _eOwningPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235276[ebp], edx
	mov	ecx, DWORD PTR $T235276[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@PlunderTra

; 3995 : 					{
; 3996 : 						strMessage << GET_PLAYER(eOwningPlayer).getNickName();

	mov	ecx, DWORD PTR _eOwningPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235280[ebp], ecx
	mov	ecx, DWORD PTR $T235280[ebp]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR $T234838[ebp], eax
	lea	edx, DWORD PTR $T234838[ebp]
	push	edx
	lea	eax, DWORD PTR _strMessage$221328[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3997 : 					}
; 3998 : 					else

	jmp	SHORT $LN5@PlunderTra
$LN6@PlunderTra:

; 3999 : 					{
; 4000 : 						strMessage << GET_PLAYER(eOwningPlayer).getNameKey();

	mov	ecx, DWORD PTR _eOwningPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235284[ebp], ecx
	mov	ecx, DWORD PTR $T235284[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T234839[ebp], eax
	lea	edx, DWORD PTR $T234839[ebp]
	push	edx
	lea	eax, DWORD PTR _strMessage$221328[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN5@PlunderTra:

; 4001 : 					}
; 4002 : 
; 4003 : 					strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234840[ebp], eax
	lea	ecx, DWORD PTR $T234840[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221328[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4004 : 					strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234841[ebp], eax
	lea	eax, DWORD PTR $T234841[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4005 : 				}
; 4006 : 				else

	jmp	$LN4@PlunderTra
$LN9@PlunderTra:

; 4007 : 				{
; 4008 : 					strMessage = Localization::Lookup("TXT_KEY_NOTIFICATION_TRADE_UNIT_PLUNDERED_TRADEE_UNKNOWN");

	push	OFFSET ??_C@_0DJ@PPADKKD@TXT_KEY_NOTIFICATION_TRADE_UNIT_@
	lea	edx, DWORD PTR $T234842[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv1044[ebp], eax
	mov	eax, DWORD PTR tv1044[ebp]
	mov	DWORD PTR tv764[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR tv764[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T234842[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 4009 : 
; 4010 : 					if(GC.getGame().isGameMultiPlayer() && GET_PLAYER(eOwningPlayer).isHuman())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235288[ebp], edx
	mov	ecx, DWORD PTR $T235288[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@PlunderTra
	mov	ecx, DWORD PTR _eOwningPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235292[ebp], ecx
	mov	ecx, DWORD PTR $T235292[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@PlunderTra

; 4011 : 					{
; 4012 : 						strMessage << GET_PLAYER(eOwningPlayer).getNickName();

	mov	eax, DWORD PTR _eOwningPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235296[ebp], eax
	mov	ecx, DWORD PTR $T235296[ebp]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR $T234843[ebp], eax
	lea	ecx, DWORD PTR $T234843[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221328[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4013 : 					}
; 4014 : 					else

	jmp	SHORT $LN2@PlunderTra
$LN3@PlunderTra:

; 4015 : 					{
; 4016 : 						strMessage << GET_PLAYER(eOwningPlayer).getNameKey();

	mov	eax, DWORD PTR _eOwningPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235300[ebp], eax
	mov	ecx, DWORD PTR $T235300[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T234844[ebp], eax
	lea	ecx, DWORD PTR $T234844[ebp]
	push	ecx
	lea	edx, DWORD PTR _strMessage$221328[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN2@PlunderTra:

; 4017 : 					}
; 4018 : 
; 4019 : 					strMessage << pOriginCity->getNameKey();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234845[ebp], eax
	lea	eax, DWORD PTR $T234845[ebp]
	push	eax
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4020 : 					strMessage << pDestCity->getNameKey();

	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T234846[ebp], eax
	lea	edx, DWORD PTR $T234846[ebp]
	push	edx
	lea	eax, DWORD PTR _strMessage$221328[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN4@PlunderTra:

; 4021 : 				}
; 4022 : 
; 4023 : 				pNotifications->Add(NOTIFICATION_TRADE_ROUTE_BROKEN, strMessage.toUTF8(), strSummary.toUTF8(), -1, -1, -1);

	push	-1
	push	-1
	push	-1
	push	-1
	lea	ecx, DWORD PTR _strSummary$221327[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-344621894				; eb757cbaH
	mov	ecx, DWORD PTR _pNotifications$221294[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 4024 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strSummary$221327[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN14@PlunderTra:

; 4025 : 		}
; 4026 : 	}
; 4027 : 
; 4028 : 	if (eDomain == DOMAIN_LAND && m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	cmp	DWORD PTR _eDomain$[ebp], 2
	jne	SHORT $LN1@PlunderTra
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@PlunderTra
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235304[ebp], eax
	mov	ecx, DWORD PTR $T235304[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@PlunderTra

; 4029 : 	{
; 4030 : 		gDLL->UnlockAchievement(ACHIEVEMENT_XP2_28);

	mov	edx, DWORD PTR $T235308[ebp]
	mov	DWORD PTR tv734[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv734[ebp], eax
	push	270					; 0000010eH
	mov	ecx, DWORD PTR tv734[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv734[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN1@PlunderTra:

; 4031 : 	}
; 4032 : 
; 4033 : 	return true;

	mov	al, 1
$LN36@PlunderTra:

; 4034 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$0:
	mov	ecx, DWORD PTR $T234814[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$1:
	lea	ecx, DWORD PTR _strBuffer$221264[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$2:
	lea	ecx, DWORD PTR $T234815[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$3:
	lea	ecx, DWORD PTR $T234816[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$4:
	lea	ecx, DWORD PTR _strSummary$221296[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$5:
	lea	ecx, DWORD PTR _strMessage$221297[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$6:
	lea	ecx, DWORD PTR $T234817[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$7:
	lea	ecx, DWORD PTR $T234818[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$8:
	lea	ecx, DWORD PTR $T234821[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$9:
	lea	ecx, DWORD PTR $T234826[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$10:
	lea	ecx, DWORD PTR _strSummary$221327[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$11:
	lea	ecx, DWORD PTR _strMessage$221328[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$12:
	lea	ecx, DWORD PTR $T234829[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$13:
	lea	ecx, DWORD PTR $T234830[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$14:
	lea	ecx, DWORD PTR $T234835[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z$15:
	lea	ecx, DWORD PTR $T234842[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__ehhandler$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1892]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PlunderTradeRoute@CvPlayerTrade@@QAE_NH@Z ENDP		; CvPlayerTrade::PlunderTradeRoute
EXTRN	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
EXTRN	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
EXTRN	?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z:PROC ; CvTechEntry::GetTradeRouteDomainExtraRange
EXTRN	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z:PROC ; CvTechXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
tv67 = -96						; size = 4
tv64 = -92						; size = 4
_this$ = -88						; size = 4
$T235366 = -84						; size = 4
$T235362 = -80						; size = 4
$T235358 = -76						; size = 4
$T235349 = -72						; size = 4
$T235345 = -68						; size = 4
$T235336 = -64						; size = 4
$T235332 = -60						; size = 4
$T235323 = -56						; size = 4
_pBuildingEntry$221405 = -52				; size = 4
_eBuilding$221402 = -48					; size = 4
_iI$221398 = -44					; size = 4
_eTech$221393 = -40					; size = 4
_iTechLoop$221389 = -36					; size = 4
_pMyPlayerTechs$ = -32					; size = 4
_pTechInfo$ = -28					; size = 4
_iRange$ = -24						; size = 4
_iBaseRange$ = -20					; size = 4
_iRangeModifier$ = -16					; size = 4
_iTraitRange$ = -12					; size = 4
_pMyTeamTechs$ = -8					; size = 4
_iExtendedRange$ = -4					; size = 4
_eDomain$ = 8						; size = 4
_pOriginCity$ = 12					; size = 4
?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z PROC ; CvPlayerTrade::GetTradeRouteRange, COMDAT
; _this$ = ecx

; 4042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 4043 : 	int iRange = 0;

	mov	DWORD PTR _iRange$[ebp], 0

; 4044 : 
; 4045 : 	int iBaseRange = 0;

	mov	DWORD PTR _iBaseRange$[ebp], 0

; 4046 : 	switch (eDomain)

	mov	eax, DWORD PTR _eDomain$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN21@GetTradeRo
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN20@GetTradeRo
	jmp	SHORT $LN19@GetTradeRo
$LN21@GetTradeRo:

; 4047 : 	{
; 4048 : 	case DOMAIN_SEA:
; 4049 : 		iBaseRange = 20;

	mov	DWORD PTR _iBaseRange$[ebp], 20		; 00000014H

; 4050 : 		break;

	jmp	SHORT $LN22@GetTradeRo
$LN20@GetTradeRo:

; 4051 : 	case DOMAIN_LAND:
; 4052 : 		iBaseRange = 10;

	mov	DWORD PTR _iBaseRange$[ebp], 10		; 0000000aH

; 4053 : 		break;

	jmp	SHORT $LN22@GetTradeRo
$LN19@GetTradeRo:

; 4054 : 	default:
; 4055 : 		CvAssertMsg(false, "Undefined domain for trade route range");
; 4056 : 		return -1;

	or	eax, -1
	jmp	$LN24@GetTradeRo
$LN22@GetTradeRo:

; 4057 : 		break;
; 4058 : 	}
; 4059 : 
; 4060 : 	int iTraitRange = 0;

	mov	DWORD PTR _iTraitRange$[ebp], 0

; 4061 : 	switch (eDomain)

	mov	ecx, DWORD PTR _eDomain$[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 0
	je	SHORT $LN16@GetTradeRo
	cmp	DWORD PTR tv67[ebp], 2
	je	SHORT $LN15@GetTradeRo
	jmp	SHORT $LN17@GetTradeRo
$LN16@GetTradeRo:

; 4062 : 	{
; 4063 : 	case DOMAIN_SEA:
; 4064 : 		// not implemented
; 4065 : 		iTraitRange = 0;

	mov	DWORD PTR _iTraitRange$[ebp], 0

; 4066 : 		break;

	jmp	SHORT $LN17@GetTradeRo
$LN15@GetTradeRo:

; 4067 : 	case DOMAIN_LAND:
; 4068 : 		iTraitRange = m_pPlayer->GetPlayerTraits()->GetLandTradeRouteRangeBonus();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T235323[ebp], eax
	mov	eax, DWORD PTR $T235323[ebp]
	mov	ecx, DWORD PTR [eax+320]
	mov	DWORD PTR _iTraitRange$[ebp], ecx
$LN17@GetTradeRo:

; 4069 : 		break;
; 4070 : 	}
; 4071 : 
; 4072 : 	CvPlayerTechs* pMyPlayerTechs = m_pPlayer->GetPlayerTechs();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	DWORD PTR _pMyPlayerTechs$[ebp], eax

; 4073 : 	CvTeamTechs* pMyTeamTechs = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).GetTeamTechs();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T235332[ebp], edx
	mov	eax, DWORD PTR $T235332[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235336[ebp], eax
	mov	ecx, DWORD PTR $T235336[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235345[ebp], eax
	mov	eax, DWORD PTR $T235345[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235349[ebp], eax
	mov	ecx, DWORD PTR $T235349[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	DWORD PTR _pMyTeamTechs$[ebp], eax

; 4074 : 	CvTechEntry* pTechInfo = NULL; 

	mov	DWORD PTR _pTechInfo$[ebp], 0

; 4075 : 
; 4076 : 	int iExtendedRange = 0;

	mov	DWORD PTR _iExtendedRange$[ebp], 0

; 4077 : #ifdef AUI_WARNING_FIXES
; 4078 : 	for (uint iTechLoop = 0; iTechLoop < pMyPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)
; 4079 : #else
; 4080 : 	for(int iTechLoop = 0; iTechLoop < pMyPlayerTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$221389[ebp], 0
	jmp	SHORT $LN14@GetTradeRo
$LN13@GetTradeRo:
	mov	ecx, DWORD PTR _iTechLoop$221389[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTechLoop$221389[ebp], ecx
$LN14@GetTradeRo:
	mov	ecx, DWORD PTR _pMyPlayerTechs$[ebp]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTechLoop$221389[ebp], eax
	jge	SHORT $LN12@GetTradeRo

; 4081 : #endif
; 4082 : 	{
; 4083 : 		TechTypes eTech = (TechTypes)iTechLoop;

	mov	edx, DWORD PTR _iTechLoop$221389[ebp]
	mov	DWORD PTR _eTech$221393[ebp], edx

; 4084 : 		if (!pMyTeamTechs->HasTech(eTech))

	mov	eax, DWORD PTR _eTech$221393[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMyTeamTechs$[ebp]
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@GetTradeRo

; 4085 : 		{
; 4086 : 			continue;

	jmp	SHORT $LN13@GetTradeRo
$LN11@GetTradeRo:

; 4087 : 		}
; 4088 : 
; 4089 : 		pTechInfo = pMyPlayerTechs->GetTechs()->GetEntry(eTech);

	mov	edx, DWORD PTR _eTech$221393[ebp]
	push	edx
	mov	ecx, DWORD PTR _pMyPlayerTechs$[ebp]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
	mov	DWORD PTR _pTechInfo$[ebp], eax

; 4090 : 		CvAssertMsg(pTechInfo, "null tech entry");
; 4091 : 		if (pTechInfo)

	cmp	DWORD PTR _pTechInfo$[ebp], 0
	je	SHORT $LN10@GetTradeRo

; 4092 : 		{
; 4093 : 			iExtendedRange += pTechInfo->GetTradeRouteDomainExtraRange(eDomain);

	mov	eax, DWORD PTR _eDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTechInfo$[ebp]
	call	?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z ; CvTechEntry::GetTradeRouteDomainExtraRange
	add	eax, DWORD PTR _iExtendedRange$[ebp]
	mov	DWORD PTR _iExtendedRange$[ebp], eax
$LN10@GetTradeRo:

; 4094 : 		}
; 4095 : 	}

	jmp	SHORT $LN13@GetTradeRo
$LN12@GetTradeRo:

; 4096 : 	
; 4097 : 	int iRangeModifier = 0;

	mov	DWORD PTR _iRangeModifier$[ebp], 0

; 4098 : #ifdef AUI_WARNING_FIXES
; 4099 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4100 : #else
; 4101 : 	for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$221398[ebp], 0
	jmp	SHORT $LN9@GetTradeRo
$LN8@GetTradeRo:
	mov	ecx, DWORD PTR _iI$221398[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221398[ebp], ecx
$LN9@GetTradeRo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$221398[ebp], eax
	jge	$LN7@GetTradeRo

; 4102 : #endif
; 4103 : 	{
; 4104 : 		BuildingTypes eBuilding = (BuildingTypes)GET_PLAYER(pOriginCity->getOwner()).getCivilizationInfo().getCivilizationBuildings(iI);

	mov	edx, DWORD PTR _pOriginCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T235358[ebp], eax
	mov	ecx, DWORD PTR $T235358[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235362[ebp], ecx
	mov	edx, DWORD PTR _iI$221398[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235362[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$221402[ebp], eax

; 4105 : 		if(eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$221402[ebp], -1
	je	$LN6@GetTradeRo

; 4106 : 		{
; 4107 : 			CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	mov	eax, DWORD PTR _eBuilding$221402[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pBuildingEntry$221405[ebp], eax

; 4108 : 			if (!pBuildingEntry)

	cmp	DWORD PTR _pBuildingEntry$221405[ebp], 0
	jne	SHORT $LN5@GetTradeRo

; 4109 : 			{
; 4110 : 				continue;

	jmp	SHORT $LN8@GetTradeRo
$LN5@GetTradeRo:

; 4111 : 			}
; 4112 : 
; 4113 : 			if (pBuildingEntry && pOriginCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()))

	cmp	DWORD PTR _pBuildingEntry$221405[ebp], 0
	je	SHORT $LN6@GetTradeRo
	mov	ecx, DWORD PTR _pBuildingEntry$221405[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235366[ebp], edx
	mov	eax, DWORD PTR $T235366[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	je	SHORT $LN6@GetTradeRo

; 4114 : 			{
; 4115 : 				if (pBuildingEntry->GetTradeRouteSeaDistanceModifier() > 0 && eDomain == DOMAIN_SEA)

	mov	ecx, DWORD PTR _pBuildingEntry$221405[ebp]
	call	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
	test	eax, eax
	jle	SHORT $LN3@GetTradeRo
	cmp	DWORD PTR _eDomain$[ebp], 0
	jne	SHORT $LN3@GetTradeRo

; 4116 : 				{
; 4117 : 					iRangeModifier += pBuildingEntry->GetTradeRouteSeaDistanceModifier();

	mov	ecx, DWORD PTR _pBuildingEntry$221405[ebp]
	call	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
	add	eax, DWORD PTR _iRangeModifier$[ebp]
	mov	DWORD PTR _iRangeModifier$[ebp], eax
	jmp	SHORT $LN6@GetTradeRo
$LN3@GetTradeRo:

; 4118 : 				}
; 4119 : 				else if (pBuildingEntry->GetTradeRouteLandDistanceModifier() > 0 && eDomain == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pBuildingEntry$221405[ebp]
	call	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
	test	eax, eax
	jle	SHORT $LN6@GetTradeRo
	cmp	DWORD PTR _eDomain$[ebp], 2
	jne	SHORT $LN6@GetTradeRo

; 4120 : 				{
; 4121 : 					iRangeModifier += pBuildingEntry->GetTradeRouteLandDistanceModifier();

	mov	ecx, DWORD PTR _pBuildingEntry$221405[ebp]
	call	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
	add	eax, DWORD PTR _iRangeModifier$[ebp]
	mov	DWORD PTR _iRangeModifier$[ebp], eax
$LN6@GetTradeRo:

; 4122 : 				}
; 4123 : 			}
; 4124 : 		}
; 4125 : 	}

	jmp	$LN8@GetTradeRo
$LN7@GetTradeRo:

; 4126 : 
; 4127 : 	iRange = iBaseRange;

	mov	ecx, DWORD PTR _iBaseRange$[ebp]
	mov	DWORD PTR _iRange$[ebp], ecx

; 4128 : 	iRange += iTraitRange;

	mov	edx, DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iTraitRange$[ebp]
	mov	DWORD PTR _iRange$[ebp], edx

; 4129 : 	iRange += iExtendedRange;

	mov	eax, DWORD PTR _iRange$[ebp]
	add	eax, DWORD PTR _iExtendedRange$[ebp]
	mov	DWORD PTR _iRange$[ebp], eax

; 4130 : 	iRange = (iRange * (100 + iRangeModifier)) / 100;

	mov	ecx, DWORD PTR _iRangeModifier$[ebp]
	add	ecx, 100				; 00000064H
	mov	eax, ecx
	imul	eax, DWORD PTR _iRange$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iRange$[ebp], eax

; 4131 : 	return iRange;

	mov	eax, DWORD PTR _iRange$[ebp]
$LN24@GetTradeRo:

; 4132 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTradeRouteRange@CvPlayerTrade@@QAEHW4DomainTypes@@PAVCvCity@@@Z ENDP ; CvPlayerTrade::GetTradeRouteRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_eDomain$ = 8						; size = 4
?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z PROC ; CvPlayerTrade::GetTradeRouteSpeed, COMDAT
; _this$ = ecx

; 4140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4141 : 	switch (eDomain)

	mov	eax, DWORD PTR _eDomain$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN2@GetTradeRo@2
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN1@GetTradeRo@2
	jmp	SHORT $LN3@GetTradeRo@2
$LN2@GetTradeRo@2:

; 4142 : 	{
; 4143 : 	case DOMAIN_SEA:
; 4144 : 		return 4;

	mov	eax, 4
	jmp	SHORT $LN5@GetTradeRo@2

; 4145 : 		break;

	jmp	SHORT $LN3@GetTradeRo@2
$LN1@GetTradeRo@2:

; 4146 : 	case DOMAIN_LAND:
; 4147 : 		return 2;

	mov	eax, 2
	jmp	SHORT $LN5@GetTradeRo@2
$LN3@GetTradeRo@2:

; 4148 : 		break;
; 4149 : 	}
; 4150 : 
; 4151 : 	CvAssertMsg(false, "Undefined domain for trade route speed");
; 4152 : 	return -1;

	or	eax, -1
$LN5@GetTradeRo@2:

; 4153 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTradeRouteSpeed@CvPlayerTrade@@QAEHW4DomainTypes@@@Z ENDP ; CvPlayerTrade::GetTradeRouteSpeed
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
EXTRN	?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetNumTradeRouteBonus
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetFounderBenefitsReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ:PROC ; CvTechEntry::GetNumInternationalTradeRoutesChange
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
; Function compile flags: /Odtp
;	COMDAT ?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T235426 = -112						; size = 4
$T235425 = -108						; size = 4
$T235421 = -104						; size = 4
$T235417 = -100						; size = 4
$T235413 = -96						; size = 4
$T235409 = -92						; size = 4
$T235405 = -88						; size = 4
$T235396 = -84						; size = 4
$T235392 = -80						; size = 4
$T235383 = -76						; size = 4
$T235379 = -72						; size = 4
_iNumRouteBonus$221462 = -68				; size = 4
_pBuildingEntry$221457 = -64				; size = 4
_eBuilding$221454 = -60					; size = 4
_iI$221450 = -56					; size = 4
_pReligion$221443 = -52					; size = 4
_eTech$221437 = -48					; size = 4
_iTechLoop$221433 = -44					; size = 4
_pMyPlayerTechs$ = -40					; size = 4
_pTechInfo$ = -36					; size = 4
_kCivInfo$ = -32					; size = 4
_pMyTeamTechs$ = -28					; size = 4
_eFoundedReligion$ = -24				; size = 4
_pMyPlayerTechEntries$ = -20				; size = 4
_iModifier$ = -16					; size = 4
_iNumRoutes$ = -12					; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ PROC	; CvPlayerTrade::GetNumTradeRoutesPossible, COMDAT
; _this$ = ecx

; 4161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 4162 : 	int iNumRoutes = 0;

	mov	DWORD PTR _iNumRoutes$[ebp], 0

; 4163 : 
; 4164 : 	CvAssert(m_pPlayer->getCivilizationType() != NO_CIVILIZATION);
; 4165 : 	if (m_pPlayer->getCivilizationType() == NO_CIVILIZATION)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	eax, -1
	jne	SHORT $LN19@GetNumTrad@2

; 4166 : 		return 0;

	xor	eax, eax
	jmp	$LN20@GetNumTrad@2
$LN19@GetNumTrad@2:

; 4167 : 
; 4168 : 	CvPlayerTechs* pMyPlayerTechs = m_pPlayer->GetPlayerTechs();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	DWORD PTR _pMyPlayerTechs$[ebp], eax

; 4169 : 	CvTeamTechs* pMyTeamTechs = GET_TEAM(GET_PLAYER(m_pPlayer->GetID()).getTeam()).GetTeamTechs();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+79104]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T235379[ebp], ecx
	mov	edx, DWORD PTR $T235379[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235383[ebp], edx
	mov	eax, DWORD PTR $T235383[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235392[ebp], eax
	mov	edx, DWORD PTR $T235392[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235396[ebp], edx
	mov	ecx, DWORD PTR $T235396[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	DWORD PTR _pMyTeamTechs$[ebp], eax

; 4170 : 	CvTechEntry* pTechInfo = NULL; 

	mov	DWORD PTR _pTechInfo$[ebp], 0

; 4171 : 
; 4172 : 	CvTechXMLEntries* pMyPlayerTechEntries = pMyPlayerTechs->GetTechs();

	mov	ecx, DWORD PTR _pMyPlayerTechs$[ebp]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	DWORD PTR _pMyPlayerTechEntries$[ebp], eax

; 4173 : 	CvAssert(pMyPlayerTechEntries);
; 4174 : 	if (pMyPlayerTechEntries == NULL)

	cmp	DWORD PTR _pMyPlayerTechEntries$[ebp], 0
	jne	SHORT $LN18@GetNumTrad@2

; 4175 : 		return 0;

	xor	eax, eax
	jmp	$LN20@GetNumTrad@2
$LN18@GetNumTrad@2:

; 4176 : 
; 4177 : #ifdef AUI_WARNING_FIXES
; 4178 : 	for (uint iTechLoop = 0; iTechLoop < pMyPlayerTechEntries->GetNumTechs(); iTechLoop++)
; 4179 : #else
; 4180 : 	for(int iTechLoop = 0; iTechLoop < pMyPlayerTechEntries->GetNumTechs(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$221433[ebp], 0
	jmp	SHORT $LN17@GetNumTrad@2
$LN16@GetNumTrad@2:
	mov	eax, DWORD PTR _iTechLoop$221433[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$221433[ebp], eax
$LN17@GetNumTrad@2:
	mov	ecx, DWORD PTR _pMyPlayerTechEntries$[ebp]
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTechLoop$221433[ebp], eax
	jge	SHORT $LN36@GetNumTrad@2

; 4181 : #endif
; 4182 : 	{
; 4183 : 		TechTypes eTech = (TechTypes)iTechLoop;

	mov	ecx, DWORD PTR _iTechLoop$221433[ebp]
	mov	DWORD PTR _eTech$221437[ebp], ecx

; 4184 : 		if (!pMyTeamTechs->HasTech(eTech))

	mov	edx, DWORD PTR _eTech$221437[ebp]
	push	edx
	mov	ecx, DWORD PTR _pMyTeamTechs$[ebp]
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@GetNumTrad@2

; 4185 : 		{
; 4186 : 			continue;

	jmp	SHORT $LN16@GetNumTrad@2
$LN14@GetNumTrad@2:

; 4187 : 		}
; 4188 : 
; 4189 : 		pTechInfo = pMyPlayerTechEntries->GetEntry(eTech);

	mov	ecx, DWORD PTR _eTech$221437[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pMyPlayerTechEntries$[ebp]
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
	mov	DWORD PTR _pTechInfo$[ebp], eax

; 4190 : 		CvAssertMsg(pTechInfo, "null tech entry");
; 4191 : 		if (pTechInfo)

	cmp	DWORD PTR _pTechInfo$[ebp], 0
	je	SHORT $LN13@GetNumTrad@2

; 4192 : 		{
; 4193 : 			iNumRoutes += pTechInfo->GetNumInternationalTradeRoutesChange();

	mov	ecx, DWORD PTR _pTechInfo$[ebp]
	call	?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetNumInternationalTradeRoutesChange
	add	eax, DWORD PTR _iNumRoutes$[ebp]
	mov	DWORD PTR _iNumRoutes$[ebp], eax
$LN13@GetNumTrad@2:

; 4194 : 		}
; 4195 : 	}

	jmp	SHORT $LN16@GetNumTrad@2

; 4196 : 
; 4197 : #ifdef NQ_EXTRA_TRADE_ROUTES_FROM_BELIEF
; 4198 : 	ReligionTypes eFoundedReligion = GC.getGame().GetGameReligions()->GetFounderBenefitsReligion(m_pPlayer->GetID());

$LN36@GetNumTrad@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+79104]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T235405[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235409[ebp], edx
	mov	eax, DWORD PTR $T235405[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235409[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetFounderBenefitsReligion@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetFounderBenefitsReligion
	mov	DWORD PTR _eFoundedReligion$[ebp], eax

; 4199 : 	if (eFoundedReligion && eFoundedReligion != NO_RELIGION)

	cmp	DWORD PTR _eFoundedReligion$[ebp], 0
	je	SHORT $LN12@GetNumTrad@2
	cmp	DWORD PTR _eFoundedReligion$[ebp], -1
	je	SHORT $LN12@GetNumTrad@2

; 4200 : 	{
; 4201 : 		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eFoundedReligion, NO_PLAYER);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235413[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _eFoundedReligion$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235413[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$221443[ebp], eax

; 4202 : 		iNumRoutes += pReligion->m_Beliefs.GetExtraTradeRoutes();

	mov	eax, DWORD PTR _pReligion$221443[ebp]
	mov	ecx, DWORD PTR [eax+224]
	mov	DWORD PTR $T235417[ebp], ecx
	mov	edx, DWORD PTR _iNumRoutes$[ebp]
	add	edx, DWORD PTR $T235417[ebp]
	mov	DWORD PTR _iNumRoutes$[ebp], edx
$LN12@GetNumTrad@2:

; 4203 : 	}
; 4204 : #endif
; 4205 : 
; 4206 : 	CvCivilizationInfo& kCivInfo = m_pPlayer->getCivilizationInfo();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	DWORD PTR _kCivInfo$[ebp], eax

; 4207 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[ebp], 0

; 4208 : 	CvCity* pLoopCity;
; 4209 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN11@GetNumTrad@2
$LN10@GetNumTrad@2:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN11@GetNumTrad@2:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN9@GetNumTrad@2

; 4210 : 	{
; 4211 : #ifdef AUI_WARNING_FIXES
; 4212 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4213 : #else
; 4214 : 		for (int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$221450[ebp], 0
	jmp	SHORT $LN8@GetNumTrad@2
$LN7@GetNumTrad@2:
	mov	edx, DWORD PTR _iI$221450[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$221450[ebp], edx
$LN8@GetNumTrad@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$221450[ebp], eax
	jge	SHORT $LN6@GetNumTrad@2

; 4215 : #endif
; 4216 : 		{
; 4217 : 			BuildingTypes eBuilding = (BuildingTypes)kCivInfo.getCivilizationBuildings(iI);

	mov	eax, DWORD PTR _iI$221450[ebp]
	push	eax
	mov	ecx, DWORD PTR _kCivInfo$[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$221454[ebp], eax

; 4218 : 			if(eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$221454[ebp], -1
	je	SHORT $LN5@GetNumTrad@2

; 4219 : 			{
; 4220 : 				CvBuildingEntry* pBuildingEntry = GC.GetGameBuildings()->GetEntry(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$221454[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	ecx, eax
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pBuildingEntry$221457[ebp], eax

; 4221 : 				if (!pBuildingEntry)

	cmp	DWORD PTR _pBuildingEntry$221457[ebp], 0
	jne	SHORT $LN4@GetNumTrad@2

; 4222 : 				{
; 4223 : 					continue;

	jmp	SHORT $LN7@GetNumTrad@2
$LN4@GetNumTrad@2:

; 4224 : 				}
; 4225 : 
; 4226 : 				if (pBuildingEntry)

	cmp	DWORD PTR _pBuildingEntry$221457[ebp], 0
	je	SHORT $LN5@GetNumTrad@2

; 4227 : 				{
; 4228 : 					if (pLoopCity->GetCityBuildings()->GetNumBuilding((BuildingTypes)pBuildingEntry->GetID()))

	mov	edx, DWORD PTR _pBuildingEntry$221457[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235421[ebp], eax
	mov	ecx, DWORD PTR $T235421[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	je	SHORT $LN5@GetNumTrad@2

; 4229 : 					{
; 4230 : 						int iNumRouteBonus = pBuildingEntry->GetNumTradeRouteBonus();

	mov	ecx, DWORD PTR _pBuildingEntry$221457[ebp]
	call	?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetNumTradeRouteBonus
	mov	DWORD PTR _iNumRouteBonus$221462[ebp], eax

; 4231 : 						if (iNumRouteBonus != 0)

	cmp	DWORD PTR _iNumRouteBonus$221462[ebp], 0
	je	SHORT $LN5@GetNumTrad@2

; 4232 : 						{
; 4233 : 							iNumRoutes += iNumRouteBonus;

	mov	edx, DWORD PTR _iNumRoutes$[ebp]
	add	edx, DWORD PTR _iNumRouteBonus$221462[ebp]
	mov	DWORD PTR _iNumRoutes$[ebp], edx
$LN5@GetNumTrad@2:

; 4234 : 						}
; 4235 : 					}
; 4236 : 				}
; 4237 : 			}
; 4238 : 		}

	jmp	$LN7@GetNumTrad@2
$LN6@GetNumTrad@2:

; 4239 : 	}

	jmp	$LN10@GetNumTrad@2
$LN9@GetNumTrad@2:

; 4240 : 
; 4241 : 	int iModifier = 100 + m_pPlayer->GetPlayerTraits()->GetNumTradeRoutesModifier();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T235425[ebp], eax
	mov	ecx, DWORD PTR $T235425[ebp]
	mov	edx, DWORD PTR [ecx+292]
	mov	DWORD PTR $T235426[ebp], edx
	mov	eax, DWORD PTR $T235426[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR _iModifier$[ebp], eax

; 4242 : 	iNumRoutes *= iModifier;

	mov	ecx, DWORD PTR _iNumRoutes$[ebp]
	imul	ecx, DWORD PTR _iModifier$[ebp]
	mov	DWORD PTR _iNumRoutes$[ebp], ecx

; 4243 : 	iNumRoutes /= 100;

	mov	eax, DWORD PTR _iNumRoutes$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iNumRoutes$[ebp], eax

; 4244 : 
; 4245 : 	return iNumRoutes;

	mov	eax, DWORD PTR _iNumRoutes$[ebp]
$LN20@GetNumTrad@2:

; 4246 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ENDP	; CvPlayerTrade::GetNumTradeRoutesPossible
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z	; CvPlayerTrade::GetNumTradeRoutesUsed
EXTRN	?getNumTrainUnitAI@CvCity@@QBEHW4UnitAITypes@@@Z:PROC ; CvCity::getNumTrainUnitAI
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
; Function compile flags: /Odtp
;	COMDAT ?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_pLoopCity$221477 = -16					; size = 4
_iReturnValue$ = -12					; size = 4
_pLoopUnit$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_bContinueTraining$ = 8					; size = 1
?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z PROC	; CvPlayerTrade::GetNumTradeRoutesUsed, COMDAT
; _this$ = ecx

; 4254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4255 : 	int iReturnValue = 0;

	mov	DWORD PTR _iReturnValue$[ebp], 0

; 4256 : 	int iLoop;
; 4257 : 
; 4258 : 	// look for units on the map
; 4259 : 	CvUnit* pLoopUnit;
; 4260 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN8@GetNumTrad@3
$LN7@GetNumTrad@3:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN8@GetNumTrad@3:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN6@GetNumTrad@3

; 4261 : 	{
; 4262 : 		if (pLoopUnit->isTrade())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@GetNumTrad@3

; 4263 : 		{
; 4264 : 			iReturnValue++;

	mov	edx, DWORD PTR _iReturnValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _iReturnValue$[ebp], edx
$LN5@GetNumTrad@3:

; 4265 : 		}
; 4266 : 	}

	jmp	SHORT $LN7@GetNumTrad@3
$LN6@GetNumTrad@3:

; 4267 : 
; 4268 : 	// look inside cities
; 4269 : 	if (!bContinueTraining)

	movzx	eax, BYTE PTR _bContinueTraining$[ebp]
	test	eax, eax
	jne	SHORT $LN4@GetNumTrad@3

; 4270 : 	{
; 4271 : 		CvCity* pLoopCity;
; 4272 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+79104]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$221477[ebp], eax
	jmp	SHORT $LN3@GetNumTrad@3
$LN2@GetNumTrad@3:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+79104]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$221477[ebp], eax
$LN3@GetNumTrad@3:
	cmp	DWORD PTR _pLoopCity$221477[ebp], 0
	je	SHORT $LN4@GetNumTrad@3

; 4273 : 		{
; 4274 : 			iReturnValue += pLoopCity->getNumTrainUnitAI(UNITAI_TRADE_UNIT);

	push	38					; 00000026H
	mov	ecx, DWORD PTR _pLoopCity$221477[ebp]
	call	?getNumTrainUnitAI@CvCity@@QBEHW4UnitAITypes@@@Z ; CvCity::getNumTrainUnitAI
	add	eax, DWORD PTR _iReturnValue$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 4275 : 		}

	jmp	SHORT $LN2@GetNumTrad@3
$LN4@GetNumTrad@3:

; 4276 : 	}
; 4277 : 
; 4278 : 	return iReturnValue;

	mov	eax, DWORD PTR _iReturnValue$[ebp]

; 4279 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z ENDP	; CvPlayerTrade::GetNumTradeRoutesUsed
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesRemaining
; Function compile flags: /Odtp
;	COMDAT ?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bContinueTraining$ = 8					; size = 1
?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z PROC ; CvPlayerTrade::GetNumTradeRoutesRemaining, COMDAT
; _this$ = ecx

; 4288 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4289 : 	return (GetNumTradeRoutesPossible() - GetNumTradeRoutesUsed(bContinueTraining));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
	mov	esi, eax
	movzx	eax, BYTE PTR _bContinueTraining$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesUsed
	sub	esi, eax
	mov	eax, esi

; 4290 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumTradeRoutesRemaining@CvPlayerTrade@@QAEH_N@Z ENDP ; CvPlayerTrade::GetNumTradeRoutesRemaining
_TEXT	ENDS
PUBLIC	?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z ; CvPlayerTrade::GetNumForeignTradeRoutes
; Function compile flags: /Odtp
;	COMDAT ?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T235440 = -24						; size = 4
$T235436 = -20						; size = 4
_pTradeConnection$221496 = -16				; size = 4
_ui$221491 = -12					; size = 4
_iResult$ = -8						; size = 4
_pTrade$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z PROC ; CvPlayerTrade::GetNumForeignTradeRoutes, COMDAT
; _this$ = ecx

; 4295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4296 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235436[ebp], eax
	mov	ecx, DWORD PTR $T235436[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 4297 : 	int iResult = 0;

	mov	DWORD PTR _iResult$[ebp], 0

; 4298 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$221491[ebp], 0
	jmp	SHORT $LN5@GetNumFore
$LN4@GetNumFore:
	mov	ecx, DWORD PTR _ui$221491[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$221491[ebp], ecx
$LN5@GetNumFore:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235440[ebp], eax
	mov	ecx, DWORD PTR _ui$221491[ebp]
	cmp	ecx, DWORD PTR $T235440[ebp]
	jae	SHORT $LN3@GetNumFore

; 4299 : 	{
; 4300 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	edx, DWORD PTR _ui$221491[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@GetNumFore

; 4301 : 		{
; 4302 : 			continue;

	jmp	SHORT $LN4@GetNumFore

; 4303 : 		}
; 4304 : 		TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);

$LN12@GetNumFore:
	mov	ecx, DWORD PTR _ui$221491[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _pTrade$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _pTradeConnection$221496[ebp], ecx

; 4305 : 		if (pTradeConnection->m_eOriginOwner == ePlayer && pTradeConnection->m_eOriginOwner != pTradeConnection->m_eDestOwner)

	mov	eax, DWORD PTR _pTradeConnection$221496[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN1@GetNumFore
	mov	edx, DWORD PTR _pTradeConnection$221496[ebp]
	mov	eax, DWORD PTR _pTradeConnection$221496[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+24]
	je	SHORT $LN1@GetNumFore

; 4306 : 		{
; 4307 : 			iResult++;

	mov	edx, DWORD PTR _iResult$[ebp]
	add	edx, 1
	mov	DWORD PTR _iResult$[ebp], edx
$LN1@GetNumFore:

; 4308 : 		}
; 4309 : 	}

	jmp	SHORT $LN4@GetNumFore
$LN3@GetNumFore:

; 4310 : 	return iResult;

	mov	eax, DWORD PTR _iResult$[ebp]

; 4311 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumForeignTradeRoutes@CvPlayerTrade@@QAEHW4PlayerTypes@@@Z ENDP ; CvPlayerTrade::GetNumForeignTradeRoutes
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
PUBLIC	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumDifferentTradingPartners
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$5
__ehfuncinfo$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
_TEXT	SEGMENT
tv490 = -444						; size = 4
tv477 = -440						; size = 4
tv374 = -436						; size = 4
tv367 = -432						; size = 4
tv204 = -428						; size = 4
_this$ = -424						; size = 4
$T236054 = -420						; size = 4
$T235995 = -388						; size = 4
$T235979 = -384						; size = 4
$T235972 = -380						; size = 4
$T235889 = -332						; size = 4
$T235879 = -328						; size = 4
$T235796 = -280						; size = 4
$T235762 = -276						; size = 4
__Tmp$235755 = -272					; size = 8
$T235708 = -264						; size = 4
$T235686 = -260						; size = 4
$T235740 = -256						; size = 4
$T235738 = -252						; size = 8
$T235737 = -244						; size = 8
$T235662 = -236						; size = 4
$T235657 = -232						; size = 4
__Tmp$235650 = -228					; size = 8
$T235603 = -220						; size = 4
$T235581 = -216						; size = 4
$T235635 = -212						; size = 4
$T235633 = -208						; size = 8
$T235632 = -200						; size = 8
$T235566 = -192						; size = 4
$T235554 = -188						; size = 4
$T235467 = -97						; size = 1
$T235463 = -96						; size = 4
$T235455 = -88						; size = 4
$T235450 = -84						; size = 4
$T235449 = -80						; size = 8
$T235448 = -72						; size = 8
$T235447 = -64						; size = 8
$T235446 = -56						; size = 8
_pTradeConnection$221514 = -48				; size = 4
_ui$221509 = -44					; size = 4
_iResult$ = -40						; size = 4
_pTrade$ = -36						; size = 4
_abConnections$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ PROC ; CvPlayerTrade::GetNumDifferentTradingPartners, COMDAT
; _this$ = ecx

; 4320 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 432				; 000001b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4321 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235455[ebp], eax
	mov	ecx, DWORD PTR $T235455[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 4322 : 
; 4323 : #ifdef AUI_TRADE_FIX_GET_NUM_DIFFERENT_TRADING_PARTNERS_USES_ARRAY
; 4324 : 	bool abConnections[MAX_CIV_PLAYERS] = {};
; 4325 : #else
; 4326 : 	std::vector<bool> abConnections;

	lea	ecx, DWORD PTR $T235467[ebp]
	mov	DWORD PTR $T235463[ebp], ecx
	lea	edx, DWORD PTR _abConnections$[ebp]
	mov	DWORD PTR tv204[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR _abConnections$[ebp], 0
	lea	ecx, DWORD PTR _abConnections$[ebp+4]
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4327 : 	abConnections.resize(MAX_CIV_PLAYERS, false);

	push	0
	push	63					; 0000003fH
	lea	ecx, DWORD PTR _abConnections$[ebp]
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 4328 : #endif
; 4329 : 
; 4330 : 	int iResult = 0;

	mov	DWORD PTR _iResult$[ebp], 0

; 4331 : 
; 4332 : #ifdef AUI_ITERATORIZE
; 4333 : 	for (TradeConnectionList::const_iterator pTradeConnection = pTrade->m_aTradeConnections.begin(); pTradeConnection != pTrade->m_aTradeConnections.end(); ++pTradeConnection)
; 4334 : 	{
; 4335 : 		if (pTrade->IsTradeRouteIndexEmpty(pTradeConnection))
; 4336 : #else
; 4337 : 	for (uint ui = 0; ui < pTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$221509[ebp], 0
	jmp	SHORT $LN10@GetNumDiff
$LN9@GetNumDiff:
	mov	eax, DWORD PTR _ui$221509[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$221509[ebp], eax
$LN10@GetNumDiff:
	mov	ecx, DWORD PTR _pTrade$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235554[ebp], edx
	mov	eax, DWORD PTR _ui$221509[ebp]
	cmp	eax, DWORD PTR $T235554[ebp]
	jae	$LN8@GetNumDiff

; 4338 : 	{
; 4339 : 		if (pTrade->IsTradeRouteIndexEmpty(ui))

	mov	ecx, DWORD PTR _ui$221509[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN55@GetNumDiff

; 4340 : #endif
; 4341 : 		{
; 4342 : 			continue;

	jmp	SHORT $LN9@GetNumDiff

; 4343 : 		}
; 4344 : 
; 4345 : #ifndef AUI_ITERATORIZE
; 4346 : #ifdef AUI_CONSTIFY
; 4347 : 		const TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);
; 4348 : #else
; 4349 : 		TradeConnection* pTradeConnection = &(pTrade->m_aTradeConnections[ui]);

$LN55@GetNumDiff:
	mov	eax, DWORD PTR _ui$221509[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _pTrade$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pTradeConnection$221514[ebp], eax

; 4350 : #endif
; 4351 : #endif
; 4352 : 		if (pTradeConnection->m_eOriginOwner == pTradeConnection->m_eDestOwner)

	mov	edx, DWORD PTR _pTradeConnection$221514[ebp]
	mov	eax, DWORD PTR _pTradeConnection$221514[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN59@GetNumDiff

; 4353 : 		{
; 4354 : 			continue;

	jmp	SHORT $LN9@GetNumDiff

; 4355 : 		}
; 4356 : 
; 4357 : 		// this involves us
; 4358 : 		if (pTradeConnection->m_eOriginOwner == m_pPlayer->GetID())

$LN59@GetNumDiff:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+79104]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T235566[ebp], ecx
	mov	edx, DWORD PTR _pTradeConnection$221514[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR $T235566[ebp]
	jne	$LN125@GetNumDiff

; 4359 : 		{
; 4360 : 			if (!abConnections[pTradeConnection->m_eDestOwner])

	mov	ecx, DWORD PTR _pTradeConnection$221514[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR $T235657[ebp], edx
	mov	eax, DWORD PTR _abConnections$[ebp+8]
	mov	DWORD PTR $T235581[ebp], eax
	mov	ecx, DWORD PTR $T235581[ebp]
	mov	DWORD PTR $T235635[ebp], ecx
	mov	edx, DWORD PTR $T235635[ebp]
	mov	DWORD PTR $T235603[ebp], edx
	mov	eax, DWORD PTR $T235603[ebp]
	mov	DWORD PTR $T235632[ebp], eax
	mov	DWORD PTR $T235632[ebp+4], 0
	mov	ecx, DWORD PTR $T235632[ebp]
	mov	edx, DWORD PTR $T235632[ebp+4]
	mov	DWORD PTR __Tmp$235650[ebp], ecx
	mov	DWORD PTR __Tmp$235650[ebp+4], edx
	mov	eax, DWORD PTR $T235657[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$235650[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$235650[ebp]
	mov	edx, DWORD PTR __Tmp$235650[ebp+4]
	mov	DWORD PTR $T235633[ebp], ecx
	mov	DWORD PTR $T235633[ebp+4], edx
	lea	eax, DWORD PTR $T235633[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235446[ebp]
	call	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
	mov	ecx, DWORD PTR $T235446[ebp]
	mov	DWORD PTR $T235662[ebp], ecx
	mov	edx, 1
	mov	ecx, DWORD PTR $T235446[ebp+4]
	shl	edx, cl
	mov	eax, DWORD PTR $T235662[ebp]
	and	edx, DWORD PTR [eax]
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	ecx, dl
	test	ecx, ecx
	jne	$LN4@GetNumDiff

; 4361 : 			{
; 4362 : 				abConnections[pTradeConnection->m_eDestOwner] = true;

	mov	edx, DWORD PTR _pTradeConnection$221514[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T235762[ebp], eax
	mov	ecx, DWORD PTR _abConnections$[ebp+8]
	mov	DWORD PTR $T235686[ebp], ecx
	mov	edx, DWORD PTR $T235686[ebp]
	mov	DWORD PTR $T235740[ebp], edx
	mov	eax, DWORD PTR $T235740[ebp]
	mov	DWORD PTR $T235708[ebp], eax
	mov	ecx, DWORD PTR $T235708[ebp]
	mov	DWORD PTR $T235737[ebp], ecx
	mov	DWORD PTR $T235737[ebp+4], 0
	mov	edx, DWORD PTR $T235737[ebp]
	mov	eax, DWORD PTR $T235737[ebp+4]
	mov	DWORD PTR __Tmp$235755[ebp], edx
	mov	DWORD PTR __Tmp$235755[ebp+4], eax
	mov	ecx, DWORD PTR $T235762[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$235755[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$235755[ebp]
	mov	eax, DWORD PTR __Tmp$235755[ebp+4]
	mov	DWORD PTR $T235738[ebp], edx
	mov	DWORD PTR $T235738[ebp+4], eax
	lea	ecx, DWORD PTR $T235738[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T235447[ebp]
	call	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN119@GetNumDiff
	mov	eax, DWORD PTR $T235447[ebp]
	mov	DWORD PTR tv367[ebp], eax
	mov	edx, 1
	mov	ecx, DWORD PTR $T235447[ebp+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv367[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv367[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN113@GetNumDiff
$LN119@GetNumDiff:
	mov	edx, DWORD PTR $T235447[ebp]
	mov	DWORD PTR tv374[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR $T235447[ebp+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv374[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv374[ebp]
	mov	DWORD PTR [edx], eax
$LN113@GetNumDiff:

; 4363 : 				iResult++;

	mov	eax, DWORD PTR _iResult$[ebp]
	add	eax, 1
	mov	DWORD PTR _iResult$[ebp], eax
$LN4@GetNumDiff:

; 4364 : 			}
; 4365 : 		}

	jmp	$LN3@GetNumDiff

; 4366 : 		else if (pTradeConnection->m_eDestOwner == m_pPlayer->GetID())

$LN125@GetNumDiff:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+79104]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235796[ebp], eax
	mov	ecx, DWORD PTR _pTradeConnection$221514[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR $T235796[ebp]
	jne	$LN3@GetNumDiff

; 4367 : 		{
; 4368 : 			if (!abConnections[pTradeConnection->m_eOriginOwner])

	mov	eax, DWORD PTR _pTradeConnection$221514[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	lea	edx, DWORD PTR $T235448[ebp]
	push	edx
	lea	ecx, DWORD PTR _abConnections$[ebp]
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T235889[ebp], eax
	mov	eax, DWORD PTR $T235889[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235879[ebp], ecx
	mov	edx, DWORD PTR $T235889[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	mov	ecx, DWORD PTR $T235879[ebp]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	edx, al
	test	edx, edx
	jne	$LN3@GetNumDiff

; 4369 : 			{
; 4370 : 				abConnections[pTradeConnection->m_eOriginOwner] = true;

	mov	eax, DWORD PTR _pTradeConnection$221514[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	lea	edx, DWORD PTR $T235449[ebp]
	push	edx
	lea	ecx, DWORD PTR _abConnections$[ebp]
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T235995[ebp], eax
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN186@GetNumDiff
	mov	ecx, DWORD PTR $T235972[ebp]
	mov	DWORD PTR tv477[ebp], ecx
	mov	edx, DWORD PTR $T235995[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv477[ebp], eax
	mov	ecx, DWORD PTR $T235995[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv477[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv477[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN187@GetNumDiff
$LN186@GetNumDiff:
	mov	edx, DWORD PTR $T235979[ebp]
	mov	DWORD PTR tv490[ebp], edx
	mov	eax, DWORD PTR $T235995[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv490[ebp], ecx
	mov	edx, DWORD PTR $T235995[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv490[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv490[ebp]
	mov	DWORD PTR [edx], eax
$LN187@GetNumDiff:

; 4371 : 				iResult++;

	mov	eax, DWORD PTR _iResult$[ebp]
	add	eax, 1
	mov	DWORD PTR _iResult$[ebp], eax
$LN3@GetNumDiff:

; 4372 : 			}
; 4373 : 		}
; 4374 : 	}

	jmp	$LN9@GetNumDiff
$LN8@GetNumDiff:

; 4375 : 
; 4376 : 	return iResult;

	mov	ecx, DWORD PTR _iResult$[ebp]
	mov	DWORD PTR $T235450[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR _abConnections$[ebp], 0
	lea	edx, DWORD PTR _abConnections$[ebp+4]
	mov	DWORD PTR $T236054[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T236054[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T235450[ebp]

; 4377 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$1:
	lea	ecx, DWORD PTR _abConnections$[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$0:
	lea	ecx, DWORD PTR _abConnections$[ebp]
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$3:
	lea	ecx, DWORD PTR _abConnections$[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ$5:
	mov	ecx, DWORD PTR $T236054[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetNumDifferentTradingPartners@CvPlayerTrade@@QAEHXZ ENDP ; CvPlayerTrade::GetNumDifferentTradingPartners
; Function compile flags: /Odtp
;	COMDAT ?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T236087 = -20						; size = 4
$T236083 = -16						; size = 4
$T236079 = -12						; size = 4
_ui$221530 = -8						; size = 4
_iTurnsUntilForget$ = -4				; size = 4
?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ PROC ; CvPlayerTrade::UpdateTradeConnectionWasPlundered, COMDAT
; _this$ = ecx

; 4381 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4382 : 	int iTurnsUntilForget = 30;

	mov	DWORD PTR _iTurnsUntilForget$[ebp], 30	; 0000001eH

; 4383 : #ifdef AUI_ITERATORIZE
; 4384 : 	for (TradeConnectionWasPlunderedList::iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4385 : 	{
; 4386 : 		if ((it->m_iTurnPlundered + iTurnsUntilForget) <= GC.getGame().getGameTurn())
; 4387 : 		{
; 4388 : 			// erasing entry to make sure vector doesn't get bigger than it should
; 4389 : 			m_aTradeConnectionWasPlundered.erase(it);
; 4390 : 			--it;
; 4391 : #else
; 4392 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	mov	DWORD PTR _ui$221530[ebp], 0
	jmp	SHORT $LN4@UpdateTrad@2
$LN3@UpdateTrad@2:
	mov	eax, DWORD PTR _ui$221530[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$221530[ebp], eax
$LN4@UpdateTrad@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+74612]
	mov	DWORD PTR $T236079[ebp], edx
	mov	eax, DWORD PTR _ui$221530[ebp]
	cmp	eax, DWORD PTR $T236079[ebp]
	jae	SHORT $LN5@UpdateTrad@2

; 4393 : 	{
; 4394 : 		if ((m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered + iTurnsUntilForget) <= GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR _ui$221530[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+74608]
	mov	DWORD PTR $T236083[ebp], ecx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236087[ebp], eax
	mov	ecx, DWORD PTR $T236083[ebp]
	mov	esi, DWORD PTR [ecx+444]
	add	esi, DWORD PTR _iTurnsUntilForget$[ebp]
	mov	ecx, DWORD PTR $T236087[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jg	SHORT $LN1@UpdateTrad@2

; 4395 : 		{
; 4396 : 			// setting turn plundered to -1 to flag it as not counting
; 4397 : 			m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered = -1;

	mov	edx, DWORD PTR _ui$221530[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	mov	DWORD PTR [ecx+edx+444], -1
$LN1@UpdateTrad@2:

; 4398 : #endif
; 4399 : 		}

	jmp	SHORT $LN3@UpdateTrad@2
$LN5@UpdateTrad@2:

; 4400 : 	}
; 4401 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTradeConnectionWasPlundered@CvPlayerTrade@@QAEXXZ ENDP ; CvPlayerTrade::UpdateTradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	??1TradeConnectionWasPlundered@@QAE@XZ		; TradeConnectionWasPlundered::~TradeConnectionWasPlundered
PUBLIC	??4TradeConnection@@QAEAAU0@ABU0@@Z		; TradeConnection::operator=
PUBLIC	?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$1
__ehfuncinfo$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
_TEXT	SEGMENT
_this$ = -540						; size = 4
$T236162 = -512						; size = 4
$T236158 = -508						; size = 4
$T236119 = -488						; size = 4
$T236115 = -484						; size = 4
$T236099 = -480						; size = 4
_kWasPlundered$221546 = -476				; size = 448
_uiIndex$221547 = -28					; size = 4
_ui$221540 = -24					; size = 4
_bAdded$ = -17						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kTradeConnection$ = 8					; size = 444
?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z PROC ; CvPlayerTrade::AddTradeConnectionWasPlundered, COMDAT
; _this$ = ecx

; 4409 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4410 : 	bool bAdded = false;

	mov	BYTE PTR _bAdded$[ebp], 0

; 4411 : #ifdef AUI_ITERATORIZE
; 4412 : 	for (TradeConnectionWasPlunderedList::iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4413 : 	{
; 4414 : 		if (it->m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4415 : 			it->m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4416 : 			it->m_kTradeConnection.m_iDestX == kTradeConnection.m_iDestX &&
; 4417 : 			it->m_kTradeConnection.m_iDestY == kTradeConnection.m_iDestY)
; 4418 : 		{
; 4419 : 			it->m_iTurnPlundered = GC.getGame().getGameTurn();
; 4420 : #else
; 4421 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	mov	DWORD PTR _ui$221540[ebp], 0
	jmp	SHORT $LN5@AddTradeCo
$LN4@AddTradeCo:
	mov	eax, DWORD PTR _ui$221540[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$221540[ebp], eax
$LN5@AddTradeCo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+74612]
	mov	DWORD PTR $T236099[ebp], edx
	mov	eax, DWORD PTR _ui$221540[ebp]
	cmp	eax, DWORD PTR $T236099[ebp]
	jae	$LN3@AddTradeCo

; 4422 : 	{
; 4423 : 		if (m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4424 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4425 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestX   == kTradeConnection.m_iDestX &&
; 4426 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestY   == kTradeConnection.m_iDestY)

	mov	ecx, DWORD PTR _ui$221540[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	ecx, DWORD PTR [eax+ecx+4]
	cmp	ecx, DWORD PTR _kTradeConnection$[ebp+4]
	jne	$LN2@AddTradeCo
	mov	edx, DWORD PTR _ui$221540[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	mov	edx, DWORD PTR [ecx+edx+8]
	cmp	edx, DWORD PTR _kTradeConnection$[ebp+8]
	jne	$LN2@AddTradeCo
	mov	eax, DWORD PTR _ui$221540[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	mov	eax, DWORD PTR [edx+eax+12]
	cmp	eax, DWORD PTR _kTradeConnection$[ebp+12]
	jne	SHORT $LN2@AddTradeCo
	mov	ecx, DWORD PTR _ui$221540[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	ecx, DWORD PTR [eax+ecx+16]
	cmp	ecx, DWORD PTR _kTradeConnection$[ebp+16]
	jne	SHORT $LN2@AddTradeCo

; 4427 : 		{
; 4428 : 			m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered = GC.getGame().getGameTurn();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236115[ebp], edx
	mov	eax, DWORD PTR _ui$221540[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+74608]
	mov	DWORD PTR $T236119[ebp], eax
	mov	ecx, DWORD PTR $T236115[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	edx, DWORD PTR $T236119[ebp]
	mov	DWORD PTR [edx+444], eax

; 4429 : #endif
; 4430 : 			bAdded = true;

	mov	BYTE PTR _bAdded$[ebp], 1

; 4431 : 			break;

	jmp	SHORT $LN3@AddTradeCo
$LN2@AddTradeCo:

; 4432 : 		}
; 4433 : 	}

	jmp	$LN4@AddTradeCo
$LN3@AddTradeCo:

; 4434 : 
; 4435 : 	if (!bAdded)

	movzx	eax, BYTE PTR _bAdded$[ebp]
	test	eax, eax
	jne	$LN1@AddTradeCo

; 4436 : 	{
; 4437 : 		TradeConnectionWasPlundered kWasPlundered;

	lea	ecx, DWORD PTR _kWasPlundered$221546[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4438 : #ifdef AUI_ITERATORIZE
; 4439 : 		m_aTradeConnectionWasPlundered.push_back(kWasPlundered);
; 4440 : 		const TradeConnectionWasPlunderedList::iterator it = m_aTradeConnectionWasPlundered.end() - 1;
; 4441 : 		it->m_kTradeConnection = kTradeConnection;
; 4442 : 		it->m_iTurnPlundered = GC.getGame().getGameTurn();
; 4443 : #else
; 4444 : 		uint uiIndex = m_aTradeConnectionWasPlundered.size();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+74612]
	mov	DWORD PTR _uiIndex$221547[ebp], edx

; 4445 : 		m_aTradeConnectionWasPlundered.push_back(kWasPlundered);

	lea	eax, DWORD PTR _kWasPlundered$221546[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 74608				; 00012370H
	call	?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back

; 4446 : 		m_aTradeConnectionWasPlundered[uiIndex].m_kTradeConnection = kTradeConnection;

	lea	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _uiIndex$221547[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+74608]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 4447 : 		m_aTradeConnectionWasPlundered[uiIndex].m_iTurnPlundered = GC.getGame().getGameTurn();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236158[ebp], eax
	mov	ecx, DWORD PTR _uiIndex$221547[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+74608]
	mov	DWORD PTR $T236162[ebp], ecx
	mov	ecx, DWORD PTR $T236158[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR $T236162[ebp]
	mov	DWORD PTR [ecx+444], eax

; 4448 : #endif
; 4449 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _kWasPlundered$221546[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
$LN1@AddTradeCo:

; 4450 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kTradeConnection$[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	444					; 000001bcH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$0:
	lea	ecx, DWORD PTR _kTradeConnection$[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z$1:
	lea	ecx, DWORD PTR _kWasPlundered$221546[ebp]
	jmp	??1TradeConnectionWasPlundered@@QAE@XZ
__ehhandler$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-532]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddTradeConnectionWasPlundered@CvPlayerTrade@@QAEXUTradeConnection@@@Z ENDP ; CvPlayerTrade::AddTradeConnectionWasPlundered
; Function compile flags: /Odtp
;	COMDAT ??1TradeConnectionWasPlundered@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1TradeConnectionWasPlundered@@QAE@XZ PROC		; TradeConnectionWasPlundered::~TradeConnectionWasPlundered, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1TradeConnectionWasPlundered@@QAE@XZ ENDP		; TradeConnectionWasPlundered::~TradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4TradeConnection@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
_$S2$221559 = -8					; size = 4
_$S1$221555 = -4					; size = 4
___that$ = 8						; size = 4
??4TradeConnection@@QAEAAU0@ABU0@@Z PROC		; TradeConnection::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+40]
	mov	BYTE PTR [eax+40], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+380]
	mov	DWORD PTR [ecx+380], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+384]
	mov	DWORD PTR [ecx+384], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR [ecx+388], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+392]
	mov	DWORD PTR [ecx+392], eax
	mov	DWORD PTR _$S1$221555[ebp], 0
	jmp	SHORT $LN6@operator@3
$LN5@operator@3:
	mov	ecx, DWORD PTR _$S1$221555[ebp]
	add	ecx, 1
	mov	DWORD PTR _$S1$221555[ebp], ecx
$LN6@operator@3:
	cmp	DWORD PTR _$S1$221555[ebp], 6
	jae	SHORT $LN4@operator@3
	mov	edx, DWORD PTR _$S1$221555[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _$S1$221555[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+396]
	mov	DWORD PTR [eax+edx*4+396], ecx
	jmp	SHORT $LN5@operator@3
$LN4@operator@3:
	mov	DWORD PTR _$S2$221559[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	edx, DWORD PTR _$S2$221559[ebp]
	add	edx, 1
	mov	DWORD PTR _$S2$221559[ebp], edx
$LN3@operator@3:
	cmp	DWORD PTR _$S2$221559[ebp], 6
	jae	SHORT $LN1@operator@3
	mov	eax, DWORD PTR _$S2$221559[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S2$221559[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+420]
	mov	DWORD PTR [ecx+eax*4+420], edx
	jmp	SHORT $LN2@operator@3
$LN1@operator@3:
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4TradeConnection@@QAEAAU0@ABU0@@Z ENDP		; TradeConnection::operator=
_TEXT	ENDS
PUBLIC	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
; Function compile flags: /Odtp
;	COMDAT ?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T236323 = -8						; size = 4
_ui$221567 = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z PROC ; CvPlayerTrade::CheckTradeConnectionWasPlundered, COMDAT
; _this$ = ecx

; 4458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4459 : #ifdef AUI_ITERATORIZE
; 4460 : 	for (TradeConnectionWasPlunderedList::const_iterator it = m_aTradeConnectionWasPlundered.begin(); it != m_aTradeConnectionWasPlundered.end(); ++it)
; 4461 : 	{
; 4462 : 		if (it->m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4463 : 			it->m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4464 : 			it->m_kTradeConnection.m_iDestX == kTradeConnection.m_iDestX &&
; 4465 : 			it->m_kTradeConnection.m_iDestY == kTradeConnection.m_iDestY &&
; 4466 : 			it->m_iTurnPlundered != -1)
; 4467 : #else
; 4468 : 	for (uint ui = 0; ui < m_aTradeConnectionWasPlundered.size(); ui++)

	mov	DWORD PTR _ui$221567[ebp], 0
	jmp	SHORT $LN4@CheckTrade
$LN3@CheckTrade:
	mov	eax, DWORD PTR _ui$221567[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$221567[ebp], eax
$LN4@CheckTrade:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+74612]
	mov	DWORD PTR $T236323[ebp], edx
	mov	eax, DWORD PTR _ui$221567[ebp]
	cmp	eax, DWORD PTR $T236323[ebp]
	jae	$LN2@CheckTrade

; 4469 : 	{
; 4470 : 		if (m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginX == kTradeConnection.m_iOriginX &&
; 4471 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginY == kTradeConnection.m_iOriginY &&
; 4472 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestX   == kTradeConnection.m_iDestX &&
; 4473 : 			m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestY   == kTradeConnection.m_iDestY &&
; 4474 : 			m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered != -1)

	mov	ecx, DWORD PTR _ui$221567[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [eax+ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN1@CheckTrade
	mov	ecx, DWORD PTR _ui$221567[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [eax+ecx+8]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN1@CheckTrade
	mov	ecx, DWORD PTR _ui$221567[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [eax+ecx+12]
	cmp	eax, DWORD PTR [edx+12]
	jne	SHORT $LN1@CheckTrade
	mov	ecx, DWORD PTR _ui$221567[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [eax+ecx+16]
	cmp	eax, DWORD PTR [edx+16]
	jne	SHORT $LN1@CheckTrade
	mov	ecx, DWORD PTR _ui$221567[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	cmp	DWORD PTR [eax+ecx+444], -1
	je	SHORT $LN1@CheckTrade

; 4475 : #endif
; 4476 : 		{
; 4477 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@CheckTrade
$LN1@CheckTrade:

; 4478 : 		}
; 4479 : 	}

	jmp	$LN3@CheckTrade
$LN2@CheckTrade:

; 4480 : 
; 4481 : 	return false;

	xor	al, al
$LN5@CheckTrade:

; 4482 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ENDP ; CvPlayerTrade::CheckTradeConnectionWasPlundered
_TEXT	ENDS
PUBLIC	??_C@_0BA@EKJHCOP@UNIT_CARGO_SHIP?$AA@		; `string'
PUBLIC	??_C@_0N@BNBCGAMK@UNIT_CARAVAN?$AA@		; `string'
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
;	COMDAT ??_C@_0BA@EKJHCOP@UNIT_CARGO_SHIP?$AA@
CONST	SEGMENT
??_C@_0BA@EKJHCOP@UNIT_CARGO_SHIP?$AA@ DB 'UNIT_CARGO_SHIP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNBCGAMK@UNIT_CARAVAN?$AA@
CONST	SEGMENT
??_C@_0N@BNBCGAMK@UNIT_CARAVAN?$AA@ DB 'UNIT_CARAVAN', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z
_TEXT	SEGMENT
_eUnitType$ = -4					; size = 4
_eDomain$ = 8						; size = 4
?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z PROC ; CvPlayerTrade::GetTradeUnit, COMDAT

; 4486 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4487 : 	UnitTypes eUnitType = NO_UNIT;

	mov	DWORD PTR _eUnitType$[ebp], -1

; 4488 : 	if (eDomain == DOMAIN_LAND)

	cmp	DWORD PTR _eDomain$[ebp], 2
	jne	SHORT $LN3@GetTradeUn@2

; 4489 : 	{
; 4490 : 		eUnitType = (UnitTypes)GC.getInfoTypeForString("UNIT_CARAVAN");

	push	0
	push	OFFSET ??_C@_0N@BNBCGAMK@UNIT_CARAVAN?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eUnitType$[ebp], eax
	jmp	SHORT $LN2@GetTradeUn@2
$LN3@GetTradeUn@2:

; 4491 : 	}
; 4492 : 	else if (eDomain == DOMAIN_SEA)

	cmp	DWORD PTR _eDomain$[ebp], 0
	jne	SHORT $LN2@GetTradeUn@2

; 4493 : 	{
; 4494 : 		eUnitType = (UnitTypes)GC.getInfoTypeForString("UNIT_CARGO_SHIP");

	push	0
	push	OFFSET ??_C@_0BA@EKJHCOP@UNIT_CARGO_SHIP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eUnitType$[ebp], eax
$LN2@GetTradeUn@2:

; 4495 : 	}
; 4496 : 
; 4497 : 	return eUnitType;

	mov	eax, DWORD PTR _eUnitType$[ebp]

; 4498 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ENDP ; CvPlayerTrade::GetTradeUnit
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
PUBLIC	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
PUBLIC	??_C@_0CI@JFPNMCKA@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@ ; `string'
PUBLIC	??_C@_0P@HAEHPLHJ@NULL?5Dest?5City?$AA@		; `string'
PUBLIC	??_C@_0BB@NJPOGILL@NULL?5Origin?5City?$AA@	; `string'
PUBLIC	??_C@_0CI@CKOPBODG@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@ ; `string'
PUBLIC	??_C@_0CH@DKKLOJGK@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARG@ ; `string'
PUBLIC	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0CE@DFPANEO@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARA@ ; `string'
PUBLIC	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
PUBLIC	?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ; CvPlayerTrade::GetPlotToolTips
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationAdjectiveKey
;	COMDAT ??_C@_0CI@JFPNMCKA@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0CI@JFPNMCKA@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@ DB 'TXT_KEY_TRADE_RO'
	DB	'UTE_TT_PLOT_MAJOR_MAJOR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HAEHPLHJ@NULL?5Dest?5City?$AA@
CONST	SEGMENT
??_C@_0P@HAEHPLHJ@NULL?5Dest?5City?$AA@ DB 'NULL Dest City', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NJPOGILL@NULL?5Origin?5City?$AA@
CONST	SEGMENT
??_C@_0BB@NJPOGILL@NULL?5Origin?5City?$AA@ DB 'NULL Origin City', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CKOPBODG@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@
CONST	SEGMENT
??_C@_0CI@CKOPBODG@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@ DB 'TXT_KEY_TRADE_RO'
	DB	'UTE_TT_PLOT_MAJOR_MINOR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DKKLOJGK@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARG@
CONST	SEGMENT
??_C@_0CH@DKKLOJGK@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARG@ DB 'TXT_KEY_TRADE_RO'
	DB	'UTE_TT_PLOT_CARGO_SHIP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DFPANEO@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARA@
CONST	SEGMENT
??_C@_0CE@DFPANEO@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARA@ DB 'TXT_KEY_TRADE_ROU'
	DB	'TE_TT_PLOT_CARAVAN', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$12
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5
	DD	06H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7
	DD	08H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$20
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
_TEXT	SEGMENT
tv639 = -1072						; size = 4
tv336 = -1068						; size = 4
tv319 = -1064						; size = 4
tv408 = -1060						; size = 4
tv241 = -1056						; size = 4
tv306 = -1052						; size = 4
tv289 = -1048						; size = 4
tv406 = -1044						; size = 4
tv265 = -1040						; size = 4
tv582 = -1036						; size = 4
tv505 = -1032						; size = 4
tv509 = -1028						; size = 4
tv521 = -1024						; size = 4
tv468 = -1020						; size = 4
_this$ = -1016						; size = 4
$T236803 = -920						; size = 4
$T236794 = -916						; size = 4
$T236790 = -912						; size = 4
$T236786 = -908						; size = 4
$T236782 = -904						; size = 4
$T236680 = -852						; size = 4
$T236671 = -848						; size = 4
$T236628 = -820						; size = 4
$T236619 = -816						; size = 4
$T236610 = -808						; size = 4
$T236609 = -804						; size = 4
$T236608 = -800						; size = 4
$T236569 = -796						; size = 4
$T236556 = -792						; size = 4
$T236552 = -788						; size = 4
$T236545 = -784						; size = 4
$T236541 = -777						; size = 1
$T236530 = -776						; size = 4
$T236526 = -769						; size = 1
_iMapY$236591 = -768					; size = 4
_iMapX$236590 = -764					; size = 4
$T236519 = -760						; size = 4
$T236510 = -752						; size = 4
$T236509 = -748						; size = 4
$T236508 = -744						; size = 4
$T236477 = -740						; size = 4
$T236472 = -736						; size = 4
$T236468 = -729						; size = 1
$T236457 = -728						; size = 4
$T236453 = -721						; size = 1
_iMapY$236486 = -720					; size = 4
_iMapX$236485 = -716					; size = 4
$T236446 = -712						; size = 4
$T236436 = -708						; size = 4
$T236423 = -704						; size = 4
$T236405 = -700						; size = 4
$T236367 = -688						; size = 4
$T236364 = -684						; size = 28
$T236363 = -656						; size = 4
$T236360 = -652						; size = 4
$T236359 = -648						; size = 4
$T236356 = -644						; size = 4
$T236355 = -640						; size = 80
$T236352 = -560						; size = 4
$T236351 = -556						; size = 4
$T236348 = -552						; size = 4
$T236347 = -548						; size = 80
$T236346 = -468						; size = 28
$T236345 = -440						; size = 4
$T236344 = -436						; size = 28
$T236343 = -408						; size = 4
_strTradeUnit$221634 = -404				; size = 80
_strTradeUnit$221627 = -324				; size = 80
_strTradeLine$221639 = -244				; size = 80
_uiPlotIndex$221620 = -160				; size = 4
_iTradeUnitX$221616 = -156				; size = 4
_iTradeUnitIndex$221615 = -152				; size = 4
_iTradeUnitY$221617 = -148				; size = 4
_pConnection$221610 = -144				; size = 4
_bDisplayInfo$221611 = -137				; size = 1
_uiConnection$221605 = -136				; size = 4
_ePlayer$ = -132					; size = 4
_iX$ = -128						; size = 4
_pDestCity$ = -124					; size = 4
_pTrade$ = -120						; size = 4
_aToolTips$ = -116					; size = 16
_iY$ = -100						; size = 4
_pOriginCity$ = -96					; size = 4
_strResult$ = -92					; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z PROC ; CvPlayerTrade::GetPlotToolTips, COMDAT
; _this$ = ecx

; 4506 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1060				; 00000424H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T236367[ebp], 0

; 4507 : 	std::vector<CvString> aToolTips;

	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4508 : 
; 4509 : 	if (!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN20@GetPlotToo

; 4510 : 	{
; 4511 : 		return aToolTips;

	lea	eax, DWORD PTR _aToolTips$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	mov	ecx, DWORD PTR $T236367[ebp]
	or	ecx, 1
	mov	DWORD PTR $T236367[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN21@GetPlotToo
$LN20@GetPlotToo:

; 4512 : 	}
; 4513 : 
; 4514 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236405[ebp], edx
	mov	ecx, DWORD PTR $T236405[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 4515 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _ePlayer$[ebp], edx

; 4516 : 	int iX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iX$[ebp], ecx

; 4517 : 	int iY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iY$[ebp], eax

; 4518 : 	CvCity* pOriginCity = NULL;

	mov	DWORD PTR _pOriginCity$[ebp], 0

; 4519 : 	CvCity* pDestCity = NULL;

	mov	DWORD PTR _pDestCity$[ebp], 0

; 4520 : 
; 4521 : 	Localization::String strResult;

	lea	ecx, DWORD PTR _strResult$[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4522 : 
; 4523 : #ifdef AUI_ITERATORIZE
; 4524 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 4525 : 	{
; 4526 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 4527 : #else
; 4528 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	DWORD PTR _uiConnection$221605[ebp], 0
	jmp	SHORT $LN19@GetPlotToo
$LN18@GetPlotToo:
	mov	ecx, DWORD PTR _uiConnection$221605[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiConnection$221605[ebp], ecx
$LN19@GetPlotToo:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236423[ebp], eax
	mov	ecx, DWORD PTR _uiConnection$221605[ebp]
	cmp	ecx, DWORD PTR $T236423[ebp]
	jae	$LN17@GetPlotToo

; 4529 : 	{
; 4530 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	mov	edx, DWORD PTR _uiConnection$221605[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN68@GetPlotToo

; 4531 : #endif
; 4532 : 		{
; 4533 : 			continue;

	jmp	SHORT $LN18@GetPlotToo

; 4534 : 		}
; 4535 : 
; 4536 : #ifndef AUI_ITERATORIZE
; 4537 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);

$LN68@GetPlotToo:
	mov	ecx, DWORD PTR _uiConnection$221605[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _pTrade$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _pConnection$221610[ebp], ecx

; 4538 : #endif
; 4539 : 
; 4540 : 		bool bDisplayInfo = false;

	mov	BYTE PTR _bDisplayInfo$221611[ebp], 0

; 4541 : 		if (pConnection->m_eOriginOwner == ePlayer || pConnection->m_eDestOwner == ePlayer)

	mov	eax, DWORD PTR _pConnection$221610[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN14@GetPlotToo
	mov	edx, DWORD PTR _pConnection$221610[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN15@GetPlotToo
$LN14@GetPlotToo:

; 4542 : 		{
; 4543 : 			bDisplayInfo = true;

	mov	BYTE PTR _bDisplayInfo$221611[ebp], 1

; 4544 : 		}
; 4545 : 		else

	jmp	SHORT $LN13@GetPlotToo
$LN15@GetPlotToo:

; 4546 : 		{
; 4547 : 			int iTradeUnitIndex = pConnection->m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR _pConnection$221610[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _iTradeUnitIndex$221615[ebp], edx

; 4548 : 			int iTradeUnitX = pConnection->m_aPlotList[iTradeUnitIndex].m_iX;

	mov	eax, DWORD PTR _pConnection$221610[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iTradeUnitIndex$221615[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _iTradeUnitX$221616[ebp], eax

; 4549 : 			int iTradeUnitY = pConnection->m_aPlotList[iTradeUnitIndex].m_iY;

	mov	ecx, DWORD PTR _pConnection$221610[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _iTradeUnitIndex$221615[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _iTradeUnitY$221617[ebp], ecx

; 4550 : 			if (iTradeUnitX == iX && iTradeUnitY == iY)

	mov	edx, DWORD PTR _iTradeUnitX$221616[ebp]
	cmp	edx, DWORD PTR _iX$[ebp]
	jne	SHORT $LN13@GetPlotToo
	mov	eax, DWORD PTR _iTradeUnitY$221617[ebp]
	cmp	eax, DWORD PTR _iY$[ebp]
	jne	SHORT $LN13@GetPlotToo

; 4551 : 			{
; 4552 : 				bDisplayInfo = true;

	mov	BYTE PTR _bDisplayInfo$221611[ebp], 1
$LN13@GetPlotToo:

; 4553 : 			}
; 4554 : 		}
; 4555 : 
; 4556 : 		// if this trade route involves us
; 4557 : 		if (bDisplayInfo)

	movzx	ecx, BYTE PTR _bDisplayInfo$221611[ebp]
	test	ecx, ecx
	je	$LN11@GetPlotToo

; 4558 : 		{
; 4559 : 			for (uint uiPlotIndex = 0; uiPlotIndex < pConnection->m_aPlotList.size(); uiPlotIndex++)

	mov	DWORD PTR _uiPlotIndex$221620[ebp], 0
	jmp	SHORT $LN10@GetPlotToo
$LN9@GetPlotToo:
	mov	edx, DWORD PTR _uiPlotIndex$221620[ebp]
	add	edx, 1
	mov	DWORD PTR _uiPlotIndex$221620[ebp], edx
$LN10@GetPlotToo:
	mov	eax, DWORD PTR _pConnection$221610[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T236436[ebp], ecx
	mov	edx, DWORD PTR _uiPlotIndex$221620[ebp]
	cmp	edx, DWORD PTR $T236436[ebp]
	jae	$LN11@GetPlotToo

; 4560 : 			{
; 4561 : 				if (pConnection->m_aPlotList[uiPlotIndex].m_iX == iX && pConnection->m_aPlotList[uiPlotIndex].m_iY == iY)

	mov	eax, DWORD PTR _pConnection$221610[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _uiPlotIndex$221620[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	cmp	eax, DWORD PTR _iX$[ebp]
	jne	$LN7@GetPlotToo
	mov	ecx, DWORD PTR _pConnection$221610[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _uiPlotIndex$221620[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	cmp	ecx, DWORD PTR _iY$[ebp]
	jne	$LN7@GetPlotToo

; 4562 : 				{
; 4563 : 					pOriginCity = GC.getMap().plot(pConnection->m_iOriginX, pConnection->m_iOriginY)->getPlotCity();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236446[ebp], edx
	mov	eax, DWORD PTR _pConnection$221610[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236509[ebp], ecx
	mov	edx, DWORD PTR _pConnection$221610[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236508[ebp], eax
	cmp	DWORD PTR $T236508[ebp], -2147483647	; 80000001H
	je	SHORT $LN82@GetPlotToo
	cmp	DWORD PTR $T236509[ebp], -2147483647	; 80000001H
	jne	SHORT $LN83@GetPlotToo
$LN82@GetPlotToo:
	mov	DWORD PTR $T236510[ebp], 0
	jmp	$LN84@GetPlotToo
$LN83@GetPlotToo:
	mov	ecx, DWORD PTR $T236446[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T236453[ebp], dl
	mov	eax, DWORD PTR $T236446[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T236457[ebp], ecx
	movzx	edx, BYTE PTR $T236453[ebp]
	test	edx, edx
	je	SHORT $LN95@GetPlotToo
	cmp	DWORD PTR $T236508[ebp], 0
	jge	SHORT $LN94@GetPlotToo
	mov	eax, DWORD PTR $T236508[ebp]
	cdq
	idiv	DWORD PTR $T236457[ebp]
	add	edx, DWORD PTR $T236457[ebp]
	mov	DWORD PTR _iMapX$236485[ebp], edx
	jmp	SHORT $LN96@GetPlotToo
	jmp	SHORT $LN95@GetPlotToo
$LN94@GetPlotToo:
	mov	eax, DWORD PTR $T236508[ebp]
	cmp	eax, DWORD PTR $T236457[ebp]
	jl	SHORT $LN95@GetPlotToo
	mov	eax, DWORD PTR $T236508[ebp]
	cdq
	idiv	DWORD PTR $T236457[ebp]
	mov	DWORD PTR _iMapX$236485[ebp], edx
	jmp	SHORT $LN96@GetPlotToo
$LN95@GetPlotToo:
	mov	ecx, DWORD PTR $T236508[ebp]
	mov	DWORD PTR _iMapX$236485[ebp], ecx
$LN96@GetPlotToo:
	mov	edx, DWORD PTR $T236446[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T236468[ebp], al
	mov	ecx, DWORD PTR $T236446[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T236472[ebp], edx
	movzx	eax, BYTE PTR $T236468[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236472[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236509[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$236486[ebp], eax
	mov	eax, DWORD PTR _iMapY$236486[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$236485[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T236446[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN86@GetPlotToo
	mov	edx, DWORD PTR $T236446[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T236477[ebp], eax
	mov	ecx, DWORD PTR _iMapY$236486[ebp]
	imul	ecx, DWORD PTR $T236477[ebp]
	add	ecx, DWORD PTR _iMapX$236485[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T236446[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv468[ebp], ecx
	jmp	SHORT $LN87@GetPlotToo
$LN86@GetPlotToo:
	mov	DWORD PTR tv468[ebp], 0
$LN87@GetPlotToo:
	mov	eax, DWORD PTR tv468[ebp]
	mov	DWORD PTR $T236510[ebp], eax
$LN84@GetPlotToo:
	mov	ecx, DWORD PTR $T236510[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pOriginCity$[ebp], eax

; 4564 : 					pDestCity = GC.getMap().plot(pConnection->m_iDestX, pConnection->m_iDestY)->getPlotCity();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236519[ebp], ecx
	mov	edx, DWORD PTR _pConnection$221610[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T236609[ebp], eax
	mov	ecx, DWORD PTR _pConnection$221610[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T236608[ebp], edx
	cmp	DWORD PTR $T236608[ebp], -2147483647	; 80000001H
	je	SHORT $LN113@GetPlotToo
	cmp	DWORD PTR $T236609[ebp], -2147483647	; 80000001H
	jne	SHORT $LN114@GetPlotToo
$LN113@GetPlotToo:
	mov	DWORD PTR $T236610[ebp], 0
	jmp	$LN115@GetPlotToo
$LN114@GetPlotToo:
	mov	eax, DWORD PTR $T236519[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T236526[ebp], cl
	mov	edx, DWORD PTR $T236519[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T236530[ebp], eax
	movzx	ecx, BYTE PTR $T236526[ebp]
	test	ecx, ecx
	je	SHORT $LN126@GetPlotToo
	cmp	DWORD PTR $T236608[ebp], 0
	jge	SHORT $LN125@GetPlotToo
	mov	eax, DWORD PTR $T236608[ebp]
	cdq
	idiv	DWORD PTR $T236530[ebp]
	add	edx, DWORD PTR $T236530[ebp]
	mov	DWORD PTR _iMapX$236590[ebp], edx
	jmp	SHORT $LN127@GetPlotToo
	jmp	SHORT $LN126@GetPlotToo
$LN125@GetPlotToo:
	mov	edx, DWORD PTR $T236608[ebp]
	cmp	edx, DWORD PTR $T236530[ebp]
	jl	SHORT $LN126@GetPlotToo
	mov	eax, DWORD PTR $T236608[ebp]
	cdq
	idiv	DWORD PTR $T236530[ebp]
	mov	DWORD PTR _iMapX$236590[ebp], edx
	jmp	SHORT $LN127@GetPlotToo
$LN126@GetPlotToo:
	mov	eax, DWORD PTR $T236608[ebp]
	mov	DWORD PTR _iMapX$236590[ebp], eax
$LN127@GetPlotToo:
	mov	ecx, DWORD PTR $T236519[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T236541[ebp], dl
	mov	eax, DWORD PTR $T236519[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T236545[ebp], ecx
	movzx	edx, BYTE PTR $T236541[ebp]
	push	edx
	mov	eax, DWORD PTR $T236545[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236609[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$236591[ebp], eax
	cmp	DWORD PTR _iMapX$236590[ebp], 0
	jl	SHORT $LN135@GetPlotToo
	mov	edx, DWORD PTR $T236519[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T236552[ebp], eax
	mov	ecx, DWORD PTR _iMapX$236590[ebp]
	cmp	ecx, DWORD PTR $T236552[ebp]
	jge	SHORT $LN135@GetPlotToo
	cmp	DWORD PTR _iMapY$236591[ebp], 0
	jl	SHORT $LN135@GetPlotToo
	mov	edx, DWORD PTR $T236519[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T236556[ebp], eax
	mov	ecx, DWORD PTR _iMapY$236591[ebp]
	cmp	ecx, DWORD PTR $T236556[ebp]
	jge	SHORT $LN135@GetPlotToo
	mov	DWORD PTR tv521[ebp], 1
	jmp	SHORT $LN133@GetPlotToo
$LN135@GetPlotToo:
	mov	DWORD PTR tv521[ebp], 0
$LN133@GetPlotToo:
	cmp	DWORD PTR tv521[ebp], 0
	je	SHORT $LN117@GetPlotToo
	mov	edx, DWORD PTR $T236519[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T236569[ebp], eax
	mov	ecx, DWORD PTR _iMapY$236591[ebp]
	imul	ecx, DWORD PTR $T236569[ebp]
	add	ecx, DWORD PTR _iMapX$236590[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T236519[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv509[ebp], ecx
	jmp	SHORT $LN118@GetPlotToo
$LN117@GetPlotToo:
	mov	DWORD PTR tv509[ebp], 0
$LN118@GetPlotToo:
	mov	eax, DWORD PTR tv509[ebp]
	mov	DWORD PTR $T236610[ebp], eax
$LN115@GetPlotToo:
	mov	ecx, DWORD PTR $T236610[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pDestCity$[ebp], eax

; 4565 : 
; 4566 : 					// Trade Routes:
; 4567 : 					// (if major to major)
; 4568 : 					// Kyoto (Japan) ~~ London (England)
; 4569 : 					// (if major to minor)
; 4570 : 					// Kyoto (Japan) ~~ Monaco (City-State)
; 4571 : 
; 4572 : 					if (uiPlotIndex == pConnection->m_iTradeUnitLocationIndex)

	mov	ecx, DWORD PTR _pConnection$221610[ebp]
	mov	edx, DWORD PTR _uiPlotIndex$221620[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jne	$LN6@GetPlotToo

; 4573 : 					{
; 4574 : 						if (pConnection->m_eDomain == DOMAIN_LAND)

	mov	eax, DWORD PTR _pConnection$221610[ebp]
	cmp	DWORD PTR [eax+28], 2
	jne	$LN5@GetPlotToo

; 4575 : 						{
; 4576 : 							Localization::String strTradeUnit = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_CARAVAN");

	push	OFFSET ??_C@_0CE@DFPANEO@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARA@
	lea	ecx, DWORD PTR _strTradeUnit$221627[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4577 : 							strTradeUnit << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	edx, DWORD PTR _pConnection$221610[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236619[ebp], eax
	mov	ecx, DWORD PTR $T236619[ebp]
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	mov	DWORD PTR $T236343[ebp], eax
	lea	ecx, DWORD PTR $T236343[ebp]
	push	ecx
	lea	edx, DWORD PTR _strTradeUnit$221627[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4578 : 							aToolTips.push_back(strTradeUnit.toUTF8());

	lea	ecx, DWORD PTR _strTradeUnit$221627[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T236628[ebp], eax
	cmp	DWORD PTR $T236628[ebp], 0
	je	SHORT $LN154@GetPlotToo
	mov	eax, DWORD PTR $T236628[ebp]
	mov	DWORD PTR tv505[ebp], eax
	jmp	SHORT $LN155@GetPlotToo
$LN154@GetPlotToo:
	mov	DWORD PTR tv505[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN155@GetPlotToo:
	mov	ecx, DWORD PTR tv505[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T236344[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	edx, DWORD PTR $T236344[ebp]
	push	edx
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T236344[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4579 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTradeUnit$221627[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	jmp	$LN6@GetPlotToo
$LN5@GetPlotToo:

; 4580 : 						else if (pConnection->m_eDomain == DOMAIN_SEA)

	mov	eax, DWORD PTR _pConnection$221610[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	$LN6@GetPlotToo

; 4581 : 						{
; 4582 : 							Localization::String strTradeUnit = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_CARGO_SHIP");

	push	OFFSET ??_C@_0CH@DKKLOJGK@TXT_KEY_TRADE_ROUTE_TT_PLOT_CARG@
	lea	ecx, DWORD PTR _strTradeUnit$221634[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 4583 : 							strTradeUnit << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	edx, DWORD PTR _pConnection$221610[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236671[ebp], eax
	mov	ecx, DWORD PTR $T236671[ebp]
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	mov	DWORD PTR $T236345[ebp], eax
	lea	ecx, DWORD PTR $T236345[ebp]
	push	ecx
	lea	edx, DWORD PTR _strTradeUnit$221634[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4584 : 							aToolTips.push_back(strTradeUnit.toUTF8());

	lea	ecx, DWORD PTR _strTradeUnit$221634[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T236680[ebp], eax
	cmp	DWORD PTR $T236680[ebp], 0
	je	SHORT $LN182@GetPlotToo
	mov	eax, DWORD PTR $T236680[ebp]
	mov	DWORD PTR tv582[ebp], eax
	jmp	SHORT $LN183@GetPlotToo
$LN182@GetPlotToo:
	mov	DWORD PTR tv582[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN183@GetPlotToo:
	mov	ecx, DWORD PTR tv582[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T236346[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	edx, DWORD PTR $T236346[ebp]
	push	edx
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T236346[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4585 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTradeUnit$221634[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN6@GetPlotToo:

; 4586 : 					}
; 4587 : 
; 4588 : 					Localization::String strTradeLine;

	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 4589 : 
; 4590 : 					if (GET_PLAYER(pConnection->m_eDestOwner).isMinorCiv()) // if a minor civ, have a special help text

	mov	eax, DWORD PTR _pConnection$221610[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236782[ebp], ecx
	mov	ecx, DWORD PTR $T236782[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	$LN2@GetPlotToo

; 4591 : 					{
; 4592 : 						strTradeLine = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJOR_MINOR");

	push	OFFSET ??_C@_0CI@CKOPBODG@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@
	lea	eax, DWORD PTR $T236347[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv265[ebp], eax
	mov	ecx, DWORD PTR tv265[ebp]
	mov	DWORD PTR tv406[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR tv406[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T236347[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 4593 : 						strTradeLine << ((pOriginCity)?pOriginCity->getNameKey():"NULL Origin City");

	cmp	DWORD PTR _pOriginCity$[ebp], 0
	je	SHORT $LN23@GetPlotToo
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR tv289[ebp], eax
	jmp	SHORT $LN24@GetPlotToo
$LN23@GetPlotToo:
	mov	DWORD PTR tv289[ebp], OFFSET ??_C@_0BB@NJPOGILL@NULL?5Origin?5City?$AA@
$LN24@GetPlotToo:
	mov	eax, DWORD PTR tv289[ebp]
	mov	DWORD PTR $T236348[ebp], eax
	lea	ecx, DWORD PTR $T236348[ebp]
	push	ecx
	lea	edx, DWORD PTR _strTradeLine$221639[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4594 : 						strTradeLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationShortDescriptionKey();

	mov	eax, DWORD PTR _pConnection$221610[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236786[ebp], ecx
	mov	ecx, DWORD PTR $T236786[ebp]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR $T236351[ebp], eax
	lea	edx, DWORD PTR $T236351[ebp]
	push	edx
	lea	eax, DWORD PTR _strTradeLine$221639[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4595 : 						strTradeLine << ((pDestCity)?pDestCity->getNameKey():"NULL Dest City");

	cmp	DWORD PTR _pDestCity$[ebp], 0
	je	SHORT $LN25@GetPlotToo
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR tv306[ebp], eax
	jmp	SHORT $LN26@GetPlotToo
$LN25@GetPlotToo:
	mov	DWORD PTR tv306[ebp], OFFSET ??_C@_0P@HAEHPLHJ@NULL?5Dest?5City?$AA@
$LN26@GetPlotToo:
	mov	ecx, DWORD PTR tv306[ebp]
	mov	DWORD PTR $T236352[ebp], ecx
	lea	edx, DWORD PTR $T236352[ebp]
	push	edx
	lea	eax, DWORD PTR _strTradeLine$221639[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4596 : 					}
; 4597 : 					else

	jmp	$LN1@GetPlotToo
$LN2@GetPlotToo:

; 4598 : 					{
; 4599 : 						strTradeLine = Localization::Lookup("TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJOR_MAJOR");

	push	OFFSET ??_C@_0CI@JFPNMCKA@TXT_KEY_TRADE_ROUTE_TT_PLOT_MAJO@
	lea	ecx, DWORD PTR $T236355[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv241[ebp], eax
	mov	edx, DWORD PTR tv241[ebp]
	mov	DWORD PTR tv408[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	eax, DWORD PTR tv408[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T236355[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 4600 : 						strTradeLine << ((pOriginCity)?pOriginCity->getNameKey():"NULL Origin City");

	cmp	DWORD PTR _pOriginCity$[ebp], 0
	je	SHORT $LN27@GetPlotToo
	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR tv319[ebp], eax
	jmp	SHORT $LN28@GetPlotToo
$LN27@GetPlotToo:
	mov	DWORD PTR tv319[ebp], OFFSET ??_C@_0BB@NJPOGILL@NULL?5Origin?5City?$AA@
$LN28@GetPlotToo:
	mov	ecx, DWORD PTR tv319[ebp]
	mov	DWORD PTR $T236356[ebp], ecx
	lea	edx, DWORD PTR $T236356[ebp]
	push	edx
	lea	eax, DWORD PTR _strTradeLine$221639[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4601 : 						strTradeLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationShortDescriptionKey();

	mov	ecx, DWORD PTR _pConnection$221610[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236790[ebp], edx
	mov	ecx, DWORD PTR $T236790[ebp]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR $T236359[ebp], eax
	lea	eax, DWORD PTR $T236359[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4602 : 						strTradeLine << ((pDestCity)?pDestCity->getNameKey():"NULL Dest City");

	cmp	DWORD PTR _pDestCity$[ebp], 0
	je	SHORT $LN29@GetPlotToo
	mov	ecx, DWORD PTR _pDestCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR tv336[ebp], eax
	jmp	SHORT $LN30@GetPlotToo
$LN29@GetPlotToo:
	mov	DWORD PTR tv336[ebp], OFFSET ??_C@_0P@HAEHPLHJ@NULL?5Dest?5City?$AA@
$LN30@GetPlotToo:
	mov	edx, DWORD PTR tv336[ebp]
	mov	DWORD PTR $T236360[ebp], edx
	lea	eax, DWORD PTR $T236360[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4603 : 
; 4604 : 						strTradeLine << GET_PLAYER(pConnection->m_eDestOwner).getCivilizationShortDescriptionKey();

	mov	edx, DWORD PTR _pConnection$221610[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236794[ebp], eax
	mov	ecx, DWORD PTR $T236794[ebp]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR $T236363[ebp], eax
	lea	ecx, DWORD PTR $T236363[ebp]
	push	ecx
	lea	edx, DWORD PTR _strTradeLine$221639[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN1@GetPlotToo:

; 4605 : 					}
; 4606 : 
; 4607 : 					aToolTips.push_back(strTradeLine.toUTF8());

	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T236803[ebp], eax
	cmp	DWORD PTR $T236803[ebp], 0
	je	SHORT $LN242@GetPlotToo
	mov	eax, DWORD PTR $T236803[ebp]
	mov	DWORD PTR tv639[ebp], eax
	jmp	SHORT $LN243@GetPlotToo
$LN242@GetPlotToo:
	mov	DWORD PTR tv639[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN243@GetPlotToo:
	mov	ecx, DWORD PTR tv639[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T236364[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	edx, DWORD PTR $T236364[ebp]
	push	edx
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T236364[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4608 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN7@GetPlotToo:

; 4609 : 			}

	jmp	$LN9@GetPlotToo
$LN11@GetPlotToo:

; 4610 : 		}
; 4611 : 	}

	jmp	$LN18@GetPlotToo
$LN17@GetPlotToo:

; 4612 : 
; 4613 : 	return aToolTips;

	lea	eax, DWORD PTR _aToolTips$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	mov	ecx, DWORD PTR $T236367[ebp]
	or	ecx, 1
	mov	DWORD PTR $T236367[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strResult$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN21@GetPlotToo:

; 4614 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1:
	mov	eax, DWORD PTR $T236367[ebp]
	and	eax, 1
	je	$LN33@GetPlotToo
	and	DWORD PTR $T236367[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
$LN33@GetPlotToo:
	ret	0
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$12:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strResult$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _strTradeUnit$221627[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR $T236344[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5:
	lea	ecx, DWORD PTR _strTradeUnit$221634[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR $T236346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7:
	lea	ecx, DWORD PTR _strTradeLine$221639[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$8:
	lea	ecx, DWORD PTR $T236347[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$9:
	lea	ecx, DWORD PTR $T236355[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$10:
	lea	ecx, DWORD PTR $T236364[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$20:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__ehhandler$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1064]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetPlotToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ENDP ; CvPlayerTrade::GetPlotToolTips
PUBLIC	??_C@_0CM@KHINAJDK@?$FLCOLOR_POSITIVE_TEXT?$FN?$HL1_InnerStr@ ; `string'
PUBLIC	??_C@_0CM@BEOGAAGE@?$FLCOLOR_NEGATIVE_TEXT?$FN?$HL1_InnerStr@ ; `string'
PUBLIC	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
PUBLIC	??_C@_0CE@NCCDLAKB@?$FLCOLOR_WHITE?$FN?$HL1_InnerStr?$HN?$FLENDCOL@ ; `string'
PUBLIC	??_C@_0CG@IMADEAHB@TXT_KEY_PLOTROLL_UNIT_DESCRIPTIO@ ; `string'
PUBLIC	??_C@_0BM@KOIMFCPM@TXT_KEY_MULTIPLAYER_UNIT_TT?$AA@ ; `string'
PUBLIC	?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ; CvPlayerTrade::GetPlotMouseoverToolTips
EXTRN	__imp_??4String@Localization@@QAEAAV01@PBD@Z:PROC
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
;	COMDAT ??_C@_0CM@KHINAJDK@?$FLCOLOR_POSITIVE_TEXT?$FN?$HL1_InnerStr@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0CM@KHINAJDK@?$FLCOLOR_POSITIVE_TEXT?$FN?$HL1_InnerStr@ DB '[COLOR_'
	DB	'POSITIVE_TEXT]{1_InnerStr}[ENDCOLOR]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BEOGAAGE@?$FLCOLOR_NEGATIVE_TEXT?$FN?$HL1_InnerStr@
CONST	SEGMENT
??_C@_0CM@BEOGAAGE@?$FLCOLOR_NEGATIVE_TEXT?$FN?$HL1_InnerStr@ DB '[COLOR_'
	DB	'NEGATIVE_TEXT]{1_InnerStr}[ENDCOLOR]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NCCDLAKB@?$FLCOLOR_WHITE?$FN?$HL1_InnerStr?$HN?$FLENDCOL@
CONST	SEGMENT
??_C@_0CE@NCCDLAKB@?$FLCOLOR_WHITE?$FN?$HL1_InnerStr?$HN?$FLENDCOL@ DB '['
	DB	'COLOR_WHITE]{1_InnerStr}[ENDCOLOR]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IMADEAHB@TXT_KEY_PLOTROLL_UNIT_DESCRIPTIO@
CONST	SEGMENT
??_C@_0CG@IMADEAHB@TXT_KEY_PLOTROLL_UNIT_DESCRIPTIO@ DB 'TXT_KEY_PLOTROLL'
	DB	'_UNIT_DESCRIPTION_CIV', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KOIMFCPM@TXT_KEY_MULTIPLAYER_UNIT_TT?$AA@
CONST	SEGMENT
??_C@_0BM@KOIMFCPM@TXT_KEY_MULTIPLAYER_UNIT_TT?$AA@ DB 'TXT_KEY_MULTIPLAY'
	DB	'ER_UNIT_TT', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$9
	DD	01H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6
	DD	07H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$13
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
_TEXT	SEGMENT
tv581 = -864						; size = 4
tv369 = -860						; size = 4
tv84 = -856						; size = 4
tv367 = -852						; size = 4
tv215 = -848						; size = 4
tv229 = -844						; size = 4
tv832 = -840						; size = 4
tv827 = -834						; size = 1
tv820 = -833						; size = 1
tv816 = -832						; size = 4
tv817 = -828						; size = 4
tv503 = -824						; size = 4
tv515 = -820						; size = 4
tv462 = -816						; size = 4
_this$ = -812						; size = 4
$T237366 = -716						; size = 4
$T237357 = -712						; size = 4
$T237356 = -708						; size = 4
$T237352 = -704						; size = 4
$T237348 = -700						; size = 4
$T237336 = -696						; size = 4
$T237332 = -692						; size = 4
$T237328 = -688						; size = 4
$T237324 = -684						; size = 4
$T237320 = -680						; size = 4
$T237316 = -676						; size = 4
$T237312 = -672						; size = 4
$T237303 = -664						; size = 4
$T237302 = -660						; size = 4
$T237301 = -656						; size = 4
$T237262 = -652						; size = 4
$T237249 = -648						; size = 4
$T237245 = -644						; size = 4
$T237238 = -640						; size = 4
$T237234 = -633						; size = 1
$T237223 = -632						; size = 4
$T237219 = -625						; size = 1
_iMapY$237300 = -624					; size = 4
_iMapX$237299 = -620					; size = 4
$T237212 = -616						; size = 4
$T237203 = -608						; size = 4
$T237202 = -604						; size = 4
$T237201 = -600						; size = 4
$T237170 = -596						; size = 4
$T237165 = -592						; size = 4
$T237161 = -585						; size = 1
$T237150 = -584						; size = 4
$T237146 = -577						; size = 1
_iMapY$237200 = -576					; size = 4
_iMapX$237199 = -572					; size = 4
$T237139 = -568						; size = 4
$T237129 = -564						; size = 4
$T237116 = -560						; size = 4
$T237098 = -556						; size = 4
$T237063 = -544						; size = 4
$T237060 = -540						; size = 28
$T237059 = -512						; size = 4
$T237058 = -508						; size = 4
$T237057 = -504						; size = 80
$T237056 = -424						; size = 4
$T237055 = -420						; size = 4
$T237054 = -416						; size = 4
$T237053 = -412						; size = 80
_strColorString$221711 = -332				; size = 80
_eTeam$221712 = -248					; size = 4
_strLine$221699 = -244					; size = 80
_uiPlotIndex$221693 = -160				; size = 4
_iTradeUnitX$221689 = -156				; size = 4
_iTradeUnitIndex$221688 = -152				; size = 4
_iTradeUnitY$221690 = -148				; size = 4
_pConnection$221683 = -144				; size = 4
_bDisplayInfo$221684 = -137				; size = 1
_uiConnection$221678 = -136				; size = 4
_ePlayer$ = -132					; size = 4
_iX$ = -128						; size = 4
_pDestCity$ = -124					; size = 4
_pTrade$ = -120						; size = 4
_aToolTips$ = -116					; size = 16
_iY$ = -100						; size = 4
_pOriginCity$ = -96					; size = 4
_strResult$ = -92					; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pPlot$ = 12						; size = 4
?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z PROC ; CvPlayerTrade::GetPlotMouseoverToolTips, COMDAT
; _this$ = ecx

; 4622 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 852				; 00000354H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T237063[ebp], 0

; 4623 : 	std::vector<CvString> aToolTips;

	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4624 : 
; 4625 : 	if (!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN21@GetPlotMou

; 4626 : 	{
; 4627 : 		return aToolTips;

	lea	eax, DWORD PTR _aToolTips$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	mov	ecx, DWORD PTR $T237063[ebp]
	or	ecx, 1
	mov	DWORD PTR $T237063[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN22@GetPlotMou
$LN21@GetPlotMou:

; 4628 : 	}
; 4629 : 
; 4630 : 	CvGameTrade* pTrade = GC.getGame().GetGameTrade();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237098[ebp], edx
	mov	ecx, DWORD PTR $T237098[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pTrade$[ebp], eax

; 4631 : 	PlayerTypes ePlayer = m_pPlayer->GetID();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+79104]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _ePlayer$[ebp], edx

; 4632 : 	int iX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iX$[ebp], ecx

; 4633 : 	int iY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iY$[ebp], eax

; 4634 : 	CvCity* pOriginCity = NULL;

	mov	DWORD PTR _pOriginCity$[ebp], 0

; 4635 : 	CvCity* pDestCity = NULL;

	mov	DWORD PTR _pDestCity$[ebp], 0

; 4636 : 
; 4637 : 	Localization::String strResult;

	lea	ecx, DWORD PTR _strResult$[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 4638 : 
; 4639 : #ifdef AUI_ITERATORIZE
; 4640 : 	for (TradeConnectionList::iterator pConnection = pTrade->m_aTradeConnections.begin(); pConnection != pTrade->m_aTradeConnections.end(); ++pConnection)
; 4641 : 	{
; 4642 : 		if (pTrade->IsTradeRouteIndexEmpty(pConnection))
; 4643 : #else
; 4644 : 	for (uint uiConnection = 0; uiConnection < pTrade->m_aTradeConnections.size(); uiConnection++)

	mov	DWORD PTR _uiConnection$221678[ebp], 0
	jmp	SHORT $LN20@GetPlotMou
$LN19@GetPlotMou:
	mov	ecx, DWORD PTR _uiConnection$221678[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiConnection$221678[ebp], ecx
$LN20@GetPlotMou:
	mov	edx, DWORD PTR _pTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237116[ebp], eax
	mov	ecx, DWORD PTR _uiConnection$221678[ebp]
	cmp	ecx, DWORD PTR $T237116[ebp]
	jae	$LN18@GetPlotMou

; 4645 : 	{
; 4646 : 		if (pTrade->IsTradeRouteIndexEmpty(uiConnection))

	mov	edx, DWORD PTR _uiConnection$221678[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrade$[ebp]
	call	?IsTradeRouteIndexEmpty@CvGameTrade@@QAE_NH@Z ; CvGameTrade::IsTradeRouteIndexEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN58@GetPlotMou

; 4647 : #endif
; 4648 : 		{
; 4649 : 			continue;

	jmp	SHORT $LN19@GetPlotMou

; 4650 : 		}
; 4651 : 
; 4652 : #ifndef AUI_ITERATORIZE
; 4653 : 		TradeConnection* pConnection = &(pTrade->m_aTradeConnections[uiConnection]);

$LN58@GetPlotMou:
	mov	ecx, DWORD PTR _uiConnection$221678[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _pTrade$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _pConnection$221683[ebp], ecx

; 4654 : #endif
; 4655 : 
; 4656 : 		bool bDisplayInfo = false;

	mov	BYTE PTR _bDisplayInfo$221684[ebp], 0

; 4657 : 		if (pConnection->m_eOriginOwner == ePlayer || pConnection->m_eDestOwner == ePlayer)

	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	je	SHORT $LN15@GetPlotMou
	mov	edx, DWORD PTR _pConnection$221683[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN16@GetPlotMou
$LN15@GetPlotMou:

; 4658 : 		{
; 4659 : 			bDisplayInfo = true;

	mov	BYTE PTR _bDisplayInfo$221684[ebp], 1

; 4660 : 		}
; 4661 : 		else

	jmp	SHORT $LN14@GetPlotMou
$LN16@GetPlotMou:

; 4662 : 		{
; 4663 : 			int iTradeUnitIndex = pConnection->m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR _pConnection$221683[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _iTradeUnitIndex$221688[ebp], edx

; 4664 : 			int iTradeUnitX = pConnection->m_aPlotList[iTradeUnitIndex].m_iX;

	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iTradeUnitIndex$221688[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _iTradeUnitX$221689[ebp], eax

; 4665 : 			int iTradeUnitY = pConnection->m_aPlotList[iTradeUnitIndex].m_iY;

	mov	ecx, DWORD PTR _pConnection$221683[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _iTradeUnitIndex$221688[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _iTradeUnitY$221690[ebp], ecx

; 4666 : 			if (iTradeUnitX == iX && iTradeUnitY == iY)

	mov	edx, DWORD PTR _iTradeUnitX$221689[ebp]
	cmp	edx, DWORD PTR _iX$[ebp]
	jne	SHORT $LN14@GetPlotMou
	mov	eax, DWORD PTR _iTradeUnitY$221690[ebp]
	cmp	eax, DWORD PTR _iY$[ebp]
	jne	SHORT $LN14@GetPlotMou

; 4667 : 			{
; 4668 : 				bDisplayInfo = true;

	mov	BYTE PTR _bDisplayInfo$221684[ebp], 1
$LN14@GetPlotMou:

; 4669 : 			}
; 4670 : 		}
; 4671 : 
; 4672 : 		// if this trade route involves us
; 4673 : 		if (bDisplayInfo)

	movzx	ecx, BYTE PTR _bDisplayInfo$221684[ebp]
	test	ecx, ecx
	je	$LN12@GetPlotMou

; 4674 : 		{
; 4675 : 			for (uint uiPlotIndex = 0; uiPlotIndex < pConnection->m_aPlotList.size(); uiPlotIndex++)

	mov	DWORD PTR _uiPlotIndex$221693[ebp], 0
	jmp	SHORT $LN11@GetPlotMou
$LN10@GetPlotMou:
	mov	edx, DWORD PTR _uiPlotIndex$221693[ebp]
	add	edx, 1
	mov	DWORD PTR _uiPlotIndex$221693[ebp], edx
$LN11@GetPlotMou:
	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T237129[ebp], ecx
	mov	edx, DWORD PTR _uiPlotIndex$221693[ebp]
	cmp	edx, DWORD PTR $T237129[ebp]
	jae	$LN12@GetPlotMou

; 4676 : 			{
; 4677 : 				if (pConnection->m_aPlotList[uiPlotIndex].m_iX == iX && pConnection->m_aPlotList[uiPlotIndex].m_iY == iY)

	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _uiPlotIndex$221693[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	cmp	eax, DWORD PTR _iX$[ebp]
	jne	$LN8@GetPlotMou
	mov	ecx, DWORD PTR _pConnection$221683[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _uiPlotIndex$221693[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	cmp	ecx, DWORD PTR _iY$[ebp]
	jne	$LN8@GetPlotMou

; 4678 : 				{
; 4679 : 					pOriginCity = GC.getMap().plot(pConnection->m_iOriginX, pConnection->m_iOriginY)->getPlotCity();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237139[ebp], edx
	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237202[ebp], ecx
	mov	edx, DWORD PTR _pConnection$221683[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237201[ebp], eax
	cmp	DWORD PTR $T237201[ebp], -2147483647	; 80000001H
	je	SHORT $LN72@GetPlotMou
	cmp	DWORD PTR $T237202[ebp], -2147483647	; 80000001H
	jne	SHORT $LN73@GetPlotMou
$LN72@GetPlotMou:
	mov	DWORD PTR $T237203[ebp], 0
	jmp	$LN74@GetPlotMou
$LN73@GetPlotMou:
	mov	ecx, DWORD PTR $T237139[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T237146[ebp], dl
	mov	eax, DWORD PTR $T237139[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237150[ebp], ecx
	movzx	edx, BYTE PTR $T237146[ebp]
	test	edx, edx
	je	SHORT $LN85@GetPlotMou
	cmp	DWORD PTR $T237201[ebp], 0
	jge	SHORT $LN84@GetPlotMou
	mov	eax, DWORD PTR $T237201[ebp]
	cdq
	idiv	DWORD PTR $T237150[ebp]
	add	edx, DWORD PTR $T237150[ebp]
	mov	DWORD PTR _iMapX$237199[ebp], edx
	jmp	SHORT $LN86@GetPlotMou
	jmp	SHORT $LN85@GetPlotMou
$LN84@GetPlotMou:
	mov	eax, DWORD PTR $T237201[ebp]
	cmp	eax, DWORD PTR $T237150[ebp]
	jl	SHORT $LN85@GetPlotMou
	mov	eax, DWORD PTR $T237201[ebp]
	cdq
	idiv	DWORD PTR $T237150[ebp]
	mov	DWORD PTR _iMapX$237199[ebp], edx
	jmp	SHORT $LN86@GetPlotMou
$LN85@GetPlotMou:
	mov	ecx, DWORD PTR $T237201[ebp]
	mov	DWORD PTR _iMapX$237199[ebp], ecx
$LN86@GetPlotMou:
	mov	edx, DWORD PTR $T237139[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T237161[ebp], al
	mov	ecx, DWORD PTR $T237139[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237165[ebp], edx
	movzx	eax, BYTE PTR $T237161[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237165[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237202[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$237200[ebp], eax
	mov	eax, DWORD PTR _iMapY$237200[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$237199[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237139[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN76@GetPlotMou
	mov	edx, DWORD PTR $T237139[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T237170[ebp], eax
	mov	ecx, DWORD PTR _iMapY$237200[ebp]
	imul	ecx, DWORD PTR $T237170[ebp]
	add	ecx, DWORD PTR _iMapX$237199[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T237139[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv462[ebp], ecx
	jmp	SHORT $LN77@GetPlotMou
$LN76@GetPlotMou:
	mov	DWORD PTR tv462[ebp], 0
$LN77@GetPlotMou:
	mov	eax, DWORD PTR tv462[ebp]
	mov	DWORD PTR $T237203[ebp], eax
$LN74@GetPlotMou:
	mov	ecx, DWORD PTR $T237203[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pOriginCity$[ebp], eax

; 4680 : 					pDestCity = GC.getMap().plot(pConnection->m_iDestX, pConnection->m_iDestY)->getPlotCity();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237212[ebp], ecx
	mov	edx, DWORD PTR _pConnection$221683[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T237302[ebp], eax
	mov	ecx, DWORD PTR _pConnection$221683[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T237301[ebp], edx
	cmp	DWORD PTR $T237301[ebp], -2147483647	; 80000001H
	je	SHORT $LN103@GetPlotMou
	cmp	DWORD PTR $T237302[ebp], -2147483647	; 80000001H
	jne	SHORT $LN104@GetPlotMou
$LN103@GetPlotMou:
	mov	DWORD PTR $T237303[ebp], 0
	jmp	$LN105@GetPlotMou
$LN104@GetPlotMou:
	mov	eax, DWORD PTR $T237212[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T237219[ebp], cl
	mov	edx, DWORD PTR $T237212[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T237223[ebp], eax
	movzx	ecx, BYTE PTR $T237219[ebp]
	test	ecx, ecx
	je	SHORT $LN116@GetPlotMou
	cmp	DWORD PTR $T237301[ebp], 0
	jge	SHORT $LN115@GetPlotMou
	mov	eax, DWORD PTR $T237301[ebp]
	cdq
	idiv	DWORD PTR $T237223[ebp]
	add	edx, DWORD PTR $T237223[ebp]
	mov	DWORD PTR _iMapX$237299[ebp], edx
	jmp	SHORT $LN117@GetPlotMou
	jmp	SHORT $LN116@GetPlotMou
$LN115@GetPlotMou:
	mov	edx, DWORD PTR $T237301[ebp]
	cmp	edx, DWORD PTR $T237223[ebp]
	jl	SHORT $LN116@GetPlotMou
	mov	eax, DWORD PTR $T237301[ebp]
	cdq
	idiv	DWORD PTR $T237223[ebp]
	mov	DWORD PTR _iMapX$237299[ebp], edx
	jmp	SHORT $LN117@GetPlotMou
$LN116@GetPlotMou:
	mov	eax, DWORD PTR $T237301[ebp]
	mov	DWORD PTR _iMapX$237299[ebp], eax
$LN117@GetPlotMou:
	mov	ecx, DWORD PTR $T237212[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T237234[ebp], dl
	mov	eax, DWORD PTR $T237212[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T237238[ebp], ecx
	movzx	edx, BYTE PTR $T237234[ebp]
	push	edx
	mov	eax, DWORD PTR $T237238[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237302[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$237300[ebp], eax
	cmp	DWORD PTR _iMapX$237299[ebp], 0
	jl	SHORT $LN125@GetPlotMou
	mov	edx, DWORD PTR $T237212[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T237245[ebp], eax
	mov	ecx, DWORD PTR _iMapX$237299[ebp]
	cmp	ecx, DWORD PTR $T237245[ebp]
	jge	SHORT $LN125@GetPlotMou
	cmp	DWORD PTR _iMapY$237300[ebp], 0
	jl	SHORT $LN125@GetPlotMou
	mov	edx, DWORD PTR $T237212[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T237249[ebp], eax
	mov	ecx, DWORD PTR _iMapY$237300[ebp]
	cmp	ecx, DWORD PTR $T237249[ebp]
	jge	SHORT $LN125@GetPlotMou
	mov	DWORD PTR tv515[ebp], 1
	jmp	SHORT $LN123@GetPlotMou
$LN125@GetPlotMou:
	mov	DWORD PTR tv515[ebp], 0
$LN123@GetPlotMou:
	cmp	DWORD PTR tv515[ebp], 0
	je	SHORT $LN107@GetPlotMou
	mov	edx, DWORD PTR $T237212[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T237262[ebp], eax
	mov	ecx, DWORD PTR _iMapY$237300[ebp]
	imul	ecx, DWORD PTR $T237262[ebp]
	add	ecx, DWORD PTR _iMapX$237299[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T237212[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv503[ebp], ecx
	jmp	SHORT $LN108@GetPlotMou
$LN107@GetPlotMou:
	mov	DWORD PTR tv503[ebp], 0
$LN108@GetPlotMou:
	mov	eax, DWORD PTR tv503[ebp]
	mov	DWORD PTR $T237303[ebp], eax
$LN105@GetPlotMou:
	mov	ecx, DWORD PTR $T237303[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pDestCity$[ebp], eax

; 4681 : 					if (uiPlotIndex == pConnection->m_iTradeUnitLocationIndex)

	mov	ecx, DWORD PTR _pConnection$221683[ebp]
	mov	edx, DWORD PTR _uiPlotIndex$221693[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jne	$LN8@GetPlotMou

; 4682 : 					{
; 4683 : #ifdef AUI_WARNING_FIXES
; 4684 : 						CvUnitEntry* pTradeUnitInfo = GC.getUnitInfo(GetTradeUnit(pConnection->m_eDomain));
; 4685 : #endif
; 4686 : 						Localization::String strLine;

	lea	ecx, DWORD PTR _strLine$221699[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 4687 : 						if(strcmp(GET_PLAYER(pConnection->m_eOriginOwner).getNickName(), "") != 0)

	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237312[ebp], ecx
	mov	DWORD PTR tv817[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR $T237312[ebp]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR tv816[ebp], eax
$LL254@GetPlotMou:
	mov	edx, DWORD PTR tv816[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv820[ebp], al
	mov	ecx, DWORD PTR tv817[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN255@GetPlotMou
	cmp	BYTE PTR tv820[ebp], 0
	je	SHORT $LN256@GetPlotMou
	mov	edx, DWORD PTR tv816[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv827[ebp], al
	mov	ecx, DWORD PTR tv817[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN255@GetPlotMou
	add	DWORD PTR tv816[ebp], 2
	add	DWORD PTR tv817[ebp], 2
	cmp	BYTE PTR tv827[ebp], 0
	jne	SHORT $LL254@GetPlotMou
$LN256@GetPlotMou:
	mov	DWORD PTR tv832[ebp], 0
	jmp	SHORT $LN257@GetPlotMou
$LN255@GetPlotMou:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv832[ebp], edx
$LN257@GetPlotMou:
	mov	eax, DWORD PTR tv832[ebp]
	mov	DWORD PTR tv229[ebp], eax
	cmp	DWORD PTR tv229[ebp], 0
	je	$LN6@GetPlotMou

; 4688 : 						{
; 4689 : 							strLine = Localization::Lookup("TXT_KEY_MULTIPLAYER_UNIT_TT");

	push	OFFSET ??_C@_0BM@KOIMFCPM@TXT_KEY_MULTIPLAYER_UNIT_TT?$AA@
	lea	ecx, DWORD PTR $T237053[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR tv215[ebp]
	mov	DWORD PTR tv367[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR tv367[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLine$221699[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T237053[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 4690 : 							strLine << GET_PLAYER(pConnection->m_eOriginOwner).getNickName();

	mov	ecx, DWORD PTR _pConnection$221683[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237316[ebp], edx
	mov	ecx, DWORD PTR $T237316[ebp]
	call	?getNickName@CvPlayer@@QBEQBDXZ		; CvPlayer::getNickName
	mov	DWORD PTR $T237054[ebp], eax
	lea	eax, DWORD PTR $T237054[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLine$221699[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4691 : 							strLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	edx, DWORD PTR _pConnection$221683[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237320[ebp], eax
	mov	ecx, DWORD PTR $T237320[ebp]
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	mov	DWORD PTR $T237055[ebp], eax
	lea	ecx, DWORD PTR $T237055[ebp]
	push	ecx
	lea	edx, DWORD PTR _strLine$221699[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4692 : #ifdef AUI_WARNING_FIXES
; 4693 : 							if (pTradeUnitInfo)
; 4694 : 								strLine << pTradeUnitInfo->GetDescription();
; 4695 : #else
; 4696 : 							strLine << GC.getUnitInfo(GetTradeUnit(pConnection->m_eDomain))->GetDescription();

	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T237324[ebp], eax
	mov	ecx, DWORD PTR $T237324[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237056[ebp], eax
	lea	edx, DWORD PTR $T237056[ebp]
	push	edx
	lea	eax, DWORD PTR _strLine$221699[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4697 : #endif
; 4698 : 						}
; 4699 : 						else

	jmp	$LN5@GetPlotMou
$LN6@GetPlotMou:

; 4700 : 						{
; 4701 : 							strLine = Localization::Lookup("TXT_KEY_PLOTROLL_UNIT_DESCRIPTION_CIV");

	push	OFFSET ??_C@_0CG@IMADEAHB@TXT_KEY_PLOTROLL_UNIT_DESCRIPTIO@
	lea	ecx, DWORD PTR $T237057[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv84[ebp], eax
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv369[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR tv369[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLine$221699[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T237057[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 4702 : 							strLine << GET_PLAYER(pConnection->m_eOriginOwner).getCivilizationAdjectiveKey();

	mov	ecx, DWORD PTR _pConnection$221683[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237328[ebp], edx
	mov	ecx, DWORD PTR $T237328[ebp]
	call	?getCivilizationAdjectiveKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationAdjectiveKey
	mov	DWORD PTR $T237058[ebp], eax
	lea	eax, DWORD PTR $T237058[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLine$221699[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 4703 : #ifdef AUI_WARNING_FIXES
; 4704 : 							if (pTradeUnitInfo)
; 4705 : 								strLine << pTradeUnitInfo->GetDescription();
; 4706 : #else
; 4707 : 							strLine << GC.getUnitInfo(GetTradeUnit(pConnection->m_eDomain))->GetDescription();

	mov	edx, DWORD PTR _pConnection$221683[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?GetTradeUnit@CvPlayerTrade@@SA?AW4UnitTypes@@W4DomainTypes@@@Z ; CvPlayerTrade::GetTradeUnit
	add	esp, 4
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR $T237332[ebp], eax
	mov	ecx, DWORD PTR $T237332[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237059[ebp], eax
	lea	ecx, DWORD PTR $T237059[ebp]
	push	ecx
	lea	edx, DWORD PTR _strLine$221699[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
$LN5@GetPlotMou:

; 4708 : #endif
; 4709 : 						}
; 4710 : 
; 4711 : 						
; 4712 : 						Localization::String strColorString;

	lea	ecx, DWORD PTR _strColorString$221711[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 4713 : 						TeamTypes eTeam = GET_PLAYER(pConnection->m_eOriginOwner).getTeam();

	mov	eax, DWORD PTR _pConnection$221683[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237336[ebp], ecx
	mov	edx, DWORD PTR $T237336[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$221712[ebp], eax

; 4714 : 						if (eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237348[ebp], ecx
	mov	ecx, DWORD PTR $T237348[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$221712[ebp], eax
	jne	SHORT $LN4@GetPlotMou

; 4715 : 						{
; 4716 : 							strColorString = "[COLOR_WHITE]{1_InnerStr}[ENDCOLOR]";

	push	OFFSET ??_C@_0CE@NCCDLAKB@?$FLCOLOR_WHITE?$FN?$HL1_InnerStr?$HN?$FLENDCOL@
	lea	ecx, DWORD PTR _strColorString$221711[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@PBD@Z

; 4717 : 							strColorString << strLine;

	lea	edx, DWORD PTR _strLine$221699[ebp]
	push	edx
	lea	eax, DWORD PTR _strColorString$221711[ebp]
	push	eax
	call	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
	add	esp, 8
	jmp	$LN3@GetPlotMou
$LN4@GetPlotMou:

; 4718 : 						}
; 4719 : 						else if (GET_TEAM(GC.getGame().getActiveTeam()).isAtWar(eTeam))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237352[ebp], ecx
	mov	ecx, DWORD PTR $T237352[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR $T237356[ebp], eax
	mov	edx, DWORD PTR $T237356[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237357[ebp], edx
	mov	eax, DWORD PTR _eTeam$221712[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237357[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetPlotMou

; 4720 : 						{
; 4721 : 							strColorString = "[COLOR_NEGATIVE_TEXT]{1_InnerStr}[ENDCOLOR]";

	push	OFFSET ??_C@_0CM@BEOGAAGE@?$FLCOLOR_NEGATIVE_TEXT?$FN?$HL1_InnerStr@
	lea	ecx, DWORD PTR _strColorString$221711[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@PBD@Z

; 4722 : 							strColorString << strLine;

	lea	edx, DWORD PTR _strLine$221699[ebp]
	push	edx
	lea	eax, DWORD PTR _strColorString$221711[ebp]
	push	eax
	call	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
	add	esp, 8

; 4723 : 						}
; 4724 : 						else

	jmp	SHORT $LN3@GetPlotMou
$LN2@GetPlotMou:

; 4725 : 						{
; 4726 : 							strColorString = "[COLOR_POSITIVE_TEXT]{1_InnerStr}[ENDCOLOR]";

	push	OFFSET ??_C@_0CM@KHINAJDK@?$FLCOLOR_POSITIVE_TEXT?$FN?$HL1_InnerStr@
	lea	ecx, DWORD PTR _strColorString$221711[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@PBD@Z

; 4727 : 							strColorString << strLine;

	lea	ecx, DWORD PTR _strLine$221699[ebp]
	push	ecx
	lea	edx, DWORD PTR _strColorString$221711[ebp]
	push	edx
	call	??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ; operator<<<Localization::String>
	add	esp, 8
$LN3@GetPlotMou:

; 4728 : 						}
; 4729 : 
; 4730 : 						aToolTips.push_back(strColorString.toUTF8());

	lea	ecx, DWORD PTR _strColorString$221711[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T237366[ebp], eax
	cmp	DWORD PTR $T237366[ebp], 0
	je	SHORT $LN166@GetPlotMou
	mov	eax, DWORD PTR $T237366[ebp]
	mov	DWORD PTR tv581[ebp], eax
	jmp	SHORT $LN167@GetPlotMou
$LN166@GetPlotMou:
	mov	DWORD PTR tv581[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN167@GetPlotMou:
	mov	ecx, DWORD PTR tv581[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T237060[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	edx, DWORD PTR $T237060[ebp]
	push	edx
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T237060[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4731 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strColorString$221711[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strLine$221699[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN8@GetPlotMou:

; 4732 : 				}
; 4733 : 			}

	jmp	$LN10@GetPlotMou
$LN12@GetPlotMou:

; 4734 : 		}
; 4735 : 	}

	jmp	$LN19@GetPlotMou
$LN18@GetPlotMou:

; 4736 : 
; 4737 : 	return aToolTips;

	lea	eax, DWORD PTR _aToolTips$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
	mov	ecx, DWORD PTR $T237063[ebp]
	or	ecx, 1
	mov	DWORD PTR $T237063[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strResult$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN22@GetPlotMou:

; 4738 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$1:
	mov	eax, DWORD PTR $T237063[ebp]
	and	eax, 1
	je	$LN26@GetPlotMou
	and	DWORD PTR $T237063[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
$LN26@GetPlotMou:
	ret	0
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$9:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strResult$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _strLine$221699[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR $T237053[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$5:
	lea	ecx, DWORD PTR $T237057[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR _strColorString$221711[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$7:
	lea	ecx, DWORD PTR $T237060[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z$13:
	lea	ecx, DWORD PTR _aToolTips$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__ehhandler$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-856]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetPlotMouseoverToolTips@CvPlayerTrade@@QAE?AV?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvPlot@@@Z ENDP ; CvPlayerTrade::GetPlotMouseoverToolTips
PUBLIC	__$ArrayPad$
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z	; operator>>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$1
__ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
_TEXT	SEGMENT
$T237864 = -1060					; size = 4
$T237857 = -1056					; size = 4
$T237850 = -1052					; size = 4
$T237843 = -1048					; size = 4
$T237836 = -1044					; size = 4
$T237829 = -1040					; size = 4
$T237804 = -1036					; size = 4
$T237797 = -1032					; size = 4
$T237790 = -1028					; size = 4
$T237783 = -1024					; size = 4
$T237776 = -1020					; size = 4
$T237736 = -1008					; size = 4
$T237729 = -1004					; size = 4
$T237722 = -1000					; size = 4
$T237715 = -996						; size = 4
$T237708 = -992						; size = 4
$T237701 = -988						; size = 4
$T237676 = -984						; size = 4
$T237669 = -980						; size = 4
$T237662 = -976						; size = 4
$T237655 = -972						; size = 4
$T237648 = -968						; size = 4
_kTradeConnectionWasPlundered$221750 = -956		; size = 448
_iConnectionType$221753 = -508				; size = 4
_iDomain$221751 = -504					; size = 4
_i$221746 = -500					; size = 4
_iNum$221745 = -496					; size = 4
_iEmptyInt$221743 = -492				; size = 4
_iConnectionType$221740 = -488				; size = 4
_kTradeConnection$221737 = -484				; size = 444
__$ArrayPad$ = -32					; size = 4
_iDomain$221738 = -28					; size = 4
_i$221733 = -24						; size = 4
_iNum$221732 = -20					; size = 4
_uiVersion$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z PROC	; operator>>, COMDAT

; 4742 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1060				; 00000424H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4743 : 	uint uiVersion;
; 4744 : 	loadFrom >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4745 : 
; 4746 : 	if (uiVersion >= 1) 

	cmp	DWORD PTR _uiVersion$[ebp], 1
	jb	$LN9@operator@4

; 4747 : 	{
; 4748 : 		int iNum = 0;

	mov	DWORD PTR _iNum$221732[ebp], 0

; 4749 : 		loadFrom >> iNum;

	lea	ecx, DWORD PTR _iNum$221732[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4750 : 		for (int i = 0; i < iNum; i++)

	mov	DWORD PTR _i$221733[ebp], 0
	jmp	SHORT $LN8@operator@4
$LN7@operator@4:
	mov	edx, DWORD PTR _i$221733[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221733[ebp], edx
$LN8@operator@4:
	mov	eax, DWORD PTR _i$221733[ebp]
	cmp	eax, DWORD PTR _iNum$221732[ebp]
	jge	$LN6@operator@4

; 4751 : 		{
; 4752 : 			TradeConnection kTradeConnection;

	lea	ecx, DWORD PTR _kTradeConnection$221737[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4753 : 			writeTo.m_aRecentlyExpiredConnections.push_back(kTradeConnection);

	lea	ecx, DWORD PTR _kTradeConnection$221737[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 4754 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iID;

	mov	edx, DWORD PTR _i$221733[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T237648[ebp], edx
	mov	ecx, DWORD PTR $T237648[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4755 : 
; 4756 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iOriginX;

	mov	edx, DWORD PTR _i$221733[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR $T237655[ebp], edx
	mov	eax, DWORD PTR $T237655[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4757 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iOriginY;

	mov	ecx, DWORD PTR _i$221733[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T237662[ebp], ecx
	mov	edx, DWORD PTR $T237662[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4758 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iDestX;

	mov	eax, DWORD PTR _i$221733[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+12]
	mov	DWORD PTR $T237669[ebp], eax
	mov	ecx, DWORD PTR $T237669[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4759 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iDestY;

	mov	edx, DWORD PTR _i$221733[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR $T237676[ebp], edx
	mov	eax, DWORD PTR $T237676[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4760 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_eOriginOwner;

	mov	ecx, DWORD PTR _i$221733[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+20]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 4761 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_eDestOwner;

	mov	eax, DWORD PTR _i$221733[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+24]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 4762 : 			int iDomain;
; 4763 : 			loadFrom >> iDomain;

	lea	edx, DWORD PTR _iDomain$221738[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4764 : 			writeTo.m_aRecentlyExpiredConnections[i].m_eDomain = (DomainTypes)iDomain;

	mov	eax, DWORD PTR _i$221733[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iDomain$221738[ebp]
	mov	DWORD PTR [edx+eax+28], ecx

; 4765 : 			int iConnectionType;
; 4766 : 			loadFrom >> iConnectionType;

	lea	edx, DWORD PTR _iConnectionType$221740[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4767 : 			writeTo.m_aRecentlyExpiredConnections[i].m_eConnectionType = (TradeConnectionType)iConnectionType;

	mov	eax, DWORD PTR _i$221733[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iConnectionType$221740[ebp]
	mov	DWORD PTR [edx+eax+32], ecx

; 4768 : 
; 4769 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iTradeUnitLocationIndex;

	mov	edx, DWORD PTR _i$221733[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+36]
	mov	DWORD PTR $T237701[ebp], edx
	mov	eax, DWORD PTR $T237701[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4770 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_bTradeUnitMovingForward;

	mov	ecx, DWORD PTR _i$221733[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+40]
	mov	DWORD PTR $T237708[ebp], ecx
	mov	edx, DWORD PTR $T237708[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 4771 : 
; 4772 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_unitID;

	mov	eax, DWORD PTR _i$221733[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+380]
	mov	DWORD PTR $T237715[ebp], eax
	mov	ecx, DWORD PTR $T237715[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4773 : 
; 4774 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iCircuitsCompleted;

	mov	edx, DWORD PTR _i$221733[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+384]
	mov	DWORD PTR $T237722[ebp], edx
	mov	eax, DWORD PTR $T237722[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4775 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iCircuitsToComplete;

	mov	ecx, DWORD PTR _i$221733[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+388]
	mov	DWORD PTR $T237729[ebp], ecx
	mov	edx, DWORD PTR $T237729[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4776 : 
; 4777 : 			loadFrom >> writeTo.m_aRecentlyExpiredConnections[i].m_iTurnRouteComplete;

	mov	eax, DWORD PTR _i$221733[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+392]
	mov	DWORD PTR $T237736[ebp], eax
	mov	ecx, DWORD PTR $T237736[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4778 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kTradeConnection$221737[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN7@operator@4
$LN6@operator@4:

; 4779 : 	}
; 4780 : 	else

	jmp	SHORT $LN5@operator@4
$LN9@operator@4:

; 4781 : 	{
; 4782 : 		int iEmptyInt;
; 4783 : 		loadFrom >> iEmptyInt;

	lea	edx, DWORD PTR _iEmptyInt$221743[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN5@operator@4:

; 4784 : 	}
; 4785 : 
; 4786 : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	$LN4@operator@4

; 4787 : 	{
; 4788 : 		int iNum = 0;

	mov	DWORD PTR _iNum$221745[ebp], 0

; 4789 : 		loadFrom >> iNum;

	lea	eax, DWORD PTR _iNum$221745[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4790 : 		for (int i = 0; i < iNum; i++)

	mov	DWORD PTR _i$221746[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	ecx, DWORD PTR _i$221746[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$221746[ebp], ecx
$LN3@operator@4:
	mov	edx, DWORD PTR _i$221746[ebp]
	cmp	edx, DWORD PTR _iNum$221745[ebp]
	jge	$LN4@operator@4

; 4791 : 		{
; 4792 : 			TradeConnectionWasPlundered kTradeConnectionWasPlundered;

	lea	ecx, DWORD PTR _kTradeConnectionWasPlundered$221750[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4793 : 			writeTo.m_aTradeConnectionWasPlundered.push_back(kTradeConnectionWasPlundered);

	lea	eax, DWORD PTR _kTradeConnectionWasPlundered$221750[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 74608				; 00012370H
	call	?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back

; 4794 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_iTurnPlundered;

	mov	ecx, DWORD PTR _i$221746[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+444]
	mov	DWORD PTR $T237776[ebp], ecx
	mov	edx, DWORD PTR $T237776[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4795 : 
; 4796 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iOriginX;

	mov	eax, DWORD PTR _i$221746[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR $T237783[ebp], eax
	mov	ecx, DWORD PTR $T237783[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4797 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iOriginY;

	mov	edx, DWORD PTR _i$221746[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T237790[ebp], edx
	mov	eax, DWORD PTR $T237790[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4798 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iDestX;

	mov	ecx, DWORD PTR _i$221746[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+12]
	mov	DWORD PTR $T237797[ebp], ecx
	mov	edx, DWORD PTR $T237797[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4799 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iDestY;

	mov	eax, DWORD PTR _i$221746[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR $T237804[ebp], eax
	mov	ecx, DWORD PTR $T237804[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4800 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eOriginOwner;

	mov	edx, DWORD PTR _i$221746[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+20]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 4801 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eDestOwner;

	mov	ecx, DWORD PTR _i$221746[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+24]
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 4802 : 			int iDomain;
; 4803 : 			loadFrom >> iDomain;

	lea	eax, DWORD PTR _iDomain$221751[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4804 : 			writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eDomain = (DomainTypes)iDomain;

	mov	ecx, DWORD PTR _i$221746[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	edx, DWORD PTR _iDomain$221751[ebp]
	mov	DWORD PTR [eax+ecx+28], edx

; 4805 : 			int iConnectionType;
; 4806 : 			loadFrom >> iConnectionType;

	lea	eax, DWORD PTR _iConnectionType$221753[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4807 : 			writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_eConnectionType = (TradeConnectionType)iConnectionType;

	mov	ecx, DWORD PTR _i$221746[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	edx, DWORD PTR _iConnectionType$221753[ebp]
	mov	DWORD PTR [eax+ecx+32], edx

; 4808 : 
; 4809 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iTradeUnitLocationIndex;

	mov	eax, DWORD PTR _i$221746[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR $T237829[ebp], eax
	mov	ecx, DWORD PTR $T237829[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4810 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_bTradeUnitMovingForward;

	mov	edx, DWORD PTR _i$221746[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+40]
	mov	DWORD PTR $T237836[ebp], edx
	mov	eax, DWORD PTR $T237836[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 4811 : 
; 4812 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_unitID;

	mov	ecx, DWORD PTR _i$221746[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+380]
	mov	DWORD PTR $T237843[ebp], ecx
	mov	edx, DWORD PTR $T237843[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4813 : 
; 4814 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iCircuitsCompleted;

	mov	eax, DWORD PTR _i$221746[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+384]
	mov	DWORD PTR $T237850[ebp], eax
	mov	ecx, DWORD PTR $T237850[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4815 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iCircuitsToComplete;

	mov	edx, DWORD PTR _i$221746[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+388]
	mov	DWORD PTR $T237857[ebp], edx
	mov	eax, DWORD PTR $T237857[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4816 : 
; 4817 : 			loadFrom >> writeTo.m_aTradeConnectionWasPlundered[i].m_kTradeConnection.m_iTurnRouteComplete;

	mov	ecx, DWORD PTR _i$221746[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+392]
	mov	DWORD PTR $T237864[ebp], ecx
	mov	edx, DWORD PTR $T237864[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4818 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kTradeConnectionWasPlundered$221750[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN2@operator@4
$LN4@operator@4:

; 4819 : 	}
; 4820 : 
; 4821 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 4822 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$0:
	lea	ecx, DWORD PTR _kTradeConnection$221737[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__unwindfunclet$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z$1:
	lea	ecx, DWORD PTR _kTradeConnectionWasPlundered$221750[ebp]
	jmp	??1TradeConnectionWasPlundered@@QAE@XZ
__ehhandler$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1064]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5@YAAAVFDataStream@@AAV0@AAVCvPlayerTrade@@@Z ENDP	; operator>>
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z	; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z
_TEXT	SEGMENT
$T238130 = -140						; size = 4
$T238123 = -136						; size = 4
$T238116 = -132						; size = 4
$T238109 = -128						; size = 4
$T238102 = -124						; size = 4
$T238095 = -120						; size = 4
$T238070 = -116						; size = 4
$T238063 = -112						; size = 4
$T238056 = -108						; size = 4
$T238049 = -104						; size = 4
$T238042 = -100						; size = 4
$T238035 = -96						; size = 4
$T238028 = -92						; size = 4
$T238024 = -88						; size = 4
$T238017 = -84						; size = 4
$T238010 = -80						; size = 4
$T238003 = -76						; size = 4
$T237996 = -72						; size = 4
$T237989 = -68						; size = 4
$T237964 = -64						; size = 4
$T237957 = -60						; size = 4
$T237950 = -56						; size = 4
$T237943 = -52						; size = 4
$T237936 = -48						; size = 4
$T237929 = -44						; size = 4
$T237922 = -40						; size = 4
$T237915 = -36						; size = 4
$T237914 = -32						; size = 4
$T237913 = -28						; size = 4
$T237912 = -24						; size = 4
$T237911 = -20						; size = 4
$T237910 = -16						; size = 4
_ui$221770 = -12					; size = 4
_ui$221761 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z PROC	; operator<<, COMDAT

; 4826 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH

; 4827 : 	uint uiVersion = 2;

	mov	DWORD PTR _uiVersion$[ebp], 2

; 4828 : 	saveTo << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4829 : 
; 4830 : 	saveTo << readFrom.m_aRecentlyExpiredConnections.size();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237922[ebp], edx
	mov	eax, DWORD PTR $T237922[ebp]
	mov	DWORD PTR $T237910[ebp], eax
	lea	ecx, DWORD PTR $T237910[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4831 : #ifdef AUI_ITERATORIZE
; 4832 : 	for (TradeConnectionList::const_iterator it = readFrom.m_aRecentlyExpiredConnections.begin(); it != readFrom.m_aRecentlyExpiredConnections.end(); ++it)
; 4833 : 	{
; 4834 : 		saveTo << it->m_iID;
; 4835 : 
; 4836 : 		saveTo << it->m_iOriginX;
; 4837 : 		saveTo << it->m_iOriginY;
; 4838 : 		saveTo << it->m_iDestX;
; 4839 : 		saveTo << it->m_iDestY;
; 4840 : 		saveTo << it->m_eOriginOwner;
; 4841 : 		saveTo << it->m_eDestOwner;
; 4842 : 		saveTo << (int)it->m_eDomain;
; 4843 : 		saveTo << (int)it->m_eConnectionType;
; 4844 : 		saveTo << it->m_iTradeUnitLocationIndex;
; 4845 : 		saveTo << it->m_bTradeUnitMovingForward;
; 4846 : 		saveTo << it->m_unitID;
; 4847 : 		saveTo << it->m_iCircuitsCompleted;
; 4848 : 		saveTo << it->m_iCircuitsToComplete;
; 4849 : 		saveTo << it->m_iTurnRouteComplete;
; 4850 : #else
; 4851 : 	for (uint ui = 0; ui < readFrom.m_aRecentlyExpiredConnections.size(); ui++)

	mov	DWORD PTR _ui$221761[ebp], 0
	jmp	SHORT $LN6@operator@5
$LN5@operator@5:
	mov	edx, DWORD PTR _ui$221761[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$221761[ebp], edx
$LN6@operator@5:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237929[ebp], ecx
	mov	edx, DWORD PTR _ui$221761[ebp]
	cmp	edx, DWORD PTR $T237929[ebp]
	jae	$LN4@operator@5

; 4852 : 	{
; 4853 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iID;

	mov	eax, DWORD PTR _ui$221761[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T237936[ebp], eax
	mov	edx, DWORD PTR $T237936[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4854 : 
; 4855 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iOriginX;

	mov	eax, DWORD PTR _ui$221761[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR $T237943[ebp], eax
	mov	ecx, DWORD PTR $T237943[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4856 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iOriginY;

	mov	edx, DWORD PTR _ui$221761[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T237950[ebp], edx
	mov	eax, DWORD PTR $T237950[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4857 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iDestX;

	mov	ecx, DWORD PTR _ui$221761[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+12]
	mov	DWORD PTR $T237957[ebp], ecx
	mov	edx, DWORD PTR $T237957[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4858 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iDestY;

	mov	eax, DWORD PTR _ui$221761[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+16]
	mov	DWORD PTR $T237964[ebp], eax
	mov	ecx, DWORD PTR $T237964[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4859 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_eOriginOwner;

	mov	edx, DWORD PTR _ui$221761[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+20]
	push	edx
	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 4860 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_eDestOwner;

	mov	ecx, DWORD PTR _ui$221761[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+24]
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 4861 : 		saveTo << (int)readFrom.m_aRecentlyExpiredConnections[ui].m_eDomain;

	mov	eax, DWORD PTR _ui$221761[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+eax+28]
	mov	DWORD PTR $T237911[ebp], eax
	lea	ecx, DWORD PTR $T237911[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4862 : 		saveTo << (int)readFrom.m_aRecentlyExpiredConnections[ui].m_eConnectionType;

	mov	edx, DWORD PTR _ui$221761[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+edx+32]
	mov	DWORD PTR $T237912[ebp], edx
	lea	eax, DWORD PTR $T237912[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4863 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iTradeUnitLocationIndex;

	mov	ecx, DWORD PTR _ui$221761[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+36]
	mov	DWORD PTR $T237989[ebp], ecx
	mov	edx, DWORD PTR $T237989[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4864 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_bTradeUnitMovingForward;

	mov	eax, DWORD PTR _ui$221761[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+40]
	mov	DWORD PTR $T237996[ebp], eax
	mov	ecx, DWORD PTR $T237996[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 4865 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_unitID;

	mov	edx, DWORD PTR _ui$221761[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+380]
	mov	DWORD PTR $T238003[ebp], edx
	mov	eax, DWORD PTR $T238003[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4866 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iCircuitsCompleted;

	mov	ecx, DWORD PTR _ui$221761[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx+384]
	mov	DWORD PTR $T238010[ebp], ecx
	mov	edx, DWORD PTR $T238010[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4867 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iCircuitsToComplete;

	mov	eax, DWORD PTR _ui$221761[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax+388]
	mov	DWORD PTR $T238017[ebp], eax
	mov	ecx, DWORD PTR $T238017[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4868 : 		saveTo << readFrom.m_aRecentlyExpiredConnections[ui].m_iTurnRouteComplete;

	mov	edx, DWORD PTR _ui$221761[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx+392]
	mov	DWORD PTR $T238024[ebp], edx
	mov	eax, DWORD PTR $T238024[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4869 : #endif
; 4870 : 	}

	jmp	$LN5@operator@5
$LN4@operator@5:

; 4871 : 
; 4872 : 	saveTo << readFrom.m_aTradeConnectionWasPlundered.size();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+74612]
	mov	DWORD PTR $T238028[ebp], edx
	mov	eax, DWORD PTR $T238028[ebp]
	mov	DWORD PTR $T237913[ebp], eax
	lea	ecx, DWORD PTR $T237913[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4873 : #ifdef AUI_ITERATORIZE
; 4874 : 	for (TradeConnectionWasPlunderedList::const_iterator it = readFrom.m_aTradeConnectionWasPlundered.begin(); it != readFrom.m_aTradeConnectionWasPlundered.end(); ++it)
; 4875 : 	{
; 4876 : 		saveTo << it->m_iTurnPlundered;
; 4877 : 
; 4878 : 		saveTo << it->m_kTradeConnection.m_iOriginX;
; 4879 : 		saveTo << it->m_kTradeConnection.m_iOriginY;
; 4880 : 		saveTo << it->m_kTradeConnection.m_iDestX;
; 4881 : 		saveTo << it->m_kTradeConnection.m_iDestY;
; 4882 : 		saveTo << it->m_kTradeConnection.m_eOriginOwner;
; 4883 : 		saveTo << it->m_kTradeConnection.m_eDestOwner;
; 4884 : 		saveTo << (int)it->m_kTradeConnection.m_eDomain;
; 4885 : 		saveTo << (int)it->m_kTradeConnection.m_eConnectionType;
; 4886 : 		saveTo << it->m_kTradeConnection.m_iTradeUnitLocationIndex;
; 4887 : 		saveTo << it->m_kTradeConnection.m_bTradeUnitMovingForward;
; 4888 : 		saveTo << it->m_kTradeConnection.m_unitID;
; 4889 : 		saveTo << it->m_kTradeConnection.m_iCircuitsCompleted;
; 4890 : 		saveTo << it->m_kTradeConnection.m_iCircuitsToComplete;
; 4891 : 		saveTo << it->m_kTradeConnection.m_iTurnRouteComplete;
; 4892 : #else
; 4893 : 	for (uint ui = 0; ui < readFrom.m_aTradeConnectionWasPlundered.size(); ui++)

	mov	DWORD PTR _ui$221770[ebp], 0
	jmp	SHORT $LN3@operator@5
$LN2@operator@5:
	mov	edx, DWORD PTR _ui$221770[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$221770[ebp], edx
$LN3@operator@5:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+74612]
	mov	DWORD PTR $T238035[ebp], ecx
	mov	edx, DWORD PTR _ui$221770[ebp]
	cmp	edx, DWORD PTR $T238035[ebp]
	jae	$LN1@operator@5

; 4894 : 	{
; 4895 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_iTurnPlundered;

	mov	eax, DWORD PTR _ui$221770[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+444]
	mov	DWORD PTR $T238042[ebp], eax
	mov	ecx, DWORD PTR $T238042[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4896 : 
; 4897 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginX;

	mov	edx, DWORD PTR _ui$221770[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+4]
	mov	DWORD PTR $T238049[ebp], edx
	mov	eax, DWORD PTR $T238049[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4898 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iOriginY;

	mov	ecx, DWORD PTR _ui$221770[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T238056[ebp], ecx
	mov	edx, DWORD PTR $T238056[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4899 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestX;

	mov	eax, DWORD PTR _ui$221770[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+12]
	mov	DWORD PTR $T238063[ebp], eax
	mov	ecx, DWORD PTR $T238063[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4900 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iDestY;

	mov	edx, DWORD PTR _ui$221770[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+16]
	mov	DWORD PTR $T238070[ebp], edx
	mov	eax, DWORD PTR $T238070[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4901 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eOriginOwner;

	mov	ecx, DWORD PTR _ui$221770[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+20]
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 4902 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eDestOwner;

	mov	eax, DWORD PTR _ui$221770[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+24]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 4903 : 		saveTo << (int)readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eDomain;

	mov	edx, DWORD PTR _ui$221770[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	mov	edx, DWORD PTR [ecx+edx+28]
	mov	DWORD PTR $T237914[ebp], edx
	lea	eax, DWORD PTR $T237914[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4904 : 		saveTo << (int)readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_eConnectionType;

	mov	ecx, DWORD PTR _ui$221770[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	mov	ecx, DWORD PTR [eax+ecx+32]
	mov	DWORD PTR $T237915[ebp], ecx
	lea	edx, DWORD PTR $T237915[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4905 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iTradeUnitLocationIndex;

	mov	eax, DWORD PTR _ui$221770[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR $T238095[ebp], eax
	mov	ecx, DWORD PTR $T238095[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4906 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_bTradeUnitMovingForward;

	mov	edx, DWORD PTR _ui$221770[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+40]
	mov	DWORD PTR $T238102[ebp], edx
	mov	eax, DWORD PTR $T238102[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 4907 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_unitID;

	mov	ecx, DWORD PTR _ui$221770[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+380]
	mov	DWORD PTR $T238109[ebp], ecx
	mov	edx, DWORD PTR $T238109[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4908 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iCircuitsCompleted;

	mov	eax, DWORD PTR _ui$221770[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+74608]
	lea	eax, DWORD PTR [edx+eax+384]
	mov	DWORD PTR $T238116[ebp], eax
	mov	ecx, DWORD PTR $T238116[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4909 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iCircuitsToComplete;

	mov	edx, DWORD PTR _ui$221770[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+74608]
	lea	edx, DWORD PTR [ecx+edx+388]
	mov	DWORD PTR $T238123[ebp], edx
	mov	eax, DWORD PTR $T238123[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4910 : 		saveTo << readFrom.m_aTradeConnectionWasPlundered[ui].m_kTradeConnection.m_iTurnRouteComplete;

	mov	ecx, DWORD PTR _ui$221770[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+74608]
	lea	ecx, DWORD PTR [eax+ecx+392]
	mov	DWORD PTR $T238130[ebp], ecx
	mov	edx, DWORD PTR $T238130[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4911 : #endif
; 4912 : 	}

	jmp	$LN2@operator@5
$LN1@operator@5:

; 4913 : 
; 4914 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 4915 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvPlayerTrade@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??0CvTradeAI@@QAE@XZ				; CvTradeAI::CvTradeAI
; Function compile flags: /Odtp
;	COMDAT ??0CvTradeAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvTradeAI@@QAE@XZ PROC				; CvTradeAI::CvTradeAI, COMDAT
; _this$ = ecx

; 4926 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4927 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvTradeAI@@QAE@XZ ENDP				; CvTradeAI::CvTradeAI
_TEXT	ENDS
PUBLIC	?Uninit@CvTradeAI@@QAEXXZ			; CvTradeAI::Uninit
PUBLIC	??1CvTradeAI@@QAE@XZ				; CvTradeAI::~CvTradeAI
; Function compile flags: /Odtp
;	COMDAT ??1CvTradeAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvTradeAI@@QAE@XZ PROC				; CvTradeAI::~CvTradeAI, COMDAT
; _this$ = ecx

; 4931 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4932 : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvTradeAI@@QAEXXZ		; CvTradeAI::Uninit

; 4933 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvTradeAI@@QAE@XZ ENDP				; CvTradeAI::~CvTradeAI
_TEXT	ENDS
PUBLIC	?Reset@CvTradeAI@@QAEXXZ			; CvTradeAI::Reset
PUBLIC	?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z		; CvTradeAI::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z PROC		; CvTradeAI::Init, COMDAT
; _this$ = ecx

; 4937 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4938 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvTradeAI@@QAEXXZ		; CvTradeAI::Reset

; 4939 : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 4940 : 	m_iRemovableValue = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 4941 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvTradeAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvTradeAI::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@CvTradeAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninit@CvTradeAI@@QAEXXZ PROC				; CvTradeAI::Uninit, COMDAT
; _this$ = ecx

; 4945 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4946 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvTradeAI@@QAEXXZ		; CvTradeAI::Reset

; 4947 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvTradeAI@@QAEXXZ ENDP				; CvTradeAI::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Reset@CvTradeAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@CvTradeAI@@QAEXXZ PROC				; CvTradeAI::Reset, COMDAT
; _this$ = ecx

; 4951 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4952 : 	m_pPlayer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 4953 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvTradeAI@@QAEXXZ ENDP				; CvTradeAI::Reset
_TEXT	ENDS
PUBLIC	?DoTurn@CvTradeAI@@QAEXXZ			; CvTradeAI::DoTurn
; Function compile flags: /Odtp
;	COMDAT ?DoTurn@CvTradeAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoTurn@CvTradeAI@@QAEXXZ PROC				; CvTradeAI::DoTurn, COMDAT
; _this$ = ecx

; 4957 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4958 : 
; 4959 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTurn@CvTradeAI@@QAEXXZ ENDP				; CvTradeAI::DoTurn
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
PUBLIC	__$ArrayPad$
PUBLIC	?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::GetAvailableTR
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0
__ehfuncinfo$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
_this$ = -640						; size = 4
$T238279 = -596						; size = 4
$T238244 = -580						; size = 4
$T238240 = -576						; size = 4
$T238236 = -572						; size = 4
$T238227 = -568						; size = 4
$T238218 = -564						; size = 4
$T238209 = -560						; size = 4
$T238200 = -556						; size = 4
$T238191 = -552						; size = 4
$T238178 = -548						; size = 4
$T238174 = -544						; size = 4
$T238170 = -540						; size = 4
$T238166 = -533						; size = 1
$T238157 = -532						; size = 4
$T238153 = -528						; size = 4
_kConnection$221842 = -524				; size = 444
__$ArrayPad$ = -72					; size = 4
_pNode$221843 = -68					; size = 4
_bTradeAvailable$221838 = -61				; size = 1
_uiConnectionTypes$221833 = -60				; size = 4
_bCheckPath$221831 = -53				; size = 1
_eConnection$221832 = -52				; size = 4
_eDomain$221824 = -48					; size = 4
_iDestCityLoop$221818 = -44				; size = 4
_pDestCity$221819 = -40					; size = 4
_ui$221811 = -36					; size = 4
_eOtherPlayer$221810 = -32				; size = 4
_pPlayerTrade$ = -28					; size = 4
_pGameTrade$ = -24					; size = 4
_iOriginCityLoop$ = -20					; size = 4
_pOriginCity$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_aTradeConnectionList$ = 8				; size = 4
?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z PROC ; CvTradeAI::GetAvailableTR, COMDAT
; _this$ = ecx

; 4963 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 628				; 00000274H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4964 : 	aTradeConnectionList.clear();

	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 4965 : 
; 4966 : 	// build trade route list
; 4967 : 	CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	DWORD PTR _pPlayerTrade$[ebp], eax

; 4968 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238153[ebp], eax
	mov	ecx, DWORD PTR $T238153[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pGameTrade$[ebp], eax

; 4969 : 	int iOriginCityLoop;
; 4970 : 	CvCity* pOriginCity = NULL;

	mov	DWORD PTR _pOriginCity$[ebp], 0

; 4971 : 	for (pOriginCity = m_pPlayer->firstCity(&iOriginCityLoop); pOriginCity != NULL; pOriginCity = m_pPlayer->nextCity(&iOriginCityLoop))

	push	0
	lea	ecx, DWORD PTR _iOriginCityLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pOriginCity$[ebp], eax
	jmp	SHORT $LN26@GetAvailab
$LN25@GetAvailab:
	push	0
	lea	eax, DWORD PTR _iOriginCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pOriginCity$[ebp], eax
$LN26@GetAvailab:
	cmp	DWORD PTR _pOriginCity$[ebp], 0
	je	$LN27@GetAvailab

; 4972 : 	{
; 4973 : 		PlayerTypes eOtherPlayer = NO_PLAYER;

	mov	DWORD PTR _eOtherPlayer$221810[ebp], -1

; 4974 : 		for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	mov	DWORD PTR _ui$221811[ebp], 0
	jmp	SHORT $LN23@GetAvailab
$LN22@GetAvailab:
	mov	edx, DWORD PTR _ui$221811[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$221811[ebp], edx
$LN23@GetAvailab:
	cmp	DWORD PTR _ui$221811[ebp], 63		; 0000003fH
	jae	$LN21@GetAvailab

; 4975 : 		{
; 4976 : 			eOtherPlayer = (PlayerTypes)ui;

	mov	eax, DWORD PTR _ui$221811[ebp]
	mov	DWORD PTR _eOtherPlayer$221810[ebp], eax

; 4977 : 
; 4978 : 			if (!GET_PLAYER(eOtherPlayer).isAlive())

	mov	ecx, DWORD PTR _eOtherPlayer$221810[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238157[ebp], ecx
	mov	edx, DWORD PTR $T238157[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238166[ebp], al
	movzx	ecx, BYTE PTR $T238166[ebp]
	test	ecx, ecx
	jne	SHORT $LN20@GetAvailab

; 4979 : 			{
; 4980 : 				continue;

	jmp	SHORT $LN22@GetAvailab
$LN20@GetAvailab:

; 4981 : 			}
; 4982 : 
; 4983 : 			if (GET_PLAYER(eOtherPlayer).isBarbarian())

	mov	edx, DWORD PTR _eOtherPlayer$221810[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238170[ebp], edx
	mov	ecx, DWORD PTR $T238170[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@GetAvailab

; 4984 : 			{
; 4985 : 				continue;

	jmp	SHORT $LN22@GetAvailab
$LN19@GetAvailab:

; 4986 : 			}
; 4987 : 
; 4988 : 			int iDestCityLoop;
; 4989 : 			CvCity* pDestCity = NULL;

	mov	DWORD PTR _pDestCity$221819[ebp], 0

; 4990 : 			for (pDestCity = GET_PLAYER(eOtherPlayer).firstCity(&iDestCityLoop); pDestCity != NULL; pDestCity = GET_PLAYER(eOtherPlayer).nextCity(&iDestCityLoop))

	mov	ecx, DWORD PTR _eOtherPlayer$221810[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238174[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iDestCityLoop$221818[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238174[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pDestCity$221819[ebp], eax
	jmp	SHORT $LN18@GetAvailab
$LN17@GetAvailab:
	mov	eax, DWORD PTR _eOtherPlayer$221810[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238178[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iDestCityLoop$221818[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238178[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pDestCity$221819[ebp], eax
$LN18@GetAvailab:
	cmp	DWORD PTR _pDestCity$221819[ebp], 0
	je	$LN16@GetAvailab

; 4991 : 			{
; 4992 : 				// if this is the same city
; 4993 : 				if (pOriginCity == pDestCity)

	mov	edx, DWORD PTR _pOriginCity$[ebp]
	cmp	edx, DWORD PTR _pDestCity$221819[ebp]
	jne	SHORT $LN15@GetAvailab

; 4994 : 				{
; 4995 : 					continue;

	jmp	SHORT $LN17@GetAvailab
$LN15@GetAvailab:

; 4996 : 				}
; 4997 : 
; 4998 : 				DomainTypes eDomain = NO_DOMAIN;

	mov	DWORD PTR _eDomain$221824[ebp], -1

; 4999 : 				for (eDomain = (DomainTypes)0; eDomain < NUM_DOMAIN_TYPES; eDomain = (DomainTypes)(eDomain + 1))

	mov	DWORD PTR _eDomain$221824[ebp], 0
	jmp	SHORT $LN14@GetAvailab
$LN13@GetAvailab:
	mov	eax, DWORD PTR _eDomain$221824[ebp]
	add	eax, 1
	mov	DWORD PTR _eDomain$221824[ebp], eax
$LN14@GetAvailab:
	cmp	DWORD PTR _eDomain$221824[ebp], 5
	jge	$LN12@GetAvailab

; 5000 : 				{
; 5001 : 					// if this isn't a valid trade domain, ignore
; 5002 : 					if (eDomain != DOMAIN_LAND && eDomain != DOMAIN_SEA)

	cmp	DWORD PTR _eDomain$221824[ebp], 2
	je	SHORT $LN11@GetAvailab
	cmp	DWORD PTR _eDomain$221824[ebp], 0
	je	SHORT $LN11@GetAvailab

; 5003 : 					{
; 5004 : 						continue;

	jmp	SHORT $LN13@GetAvailab
$LN11@GetAvailab:

; 5005 : 					}
; 5006 : 
; 5007 : 					bool bCheckPath = true;

	mov	BYTE PTR _bCheckPath$221831[ebp], 1

; 5008 : 					TradeConnectionType eConnection = NUM_TRADE_CONNECTION_TYPES;

	mov	DWORD PTR _eConnection$221832[ebp], 3

; 5009 : 					for (uint uiConnectionTypes = 0; uiConnectionTypes < NUM_TRADE_CONNECTION_TYPES; uiConnectionTypes++)

	mov	DWORD PTR _uiConnectionTypes$221833[ebp], 0
	jmp	SHORT $LN10@GetAvailab
$LN9@GetAvailab:
	mov	ecx, DWORD PTR _uiConnectionTypes$221833[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiConnectionTypes$221833[ebp], ecx
$LN10@GetAvailab:
	cmp	DWORD PTR _uiConnectionTypes$221833[ebp], 3
	jae	$LN8@GetAvailab

; 5010 : 					{
; 5011 : 						eConnection = (TradeConnectionType)uiConnectionTypes;

	mov	edx, DWORD PTR _uiConnectionTypes$221833[ebp]
	mov	DWORD PTR _eConnection$221832[ebp], edx

; 5012 : 
; 5013 : 						// Check the trade route, ignoring the path for now
; 5014 : 						bool bTradeAvailable = pPlayerTrade->CanCreateTradeRoute(pOriginCity, pDestCity, eDomain, eConnection, true, false);

	push	0
	push	1
	mov	eax, DWORD PTR _eConnection$221832[ebp]
	push	eax
	mov	ecx, DWORD PTR _eDomain$221824[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDestCity$221819[ebp]
	push	edx
	mov	eax, DWORD PTR _pOriginCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayerTrade$[ebp]
	call	?CanCreateTradeRoute@CvPlayerTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@W4TradeConnectionType@@_N3@Z ; CvPlayerTrade::CanCreateTradeRoute
	mov	BYTE PTR _bTradeAvailable$221838[ebp], al

; 5015 : 						if (!bTradeAvailable)

	movzx	ecx, BYTE PTR _bTradeAvailable$221838[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@GetAvailab

; 5016 : 						{
; 5017 : 							continue;

	jmp	SHORT $LN9@GetAvailab
$LN7@GetAvailab:

; 5018 : 						}
; 5019 : 
; 5020 : 						// Now test the path
; 5021 : 						if (bCheckPath)

	movzx	edx, BYTE PTR _bCheckPath$221831[ebp]
	test	edx, edx
	je	SHORT $LN6@GetAvailab

; 5022 : 						{
; 5023 : 							bTradeAvailable = pGameTrade->IsValidTradeRoutePath(pOriginCity, pDestCity, eDomain);

	mov	eax, DWORD PTR _eDomain$221824[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDestCity$221819[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOriginCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGameTrade$[ebp]
	call	?IsValidTradeRoutePath@CvGameTrade@@QAE_NPAVCvCity@@0W4DomainTypes@@@Z ; CvGameTrade::IsValidTradeRoutePath
	mov	BYTE PTR _bTradeAvailable$221838[ebp], al

; 5024 : 							if (!bTradeAvailable)

	movzx	eax, BYTE PTR _bTradeAvailable$221838[ebp]
	test	eax, eax
	jne	SHORT $LN5@GetAvailab

; 5025 : 								break;		// If there is no path for this domain, just skip the rest of the connection tests.

	jmp	$LN8@GetAvailab
$LN5@GetAvailab:

; 5026 : 
; 5027 : 							bCheckPath = false;		// No need to check the path for this domain again

	mov	BYTE PTR _bCheckPath$221831[ebp], 0
$LN6@GetAvailab:

; 5028 : 						}
; 5029 : 
; 5030 : 						TradeConnection kConnection;

	lea	ecx, DWORD PTR _kConnection$221842[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5031 : 						kConnection.m_iOriginX = pOriginCity->getX();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T238191[ebp], edx
	mov	eax, DWORD PTR $T238191[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+4], eax

; 5032 : 						kConnection.m_iOriginY = pOriginCity->getY();

	mov	ecx, DWORD PTR _pOriginCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T238200[ebp], edx
	mov	eax, DWORD PTR $T238200[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+8], eax

; 5033 : 						kConnection.m_iDestX = pDestCity->getX();

	mov	ecx, DWORD PTR _pDestCity$221819[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T238209[ebp], edx
	mov	eax, DWORD PTR $T238209[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+12], eax

; 5034 : 						kConnection.m_iDestY = pDestCity->getY();

	mov	ecx, DWORD PTR _pDestCity$221819[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T238218[ebp], edx
	mov	eax, DWORD PTR $T238218[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+16], eax

; 5035 : 						kConnection.m_eConnectionType = eConnection;

	mov	ecx, DWORD PTR _eConnection$221832[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+32], ecx

; 5036 : 						kConnection.m_eDomain = eDomain;

	mov	edx, DWORD PTR _eDomain$221824[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+28], edx

; 5037 : 						kConnection.m_eOriginOwner = pOriginCity->getOwner();

	mov	eax, DWORD PTR _pOriginCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T238227[ebp], ecx
	mov	edx, DWORD PTR $T238227[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+20], edx

; 5038 : 						kConnection.m_eDestOwner = pDestCity->getOwner();

	mov	eax, DWORD PTR _pDestCity$221819[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T238236[ebp], ecx
	mov	edx, DWORD PTR $T238236[ebp]
	mov	DWORD PTR _kConnection$221842[ebp+24], edx

; 5039 : 
; 5040 : 						CvAStarNode* pNode = NULL;

	mov	DWORD PTR _pNode$221843[ebp], 0

; 5041 : 						if (eDomain ==  DOMAIN_LAND)

	cmp	DWORD PTR _eDomain$221824[ebp], 2
	jne	SHORT $LN4@GetAvailab

; 5042 : 						{
; 5043 : 							pNode = GC.GetInternationalTradeRouteLandFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	DWORD PTR $T238240[ebp], eax
	mov	eax, DWORD PTR $T238240[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$221843[ebp], ecx

; 5044 : 						}
; 5045 : 						else if (eDomain == DOMAIN_SEA)

	jmp	SHORT $LN3@GetAvailab
$LN4@GetAvailab:
	cmp	DWORD PTR _eDomain$221824[ebp], 0
	jne	SHORT $LN3@GetAvailab

; 5046 : 						{
; 5047 : 							pNode = GC.GetInternationalTradeRouteWaterFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	DWORD PTR $T238244[ebp], eax
	mov	edx, DWORD PTR $T238244[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pNode$221843[ebp], eax
$LN3@GetAvailab:

; 5048 : 						}
; 5049 : 
; 5050 : 						CvAssertMsg(pNode != NULL, "no path found for unit");
; 5051 : 						if (pNode == NULL)

	cmp	DWORD PTR _pNode$221843[ebp], 0
	jne	SHORT $LN1@GetAvailab

; 5052 : 						{
; 5053 : 							continue;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kConnection$221842[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN9@GetAvailab
$LN1@GetAvailab:

; 5054 : 						}
; 5055 : 
; 5056 : 						GC.getGame().GetGameTrade()->CopyPathIntoTradeConnection(pNode, &kConnection);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238279[ebp], ecx
	lea	edx, DWORD PTR _kConnection$221842[ebp]
	push	edx
	mov	eax, DWORD PTR _pNode$221843[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238279[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?CopyPathIntoTradeConnection@CvGameTrade@@QAEXPAVCvAStarNode@@PAUTradeConnection@@@Z ; CvGameTrade::CopyPathIntoTradeConnection

; 5057 : 						aTradeConnectionList.push_back(kConnection);

	lea	ecx, DWORD PTR _kConnection$221842[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 5058 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kConnection$221842[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN9@GetAvailab
$LN8@GetAvailab:

; 5059 : 				}

	jmp	$LN13@GetAvailab
$LN12@GetAvailab:

; 5060 : 			}

	jmp	$LN17@GetAvailab
$LN16@GetAvailab:

; 5061 : 		}

	jmp	$LN22@GetAvailab
$LN21@GetAvailab:

; 5062 : 	}

	jmp	$LN25@GetAvailab
$LN27@GetAvailab:

; 5063 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0:
	lea	ecx, DWORD PTR _kConnection$221842[ebp]
	jmp	??1TradeConnection@@QAE@XZ
__ehhandler$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-632]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ENDP ; CvTradeAI::GetAvailableTR
PUBLIC	?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z ; CvTradeAI::ScoreInternationalTR
EXTRN	?GetTourism@CvPlayerCulture@@QAEHXZ:PROC	; CvPlayerCulture::GetTourism
EXTRN	?WouldExertTradeRoutePressureToward@CvCityReligions@@QAE_NPAVCvCity@@AAW4ReligionTypes@@AAH@Z:PROC ; CvCityReligions::WouldExertTradeRoutePressureToward
EXTRN	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligionCreatedByPlayer
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
; Function compile flags: /Odtp
;	COMDAT ?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z
_TEXT	SEGMENT
tv374 = -236						; size = 4
_this$ = -232						; size = 4
$T238537 = -228						; size = 4
$T238533 = -224						; size = 4
$T238524 = -220						; size = 4
$T238520 = -216						; size = 4
$T238516 = -212						; size = 4
$T238512 = -208						; size = 4
$T238508 = -204						; size = 4
$T238499 = -200						; size = 4
$T238495 = -196						; size = 4
$T238491 = -192						; size = 4
$T238487 = -188						; size = 4
$T238483 = -184						; size = 4
$T238482 = -180						; size = 4
$T238473 = -176						; size = 4
_playerID$238465 = -172					; size = 4
$T238456 = -168						; size = 4
_playerID$238448 = -164					; size = 4
$T238439 = -157						; size = 1
$T238429 = -156						; size = 4
$T238428 = -152						; size = 4
$T238419 = -148						; size = 4
$T238418 = -144						; size = 4
$T238387 = -140						; size = 4
$T238382 = -136						; size = 4
$T238378 = -129						; size = 1
$T238367 = -128						; size = 4
$T238363 = -121						; size = 1
_iMapY$238396 = -120					; size = 4
_iMapX$238395 = -116					; size = 4
$T238356 = -112						; size = 4
$T238352 = -108						; size = 4
$T238348 = -104						; size = 4
$T238344 = -100						; size = 4
$T238340 = -96						; size = 4
_eToReligion$221880 = -92				; size = 4
_iToPressure$221881 = -88				; size = 4
_bAnyToCityPressure$221885 = -81			; size = 1
_eFromReligion$221882 = -80				; size = 4
_bAnyFromCityPressure$221884 = -73			; size = 1
_iFromPressure$221883 = -72				; size = 4
_pFromCity$221878 = -68					; size = 4
_pToCity$221877 = -64					; size = 4
_iDangerValue$221863 = -60				; size = 4
_pPlot$221861 = -56					; size = 4
_uiPlotList$221857 = -52				; size = 4
_eOwnerFoundedReligion$ = -48				; size = 4
_iOtherGoldAmount$ = -44				; size = 4
_iTechDelta$ = -40					; size = 4
_iGoldAmount$ = -36					; size = 4
_iTechDifferenceP2fromP1$ = -32				; size = 4
_iGoldDelta$ = -28					; size = 4
_pOtherPlayerTrade$ = -24				; size = 4
_iDangerSum$ = -20					; size = 4
_iTechDifferenceP1fromP2$ = -16				; size = 4
_pPlayerTrade$ = -12					; size = 4
_iReligionDelta$ = -8					; size = 4
_iScore$ = -4						; size = 4
_kTradeConnection$ = 8					; size = 4
?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z PROC ; CvTradeAI::ScoreInternationalTR, COMDAT
; _this$ = ecx

; 5071 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	mov	DWORD PTR _this$[ebp], ecx

; 5072 : 	// don't evaluate other trade types
; 5073 : 	if (kTradeConnection.m_eConnectionType != TRADE_CONNECTION_INTERNATIONAL)

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN19@ScoreInter

; 5074 : 	{
; 5075 : 		return 0;

	xor	eax, eax
	jmp	$LN20@ScoreInter
$LN19@ScoreInter:

; 5076 : 	}
; 5077 : 
; 5078 : 	// if this was recently plundered, 0 the score
; 5079 : 	if (m_pPlayer->GetTrade()->CheckTradeConnectionWasPlundered(kTradeConnection))

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@ScoreInter

; 5080 : 	{
; 5081 : 		return 0;

	xor	eax, eax
	jmp	$LN20@ScoreInter
$LN18@ScoreInter:

; 5082 : 	}
; 5083 : 
; 5084 : 	CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	DWORD PTR _pPlayerTrade$[ebp], eax

; 5085 : 	CvPlayerTrade* pOtherPlayerTrade = GET_PLAYER(kTradeConnection.m_eDestOwner).GetTrade();

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238340[ebp], eax
	mov	ecx, DWORD PTR $T238340[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	DWORD PTR _pOtherPlayerTrade$[ebp], eax

; 5086 : 	int iDangerSum = 1; // can't be zero because we divide by zero!

	mov	DWORD PTR _iDangerSum$[ebp], 1

; 5087 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	DWORD PTR _uiPlotList$221857[ebp], 0
	jmp	SHORT $LN17@ScoreInter
$LN16@ScoreInter:
	mov	ecx, DWORD PTR _uiPlotList$221857[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiPlotList$221857[ebp], ecx
$LN17@ScoreInter:
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T238344[ebp], eax
	mov	ecx, DWORD PTR _uiPlotList$221857[ebp]
	cmp	ecx, DWORD PTR $T238344[ebp]
	jae	$LN15@ScoreInter

; 5088 : 	{
; 5089 : 		CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[uiPlotList].m_iX, kTradeConnection.m_aPlotList[uiPlotList].m_iY);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _uiPlotList$221857[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T238348[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _uiPlotList$221857[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T238352[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238356[ebp], ecx
	mov	edx, DWORD PTR $T238348[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238419[ebp], eax
	mov	ecx, DWORD PTR $T238352[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T238418[ebp], edx
	cmp	DWORD PTR $T238418[ebp], -2147483647	; 80000001H
	je	SHORT $LN32@ScoreInter
	cmp	DWORD PTR $T238419[ebp], -2147483647	; 80000001H
	jne	SHORT $LN33@ScoreInter
$LN32@ScoreInter:
	mov	DWORD PTR _pPlot$221861[ebp], 0
	jmp	$LN34@ScoreInter
$LN33@ScoreInter:
	mov	eax, DWORD PTR $T238356[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T238363[ebp], cl
	mov	edx, DWORD PTR $T238356[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T238367[ebp], eax
	movzx	ecx, BYTE PTR $T238363[ebp]
	test	ecx, ecx
	je	SHORT $LN45@ScoreInter
	cmp	DWORD PTR $T238418[ebp], 0
	jge	SHORT $LN44@ScoreInter
	mov	eax, DWORD PTR $T238418[ebp]
	cdq
	idiv	DWORD PTR $T238367[ebp]
	add	edx, DWORD PTR $T238367[ebp]
	mov	DWORD PTR _iMapX$238395[ebp], edx
	jmp	SHORT $LN46@ScoreInter
	jmp	SHORT $LN45@ScoreInter
$LN44@ScoreInter:
	mov	edx, DWORD PTR $T238418[ebp]
	cmp	edx, DWORD PTR $T238367[ebp]
	jl	SHORT $LN45@ScoreInter
	mov	eax, DWORD PTR $T238418[ebp]
	cdq
	idiv	DWORD PTR $T238367[ebp]
	mov	DWORD PTR _iMapX$238395[ebp], edx
	jmp	SHORT $LN46@ScoreInter
$LN45@ScoreInter:
	mov	eax, DWORD PTR $T238418[ebp]
	mov	DWORD PTR _iMapX$238395[ebp], eax
$LN46@ScoreInter:
	mov	ecx, DWORD PTR $T238356[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T238378[ebp], dl
	mov	eax, DWORD PTR $T238356[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T238382[ebp], ecx
	movzx	edx, BYTE PTR $T238378[ebp]
	push	edx
	mov	eax, DWORD PTR $T238382[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238419[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$238396[ebp], eax
	mov	edx, DWORD PTR _iMapY$238396[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$238395[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238356[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN36@ScoreInter
	mov	ecx, DWORD PTR $T238356[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T238387[ebp], edx
	mov	eax, DWORD PTR _iMapY$238396[ebp]
	imul	eax, DWORD PTR $T238387[ebp]
	add	eax, DWORD PTR _iMapX$238395[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T238356[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv374[ebp], eax
	jmp	SHORT $LN37@ScoreInter
$LN36@ScoreInter:
	mov	DWORD PTR tv374[ebp], 0
$LN37@ScoreInter:
	mov	edx, DWORD PTR tv374[ebp]
	mov	DWORD PTR _pPlot$221861[ebp], edx
$LN34@ScoreInter:

; 5090 : 		CvAssertMsg(pPlot, "pPlot is null when trying to evaluate the list");
; 5091 : 		if (pPlot == NULL)

	cmp	DWORD PTR _pPlot$221861[ebp], 0
	jne	SHORT $LN14@ScoreInter

; 5092 : 		{
; 5093 : 			break;

	jmp	$LN15@ScoreInter
$LN14@ScoreInter:

; 5094 : 		}
; 5095 : 		int iDangerValue = m_pPlayer->GetPlotDanger(*pPlot);

	mov	eax, DWORD PTR _pPlot$221861[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	DWORD PTR _iDangerValue$221863[ebp], eax

; 5096 : 		if (iDangerValue == 0)

	cmp	DWORD PTR _iDangerValue$221863[ebp], 0
	jne	$LN13@ScoreInter

; 5097 : 		{
; 5098 : 			if (!pPlot->isVisible(m_pPlayer->getTeam()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238428[ebp], eax
	mov	ecx, DWORD PTR $T238428[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238429[ebp], eax
	cmp	DWORD PTR $T238429[ebp], -1
	jne	SHORT $LN63@ScoreInter
	mov	BYTE PTR $T238439[ebp], 0
	jmp	SHORT $LN61@ScoreInter
$LN63@ScoreInter:
	mov	eax, DWORD PTR _pPlot$221861[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR $T238429[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T238439[ebp], cl
$LN61@ScoreInter:
	movzx	edx, BYTE PTR $T238439[ebp]
	test	edx, edx
	jne	SHORT $LN69@ScoreInter

; 5099 : 			{
; 5100 : 				iDangerValue += 1;

	mov	eax, DWORD PTR _iDangerValue$221863[ebp]
	add	eax, 1
	mov	DWORD PTR _iDangerValue$221863[ebp], eax

; 5101 : 			}
; 5102 : 
; 5103 : 			if (pPlot->getTeam() != NO_TEAM && GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

$LN69@ScoreInter:
	mov	ecx, DWORD PTR _pPlot$221861[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$238448[ebp], edx
	cmp	DWORD PTR _playerID$238448[ebp], -1
	je	SHORT $LN66@ScoreInter
	mov	eax, DWORD PTR _playerID$238448[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238456[ebp], eax
	jmp	SHORT $LN67@ScoreInter
	jmp	SHORT $LN67@ScoreInter
$LN66@ScoreInter:
	mov	DWORD PTR $T238456[ebp], -1
$LN67@ScoreInter:
	cmp	DWORD PTR $T238456[ebp], -1
	je	$LN13@ScoreInter
	mov	ecx, DWORD PTR _pPlot$221861[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$238465[ebp], edx
	cmp	DWORD PTR _playerID$238465[ebp], -1
	je	SHORT $LN74@ScoreInter
	mov	eax, DWORD PTR _playerID$238465[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238473[ebp], eax
	jmp	SHORT $LN75@ScoreInter
	jmp	SHORT $LN75@ScoreInter
$LN74@ScoreInter:
	mov	DWORD PTR $T238473[ebp], -1
$LN75@ScoreInter:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238482[ebp], edx
	mov	eax, DWORD PTR $T238482[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238483[ebp], eax
	mov	edx, DWORD PTR $T238483[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T238487[ebp], edx
	mov	eax, DWORD PTR $T238473[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238487[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@ScoreInter

; 5104 : 			{
; 5105 : 				iDangerValue += 1000;

	mov	edx, DWORD PTR _iDangerValue$221863[ebp]
	add	edx, 1000				; 000003e8H
	mov	DWORD PTR _iDangerValue$221863[ebp], edx
$LN13@ScoreInter:

; 5106 : 			}
; 5107 : 		}
; 5108 : 		iDangerSum += iDangerValue;

	mov	eax, DWORD PTR _iDangerSum$[ebp]
	add	eax, DWORD PTR _iDangerValue$221863[ebp]
	mov	DWORD PTR _iDangerSum$[ebp], eax

; 5109 : 	}

	jmp	$LN16@ScoreInter
$LN15@ScoreInter:

; 5110 : 
; 5111 : 	// gold
; 5112 : 	int iGoldAmount = pPlayerTrade->GetTradeConnectionValueTimes100(kTradeConnection, YIELD_GOLD, true);

	push	1
	push	2
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayerTrade$[ebp]
	call	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
	mov	DWORD PTR _iGoldAmount$[ebp], eax

; 5113 : 	int iOtherGoldAmount = pOtherPlayerTrade->GetTradeConnectionValueTimes100(kTradeConnection, YIELD_GOLD, false);

	push	0
	push	2
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOtherPlayerTrade$[ebp]
	call	?GetTradeConnectionValueTimes100@CvPlayerTrade@@QAEHABUTradeConnection@@W4YieldTypes@@_N@Z ; CvPlayerTrade::GetTradeConnectionValueTimes100
	mov	DWORD PTR _iOtherGoldAmount$[ebp], eax

; 5114 : 	int iGoldDelta = iGoldAmount - iOtherGoldAmount;

	mov	eax, DWORD PTR _iGoldAmount$[ebp]
	sub	eax, DWORD PTR _iOtherGoldAmount$[ebp]
	mov	DWORD PTR _iGoldDelta$[ebp], eax

; 5115 : 
; 5116 : 	// getting out of a logjam at the beginning of the game on an archepeligo map
; 5117 : 	// if the player has made a trade unit but all the trade routes yields will be negative to the player
; 5118 : 	// still try to trade with some of the minor civs
; 5119 : 	if (iGoldDelta <= 0 && GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv())

	cmp	DWORD PTR _iGoldDelta$[ebp], 0
	jg	SHORT $LN10@ScoreInter
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238491[ebp], edx
	mov	ecx, DWORD PTR $T238491[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@ScoreInter

; 5120 : 	{
; 5121 : 		iGoldDelta = 1;

	mov	DWORD PTR _iGoldDelta$[ebp], 1
$LN10@ScoreInter:

; 5122 : 	}
; 5123 : 
; 5124 : 	// tech
; 5125 : 	int iTechDifferenceP1fromP2 = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eOriginOwner, kTradeConnection.m_eDestOwner);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238495[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR $T238495[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference
	mov	DWORD PTR _iTechDifferenceP1fromP2$[ebp], eax

; 5126 : 	int iTechDifferenceP2fromP1 = GC.getGame().GetGameTrade()->GetTechDifference(kTradeConnection.m_eDestOwner,   kTradeConnection.m_eOriginOwner);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238499[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR $T238499[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?GetTechDifference@CvGameTrade@@QAEHW4PlayerTypes@@0@Z ; CvGameTrade::GetTechDifference
	mov	DWORD PTR _iTechDifferenceP2fromP1$[ebp], eax

; 5127 : 	int iTechDelta = iTechDifferenceP1fromP2 - iTechDifferenceP2fromP1;

	mov	edx, DWORD PTR _iTechDifferenceP1fromP2$[ebp]
	sub	edx, DWORD PTR _iTechDifferenceP2fromP1$[ebp]
	mov	DWORD PTR _iTechDelta$[ebp], edx

; 5128 : 
; 5129 : 	// religion
; 5130 : 	ReligionTypes eOwnerFoundedReligion = GC.getGame().GetGameReligions()->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T238508[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238512[ebp], eax
	mov	ecx, DWORD PTR $T238508[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238512[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer
	mov	DWORD PTR _eOwnerFoundedReligion$[ebp], eax

; 5131 : 	int iReligionDelta = 0;

	mov	DWORD PTR _iReligionDelta$[ebp], 0

; 5132 : 	if (eOwnerFoundedReligion != NO_RELIGION)

	cmp	DWORD PTR _eOwnerFoundedReligion$[ebp], -1
	je	$LN9@ScoreInter

; 5133 : 	{
; 5134 : 		CvCity* pToCity = CvGameTrade::GetDestCity(kTradeConnection);

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	push	edx
	call	?GetDestCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetDestCity
	add	esp, 4
	mov	DWORD PTR _pToCity$221877[ebp], eax

; 5135 : 		CvCity* pFromCity = CvGameTrade::GetOriginCity(kTradeConnection);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	push	eax
	call	?GetOriginCity@CvGameTrade@@SAPAVCvCity@@ABUTradeConnection@@@Z ; CvGameTrade::GetOriginCity
	add	esp, 4
	mov	DWORD PTR _pFromCity$221878[ebp], eax

; 5136 : 		CvAssert(pToCity != NULL && pFromCity != NULL);
; 5137 : 		if (pToCity != NULL && pFromCity != NULL)

	cmp	DWORD PTR _pToCity$221877[ebp], 0
	je	$LN9@ScoreInter
	cmp	DWORD PTR _pFromCity$221878[ebp], 0
	je	$LN9@ScoreInter

; 5138 : 		{
; 5139 : 			ReligionTypes eToReligion = NO_RELIGION;

	mov	DWORD PTR _eToReligion$221880[ebp], -1

; 5140 : 			int iToPressure = 0;

	mov	DWORD PTR _iToPressure$221881[ebp], 0

; 5141 : 			ReligionTypes eFromReligion = NO_RELIGION;

	mov	DWORD PTR _eFromReligion$221882[ebp], -1

; 5142 : 			int iFromPressure = 0;

	mov	DWORD PTR _iFromPressure$221883[ebp], 0

; 5143 : 			bool bAnyFromCityPressure = pFromCity->GetCityReligions()->WouldExertTradeRoutePressureToward(pToCity, eToReligion, iToPressure);

	lea	ecx, DWORD PTR _iToPressure$221881[ebp]
	push	ecx
	lea	edx, DWORD PTR _eToReligion$221880[ebp]
	push	edx
	mov	eax, DWORD PTR _pToCity$221877[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromCity$221878[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?WouldExertTradeRoutePressureToward@CvCityReligions@@QAE_NPAVCvCity@@AAW4ReligionTypes@@AAH@Z ; CvCityReligions::WouldExertTradeRoutePressureToward
	mov	BYTE PTR _bAnyFromCityPressure$221884[ebp], al

; 5144 : 			bool bAnyToCityPressure = pToCity->GetCityReligions()->WouldExertTradeRoutePressureToward(pFromCity, eFromReligion, iFromPressure);

	lea	ecx, DWORD PTR _iFromPressure$221883[ebp]
	push	ecx
	lea	edx, DWORD PTR _eFromReligion$221882[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromCity$221878[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToCity$221877[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?WouldExertTradeRoutePressureToward@CvCityReligions@@QAE_NPAVCvCity@@AAW4ReligionTypes@@AAH@Z ; CvCityReligions::WouldExertTradeRoutePressureToward
	mov	BYTE PTR _bAnyToCityPressure$221885[ebp], al

; 5145 : 
; 5146 : 			// Internally pressure is now 10 times greater than what is shown to user
; 5147 : 			iToPressure /= GC.getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7900
	mov	DWORD PTR $T238516[ebp], ecx
	mov	eax, DWORD PTR _iToPressure$221881[ebp]
	cdq
	idiv	DWORD PTR $T238516[ebp]
	mov	DWORD PTR _iToPressure$221881[ebp], eax

; 5148 : 			iFromPressure /= GC.getRELIGION_MISSIONARY_PRESSURE_MULTIPLIER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7900
	mov	DWORD PTR $T238520[ebp], edx
	mov	eax, DWORD PTR _iFromPressure$221883[ebp]
	cdq
	idiv	DWORD PTR $T238520[ebp]
	mov	DWORD PTR _iFromPressure$221883[ebp], eax

; 5149 : 
; 5150 : 			// if anyone is exerting pressure
; 5151 : 			if (bAnyFromCityPressure || bAnyToCityPressure)

	movzx	eax, BYTE PTR _bAnyFromCityPressure$221884[ebp]
	test	eax, eax
	jne	SHORT $LN6@ScoreInter
	movzx	ecx, BYTE PTR _bAnyToCityPressure$221885[ebp]
	test	ecx, ecx
	je	SHORT $LN9@ScoreInter
$LN6@ScoreInter:

; 5152 : 			{
; 5153 : 				// "to" and "from" religions need to be different for us to care
; 5154 : 				if (eToReligion != eFromReligion)

	mov	edx, DWORD PTR _eToReligion$221880[ebp]
	cmp	edx, DWORD PTR _eFromReligion$221882[ebp]
	je	SHORT $LN9@ScoreInter

; 5155 : 				{
; 5156 : 					if (eToReligion == eOwnerFoundedReligion)

	mov	eax, DWORD PTR _eToReligion$221880[ebp]
	cmp	eax, DWORD PTR _eOwnerFoundedReligion$[ebp]
	jne	SHORT $LN4@ScoreInter

; 5157 : 					{
; 5158 : 						iReligionDelta += iToPressure;

	mov	ecx, DWORD PTR _iReligionDelta$[ebp]
	add	ecx, DWORD PTR _iToPressure$221881[ebp]
	mov	DWORD PTR _iReligionDelta$[ebp], ecx
$LN4@ScoreInter:

; 5159 : 					}
; 5160 : 
; 5161 : 					if (eFromReligion != eOwnerFoundedReligion)

	mov	edx, DWORD PTR _eFromReligion$221882[ebp]
	cmp	edx, DWORD PTR _eOwnerFoundedReligion$[ebp]
	je	SHORT $LN9@ScoreInter

; 5162 : 					{
; 5163 : 						iReligionDelta -= iFromPressure;

	mov	eax, DWORD PTR _iReligionDelta$[ebp]
	sub	eax, DWORD PTR _iFromPressure$221883[ebp]
	mov	DWORD PTR _iReligionDelta$[ebp], eax
$LN9@ScoreInter:

; 5164 : 					}
; 5165 : 				}
; 5166 : 			}
; 5167 : 		}
; 5168 : 	}
; 5169 : 
; 5170 : 	int iScore = 0;

	mov	DWORD PTR _iScore$[ebp], 0

; 5171 : 	iScore += iGoldDelta;

	mov	ecx, DWORD PTR _iScore$[ebp]
	add	ecx, DWORD PTR _iGoldDelta$[ebp]
	mov	DWORD PTR _iScore$[ebp], ecx

; 5172 : 	iScore += iTechDelta * 3; // 3 science = 1 gold

	mov	edx, DWORD PTR _iTechDelta$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iScore$[ebp], edx

; 5173 : 	iScore += iReligionDelta * 2; // 2 religion = 1 gold

	mov	eax, DWORD PTR _iReligionDelta$[ebp]
	mov	ecx, DWORD PTR _iScore$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _iScore$[ebp], edx

; 5174 : 	iScore = (iScore * 10) / iDangerSum;

	mov	eax, DWORD PTR _iScore$[ebp]
	imul	eax, 10					; 0000000aH
	cdq
	idiv	DWORD PTR _iDangerSum$[ebp]
	mov	DWORD PTR _iScore$[ebp], eax

; 5175 : 	
; 5176 : 	// if we have any tourism and the destination owner is not a minor civ
; 5177 : 	if (m_pPlayer->GetCulture()->GetTourism() > 0 && !GET_PLAYER(kTradeConnection.m_eDestOwner).isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	test	eax, eax
	jle	SHORT $LN2@ScoreInter
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238524[ebp], edx
	mov	ecx, DWORD PTR $T238524[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@ScoreInter

; 5178 : 	{
; 5179 : 		// if we're not connected to a player, double the value to that player
; 5180 : 		if (!GC.getGame().GetGameTrade()->IsPlayerConnectedToPlayer(m_pPlayer->GetID(), kTradeConnection.m_eDestOwner))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T238533[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T238537[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR $T238533[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238537[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	ecx, eax
	call	?IsPlayerConnectedToPlayer@CvGameTrade@@QAE_NW4PlayerTypes@@0@Z ; CvGameTrade::IsPlayerConnectedToPlayer
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@ScoreInter

; 5181 : 		{
; 5182 : 			iScore *= 2;

	mov	eax, DWORD PTR _iScore$[ebp]
	shl	eax, 1
	mov	DWORD PTR _iScore$[ebp], eax
$LN2@ScoreInter:

; 5183 : 		}
; 5184 : 	}
; 5185 : 
; 5186 : 	return iScore;

	mov	eax, DWORD PTR _iScore$[ebp]
$LN20@ScoreInter:

; 5187 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z ENDP ; CvTradeAI::ScoreInternationalTR
_TEXT	ENDS
PUBLIC	?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z ; CvTradeAI::ScoreFoodTR
; Function compile flags: /Odtp
;	COMDAT ?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z
_TEXT	SEGMENT
tv224 = -140						; size = 4
_this$ = -136						; size = 4
$T238721 = -132						; size = 4
$T238717 = -128						; size = 4
$T238716 = -124						; size = 4
$T238707 = -120						; size = 4
_playerID$238704 = -116					; size = 4
$T238690 = -112						; size = 4
_playerID$238687 = -108					; size = 4
$T238673 = -101						; size = 1
$T238663 = -100						; size = 4
$T238662 = -96						; size = 4
$T238653 = -92						; size = 4
$T238652 = -88						; size = 4
$T238615 = -84						; size = 4
$T238603 = -80						; size = 4
$T238599 = -73						; size = 1
$T238588 = -72						; size = 4
$T238584 = -65						; size = 1
_iMapY$238642 = -64					; size = 4
_iMapX$238641 = -60					; size = 4
$T238577 = -56						; size = 4
$T238573 = -52						; size = 4
$T238569 = -48						; size = 4
$T238565 = -44						; size = 4
$T238561 = -40						; size = 4
$T238557 = -36						; size = 4
$T238548 = -32						; size = 4
_iDangerValue$221913 = -28				; size = 4
_pPlot$221911 = -24					; size = 4
_uiPlotList$221907 = -20				; size = 4
_iDistance$ = -16					; size = 4
_iDistanceScore$ = -12					; size = 4
_iDangerSum$ = -8					; size = 4
_iMaxDistance$ = -4					; size = 4
_kTradeConnection$ = 8					; size = 4
_pSmallestCity$ = 12					; size = 4
?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z PROC ; CvTradeAI::ScoreFoodTR, COMDAT
; _this$ = ecx

; 5195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	DWORD PTR _this$[ebp], ecx

; 5196 : 	if (kTradeConnection.m_eConnectionType != TRADE_CONNECTION_FOOD)

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [eax+32], 1
	je	SHORT $LN11@ScoreFoodT

; 5197 : 	{
; 5198 : 		return 0;

	xor	eax, eax
	jmp	$LN12@ScoreFoodT
$LN11@ScoreFoodT:

; 5199 : 	}
; 5200 : 
; 5201 : 	// if this was recently plundered, 0 the score
; 5202 : 	if (m_pPlayer->GetTrade()->CheckTradeConnectionWasPlundered(kTradeConnection))

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@ScoreFoodT

; 5203 : 	{
; 5204 : 		return 0;

	xor	eax, eax
	jmp	$LN12@ScoreFoodT

; 5205 : 	}
; 5206 : 
; 5207 : 	// if we're not going to the smallest city, ignore
; 5208 : 	if (kTradeConnection.m_iDestX != pSmallestCity->getX() && kTradeConnection.m_iDestY != pSmallestCity->getY())

$LN16@ScoreFoodT:
	mov	ecx, DWORD PTR _pSmallestCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T238548[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR $T238548[ebp]
	je	SHORT $LN9@ScoreFoodT
	mov	edx, DWORD PTR _pSmallestCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T238557[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR $T238557[ebp]
	je	SHORT $LN9@ScoreFoodT

; 5209 : 	{
; 5210 : 		return 0;

	xor	eax, eax
	jmp	$LN12@ScoreFoodT
$LN9@ScoreFoodT:

; 5211 : 	}
; 5212 : 
; 5213 : 	int iMaxDistance = 60;

	mov	DWORD PTR _iMaxDistance$[ebp], 60	; 0000003cH

; 5214 : 	int iDistance = kTradeConnection.m_aPlotList.size();

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T238561[ebp], ecx
	mov	edx, DWORD PTR $T238561[ebp]
	mov	DWORD PTR _iDistance$[ebp], edx

; 5215 : 	int iDistanceScore = iMaxDistance - iDistance;

	mov	eax, DWORD PTR _iMaxDistance$[ebp]
	sub	eax, DWORD PTR _iDistance$[ebp]
	mov	DWORD PTR _iDistanceScore$[ebp], eax

; 5216 : 	if (kTradeConnection.m_eDomain == DOMAIN_SEA)

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN8@ScoreFoodT

; 5217 : 	{
; 5218 : 		iDistanceScore = iDistanceScore * 2;

	mov	edx, DWORD PTR _iDistanceScore$[ebp]
	shl	edx, 1
	mov	DWORD PTR _iDistanceScore$[ebp], edx
$LN8@ScoreFoodT:

; 5219 : 	}
; 5220 : 
; 5221 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5222 : 	int iDangerSum = 1; // can't be zero because we divide by zero!

	mov	DWORD PTR _iDangerSum$[ebp], 1

; 5223 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	DWORD PTR _uiPlotList$221907[ebp], 0
	jmp	SHORT $LN7@ScoreFoodT
$LN6@ScoreFoodT:
	mov	eax, DWORD PTR _uiPlotList$221907[ebp]
	add	eax, 1
	mov	DWORD PTR _uiPlotList$221907[ebp], eax
$LN7@ScoreFoodT:
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T238565[ebp], edx
	mov	eax, DWORD PTR _uiPlotList$221907[ebp]
	cmp	eax, DWORD PTR $T238565[ebp]
	jae	$LN5@ScoreFoodT

; 5224 : 	{
; 5225 : 		CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[uiPlotList].m_iX, kTradeConnection.m_aPlotList[uiPlotList].m_iY);

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _uiPlotList$221907[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T238569[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _uiPlotList$221907[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T238573[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238577[ebp], eax
	mov	ecx, DWORD PTR $T238569[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238653[ebp], edx
	mov	eax, DWORD PTR $T238573[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T238652[ebp], ecx
	cmp	DWORD PTR $T238652[ebp], -2147483647	; 80000001H
	je	SHORT $LN32@ScoreFoodT
	cmp	DWORD PTR $T238653[ebp], -2147483647	; 80000001H
	jne	SHORT $LN33@ScoreFoodT
$LN32@ScoreFoodT:
	mov	DWORD PTR _pPlot$221911[ebp], 0
	jmp	$LN34@ScoreFoodT
$LN33@ScoreFoodT:
	mov	edx, DWORD PTR $T238577[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T238584[ebp], al
	mov	ecx, DWORD PTR $T238577[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T238588[ebp], edx
	movzx	eax, BYTE PTR $T238584[ebp]
	test	eax, eax
	je	SHORT $LN45@ScoreFoodT
	cmp	DWORD PTR $T238652[ebp], 0
	jge	SHORT $LN44@ScoreFoodT
	mov	eax, DWORD PTR $T238652[ebp]
	cdq
	idiv	DWORD PTR $T238588[ebp]
	add	edx, DWORD PTR $T238588[ebp]
	mov	DWORD PTR _iMapX$238641[ebp], edx
	jmp	SHORT $LN46@ScoreFoodT
	jmp	SHORT $LN45@ScoreFoodT
$LN44@ScoreFoodT:
	mov	ecx, DWORD PTR $T238652[ebp]
	cmp	ecx, DWORD PTR $T238588[ebp]
	jl	SHORT $LN45@ScoreFoodT
	mov	eax, DWORD PTR $T238652[ebp]
	cdq
	idiv	DWORD PTR $T238588[ebp]
	mov	DWORD PTR _iMapX$238641[ebp], edx
	jmp	SHORT $LN46@ScoreFoodT
$LN45@ScoreFoodT:
	mov	edx, DWORD PTR $T238652[ebp]
	mov	DWORD PTR _iMapX$238641[ebp], edx
$LN46@ScoreFoodT:
	mov	eax, DWORD PTR $T238577[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T238599[ebp], cl
	mov	edx, DWORD PTR $T238577[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T238603[ebp], eax
	movzx	ecx, BYTE PTR $T238599[ebp]
	test	ecx, ecx
	je	SHORT $LN55@ScoreFoodT
	cmp	DWORD PTR $T238653[ebp], 0
	jge	SHORT $LN54@ScoreFoodT
	mov	eax, DWORD PTR $T238653[ebp]
	cdq
	idiv	DWORD PTR $T238603[ebp]
	add	edx, DWORD PTR $T238603[ebp]
	mov	DWORD PTR _iMapY$238642[ebp], edx
	jmp	SHORT $LN56@ScoreFoodT
	jmp	SHORT $LN55@ScoreFoodT
$LN54@ScoreFoodT:
	mov	edx, DWORD PTR $T238653[ebp]
	cmp	edx, DWORD PTR $T238603[ebp]
	jl	SHORT $LN55@ScoreFoodT
	mov	eax, DWORD PTR $T238653[ebp]
	cdq
	idiv	DWORD PTR $T238603[ebp]
	mov	DWORD PTR _iMapY$238642[ebp], edx
	jmp	SHORT $LN56@ScoreFoodT
$LN55@ScoreFoodT:
	mov	eax, DWORD PTR $T238653[ebp]
	mov	DWORD PTR _iMapY$238642[ebp], eax
$LN56@ScoreFoodT:
	mov	ecx, DWORD PTR _iMapY$238642[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$238641[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238577[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN36@ScoreFoodT
	mov	eax, DWORD PTR $T238577[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238615[ebp], ecx
	mov	edx, DWORD PTR _iMapY$238642[ebp]
	imul	edx, DWORD PTR $T238615[ebp]
	add	edx, DWORD PTR _iMapX$238641[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T238577[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv224[ebp], edx
	jmp	SHORT $LN37@ScoreFoodT
$LN36@ScoreFoodT:
	mov	DWORD PTR tv224[ebp], 0
$LN37@ScoreFoodT:
	mov	ecx, DWORD PTR tv224[ebp]
	mov	DWORD PTR _pPlot$221911[ebp], ecx
$LN34@ScoreFoodT:

; 5226 : 		CvAssertMsg(pPlot, "pPlot is null when trying to evaluate the list");
; 5227 : 		if (pPlot == NULL)

	cmp	DWORD PTR _pPlot$221911[ebp], 0
	jne	SHORT $LN4@ScoreFoodT

; 5228 : 		{
; 5229 : 			break;

	jmp	$LN5@ScoreFoodT
$LN4@ScoreFoodT:

; 5230 : 		}
; 5231 : 		int iDangerValue = m_pPlayer->GetPlotDanger(*pPlot);

	mov	edx, DWORD PTR _pPlot$221911[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	DWORD PTR _iDangerValue$221913[ebp], eax

; 5232 : 		if (iDangerValue == 0)

	cmp	DWORD PTR _iDangerValue$221913[ebp], 0
	jne	$LN3@ScoreFoodT

; 5233 : 		{
; 5234 : 			if (!pPlot->isVisible(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238662[ebp], edx
	mov	eax, DWORD PTR $T238662[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238663[ebp], eax
	cmp	DWORD PTR $T238663[ebp], -1
	jne	SHORT $LN69@ScoreFoodT
	mov	BYTE PTR $T238673[ebp], 0
	jmp	SHORT $LN67@ScoreFoodT
$LN69@ScoreFoodT:
	mov	edx, DWORD PTR _pPlot$221911[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR $T238663[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T238673[ebp], al
$LN67@ScoreFoodT:
	movzx	ecx, BYTE PTR $T238673[ebp]
	test	ecx, ecx
	jne	SHORT $LN75@ScoreFoodT

; 5235 : 			{
; 5236 : 				iDangerValue += 1;

	mov	edx, DWORD PTR _iDangerValue$221913[ebp]
	add	edx, 1
	mov	DWORD PTR _iDangerValue$221913[ebp], edx

; 5237 : 			}
; 5238 : 
; 5239 : 			if (pPlot->getTeam() != NO_TEAM && GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

$LN75@ScoreFoodT:
	mov	eax, DWORD PTR _pPlot$221911[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$238687[ebp], ecx
	cmp	DWORD PTR _playerID$238687[ebp], -1
	je	SHORT $LN72@ScoreFoodT
	mov	edx, DWORD PTR _playerID$238687[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238690[ebp], eax
	jmp	SHORT $LN73@ScoreFoodT
	jmp	SHORT $LN73@ScoreFoodT
$LN72@ScoreFoodT:
	mov	DWORD PTR $T238690[ebp], -1
$LN73@ScoreFoodT:
	cmp	DWORD PTR $T238690[ebp], -1
	je	SHORT $LN3@ScoreFoodT
	mov	eax, DWORD PTR _pPlot$221911[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$238704[ebp], ecx
	cmp	DWORD PTR _playerID$238704[ebp], -1
	je	SHORT $LN80@ScoreFoodT
	mov	edx, DWORD PTR _playerID$238704[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238707[ebp], eax
	jmp	SHORT $LN81@ScoreFoodT
	jmp	SHORT $LN81@ScoreFoodT
$LN80@ScoreFoodT:
	mov	DWORD PTR $T238707[ebp], -1
$LN81@ScoreFoodT:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238716[ebp], ecx
	mov	edx, DWORD PTR $T238716[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238717[ebp], eax
	mov	ecx, DWORD PTR $T238717[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T238721[ebp], ecx
	mov	edx, DWORD PTR $T238707[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238721[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ScoreFoodT

; 5240 : 			{
; 5241 : 				iDangerValue += 1000;

	mov	ecx, DWORD PTR _iDangerValue$221913[ebp]
	add	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iDangerValue$221913[ebp], ecx
$LN3@ScoreFoodT:

; 5242 : 			}
; 5243 : 		}
; 5244 : 		iDangerSum += iDangerValue;

	mov	edx, DWORD PTR _iDangerSum$[ebp]
	add	edx, DWORD PTR _iDangerValue$221913[ebp]
	mov	DWORD PTR _iDangerSum$[ebp], edx

; 5245 : 	}

	jmp	$LN6@ScoreFoodT
$LN5@ScoreFoodT:

; 5246 : 
; 5247 : 	return iDistanceScore - iDangerSum;

	mov	eax, DWORD PTR _iDistanceScore$[ebp]
	sub	eax, DWORD PTR _iDangerSum$[ebp]
$LN12@ScoreFoodT:

; 5248 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z ENDP ; CvTradeAI::ScoreFoodTR
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
PUBLIC	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
PUBLIC	?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvTradeAI::ScoreProductionTR
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
_TEXT	SEGMENT
tv277 = -224						; size = 4
tv321 = -220						; size = 4
_this$ = -216						; size = 4
$T238986 = -184						; size = 4
$T238982 = -180						; size = 4
$T238981 = -176						; size = 4
$T238972 = -172						; size = 4
_playerID$238969 = -168					; size = 4
$T238955 = -164						; size = 4
_playerID$238952 = -160					; size = 4
$T238938 = -153						; size = 1
$T238928 = -152						; size = 4
$T238927 = -148						; size = 4
$T238918 = -144						; size = 4
$T238917 = -140						; size = 4
$T238878 = -136						; size = 4
$T238865 = -132						; size = 4
$T238861 = -128						; size = 4
$T238854 = -124						; size = 4
$T238850 = -117						; size = 1
$T238839 = -116						; size = 4
$T238835 = -109						; size = 1
_iMapY$238916 = -108					; size = 4
_iMapX$238915 = -104					; size = 4
$T238828 = -100						; size = 4
$T238824 = -96						; size = 4
$T238820 = -92						; size = 4
$T238816 = -88						; size = 4
$T238812 = -84						; size = 4
$T238791 = -80						; size = 4
$T238782 = -76						; size = 4
$T238778 = -72						; size = 4
$T238769 = -68						; size = 4
$T238727 = -64						; size = 4
$T238726 = -60						; size = 4
$T238725 = -56						; size = 4
$T238724 = -52						; size = 4
_iDangerValue$221949 = -48				; size = 4
_pPlot$221947 = -44					; size = 4
_uiPlotList$221943 = -40				; size = 4
_ui$221931 = -36					; size = 4
_iDistance$ = -32					; size = 4
_iDistanceScore$ = -28					; size = 4
_iDangerSum$ = -24					; size = 4
_iMaxDistance$ = -20					; size = 4
_bValidTarget$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_kTradeConnection$ = 8					; size = 4
_aTargetCityList$ = 12					; size = 16
?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z PROC ; CvTradeAI::ScoreProductionTR, COMDAT
; _this$ = ecx

; 5256 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5257 : 	// only consider production trades
; 5258 : 	if (kTradeConnection.m_eConnectionType != TRADE_CONNECTION_PRODUCTION)

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [eax+32], 2
	je	SHORT $LN15@ScoreProdu

; 5259 : 	{
; 5260 : 		return 0;

	mov	DWORD PTR $T238724[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T238724[ebp]
	jmp	$LN16@ScoreProdu
$LN15@ScoreProdu:

; 5261 : 	}
; 5262 : 
; 5263 : 	// if this was recently plundered, 0 the score
; 5264 : 	if (m_pPlayer->GetTrade()->CheckTradeConnectionWasPlundered(kTradeConnection))

	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?CheckTradeConnectionWasPlundered@CvPlayerTrade@@QAE_NABUTradeConnection@@@Z ; CvPlayerTrade::CheckTradeConnectionWasPlundered
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@ScoreProdu

; 5265 : 	{
; 5266 : 		return 0;

	mov	DWORD PTR $T238725[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T238725[ebp]
	jmp	$LN16@ScoreProdu
$LN14@ScoreProdu:

; 5267 : 	}
; 5268 : 
; 5269 : 	// if we're not going to a target production city, ignore
; 5270 : 	bool bValidTarget = false;

	mov	BYTE PTR _bValidTarget$[ebp], 0

; 5271 : #ifdef AUI_ITERATORIZE
; 5272 : 	for (std::vector<const CvCity*>::iterator it = aTargetCityList.begin(); it != aTargetCityList.end(); ++it)
; 5273 : 	{
; 5274 : 		if (kTradeConnection.m_iDestX == (*it)->getX() && kTradeConnection.m_iDestY == (*it)->getY())
; 5275 : #else
; 5276 : 	for (uint ui = 0; ui < aTargetCityList.size(); ui++)

	mov	DWORD PTR _ui$221931[ebp], 0
	jmp	SHORT $LN35@ScoreProdu
$LN12@ScoreProdu:
	mov	ecx, DWORD PTR _ui$221931[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$221931[ebp], ecx
$LN35@ScoreProdu:
	mov	edx, DWORD PTR _aTargetCityList$[ebp+8]
	sub	edx, DWORD PTR _aTargetCityList$[ebp+4]
	sar	edx, 2
	cmp	DWORD PTR _ui$221931[ebp], edx
	jae	SHORT $LN11@ScoreProdu

; 5277 : 	{
; 5278 : 		if (kTradeConnection.m_iDestX == aTargetCityList[ui]->getX() && kTradeConnection.m_iDestY == aTargetCityList[ui]->getY())

	mov	eax, DWORD PTR _aTargetCityList$[ebp+4]
	mov	ecx, DWORD PTR _ui$221931[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T238769[ebp], edx
	mov	eax, DWORD PTR $T238769[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T238778[ebp], edx
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR $T238778[ebp]
	jne	SHORT $LN10@ScoreProdu
	mov	edx, DWORD PTR _aTargetCityList$[ebp+4]
	mov	eax, DWORD PTR _ui$221931[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T238782[ebp], ecx
	mov	edx, DWORD PTR $T238782[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T238791[ebp], ecx
	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR $T238791[ebp]
	jne	SHORT $LN10@ScoreProdu

; 5279 : #endif
; 5280 : 		{
; 5281 : 			bValidTarget = true;

	mov	BYTE PTR _bValidTarget$[ebp], 1

; 5282 : 			break;

	jmp	SHORT $LN11@ScoreProdu
$LN10@ScoreProdu:

; 5283 : 		}
; 5284 : 	}

	jmp	SHORT $LN12@ScoreProdu
$LN11@ScoreProdu:

; 5285 : 
; 5286 : 	if (!bValidTarget)

	movzx	ecx, BYTE PTR _bValidTarget$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@ScoreProdu

; 5287 : 	{
; 5288 : 		return 0;

	mov	DWORD PTR $T238726[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T238726[ebp]
	jmp	$LN16@ScoreProdu
$LN9@ScoreProdu:

; 5289 : 	}
; 5290 : 
; 5291 : 	int iMaxDistance = 60;

	mov	DWORD PTR _iMaxDistance$[ebp], 60	; 0000003cH

; 5292 : 	int iDistance = kTradeConnection.m_aPlotList.size();

	mov	edx, DWORD PTR _kTradeConnection$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T238812[ebp], eax
	mov	ecx, DWORD PTR $T238812[ebp]
	mov	DWORD PTR _iDistance$[ebp], ecx

; 5293 : 	int iDistanceScore = iMaxDistance - iDistance;

	mov	edx, DWORD PTR _iMaxDistance$[ebp]
	sub	edx, DWORD PTR _iDistance$[ebp]
	mov	DWORD PTR _iDistanceScore$[ebp], edx

; 5294 : 	if (kTradeConnection.m_eDomain == DOMAIN_SEA)

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN8@ScoreProdu

; 5295 : 	{
; 5296 : 		iDistanceScore = iDistanceScore * 2;

	mov	ecx, DWORD PTR _iDistanceScore$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _iDistanceScore$[ebp], ecx
$LN8@ScoreProdu:

; 5297 : 	}
; 5298 : 
; 5299 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5300 : 	int iDangerSum = 1; // can't be zero because we divide by zero!

	mov	DWORD PTR _iDangerSum$[ebp], 1

; 5301 : 	for (uint uiPlotList = 0; uiPlotList < kTradeConnection.m_aPlotList.size(); uiPlotList++)

	mov	DWORD PTR _uiPlotList$221943[ebp], 0
	jmp	SHORT $LN7@ScoreProdu
$LN6@ScoreProdu:
	mov	edx, DWORD PTR _uiPlotList$221943[ebp]
	add	edx, 1
	mov	DWORD PTR _uiPlotList$221943[ebp], edx
$LN7@ScoreProdu:
	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T238816[ebp], ecx
	mov	edx, DWORD PTR _uiPlotList$221943[ebp]
	cmp	edx, DWORD PTR $T238816[ebp]
	jae	$LN5@ScoreProdu

; 5302 : 	{
; 5303 : 		CvPlot* pPlot = GC.getMap().plot(kTradeConnection.m_aPlotList[uiPlotList].m_iX, kTradeConnection.m_aPlotList[uiPlotList].m_iY);

	mov	eax, DWORD PTR _kTradeConnection$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _uiPlotList$221943[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T238820[ebp], eax
	mov	ecx, DWORD PTR _kTradeConnection$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _uiPlotList$221943[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T238824[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T238828[ebp], edx
	mov	eax, DWORD PTR $T238820[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238918[ebp], ecx
	mov	edx, DWORD PTR $T238824[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238917[ebp], eax
	cmp	DWORD PTR $T238917[ebp], -2147483647	; 80000001H
	je	SHORT $LN67@ScoreProdu
	cmp	DWORD PTR $T238918[ebp], -2147483647	; 80000001H
	jne	SHORT $LN68@ScoreProdu
$LN67@ScoreProdu:
	mov	DWORD PTR _pPlot$221947[ebp], 0
	jmp	$LN69@ScoreProdu
$LN68@ScoreProdu:
	mov	ecx, DWORD PTR $T238828[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T238835[ebp], dl
	mov	eax, DWORD PTR $T238828[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238839[ebp], ecx
	movzx	edx, BYTE PTR $T238835[ebp]
	test	edx, edx
	je	SHORT $LN80@ScoreProdu
	cmp	DWORD PTR $T238917[ebp], 0
	jge	SHORT $LN79@ScoreProdu
	mov	eax, DWORD PTR $T238917[ebp]
	cdq
	idiv	DWORD PTR $T238839[ebp]
	add	edx, DWORD PTR $T238839[ebp]
	mov	DWORD PTR _iMapX$238915[ebp], edx
	jmp	SHORT $LN81@ScoreProdu
	jmp	SHORT $LN80@ScoreProdu
$LN79@ScoreProdu:
	mov	eax, DWORD PTR $T238917[ebp]
	cmp	eax, DWORD PTR $T238839[ebp]
	jl	SHORT $LN80@ScoreProdu
	mov	eax, DWORD PTR $T238917[ebp]
	cdq
	idiv	DWORD PTR $T238839[ebp]
	mov	DWORD PTR _iMapX$238915[ebp], edx
	jmp	SHORT $LN81@ScoreProdu
$LN80@ScoreProdu:
	mov	ecx, DWORD PTR $T238917[ebp]
	mov	DWORD PTR _iMapX$238915[ebp], ecx
$LN81@ScoreProdu:
	mov	edx, DWORD PTR $T238828[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T238850[ebp], al
	mov	ecx, DWORD PTR $T238828[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T238854[ebp], edx
	movzx	eax, BYTE PTR $T238850[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238854[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238918[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$238916[ebp], eax
	cmp	DWORD PTR _iMapX$238915[ebp], 0
	jl	SHORT $LN89@ScoreProdu
	mov	eax, DWORD PTR $T238828[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238861[ebp], ecx
	mov	edx, DWORD PTR _iMapX$238915[ebp]
	cmp	edx, DWORD PTR $T238861[ebp]
	jge	SHORT $LN89@ScoreProdu
	cmp	DWORD PTR _iMapY$238916[ebp], 0
	jl	SHORT $LN89@ScoreProdu
	mov	eax, DWORD PTR $T238828[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T238865[ebp], ecx
	mov	edx, DWORD PTR _iMapY$238916[ebp]
	cmp	edx, DWORD PTR $T238865[ebp]
	jge	SHORT $LN89@ScoreProdu
	mov	DWORD PTR tv321[ebp], 1
	jmp	SHORT $LN87@ScoreProdu
$LN89@ScoreProdu:
	mov	DWORD PTR tv321[ebp], 0
$LN87@ScoreProdu:
	cmp	DWORD PTR tv321[ebp], 0
	je	SHORT $LN71@ScoreProdu
	mov	eax, DWORD PTR $T238828[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238878[ebp], ecx
	mov	edx, DWORD PTR _iMapY$238916[ebp]
	imul	edx, DWORD PTR $T238878[ebp]
	add	edx, DWORD PTR _iMapX$238915[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T238828[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv277[ebp], edx
	jmp	SHORT $LN72@ScoreProdu
$LN71@ScoreProdu:
	mov	DWORD PTR tv277[ebp], 0
$LN72@ScoreProdu:
	mov	ecx, DWORD PTR tv277[ebp]
	mov	DWORD PTR _pPlot$221947[ebp], ecx
$LN69@ScoreProdu:

; 5304 : 		CvAssertMsg(pPlot, "pPlot is null when trying to evaluate the list");
; 5305 : 		if (pPlot == NULL)

	cmp	DWORD PTR _pPlot$221947[ebp], 0
	jne	SHORT $LN4@ScoreProdu

; 5306 : 		{
; 5307 : 			break;

	jmp	$LN5@ScoreProdu
$LN4@ScoreProdu:

; 5308 : 		}
; 5309 : 		int iDangerValue = m_pPlayer->GetPlotDanger(*pPlot);

	mov	edx, DWORD PTR _pPlot$221947[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	mov	DWORD PTR _iDangerValue$221949[ebp], eax

; 5310 : 		if (iDangerValue == 0)

	cmp	DWORD PTR _iDangerValue$221949[ebp], 0
	jne	$LN3@ScoreProdu

; 5311 : 		{
; 5312 : 			if (!pPlot->isVisible(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238927[ebp], edx
	mov	eax, DWORD PTR $T238927[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238928[ebp], eax
	cmp	DWORD PTR $T238928[ebp], -1
	jne	SHORT $LN106@ScoreProdu
	mov	BYTE PTR $T238938[ebp], 0
	jmp	SHORT $LN104@ScoreProdu
$LN106@ScoreProdu:
	mov	edx, DWORD PTR _pPlot$221947[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR $T238928[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T238938[ebp], al
$LN104@ScoreProdu:
	movzx	ecx, BYTE PTR $T238938[ebp]
	test	ecx, ecx
	jne	SHORT $LN112@ScoreProdu

; 5313 : 			{
; 5314 : 				iDangerValue += 1;

	mov	edx, DWORD PTR _iDangerValue$221949[ebp]
	add	edx, 1
	mov	DWORD PTR _iDangerValue$221949[ebp], edx

; 5315 : 			}
; 5316 : 
; 5317 : 			if (pPlot->getTeam() != NO_TEAM && GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

$LN112@ScoreProdu:
	mov	eax, DWORD PTR _pPlot$221947[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$238952[ebp], ecx
	cmp	DWORD PTR _playerID$238952[ebp], -1
	je	SHORT $LN109@ScoreProdu
	mov	edx, DWORD PTR _playerID$238952[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238955[ebp], eax
	jmp	SHORT $LN110@ScoreProdu
	jmp	SHORT $LN110@ScoreProdu
$LN109@ScoreProdu:
	mov	DWORD PTR $T238955[ebp], -1
$LN110@ScoreProdu:
	cmp	DWORD PTR $T238955[ebp], -1
	je	$LN3@ScoreProdu
	mov	eax, DWORD PTR _pPlot$221947[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$238969[ebp], ecx
	cmp	DWORD PTR _playerID$238969[ebp], -1
	je	SHORT $LN117@ScoreProdu
	mov	edx, DWORD PTR _playerID$238969[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238972[ebp], eax
	jmp	SHORT $LN118@ScoreProdu
	jmp	SHORT $LN118@ScoreProdu
$LN117@ScoreProdu:
	mov	DWORD PTR $T238972[ebp], -1
$LN118@ScoreProdu:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238981[ebp], ecx
	mov	edx, DWORD PTR $T238981[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238982[ebp], eax
	mov	ecx, DWORD PTR $T238982[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T238986[ebp], ecx
	mov	edx, DWORD PTR $T238972[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238986[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ScoreProdu

; 5318 : 			{
; 5319 : 				iDangerValue += 1000;

	mov	ecx, DWORD PTR _iDangerValue$221949[ebp]
	add	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iDangerValue$221949[ebp], ecx
$LN3@ScoreProdu:

; 5320 : 			}
; 5321 : 		}
; 5322 : 		iDangerSum += iDangerValue;

	mov	edx, DWORD PTR _iDangerSum$[ebp]
	add	edx, DWORD PTR _iDangerValue$221949[ebp]
	mov	DWORD PTR _iDangerSum$[ebp], edx

; 5323 : 	}

	jmp	$LN6@ScoreProdu
$LN5@ScoreProdu:

; 5324 : 
; 5325 : 	return iDistanceScore - iDangerSum;

	mov	eax, DWORD PTR _iDistanceScore$[ebp]
	sub	eax, DWORD PTR _iDangerSum$[ebp]
	mov	DWORD PTR $T238727[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T238727[ebp]
$LN16@ScoreProdu:

; 5326 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$1:
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$3:
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$5:
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__unwindfunclet$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z$7:
	lea	ecx, DWORD PTR _aTargetCityList$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ENDP ; CvTradeAI::ScoreProductionTR
PUBLIC	??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::~_Vector_val<TRSortElement,std::allocator<TRSortElement> >
PUBLIC	??1TRSortElement@@QAE@XZ			; TRSortElement::~TRSortElement
PUBLIC	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
PUBLIC	?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
PUBLIC	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
PUBLIC	?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase
PUBLIC	??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >
PUBLIC	__$ArrayPad$
PUBLIC	?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::PrioritizeTradeRoutes
EXTRN	?GetSpaceshipProject@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetSpaceshipProject
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
EXTRN	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ:PROC ; CvCity::getProductionUnit
EXTRN	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ:PROC ; CvCitySpecializationAI::GetWonderBuildCity
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?GetHappiness@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetHappiness
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$7
	DD	02H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$25
	DD	01H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$27
	DD	00H
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$29
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$31
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtradeclasses.cpp
xdata$x	ENDS
;	COMDAT ?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
tv405 = -1916						; size = 4
tv404 = -1912						; size = 4
_this$ = -1908						; size = 4
$T239708 = -1865					; size = 1
$T239707 = -1864					; size = 4
$T239706 = -1860					; size = 4
$T239673 = -1856					; size = 4
$T239657 = -1852					; size = 4
$T239606 = -1828					; size = 4
$T239588 = -1816					; size = 4
$T239559 = -1812					; size = 4
$T239543 = -1808					; size = 4
$T239572 = -1804					; size = 4
$T239571 = -1800					; size = 4
$T239570 = -1796					; size = 4
$T239569 = -1792					; size = 4
$T239568 = -1788					; size = 4
$T239527 = -1781					; size = 1
$T239526 = -1780					; size = 4
$T239525 = -1776					; size = 4
$T239492 = -1772					; size = 4
$T239476 = -1768					; size = 4
$T239425 = -1744					; size = 4
$T239407 = -1732					; size = 4
$T239378 = -1728					; size = 4
$T239362 = -1724					; size = 4
$T239390 = -1720					; size = 4
$T239389 = -1716					; size = 4
$T239388 = -1712					; size = 4
$T239387 = -1708					; size = 4
$T239386 = -1704					; size = 4
$T239274 = -1649					; size = 1
$T239273 = -1648					; size = 4
$T239272 = -1644					; size = 4
$T239239 = -1640					; size = 4
$T239223 = -1636					; size = 4
$T239172 = -1612					; size = 4
$T239154 = -1600					; size = 4
$T239125 = -1596					; size = 4
$T239109 = -1592					; size = 4
$T239137 = -1588					; size = 4
$T239136 = -1584					; size = 4
$T239135 = -1580					; size = 4
$T239134 = -1576					; size = 4
$T239133 = -1572					; size = 4
$T239072 = -1544					; size = 4
$T239060 = -1540					; size = 4
$T239059 = -1536					; size = 4
$T239058 = -1529					; size = 1
$T239057 = -1528					; size = 4
$T239056 = -1524					; size = 4
$T239055 = -1517					; size = 1
$T239054 = -1516					; size = 4
$T239053 = -1512					; size = 4
$T239052 = -1508					; size = 4
$T239051 = -1501					; size = 1
_ui$222514 = -1500					; size = 4
_ui$222508 = -1496					; size = 4
_kElement$222502 = -1492				; size = 448
_ui$222498 = -1040					; size = 4
_kElement$222492 = -1036				; size = 448
_ui$222488 = -584					; size = 4
_pkUnit$222484 = -580					; size = 4
_eUnit$222482 = -576					; size = 4
_kElement$222311 = -572					; size = 448
__$ArrayPad$ = -120					; size = 4
_ui$222307 = -116					; size = 4
_iCitySize$222304 = -112				; size = 4
_iCityLoop$222299 = -108				; size = 4
_iSmallestCitySize$222297 = -104			; size = 4
_pCity$222300 = -100					; size = 4
_pSmallestCity$222298 = -96				; size = 4
_aProductionSortedTR$ = -92				; size = 16
_apProductionTargetCities$ = -76			; size = 16
_iCityLoop$ = -60					; size = 4
_aGoldSortedTR$ = -56					; size = 16
_pCity$ = -40						; size = 4
_uiNumInternationalTradesToAdd$ = -36			; size = 4
_pWonderCity$ = -32					; size = 4
_aFoodSortedTR$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_aTradeConnectionList$ = 8				; size = 4
?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z PROC ; CvTradeAI::PrioritizeTradeRoutes, COMDAT
; _this$ = ecx

; 5345 : {	

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1904				; 00000770H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5346 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5347 : 	GetAvailableTR(aTradeConnectionList);

	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAvailableTR@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::GetAvailableTR

; 5348 : 
; 5349 : 	// if the list is empty, bail
; 5350 : 	if (aTradeConnectionList.size() == 0)

	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239072[ebp], edx
	cmp	DWORD PTR $T239072[ebp], 0
	jne	SHORT $LN35@Prioritize

; 5351 : 	{
; 5352 : 		return;

	jmp	$LN36@Prioritize
$LN35@Prioritize:

; 5353 : 	}
; 5354 : 
; 5355 : 	// score TR
; 5356 : 	std::vector<TRSortElement> aProductionSortedTR;

	lea	ecx, DWORD PTR _aProductionSortedTR$[ebp]
	call	??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5357 : 	std::vector<TRSortElement> aFoodSortedTR;

	lea	ecx, DWORD PTR _aFoodSortedTR$[ebp]
	call	??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 5358 : 	std::vector<TRSortElement> aGoldSortedTR;

	lea	ecx, DWORD PTR _aGoldSortedTR$[ebp]
	call	??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 5359 : 
; 5360 : 	// FOOD FOOD FOOD FOOD
; 5361 : 	if (m_pPlayer->GetHappiness() >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetHappiness@CvPlayer@@QBEHXZ		; CvPlayer::GetHappiness
	test	eax, eax
	jl	$LN34@Prioritize

; 5362 : 	{
; 5363 : 		// - Find smallest city
; 5364 : 		int iSmallestCitySize = MAX_INT;

	mov	DWORD PTR _iSmallestCitySize$222297[ebp], 2147483647 ; 7fffffffH

; 5365 : 		CvCity* pSmallestCity = NULL;

	mov	DWORD PTR _pSmallestCity$222298[ebp], 0

; 5366 : 		int iCityLoop;
; 5367 : 		CvCity* pCity = NULL;

	mov	DWORD PTR _pCity$222300[ebp], 0

; 5368 : 		for (pCity = m_pPlayer->firstCity(&iCityLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$222299[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$222300[ebp], eax
	jmp	SHORT $LN33@Prioritize
$LN32@Prioritize:
	push	0
	lea	eax, DWORD PTR _iCityLoop$222299[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$222300[ebp], eax
$LN33@Prioritize:
	cmp	DWORD PTR _pCity$222300[ebp], 0
	je	SHORT $LN31@Prioritize

; 5369 : 		{
; 5370 : 			int iCitySize = pCity->getPopulation();

	mov	ecx, DWORD PTR _pCity$222300[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	DWORD PTR _iCitySize$222304[ebp], eax

; 5371 : 			if (iCitySize < iSmallestCitySize)

	mov	edx, DWORD PTR _iCitySize$222304[ebp]
	cmp	edx, DWORD PTR _iSmallestCitySize$222297[ebp]
	jge	SHORT $LN30@Prioritize

; 5372 : 			{
; 5373 : 				pSmallestCity = pCity;

	mov	eax, DWORD PTR _pCity$222300[ebp]
	mov	DWORD PTR _pSmallestCity$222298[ebp], eax

; 5374 : 				iSmallestCitySize = iCitySize;

	mov	ecx, DWORD PTR _iCitySize$222304[ebp]
	mov	DWORD PTR _iSmallestCitySize$222297[ebp], ecx
$LN30@Prioritize:

; 5375 : 			}
; 5376 : 		}

	jmp	SHORT $LN32@Prioritize
$LN31@Prioritize:

; 5377 : 
; 5378 : 		// - Send tr there
; 5379 : 		// if there is a smallest city, score according to that
; 5380 : 		if (pSmallestCity)

	cmp	DWORD PTR _pSmallestCity$222298[ebp], 0
	je	$LN34@Prioritize

; 5381 : 		{
; 5382 : 			aFoodSortedTR.clear();

	mov	edx, DWORD PTR _aFoodSortedTR$[ebp+8]
	mov	DWORD PTR $T239109[ebp], edx
	mov	eax, DWORD PTR $T239109[ebp]
	mov	DWORD PTR $T239134[ebp], eax
	mov	ecx, DWORD PTR $T239134[ebp]
	mov	DWORD PTR $T239133[ebp], ecx
	mov	edx, DWORD PTR _aFoodSortedTR$[ebp+4]
	mov	DWORD PTR $T239125[ebp], edx
	mov	eax, DWORD PTR $T239125[ebp]
	mov	DWORD PTR $T239136[ebp], eax
	mov	ecx, DWORD PTR $T239136[ebp]
	mov	DWORD PTR $T239135[ebp], ecx
	mov	edx, DWORD PTR $T239133[ebp]
	push	edx
	mov	eax, DWORD PTR $T239135[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239137[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aFoodSortedTR$[ebp]
	call	?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase

; 5383 : #ifdef AUI_ITERATORIZE
; 5384 : 			for (TradeConnectionList::iterator it = aTradeConnectionList.begin(); it != aTradeConnectionList.end(); ++it)
; 5385 : 			{
; 5386 : 				TRSortElement kElement;
; 5387 : 				kElement.m_kTradeConnection = *it;
; 5388 : 				kElement.m_iScore = ScoreFoodTR(*it, pSmallestCity);
; 5389 : #else
; 5390 : 			for (uint ui = 0; ui < aTradeConnectionList.size(); ui++)

	mov	DWORD PTR _ui$222307[ebp], 0
	jmp	SHORT $LN28@Prioritize
$LN27@Prioritize:
	mov	edx, DWORD PTR _ui$222307[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$222307[ebp], edx
$LN28@Prioritize:
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239154[ebp], ecx
	mov	edx, DWORD PTR _ui$222307[ebp]
	cmp	edx, DWORD PTR $T239154[ebp]
	jae	SHORT $LN26@Prioritize

; 5391 : 			{
; 5392 : 				TRSortElement kElement;

	lea	ecx, DWORD PTR _kElement$222311[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 5393 : 				kElement.m_kTradeConnection = aTradeConnectionList[ui];

	mov	eax, DWORD PTR _ui$222307[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	lea	ecx, DWORD PTR _kElement$222311[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 5394 : 				kElement.m_iScore = ScoreFoodTR(aTradeConnectionList[ui], pSmallestCity);

	mov	edx, DWORD PTR _ui$222307[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T239172[ebp], edx
	mov	ecx, DWORD PTR _pSmallestCity$222298[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239172[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScoreFoodTR@CvTradeAI@@QAEHABUTradeConnection@@PAVCvCity@@@Z ; CvTradeAI::ScoreFoodTR
	mov	DWORD PTR _kElement$222311[ebp+444], eax

; 5395 : #endif
; 5396 : 				if (kElement.m_iScore > 0)

	cmp	DWORD PTR _kElement$222311[ebp+444], 0
	jle	SHORT $LN25@Prioritize

; 5397 : 				{
; 5398 : 					aFoodSortedTR.push_back(kElement);

	lea	eax, DWORD PTR _kElement$222311[ebp]
	push	eax
	lea	ecx, DWORD PTR _aFoodSortedTR$[ebp]
	call	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
$LN25@Prioritize:

; 5399 : 				}
; 5400 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _kElement$222311[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN27@Prioritize
$LN26@Prioritize:

; 5401 : 
; 5402 : 			std::stable_sort(aFoodSortedTR.begin(), aFoodSortedTR.end(), SortTR());

	xor	ecx, ecx
	mov	BYTE PTR $T239051[ebp], cl
	mov	edx, DWORD PTR _aFoodSortedTR$[ebp+8]
	mov	DWORD PTR $T239223[ebp], edx
	mov	eax, DWORD PTR $T239223[ebp]
	mov	DWORD PTR $T239052[ebp], eax
	mov	ecx, DWORD PTR _aFoodSortedTR$[ebp+4]
	mov	DWORD PTR $T239239[ebp], ecx
	mov	edx, DWORD PTR $T239239[ebp]
	mov	DWORD PTR $T239053[ebp], edx
	mov	al, BYTE PTR $T239051[ebp]
	mov	BYTE PTR $T239274[ebp], al
	mov	ecx, DWORD PTR $T239052[ebp]
	mov	DWORD PTR $T239273[ebp], ecx
	mov	edx, DWORD PTR $T239053[ebp]
	mov	DWORD PTR $T239272[ebp], edx
	mov	eax, DWORD PTR $T239272[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T239273[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN34@Prioritize
	movzx	ecx, BYTE PTR $T239274[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR $T239273[ebp]
	push	edx
	mov	eax, DWORD PTR $T239272[ebp]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN34@Prioritize:

; 5403 : 		}
; 5404 : 	}
; 5405 : 
; 5406 : 	// PRODUCTION PRODUCTION PRODUCTION PRODUCTION
; 5407 : 	// - Search for wonder city
; 5408 : 	// - Search for spaceship city
; 5409 : #ifdef AUI_CONSTIFY
; 5410 : 	std::vector<const CvCity*> apProductionTargetCities;
; 5411 : #else
; 5412 : 	std::vector<CvCity*> apProductionTargetCities;

	lea	ecx, DWORD PTR _apProductionTargetCities$[ebp]
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 5413 : #endif
; 5414 : 	CvCity* pWonderCity = m_pPlayer->GetCitySpecializationAI()->GetWonderBuildCity();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?GetWonderBuildCity@CvCitySpecializationAI@@QBEPAVCvCity@@XZ ; CvCitySpecializationAI::GetWonderBuildCity
	mov	DWORD PTR _pWonderCity$[ebp], eax

; 5415 : 	if (pWonderCity)

	cmp	DWORD PTR _pWonderCity$[ebp], 0
	je	SHORT $LN24@Prioritize

; 5416 : 	{
; 5417 : 		apProductionTargetCities.push_back(pWonderCity);

	lea	edx, DWORD PTR _pWonderCity$[ebp]
	push	edx
	lea	ecx, DWORD PTR _apProductionTargetCities$[ebp]
	call	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
$LN24@Prioritize:

; 5418 : 	}
; 5419 : 	CvCity* pCity = NULL;

	mov	DWORD PTR _pCity$[ebp], 0

; 5420 : 	int iCityLoop;
; 5421 : 	for (pCity = m_pPlayer->firstCity(&iCityLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN23@Prioritize
$LN22@Prioritize:
	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN23@Prioritize:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN179@Prioritize

; 5422 : 	{
; 5423 : 		UnitTypes eUnit = pCity->getProductionUnit();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ ; CvCity::getProductionUnit
	mov	DWORD PTR _eUnit$222482[ebp], eax

; 5424 : 		if (eUnit != -1)

	cmp	DWORD PTR _eUnit$222482[ebp], -1
	je	SHORT $LN20@Prioritize

; 5425 : 		{
; 5426 : 			CvUnitEntry *pkUnit = GC.GetGameUnits()->GetEntry(eUnit);

	mov	ecx, DWORD PTR _eUnit$222482[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _pkUnit$222484[ebp], eax

; 5427 : 			if (pkUnit)

	cmp	DWORD PTR _pkUnit$222484[ebp], 0
	je	SHORT $LN20@Prioritize

; 5428 : 			{
; 5429 : 				if (pkUnit->GetSpaceshipProject() != NO_PROJECT)

	mov	ecx, DWORD PTR _pkUnit$222484[ebp]
	call	?GetSpaceshipProject@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetSpaceshipProject
	cmp	eax, -1
	je	SHORT $LN20@Prioritize

; 5430 : 				{
; 5431 : 					apProductionTargetCities.push_back(pCity);

	lea	edx, DWORD PTR _pCity$[ebp]
	push	edx
	lea	ecx, DWORD PTR _apProductionTargetCities$[ebp]
	call	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
$LN20@Prioritize:

; 5432 : 				}
; 5433 : 			}
; 5434 : 		}
; 5435 : 	}

	jmp	SHORT $LN22@Prioritize

; 5436 : 	if (apProductionTargetCities.size() > 0)

$LN179@Prioritize:
	mov	eax, DWORD PTR _apProductionTargetCities$[ebp+8]
	sub	eax, DWORD PTR _apProductionTargetCities$[ebp+4]
	sar	eax, 2
	test	eax, eax
	jbe	$LN17@Prioritize

; 5437 : 	{
; 5438 : 		aProductionSortedTR.clear();

	mov	ecx, DWORD PTR _aProductionSortedTR$[ebp+8]
	mov	DWORD PTR $T239362[ebp], ecx
	mov	edx, DWORD PTR $T239362[ebp]
	mov	DWORD PTR $T239387[ebp], edx
	mov	eax, DWORD PTR $T239387[ebp]
	mov	DWORD PTR $T239386[ebp], eax
	mov	ecx, DWORD PTR _aProductionSortedTR$[ebp+4]
	mov	DWORD PTR $T239378[ebp], ecx
	mov	edx, DWORD PTR $T239378[ebp]
	mov	DWORD PTR $T239389[ebp], edx
	mov	eax, DWORD PTR $T239389[ebp]
	mov	DWORD PTR $T239388[ebp], eax
	mov	ecx, DWORD PTR $T239386[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239388[ebp]
	push	edx
	lea	eax, DWORD PTR $T239390[ebp]
	push	eax
	lea	ecx, DWORD PTR _aProductionSortedTR$[ebp]
	call	?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase

; 5439 : #ifdef AUI_ITERATORIZE
; 5440 : 		for (TradeConnectionList::iterator it = aTradeConnectionList.begin(); it != aTradeConnectionList.end(); ++it)
; 5441 : 		{
; 5442 : 			TRSortElement kElement;
; 5443 : 			kElement.m_kTradeConnection = *it;
; 5444 : 			kElement.m_iScore = ScoreProductionTR(*it, apProductionTargetCities);
; 5445 : #else
; 5446 : 		for (uint ui = 0; ui < aTradeConnectionList.size(); ui++)

	mov	DWORD PTR _ui$222488[ebp], 0
	jmp	SHORT $LN16@Prioritize
$LN15@Prioritize:
	mov	ecx, DWORD PTR _ui$222488[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$222488[ebp], ecx
$LN16@Prioritize:
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239407[ebp], eax
	mov	ecx, DWORD PTR _ui$222488[ebp]
	cmp	ecx, DWORD PTR $T239407[ebp]
	jae	$LN14@Prioritize

; 5447 : 		{
; 5448 : 			TRSortElement kElement;

	lea	ecx, DWORD PTR _kElement$222492[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 5449 : 			kElement.m_kTradeConnection = aTradeConnectionList[ui];

	mov	edx, DWORD PTR _ui$222488[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _kElement$222492[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 5450 : 			kElement.m_iScore = ScoreProductionTR(aTradeConnectionList[ui], apProductionTargetCities);

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR $T239054[ebp], esp
	lea	edx, DWORD PTR _apProductionTargetCities$[ebp]
	push	edx
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	DWORD PTR tv404[ebp], eax
	mov	eax, DWORD PTR _ui$222488[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T239425[ebp], eax
	mov	edx, DWORD PTR $T239425[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScoreProductionTR@CvTradeAI@@QAEHABUTradeConnection@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@Z ; CvTradeAI::ScoreProductionTR
	mov	DWORD PTR tv405[ebp], eax
	mov	eax, DWORD PTR tv405[ebp]
	mov	DWORD PTR _kElement$222492[ebp+444], eax

; 5451 : #endif
; 5452 : 			if (kElement.m_iScore > 0)

	cmp	DWORD PTR _kElement$222492[ebp+444], 0
	jle	SHORT $LN13@Prioritize

; 5453 : 			{
; 5454 : 				aProductionSortedTR.push_back(kElement);

	lea	ecx, DWORD PTR _kElement$222492[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aProductionSortedTR$[ebp]
	call	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
$LN13@Prioritize:

; 5455 : 			}
; 5456 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _kElement$222492[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN15@Prioritize
$LN14@Prioritize:

; 5457 : 		std::stable_sort(aProductionSortedTR.begin(), aProductionSortedTR.end(), SortTR());

	xor	edx, edx
	mov	BYTE PTR $T239055[ebp], dl
	mov	eax, DWORD PTR _aProductionSortedTR$[ebp+8]
	mov	DWORD PTR $T239476[ebp], eax
	mov	ecx, DWORD PTR $T239476[ebp]
	mov	DWORD PTR $T239056[ebp], ecx
	mov	edx, DWORD PTR _aProductionSortedTR$[ebp+4]
	mov	DWORD PTR $T239492[ebp], edx
	mov	eax, DWORD PTR $T239492[ebp]
	mov	DWORD PTR $T239057[ebp], eax
	mov	cl, BYTE PTR $T239055[ebp]
	mov	BYTE PTR $T239527[ebp], cl
	mov	edx, DWORD PTR $T239056[ebp]
	mov	DWORD PTR $T239526[ebp], edx
	mov	eax, DWORD PTR $T239057[ebp]
	mov	DWORD PTR $T239525[ebp], eax
	mov	ecx, DWORD PTR $T239525[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T239526[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@Prioritize
	movzx	edx, BYTE PTR $T239527[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR $T239526[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239525[ebp]
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN17@Prioritize:

; 5458 : 	}
; 5459 : 
; 5460 : 	// GOLD GOLD GOLD GOLD
; 5461 : 	aGoldSortedTR.clear();

	mov	edx, DWORD PTR _aGoldSortedTR$[ebp+8]
	mov	DWORD PTR $T239543[ebp], edx
	mov	eax, DWORD PTR $T239543[ebp]
	mov	DWORD PTR $T239569[ebp], eax
	mov	ecx, DWORD PTR $T239569[ebp]
	mov	DWORD PTR $T239568[ebp], ecx
	mov	edx, DWORD PTR _aGoldSortedTR$[ebp+4]
	mov	DWORD PTR $T239559[ebp], edx
	mov	eax, DWORD PTR $T239559[ebp]
	mov	DWORD PTR $T239571[ebp], eax
	mov	ecx, DWORD PTR $T239571[ebp]
	mov	DWORD PTR $T239570[ebp], ecx
	mov	edx, DWORD PTR $T239568[ebp]
	push	edx
	mov	eax, DWORD PTR $T239570[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239572[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aGoldSortedTR$[ebp]
	call	?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase

; 5462 : #ifdef AUI_ITERATORIZE
; 5463 : 	for (TradeConnectionList::iterator it = aTradeConnectionList.begin(); it != aTradeConnectionList.end(); ++it)
; 5464 : 	{
; 5465 : 		TRSortElement kElement;
; 5466 : 		kElement.m_kTradeConnection = *it;
; 5467 : 		kElement.m_iScore = ScoreInternationalTR(*it);
; 5468 : #else
; 5469 : 	for (uint ui = 0; ui < aTradeConnectionList.size(); ui++)

	mov	DWORD PTR _ui$222498[ebp], 0
	jmp	SHORT $LN12@Prioritize
$LN11@Prioritize:
	mov	edx, DWORD PTR _ui$222498[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$222498[ebp], edx
$LN12@Prioritize:
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239588[ebp], ecx
	mov	edx, DWORD PTR _ui$222498[ebp]
	cmp	edx, DWORD PTR $T239588[ebp]
	jae	$LN10@Prioritize

; 5470 : 	{
; 5471 : 		TRSortElement kElement;

	lea	ecx, DWORD PTR _kElement$222502[ebp+44]
	call	??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 5472 : 		kElement.m_kTradeConnection = aTradeConnectionList[ui];

	mov	eax, DWORD PTR _ui$222498[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	lea	ecx, DWORD PTR _kElement$222502[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z

; 5473 : 		kElement.m_iScore = ScoreInternationalTR(aTradeConnectionList[ui]);

	mov	edx, DWORD PTR _ui$222498[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T239606[ebp], edx
	mov	ecx, DWORD PTR $T239606[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScoreInternationalTR@CvTradeAI@@QAEHABUTradeConnection@@@Z ; CvTradeAI::ScoreInternationalTR
	mov	DWORD PTR _kElement$222502[ebp+444], eax

; 5474 : #endif
; 5475 : 		if (kElement.m_iScore > 0)

	cmp	DWORD PTR _kElement$222502[ebp+444], 0
	jle	SHORT $LN9@Prioritize

; 5476 : 		{
; 5477 : 			aGoldSortedTR.push_back(kElement);

	lea	edx, DWORD PTR _kElement$222502[ebp]
	push	edx
	lea	ecx, DWORD PTR _aGoldSortedTR$[ebp]
	call	?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
$LN9@Prioritize:

; 5478 : 		}
; 5479 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _kElement$222502[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN11@Prioritize
$LN10@Prioritize:

; 5480 : 	std::stable_sort(aGoldSortedTR.begin(), aGoldSortedTR.end(), SortTR());

	xor	eax, eax
	mov	BYTE PTR $T239058[ebp], al
	mov	ecx, DWORD PTR _aGoldSortedTR$[ebp+8]
	mov	DWORD PTR $T239657[ebp], ecx
	mov	edx, DWORD PTR $T239657[ebp]
	mov	DWORD PTR $T239059[ebp], edx
	mov	eax, DWORD PTR _aGoldSortedTR$[ebp+4]
	mov	DWORD PTR $T239673[ebp], eax
	mov	ecx, DWORD PTR $T239673[ebp]
	mov	DWORD PTR $T239060[ebp], ecx
	mov	dl, BYTE PTR $T239058[ebp]
	mov	BYTE PTR $T239708[ebp], dl
	mov	eax, DWORD PTR $T239059[ebp]
	mov	DWORD PTR $T239707[ebp], eax
	mov	ecx, DWORD PTR $T239060[ebp]
	mov	DWORD PTR $T239706[ebp], ecx
	mov	edx, DWORD PTR $T239706[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T239707[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN329@Prioritize
	movzx	eax, BYTE PTR $T239708[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR $T239707[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239706[ebp]
	push	edx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN329@Prioritize:

; 5481 : 	uint uiNumInternationalTradesToAdd = 2;

	mov	DWORD PTR _uiNumInternationalTradesToAdd$[ebp], 2

; 5482 : 
; 5483 : 	// clear list
; 5484 : 	aTradeConnectionList.clear();

	mov	eax, DWORD PTR _aTradeConnectionList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _aTradeConnectionList$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	call	?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ; BaseVector<TradeConnection,0>::Destroy
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 5485 : 
; 5486 : 	// add all the gold trs
; 5487 : #ifdef AUI_ITERATORIZE
; 5488 : 	std::vector<TRSortElement>::iterator it;
; 5489 : 	uint ui = 0;
; 5490 : 	for (it = aGoldSortedTR.begin(); ui < uiNumInternationalTradesToAdd && it < aGoldSortedTR.end(); ++it)
; 5491 : 	{
; 5492 : 		aTradeConnectionList.push_back(it->m_kTradeConnection);
; 5493 : 		ui++;
; 5494 : #else
; 5495 : 	for (uint ui = 0; ui < uiNumInternationalTradesToAdd && ui < aGoldSortedTR.size(); ui++)

	mov	DWORD PTR _ui$222508[ebp], 0
	jmp	SHORT $LN8@Prioritize
$LN7@Prioritize:
	mov	edx, DWORD PTR _ui$222508[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$222508[ebp], edx
$LN8@Prioritize:
	mov	eax, DWORD PTR _ui$222508[ebp]
	cmp	eax, DWORD PTR _uiNumInternationalTradesToAdd$[ebp]
	jae	SHORT $LN353@Prioritize
	mov	eax, DWORD PTR _aGoldSortedTR$[ebp+8]
	sub	eax, DWORD PTR _aGoldSortedTR$[ebp+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	cmp	DWORD PTR _ui$222508[ebp], eax
	jae	SHORT $LN353@Prioritize

; 5496 : 	{
; 5497 : 		aTradeConnectionList.push_back(aGoldSortedTR[ui].m_kTradeConnection);

	mov	edx, DWORD PTR _ui$222508[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR _aGoldSortedTR$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 5498 : #endif
; 5499 : 	}

	jmp	SHORT $LN7@Prioritize

; 5500 : 
; 5501 : 	// add first food
; 5502 : 	if (aFoodSortedTR.size() > 0) 

$LN353@Prioritize:
	mov	eax, DWORD PTR _aFoodSortedTR$[ebp+8]
	sub	eax, DWORD PTR _aFoodSortedTR$[ebp+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	test	eax, eax
	jbe	SHORT $LN357@Prioritize

; 5503 : 	{
; 5504 : #ifdef AUI_ITERATORIZE
; 5505 : 		aTradeConnectionList.push_back(aFoodSortedTR.begin()->m_kTradeConnection);
; 5506 : #else
; 5507 : 		aTradeConnectionList.push_back(aFoodSortedTR[0].m_kTradeConnection);

	xor	edx, edx
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR _aFoodSortedTR$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 5508 : #endif
; 5509 : 	}
; 5510 : 	
; 5511 : 	// add first production tr
; 5512 : 	if (aProductionSortedTR.size() > 0)

$LN357@Prioritize:
	mov	eax, DWORD PTR _aProductionSortedTR$[ebp+8]
	sub	eax, DWORD PTR _aProductionSortedTR$[ebp+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	test	eax, eax
	jbe	SHORT $LN4@Prioritize

; 5513 : 	{
; 5514 : #ifdef AUI_ITERATORIZE
; 5515 : 		aTradeConnectionList.push_back(aProductionSortedTR.begin()->m_kTradeConnection);
; 5516 : #else
; 5517 : 		aTradeConnectionList.push_back(aProductionSortedTR[0].m_kTradeConnection);

	xor	edx, edx
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR _aProductionSortedTR$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back
$LN4@Prioritize:

; 5518 : #endif
; 5519 : 	}
; 5520 : 
; 5521 : 	// add all the gold trs
; 5522 : #ifdef AUI_ITERATORIZE
; 5523 : 	for (;it < aGoldSortedTR.end(); ++it)
; 5524 : 	{
; 5525 : 		aTradeConnectionList.push_back(it->m_kTradeConnection);
; 5526 : #else
; 5527 : 	for (uint ui = uiNumInternationalTradesToAdd; ui < aGoldSortedTR.size(); ui++)

	mov	eax, DWORD PTR _uiNumInternationalTradesToAdd$[ebp]
	mov	DWORD PTR _ui$222514[ebp], eax
	jmp	SHORT $LN361@Prioritize
$LN2@Prioritize:
	mov	ecx, DWORD PTR _ui$222514[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$222514[ebp], ecx
$LN361@Prioritize:
	mov	eax, DWORD PTR _aGoldSortedTR$[ebp+8]
	sub	eax, DWORD PTR _aGoldSortedTR$[ebp+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	cmp	DWORD PTR _ui$222514[ebp], eax
	jae	SHORT $LN1@Prioritize

; 5528 : 	{
; 5529 : 		aTradeConnectionList.push_back(aGoldSortedTR[ui].m_kTradeConnection);

	mov	edx, DWORD PTR _ui$222514[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR _aGoldSortedTR$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _aTradeConnectionList$[ebp]
	call	?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ; FStaticVector<TradeConnection,168,0,297,0>::push_back

; 5530 : #endif
; 5531 : 	}

	jmp	SHORT $LN2@Prioritize
$LN1@Prioritize:

; 5532 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _apProductionTargetCities$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _aGoldSortedTR$[ebp]
	call	?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR _aFoodSortedTR$[ebp]
	call	?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR _aProductionSortedTR$[ebp]
	call	?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN36@Prioritize:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$0:
	lea	ecx, DWORD PTR _aProductionSortedTR$[ebp]
	jmp	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$1:
	lea	ecx, DWORD PTR _aFoodSortedTR$[ebp]
	jmp	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$2:
	lea	ecx, DWORD PTR _aGoldSortedTR$[ebp]
	jmp	??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$3:
	lea	ecx, DWORD PTR _kElement$222311[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$4:
	lea	ecx, DWORD PTR _apProductionTargetCities$[ebp]
	jmp	??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$5:
	lea	ecx, DWORD PTR _kElement$222492[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$7:
	lea	ecx, DWORD PTR _kElement$222502[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$25:
	lea	ecx, DWORD PTR _apProductionTargetCities$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$27:
	lea	ecx, DWORD PTR _aGoldSortedTR$[ebp]
	jmp	??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$29:
	lea	ecx, DWORD PTR _aFoodSortedTR$[ebp]
	jmp	??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
__unwindfunclet$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z$31:
	lea	ecx, DWORD PTR _aProductionSortedTR$[ebp]
	jmp	??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
__ehhandler$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1908]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PrioritizeTradeRoutes@CvTradeAI@@QAEXAAV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ENDP ; CvTradeAI::PrioritizeTradeRoutes
; Function compile flags: /Odtp
;	COMDAT ??1TRSortElement@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1TRSortElement@@QAE@XZ PROC				; TRSortElement::~TRSortElement, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1TRSortElement@@QAE@XZ ENDP				; TRSortElement::~TRSortElement
_TEXT	ENDS
PUBLIC	?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ; CvTradeAI::ChooseTradeUnitTargetPlot
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?canMakeTradeRouteAt@CvUnit@@QBE_NPBVCvPlot@@HHW4TradeConnectionType@@@Z:PROC ; CvUnit::canMakeTradeRouteAt
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
; Function compile flags: /Odtp
;	COMDAT ?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z
_TEXT	SEGMENT
tv423 = -204						; size = 4
tv438 = -200						; size = 4
tv389 = -196						; size = 4
_this$ = -192						; size = 4
$T240216 = -188						; size = 4
$T240215 = -184						; size = 4
$T240170 = -180						; size = 4
$T240157 = -176						; size = 4
$T240153 = -172						; size = 4
$T240139 = -168						; size = 4
$T240135 = -161						; size = 1
$T240124 = -160						; size = 4
$T240120 = -153						; size = 1
_iMapY$240214 = -152					; size = 4
_iMapX$240213 = -148					; size = 4
$T240113 = -144						; size = 4
$T240109 = -140						; size = 4
$T240105 = -136						; size = 4
$T240101 = -132						; size = 4
$T240097 = -128						; size = 4
$T240093 = -124						; size = 4
$T240089 = -120						; size = 4
$T240088 = -116						; size = 4
$T240051 = -112						; size = 4
$T240039 = -108						; size = 4
$T240035 = -101						; size = 1
$T240024 = -100						; size = 4
$T240020 = -93						; size = 1
_iMapY$240087 = -92					; size = 4
_iMapX$240086 = -88					; size = 4
$T240013 = -84						; size = 4
$T240009 = -80						; size = 4
$T240005 = -76						; size = 4
$T240001 = -72						; size = 4
$T239997 = -68						; size = 4
$T239990 = -64						; size = 4
$T239983 = -60						; size = 4
$T239976 = -56						; size = 4
$T239969 = -52						; size = 4
$T239962 = -48						; size = 4
_pDestPlot$222555 = -40					; size = 4
_pPlot$222553 = -36					; size = 4
_ui$222546 = -32					; size = 4
_ui2$222541 = -28					; size = 4
_ui$222537 = -24					; size = 4
_uiNumTradeRoutesPossible$ = -20			; size = 4
_uiNumTradeConnections$ = -16				; size = 4
_uiNumDuplicateTRs$ = -12				; size = 4
_pkTradeAI$ = -8					; size = 4
_pOriginCity$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_iOriginPlotIndex$ = 12					; size = 4
_iDestPlotIndex$ = 16					; size = 4
_eTradeConnectionType$ = 20				; size = 4
_bDisband$ = 24						; size = 4
_aTradeConnections$ = 28				; size = 4
?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z PROC ; CvTradeAI::ChooseTradeUnitTargetPlot, COMDAT
; _this$ = ecx

; 5540 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	DWORD PTR _this$[ebp], ecx

; 5541 : 	// clearing the returned data
; 5542 : 	iOriginPlotIndex = MAX_INT;

	mov	eax, DWORD PTR _iOriginPlotIndex$[ebp]
	mov	DWORD PTR [eax], 2147483647		; 7fffffffH

; 5543 : 	iDestPlotIndex = MAX_INT;

	mov	ecx, DWORD PTR _iDestPlotIndex$[ebp]
	mov	DWORD PTR [ecx], 2147483647		; 7fffffffH

; 5544 : 	eTradeConnectionType = NUM_TRADE_CONNECTION_TYPES;

	mov	edx, DWORD PTR _eTradeConnectionType$[ebp]
	mov	DWORD PTR [edx], 3

; 5545 : 	bDisband = false;

	mov	eax, DWORD PTR _bDisband$[ebp]
	mov	BYTE PTR [eax], 0

; 5546 : 
; 5547 : 	CvCity* pOriginCity = pUnit->plot()->getPlotCity();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pOriginCity$[ebp], eax

; 5548 : 	CvAssertMsg(pOriginCity, "pOriginCity is null! Whaa?");
; 5549 : 	if (!pOriginCity)

	cmp	DWORD PTR _pOriginCity$[ebp], 0
	jne	SHORT $LN15@ChooseTrad

; 5550 : 	{
; 5551 : 		return false;

	xor	al, al
	jmp	$LN16@ChooseTrad
$LN15@ChooseTrad:

; 5552 : 	}
; 5553 : 
; 5554 : 	CvPlayerTrade* pkTradeAI = m_pPlayer->GetTrade();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	DWORD PTR _pkTradeAI$[ebp], eax

; 5555 : 	//CvPlayerTrade* pPlayerTrade = m_pPlayer->GetTrade();
; 5556 : 	uint uiNumDuplicateTRs = 0;

	mov	DWORD PTR _uiNumDuplicateTRs$[ebp], 0

; 5557 : 	uint uiNumTradeRoutesPossible =  pkTradeAI->GetNumTradeRoutesPossible();

	mov	ecx, DWORD PTR _pkTradeAI$[ebp]
	call	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
	mov	DWORD PTR _uiNumTradeRoutesPossible$[ebp], eax

; 5558 : #ifdef AUI_ITERATORIZE
; 5559 : 	const TradeConnectionList::const_iterator pNoMoreTradeRoutesPossible = aTradeConnections.begin() + uiNumTradeRoutesPossible;
; 5560 : 	for (TradeConnectionList::const_iterator it = aTradeConnections.begin(); it != aTradeConnections.end() && it < pNoMoreTradeRoutesPossible; ++it)
; 5561 : 	{
; 5562 : 		for (TradeConnectionList::const_iterator it2 = it + 1; it2 != aTradeConnections.end() && it2 < pNoMoreTradeRoutesPossible; ++it2)
; 5563 : 		{
; 5564 : 			if (it->m_iOriginX == it2->m_iOriginX &&
; 5565 : 				it->m_iOriginY == it2->m_iOriginY &&
; 5566 : 				it->m_iDestX == it2->m_iDestX &&
; 5567 : 				it->m_iDestY == it2->m_iDestY &&
; 5568 : 				it->m_eConnectionType == it2->m_eConnectionType)
; 5569 : #else
; 5570 : 	uint uiNumTradeConnections = aTradeConnections.size();

	mov	edx, DWORD PTR _aTradeConnections$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _uiNumTradeConnections$[ebp], eax

; 5571 : 
; 5572 : 	for (uint ui = 0; ui < uiNumTradeRoutesPossible && ui < uiNumTradeConnections; ui++)

	mov	DWORD PTR _ui$222537[ebp], 0
	jmp	SHORT $LN14@ChooseTrad
$LN13@ChooseTrad:
	mov	ecx, DWORD PTR _ui$222537[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$222537[ebp], ecx
$LN14@ChooseTrad:
	mov	edx, DWORD PTR _ui$222537[ebp]
	cmp	edx, DWORD PTR _uiNumTradeRoutesPossible$[ebp]
	jae	$LN12@ChooseTrad
	mov	eax, DWORD PTR _ui$222537[ebp]
	cmp	eax, DWORD PTR _uiNumTradeConnections$[ebp]
	jae	$LN12@ChooseTrad

; 5573 : 	{
; 5574 : 		for (uint ui2 = ui + 1;  ui2 < uiNumTradeRoutesPossible && ui2 < uiNumTradeConnections; ui2++)

	mov	ecx, DWORD PTR _ui$222537[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui2$222541[ebp], ecx
	jmp	SHORT $LN11@ChooseTrad
$LN10@ChooseTrad:
	mov	edx, DWORD PTR _ui2$222541[ebp]
	add	edx, 1
	mov	DWORD PTR _ui2$222541[ebp], edx
$LN11@ChooseTrad:
	mov	eax, DWORD PTR _ui2$222541[ebp]
	cmp	eax, DWORD PTR _uiNumTradeRoutesPossible$[ebp]
	jae	$LN9@ChooseTrad
	mov	ecx, DWORD PTR _ui2$222541[ebp]
	cmp	ecx, DWORD PTR _uiNumTradeConnections$[ebp]
	jae	$LN9@ChooseTrad

; 5575 : 		{
; 5576 : 			if (aTradeConnections[ui].m_iOriginX == aTradeConnections[ui2].m_iOriginX && 
; 5577 : 				aTradeConnections[ui].m_iOriginY == aTradeConnections[ui2].m_iOriginY && 
; 5578 : 				aTradeConnections[ui].m_iDestX   == aTradeConnections[ui2].m_iDestX && 
; 5579 : 				aTradeConnections[ui].m_iDestY   == aTradeConnections[ui2].m_iDestY && 
; 5580 : 				aTradeConnections[ui].m_eConnectionType == aTradeConnections[ui2].m_eConnectionType)

	mov	edx, DWORD PTR _ui$222537[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T239962[ebp], edx
	mov	ecx, DWORD PTR _ui2$222541[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnections$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR $T239962[ebp]
	mov	edx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [eax+ecx+4]
	jne	$LN8@ChooseTrad
	mov	eax, DWORD PTR _ui$222537[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnections$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T239969[ebp], eax
	mov	edx, DWORD PTR _ui2$222541[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T239969[ebp]
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [ecx+edx+8]
	jne	$LN8@ChooseTrad
	mov	ecx, DWORD PTR _ui$222537[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnections$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T239976[ebp], ecx
	mov	eax, DWORD PTR _ui2$222541[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnections$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T239976[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	cmp	ecx, DWORD PTR [edx+eax+12]
	jne	SHORT $LN8@ChooseTrad
	mov	edx, DWORD PTR _ui$222537[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T239983[ebp], edx
	mov	ecx, DWORD PTR _ui2$222541[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnections$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR $T239983[ebp]
	mov	edx, DWORD PTR [edx+16]
	cmp	edx, DWORD PTR [eax+ecx+16]
	jne	SHORT $LN8@ChooseTrad
	mov	eax, DWORD PTR _ui$222537[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnections$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T239990[ebp], eax
	mov	edx, DWORD PTR _ui2$222541[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR $T239990[ebp]
	mov	eax, DWORD PTR [eax+32]
	cmp	eax, DWORD PTR [ecx+edx+32]
	jne	SHORT $LN8@ChooseTrad

; 5581 : #endif
; 5582 : 			{
; 5583 : 				uiNumDuplicateTRs++;

	mov	ecx, DWORD PTR _uiNumDuplicateTRs$[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiNumDuplicateTRs$[ebp], ecx
$LN8@ChooseTrad:

; 5584 : 			}
; 5585 : 		}

	jmp	$LN10@ChooseTrad
$LN9@ChooseTrad:

; 5586 : 	}

	jmp	$LN13@ChooseTrad
$LN12@ChooseTrad:

; 5587 : 
; 5588 : #ifdef AUI_ITERATORIZE
; 5589 : 	const TradeConnectionList::const_iterator pDisbandThreshold = aTradeConnections.begin() + uiNumTradeRoutesPossible + uiNumDuplicateTRs;
; 5590 : 	for (TradeConnectionList::const_iterator it = aTradeConnections.begin(); it != aTradeConnections.end() && it < pNoMoreTradeRoutesPossible; ++it)
; 5591 : 	{
; 5592 : 		if (it >= pDisbandThreshold)
; 5593 : 		{
; 5594 : 			if ((uiNumTradeRoutesPossible - pkTradeAI->GetNumTradeRoutesUsed(true)) == 0) // GetNumTradeRoutesRemaining(true)
; 5595 : 			{
; 5596 : 				bDisband = true;
; 5597 : 				return true;
; 5598 : 			}
; 5599 : 		}
; 5600 : 
; 5601 : 		if (it->m_eDomain == pUnit->getDomainType())
; 5602 : 		{
; 5603 : 			CvPlot* pPlot = GC.getMap().plot(it->m_iOriginX, it->m_iOriginY);
; 5604 : 			if (pUnit->canMakeTradeRouteAt(pPlot, it->m_iDestX, it->m_iDestY, it->m_eConnectionType))
; 5605 : 			{
; 5606 : 				CvPlot* pDestPlot = GC.getMap().plot(it->m_iDestX, it->m_iDestY);
; 5607 : 				iOriginPlotIndex = pPlot->GetPlotIndex();
; 5608 : 				iDestPlotIndex = pDestPlot->GetPlotIndex();
; 5609 : 				eTradeConnectionType = it->m_eConnectionType;
; 5610 : #else
; 5611 : 	for (uint ui = 0; ui < aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$222546[ebp], 0
	jmp	SHORT $LN7@ChooseTrad
$LN6@ChooseTrad:
	mov	edx, DWORD PTR _ui$222546[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$222546[ebp], edx
$LN7@ChooseTrad:
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239997[ebp], ecx
	mov	edx, DWORD PTR _ui$222546[ebp]
	cmp	edx, DWORD PTR $T239997[ebp]
	jae	$LN5@ChooseTrad

; 5612 : 	{
; 5613 : 		if (ui >= (uiNumTradeRoutesPossible + uiNumDuplicateTRs))

	mov	eax, DWORD PTR _uiNumTradeRoutesPossible$[ebp]
	add	eax, DWORD PTR _uiNumDuplicateTRs$[ebp]
	cmp	DWORD PTR _ui$222546[ebp], eax
	jb	SHORT $LN4@ChooseTrad

; 5614 : 		{
; 5615 : 			if ((uiNumTradeRoutesPossible - pkTradeAI->GetNumTradeRoutesUsed(true)) == 0) // GetNumTradeRoutesRemaining(true)

	push	1
	mov	ecx, DWORD PTR _pkTradeAI$[ebp]
	call	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesUsed
	mov	ecx, DWORD PTR _uiNumTradeRoutesPossible$[ebp]
	sub	ecx, eax
	jne	SHORT $LN4@ChooseTrad

; 5616 : 			{
; 5617 : 				bDisband = true;

	mov	edx, DWORD PTR _bDisband$[ebp]
	mov	BYTE PTR [edx], 1

; 5618 : 				return true;

	mov	al, 1
	jmp	$LN16@ChooseTrad
$LN4@ChooseTrad:

; 5619 : 			}
; 5620 : 		}
; 5621 : 
; 5622 : 		if (aTradeConnections[ui].m_eDomain == pUnit->getDomainType())

	mov	eax, DWORD PTR _ui$222546[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnections$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T240001[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	edx, DWORD PTR $T240001[ebp]
	cmp	DWORD PTR [edx+28], eax
	jne	$LN2@ChooseTrad

; 5623 : 		{
; 5624 : 			CvPlot* pPlot = GC.getMap().plot(aTradeConnections[ui].m_iOriginX, aTradeConnections[ui].m_iOriginY);

	mov	eax, DWORD PTR _ui$222546[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnections$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T240005[ebp], eax
	mov	edx, DWORD PTR _ui$222546[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T240009[ebp], edx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240013[ebp], ecx
	mov	edx, DWORD PTR $T240005[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240089[ebp], eax
	mov	ecx, DWORD PTR $T240009[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240088[ebp], edx
	cmp	DWORD PTR $T240088[ebp], -2147483647	; 80000001H
	je	SHORT $LN55@ChooseTrad
	cmp	DWORD PTR $T240089[ebp], -2147483647	; 80000001H
	jne	SHORT $LN56@ChooseTrad
$LN55@ChooseTrad:
	mov	DWORD PTR _pPlot$222553[ebp], 0
	jmp	$LN57@ChooseTrad
$LN56@ChooseTrad:
	mov	eax, DWORD PTR $T240013[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T240020[ebp], cl
	mov	edx, DWORD PTR $T240013[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T240024[ebp], eax
	movzx	ecx, BYTE PTR $T240020[ebp]
	test	ecx, ecx
	je	SHORT $LN68@ChooseTrad
	cmp	DWORD PTR $T240088[ebp], 0
	jge	SHORT $LN67@ChooseTrad
	mov	eax, DWORD PTR $T240088[ebp]
	cdq
	idiv	DWORD PTR $T240024[ebp]
	add	edx, DWORD PTR $T240024[ebp]
	mov	DWORD PTR _iMapX$240086[ebp], edx
	jmp	SHORT $LN69@ChooseTrad
	jmp	SHORT $LN68@ChooseTrad
$LN67@ChooseTrad:
	mov	edx, DWORD PTR $T240088[ebp]
	cmp	edx, DWORD PTR $T240024[ebp]
	jl	SHORT $LN68@ChooseTrad
	mov	eax, DWORD PTR $T240088[ebp]
	cdq
	idiv	DWORD PTR $T240024[ebp]
	mov	DWORD PTR _iMapX$240086[ebp], edx
	jmp	SHORT $LN69@ChooseTrad
$LN68@ChooseTrad:
	mov	eax, DWORD PTR $T240088[ebp]
	mov	DWORD PTR _iMapX$240086[ebp], eax
$LN69@ChooseTrad:
	mov	ecx, DWORD PTR $T240013[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T240035[ebp], dl
	mov	eax, DWORD PTR $T240013[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T240039[ebp], ecx
	movzx	edx, BYTE PTR $T240035[ebp]
	test	edx, edx
	je	SHORT $LN78@ChooseTrad
	cmp	DWORD PTR $T240089[ebp], 0
	jge	SHORT $LN77@ChooseTrad
	mov	eax, DWORD PTR $T240089[ebp]
	cdq
	idiv	DWORD PTR $T240039[ebp]
	add	edx, DWORD PTR $T240039[ebp]
	mov	DWORD PTR _iMapY$240087[ebp], edx
	jmp	SHORT $LN79@ChooseTrad
	jmp	SHORT $LN78@ChooseTrad
$LN77@ChooseTrad:
	mov	eax, DWORD PTR $T240089[ebp]
	cmp	eax, DWORD PTR $T240039[ebp]
	jl	SHORT $LN78@ChooseTrad
	mov	eax, DWORD PTR $T240089[ebp]
	cdq
	idiv	DWORD PTR $T240039[ebp]
	mov	DWORD PTR _iMapY$240087[ebp], edx
	jmp	SHORT $LN79@ChooseTrad
$LN78@ChooseTrad:
	mov	ecx, DWORD PTR $T240089[ebp]
	mov	DWORD PTR _iMapY$240087[ebp], ecx
$LN79@ChooseTrad:
	mov	edx, DWORD PTR _iMapY$240087[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$240086[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240013[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN59@ChooseTrad
	mov	ecx, DWORD PTR $T240013[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240051[ebp], edx
	mov	eax, DWORD PTR _iMapY$240087[ebp]
	imul	eax, DWORD PTR $T240051[ebp]
	add	eax, DWORD PTR _iMapX$240086[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T240013[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv389[ebp], eax
	jmp	SHORT $LN60@ChooseTrad
$LN59@ChooseTrad:
	mov	DWORD PTR tv389[ebp], 0
$LN60@ChooseTrad:
	mov	edx, DWORD PTR tv389[ebp]
	mov	DWORD PTR _pPlot$222553[ebp], edx
$LN57@ChooseTrad:

; 5625 : 			if (pUnit->canMakeTradeRouteAt(pPlot, aTradeConnections[ui].m_iDestX, aTradeConnections[ui].m_iDestY, aTradeConnections[ui].m_eConnectionType))

	mov	eax, DWORD PTR _ui$222546[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnections$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T240093[ebp], eax
	mov	edx, DWORD PTR _ui$222546[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T240097[ebp], edx
	mov	ecx, DWORD PTR _ui$222546[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnections$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T240101[ebp], ecx
	mov	eax, DWORD PTR $T240093[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR $T240097[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR $T240101[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pPlot$222553[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMakeTradeRouteAt@CvUnit@@QBE_NPBVCvPlot@@HHW4TradeConnectionType@@@Z ; CvUnit::canMakeTradeRouteAt
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ChooseTrad

; 5626 : 			{
; 5627 : 				CvPlot* pDestPlot = GC.getMap().plot(aTradeConnections[ui].m_iDestX, aTradeConnections[ui].m_iDestY);

	mov	edx, DWORD PTR _ui$222546[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _aTradeConnections$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T240105[ebp], edx
	mov	ecx, DWORD PTR _ui$222546[ebp]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _aTradeConnections$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T240109[ebp], ecx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240113[ebp], eax
	mov	ecx, DWORD PTR $T240105[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T240216[ebp], edx
	mov	eax, DWORD PTR $T240109[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T240215[ebp], ecx
	cmp	DWORD PTR $T240215[ebp], -2147483647	; 80000001H
	je	SHORT $LN97@ChooseTrad
	cmp	DWORD PTR $T240216[ebp], -2147483647	; 80000001H
	jne	SHORT $LN98@ChooseTrad
$LN97@ChooseTrad:
	mov	DWORD PTR _pDestPlot$222555[ebp], 0
	jmp	$LN99@ChooseTrad
$LN98@ChooseTrad:
	mov	edx, DWORD PTR $T240113[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T240120[ebp], al
	mov	ecx, DWORD PTR $T240113[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240124[ebp], edx
	movzx	eax, BYTE PTR $T240120[ebp]
	test	eax, eax
	je	SHORT $LN110@ChooseTrad
	cmp	DWORD PTR $T240215[ebp], 0
	jge	SHORT $LN109@ChooseTrad
	mov	eax, DWORD PTR $T240215[ebp]
	cdq
	idiv	DWORD PTR $T240124[ebp]
	add	edx, DWORD PTR $T240124[ebp]
	mov	DWORD PTR _iMapX$240213[ebp], edx
	jmp	SHORT $LN111@ChooseTrad
	jmp	SHORT $LN110@ChooseTrad
$LN109@ChooseTrad:
	mov	ecx, DWORD PTR $T240215[ebp]
	cmp	ecx, DWORD PTR $T240124[ebp]
	jl	SHORT $LN110@ChooseTrad
	mov	eax, DWORD PTR $T240215[ebp]
	cdq
	idiv	DWORD PTR $T240124[ebp]
	mov	DWORD PTR _iMapX$240213[ebp], edx
	jmp	SHORT $LN111@ChooseTrad
$LN110@ChooseTrad:
	mov	edx, DWORD PTR $T240215[ebp]
	mov	DWORD PTR _iMapX$240213[ebp], edx
$LN111@ChooseTrad:
	mov	eax, DWORD PTR $T240113[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T240135[ebp], cl
	mov	edx, DWORD PTR $T240113[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T240139[ebp], eax
	movzx	ecx, BYTE PTR $T240135[ebp]
	test	ecx, ecx
	je	SHORT $LN120@ChooseTrad
	cmp	DWORD PTR $T240216[ebp], 0
	jge	SHORT $LN119@ChooseTrad
	mov	eax, DWORD PTR $T240216[ebp]
	cdq
	idiv	DWORD PTR $T240139[ebp]
	add	edx, DWORD PTR $T240139[ebp]
	mov	DWORD PTR _iMapY$240214[ebp], edx
	jmp	SHORT $LN121@ChooseTrad
	jmp	SHORT $LN120@ChooseTrad
$LN119@ChooseTrad:
	mov	edx, DWORD PTR $T240216[ebp]
	cmp	edx, DWORD PTR $T240139[ebp]
	jl	SHORT $LN120@ChooseTrad
	mov	eax, DWORD PTR $T240216[ebp]
	cdq
	idiv	DWORD PTR $T240139[ebp]
	mov	DWORD PTR _iMapY$240214[ebp], edx
	jmp	SHORT $LN121@ChooseTrad
$LN120@ChooseTrad:
	mov	eax, DWORD PTR $T240216[ebp]
	mov	DWORD PTR _iMapY$240214[ebp], eax
$LN121@ChooseTrad:
	cmp	DWORD PTR _iMapX$240213[ebp], 0
	jl	SHORT $LN125@ChooseTrad
	mov	ecx, DWORD PTR $T240113[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240153[ebp], edx
	mov	eax, DWORD PTR _iMapX$240213[ebp]
	cmp	eax, DWORD PTR $T240153[ebp]
	jge	SHORT $LN125@ChooseTrad
	cmp	DWORD PTR _iMapY$240214[ebp], 0
	jl	SHORT $LN125@ChooseTrad
	mov	ecx, DWORD PTR $T240113[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T240157[ebp], edx
	mov	eax, DWORD PTR _iMapY$240214[ebp]
	cmp	eax, DWORD PTR $T240157[ebp]
	jge	SHORT $LN125@ChooseTrad
	mov	DWORD PTR tv438[ebp], 1
	jmp	SHORT $LN123@ChooseTrad
$LN125@ChooseTrad:
	mov	DWORD PTR tv438[ebp], 0
$LN123@ChooseTrad:
	cmp	DWORD PTR tv438[ebp], 0
	je	SHORT $LN101@ChooseTrad
	mov	ecx, DWORD PTR $T240113[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240170[ebp], edx
	mov	eax, DWORD PTR _iMapY$240214[ebp]
	imul	eax, DWORD PTR $T240170[ebp]
	add	eax, DWORD PTR _iMapX$240213[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T240113[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv423[ebp], eax
	jmp	SHORT $LN102@ChooseTrad
$LN101@ChooseTrad:
	mov	DWORD PTR tv423[ebp], 0
$LN102@ChooseTrad:
	mov	edx, DWORD PTR tv423[ebp]
	mov	DWORD PTR _pDestPlot$222555[ebp], edx
$LN99@ChooseTrad:

; 5628 : 				iOriginPlotIndex = pPlot->GetPlotIndex();

	mov	ecx, DWORD PTR _pPlot$222553[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR _iOriginPlotIndex$[ebp]
	mov	DWORD PTR [ecx], eax

; 5629 : 				iDestPlotIndex = pDestPlot->GetPlotIndex();

	mov	ecx, DWORD PTR _pDestPlot$222555[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	edx, DWORD PTR _iDestPlotIndex$[ebp]
	mov	DWORD PTR [edx], eax

; 5630 : 				eTradeConnectionType = aTradeConnections[ui].m_eConnectionType;

	mov	eax, DWORD PTR _ui$222546[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _aTradeConnections$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _eTradeConnectionType$[ebp]
	mov	edx, DWORD PTR [edx+eax+32]
	mov	DWORD PTR [ecx], edx

; 5631 : #endif
; 5632 : 				return true;

	mov	al, 1
	jmp	SHORT $LN16@ChooseTrad
$LN2@ChooseTrad:

; 5633 : 			}
; 5634 : 		}
; 5635 : 	}

	jmp	$LN6@ChooseTrad
$LN5@ChooseTrad:

; 5636 : 
; 5637 : 	return false;

	xor	al, al
$LN16@ChooseTrad:

; 5638 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?ChooseTradeUnitTargetPlot@CvTradeAI@@QAE_NPAVCvUnit@@AAH1AAW4TradeConnectionType@@AA_NABV?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@@Z ENDP ; CvTradeAI::ChooseTradeUnitTargetPlot
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z	; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z PROC	; operator>>, COMDAT

; 5643 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5644 : 	uint uiVersion;
; 5645 : 	loadFrom >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5646 : 
; 5647 : 	loadFrom >> writeTo.m_iRemovableValue;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5648 : 
; 5649 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 5650 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvTradeAI@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z	; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z PROC	; operator<<, COMDAT

; 5654 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5655 : 	uint uiVersion = 0;

	mov	DWORD PTR _uiVersion$[ebp], 0

; 5656 : 	saveTo << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5657 : 
; 5658 : 	saveTo << readFrom.m_iRemovableValue;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5659 : 
; 5660 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 5661 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvTradeAI@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -208						; size = 4
tv148 = -204						; size = 4
tv172 = -200						; size = 4
_this$ = -196						; size = 4
$T240351 = -164						; size = 4
$T240350 = -160						; size = 4
$T240349 = -156						; size = 4
$T240339 = -152						; size = 4
$T240338 = -148						; size = 4
__Cat$240348 = -143					; size = 1
$T240345 = -142						; size = 1
$T240344 = -141						; size = 1
$T240318 = -140						; size = 4
$T240309 = -136						; size = 4
$T240278 = -48						; size = 4
$T240274 = -42						; size = 1
$T240261 = -41						; size = 1
$T240257 = -40						; size = 4
$T240250 = -32						; size = 4
$T240240 = -28						; size = 4
$T240239 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T240274[ebp]
	mov	DWORD PTR $T240250[ebp], eax
	lea	ecx, DWORD PTR $T240261[ebp]
	mov	DWORD PTR $T240257[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T240278[ebp], eax
	mov	ecx, DWORD PTR $T240278[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN3@vector

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240309[ebp], ecx
	mov	edx, DWORD PTR $T240309[ebp]
	mov	DWORD PTR $T240239[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240318[ebp], ecx
	mov	edx, DWORD PTR $T240318[ebp]
	mov	DWORD PTR $T240240[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240351[ebp], ecx
	mov	edx, DWORD PTR $T240239[ebp]
	mov	DWORD PTR $T240350[ebp], edx
	mov	eax, DWORD PTR $T240240[ebp]
	mov	DWORD PTR $T240349[ebp], eax
	mov	ecx, DWORD PTR $T240351[ebp]
	mov	DWORD PTR $T240339[ebp], ecx
	mov	edx, DWORD PTR $T240349[ebp]
	mov	DWORD PTR $T240338[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T240344[ebp], al
	mov	cl, BYTE PTR __Cat$240348[ebp]
	mov	BYTE PTR $T240345[ebp], cl
	movzx	edx, BYTE PTR $T240344[ebp]
	push	edx
	movzx	eax, BYTE PTR $T240345[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240339[ebp]
	push	edx
	mov	eax, DWORD PTR $T240350[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240338[ebp]
	push	ecx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN5@vector
__catch$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv224 = -308						; size = 4
_this$ = -304						; size = 4
$T240677 = -300						; size = 4
$T240676 = -296						; size = 4
$T240675 = -292						; size = 4
$T240621 = -176						; size = 4
$T240617 = -172						; size = 4
$T240616 = -168						; size = 4
$T240612 = -164						; size = 4
$T240611 = -160						; size = 4
$T240600 = -156						; size = 4
$T240599 = -152						; size = 4
__Cat$240607 = -146					; size = 1
$T240605 = -145						; size = 1
$T240580 = -144						; size = 4
$T240579 = -140						; size = 4
$T240527 = -84						; size = 4
$T240520 = -80						; size = 4
$T240509 = -76						; size = 4
$T240508 = -72						; size = 4
__Cat$240516 = -68					; size = 1
$T240514 = -67						; size = 1
$T240464 = -40						; size = 4
$T240435 = -36						; size = 4
$T240419 = -32						; size = 4
$T240447 = -28						; size = 4
$T240446 = -24						; size = 4
$T240445 = -20						; size = 4
$T240444 = -16						; size = 4
$T240443 = -12						; size = 4
__Ptr$222587 = -8					; size = 4
__Ptr$222584 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@6

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator@6

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240419[ebp], edx
	mov	eax, DWORD PTR $T240419[ebp]
	mov	DWORD PTR $T240444[ebp], eax
	mov	ecx, DWORD PTR $T240444[ebp]
	mov	DWORD PTR $T240443[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240435[ebp], eax
	mov	ecx, DWORD PTR $T240435[ebp]
	mov	DWORD PTR $T240446[ebp], ecx
	mov	edx, DWORD PTR $T240446[ebp]
	mov	DWORD PTR $T240445[ebp], edx
	mov	eax, DWORD PTR $T240443[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240445[ebp]
	push	ecx
	lea	edx, DWORD PTR $T240447[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator@6
$LN8@operator@6:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T240464[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR $T240464[ebp], edx
	ja	SHORT $LN6@operator@6

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$222584[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240520[ebp], ecx
	mov	edx, DWORD PTR $T240520[ebp]
	mov	DWORD PTR $T240509[ebp], edx
	mov	eax, DWORD PTR __Ptr$222584[ebp]
	mov	DWORD PTR $T240508[ebp], eax
	mov	cl, BYTE PTR __Cat$240516[ebp]
	mov	BYTE PTR $T240514[ebp], cl

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	$LN9@operator@6
$LN6@operator@6:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T240527[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN55@operator@6
	mov	DWORD PTR tv224[ebp], 0
	jmp	SHORT $LN53@operator@6
$LN55@operator@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv224[ebp], eax
$LN53@operator@6:
	mov	ecx, DWORD PTR $T240527[ebp]
	cmp	ecx, DWORD PTR tv224[ebp]
	ja	$LN4@operator@6

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR __Ptr$222587[ebp], ecx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Ptr$222587[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240580[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240579[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240580[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240579[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$222587[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@6
$LN4@operator@6:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN2@operator@6

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240612[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240611[ebp], eax
	mov	ecx, DWORD PTR $T240612[ebp]
	mov	DWORD PTR $T240600[ebp], ecx
	mov	edx, DWORD PTR $T240611[ebp]
	mov	DWORD PTR $T240599[ebp], edx
	mov	al, BYTE PTR __Cat$240607[ebp]
	mov	BYTE PTR $T240605[ebp], al

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T240617[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240616[ebp], edx
	mov	eax, DWORD PTR $T240616[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator@6:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T240621[ebp], eax
	mov	ecx, DWORD PTR $T240621[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@operator@6

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240677[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240676[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240675[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240677[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240676[ebp]
	push	edx
	mov	eax, DWORD PTR $T240675[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@operator@6:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@HV?$allocator@H@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T240709 = -30						; size = 1
$T240696 = -29						; size = 1
$T240692 = -28						; size = 4
$T240685 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T240709[ebp]
	mov	DWORD PTR $T240685[ebp], eax
	lea	ecx, DWORD PTR $T240696[ebp]
	mov	DWORD PTR $T240692[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$6
__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -216						; size = 4
tv148 = -212						; size = 4
tv172 = -208						; size = 4
_this$ = -204						; size = 4
$T240871 = -164						; size = 4
$T240870 = -160						; size = 4
$T240869 = -156						; size = 4
$T240859 = -152						; size = 4
$T240858 = -148						; size = 4
__Cat$240866 = -143					; size = 1
$T240863 = -142						; size = 1
$T240862 = -141						; size = 1
$T240838 = -140						; size = 4
$T240829 = -136						; size = 4
$T240798 = -48						; size = 4
$T240794 = -42						; size = 1
$T240781 = -41						; size = 1
$T240777 = -40						; size = 4
$T240770 = -32						; size = 4
$T240761 = -28						; size = 4
$T240760 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T240794[ebp]
	mov	DWORD PTR $T240770[ebp], eax
	lea	ecx, DWORD PTR $T240781[ebp]
	mov	DWORD PTR $T240777[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T240798[ebp], eax
	mov	edx, DWORD PTR $T240798[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	$LN3@vector@2

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240829[ebp], edx
	mov	eax, DWORD PTR $T240829[ebp]
	mov	DWORD PTR $T240760[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240838[ebp], edx
	mov	eax, DWORD PTR $T240838[ebp]
	mov	DWORD PTR $T240761[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240871[ebp], edx
	mov	eax, DWORD PTR $T240760[ebp]
	mov	DWORD PTR $T240870[ebp], eax
	mov	ecx, DWORD PTR $T240761[ebp]
	mov	DWORD PTR $T240869[ebp], ecx
	mov	edx, DWORD PTR $T240871[ebp]
	mov	DWORD PTR $T240859[ebp], edx
	mov	eax, DWORD PTR $T240869[ebp]
	mov	DWORD PTR $T240858[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240862[ebp], cl
	mov	dl, BYTE PTR __Cat$240866[ebp]
	mov	BYTE PTR $T240863[ebp], dl
	movzx	eax, BYTE PTR $T240862[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T240863[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240859[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240870[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240858[ebp]
	push	edx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN5@vector@2
__catch$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@2
	ret	0
$LN5@vector@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@2:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
PUBLIC	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
PUBLIC	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T241158 = -32						; size = 4
$T241148 = -28						; size = 4
$T241138 = -24						; size = 4
__Cat$241144 = -19					; size = 1
$T241142 = -18						; size = 1
$T241141 = -17						; size = 1
$T241115 = -16						; size = 4
$T241111 = -12						; size = 4
$T241110 = -8						; size = 4
$T241109 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T241115[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	edx, DWORD PTR $T241115[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241148[ebp], ecx
	mov	edx, DWORD PTR $T241148[ebp]
	mov	DWORD PTR $T241138[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241141[ebp], al
	mov	cl, BYTE PTR __Cat$241144[ebp]
	mov	BYTE PTR $T241142[ebp], cl
	movzx	edx, BYTE PTR $T241141[ebp]
	push	edx
	movzx	eax, BYTE PTR $T241142[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T241138[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR $T241148[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241158[ebp], ecx
	mov	edx, DWORD PTR $T241158[ebp]
	mov	DWORD PTR $T241110[ebp], edx
	mov	eax, DWORD PTR $T241110[ebp]
	mov	DWORD PTR $T241109[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241109[ebp]
	push	edx
	lea	eax, DWORD PTR $T241111[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::push_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z
_TEXT	SEGMENT
_this$ = -428						; size = 4
__Tmp$241535 = -236					; size = 8
$T241513 = -228						; size = 4
$T241491 = -224						; size = 4
$T241516 = -220						; size = 4
$T241425 = -192						; size = 4
$T241295 = -96						; size = 4
$T241237 = -68						; size = 4
$T241233 = -64						; size = 8
$T241232 = -56						; size = 8
$T241231 = -48						; size = 8
$T241230 = -40						; size = 8
$T241229 = -32						; size = 8
$T241228 = -24						; size = 8
$T241227 = -16						; size = 8
$T241226 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z PROC ; std::vector<bool,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 2039 : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	mov	DWORD PTR _this$[ebp], ecx

; 2040 : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241237[ebp], ecx
	mov	edx, DWORD PTR $T241237[ebp]
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize

; 2041 : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T241227[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241226[ebp], ecx
	mov	DWORD PTR $T241226[ebp+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241295[ebp], ecx
	movzx	edx, BYTE PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, DWORD PTR $T241295[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241226[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T241226[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	jmp	$LN4@resize
$LN3@resize:

; 2042 : 		else if (_Newsize < size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241425[ebp], ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, DWORD PTR $T241425[ebp]
	jae	$LN4@resize

; 2043 : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR $T241229[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241228[ebp], ecx
	mov	DWORD PTR $T241228[ebp+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241491[ebp], ecx
	mov	edx, DWORD PTR $T241491[ebp]
	mov	DWORD PTR $T241516[ebp], edx
	mov	eax, DWORD PTR $T241516[ebp]
	mov	DWORD PTR $T241513[ebp], eax
	mov	ecx, DWORD PTR $T241513[ebp]
	mov	DWORD PTR $T241231[ebp], ecx
	mov	DWORD PTR $T241231[ebp+4], 0
	mov	edx, DWORD PTR $T241231[ebp]
	mov	eax, DWORD PTR $T241231[ebp+4]
	mov	DWORD PTR __Tmp$241535[ebp], edx
	mov	DWORD PTR __Tmp$241535[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$241535[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$241535[ebp]
	mov	eax, DWORD PTR __Tmp$241535[ebp+4]
	mov	DWORD PTR $T241232[ebp], edx
	mov	DWORD PTR $T241232[ebp+4], eax
	mov	ecx, DWORD PTR $T241232[ebp]
	mov	edx, DWORD PTR $T241232[ebp+4]
	mov	DWORD PTR $T241230[ebp], ecx
	mov	DWORD PTR $T241230[ebp+4], edx
	mov	eax, DWORD PTR $T241228[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T241228[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241230[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T241230[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241233[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
$LN4@resize:

; 2044 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T241824 = -44						; size = 4
$T241823 = -40						; size = 4
__Tmp$241814 = -36					; size = 8
$T241792 = -28						; size = 4
$T241770 = -24						; size = 4
$T241794 = -20						; size = 4
$T241758 = -16						; size = 8
$T241757 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2090 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2091 : 		return (*(begin() + _Off));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241770[ebp], ecx
	mov	edx, DWORD PTR $T241770[ebp]
	mov	DWORD PTR $T241794[ebp], edx
	mov	eax, DWORD PTR $T241794[ebp]
	mov	DWORD PTR $T241792[ebp], eax
	mov	ecx, DWORD PTR $T241792[ebp]
	mov	DWORD PTR $T241757[ebp], ecx
	mov	DWORD PTR $T241757[ebp+4], 0
	mov	edx, DWORD PTR $T241757[ebp]
	mov	eax, DWORD PTR $T241757[ebp+4]
	mov	DWORD PTR __Tmp$241814[ebp], edx
	mov	DWORD PTR __Tmp$241814[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$241814[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$241814[ebp]
	mov	eax, DWORD PTR __Tmp$241814[ebp+4]
	mov	DWORD PTR $T241758[ebp], edx
	mov	DWORD PTR $T241758[ebp+4], eax
	mov	ecx, DWORD PTR $T241758[ebp+4]
	mov	DWORD PTR $T241824[ebp], ecx
	mov	edx, DWORD PTR $T241758[ebp]
	mov	DWORD PTR $T241823[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T241823[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T241824[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2092 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z$0
__ehfuncinfo$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T241847 = -20						; size = 4
_pRet$241844 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_RHS$ = 8						; size = 4
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 591  : 	FStaticVector(const THIS_TYPE& RHS)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 592  : 	{
; 593  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 594  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 595  : 		m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	eax, DWORD PTR _RHS$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241847[ebp], ecx
	cmp	DWORD PTR $T241847[ebp], 40		; 00000028H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T241847[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$241844[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T241847[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$241844[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 40			; 00000028H
$LN8@FStaticVec:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pRet$241844[ebp]
	mov	DWORD PTR [ecx], edx

; 596  : #ifdef BREAK_ON_STATIC_RESIZE
; 597  : 		m_iNumResized = 0;
; 598  : #endif
; 599  : 		Copy(RHS);

	mov	eax, DWORD PTR _RHS$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy

; 600  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
__ehhandler$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@ABV0@@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T241873 = -20						; size = 4
_pRet$241870 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 40			; 00000028H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241873[ebp], edx
	cmp	DWORD PTR $T241873[ebp], 40		; 00000028H
	jbe	SHORT $LN7@FStaticVec@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T241873[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$241870[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T241873[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@2
$LN7@FStaticVec@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$241870[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 40			; 00000028H
$LN8@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$241870[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
__ehhandler$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::FStaticVector<TradeConnectionPlot,40,0,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T241904 = -24						; size = 4
$T241903 = -20						; size = 4
_i$241896 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241904[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241903[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@FStaticVec@3
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@FStaticVec@3
	mov	DWORD PTR _i$241896[ebp], 0
	jmp	SHORT $LN10@FStaticVec@3
$LN9@FStaticVec@3:
	mov	eax, DWORD PTR _i$241896[ebp]
	add	eax, 1
	mov	DWORD PTR _i$241896[ebp], eax
$LN10@FStaticVec@3:
	mov	ecx, DWORD PTR _i$241896[ebp]
	cmp	ecx, DWORD PTR $T241904[ebp]
	jae	SHORT $LN5@FStaticVec@3
	jmp	SHORT $LN9@FStaticVec@3
$LN5@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T241903[ebp], edx
	je	SHORT $LN1@FStaticVec@3
	mov	eax, DWORD PTR $T241903[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@3:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
__ehhandler$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
; Function compile flags: /Odtp
;	COMDAT ??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_i$241949 = -24						; size = 4
$T241944 = -20						; size = 4
_pRet$241941 = -16					; size = 4
$T241937 = -12						; size = 4
$T241936 = -8						; size = 4
_i$241929 = -4						; size = 4
_RHS$ = 8						; size = 4
??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	ja	$LN2@operator@7

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241937[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241936[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN6@operator@7
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN6@operator@7
	mov	DWORD PTR _i$241929[ebp], 0
	jmp	SHORT $LN11@operator@7
$LN10@operator@7:
	mov	eax, DWORD PTR _i$241929[ebp]
	add	eax, 1
	mov	DWORD PTR _i$241929[ebp], eax
$LN11@operator@7:
	mov	ecx, DWORD PTR _i$241929[ebp]
	cmp	ecx, DWORD PTR $T241937[ebp]
	jae	SHORT $LN6@operator@7
	jmp	SHORT $LN10@operator@7
$LN6@operator@7:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T241936[ebp], edx
	je	SHORT $LN7@operator@7
	mov	eax, DWORD PTR $T241936[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN7@operator@7:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241944[ebp], edx
	cmp	DWORD PTR $T241944[ebp], 40		; 00000028H
	jbe	SHORT $LN16@operator@7
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T241944[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$241941[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T241944[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN17@operator@7
$LN16@operator@7:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$241941[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 40			; 00000028H
$LN17@operator@7:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$241941[ebp]
	mov	DWORD PTR [edx], eax

; 624  : 		}else{

	jmp	SHORT $LN1@operator@7
$LN2@operator@7:

; 625  : 			Destroy(m_pData, m_uiCurrSize);

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN1@operator@7
	mov	DWORD PTR _i$241949[ebp], 0
	jmp	SHORT $LN21@operator@7
$LN20@operator@7:
	mov	edx, DWORD PTR _i$241949[ebp]
	add	edx, 1
	mov	DWORD PTR _i$241949[ebp], edx
$LN21@operator@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$241949[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN1@operator@7
	jmp	SHORT $LN20@operator@7
$LN1@operator@7:

; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR _RHS$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ; BaseVector<TradeConnectionPlot,0>::Copy

; 628  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::operator=
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T241962 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+332], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T241962[ebp], ecx
	cmp	DWORD PTR $T241962[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T241962[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T241962[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionPlot@@@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::push_back
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T242016 = -20						; size = 4
_pRet$242013 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 168			; 000000a8H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242016[ebp], edx
	cmp	DWORD PTR $T242016[ebp], 168		; 000000a8H
	jbe	SHORT $LN7@FStaticVec@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T242016[ebp]
	imul	eax, 444				; 000001bcH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$242013[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T242016[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@4
$LN7@FStaticVec@4:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$242013[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 168			; 000000a8H
$LN8@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$242013[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
__ehhandler$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnection,168,0,297,0>::FStaticVector<TradeConnection,168,0,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
__ehhandler$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnection,168,0,297,0>::~FStaticVector<TradeConnection,168,0,297,0>
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
_TEXT	SEGMENT
tv157 = -84						; size = 4
tv149 = -80						; size = 4
_this$ = -76						; size = 4
$T242090 = -20						; size = 4
$T242089 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+74604], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN43@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN43@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T242090[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T242090[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	eax, DWORD PTR _element$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242090[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@3:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T242089[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 681  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv157[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T242090[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@QAEIABUTradeConnection@@@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::push_back
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T242221 = -28						; size = 4
$T242220 = -24						; size = 4
$T242207 = -20						; size = 4
_i$242216 = -4						; size = 4
?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ PROC	; BaseVector<TradeConnection,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242221[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242220[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@clear
	mov	DWORD PTR _i$242216[ebp], 0
	jmp	SHORT $LN5@clear
$LN4@clear:
	mov	edx, DWORD PTR _i$242216[ebp]
	add	edx, 1
	mov	DWORD PTR _i$242216[ebp], edx
$LN5@clear:
	mov	eax, DWORD PTR _i$242216[ebp]
	cmp	eax, DWORD PTR $T242221[ebp]
	jae	SHORT $LN7@clear
	mov	ecx, DWORD PTR _i$242216[ebp]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR $T242220[ebp]
	mov	DWORD PTR $T242207[ebp], ecx
	mov	ecx, DWORD PTR $T242207[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN10@clear
	mov	eax, DWORD PTR $T242207[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@clear:
	jmp	SHORT $LN4@clear
$LN7@clear:

; 122  : 		m_uiCurrSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$BaseVector@UTradeConnection@@$0A@@@QAEXXZ ENDP	; BaseVector<TradeConnection,0>::clear
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T242234 = -20						; size = 4
_pRet$242231 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::FStaticVector<TradeConnectionWasPlundered,10,0,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242234[ebp], edx
	cmp	DWORD PTR $T242234[ebp], 10		; 0000000aH
	jbe	SHORT $LN7@FStaticVec@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T242234[ebp]
	imul	eax, 448				; 000001c0H
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$242231[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T242234[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@5
$LN7@FStaticVec@5:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$242231[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 10			; 0000000aH
$LN8@FStaticVec@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$242231[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>
__ehhandler$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>
__ehhandler$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::~FStaticVector<TradeConnectionWasPlundered,10,0,297,0>
PUBLIC	?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z$0
__ehfuncinfo$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
_TEXT	SEGMENT
tv157 = -80						; size = 4
tv149 = -76						; size = 4
_this$ = -72						; size = 4
$T242318 = -20						; size = 4
$T242317 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4492], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN34@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN34@push_back@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T242318[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T242318[ebp], 0
	je	SHORT $LN4@push_back@4
	mov	eax, DWORD PTR _element$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242318[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR $T242318[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	mov	ecx, DWORD PTR $T242318[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	jmp	SHORT $LN5@push_back@4
$LN4@push_back@4:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@4:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T242317[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv157[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR $T242318[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@QAEIABUTradeConnectionWasPlundered@@@Z ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::push_back
; Function compile flags: /Odtp
;	COMDAT ?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T242441 = -28						; size = 4
$T242440 = -24						; size = 4
$T242425 = -20						; size = 4
_i$242436 = -4						; size = 4
?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ PROC ; BaseVector<TradeConnectionWasPlundered,0>::clear, COMDAT
; _this$ = ecx

; 120  : 	void clear(){

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242441[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T242440[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@clear@2
	mov	DWORD PTR _i$242436[ebp], 0
	jmp	SHORT $LN5@clear@2
$LN4@clear@2:
	mov	edx, DWORD PTR _i$242436[ebp]
	add	edx, 1
	mov	DWORD PTR _i$242436[ebp], edx
$LN5@clear@2:
	mov	eax, DWORD PTR _i$242436[ebp]
	cmp	eax, DWORD PTR $T242441[ebp]
	jae	SHORT $LN7@clear@2
	mov	ecx, DWORD PTR _i$242436[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR $T242440[ebp]
	mov	DWORD PTR $T242425[ebp], ecx
	mov	ecx, DWORD PTR $T242425[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN10@clear@2
	mov	eax, DWORD PTR $T242425[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@clear@2:
	jmp	SHORT $LN4@clear@2
$LN7@clear@2:

; 122  : 		m_uiCurrSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAEXXZ ENDP ; BaseVector<TradeConnectionWasPlundered,0>::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$242449 = -8					; size = 4
$T242444 = -4						; size = 4
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T242444[ebp], ecx
	cmp	DWORD PTR $T242444[ebp], 0
	je	SHORT $LN1@auto_ptr
	mov	edx, DWORD PTR $T242444[ebp]
	mov	DWORD PTR _inst$242449[ebp], edx
	mov	eax, DWORD PTR _inst$242449[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$242449[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T242481 = -30						; size = 1
$T242468 = -29						; size = 1
$T242464 = -28						; size = 4
$T242457 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T242481[ebp]
	mov	DWORD PTR $T242457[ebp], eax
	lea	ecx, DWORD PTR $T242468[ebp]
	mov	DWORD PTR $T242464[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -208						; size = 4
tv148 = -204						; size = 4
tv172 = -200						; size = 4
_this$ = -196						; size = 4
$T242643 = -164						; size = 4
$T242642 = -160						; size = 4
$T242641 = -156						; size = 4
$T242631 = -152						; size = 4
$T242630 = -148						; size = 4
__Cat$242639 = -143					; size = 1
$T242637 = -142						; size = 1
$T242636 = -141						; size = 1
$T242610 = -140						; size = 4
$T242601 = -136						; size = 4
$T242570 = -48						; size = 4
$T242566 = -42						; size = 1
$T242553 = -41						; size = 1
$T242549 = -40						; size = 4
$T242542 = -32						; size = 4
$T242533 = -28						; size = 4
$T242532 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T242566[ebp]
	mov	DWORD PTR $T242542[ebp], eax
	lea	ecx, DWORD PTR $T242553[ebp]
	mov	DWORD PTR $T242549[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T242570[ebp], eax
	mov	ecx, DWORD PTR $T242570[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN3@vector@3

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242601[ebp], ecx
	mov	edx, DWORD PTR $T242601[ebp]
	mov	DWORD PTR $T242532[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242610[ebp], ecx
	mov	edx, DWORD PTR $T242610[ebp]
	mov	DWORD PTR $T242533[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T242643[ebp], ecx
	mov	edx, DWORD PTR $T242532[ebp]
	mov	DWORD PTR $T242642[ebp], edx
	mov	eax, DWORD PTR $T242533[ebp]
	mov	DWORD PTR $T242641[ebp], eax
	mov	ecx, DWORD PTR $T242643[ebp]
	mov	DWORD PTR $T242631[ebp], ecx
	mov	edx, DWORD PTR $T242641[ebp]
	mov	DWORD PTR $T242630[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242636[ebp], al
	mov	cl, BYTE PTR __Cat$242639[ebp]
	mov	BYTE PTR $T242637[ebp], cl
	movzx	edx, BYTE PTR $T242636[ebp]
	push	edx
	movzx	eax, BYTE PTR $T242637[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242631[ebp]
	push	edx
	mov	eax, DWORD PTR $T242642[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242630[ebp]
	push	ecx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN5@vector@3
__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@3
	ret	0
$LN5@vector@3:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@3:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::~vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
PUBLIC	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T242836 = -64						; size = 4
$T242826 = -60						; size = 4
$T242814 = -56						; size = 4
$T242804 = -49						; size = 1
$T242803 = -48						; size = 4
__Cat$242822 = -19					; size = 1
$T242819 = -18						; size = 1
$T242818 = -17						; size = 1
$T242755 = -16						; size = 4
$T242751 = -12						; size = 4
$T242750 = -8						; size = 4
$T242749 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T242755[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@5
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@5
$LN9@push_back@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@5:
	mov	ecx, DWORD PTR $T242755[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T242826[ebp], eax
	mov	ecx, DWORD PTR $T242826[ebp]
	mov	DWORD PTR $T242814[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T242818[ebp], dl
	mov	al, BYTE PTR __Cat$242822[ebp]
	mov	BYTE PTR $T242819[ebp], al
	mov	cl, BYTE PTR $T242818[ebp]
	mov	BYTE PTR $T242804[ebp], cl
	mov	edx, DWORD PTR $T242814[ebp]
	mov	DWORD PTR $T242803[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T242803[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T242826[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@5
$LN2@push_back@5:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242836[ebp], edx
	mov	eax, DWORD PTR $T242836[ebp]
	mov	DWORD PTR $T242750[ebp], eax
	mov	ecx, DWORD PTR $T242750[ebp]
	mov	DWORD PTR $T242749[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242749[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242751[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
$LN3@push_back@5:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T242933 = -30						; size = 1
$T242920 = -29						; size = 1
$T242916 = -28						; size = 4
$T242909 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T242933[ebp]
	mov	DWORD PTR $T242909[ebp], eax
	lea	ecx, DWORD PTR $T242920[ebp]
	mov	DWORD PTR $T242916[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::vector<TRSortElement,std::allocator<TRSortElement> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::~vector<TRSortElement,std::allocator<TRSortElement> >
PUBLIC	?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert
PUBLIC	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T243184 = -32						; size = 4
$T243174 = -28						; size = 4
$T243164 = -24						; size = 4
__Cat$243171 = -19					; size = 1
$T243169 = -18						; size = 1
$T243168 = -17						; size = 1
$T243141 = -16						; size = 4
$T243137 = -12						; size = 4
$T243136 = -8						; size = 4
$T243135 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR $T243141[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back@6
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@6
$LN9@push_back@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@6:
	mov	edx, DWORD PTR $T243141[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243174[ebp], ecx
	mov	edx, DWORD PTR $T243174[ebp]
	mov	DWORD PTR $T243164[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T243168[ebp], al
	mov	cl, BYTE PTR __Cat$243171[ebp]
	mov	BYTE PTR $T243169[ebp], cl
	movzx	edx, BYTE PTR $T243168[ebp]
	push	edx
	movzx	eax, BYTE PTR $T243169[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T243164[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR $T243174[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@6
$LN2@push_back@6:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243184[ebp], ecx
	mov	edx, DWORD PTR $T243184[ebp]
	mov	DWORD PTR $T243136[ebp], edx
	mov	eax, DWORD PTR $T243136[ebp]
	mov	DWORD PTR $T243135[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243135[ebp]
	push	edx
	lea	eax, DWORD PTR $T243137[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert
$LN3@push_back@6:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAEXABUTRSortElement@@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::~_Vector_val<TRSortElement,std::allocator<TRSortElement> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<TRSortElement,std::allocator<TRSortElement> >::~_Vector_val<TRSortElement,std::allocator<TRSortElement> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$243322 = -24					; size = 4
$T243305 = -20						; size = 4
$T243286 = -16						; size = 4
$T243273 = -12						; size = 4
$T243270 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243286[ebp], eax
	mov	ecx, DWORD PTR $T243286[ebp]
	mov	DWORD PTR $T243270[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T243270[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243305[ebp], eax
	mov	ecx, DWORD PTR $T243305[ebp]
	mov	DWORD PTR $T243273[ebp], ecx
	mov	edx, DWORD PTR $T243273[ebp]
	mov	DWORD PTR __Tmp$243322[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Tmp$243322[ebp]
	mov	DWORD PTR __Tmp$243322[ebp], eax
	mov	ecx, DWORD PTR __Tmp$243322[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@ABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::insert
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
PUBLIC	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$243342 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$243342[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$243342[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$243342[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T243474 = -36						; size = 4
$T243473 = -32						; size = 4
$T243469 = -28						; size = 4
$T243468 = -24						; size = 4
$T243445 = -20						; size = 4
$T243444 = -16						; size = 4
$T243423 = -12						; size = 4
$T243422 = -8						; size = 4
__Cat$243451 = -2					; size = 1
$T243449 = -1						; size = 1
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243469[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243468[ebp], ecx
	mov	edx, DWORD PTR $T243469[ebp]
	mov	DWORD PTR $T243445[ebp], edx
	mov	eax, DWORD PTR $T243468[ebp]
	mov	DWORD PTR $T243444[ebp], eax
	mov	cl, BYTE PTR __Cat$243451[ebp]
	mov	BYTE PTR $T243449[ebp], cl
	mov	edx, DWORD PTR $T243445[ebp]
	mov	DWORD PTR $T243423[ebp], edx
	mov	eax, DWORD PTR $T243444[ebp]
	mov	DWORD PTR $T243422[ebp], eax
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	ecx, DWORD PTR $T243422[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T243422[ebp], ecx
$LN12@Tidy:
	mov	edx, DWORD PTR $T243422[ebp]
	cmp	edx, DWORD PTR $T243423[ebp]
	je	SHORT $LN4@Tidy
	mov	ecx, DWORD PTR $T243422[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy
	mov	ecx, DWORD PTR $T243422[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy:
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T243474[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243473[ebp], eax
	mov	ecx, DWORD PTR $T243473[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T243511 = -36						; size = 4
$T243510 = -32						; size = 4
_i$243503 = -28						; size = 4
$T243486 = -24						; size = 4
_pRet$243483 = -20					; size = 4
$T243477 = -16						; size = 4
_i$223074 = -12						; size = 4
_uiNewSize$223066 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223066[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223066[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223066[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243486[ebp], ecx
	cmp	DWORD PTR $T243486[ebp], 40		; 00000028H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T243486[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$243483[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T243486[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$243483[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 40			; 00000028H
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$243483[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	xor	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223074[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$223074[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223074[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223074[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223074[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T243477[ebp], ecx
	cmp	DWORD PTR $T243477[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$223074[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T243477[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T243477[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243511[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T243510[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$243503[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	eax, DWORD PTR _i$243503[ebp]
	add	eax, 1
	mov	DWORD PTR _i$243503[ebp], eax
$LN26@GrowSize:
	mov	ecx, DWORD PTR _i$243503[ebp]
	cmp	ecx, DWORD PTR $T243511[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T243510[ebp], edx
	je	SHORT $LN22@GrowSize
	mov	eax, DWORD PTR $T243510[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+332], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$243519 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z PROC ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Free
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@Free
	mov	DWORD PTR _i$243519[ebp], 0
	jmp	SHORT $LN7@Free
$LN6@Free:
	mov	edx, DWORD PTR _i$243519[ebp]
	add	edx, 1
	mov	DWORD PTR _i$243519[ebp], edx
$LN7@Free:
	mov	eax, DWORD PTR _i$243519[ebp]
	cmp	eax, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN2@Free
	jmp	SHORT $LN6@Free
$LN2@Free:

; 811  : 		if( pVal != (T*)m_aData )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR _pVal$[ebp], ecx
	je	SHORT $LN3@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	mov	edx, DWORD PTR _pVal$[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@Free:

; 813  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Free@?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionPlot@@I@Z ENDP ; FStaticVector<TradeConnectionPlot,40,0,297,0>::Free
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UTradeConnectionPlot@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnectionPlot,0>::~BaseVector<TradeConnectionPlot,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
tv84 = -16						; size = 4
_this$ = -12						; size = 4
$T243527 = -8						; size = 4
_i$223114 = -4						; size = 4
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z PROC ; BaseVector<TradeConnectionPlot,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 231  : 		if( bPODType ){

	xor	eax, eax
	je	SHORT $LN5@Copy

; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _RHS$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{

	jmp	SHORT $LN6@Copy
$LN5@Copy:

; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	mov	DWORD PTR _i$223114[ebp], 0
	jmp	SHORT $LN3@Copy
$LN2@Copy:
	mov	ecx, DWORD PTR _i$223114[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$223114[ebp], ecx
$LN3@Copy:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$223114[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@Copy

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$223114[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T243527[ebp], ecx
	cmp	DWORD PTR $T243527[ebp], 0
	je	SHORT $LN8@Copy
	mov	edx, DWORD PTR _RHS$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$223114[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T243527[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T243527[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN9@Copy
$LN8@Copy:
	mov	DWORD PTR tv84[ebp], 0
$LN9@Copy:

; 236  : 			}

	jmp	SHORT $LN2@Copy
$LN6@Copy:

; 237  : 		}
; 238  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@?$BaseVector@UTradeConnectionPlot@@$0A@@@IAEXABV1@@Z ENDP ; BaseVector<TradeConnectionPlot,0>::Copy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -76						; size = 4
_this$ = -72						; size = 4
$T243546 = -40						; size = 4
_pRet$243543 = -36					; size = 4
$T243536 = -32						; size = 4
$T243535 = -28						; size = 4
_i$223135 = -24						; size = 4
_uiNewSize$223127 = -20					; size = 4
_pTemp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223127[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223127[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223127[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243546[ebp], ecx
	cmp	DWORD PTR $T243546[ebp], 168		; 000000a8H
	jbe	SHORT $LN16@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T243546[ebp]
	imul	edx, 444				; 000001bcH
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$243543[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T243546[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@2
$LN16@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$243543[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 168			; 000000a8H
$LN17@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$243543[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	xor	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 444				; 000001bcH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223135[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$223135[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223135[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223135[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223135[ebp]
	imul	edx, 444				; 000001bcH
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T243536[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T243536[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	eax, DWORD PTR _i$223135[ebp]
	imul	eax, 444				; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR $T243536[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@2:
	mov	edx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T243535[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ; FStaticVector<TradeConnection,168,0,297,0>::Free

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+74604], 1

; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$223135[ebp]
	imul	eax, 444				; 000001bcH
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243536[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T243662 = -20						; size = 4
_i$243666 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z PROC ; FStaticVector<TradeConnection,168,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Free@2
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@Free@2
	mov	DWORD PTR _i$243666[ebp], 0
	jmp	SHORT $LN7@Free@2
$LN6@Free@2:
	mov	edx, DWORD PTR _i$243666[ebp]
	add	edx, 1
	mov	DWORD PTR _i$243666[ebp], edx
$LN7@Free@2:
	mov	eax, DWORD PTR _i$243666[ebp]
	cmp	eax, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN2@Free@2
	mov	ecx, DWORD PTR _i$243666[ebp]
	imul	ecx, 444				; 000001bcH
	add	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR $T243662[ebp], ecx
	mov	ecx, DWORD PTR $T243662[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN12@Free@2
	mov	eax, DWORD PTR $T243662[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Free@2:
	jmp	SHORT $LN6@Free@2
$LN2@Free@2:

; 811  : 		if( pVal != (T*)m_aData )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR _pVal$[ebp], ecx
	je	SHORT $LN3@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	mov	edx, DWORD PTR _pVal$[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@Free@2:

; 813  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Free@?$FStaticVector@UTradeConnection@@$0KI@$0A@$0BCJ@$0A@@@IAEXPAUTradeConnection@@I@Z ENDP ; FStaticVector<TradeConnection,168,0,297,0>::Free
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ PROC	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UTradeConnection@@$0A@@@QAE@XZ ENDP	; BaseVector<TradeConnection,0>::~BaseVector<TradeConnection,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T243716 = -20						; size = 4
_i$223167 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z PROC ; BaseVector<TradeConnection,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Destroy

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$223167[ebp], 0
	jmp	SHORT $LN3@Destroy
$LN2@Destroy:
	mov	ecx, DWORD PTR _i$223167[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$223167[ebp], ecx
$LN3@Destroy:
	mov	edx, DWORD PTR _i$223167[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy

; 223  : 				pVal[i].~T();

	mov	eax, DWORD PTR _i$223167[ebp]
	imul	eax, 444				; 000001bcH
	add	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR $T243716[ebp], eax
	mov	ecx, DWORD PTR $T243716[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN8@Destroy
	mov	edx, DWORD PTR $T243716[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@Destroy:

; 224  : 			}

	jmp	SHORT $LN2@Destroy
$LN5@Destroy:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@UTradeConnection@@$0A@@@IAEXPAUTradeConnection@@I@Z ENDP ; BaseVector<TradeConnection,0>::Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z$0
__ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -72						; size = 4
_this$ = -68						; size = 4
$T243745 = -44						; size = 4
$T243730 = -40						; size = 4
_pRet$243727 = -36					; size = 4
$T243720 = -32						; size = 4
$T243719 = -28						; size = 4
_i$223185 = -24						; size = 4
_uiNewSize$223177 = -20					; size = 4
_pTemp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@3

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223177[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223177[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@3

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@3
$LN6@GrowSize@3:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223177[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@3
$LN7@GrowSize@3:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243730[ebp], ecx
	cmp	DWORD PTR $T243730[ebp], 10		; 0000000aH
	jbe	SHORT $LN16@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T243730[ebp]
	imul	edx, 448				; 000001c0H
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$243727[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T243730[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$243727[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH
$LN17@GrowSize@3:
	mov	ecx, DWORD PTR _pRet$243727[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	xor	edx, edx
	je	SHORT $LN5@GrowSize@3

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 448				; 000001c0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	$LN4@GrowSize@3
$LN5@GrowSize@3:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223185[ebp], 0
	jmp	SHORT $LN3@GrowSize@3
$LN2@GrowSize@3:
	mov	edx, DWORD PTR _i$223185[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223185[ebp], edx
$LN3@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223185[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@3

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223185[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T243720[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T243720[ebp], 0
	je	SHORT $LN12@GrowSize@3
	mov	eax, DWORD PTR _i$223185[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T243745[ebp], eax
	mov	edx, DWORD PTR $T243745[ebp]
	push	edx
	mov	ecx, DWORD PTR $T243720[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR $T243720[ebp]
	mov	ecx, DWORD PTR $T243745[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	mov	eax, DWORD PTR $T243720[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@3
$LN12@GrowSize@3:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@3:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T243719[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	jmp	SHORT $LN2@GrowSize@3
$LN4@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4492], 1

; 772  : 	};

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z$0:
	mov	eax, DWORD PTR _i$223185[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243720[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrowSize@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T243862 = -20						; size = 4
_i$243873 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z PROC ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Free@3
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@Free@3
	mov	DWORD PTR _i$243873[ebp], 0
	jmp	SHORT $LN7@Free@3
$LN6@Free@3:
	mov	edx, DWORD PTR _i$243873[ebp]
	add	edx, 1
	mov	DWORD PTR _i$243873[ebp], edx
$LN7@Free@3:
	mov	eax, DWORD PTR _i$243873[ebp]
	cmp	eax, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN2@Free@3
	mov	ecx, DWORD PTR _i$243873[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR $T243862[ebp], ecx
	mov	ecx, DWORD PTR $T243862[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN12@Free@3
	mov	eax, DWORD PTR $T243862[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Free@3:
	jmp	SHORT $LN6@Free@3
$LN2@Free@3:

; 811  : 		if( pVal != (T*)m_aData )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR _pVal$[ebp], ecx
	je	SHORT $LN3@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	mov	edx, DWORD PTR _pVal$[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@Free@3:

; 813  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Free@?$FStaticVector@UTradeConnectionWasPlundered@@$09$0A@$0BCJ@$0A@@@IAEXPAUTradeConnectionWasPlundered@@I@Z ENDP ; FStaticVector<TradeConnectionWasPlundered,10,0,297,0>::Free
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ PROC ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UTradeConnectionWasPlundered@@$0A@@@QAE@XZ ENDP ; BaseVector<TradeConnectionWasPlundered,0>::~BaseVector<TradeConnectionWasPlundered,0>
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$243938 = -24					; size = 4
$T243916 = -20						; size = 4
$T243897 = -16						; size = 4
$T243884 = -12						; size = 4
$T243881 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243897[ebp], ecx
	mov	edx, DWORD PTR $T243897[ebp]
	mov	DWORD PTR $T243881[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T243881[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243916[ebp], edx
	mov	eax, DWORD PTR $T243916[ebp]
	mov	DWORD PTR $T243884[ebp], eax
	mov	ecx, DWORD PTR $T243884[ebp]
	mov	DWORD PTR __Tmp$243938[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$243938[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$243938[ebp], ecx
	mov	edx, DWORD PTR __Tmp$243938[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
PUBLIC	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$243956 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$243956[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$243956[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$243956[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T244019 = -28						; size = 4
$T244018 = -24						; size = 4
$T244014 = -20						; size = 4
$T244013 = -16						; size = 4
$T244002 = -12						; size = 4
$T244001 = -8						; size = 4
__Cat$244009 = -2					; size = 1
$T244006 = -1						; size = 1
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244014[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244013[ebp], ecx
	mov	edx, DWORD PTR $T244014[ebp]
	mov	DWORD PTR $T244002[ebp], edx
	mov	eax, DWORD PTR $T244013[ebp]
	mov	DWORD PTR $T244001[ebp], eax
	mov	cl, BYTE PTR __Cat$244009[ebp]
	mov	BYTE PTR $T244006[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T244019[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244018[ebp], eax
	mov	ecx, DWORD PTR $T244018[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$244074 = -24					; size = 4
$T244057 = -20						; size = 4
$T244038 = -16						; size = 4
$T244025 = -12						; size = 4
$T244022 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244038[ebp], eax
	mov	ecx, DWORD PTR $T244038[ebp]
	mov	DWORD PTR $T244022[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T244022[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244057[ebp], eax
	mov	ecx, DWORD PTR $T244057[ebp]
	mov	DWORD PTR $T244025[ebp], ecx
	mov	edx, DWORD PTR $T244025[ebp]
	mov	DWORD PTR __Tmp$244074[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Tmp$244074[ebp]
	mov	DWORD PTR __Tmp$244074[ebp], eax
	mov	ecx, DWORD PTR __Tmp$244074[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@ABUTRSortElement@@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::insert
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ; stdext::unchecked_copy<TRSortElement *,TRSortElement *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T244289 = -72						; size = 4
$T244264 = -68						; size = 4
$T244263 = -64						; size = 4
$T244240 = -60						; size = 4
$T244239 = -56						; size = 4
__Cat$244271 = -40					; size = 1
$T244268 = -39						; size = 1
__Ptr$223288 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ; stdext::unchecked_copy<TRSortElement *,TRSortElement *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$223288[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244289[ebp], edx
	mov	eax, DWORD PTR $T244289[ebp]
	mov	DWORD PTR $T244264[ebp], eax
	mov	ecx, DWORD PTR __Ptr$223288[ebp]
	mov	DWORD PTR $T244263[ebp], ecx
	mov	dl, BYTE PTR __Cat$244271[ebp]
	mov	BYTE PTR $T244268[ebp], dl
	mov	eax, DWORD PTR $T244264[ebp]
	mov	DWORD PTR $T244240[ebp], eax
	mov	ecx, DWORD PTR $T244263[ebp]
	mov	DWORD PTR $T244239[ebp], ecx
	jmp	SHORT $LN49@erase
$LN48@erase:
	mov	edx, DWORD PTR $T244239[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR $T244239[ebp], edx
$LN49@erase:
	mov	eax, DWORD PTR $T244239[ebp]
	cmp	eax, DWORD PTR $T244240[ebp]
	je	SHORT $LN41@erase
	mov	ecx, DWORD PTR $T244239[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN52@erase
	mov	edx, DWORD PTR $T244239[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@erase:
	jmp	SHORT $LN48@erase
$LN41@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$223288[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@QAE?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@V?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ; std::_Allocate<TRSortElement>
PUBLIC	?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$244304 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$244304[ebp], 9586980	; 00924924H
	cmp	DWORD PTR __Count$244304[ebp], 0
	jbe	SHORT $LN11@Buy@3
	mov	eax, DWORD PTR __Count$244304[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@3
$LN11@Buy@3:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@3:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ; std::_Allocate<TRSortElement>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T244481 = -48						; size = 4
$T244480 = -44						; size = 4
$T244476 = -40						; size = 4
$T244475 = -36						; size = 4
$T244450 = -32						; size = 4
$T244449 = -28						; size = 4
$T244426 = -24						; size = 4
$T244425 = -20						; size = 4
__Cat$244456 = -2					; size = 1
$T244454 = -1						; size = 1
?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244476[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244475[ebp], ecx
	mov	edx, DWORD PTR $T244476[ebp]
	mov	DWORD PTR $T244450[ebp], edx
	mov	eax, DWORD PTR $T244475[ebp]
	mov	DWORD PTR $T244449[ebp], eax
	mov	cl, BYTE PTR __Cat$244456[ebp]
	mov	BYTE PTR $T244454[ebp], cl
	mov	edx, DWORD PTR $T244450[ebp]
	mov	DWORD PTR $T244426[ebp], edx
	mov	eax, DWORD PTR $T244449[ebp]
	mov	DWORD PTR $T244425[ebp], eax
	jmp	SHORT $LN12@Tidy@3
$LN11@Tidy@3:
	mov	ecx, DWORD PTR $T244425[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T244425[ebp], ecx
$LN12@Tidy@3:
	mov	edx, DWORD PTR $T244425[ebp]
	cmp	edx, DWORD PTR $T244426[ebp]
	je	SHORT $LN4@Tidy@3
	mov	ecx, DWORD PTR $T244425[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy@3
	mov	ecx, DWORD PTR $T244425[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy@3:
	jmp	SHORT $LN11@Tidy@3
$LN4@Tidy@3:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR $T244481[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244480[ebp], eax
	mov	ecx, DWORD PTR $T244480[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
PUBLIC	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$16 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$15 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$15
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$16
__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
_TEXT	SEGMENT
tv84 = -460						; size = 4
tv312 = -456						; size = 4
tv298 = -452						; size = 4
tv290 = -448						; size = 4
_this$ = -444						; size = 4
$T245280 = -440						; size = 4
$T245217 = -400						; size = 4
$T245198 = -396						; size = 4
$T245181 = -389						; size = 1
$T245180 = -388						; size = 4
$T245170 = -384						; size = 4
$T245169 = -380						; size = 4
__Cat$245212 = -374					; size = 1
$T245210 = -373						; size = 1
$T245209 = -372						; size = 1
__Cat$245205 = -371					; size = 1
$T245202 = -370						; size = 1
$T245201 = -369						; size = 1
$T245137 = -368						; size = 4
$T245127 = -364						; size = 4
$T245114 = -360						; size = 4
$T245091 = -356						; size = 4
$T245090 = -352						; size = 4
$T245069 = -348						; size = 4
$T245068 = -344						; size = 4
__Cat$245098 = -338					; size = 1
$T245095 = -337						; size = 1
$T245017 = -336						; size = 4
$T245016 = -332						; size = 4
$T245006 = -328						; size = 4
__Cat$245013 = -323					; size = 1
$T245010 = -322						; size = 1
$T245009 = -321						; size = 1
$T244990 = -320						; size = 4
$T244978 = -316						; size = 4
$T244968 = -309						; size = 1
$T244967 = -308						; size = 4
__Cat$244985 = -303					; size = 1
$T244982 = -302						; size = 1
$T244981 = -301						; size = 1
$T244951 = -300						; size = 4
$T244950 = -296						; size = 4
$T244946 = -292						; size = 4
$T244945 = -288						; size = 4
$T244922 = -284						; size = 4
$T244921 = -280						; size = 4
$T244900 = -276						; size = 4
$T244899 = -272						; size = 4
__Cat$244929 = -266					; size = 1
$T244926 = -265						; size = 1
$T244820 = -264						; size = 4
$T244819 = -260						; size = 4
$T244798 = -256						; size = 4
$T244797 = -252						; size = 4
__Cat$244826 = -246					; size = 1
$T244823 = -245						; size = 1
$T244724 = -244						; size = 4
$T244723 = -240						; size = 4
$T244702 = -236						; size = 4
$T244701 = -232						; size = 4
__Cat$244731 = -226					; size = 1
$T244729 = -225						; size = 1
$T244650 = -224						; size = 4
$T244638 = -220						; size = 4
$T244628 = -213						; size = 1
$T244627 = -212						; size = 4
__Cat$244646 = -207					; size = 1
$T244644 = -206						; size = 1
$T244643 = -205						; size = 1
$T244615 = -204						; size = 4
$T244603 = -200						; size = 4
$T244593 = -193						; size = 1
$T244592 = -192						; size = 4
__Cat$244611 = -187					; size = 1
$T244609 = -186						; size = 1
$T244608 = -185						; size = 1
$T244580 = -184						; size = 4
$T244570 = -180						; size = 4
__Cat$244578 = -175					; size = 1
$T244576 = -174						; size = 1
$T244575 = -173						; size = 1
__Count$244542 = -172					; size = 4
__Count$244516 = -100					; size = 4
__Tmp$223383 = -96					; size = 28
__Oldend$223384 = -68					; size = 4
__Tmp$223373 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
__Ncopied$223360 = -32					; size = 4
__Newvec$223358 = -28					; size = 4
__Whereoff$223359 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 444				; 000001bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n
$LN31@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n:
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$244516[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$244516[ebp], 0
	jbe	SHORT $LN37@Insert_n
	mov	eax, DWORD PTR __Count$244516[ebp]
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN39@Insert_n
$LN37@Insert_n:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR tv298[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$244542[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$244542[ebp], 0
	jbe	SHORT $LN50@Insert_n
	mov	edx, DWORD PTR __Count$244542[ebp]
	mov	DWORD PTR tv312[ebp], edx
	jmp	SHORT $LN46@Insert_n
$LN50@Insert_n:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv312[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN56@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8
	mov	DWORD PTR __Newvec$223358[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$223359[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$223360[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$223359[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$223358[ebp]
	mov	DWORD PTR $T244580[ebp], edx
	mov	eax, DWORD PTR $T244580[ebp]
	mov	DWORD PTR $T244570[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244575[ebp], cl
	mov	dl, BYTE PTR __Cat$244578[ebp]
	mov	BYTE PTR $T244576[ebp], dl
	movzx	eax, BYTE PTR $T244575[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T244576[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244570[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$223360[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$223360[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244615[ebp], edx
	mov	eax, DWORD PTR __Newvec$223358[ebp]
	mov	DWORD PTR $T244603[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244608[ebp], cl
	mov	dl, BYTE PTR __Cat$244611[ebp]
	mov	BYTE PTR $T244609[ebp], dl
	mov	al, BYTE PTR $T244608[ebp]
	mov	BYTE PTR $T244593[ebp], al
	mov	ecx, DWORD PTR $T244603[ebp]
	mov	DWORD PTR $T244592[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T244592[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244615[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$223360[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$223360[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244650[ebp], edx
	mov	eax, DWORD PTR __Whereoff$223359[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Newvec$223358[ebp]
	mov	DWORD PTR $T244638[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244643[ebp], cl
	mov	dl, BYTE PTR __Cat$244646[ebp]
	mov	BYTE PTR $T244644[ebp], dl
	mov	al, BYTE PTR $T244643[ebp]
	mov	BYTE PTR $T244628[ebp], al
	mov	ecx, DWORD PTR $T244638[ebp]
	mov	DWORD PTR $T244627[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T244627[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244650[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223360[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$223359[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Newvec$223358[ebp]
	mov	DWORD PTR $T244724[ebp], eax
	mov	ecx, DWORD PTR __Newvec$223358[ebp]
	mov	DWORD PTR $T244723[ebp], ecx
	mov	dl, BYTE PTR __Cat$244731[ebp]
	mov	BYTE PTR $T244729[ebp], dl
	mov	eax, DWORD PTR $T244724[ebp]
	mov	DWORD PTR $T244702[ebp], eax
	mov	ecx, DWORD PTR $T244723[ebp]
	mov	DWORD PTR $T244701[ebp], ecx
	jmp	SHORT $LN88@Insert_n
$LN87@Insert_n:
	mov	edx, DWORD PTR $T244701[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T244701[ebp], edx
$LN88@Insert_n:
	mov	eax, DWORD PTR $T244701[ebp]
	cmp	eax, DWORD PTR $T244702[ebp]
	je	SHORT $LN7@Insert_n
	mov	ecx, DWORD PTR $T244701[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN91@Insert_n
	mov	edx, DWORD PTR $T244701[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Insert_n:
	jmp	SHORT $LN87@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223360[ebp], 0
	jle	$LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR __Whereoff$223359[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Newvec$223358[ebp]
	add	ecx, eax
	mov	DWORD PTR $T244820[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$223359[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$223358[ebp]
	mov	DWORD PTR $T244819[ebp], edx
	mov	al, BYTE PTR __Cat$244826[ebp]
	mov	BYTE PTR $T244823[ebp], al
	mov	ecx, DWORD PTR $T244820[ebp]
	mov	DWORD PTR $T244798[ebp], ecx
	mov	edx, DWORD PTR $T244819[ebp]
	mov	DWORD PTR $T244797[ebp], edx
	jmp	SHORT $LN109@Insert_n
$LN108@Insert_n:
	mov	eax, DWORD PTR $T244797[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T244797[ebp], eax
$LN109@Insert_n:
	mov	ecx, DWORD PTR $T244797[ebp]
	cmp	ecx, DWORD PTR $T244798[ebp]
	je	SHORT $LN6@Insert_n
	mov	ecx, DWORD PTR $T244797[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN112@Insert_n
	mov	eax, DWORD PTR $T244797[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN112@Insert_n:
	jmp	SHORT $LN108@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$223358[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN124@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN124@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244946[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244945[ebp], eax
	mov	ecx, DWORD PTR $T244946[ebp]
	mov	DWORD PTR $T244922[ebp], ecx
	mov	edx, DWORD PTR $T244945[ebp]
	mov	DWORD PTR $T244921[ebp], edx
	mov	al, BYTE PTR __Cat$244929[ebp]
	mov	BYTE PTR $T244926[ebp], al
	mov	ecx, DWORD PTR $T244922[ebp]
	mov	DWORD PTR $T244900[ebp], ecx
	mov	edx, DWORD PTR $T244921[ebp]
	mov	DWORD PTR $T244899[ebp], edx
	jmp	SHORT $LN134@Insert_n
$LN133@Insert_n:
	mov	eax, DWORD PTR $T244899[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T244899[ebp], eax
$LN134@Insert_n:
	mov	ecx, DWORD PTR $T244899[ebp]
	cmp	ecx, DWORD PTR $T244900[ebp]
	je	SHORT $LN126@Insert_n
	mov	ecx, DWORD PTR $T244899[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN137@Insert_n
	mov	eax, DWORD PTR $T244899[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN137@Insert_n:
	jmp	SHORT $LN133@Insert_n
$LN126@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T244951[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244950[ebp], eax
	mov	ecx, DWORD PTR $T244950[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Newvec$223358[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Newvec$223358[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$223358[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$223373[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244990[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244978[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T244981[ebp], al
	mov	cl, BYTE PTR __Cat$244985[ebp]
	mov	BYTE PTR $T244982[ebp], cl
	mov	dl, BYTE PTR $T244981[ebp]
	mov	BYTE PTR $T244968[ebp], dl
	mov	eax, DWORD PTR $T244978[ebp]
	mov	DWORD PTR $T244967[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244967[ebp]
	push	edx
	mov	eax, DWORD PTR $T244990[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 16					; 00000010H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T245017[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245016[ebp], ecx
	mov	edx, DWORD PTR $T245016[ebp]
	mov	DWORD PTR $T245006[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245009[ebp], al
	mov	cl, BYTE PTR __Cat$245013[ebp]
	mov	BYTE PTR $T245010[ebp], cl
	movzx	edx, BYTE PTR $T245009[ebp]
	push	edx
	movzx	eax, BYTE PTR $T245010[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$223373[ebp]
	push	edx
	mov	eax, DWORD PTR $T245017[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245006[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245114[ebp], edx
	mov	ecx, DWORD PTR $T245114[ebp]
	mov	DWORD PTR $T245091[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245090[ebp], edx
	mov	al, BYTE PTR __Cat$245098[ebp]
	mov	BYTE PTR $T245095[ebp], al
	mov	ecx, DWORD PTR $T245091[ebp]
	mov	DWORD PTR $T245069[ebp], ecx
	mov	edx, DWORD PTR $T245090[ebp]
	mov	DWORD PTR $T245068[ebp], edx
	jmp	SHORT $LN174@Insert_n
$LN173@Insert_n:
	mov	eax, DWORD PTR $T245068[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T245068[ebp], eax
$LN174@Insert_n:
	mov	ecx, DWORD PTR $T245068[ebp]
	cmp	ecx, DWORD PTR $T245069[ebp]
	je	SHORT $LN166@Insert_n
	mov	ecx, DWORD PTR $T245068[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN177@Insert_n
	mov	eax, DWORD PTR $T245068[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN177@Insert_n:
	jmp	SHORT $LN173@Insert_n
$LN166@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	eax, __tryend$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T245137[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245127[ebp], ecx
	jmp	SHORT $LN191@Insert_n
$LN190@Insert_n:
	mov	edx, DWORD PTR $T245127[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T245127[ebp], edx
$LN191@Insert_n:
	mov	eax, DWORD PTR $T245127[ebp]
	cmp	eax, DWORD PTR $T245137[ebp]
	je	SHORT $LN187@Insert_n
	lea	ecx, DWORD PTR __Tmp$223373[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T245127[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN190@Insert_n
$LN187@Insert_n:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$223373[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$223383[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$223384[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245217[ebp], eax
	mov	ecx, DWORD PTR $T245217[ebp]
	mov	DWORD PTR $T245198[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T245201[ebp], dl
	mov	al, BYTE PTR __Cat$245205[ebp]
	mov	BYTE PTR $T245202[ebp], al
	mov	cl, BYTE PTR $T245201[ebp]
	mov	BYTE PTR $T245181[ebp], cl
	mov	edx, DWORD PTR $T245198[ebp]
	mov	DWORD PTR $T245180[ebp], edx
	mov	eax, DWORD PTR $T245180[ebp]
	mov	DWORD PTR $T245170[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Oldend$223384[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T245169[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245209[ebp], al
	mov	cl, BYTE PTR __Cat$245212[ebp]
	mov	BYTE PTR $T245210[ebp], cl
	movzx	edx, BYTE PTR $T245209[ebp]
	push	edx
	movzx	eax, BYTE PTR $T245210[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245170[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$223384[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245169[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$223384[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Oldend$223384[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245280[ebp], ecx
	jmp	SHORT $LN234@Insert_n
$LN233@Insert_n:
	mov	edx, DWORD PTR $T245280[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T245280[ebp], edx
$LN234@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T245280[ebp], eax
	je	SHORT $LN230@Insert_n
	lea	ecx, DWORD PTR __Tmp$223383[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T245280[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN233@Insert_n
$LN230@Insert_n:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$223383[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@Insert_n:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$223373[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$223383[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-464]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T245308 = -80						; size = 28
$T245307 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T245308[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T245307[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T245307[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T245308[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245307[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T245307[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T245307[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T245308[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T245308[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T245307[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
PUBLIC	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
PUBLIC	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T245912 = -412						; size = 4
$T245860 = -368						; size = 4
$T245848 = -364						; size = 4
$T245838 = -357						; size = 1
$T245837 = -356						; size = 4
__Cat$245855 = -327					; size = 1
$T245852 = -326						; size = 1
$T245851 = -325						; size = 1
$T245809 = -324						; size = 4
$T245801 = -320						; size = 4
$T245793 = -316						; size = 4
$T245782 = -312						; size = 4
$T245781 = -308						; size = 4
__Cat$245788 = -302					; size = 1
$T245785 = -301						; size = 1
$T245710 = -276						; size = 4
$T245691 = -272						; size = 4
$T245674 = -265						; size = 1
$T245673 = -264						; size = 4
$T245663 = -260						; size = 4
$T245662 = -256						; size = 4
__Cat$245708 = -250					; size = 1
$T245706 = -249						; size = 1
$T245705 = -248						; size = 1
__Cat$245699 = -247					; size = 1
$T245697 = -246						; size = 1
$T245696 = -245						; size = 1
$T245638 = -244						; size = 4
$T245637 = -240						; size = 4
$T245633 = -236						; size = 4
$T245632 = -232						; size = 4
$T245621 = -228						; size = 4
$T245620 = -224						; size = 4
__Cat$245627 = -218					; size = 1
$T245625 = -217						; size = 1
$T245585 = -216						; size = 4
$T245584 = -212						; size = 4
__Cat$245591 = -206					; size = 1
$T245589 = -205						; size = 1
$T245555 = -204						; size = 4
$T245554 = -200						; size = 4
__Cat$245561 = -194					; size = 1
$T245559 = -193						; size = 1
$T245535 = -192						; size = 4
$T245523 = -188						; size = 4
$T245513 = -181						; size = 1
$T245512 = -180						; size = 4
__Cat$245530 = -175					; size = 1
$T245528 = -174						; size = 1
$T245527 = -173						; size = 1
$T245500 = -172						; size = 4
$T245488 = -168						; size = 4
$T245478 = -161						; size = 1
$T245477 = -160						; size = 4
__Cat$245495 = -155					; size = 1
$T245493 = -154						; size = 1
$T245492 = -153						; size = 1
$T245465 = -152						; size = 4
$T245453 = -148						; size = 4
$T245443 = -141						; size = 1
$T245442 = -140						; size = 4
__Cat$245461 = -135					; size = 1
$T245459 = -134						; size = 1
$T245458 = -133						; size = 1
__Count$245416 = -120					; size = 4
__Count$245390 = -48					; size = 4
__Tmp$223456 = -44					; size = 4
__Oldend$223457 = -40					; size = 4
__Tmp$223446 = -36					; size = 4
__Ncopied$223433 = -32					; size = 4
__Newvec$223431 = -28					; size = 4
__Whereoff$223432 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$245390[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$245390[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$245390[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$245416[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$245416[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$245416[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8
	mov	DWORD PTR __Newvec$223431[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$223432[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$223433[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$223432[ebp]
	mov	ecx, DWORD PTR __Newvec$223431[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T245465[ebp], edx
	mov	eax, DWORD PTR $T245465[ebp]
	mov	DWORD PTR $T245453[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245458[ebp], cl
	mov	dl, BYTE PTR __Cat$245461[ebp]
	mov	BYTE PTR $T245459[ebp], dl
	mov	al, BYTE PTR $T245458[ebp]
	mov	BYTE PTR $T245443[ebp], al
	mov	ecx, DWORD PTR $T245453[ebp]
	mov	DWORD PTR $T245442[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245442[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$223433[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$223433[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245500[ebp], ecx
	mov	edx, DWORD PTR __Newvec$223431[ebp]
	mov	DWORD PTR $T245488[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245492[ebp], al
	mov	cl, BYTE PTR __Cat$245495[ebp]
	mov	BYTE PTR $T245493[ebp], cl
	mov	dl, BYTE PTR $T245492[ebp]
	mov	BYTE PTR $T245478[ebp], dl
	mov	eax, DWORD PTR $T245488[ebp]
	mov	DWORD PTR $T245477[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245477[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245500[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$223433[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$223433[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245535[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$223432[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$223431[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T245523[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T245527[ebp], dl
	mov	al, BYTE PTR __Cat$245530[ebp]
	mov	BYTE PTR $T245528[ebp], al
	mov	cl, BYTE PTR $T245527[ebp]
	mov	BYTE PTR $T245513[ebp], cl
	mov	edx, DWORD PTR $T245523[ebp]
	mov	DWORD PTR $T245512[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245512[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245535[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223433[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$223432[ebp]
	mov	edx, DWORD PTR __Newvec$223431[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T245555[ebp], eax
	mov	ecx, DWORD PTR __Newvec$223431[ebp]
	mov	DWORD PTR $T245554[ebp], ecx
	mov	dl, BYTE PTR __Cat$245561[ebp]
	mov	BYTE PTR $T245559[ebp], dl
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223433[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$223432[ebp]
	mov	ecx, DWORD PTR __Newvec$223431[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T245585[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$223432[ebp]
	mov	eax, DWORD PTR __Newvec$223431[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T245584[ebp], ecx
	mov	dl, BYTE PTR __Cat$245591[ebp]
	mov	BYTE PTR $T245589[ebp], dl
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$223431[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245633[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245632[ebp], edx
	mov	eax, DWORD PTR $T245633[ebp]
	mov	DWORD PTR $T245621[ebp], eax
	mov	ecx, DWORD PTR $T245632[ebp]
	mov	DWORD PTR $T245620[ebp], ecx
	mov	dl, BYTE PTR __Cat$245627[ebp]
	mov	BYTE PTR $T245625[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T245638[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245637[ebp], ecx
	mov	edx, DWORD PTR $T245637[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$223431[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$223431[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$223431[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$223446[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245710[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T245691[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245696[ebp], cl
	mov	dl, BYTE PTR __Cat$245699[ebp]
	mov	BYTE PTR $T245697[ebp], dl
	mov	al, BYTE PTR $T245696[ebp]
	mov	BYTE PTR $T245674[ebp], al
	mov	ecx, DWORD PTR $T245691[ebp]
	mov	DWORD PTR $T245673[ebp], ecx
	mov	edx, DWORD PTR $T245673[ebp]
	mov	DWORD PTR $T245663[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245662[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245705[ebp], cl
	mov	dl, BYTE PTR __Cat$245708[ebp]
	mov	BYTE PTR $T245706[ebp], dl
	movzx	eax, BYTE PTR $T245705[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T245706[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T245663[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245710[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245662[ebp]
	push	edx
	call	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$223446[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T245793[ebp], eax
	mov	ecx, DWORD PTR $T245793[ebp]
	mov	DWORD PTR $T245782[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T245781[ebp], ecx
	mov	dl, BYTE PTR __Cat$245788[ebp]
	mov	BYTE PTR $T245785[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T245809[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245801[ebp], edx
	jmp	SHORT $LN151@Insert_n@2
$LN150@Insert_n@2:
	mov	eax, DWORD PTR $T245801[ebp]
	add	eax, 4
	mov	DWORD PTR $T245801[ebp], eax
$LN151@Insert_n@2:
	mov	ecx, DWORD PTR $T245801[ebp]
	cmp	ecx, DWORD PTR $T245809[ebp]
	je	SHORT $LN147@Insert_n@2
	mov	edx, DWORD PTR $T245801[ebp]
	mov	eax, DWORD PTR __Tmp$223446[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@2
$LN147@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$223456[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$223457[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245860[ebp], eax
	mov	ecx, DWORD PTR $T245860[ebp]
	mov	DWORD PTR $T245848[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T245851[ebp], dl
	mov	al, BYTE PTR __Cat$245855[ebp]
	mov	BYTE PTR $T245852[ebp], al
	mov	cl, BYTE PTR $T245851[ebp]
	mov	BYTE PTR $T245838[ebp], cl
	mov	edx, DWORD PTR $T245848[ebp]
	mov	DWORD PTR $T245837[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245837[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$223457[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$223457[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$223457[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$223457[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245912[ebp], ecx
	jmp	SHORT $LN186@Insert_n@2
$LN185@Insert_n@2:
	mov	edx, DWORD PTR $T245912[ebp]
	add	edx, 4
	mov	DWORD PTR $T245912[ebp], edx
$LN186@Insert_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T245912[ebp], edx
	je	SHORT $LN16@Insert_n@2
	mov	eax, DWORD PTR $T245912[ebp]
	mov	ecx, DWORD PTR __Tmp$223456[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T245983 = -40						; size = 4
$T245973 = -33						; size = 1
$T245972 = -32						; size = 4
__Cat$245979 = -3					; size = 1
$T245976 = -2						; size = 1
$T245975 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T245983[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245975[ebp], cl
	mov	dl, BYTE PTR __Cat$245979[ebp]
	mov	BYTE PTR $T245976[ebp], dl
	mov	al, BYTE PTR $T245975[ebp]
	mov	BYTE PTR $T245973[ebp], al
	mov	ecx, DWORD PTR $T245983[ebp]
	mov	DWORD PTR $T245972[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245972[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T245987 = -80						; size = 28
$T245986 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T245987[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T245986[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T245986[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T245987[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245986[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T245986[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T245986[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T245987[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T245987[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T245986[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
PUBLIC	??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>
PUBLIC	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
PUBLIC	??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ; std::_Destroy<TRSortElement>
PUBLIC	??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$27 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$2
__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$26
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$27
__unwindtable$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$5
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
_TEXT	SEGMENT
tv84 = -1348						; size = 4
tv312 = -1344						; size = 4
tv298 = -1340						; size = 4
tv290 = -1336						; size = 4
_this$ = -1332						; size = 4
$T246826 = -1316					; size = 4
$T246762 = -1268					; size = 4
$T246743 = -1264					; size = 4
$T246726 = -1257					; size = 1
$T246725 = -1256					; size = 4
$T246715 = -1252					; size = 4
$T246714 = -1248					; size = 4
__Cat$246759 = -1242					; size = 1
$T246757 = -1241					; size = 1
$T246756 = -1240					; size = 1
__Cat$246750 = -1239					; size = 1
$T246748 = -1238					; size = 1
$T246747 = -1237					; size = 1
$T246664 = -1228					; size = 4
$T246654 = -1224					; size = 4
$T246641 = -1220					; size = 4
$T246625 = -1216					; size = 4
$T246624 = -1212					; size = 4
$T246610 = -1208					; size = 4
$T246609 = -1204					; size = 4
__Cat$246631 = -1194					; size = 1
$T246629 = -1193					; size = 1
$T246549 = -1192					; size = 4
$T246548 = -1188					; size = 4
$T246538 = -1184					; size = 4
__Cat$246546 = -1179					; size = 1
$T246544 = -1178					; size = 1
$T246543 = -1177					; size = 1
$T246522 = -1176					; size = 4
$T246510 = -1172					; size = 4
$T246500 = -1165					; size = 1
$T246499 = -1164					; size = 4
__Cat$246517 = -1159					; size = 1
$T246515 = -1158					; size = 1
$T246514 = -1157					; size = 1
$T246483 = -1156					; size = 4
$T246482 = -1152					; size = 4
$T246478 = -1148					; size = 4
$T246477 = -1144					; size = 4
$T246461 = -1140					; size = 4
$T246460 = -1136					; size = 4
$T246446 = -1132					; size = 4
$T246445 = -1128					; size = 4
__Cat$246467 = -1118					; size = 1
$T246465 = -1117					; size = 1
$T246364 = -1116					; size = 4
$T246363 = -1112					; size = 4
$T246349 = -1108					; size = 4
$T246348 = -1104					; size = 4
__Cat$246370 = -1094					; size = 1
$T246368 = -1093					; size = 1
$T246264 = -1092					; size = 4
$T246263 = -1088					; size = 4
$T246240 = -1084					; size = 4
$T246239 = -1080					; size = 4
__Cat$246271 = -1074					; size = 1
$T246268 = -1073					; size = 1
$T246174 = -1072					; size = 4
$T246162 = -1068					; size = 4
$T246152 = -1061					; size = 1
$T246151 = -1060					; size = 4
__Cat$246169 = -1055					; size = 1
$T246166 = -1054					; size = 1
$T246165 = -1053					; size = 1
$T246139 = -1052					; size = 4
$T246127 = -1048					; size = 4
$T246117 = -1041					; size = 1
$T246116 = -1040					; size = 4
__Cat$246134 = -1035					; size = 1
$T246131 = -1034					; size = 1
$T246130 = -1033					; size = 1
$T246104 = -1032					; size = 4
$T246094 = -1028					; size = 4
__Cat$246102 = -1023					; size = 1
$T246099 = -1022					; size = 1
$T246098 = -1021					; size = 1
__Count$246069 = -1020					; size = 4
__Count$246043 = -948					; size = 4
__Tmp$223531 = -944					; size = 448
__Oldend$223532 = -492					; size = 4
__Tmp$223521 = -488					; size = 448
__$ArrayPad$ = -36					; size = 4
__Ncopied$223508 = -32					; size = 4
__Newvec$223506 = -28					; size = 4
__Whereoff$223507 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 1332				; 00000534H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN31@Insert_n@3
	mov	DWORD PTR tv290[ebp], 0
	jmp	SHORT $LN29@Insert_n@3
$LN31@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR tv290[ebp], eax
$LN29@Insert_n@3:
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$246043[ebp], 9586980	; 00924924H
	cmp	DWORD PTR __Count$246043[ebp], 0
	jbe	SHORT $LN37@Insert_n@3
	mov	eax, DWORD PTR __Count$246043[ebp]
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN39@Insert_n@3
$LN37@Insert_n@3:
	mov	DWORD PTR tv298[ebp], 1
$LN39@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	edx, DWORD PTR tv298[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN44@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen
	jmp	$LN16@Insert_n@3

; 1167 : 		else if (_Capacity < size() + _Count)

$LN44@Insert_n@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$246069[ebp], 9586980	; 00924924H
	cmp	DWORD PTR __Count$246069[ebp], 0
	jbe	SHORT $LN50@Insert_n@3
	mov	edx, DWORD PTR __Count$246069[ebp]
	mov	DWORD PTR tv312[ebp], edx
	jmp	SHORT $LN46@Insert_n@3
$LN50@Insert_n@3:
	mov	DWORD PTR tv312[ebp], 1
$LN46@Insert_n@3:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv312[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@3:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN56@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN56@Insert_n@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ; std::_Allocate<TRSortElement>
	add	esp, 8
	mov	DWORD PTR __Newvec$223506[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR __Whereoff$223507[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$223508[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$223507[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR __Newvec$223506[ebp]
	mov	DWORD PTR $T246104[ebp], edx
	mov	eax, DWORD PTR $T246104[ebp]
	mov	DWORD PTR $T246094[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T246098[ebp], cl
	mov	dl, BYTE PTR __Cat$246102[ebp]
	mov	BYTE PTR $T246099[ebp], dl
	movzx	eax, BYTE PTR $T246098[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T246099[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246094[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$223508[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$223508[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246139[ebp], edx
	mov	eax, DWORD PTR __Newvec$223506[ebp]
	mov	DWORD PTR $T246127[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T246130[ebp], cl
	mov	dl, BYTE PTR __Cat$246134[ebp]
	mov	BYTE PTR $T246131[ebp], dl
	mov	al, BYTE PTR $T246130[ebp]
	mov	BYTE PTR $T246117[ebp], al
	mov	ecx, DWORD PTR $T246127[ebp]
	mov	DWORD PTR $T246116[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T246116[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246139[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$223508[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$223508[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246174[ebp], edx
	mov	eax, DWORD PTR __Whereoff$223507[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Newvec$223506[ebp]
	mov	DWORD PTR $T246162[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T246165[ebp], cl
	mov	dl, BYTE PTR __Cat$246169[ebp]
	mov	BYTE PTR $T246166[ebp], dl
	mov	al, BYTE PTR $T246165[ebp]
	mov	BYTE PTR $T246152[ebp], al
	mov	ecx, DWORD PTR $T246162[ebp]
	mov	DWORD PTR $T246151[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T246151[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246174[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@3
__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223508[ebp], 1
	jle	$LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$223507[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Newvec$223506[ebp]
	mov	DWORD PTR $T246264[ebp], eax
	mov	ecx, DWORD PTR __Newvec$223506[ebp]
	mov	DWORD PTR $T246263[ebp], ecx
	mov	dl, BYTE PTR __Cat$246271[ebp]
	mov	BYTE PTR $T246268[ebp], dl
	mov	eax, DWORD PTR $T246264[ebp]
	mov	DWORD PTR $T246240[ebp], eax
	mov	ecx, DWORD PTR $T246263[ebp]
	mov	DWORD PTR $T246239[ebp], ecx
	jmp	SHORT $LN88@Insert_n@3
$LN87@Insert_n@3:
	mov	edx, DWORD PTR $T246239[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR $T246239[ebp], edx
$LN88@Insert_n@3:
	mov	eax, DWORD PTR $T246239[ebp]
	cmp	eax, DWORD PTR $T246240[ebp]
	je	SHORT $LN7@Insert_n@3
	mov	ecx, DWORD PTR $T246239[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN91@Insert_n@3
	mov	edx, DWORD PTR $T246239[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN91@Insert_n@3:
	jmp	SHORT $LN87@Insert_n@3
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$223508[ebp], 0
	jle	$LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR __Whereoff$223507[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Newvec$223506[ebp]
	add	ecx, eax
	mov	DWORD PTR $T246364[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$223507[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR __Newvec$223506[ebp]
	mov	DWORD PTR $T246363[ebp], edx
	mov	al, BYTE PTR __Cat$246370[ebp]
	mov	BYTE PTR $T246368[ebp], al
	mov	ecx, DWORD PTR $T246364[ebp]
	mov	DWORD PTR $T246349[ebp], ecx
	mov	edx, DWORD PTR $T246363[ebp]
	mov	DWORD PTR $T246348[ebp], edx
	jmp	SHORT $LN112@Insert_n@3
$LN111@Insert_n@3:
	mov	eax, DWORD PTR $T246348[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR $T246348[ebp], eax
$LN112@Insert_n@3:
	mov	ecx, DWORD PTR $T246348[ebp]
	cmp	ecx, DWORD PTR $T246349[ebp]
	je	SHORT $LN6@Insert_n@3
	mov	edx, DWORD PTR $T246348[ebp]
	push	edx
	call	??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ; std::_Destroy<TRSortElement>
	add	esp, 4
	jmp	SHORT $LN111@Insert_n@3
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$223506[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN135@Insert_n@3
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN135@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246478[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246477[ebp], eax
	mov	ecx, DWORD PTR $T246478[ebp]
	mov	DWORD PTR $T246461[ebp], ecx
	mov	edx, DWORD PTR $T246477[ebp]
	mov	DWORD PTR $T246460[ebp], edx
	mov	al, BYTE PTR __Cat$246467[ebp]
	mov	BYTE PTR $T246465[ebp], al
	mov	ecx, DWORD PTR $T246461[ebp]
	mov	DWORD PTR $T246446[ebp], ecx
	mov	edx, DWORD PTR $T246460[ebp]
	mov	DWORD PTR $T246445[ebp], edx
	jmp	SHORT $LN145@Insert_n@3
$LN144@Insert_n@3:
	mov	eax, DWORD PTR $T246445[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR $T246445[ebp], eax
$LN145@Insert_n@3:
	mov	ecx, DWORD PTR $T246445[ebp]
	cmp	ecx, DWORD PTR $T246446[ebp]
	je	SHORT $LN137@Insert_n@3
	mov	edx, DWORD PTR $T246445[ebp]
	push	edx
	call	??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ; std::_Destroy<TRSortElement>
	add	esp, 4
	jmp	SHORT $LN144@Insert_n@3
$LN137@Insert_n@3:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR $T246483[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246482[ebp], eax
	mov	ecx, DWORD PTR $T246482[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR __Newvec$223506[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Newvec$223506[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$223506[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$223521[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR __Tmp$223521[ebp+444], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246522[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246510[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246514[ebp], dl
	mov	al, BYTE PTR __Cat$246517[ebp]
	mov	BYTE PTR $T246515[ebp], al
	mov	cl, BYTE PTR $T246514[ebp]
	mov	BYTE PTR $T246500[ebp], cl
	mov	edx, DWORD PTR $T246510[ebp]
	mov	DWORD PTR $T246499[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246499[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246522[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
	add	esp, 16					; 00000010H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T246549[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246548[ebp], ecx
	mov	edx, DWORD PTR $T246548[ebp]
	mov	DWORD PTR $T246538[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T246543[ebp], al
	mov	cl, BYTE PTR __Cat$246546[ebp]
	mov	BYTE PTR $T246544[ebp], cl
	movzx	edx, BYTE PTR $T246543[ebp]
	push	edx
	movzx	eax, BYTE PTR $T246544[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$223521[ebp]
	push	edx
	mov	eax, DWORD PTR $T246549[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246538[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
	add	esp, 24					; 00000018H
	jmp	$LN21@Insert_n@3
__catch$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 448				; 000001c0H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246641[ebp], edx
	mov	ecx, DWORD PTR $T246641[ebp]
	mov	DWORD PTR $T246625[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246624[ebp], edx
	mov	al, BYTE PTR __Cat$246631[ebp]
	mov	BYTE PTR $T246629[ebp], al
	mov	ecx, DWORD PTR $T246625[ebp]
	mov	DWORD PTR $T246610[ebp], ecx
	mov	edx, DWORD PTR $T246624[ebp]
	mov	DWORD PTR $T246609[ebp], edx
	jmp	SHORT $LN193@Insert_n@3
$LN192@Insert_n@3:
	mov	eax, DWORD PTR $T246609[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR $T246609[ebp], eax
$LN193@Insert_n@3:
	mov	ecx, DWORD PTR $T246609[ebp]
	cmp	ecx, DWORD PTR $T246610[ebp]
	je	SHORT $LN185@Insert_n@3
	mov	edx, DWORD PTR $T246609[ebp]
	push	edx
	call	??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ; std::_Destroy<TRSortElement>
	add	esp, 4
	jmp	SHORT $LN192@Insert_n@3
$LN185@Insert_n@3:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	eax, __tryend$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], 2
__tryend$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 448				; 000001c0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T246664[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246654[ebp], eax
	jmp	SHORT $LN218@Insert_n@3
$LN217@Insert_n@3:
	mov	ecx, DWORD PTR $T246654[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T246654[ebp], ecx
$LN218@Insert_n@3:
	mov	edx, DWORD PTR $T246654[ebp]
	cmp	edx, DWORD PTR $T246664[ebp]
	je	SHORT $LN214@Insert_n@3
	lea	eax, DWORD PTR __Tmp$223521[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246654[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR $T246654[ebp]
	mov	edx, DWORD PTR __Tmp$223521[ebp+444]
	mov	DWORD PTR [ecx+444], edx
	jmp	SHORT $LN217@Insert_n@3
$LN214@Insert_n@3:

; 1232 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$223521[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>

; 1233 : 		else

	jmp	$LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$223531[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR __Tmp$223531[ebp+444], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 5

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$223532[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246762[ebp], eax
	mov	ecx, DWORD PTR $T246762[ebp]
	mov	DWORD PTR $T246743[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246747[ebp], dl
	mov	al, BYTE PTR __Cat$246750[ebp]
	mov	BYTE PTR $T246748[ebp], al
	mov	cl, BYTE PTR $T246747[ebp]
	mov	BYTE PTR $T246726[ebp], cl
	mov	edx, DWORD PTR $T246743[ebp]
	mov	DWORD PTR $T246725[ebp], edx
	mov	eax, DWORD PTR $T246725[ebp]
	mov	DWORD PTR $T246715[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR __Oldend$223532[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T246714[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T246756[ebp], al
	mov	cl, BYTE PTR __Cat$246759[ebp]
	mov	BYTE PTR $T246757[ebp], cl
	movzx	edx, BYTE PTR $T246756[ebp]
	push	edx
	movzx	eax, BYTE PTR $T246757[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246715[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$223532[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246714[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$223532[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR __Oldend$223532[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246826[ebp], ecx
	jmp	SHORT $LN273@Insert_n@3
$LN272@Insert_n@3:
	mov	edx, DWORD PTR $T246826[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR $T246826[ebp], edx
$LN273@Insert_n@3:
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T246826[ebp], eax
	je	SHORT $LN269@Insert_n@3
	lea	ecx, DWORD PTR __Tmp$223531[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T246826[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T246826[ebp]
	mov	eax, DWORD PTR __Tmp$223531[ebp+444]
	mov	DWORD PTR [edx+444], eax
	jmp	SHORT $LN272@Insert_n@3
$LN269@Insert_n@3:

; 1249 : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$223531[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
$LN16@Insert_n@3:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$223521[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__unwindfunclet$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$223531[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1352]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@IAEXV?$_Vector_const_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@IABUTRSortElement@@@Z ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T246887 = -80						; size = 28
$T246886 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ PROC ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T246887[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T246886[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T246886[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T246887[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246886[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T246886[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T246886[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T246887[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T246887[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T246886[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@KAXXZ ENDP ; std::vector<TRSortElement,std::allocator<TRSortElement> >::_Xlen
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	256					; 00000100H
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
PUBLIC	??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z ; operator<<<21>
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$1
__ehfuncinfo$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
_TEXT	SEGMENT
$T246914 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z PROC ; GetLocalizedText<int,char const [21]>, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T246914[ebp], 0

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z ; operator<<<21>
	add	esp, 8

; 517  : 
; 518  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 520  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 521  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 522  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T246914[ebp]
	or	eax, 1
	mov	DWORD PTR $T246914[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z$2:
	mov	eax, DWORD PTR $T246914[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz
	and	DWORD PTR $T246914[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz:
	ret	0
__ehhandler$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@H$$BY0BF@$$CBD@@YA?AVCvString@@PBDABHAAY0BF@$$CBD@Z ENDP ; GetLocalizedText<int,char const [21]>
PUBLIC	??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z ; operator<<<24>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$1
__ehfuncinfo$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
_TEXT	SEGMENT
$T246940 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z PROC ; GetLocalizedText<int,char const [24]>, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T246940[ebp], 0

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z ; operator<<<24>
	add	esp, 8

; 517  : 
; 518  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 520  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 521  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 522  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T246940[ebp]
	or	eax, 1
	mov	DWORD PTR $T246940[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z$2:
	mov	eax, DWORD PTR $T246940[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@2
	and	DWORD PTR $T246940[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@H$$BY0BI@$$CBD@@YA?AVCvString@@PBDABHAAY0BI@$$CBD@Z ENDP ; GetLocalizedText<int,char const [24]>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NABV12@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z PROC ; operator<<<Localization::String>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NABV12@@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6VString@Localization@@@@YAAAVString@Localization@@AAV01@ABV01@@Z ENDP ; operator<<<Localization::String>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z
_TEXT	SEGMENT
$T247037 = -58						; size = 1
$T247036 = -57						; size = 1
$T247035 = -56						; size = 4
$T247034 = -52						; size = 4
__Cat$246972 = -4					; size = 1
$T246968 = -3						; size = 1
$T246967 = -2						; size = 1
$T246966 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z PROC ; stdext::unchecked_copy<TRSortElement *,TRSortElement *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T246966[ebp], al
	mov	cl, BYTE PTR __Cat$246972[ebp]
	mov	BYTE PTR $T246967[ebp], cl
	mov	dl, BYTE PTR $T246966[ebp]
	mov	BYTE PTR $T247037[ebp], dl
	mov	al, BYTE PTR $T246968[ebp]
	mov	BYTE PTR $T247036[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T247035[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247034[ebp], edx
	jmp	SHORT $LN9@unchecked_
$LN8@unchecked_:
	mov	eax, DWORD PTR $T247035[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR $T247035[ebp], eax
	mov	ecx, DWORD PTR $T247034[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T247034[ebp], ecx
$LN9@unchecked_:
	mov	edx, DWORD PTR $T247034[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN10@unchecked_
	mov	eax, DWORD PTR $T247034[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247035[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR $T247035[ebp]
	mov	edx, DWORD PTR $T247034[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	jmp	SHORT $LN8@unchecked_
$LN10@unchecked_:
	mov	eax, DWORD PTR $T247035[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ENDP ; stdext::unchecked_copy<TRSortElement *,TRSortElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
$T247088 = -34						; size = 1
$T247087 = -33						; size = 1
$T247086 = -32						; size = 4
$T247085 = -28						; size = 4
$T247071 = -21						; size = 1
$T247070 = -20						; size = 4
$T247069 = -16						; size = 4
$T247068 = -12						; size = 4
__Cat$247077 = -8					; size = 1
$T247074 = -7						; size = 1
$T247073 = -6						; size = 1
__Cat$247046 = -4					; size = 1
$T247042 = -3						; size = 1
$T247041 = -2						; size = 1
$T247040 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvString *,CvString *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T247040[ebp], al
	mov	cl, BYTE PTR __Cat$247046[ebp]
	mov	BYTE PTR $T247041[ebp], cl
	mov	dl, BYTE PTR $T247040[ebp]
	mov	BYTE PTR $T247088[ebp], dl
	mov	al, BYTE PTR $T247042[ebp]
	mov	BYTE PTR $T247087[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T247086[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247085[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247073[ebp], al
	mov	cl, BYTE PTR __Cat$247077[ebp]
	mov	BYTE PTR $T247074[ebp], cl
	mov	dl, BYTE PTR $T247073[ebp]
	mov	BYTE PTR $T247071[ebp], dl
	mov	eax, DWORD PTR $T247086[ebp]
	mov	DWORD PTR $T247070[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T247069[ebp], ecx
	mov	edx, DWORD PTR $T247085[ebp]
	mov	DWORD PTR $T247068[ebp], edx
$LN12@Unchecked_:
	mov	eax, DWORD PTR $T247068[ebp]
	cmp	eax, DWORD PTR $T247069[ebp]
	je	SHORT $LN7@Unchecked_
	mov	ecx, DWORD PTR $T247069[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR $T247069[ebp], ecx
	mov	edx, DWORD PTR $T247070[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR $T247070[ebp], edx
	mov	eax, DWORD PTR $T247069[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247070[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN12@Unchecked_
$LN7@Unchecked_:
	mov	eax, DWORD PTR $T247070[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z
_TEXT	SEGMENT
$T247095 = -16						; size = 4
$T247091 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z PROC ; std::_Allocate<CvString>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247095[ebp], 0
	lea	eax, DWORD PTR $T247095[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247091[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247091[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247091[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ENDP ; std::_Allocate<CvString>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
$T247147 = -38						; size = 1
$T247146 = -37						; size = 1
$T247145 = -36						; size = 4
$T247144 = -32						; size = 4
$T247131 = -25						; size = 1
$T247130 = -24						; size = 4
$T247129 = -20						; size = 4
__Off$247140 = -16					; size = 4
__Result$247141 = -12					; size = 4
__Cat$247137 = -8					; size = 1
$T247134 = -7						; size = 1
$T247133 = -6						; size = 1
__Cat$247111 = -4					; size = 1
$T247107 = -3						; size = 1
$T247106 = -2						; size = 1
$T247105 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T247105[ebp], al
	mov	cl, BYTE PTR __Cat$247111[ebp]
	mov	BYTE PTR $T247106[ebp], cl
	mov	dl, BYTE PTR $T247105[ebp]
	mov	BYTE PTR $T247147[ebp], dl
	mov	al, BYTE PTR $T247107[ebp]
	mov	BYTE PTR $T247146[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T247145[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247144[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247133[ebp], al
	mov	cl, BYTE PTR __Cat$247137[ebp]
	mov	BYTE PTR $T247134[ebp], cl
	mov	dl, BYTE PTR $T247133[ebp]
	mov	BYTE PTR $T247131[ebp], dl
	mov	eax, DWORD PTR $T247145[ebp]
	mov	DWORD PTR $T247130[ebp], eax
	mov	ecx, DWORD PTR $T247144[ebp]
	mov	DWORD PTR $T247129[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T247129[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$247140[ebp], edx
	mov	eax, DWORD PTR __Off$247140[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T247130[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$247141[ebp], ecx
	cmp	DWORD PTR __Off$247140[ebp], 0
	jle	SHORT $LN7@Unchecked_@2
	mov	edx, DWORD PTR __Off$247140[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T247129[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$247140[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$247141[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@2:
	mov	eax, DWORD PTR __Result$247141[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z
_TEXT	SEGMENT
$T247154 = -16						; size = 4
$T247150 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z PROC ; std::_Allocate<CvCity *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247154[ebp], 0
	lea	eax, DWORD PTR $T247154[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247150[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247150[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247150[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCity *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z
_TEXT	SEGMENT
$T247251 = -74						; size = 1
$T247250 = -73						; size = 1
$T247249 = -72						; size = 4
$T247248 = -68						; size = 4
$T247234 = -61						; size = 1
$T247233 = -60						; size = 4
$T247232 = -56						; size = 4
$T247231 = -52						; size = 4
__Cat$247240 = -8					; size = 1
$T247237 = -7						; size = 1
$T247236 = -6						; size = 1
__Cat$247163 = -4					; size = 1
$T247159 = -3						; size = 1
$T247158 = -2						; size = 1
$T247157 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T247157[ebp], al
	mov	cl, BYTE PTR __Cat$247163[ebp]
	mov	BYTE PTR $T247158[ebp], cl
	mov	dl, BYTE PTR $T247157[ebp]
	mov	BYTE PTR $T247251[ebp], dl
	mov	al, BYTE PTR $T247159[ebp]
	mov	BYTE PTR $T247250[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T247249[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247248[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247236[ebp], al
	mov	cl, BYTE PTR __Cat$247240[ebp]
	mov	BYTE PTR $T247237[ebp], cl
	mov	dl, BYTE PTR $T247236[ebp]
	mov	BYTE PTR $T247234[ebp], dl
	mov	eax, DWORD PTR $T247249[ebp]
	mov	DWORD PTR $T247233[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T247232[ebp], ecx
	mov	edx, DWORD PTR $T247248[ebp]
	mov	DWORD PTR $T247231[ebp], edx
$LN12@Unchecked_@3:
	mov	eax, DWORD PTR $T247231[ebp]
	cmp	eax, DWORD PTR $T247232[ebp]
	je	SHORT $LN7@Unchecked_@3
	mov	ecx, DWORD PTR $T247232[ebp]
	sub	ecx, 448				; 000001c0H
	mov	DWORD PTR $T247232[ebp], ecx
	mov	edx, DWORD PTR $T247233[ebp]
	sub	edx, 448				; 000001c0H
	mov	DWORD PTR $T247233[ebp], edx
	mov	eax, DWORD PTR $T247232[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247233[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR $T247233[ebp]
	mov	edx, DWORD PTR $T247232[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	jmp	SHORT $LN12@Unchecked_@3
$LN7@Unchecked_@3:
	mov	eax, DWORD PTR $T247233[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUTRSortElement@@PAU1@@stdext@@YAPAUTRSortElement@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<TRSortElement *,TRSortElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z
_TEXT	SEGMENT
$T247258 = -16						; size = 4
$T247254 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z PROC ; std::_Allocate<TRSortElement>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 448				; 000001c0H
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247258[ebp], 0
	lea	eax, DWORD PTR $T247258[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247254[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247254[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247254[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 448				; 000001c0H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UTRSortElement@@@std@@YAPAUTRSortElement@@IPAU1@@Z ENDP ; std::_Allocate<TRSortElement>
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBDI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z PROC ; operator<<<21>, COMDAT

; 497  : {

	push	ebp
	mov	ebp, esp

; 498  : 	s.PushArgument(val, N - 1);

	push	20					; 00000014H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 500  : }

	pop	ebp
	ret	0
??$?6$0BF@@@YAAAVString@Localization@@AAV01@AAY0BF@$$CBD@Z ENDP ; operator<<<21>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z PROC ; operator<<<24>, COMDAT

; 497  : {

	push	ebp
	mov	ebp, esp

; 498  : 	s.PushArgument(val, N - 1);

	push	23					; 00000017H
	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBDI@Z

; 499  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 500  : }

	pop	ebp
	ret	0
??$?6$0BI@@@YAAAVString@Localization@@AAV01@AAY0BI@$$CBD@Z ENDP ; operator<<<24>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
_TEXT	SEGMENT
$T247307 = -56						; size = 4
$T247303 = -52						; size = 4
$T247290 = -48						; size = 4
$T247289 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3561 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3562 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247303[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T247290[ebp], ecx
	mov	edx, DWORD PTR $T247303[ebp]
	mov	DWORD PTR $T247289[ebp], edx
	mov	eax, DWORD PTR $T247290[ebp]
	sub	eax, DWORD PTR $T247289[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T247307[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T247307[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H

; 3565 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0PAHPAUTRSortElement@@USortTR@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T247516 = -32						; size = 4
$T247515 = -28						; size = 4
__Vptr$247524 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$247524[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247524[ebp]
	mov	DWORD PTR $T247516[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T247516[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T247516[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T247516[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T247515[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN26@Uninit_fil
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@Uninit_fil:
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$247524[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247516[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$9
__unwindtable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -48						; size = 4
$T247604 = -32						; size = 4
$T247603 = -28						; size = 4
__Vptr$247612 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$247612[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247612[ebp]
	mov	DWORD PTR $T247604[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T247604[ebp], 0
	je	SHORT $LN18@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T247604[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR $T247604[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	mov	eax, DWORD PTR $T247604[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil@2
$LN18@Uninit_fil@2:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@2:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T247603[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN34@Uninit_fil@2
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Uninit_fil@2:
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$247612[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247604[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUTRSortElement@@IU1@V?$allocator@UTRSortElement@@@std@@@std@@YAXPAUTRSortElement@@IABU1@AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<TRSortElement *,unsigned int,TRSortElement,std::allocator<TRSortElement> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T247749 = -20						; size = 4
__Next$224959 = -4					; size = 4
??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ PROC	; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$224959[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$224959[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Next$224959[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$224959[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	mov	ecx, DWORD PTR __Next$224959[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN7@Temp_itera
	mov	ecx, DWORD PTR __Next$224959[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Temp_itera:
	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T247749[ebp], eax
	mov	ecx, DWORD PTR $T247749[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ENDP	; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
PUBLIC	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z
_TEXT	SEGMENT
__Count2$225016 = -8					; size = 4
__Mid$225017 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H

; 3530 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
	add	esp, 16					; 00000010H

; 3532 : 	else

	jmp	$LN5@Stable_sor
$LN4@Stable_sor:

; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$225016[ebp], eax

; 3535 : 		_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$225017[ebp], eax

; 3536 : 		std::advance(_Mid, _Count2);

	mov	ecx, DWORD PTR __Count2$225016[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Mid$225017[ebp]
	mov	DWORD PTR __Mid$225017[ebp], ecx

; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	DWORD PTR __Count2$225016[ebp], eax
	jg	SHORT $LN2@Stable_sor

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$225016[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$225017[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$225016[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$225017[ebp]
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN1@Stable_sor
$LN2@Stable_sor:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$225016[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$225017[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Count2$225016[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$225017[ebp]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 20					; 00000014H
$LN1@Stable_sor:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$225016[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$225016[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$225017[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 28					; 0000001cH
$LN5@Stable_sor:

; 3552 : 		}
; 3553 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv94 = -36						; size = 4
$T248283 = -32						; size = 4
$T248277 = -28						; size = 4
__Vptr$248275 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248283[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$248275[ebp], edx
	mov	eax, DWORD PTR __Vptr$248275[ebp]
	mov	DWORD PTR $T248277[ebp], eax
	cmp	DWORD PTR $T248277[ebp], 0
	je	SHORT $LN26@Uninit_cop
	mov	ecx, DWORD PTR $T248277[ebp]
	mov	edx, DWORD PTR $T248283[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T248277[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN22@Uninit_cop
$LN26@Uninit_cop:
	mov	DWORD PTR tv94[ebp], 0
$LN22@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@PAHV?$allocator@H@2@@std@@YAPAHV?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0PAHAAV?$allocator@H@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<int,std::allocator<int> >,int *,std::allocator<int> >
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv132 = -40						; size = 4
$T248359 = -36						; size = 4
$T248349 = -32						; size = 4
$T248348 = -28						; size = 4
__Vptr$248357 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248359[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$248357[ebp], edx
	mov	eax, DWORD PTR __Vptr$248357[ebp]
	mov	DWORD PTR $T248349[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T248349[ebp], 0
	je	SHORT $LN26@Uninit_cop@2
	mov	ecx, DWORD PTR $T248359[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T248349[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T248349[ebp]
	mov	DWORD PTR tv132[ebp], edx
	jmp	SHORT $LN27@Uninit_cop@2
$LN26@Uninit_cop@2:
	mov	DWORD PTR tv132[ebp], 0
$LN27@Uninit_cop@2:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T248348[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN34@Uninit_cop@2
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Uninit_cop@2:
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$248357[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248349[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@PAVCvString@@V?$allocator@VCvString@@@2@@std@@YAPAVCvString@@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@0@0PAV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvString,std::allocator<CvString> >,CvString *,std::allocator<CvString> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv94 = -36						; size = 4
$T248443 = -32						; size = 4
$T248437 = -28						; size = 4
__Vptr$248435 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248443[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$248435[ebp], edx
	mov	eax, DWORD PTR __Vptr$248435[ebp]
	mov	DWORD PTR $T248437[ebp], eax
	cmp	DWORD PTR $T248437[ebp], 0
	je	SHORT $LN26@Uninit_cop@3
	mov	ecx, DWORD PTR $T248437[ebp]
	mov	edx, DWORD PTR $T248443[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T248437[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN22@Uninit_cop@3
$LN26@Uninit_cop@3:
	mov	DWORD PTR tv94[ebp], 0
$LN22@Uninit_cop@3:
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z
_TEXT	SEGMENT
$T248490 = -22						; size = 1
$T248489 = -21						; size = 1
$T248488 = -20						; size = 4
$T248479 = -13						; size = 1
$T248478 = -12						; size = 4
$T248477 = -8						; size = 4
$T248482 = -4						; size = 1
$T248464 = -2						; size = 1
$T248463 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T248463[ebp], al
	mov	cl, BYTE PTR $T248463[ebp]
	mov	BYTE PTR $T248490[ebp], cl
	mov	dl, BYTE PTR $T248464[ebp]
	mov	BYTE PTR $T248489[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248488[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248482[ebp], cl
	mov	dl, BYTE PTR $T248482[ebp]
	mov	BYTE PTR $T248479[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T248478[ebp], eax
	mov	ecx, DWORD PTR $T248488[ebp]
	mov	DWORD PTR $T248477[ebp], ecx
	jmp	SHORT $LN9@unchecked_@2
$LN8@unchecked_@2:
	mov	edx, DWORD PTR $T248478[ebp]
	sub	edx, 1
	mov	DWORD PTR $T248478[ebp], edx
	mov	eax, DWORD PTR $T248477[ebp]
	add	eax, 4
	mov	DWORD PTR $T248477[ebp], eax
$LN9@unchecked_@2:
	cmp	DWORD PTR $T248478[ebp], 0
	jbe	SHORT $LN1@unchecked_@2
	mov	ecx, DWORD PTR $T248477[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@2
$LN1@unchecked_@2:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z PROC ; std::_Destroy<TRSortElement>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN1@Destroy@2
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Destroy@2:

; 60   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy@UTRSortElement@@@std@@YAXPAUTRSortElement@@@Z ENDP ; std::_Destroy<TRSortElement>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z ; std::get_temporary_buffer<TRSortElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$225243 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ PROC ; std::_Temp_iterator<TRSortElement>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$225243[ebp]
	push	ecx
	call	??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z ; std::get_temporary_buffer<TRSortElement>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$225243[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$225243[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$225243[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$225243[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<TRSortElement>::_Maxlen
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z
_TEXT	SEGMENT
tv144 = -220						; size = 4
$T248948 = -61						; size = 1
$T248672 = -60						; size = 4
$T248668 = -56						; size = 4
$T248617 = -32						; size = 4
$T248597 = -28						; size = 4
$T248554 = -20						; size = 4
__Chunk$225315 = -16					; size = 4
__Midn$225313 = -12					; size = 4
__Nleft$225309 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$225309[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$225309[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$225309[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$225309[ebp], 32	; 00000020H
	jl	SHORT $LN26@Buffered_m

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midn$225313[ebp], eax

; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Midn$225313[ebp]
	mov	DWORD PTR __Midn$225313[ebp], ecx

; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	edx, DWORD PTR __Midn$225313[ebp]
	mov	DWORD PTR $T248597[ebp], edx
	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248597[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
	add	esp, 16					; 00000010H

; 3510 : 		_Mid = _Midn;

	mov	eax, DWORD PTR __Midn$225313[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3511 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

$LN26@Buffered_m:
	push	0
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
	add	esp, 16					; 00000010H

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$225315[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	ecx, DWORD PTR __Chunk$225315[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$225315[ebp], ecx
$LN3@Buffered_m:
	mov	edx, DWORD PTR __Chunk$225315[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$225315[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T248554[ebp], esp
	mov	DWORD PTR $T248617[ebp], edx
	mov	eax, DWORD PTR $T248617[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T248617[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T248617[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T248617[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T248617[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T248617[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
	add	esp, 40					; 00000028H

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Chunk$225315[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$225315[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T248668[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T248672[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248948[ebp], dl
	movzx	eax, BYTE PTR $T248948[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$225315[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248668[ebp]
	push	edx
	mov	eax, DWORD PTR $T248672[ebp]
	push	eax
	call	??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
	add	esp, 28					; 0000001cH

; 3520 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0HAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
PUBLIC	??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
PUBLIC	??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z ; std::swap<TRSortElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z
_TEXT	SEGMENT
tv244 = -332						; size = 4
tv243 = -328						; size = 4
tv240 = -324						; size = 4
tv239 = -320						; size = 4
$T249344 = -260						; size = 4
$T249331 = -256						; size = 4
$T249330 = -252						; size = 4
$T249308 = -245						; size = 1
$T249307 = -244						; size = 4
$T249306 = -240						; size = 4
$T249302 = -236						; size = 4
$T249295 = -232						; size = 4
$T249253 = -224						; size = 4
$T249240 = -220						; size = 4
$T249239 = -216						; size = 4
$T249217 = -209						; size = 1
$T249216 = -208						; size = 4
$T249212 = -204						; size = 4
$T249205 = -200						; size = 4
$T249147 = -193						; size = 1
$T249146 = -192						; size = 4
$T249145 = -188						; size = 4
$T249143 = -181						; size = 1
$T249139 = -180						; size = 4
$T249135 = -176						; size = 4
$T249098 = -164						; size = 4
$T249085 = -149						; size = 1
$T249084 = -148						; size = 4
$T249083 = -144						; size = 4
$T249082 = -140						; size = 4
$T249077 = -134						; size = 1
$T249076 = -133						; size = 1
$T249067 = -132						; size = 4
$T249063 = -128						; size = 4
$T249026 = -116						; size = 4
$T249013 = -104						; size = 4
$T249012 = -100						; size = 4
$T248993 = -96						; size = 4
$T248980 = -92						; size = 4
$T248971 = -88						; size = 4
$T248958 = -84						; size = 4
$T248957 = -80						; size = 4
$T248956 = -76						; size = 4
$T248955 = -72						; size = 20
$T248954 = -52						; size = 4
$T248953 = -48						; size = 4
$T248952 = -44						; size = 20
$T248951 = -24						; size = 4
__Firstn$225395 = -20					; size = 4
__Count2n$225398 = -16					; size = 4
__Midn$225421 = -12					; size = 4
__Lastn$225396 = -8					; size = 4
__Count1n$225397 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248971[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T248980[ebp], edx
	mov	eax, DWORD PTR $T248980[ebp]
	mov	ecx, DWORD PTR $T248971[ebp]
	mov	edx, DWORD PTR [eax+444]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+444]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T249013[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249012[ebp], eax
	mov	ecx, DWORD PTR $T249013[ebp]
	mov	DWORD PTR $T248993[ebp], ecx
	mov	edx, DWORD PTR $T248993[ebp]
	push	edx
	mov	eax, DWORD PTR $T249012[ebp]
	push	eax
	call	??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z ; std::swap<TRSortElement>
	add	esp, 8
$LN8@Buffered_m@2:

; 2894 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Count1$[ebp]
	cmp	ecx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T248951[ebp], esp
	mov	DWORD PTR $T249026[ebp], ecx
	mov	edx, DWORD PTR $T249026[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T249026[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T249026[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T249026[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T249026[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T249026[ebp]
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T248952[ebp]
	push	eax
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv240[ebp], eax
	lea	ecx, DWORD PTR $T248952[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T249063[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249067[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T249085[ebp], cl
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249084[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T249083[ebp], eax
	mov	ecx, DWORD PTR $T249067[ebp]
	mov	DWORD PTR $T249082[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T249076[ebp], dl
	movzx	eax, BYTE PTR $T249076[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T249077[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T249085[ebp]
	push	edx
	mov	eax, DWORD PTR $T249084[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249083[ebp]
	push	edx
	mov	eax, DWORD PTR $T249063[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249082[ebp]
	push	ecx
	lea	edx, DWORD PTR $T248953[ebp]
	push	edx
	call	??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T248954[ebp], esp
	mov	DWORD PTR $T249098[ebp], edx
	mov	eax, DWORD PTR $T249098[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T249098[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T249098[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T249098[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T249098[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T249098[ebp]
	mov	DWORD PTR tv243[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248955[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv244[ebp], eax
	lea	ecx, DWORD PTR $T248955[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249135[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249139[ebp], ecx
	mov	dl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T249147[ebp], dl
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T249146[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249145[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T249143[ebp], dl
	movzx	eax, BYTE PTR $T249143[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T249147[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T249135[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249139[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249146[ebp]
	push	edx
	mov	eax, DWORD PTR $T249145[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248956[ebp]
	push	ecx
	call	??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
	add	esp, 32					; 00000020H

; 2906 : 		}
; 2907 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;

	mov	DWORD PTR __Firstn$225395[ebp], 0
	mov	DWORD PTR __Lastn$225396[ebp], 0

; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	mov	edx, DWORD PTR __Count2$[ebp]
	cmp	edx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@2

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$225397[ebp], eax
	mov	DWORD PTR __Count2n$225398[ebp], 0

; 2914 : 			_Firstn = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$225395[ebp], eax

; 2915 : 			std::advance(_Firstn, _Count1n);

	mov	ecx, DWORD PTR __Count1n$225397[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Firstn$225395[ebp]
	mov	DWORD PTR __Firstn$225395[ebp], ecx

; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	edx, DWORD PTR __Firstn$225395[ebp]
	mov	DWORD PTR $T249205[ebp], edx
	mov	al, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T249217[ebp], al
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T249216[ebp], ecx
	push	0
	movzx	edx, BYTE PTR $T249217[ebp]
	push	edx
	mov	eax, DWORD PTR $T249205[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249216[ebp]
	push	edx
	lea	eax, DWORD PTR $T249212[ebp]
	push	eax
	call	??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249216[ebp], ecx
	mov	edx, DWORD PTR $T249216[ebp]
	mov	DWORD PTR $T248957[ebp], edx
	mov	eax, DWORD PTR $T248957[ebp]
	mov	DWORD PTR __Lastn$225396[ebp], eax

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T249253[ebp], ecx
	mov	edx, DWORD PTR __Lastn$225396[ebp]
	mov	DWORD PTR $T249240[ebp], edx
	mov	eax, DWORD PTR $T249253[ebp]
	mov	DWORD PTR $T249239[ebp], eax
	mov	eax, DWORD PTR $T249240[ebp]
	sub	eax, DWORD PTR $T249239[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count2n$225398[ebp]
	mov	DWORD PTR __Count2n$225398[ebp], eax

; 2918 : 			}
; 2919 : 		else

	jmp	$LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$225397[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$225398[ebp], eax

; 2922 : 			_Lastn = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$225396[ebp], edx

; 2923 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Count2n$225398[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Lastn$225396[ebp]
	mov	DWORD PTR __Lastn$225396[ebp], eax

; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Lastn$225396[ebp]
	mov	DWORD PTR $T249295[ebp], ecx
	mov	dl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T249308[ebp], dl
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T249307[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249306[ebp], ecx
	push	0
	movzx	edx, BYTE PTR $T249308[ebp]
	push	edx
	mov	eax, DWORD PTR $T249295[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249307[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249306[ebp]
	push	edx
	lea	eax, DWORD PTR $T249302[ebp]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249306[ebp], ecx
	mov	edx, DWORD PTR $T249306[ebp]
	mov	DWORD PTR $T248958[ebp], edx
	mov	eax, DWORD PTR $T248958[ebp]
	mov	DWORD PTR __Firstn$225395[ebp], eax

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249344[ebp], ecx
	mov	edx, DWORD PTR __Firstn$225395[ebp]
	mov	DWORD PTR $T249331[ebp], edx
	mov	eax, DWORD PTR $T249344[ebp]
	mov	DWORD PTR $T249330[ebp], eax
	mov	eax, DWORD PTR $T249331[ebp]
	sub	eax, DWORD PTR $T249330[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count1n$225397[ebp]
	mov	DWORD PTR __Count1n$225397[ebp], eax
$LN1@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$225398[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$225397[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$225396[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$225395[ebp]
	push	ecx
	lea	edx, DWORD PTR __Midn$225421[ebp]
	push	edx
	call	??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
	add	esp, 28					; 0000001cH

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2n$225398[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1n$225397[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$225421[ebp]
	push	ecx
	mov	edx, DWORD PTR __Firstn$225395[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 28					; 0000001cH

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$[ebp]
	sub	eax, DWORD PTR __Count2n$225398[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$225397[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$225396[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$225421[ebp]
	push	ecx
	call	??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
	add	esp, 28					; 0000001cH
$LN10@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@USortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@USortTR@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement,SortTR>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
__Cat$249362 = -3					; size = 1
$T249359 = -2						; size = 1
$T249358 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T249358[ebp], al
	mov	cl, BYTE PTR __Cat$249362[ebp]
	mov	BYTE PTR $T249359[ebp], cl
	movzx	edx, BYTE PTR $T249358[ebp]
	push	edx
	movzx	eax, BYTE PTR $T249359[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
$T249380 = -21						; size = 1
$T249379 = -20						; size = 4
$T249378 = -16						; size = 4
__Result$249376 = -12					; size = 4
__Count$249375 = -8					; size = 4
__Cat$249370 = -3					; size = 1
$T249367 = -2						; size = 1
$T249366 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T249366[ebp], al
	mov	cl, BYTE PTR __Cat$249370[ebp]
	mov	BYTE PTR $T249367[ebp], cl
	mov	dl, BYTE PTR $T249366[ebp]
	mov	BYTE PTR $T249380[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249379[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249378[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T249378[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$249375[ebp], edx
	mov	eax, DWORD PTR __Count$249375[ebp]
	mov	ecx, DWORD PTR $T249379[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$249376[ebp], edx
	cmp	DWORD PTR __Count$249375[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$249375[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T249378[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$249375[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T249379[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$249376[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z
_TEXT	SEGMENT
__Cat$249387 = -3					; size = 1
$T249384 = -2						; size = 1
$T249383 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T249383[ebp], al
	mov	cl, BYTE PTR __Cat$249387[ebp]
	mov	BYTE PTR $T249384[ebp], cl
	movzx	edx, BYTE PTR $T249383[ebp]
	push	edx
	movzx	eax, BYTE PTR $T249384[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@stdext@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
_TEXT	ENDS
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Odtp
;	COMDAT ??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z
_TEXT	SEGMENT
$T249395 = -20						; size = 4
$T249391 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z PROC ; std::get_temporary_buffer<TRSortElement>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 448				; 000001c0H
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T249395[ebp], 0
	lea	eax, DWORD PTR $T249395[ebp]
	push	eax
	lea	ecx, DWORD PTR $T249391[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T249391[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T249391[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 448				; 000001c0H
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@UTRSortElement@@@std@@YA?AU?$pair@PAUTRSortElement@@H@0@H@Z ENDP ; std::get_temporary_buffer<TRSortElement>
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T249426 = -2092					; size = 4
$T249425 = -2088					; size = 4
$T249424 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T249424[ebp], eax
	mov	ecx, DWORD PTR $T249424[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T249425[ebp], eax
	mov	eax, DWORD PTR $T249425[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T249426[ebp], eax
	mov	ecx, DWORD PTR $T249426[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z$0
__ehfuncinfo$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
_TEXT	SEGMENT
$T249581 = -540						; size = 4
$T249567 = -528						; size = 4
$T249555 = -524						; size = 4
$T249543 = -520						; size = 4
$T249526 = -516						; size = 4
$T249514 = -512						; size = 4
$T249513 = -508						; size = 4
$T249512 = -504						; size = 4
__Cat$249507 = -496					; size = 1
$T249505 = -495						; size = 1
$T249504 = -494						; size = 1
$T249503 = -493						; size = 1
$T249477 = -492						; size = 4
$T249464 = -488						; size = 4
$T249430 = -484						; size = 4
__First1$225598 = -480					; size = 4
__Val$225587 = -476					; size = 448
__$ArrayPad$ = -24					; size = 4
__Next1$225586 = -20					; size = 4
__Next$225582 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 540				; 0000021cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$225582[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$225582[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __Next$225582[ebp], edx
	mov	eax, DWORD PTR __Next$225582[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$225582[ebp]
	mov	DWORD PTR __Next1$225586[ebp], ecx

; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$225582[ebp]
	mov	DWORD PTR $T249464[ebp], edx
	mov	eax, DWORD PTR $T249464[ebp]
	push	eax
	lea	ecx, DWORD PTR __Val$225587[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR $T249464[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR __Val$225587[ebp+444], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249477[ebp], eax
	mov	ecx, DWORD PTR $T249477[ebp]
	mov	edx, DWORD PTR __Val$225587[ebp+444]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+444]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@Insertion_

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$225586[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __Next1$225586[ebp], edx
	mov	eax, DWORD PTR __Next1$225586[ebp]
	mov	DWORD PTR $T249514[ebp], eax
	mov	ecx, DWORD PTR __Next$225582[ebp]
	mov	DWORD PTR $T249513[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249512[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T249503[ebp], al
	mov	cl, BYTE PTR __Cat$249507[ebp]
	mov	BYTE PTR $T249504[ebp], cl
	movzx	edx, BYTE PTR $T249503[ebp]
	push	edx
	movzx	eax, BYTE PTR $T249504[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T249505[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249514[ebp]
	push	edx
	mov	eax, DWORD PTR $T249513[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249512[ebp]
	push	ecx
	lea	edx, DWORD PTR $T249430[ebp]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249526[ebp], eax
	lea	ecx, DWORD PTR __Val$225587[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T249526[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T249526[ebp]
	mov	eax, DWORD PTR __Val$225587[ebp+444]
	mov	DWORD PTR [edx+444], eax

; 3134 : 				}
; 3135 : 			else

	jmp	$LN4@Insertion_
$LN5@Insertion_:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;

	mov	ecx, DWORD PTR __Next1$225586[ebp]
	mov	DWORD PTR __First1$225598[ebp], ecx

; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	edx, DWORD PTR __First1$225598[ebp]
	mov	DWORD PTR __Next1$225586[ebp], edx
$LN3@Insertion_:
	mov	eax, DWORD PTR __First1$225598[ebp]
	sub	eax, 448				; 000001c0H
	mov	DWORD PTR __First1$225598[ebp], eax
	mov	ecx, DWORD PTR __First1$225598[ebp]
	mov	DWORD PTR $T249543[ebp], ecx
	mov	edx, DWORD PTR $T249543[ebp]
	mov	eax, DWORD PTR __Val$225587[ebp+444]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+444]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN73@Insertion_

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	eax, DWORD PTR __First1$225598[ebp]
	mov	DWORD PTR $T249555[ebp], eax
	mov	ecx, DWORD PTR __Next1$225586[ebp]
	mov	DWORD PTR $T249567[ebp], ecx
	mov	edx, DWORD PTR $T249555[ebp]
	push	edx
	mov	ecx, DWORD PTR $T249567[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T249567[ebp]
	mov	ecx, DWORD PTR $T249555[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	jmp	$LN2@Insertion_

; 3141 : 				*_Next1 = _Val;	// insert element in hole

$LN73@Insertion_:
	mov	eax, DWORD PTR __Next1$225586[ebp]
	mov	DWORD PTR $T249581[ebp], eax
	lea	ecx, DWORD PTR __Val$225587[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T249581[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T249581[ebp]
	mov	eax, DWORD PTR __Val$225587[ebp+444]
	mov	DWORD PTR [edx+444], eax
$LN4@Insertion_:

; 3142 : 				}
; 3143 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Val$225587[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 3144 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z$0:
	lea	ecx, DWORD PTR __Val$225587[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-544]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@UTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0USortTR@@PAUTRSortElement@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,TRSortElement>
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
_TEXT	SEGMENT
tv94 = -172						; size = 4
$T249639 = -24						; size = 4
$T249628 = -20						; size = 4
$T249627 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>, COMDAT

; 5285 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T249627[ebp], al
	movzx	ecx, BYTE PTR $T249627[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Chunk$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T249628[ebp], esp
	mov	DWORD PTR $T249639[ebp], edx
	mov	eax, DWORD PTR $T249639[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T249639[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T249639[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T249639[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T249639[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T249639[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
	add	esp, 44					; 0000002cH

; 5287 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@stdext@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@0V?$_Temp_iterator@UTRSortElement@@@2@HHUSortTR@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
tv135 = -60						; size = 4
tv134 = -56						; size = 4
$T249934 = -32						; size = 4
__Cat$249921 = -25					; size = 1
$T249916 = -24						; size = 4
$T249912 = -20						; size = 4
$T249911 = -15						; size = 1
$T249910 = -14						; size = 1
$T249909 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T249916[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T249909[ebp], al
	mov	cl, BYTE PTR __Cat$249921[ebp]
	mov	BYTE PTR $T249910[ebp], cl
	movzx	edx, BYTE PTR $T249909[ebp]
	push	edx
	movzx	eax, BYTE PTR $T249910[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T249911[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T249912[ebp], esp
	mov	DWORD PTR $T249934[ebp], edx
	mov	eax, DWORD PTR $T249934[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T249934[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T249934[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T249934[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T249934[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T249934[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T249916[ebp]
	or	ecx, 1
	mov	DWORD PTR $T249916[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z$2:
	mov	eax, DWORD PTR $T249916[ebp]
	and	eax, 1
	je	$LN6@unchecked_@4
	and	DWORD PTR $T249916[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN6@unchecked_@4:
	ret	0
__ehhandler$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
PUBLIC	??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
PUBLIC	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z
_TEXT	SEGMENT
tv180 = -248						; size = 4
tv179 = -244						; size = 4
tv176 = -240						; size = 4
tv175 = -236						; size = 4
$T250337 = -228						; size = 4
$T250336 = -224						; size = 4
$T250335 = -220						; size = 4
$T250313 = -213						; size = 1
$T250312 = -212						; size = 4
$T250311 = -208						; size = 4
$T250310 = -204						; size = 4
$T250315 = -197						; size = 1
$T250274 = -196						; size = 4
$T250273 = -192						; size = 4
__Cat$250267 = -184					; size = 1
$T250265 = -183						; size = 1
$T250264 = -182						; size = 1
$T250263 = -181						; size = 1
$T250249 = -180						; size = 4
$T250245 = -176						; size = 4
$T250241 = -172						; size = 4
$T250240 = -168						; size = 4
__Cat$250234 = -160					; size = 1
$T250232 = -159						; size = 1
$T250231 = -158						; size = 1
$T250230 = -157						; size = 1
$T250183 = -148						; size = 4
$T250170 = -136						; size = 4
$T250169 = -132						; size = 4
$T250143 = -126						; size = 1
$T250142 = -125						; size = 1
$T250141 = -124						; size = 4
$T250140 = -120						; size = 4
$T250139 = -116						; size = 4
$T250124 = -112						; size = 4
__Cat$250149 = -104					; size = 1
$T250147 = -103						; size = 1
$T250146 = -102						; size = 1
$T250145 = -101						; size = 1
$T250091 = -100						; size = 4
$T250087 = -96						; size = 4
$T250083 = -92						; size = 4
$T250082 = -88						; size = 4
__Cat$250076 = -80					; size = 1
$T250074 = -79						; size = 1
$T250073 = -78						; size = 1
$T250072 = -77						; size = 1
$T250025 = -68						; size = 4
$T250008 = -56						; size = 4
$T250007 = -52						; size = 20
$T250006 = -32						; size = 4
$T250005 = -28						; size = 4
$T250004 = -24						; size = 20
$T250003 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T250003[ebp], esp
	mov	DWORD PTR $T250025[ebp], eax
	mov	ecx, DWORD PTR $T250025[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T250025[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T250025[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T250025[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T250025[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T250025[ebp]
	mov	DWORD PTR tv175[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T250004[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv176[ebp], eax
	lea	ecx, DWORD PTR $T250004[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T250083[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T250082[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T250072[ebp], dl
	mov	al, BYTE PTR __Cat$250076[ebp]
	mov	BYTE PTR $T250073[ebp], al
	movzx	ecx, BYTE PTR $T250072[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T250073[ebp]
	push	edx
	movzx	eax, BYTE PTR $T250074[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250083[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T250082[ebp]
	push	eax
	lea	ecx, DWORD PTR $T250005[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250087[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T250091[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T250170[ebp], edx
	mov	eax, DWORD PTR $T250091[ebp]
	mov	DWORD PTR $T250169[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T250145[ebp], cl
	mov	dl, BYTE PTR __Cat$250149[ebp]
	mov	BYTE PTR $T250146[ebp], dl
	mov	al, BYTE PTR $T250145[ebp]
	mov	BYTE PTR $T250143[ebp], al
	mov	cl, BYTE PTR $T250147[ebp]
	mov	BYTE PTR $T250142[ebp], cl
	mov	edx, DWORD PTR $T250170[ebp]
	mov	DWORD PTR $T250141[ebp], edx
	mov	eax, DWORD PTR $T250087[ebp]
	mov	DWORD PTR $T250140[ebp], eax
	mov	ecx, DWORD PTR $T250169[ebp]
	mov	DWORD PTR $T250139[ebp], ecx
$LN56@Buffered_r:
	mov	edx, DWORD PTR $T250139[ebp]
	cmp	edx, DWORD PTR $T250140[ebp]
	je	SHORT $LN55@Buffered_r
	mov	eax, DWORD PTR $T250140[ebp]
	sub	eax, 448				; 000001c0H
	mov	DWORD PTR $T250140[ebp], eax
	mov	ecx, DWORD PTR $T250141[ebp]
	sub	ecx, 448				; 000001c0H
	mov	DWORD PTR $T250141[ebp], ecx
	mov	edx, DWORD PTR $T250141[ebp]
	mov	DWORD PTR $T250124[ebp], edx
	mov	eax, DWORD PTR $T250140[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250124[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR $T250124[ebp]
	mov	edx, DWORD PTR $T250140[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	jmp	SHORT $LN56@Buffered_r
$LN55@Buffered_r:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T250141[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UTRSortElement@@@std@@QAEHXZ ; std::_Temp_iterator<TRSortElement>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T250006[ebp], esp
	mov	DWORD PTR $T250183[ebp], edx
	mov	eax, DWORD PTR $T250183[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T250183[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T250183[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T250183[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T250183[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T250183[ebp]
	mov	DWORD PTR tv179[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T250007[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv180[ebp], eax
	lea	ecx, DWORD PTR $T250007[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T250241[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T250240[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T250230[ebp], cl
	mov	dl, BYTE PTR __Cat$250234[ebp]
	mov	BYTE PTR $T250231[ebp], dl
	movzx	eax, BYTE PTR $T250230[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T250231[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T250232[ebp]
	push	edx
	mov	eax, DWORD PTR $T250241[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250240[ebp]
	push	edx
	lea	eax, DWORD PTR $T250008[ebp]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T250245[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T250249[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T250274[ebp], ecx
	mov	edx, DWORD PTR $T250249[ebp]
	mov	DWORD PTR $T250273[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T250263[ebp], al
	mov	cl, BYTE PTR __Cat$250267[ebp]
	mov	BYTE PTR $T250264[ebp], cl
	movzx	edx, BYTE PTR $T250263[ebp]
	push	edx
	movzx	eax, BYTE PTR $T250264[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T250265[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250274[ebp]
	push	edx
	mov	eax, DWORD PTR $T250245[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250273[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	$LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T250337[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T250336[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T250335[ebp], edx
	mov	eax, DWORD PTR $T250335[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T250336[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN134@Buffered_r
	mov	ecx, DWORD PTR $T250336[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T250337[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN134@Buffered_r
	mov	dl, BYTE PTR $T250315[ebp]
	mov	BYTE PTR $T250313[ebp], dl
	mov	eax, DWORD PTR $T250337[ebp]
	mov	DWORD PTR $T250312[ebp], eax
	mov	ecx, DWORD PTR $T250336[ebp]
	mov	DWORD PTR $T250311[ebp], ecx
	mov	edx, DWORD PTR $T250335[ebp]
	mov	DWORD PTR $T250310[ebp], edx
	push	0
	push	0
	mov	eax, DWORD PTR $T250312[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250311[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250310[ebp]
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN134@Buffered_r:
	mov	eax, DWORD PTR __Count2$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 2701 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00HHAAV?$_Temp_iterator@UTRSortElement@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T250405 = -32						; size = 4
$T250404 = -28						; size = 4
__Vptr$250413 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$250413[ebp], ecx
	mov	edx, DWORD PTR __Vptr$250413[ebp]
	mov	DWORD PTR $T250405[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T250405[ebp], 0
	je	SHORT $LN18@Uninit_cop@4
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250405[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T250405[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	jmp	SHORT $LN19@Uninit_cop@4
$LN18@Uninit_cop@4:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop@4:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T250404[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN26@Uninit_cop@4
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN26@Uninit_cop@4:
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$250413[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250405[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@5

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@5:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$9
__unwindtable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -48						; size = 4
$T250495 = -32						; size = 4
$T250494 = -28						; size = 4
__Vptr$250503 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@6
$LN5@Uninit_cop@6:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@6:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$250503[ebp], ecx
	mov	edx, DWORD PTR __Vptr$250503[ebp]
	mov	DWORD PTR $T250495[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T250495[ebp], 0
	je	SHORT $LN18@Uninit_cop@6
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250495[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	ecx, DWORD PTR $T250495[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	mov	ecx, DWORD PTR $T250495[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	jmp	SHORT $LN19@Uninit_cop@6
$LN18@Uninit_cop@6:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop@6:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T250494[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop@6
$LN4@Uninit_cop@6:
	jmp	SHORT $LN10@Uninit_cop@6
__catch$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@6
$LN2@Uninit_cop@6:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@6:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@6

; 134  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN34@Uninit_cop@6
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Uninit_cop@6:
	jmp	SHORT $LN2@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@6:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$250503[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250495[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUTRSortElement@@PAU1@V?$allocator@UTRSortElement@@@std@@@std@@YAPAUTRSortElement@@PAU1@00AAV?$allocator@UTRSortElement@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<TRSortElement *,TRSortElement *,std::allocator<TRSortElement> >
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv187 = -204						; size = 4
tv186 = -200						; size = 4
tv182 = -196						; size = 4
tv181 = -192						; size = 4
tv177 = -188						; size = 4
tv176 = -184						; size = 4
$T250804 = -144						; size = 4
$T250716 = -124						; size = 4
$T250674 = -112						; size = 4
$T250670 = -108						; size = 4
$T250588 = -100						; size = 20
$T250587 = -80						; size = 4
$T250586 = -76						; size = 20
$T250585 = -56						; size = 4
$T250584 = -52						; size = 20
$T250583 = -32						; size = 4
__Mid1$226033 = -28					; size = 4
__Mid2$226014 = -24					; size = 4
__Mid1$226013 = -20					; size = 4
__Chunk2$226009 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$226009[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$226009[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$226009[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$226013[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Mid1$226013[ebp]
	mov	DWORD PTR __Mid1$226013[ebp], ecx

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$226013[ebp]
	mov	DWORD PTR __Mid2$226014[ebp], edx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Mid2$226014[ebp]
	mov	DWORD PTR __Mid2$226014[ebp], eax

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T250583[ebp], esp
	mov	DWORD PTR $T250670[ebp], edx
	mov	eax, DWORD PTR $T250670[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T250670[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T250670[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T250670[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T250670[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T250670[ebp]
	mov	DWORD PTR tv176[ebp], eax
	mov	ecx, DWORD PTR __Mid2$226014[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$226013[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$226013[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T250584[ebp]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv177[ebp], eax
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T250674[ebp], eax
	mov	ecx, DWORD PTR $T250674[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Dest$[ebp+16], edx
	lea	ecx, DWORD PTR $T250584[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 3443 : 		_First = _Mid2;

	mov	eax, DWORD PTR __Mid2$226014[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 3444 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T250585[ebp], esp
	mov	DWORD PTR $T250716[ebp], edx
	mov	eax, DWORD PTR $T250716[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T250716[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T250716[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T250716[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T250716[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T250716[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T250586[ebp]
	push	eax
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv182[ebp], eax
	lea	ecx, DWORD PTR $T250586[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 3448 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$226033[ebp], ecx

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	imul	edx, 448				; 000001c0H
	add	edx, DWORD PTR __Mid1$226033[ebp]
	mov	DWORD PTR __Mid1$226033[ebp], edx

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T250587[ebp], esp
	mov	DWORD PTR $T250804[ebp], ecx
	mov	edx, DWORD PTR $T250804[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T250804[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T250804[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T250804[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T250804[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T250804[ebp]
	mov	DWORD PTR tv186[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$226033[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$226033[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T250588[ebp]
	push	ecx
	call	??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv187[ebp], eax
	lea	ecx, DWORD PTR $T250588[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN1@Chunked_me:

; 3454 : 		}
; 3455 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@HUSortTR@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V?$_Temp_iterator@UTRSortElement@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,int,SortTR>
PUBLIC	??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251347 = -216						; size = 4
$T251346 = -212						; size = 4
$T251345 = -208						; size = 4
$T251344 = -204						; size = 4
$T251340 = -120						; size = 1
$T251339 = -119						; size = 1
$T251115 = -116						; size = 4
$T251114 = -112						; size = 4
$T251087 = -106						; size = 1
$T251086 = -105						; size = 1
$T251085 = -104						; size = 4
$T251084 = -100						; size = 4
$T251068 = -96						; size = 4
__Cat$251093 = -88					; size = 1
$T251091 = -87						; size = 1
$T251090 = -86						; size = 1
$T251089 = -85						; size = 1
$T251035 = -84						; size = 4
$T251034 = -80						; size = 4
$T251033 = -76						; size = 4
$T251032 = -72						; size = 4
$T251031 = -68						; size = 4
$T251026 = -34						; size = 1
$T251025 = -33						; size = 1
$T250920 = -28						; size = 4
$T250919 = -24						; size = 4
$T250918 = -20						; size = 4
__Mid1$226065 = -16					; size = 4
__Mid2$226048 = -12					; size = 4
__Mid1$226041 = -8					; size = 4
__Chunk2$226037 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$226037[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$226037[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$226037[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me@2

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$226041[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Mid1$226041[ebp]
	mov	DWORD PTR __Mid1$226041[ebp], ecx

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$226041[ebp]
	mov	DWORD PTR __Mid2$226048[ebp], edx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Mid2$226048[ebp]
	mov	DWORD PTR __Mid2$226048[ebp], eax

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251035[ebp], ecx
	mov	edx, DWORD PTR __Mid2$226048[ebp]
	mov	DWORD PTR $T251034[ebp], edx
	mov	eax, DWORD PTR __Mid1$226041[ebp]
	mov	DWORD PTR $T251033[ebp], eax
	mov	ecx, DWORD PTR __Mid1$226041[ebp]
	mov	DWORD PTR $T251032[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T251031[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T251025[ebp], al
	movzx	ecx, BYTE PTR $T251025[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T251026[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251035[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251034[ebp]
	push	edx
	mov	eax, DWORD PTR $T251033[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251032[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251031[ebp]
	push	edx
	lea	eax, DWORD PTR $T250918[ebp]
	push	eax
	call	??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	ecx, DWORD PTR $T250918[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx

; 3443 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$226048[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3444 : 		}

	jmp	$LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251115[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T251114[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T251089[ebp], al
	mov	cl, BYTE PTR __Cat$251093[ebp]
	mov	BYTE PTR $T251090[ebp], cl
	mov	dl, BYTE PTR $T251089[ebp]
	mov	BYTE PTR $T251087[ebp], dl
	mov	al, BYTE PTR $T251091[ebp]
	mov	BYTE PTR $T251086[ebp], al
	mov	ecx, DWORD PTR $T251115[ebp]
	mov	DWORD PTR $T251085[ebp], ecx
	mov	edx, DWORD PTR $T251114[ebp]
	mov	DWORD PTR $T251084[ebp], edx
	jmp	SHORT $LN63@Chunked_me@2
$LN62@Chunked_me@2:
	mov	eax, DWORD PTR $T251085[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR $T251085[ebp], eax
	mov	ecx, DWORD PTR $T251084[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T251084[ebp], ecx
$LN63@Chunked_me@2:
	mov	edx, DWORD PTR $T251084[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN61@Chunked_me@2
	mov	eax, DWORD PTR $T251085[ebp]
	mov	DWORD PTR $T251068[ebp], eax
	mov	ecx, DWORD PTR $T251084[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T251068[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T251068[ebp]
	mov	eax, DWORD PTR $T251084[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+444], ecx
	jmp	SHORT $LN62@Chunked_me@2
$LN61@Chunked_me@2:
	mov	edx, DWORD PTR $T251085[ebp]
	mov	DWORD PTR $T250919[ebp], edx

; 3448 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$226065[ebp], eax

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Mid1$226065[ebp]
	mov	DWORD PTR __Mid1$226065[ebp], ecx

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251347[ebp], edx
	mov	eax, DWORD PTR __Mid1$226065[ebp]
	mov	DWORD PTR $T251346[ebp], eax
	mov	ecx, DWORD PTR __Mid1$226065[ebp]
	mov	DWORD PTR $T251345[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T251344[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T251339[ebp], al
	movzx	ecx, BYTE PTR $T251339[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T251340[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251347[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T251346[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251345[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251344[ebp]
	push	edx
	lea	eax, DWORD PTR $T250920[ebp]
	push	eax
	call	??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
$LN6@Chunked_me@2:

; 3454 : 		}
; 3455 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUSortTR@@@std@@YAXPAUTRSortElement@@0V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@HHUSortTR@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,SortTR>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z$0
__ehfuncinfo$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	ENDS
;	COMDAT ??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
_TEXT	SEGMENT
__Tmp$226069 = -468					; size = 448
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z PROC ; std::swap<TRSortElement>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 476				; 000001dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$226069[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR __Tmp$226069[ebp+444], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 21   : 
; 22   : 		_Left = _Right;

	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+444], ecx

; 23   : 		_Right = _Tmp;

	lea	edx, DWORD PTR __Tmp$226069[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Tmp$226069[ebp+444]
	mov	DWORD PTR [eax+444], ecx

; 24   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$226069[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
$LN2@swap:

; 25   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z$0:
	lea	ecx, DWORD PTR __Tmp$226069[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-480]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$swap@UTRSortElement@@@std@@YAXAAUTRSortElement@@0@Z ENDP ; std::swap<TRSortElement>
PUBLIC	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ; std::_Temp_iterator<TRSortElement>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251441 = -20						; size = 4
$T251412 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T251412[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN15@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __First$[ebp], eax
$LN15@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T251441[ebp], edx
	mov	eax, DWORD PTR $T251441[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ; std::_Temp_iterator<TRSortElement>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T251412[ebp]
	or	ecx, 1
	mov	DWORD PTR $T251412[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:
	mov	eax, DWORD PTR $T251412[ebp]
	and	eax, 1
	je	$LN8@Copy_opt
	and	DWORD PTR $T251412[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN8@Copy_opt:
	ret	0
__ehhandler$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,std::forward_iterator_tag>
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251701 = -68						; size = 4
$T251700 = -64						; size = 4
$T251673 = -58						; size = 1
$T251672 = -57						; size = 1
$T251671 = -56						; size = 4
$T251670 = -52						; size = 4
$T251654 = -48						; size = 4
__Cat$251679 = -32					; size = 1
$T251677 = -31						; size = 1
$T251676 = -30						; size = 1
$T251675 = -29						; size = 1
$T251620 = -28						; size = 4
$T251599 = -16						; size = 4
$T251587 = -12						; size = 4
$T251575 = -8						; size = 4
$T251550 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	$LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last2$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T251575[ebp], eax
	mov	ecx, DWORD PTR $T251575[ebp]
	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR [ecx+444]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+444]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN36@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T251587[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251599[ebp], ecx
	mov	edx, DWORD PTR $T251587[ebp]
	push	edx
	mov	ecx, DWORD PTR $T251599[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T251599[ebp]
	mov	ecx, DWORD PTR $T251587[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __First2$[ebp], eax

; 2600 : 		else

	jmp	SHORT $LN1@Merge

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN36@Merge:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251620[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T251620[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T251620[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	mov	eax, DWORD PTR __First1$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __First1$[ebp], eax
$LN1@Merge:
	jmp	$LN4@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251701[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T251700[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T251675[ebp], al
	mov	cl, BYTE PTR __Cat$251679[ebp]
	mov	BYTE PTR $T251676[ebp], cl
	mov	dl, BYTE PTR $T251675[ebp]
	mov	BYTE PTR $T251673[ebp], dl
	mov	al, BYTE PTR $T251677[ebp]
	mov	BYTE PTR $T251672[ebp], al
	mov	ecx, DWORD PTR $T251701[ebp]
	mov	DWORD PTR $T251671[ebp], ecx
	mov	edx, DWORD PTR $T251700[ebp]
	mov	DWORD PTR $T251670[ebp], edx
	jmp	SHORT $LN58@Merge
$LN57@Merge:
	mov	eax, DWORD PTR $T251671[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR $T251671[ebp], eax
	mov	ecx, DWORD PTR $T251670[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T251670[ebp], ecx
$LN58@Merge:
	mov	edx, DWORD PTR $T251670[ebp]
	cmp	edx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN56@Merge
	mov	eax, DWORD PTR $T251671[ebp]
	mov	DWORD PTR $T251654[ebp], eax
	mov	ecx, DWORD PTR $T251670[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T251654[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T251654[ebp]
	mov	eax, DWORD PTR $T251670[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+444], ecx
	jmp	SHORT $LN57@Merge
$LN56@Merge:
	mov	edx, DWORD PTR $T251671[ebp]
	mov	DWORD PTR $T251550[ebp], edx
	mov	eax, DWORD PTR $T251550[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V23@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@11USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T251971 = -80						; size = 4
$T251950 = -68						; size = 4
$T251930 = -64						; size = 4
$T251918 = -60						; size = 4
$T251901 = -56						; size = 4
$T251900 = -52						; size = 4
$T251899 = -48						; size = 4
__Cat$251894 = -40					; size = 1
$T251892 = -39						; size = 1
$T251891 = -38						; size = 1
$T251890 = -37						; size = 1
$T251875 = -36						; size = 4
$T251874 = -32						; size = 4
$T251848 = -26						; size = 1
$T251847 = -25						; size = 1
$T251846 = -24						; size = 4
$T251845 = -20						; size = 4
$T251844 = -16						; size = 4
$T251829 = -12						; size = 4
__Cat$251855 = -4					; size = 1
$T251853 = -3						; size = 1
$T251852 = -2						; size = 1
$T251851 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

$LN11@Merge_back:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN6@Merge_back

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251875[ebp], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T251874[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T251851[ebp], dl
	mov	al, BYTE PTR __Cat$251855[ebp]
	mov	BYTE PTR $T251852[ebp], al
	mov	cl, BYTE PTR $T251851[ebp]
	mov	BYTE PTR $T251848[ebp], cl
	mov	dl, BYTE PTR $T251853[ebp]
	mov	BYTE PTR $T251847[ebp], dl
	mov	eax, DWORD PTR $T251875[ebp]
	mov	DWORD PTR $T251846[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T251845[ebp], ecx
	mov	edx, DWORD PTR $T251874[ebp]
	mov	DWORD PTR $T251844[ebp], edx
$LN20@Merge_back:
	mov	eax, DWORD PTR $T251844[ebp]
	cmp	eax, DWORD PTR $T251845[ebp]
	je	SHORT $LN19@Merge_back
	mov	ecx, DWORD PTR $T251845[ebp]
	sub	ecx, 448				; 000001c0H
	mov	DWORD PTR $T251845[ebp], ecx
	mov	edx, DWORD PTR $T251846[ebp]
	sub	edx, 448				; 000001c0H
	mov	DWORD PTR $T251846[ebp], edx
	mov	eax, DWORD PTR $T251846[ebp]
	mov	DWORD PTR $T251829[ebp], eax
	mov	ecx, DWORD PTR $T251845[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T251829[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T251829[ebp]
	mov	eax, DWORD PTR $T251845[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+444], ecx
	jmp	SHORT $LN20@Merge_back
$LN19@Merge_back:
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T251846[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251901[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T251900[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T251899[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T251890[ebp], dl
	mov	al, BYTE PTR __Cat$251894[ebp]
	mov	BYTE PTR $T251891[ebp], al
	movzx	ecx, BYTE PTR $T251890[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T251891[ebp]
	push	edx
	movzx	eax, BYTE PTR $T251892[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251901[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251900[ebp]
	push	edx
	mov	eax, DWORD PTR $T251899[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN4@Merge_back:

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	edx, DWORD PTR __Last2$[ebp]
	sub	edx, 448				; 000001c0H
	mov	DWORD PTR __Last2$[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	sub	eax, 448				; 000001c0H
	mov	DWORD PTR __Last1$[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T251918[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	eax, DWORD PTR $T251918[ebp]
	mov	ecx, DWORD PTR [edx+444]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+444]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Merge_back

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T251930[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251950[ebp], eax
	mov	ecx, DWORD PTR $T251930[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T251950[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T251950[ebp]
	mov	eax, DWORD PTR $T251930[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+444], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __Last2$[ebp], edx

; 2847 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251971[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T251971[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T251971[ebp]
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Last1$[ebp], eax
$LN5@Merge_back:
	jmp	$LN11@Merge_back
$LN9@Merge_back:

; 2849 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@PAUTRSortElement@@V12@USortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0PAUTRSortElement@@10USortTR@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z
_TEXT	SEGMENT
$T252059 = -36						; size = 4
$T252017 = -28						; size = 4
$T252004 = -24						; size = 4
$T252003 = -20						; size = 4
__Count2$226123 = -12					; size = 4
__Mid$226124 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>, COMDAT

; 2288 : 	{	// find first element not before _Val, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2292 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T252017[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T252004[ebp], ecx
	mov	edx, DWORD PTR $T252017[ebp]
	mov	DWORD PTR $T252003[ebp], edx
	mov	eax, DWORD PTR $T252004[ebp]
	sub	eax, DWORD PTR $T252003[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$226123[ebp], eax

; 2296 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$226124[ebp], edx

; 2297 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$226123[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Mid$226124[ebp]
	mov	DWORD PTR __Mid$226124[ebp], eax

; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	mov	ecx, DWORD PTR __Mid$226124[ebp]
	mov	DWORD PTR $T252059[ebp], ecx
	mov	edx, DWORD PTR $T252059[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+444]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+444]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$226124[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __Mid$226124[ebp], ecx
	mov	edx, DWORD PTR __Mid$226124[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$226123[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$226123[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Lower_boun:

; 2304 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2305 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2306 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z
_TEXT	SEGMENT
$T252150 = -36						; size = 4
$T252108 = -28						; size = 4
$T252095 = -24						; size = 4
$T252094 = -20						; size = 4
__Count2$226133 = -12					; size = 4
__Mid$226134 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>, COMDAT

; 2359 : 	{	// find first element that _Val is before, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2363 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T252108[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T252095[ebp], ecx
	mov	edx, DWORD PTR $T252108[ebp]
	mov	DWORD PTR $T252094[ebp], edx
	mov	eax, DWORD PTR $T252095[ebp]
	sub	eax, DWORD PTR $T252094[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$226133[ebp], eax

; 2367 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$226134[ebp], edx

; 2368 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$226133[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Mid$226134[ebp]
	mov	DWORD PTR __Mid$226134[ebp], eax

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	mov	ecx, DWORD PTR __Mid$226134[ebp]
	mov	DWORD PTR $T252150[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T252150[ebp]
	mov	ecx, DWORD PTR [edx+444]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+444]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$226134[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __Mid$226134[ebp], ecx
	mov	edx, DWORD PTR __Mid$226134[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$226133[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$226133[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Upper_boun:

; 2375 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2376 : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2377 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@UTRSortElement@@HUSortTR@@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@0ABUTRSortElement@@USortTR@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,TRSortElement,int,SortTR>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T252298 = -70						; size = 1
$T252297 = -69						; size = 1
$T252296 = -68						; size = 4
$T252295 = -64						; size = 4
$T252294 = -60						; size = 4
$T252266 = -56						; size = 4
$T252208 = -12						; size = 4
__Cat$252169 = -4					; size = 1
$T252166 = -3						; size = 1
$T252165 = -2						; size = 1
$T252164 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T252164[ebp], al
	mov	cl, BYTE PTR __Cat$252169[ebp]
	mov	BYTE PTR $T252165[ebp], cl
	mov	dl, BYTE PTR $T252164[ebp]
	mov	BYTE PTR $T252298[ebp], dl
	mov	al, BYTE PTR $T252166[ebp]
	mov	BYTE PTR $T252297[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T252296[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T252295[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T252294[ebp], eax
	jmp	SHORT $LN20@unchecked_@5
$LN8@unchecked_@5:
	mov	ecx, DWORD PTR $T252296[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T252296[ebp], ecx
	mov	edx, DWORD PTR $T252294[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR $T252294[ebp], edx
$LN20@unchecked_@5:
	mov	eax, DWORD PTR $T252294[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T252295[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN7@unchecked_@5
	mov	ecx, DWORD PTR $T252294[ebp]
	mov	DWORD PTR $T252208[ebp], ecx
	mov	edx, DWORD PTR $T252296[ebp]
	mov	DWORD PTR $T252266[ebp], edx
	mov	eax, DWORD PTR $T252208[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252266[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR $T252266[ebp]
	mov	edx, DWORD PTR $T252208[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	jmp	SHORT $LN8@unchecked_@5
$LN7@unchecked_@5:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T252296[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z$0
__ehfuncinfo$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z
_TEXT	SEGMENT
tv164 = -72						; size = 4
_this$ = -68						; size = 4
$T252350 = -48						; size = 4
$T252349 = -44						; size = 4
__Vptr$252358 = -40					; size = 4
$T252313 = -36						; size = 4
__Ptr$226295 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z PROC ; std::_Temp_iterator<TRSortElement>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@8

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T252313[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T252313[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T252313[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx

; 565  : 		else

	jmp	$LN1@operator@8
$LN2@operator@8:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Ptr$226295[ebp], edx

; 569  : 			_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$226295[ebp]
	mov	DWORD PTR __Vptr$252358[ebp], eax
	mov	ecx, DWORD PTR __Vptr$252358[ebp]
	mov	DWORD PTR $T252350[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T252350[ebp], 0
	je	SHORT $LN25@operator@8
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T252350[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR $T252350[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	mov	eax, DWORD PTR $T252350[ebp]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN26@operator@8
$LN25@operator@8:
	mov	DWORD PTR tv164[ebp], 0
$LN26@operator@8:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T252349[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 448				; 000001c0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], edx
$LN1@operator@8:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z$0:
	mov	eax, DWORD PTR __Vptr$252358[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252350[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ENDP ; std::_Temp_iterator<TRSortElement>::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T252457 = -48						; size = 4
$T252391 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

$LN5@Copy_backw:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 448				; 000001c0H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T252391[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T252457[ebp], ecx
	mov	edx, DWORD PTR $T252391[ebp]
	push	edx
	mov	ecx, DWORD PTR $T252457[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T252457[ebp]
	mov	ecx, DWORD PTR $T252391[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	jmp	SHORT $LN5@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$0
__ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
_TEXT	SEGMENT
tv135 = -60						; size = 4
tv134 = -56						; size = 4
$T252480 = -32						; size = 4
$T252466 = -24						; size = 4
$T252462 = -20						; size = 4
$T252461 = -14						; size = 1
$T252460 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T252466[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T252460[ebp], al
	movzx	ecx, BYTE PTR $T252460[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T252461[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T252462[ebp], esp
	mov	DWORD PTR $T252480[ebp], ecx
	mov	edx, DWORD PTR $T252480[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T252480[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T252480[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T252480[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T252480[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T252480[ebp]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>
	add	esp, 52					; 00000034H
	mov	DWORD PTR tv135[ebp], eax
	mov	edx, DWORD PTR $T252466[ebp]
	or	edx, 1
	mov	DWORD PTR $T252466[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z$2:
	mov	eax, DWORD PTR $T252466[ebp]
	and	eax, 1
	je	$LN6@unchecked_@6
	and	DWORD PTR $T252466[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN6@unchecked_@6:
	ret	0
__ehhandler$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@000V12@USortTR@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T252639 = -48						; size = 4
$T252581 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN14@Copy_opt@2
$LN2@Copy_opt@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __First$[ebp], ecx
$LN14@Copy_opt@2:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T252581[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T252639[ebp], ecx
	mov	edx, DWORD PTR $T252581[ebp]
	push	edx
	mov	ecx, DWORD PTR $T252639[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T252639[ebp]
	mov	ecx, DWORD PTR $T252581[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T252707 = -44						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@3
$LN2@Copy_opt@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@3:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@3

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T252707[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T252707[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T252707[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+444], ecx
	jmp	SHORT $LN2@Copy_opt@3
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUTRSortElement@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::random_access_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv197 = -160						; size = 4
tv196 = -156						; size = 4
tv192 = -152						; size = 4
tv191 = -148						; size = 4
$T252919 = -124						; size = 4
$T252864 = -108						; size = 4
$T252860 = -104						; size = 4
$T252811 = -80						; size = 4
$T252768 = -56						; size = 4
$T252756 = -52						; size = 4
$T252747 = -48						; size = 4
$T252718 = -44						; size = 4
$T252712 = -40						; size = 4
$T252711 = -36						; size = 20
$T252710 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T252718[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

$LN16@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last2$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T252747[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T252756[ebp], eax
	mov	ecx, DWORD PTR $T252756[ebp]
	mov	edx, DWORD PTR $T252747[ebp]
	mov	eax, DWORD PTR [ecx+444]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+444]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN59@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T252768[ebp], eax
	mov	ecx, DWORD PTR $T252768[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ; std::_Temp_iterator<TRSortElement>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __First2$[ebp], edx

; 2600 : 		else

	jmp	SHORT $LN1@Merge@2

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN59@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T252811[ebp], eax
	mov	ecx, DWORD PTR $T252811[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UTRSortElement@@@std@@QAEAAV01@ABUTRSortElement@@@Z ; std::_Temp_iterator<TRSortElement>::operator=
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@2:
	jmp	$LN16@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T252710[ebp], esp
	mov	DWORD PTR $T252860[ebp], eax
	mov	ecx, DWORD PTR $T252860[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T252860[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T252860[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T252860[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T252860[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T252860[ebp]
	mov	DWORD PTR tv191[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252711[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv192[ebp], eax
	mov	edx, DWORD PTR tv192[ebp]
	mov	DWORD PTR $T252864[ebp], edx
	mov	eax, DWORD PTR $T252864[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	lea	ecx, DWORD PTR $T252711[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T252712[ebp], esp
	mov	DWORD PTR $T252919[ebp], edx
	mov	eax, DWORD PTR $T252919[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T252919[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T252919[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T252919[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T252919[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T252919[ebp]
	mov	DWORD PTR tv196[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$unchecked_copy@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V?$_Temp_iterator@UTRSortElement@@@2@@stdext@@YA?AV?$_Temp_iterator@UTRSortElement@@@std@@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv197[ebp], eax
	mov	ecx, DWORD PTR $T252718[ebp]
	or	ecx, 1
	mov	DWORD PTR $T252718[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
__unwindfunclet$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$4:
	mov	eax, DWORD PTR $T252718[ebp]
	and	eax, 1
	je	$LN13@Merge@2
	and	DWORD PTR $T252718[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$_Temp_iterator@UTRSortElement@@@std@@QAE@XZ ; std::_Temp_iterator<TRSortElement>::~_Temp_iterator<TRSortElement>
$LN13@Merge@2:
	ret	0
__ehhandler$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@V12@V?$_Temp_iterator@UTRSortElement@@@2@USortTR@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@UTRSortElement@@@0@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@000V10@USortTR@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,std::_Temp_iterator<TRSortElement>,SortTR,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T253185 = -92						; size = 4
$T253184 = -88						; size = 4
$T253157 = -82						; size = 1
$T253156 = -81						; size = 1
$T253155 = -80						; size = 4
$T253154 = -76						; size = 4
$T253138 = -72						; size = 4
__Cat$253163 = -64					; size = 1
$T253161 = -63						; size = 1
$T253160 = -62						; size = 1
$T253159 = -61						; size = 1
$T253105 = -60						; size = 4
$T253104 = -56						; size = 4
$T253077 = -50						; size = 1
$T253076 = -49						; size = 1
$T253075 = -48						; size = 4
$T253074 = -44						; size = 4
$T253058 = -40						; size = 4
__Cat$253084 = -24					; size = 1
$T253081 = -23						; size = 1
$T253080 = -22						; size = 1
$T253079 = -21						; size = 1
$T253024 = -20						; size = 4
$T253011 = -8						; size = 4
$T252988 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge@3
$LN4@Merge@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 448				; 000001c0H
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge@3:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	$LN3@Merge@3
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	$LN3@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+444]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+444]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T253011[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253011[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR $T253011[ebp]
	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __First2$[ebp], ecx

; 2600 : 		else

	jmp	SHORT $LN1@Merge@3

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN20@Merge@3:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T253024[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253024[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	ecx, DWORD PTR $T253024[ebp]
	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR [ecx+444], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@3:
	jmp	$LN4@Merge@3
$LN3@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T253105[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T253104[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T253079[ebp], cl
	mov	dl, BYTE PTR __Cat$253084[ebp]
	mov	BYTE PTR $T253080[ebp], dl
	mov	al, BYTE PTR $T253079[ebp]
	mov	BYTE PTR $T253077[ebp], al
	mov	cl, BYTE PTR $T253081[ebp]
	mov	BYTE PTR $T253076[ebp], cl
	mov	edx, DWORD PTR $T253105[ebp]
	mov	DWORD PTR $T253075[ebp], edx
	mov	eax, DWORD PTR $T253104[ebp]
	mov	DWORD PTR $T253074[ebp], eax
	jmp	SHORT $LN42@Merge@3
$LN41@Merge@3:
	mov	ecx, DWORD PTR $T253075[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T253075[ebp], ecx
	mov	edx, DWORD PTR $T253074[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR $T253074[ebp], edx
$LN42@Merge@3:
	mov	eax, DWORD PTR $T253074[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN40@Merge@3
	mov	ecx, DWORD PTR $T253075[ebp]
	mov	DWORD PTR $T253058[ebp], ecx
	mov	edx, DWORD PTR $T253074[ebp]
	push	edx
	mov	ecx, DWORD PTR $T253058[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T253058[ebp]
	mov	ecx, DWORD PTR $T253074[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	jmp	SHORT $LN41@Merge@3
$LN40@Merge@3:
	mov	eax, DWORD PTR $T253075[ebp]
	mov	DWORD PTR $T252988[ebp], eax
	mov	ecx, DWORD PTR $T252988[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T253185[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T253184[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T253159[ebp], cl
	mov	dl, BYTE PTR __Cat$253163[ebp]
	mov	BYTE PTR $T253160[ebp], dl
	mov	al, BYTE PTR $T253159[ebp]
	mov	BYTE PTR $T253157[ebp], al
	mov	cl, BYTE PTR $T253161[ebp]
	mov	BYTE PTR $T253156[ebp], cl
	mov	edx, DWORD PTR $T253185[ebp]
	mov	DWORD PTR $T253155[ebp], edx
	mov	eax, DWORD PTR $T253184[ebp]
	mov	DWORD PTR $T253154[ebp], eax
	jmp	SHORT $LN71@Merge@3
$LN70@Merge@3:
	mov	ecx, DWORD PTR $T253155[ebp]
	add	ecx, 448				; 000001c0H
	mov	DWORD PTR $T253155[ebp], ecx
	mov	edx, DWORD PTR $T253154[ebp]
	add	edx, 448				; 000001c0H
	mov	DWORD PTR $T253154[ebp], edx
$LN71@Merge@3:
	mov	eax, DWORD PTR $T253154[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	je	SHORT $LN69@Merge@3
	mov	ecx, DWORD PTR $T253155[ebp]
	mov	DWORD PTR $T253138[ebp], ecx
	mov	edx, DWORD PTR $T253154[ebp]
	push	edx
	mov	ecx, DWORD PTR $T253138[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	eax, DWORD PTR $T253138[ebp]
	mov	ecx, DWORD PTR $T253154[ebp]
	mov	edx, DWORD PTR [ecx+444]
	mov	DWORD PTR [eax+444], edx
	jmp	SHORT $LN70@Merge@3
$LN69@Merge@3:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T253155[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAUTRSortElement@@PAU1@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@USortTR@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@PAUTRSortElement@@000V10@USortTR@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<TRSortElement *,TRSortElement *,std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,SortTR,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z$0
__ehfuncinfo$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
_TEXT	SEGMENT
tv197 = -588						; size = 4
tv152 = -584						; size = 4
$T253379 = -568						; size = 4
__Tmp$253360 = -556					; size = 4
$T253349 = -552						; size = 4
__Tmp$253335 = -548					; size = 4
$T253316 = -544						; size = 4
$T253304 = -540						; size = 4
__Tmp$253282 = -536					; size = 4
__Tmp$253264 = -532					; size = 4
$T253248 = -528						; size = 4
__Tmp$253239 = -524					; size = 4
$T253196 = -520						; size = 4
$T253195 = -516						; size = 4
$T253194 = -512						; size = 4
$T253191 = -508						; size = 4
$T253190 = -504						; size = 4
$T253189 = -500						; size = 4
__Hole$226523 = -496					; size = 4
__Holeval$226526 = -492					; size = 448
__$ArrayPad$ = -40					; size = 4
__Next1$226527 = -36					; size = 4
__Next$226525 = -32					; size = 4
__Tmp$226518 = -28					; size = 4
__Factor$226514 = -24					; size = 4
__Shift$ = -20						; size = 4
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z PROC ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 576				; 00000240H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR __Count$[ebp], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$226514[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$226514[ebp], 0
	je	SHORT $LN24@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$226514[ebp]
	mov	DWORD PTR __Tmp$226518[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$226514[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$226518[ebp]
	mov	DWORD PTR __Factor$226514[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

$LN24@Rotate:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	cmp	DWORD PTR __Count$[ebp], eax
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$253239[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Tmp$253239[ebp]
	mov	DWORD PTR __Tmp$253239[ebp], ecx
	mov	edx, DWORD PTR __Tmp$253239[ebp]
	mov	DWORD PTR __Hole$226523[ebp], edx

; 1695 : 			_RanIt _Next = _Hole;

	mov	eax, DWORD PTR __Hole$226523[ebp]
	mov	DWORD PTR __Next$226525[ebp], eax

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR __Hole$226523[ebp]
	mov	DWORD PTR $T253248[ebp], ecx
	mov	edx, DWORD PTR $T253248[ebp]
	push	edx
	lea	ecx, DWORD PTR __Holeval$226526[ebp]
	call	??0TradeConnection@@QAE@ABU0@@Z
	mov	eax, DWORD PTR $T253248[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR __Holeval$226526[ebp+444], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	edx, DWORD PTR __Next$226525[ebp]
	mov	DWORD PTR __Tmp$253264[ebp], edx
	mov	eax, DWORD PTR __Shift$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Tmp$253264[ebp]
	mov	DWORD PTR __Tmp$253264[ebp], eax
	mov	ecx, DWORD PTR __Tmp$253264[ebp]
	mov	DWORD PTR $T253190[ebp], ecx
	mov	edx, DWORD PTR $T253190[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@Rotate
	lea	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv152[ebp], edx
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	eax, DWORD PTR __Next$226525[ebp]
	mov	DWORD PTR __Tmp$253282[ebp], eax
	mov	ecx, DWORD PTR __Shift$[ebp]
	imul	ecx, 448				; 000001c0H
	add	ecx, DWORD PTR __Tmp$253282[ebp]
	mov	DWORD PTR __Tmp$253282[ebp], ecx
	mov	edx, DWORD PTR __Tmp$253282[ebp]
	mov	DWORD PTR $T253191[ebp], edx
	lea	eax, DWORD PTR $T253191[ebp]
	mov	DWORD PTR tv152[ebp], eax
$LN12@Rotate:
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR $T253189[ebp], ecx
	mov	edx, DWORD PTR $T253189[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Next1$226527[ebp], eax

; 1698 : 			while (_Next1 != _Hole)

$LN55@Rotate:
	mov	ecx, DWORD PTR __Next1$226527[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Hole$226523[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN89@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$226527[ebp]
	mov	DWORD PTR $T253304[ebp], edx
	mov	eax, DWORD PTR __Next$226525[ebp]
	mov	DWORD PTR $T253316[ebp], eax
	mov	ecx, DWORD PTR $T253304[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T253316[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T253316[ebp]
	mov	eax, DWORD PTR $T253304[ebp]
	mov	ecx, DWORD PTR [eax+444]
	mov	DWORD PTR [edx+444], ecx

; 1701 : 				_Next = _Next1;

	mov	edx, DWORD PTR __Next1$226527[ebp]
	mov	DWORD PTR __Next$226525[ebp], edx

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$226527[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	cmp	DWORD PTR __Shift$[ebp], eax
	jge	SHORT $LN81@Rotate
	mov	edx, DWORD PTR __Next1$226527[ebp]
	mov	DWORD PTR __Tmp$253335[ebp], edx
	mov	eax, DWORD PTR __Shift$[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Tmp$253335[ebp]
	mov	DWORD PTR __Tmp$253335[ebp], eax
	mov	ecx, DWORD PTR __Tmp$253335[ebp]
	mov	DWORD PTR $T253195[ebp], ecx
	lea	edx, DWORD PTR $T253195[ebp]
	mov	DWORD PTR tv197[ebp], edx
	jmp	SHORT $LN14@Rotate
$LN81@Rotate:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$226527[ebp]
	cdq
	mov	ecx, 448				; 000001c0H
	idiv	ecx
	mov	DWORD PTR $T253349[ebp], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$253360[ebp], edx
	mov	eax, DWORD PTR __Shift$[ebp]
	sub	eax, DWORD PTR $T253349[ebp]
	imul	eax, 448				; 000001c0H
	add	eax, DWORD PTR __Tmp$253360[ebp]
	mov	DWORD PTR __Tmp$253360[ebp], eax
	mov	ecx, DWORD PTR __Tmp$253360[ebp]
	mov	DWORD PTR $T253196[ebp], ecx
	lea	edx, DWORD PTR $T253196[ebp]
	mov	DWORD PTR tv197[ebp], edx
$LN14@Rotate:
	mov	eax, DWORD PTR tv197[ebp]
	mov	DWORD PTR $T253194[ebp], eax
	mov	ecx, DWORD PTR $T253194[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next1$226527[ebp], edx

; 1704 : 				}

	jmp	$LN55@Rotate

; 1705 : 			*_Next = _Holeval;

$LN89@Rotate:
	mov	eax, DWORD PTR __Next$226525[ebp]
	mov	DWORD PTR $T253379[ebp], eax
	lea	ecx, DWORD PTR __Holeval$226526[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T253379[ebp]
	call	??4TradeConnection@@QAEAAU0@ABU0@@Z
	mov	edx, DWORD PTR $T253379[ebp]
	mov	eax, DWORD PTR __Holeval$226526[ebp+444]
	mov	DWORD PTR [edx+444], eax

; 1706 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Holeval$226526[ebp+44]
	call	??1?$FStaticVector@UTradeConnectionPlot@@$0CI@$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<TradeConnectionPlot,40,0,297,0>::~FStaticVector<TradeConnectionPlot,40,0,297,0>
	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z$0:
	lea	ecx, DWORD PTR __Holeval$226526[ebp]
	jmp	??1TRSortElement@@QAE@XZ
__ehhandler$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-580]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Rotate@V?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@std@@HUTRSortElement@@@std@@YAXV?$_Vector_iterator@UTRSortElement@@V?$allocator@UTRSortElement@@@std@@@0@00PAHPAUTRSortElement@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<TRSortElement,std::allocator<TRSortElement> >,int,TRSortElement>
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T253433 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T253433[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T253433[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
EXTRN	?isDebugMode@CvGame@@QBE_NXZ:PROC		; CvGame::isDebugMode
; Function compile flags: /Odtp
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiOffset$253443 = -8					; size = 4
$T253439 = -4						; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 611  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		if(bDebug && GC.getGame().isDebugMode())

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	je	SHORT $LN1@isRevealed
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253439[ebp], ecx
	mov	ecx, DWORD PTR $T253439[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@isRevealed

; 613  : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isRevealed
$LN1@isRevealed:

; 614  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 615  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 616  : 		return m_bfRevealed.GetBit(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$253443[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$253443[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$253443[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
$LN2@isRevealed:

; 617  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isRevealed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T253457 = -8						; size = 4
$T253453 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T253453[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T253453[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T253457[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T253457[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T253489 = -30						; size = 1
$T253476 = -29						; size = 1
$T253472 = -28						; size = 4
$T253465 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T253489[ebp]
	mov	DWORD PTR $T253465[ebp], eax
	lea	ecx, DWORD PTR $T253476[ebp]
	mov	DWORD PTR $T253472[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$253613 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$253613[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$253613[ebp], 0
	jbe	SHORT $LN11@Buy@4
	mov	eax, DWORD PTR __Count$253613[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@4
$LN11@Buy@4:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@4:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@4:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T253679 = -28						; size = 4
$T253678 = -24						; size = 4
$T253674 = -20						; size = 4
$T253673 = -16						; size = 4
$T253662 = -12						; size = 4
$T253661 = -8						; size = 4
__Cat$253669 = -2					; size = 1
$T253667 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T253674[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T253673[ebp], ecx
	mov	edx, DWORD PTR $T253674[ebp]
	mov	DWORD PTR $T253662[ebp], edx
	mov	eax, DWORD PTR $T253673[ebp]
	mov	DWORD PTR $T253661[ebp], eax
	mov	cl, BYTE PTR __Cat$253669[ebp]
	mov	BYTE PTR $T253667[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T253679[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T253678[ebp], eax
	mov	ecx, DWORD PTR $T253678[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T253697 = -80						; size = 28
$T253696 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T253697[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T253696[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T253696[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T253697[ebp]
	push	eax
	lea	ecx, DWORD PTR $T253696[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T253696[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T253696[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T253697[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T253697[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T253696[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T253722 = -16						; size = 4
$T253718 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T253722[ebp], 0
	lea	eax, DWORD PTR $T253722[ebp]
	push	eax
	lea	ecx, DWORD PTR $T253718[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T253718[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T253718[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2
__ehfuncinfo$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T253785 = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1957 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1958 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1959 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T253785[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T253785[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T253785[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T253887 = -52						; size = 4
$T253876 = -48						; size = 4
$T253875 = -44						; size = 4
__Cat$253883 = -40					; size = 1
$T253881 = -39						; size = 1
__Ptr$210227 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$210227[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T253887[ebp], edx
	mov	eax, DWORD PTR $T253887[ebp]
	mov	DWORD PTR $T253876[ebp], eax
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR $T253875[ebp], ecx
	mov	dl, BYTE PTR __Cat$253883[ebp]
	mov	BYTE PTR $T253881[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T253943 = -24						; size = 4
$T253923 = -20						; size = 4
$T253901 = -16						; size = 4
$T253926 = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1995 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1996 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253901[ebp], ecx
	mov	edx, DWORD PTR $T253901[ebp]
	mov	DWORD PTR $T253926[ebp], edx
	mov	eax, DWORD PTR $T253926[ebp]
	mov	DWORD PTR $T253923[ebp], eax
	mov	ecx, DWORD PTR $T253923[ebp]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], 0

; 1997 : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN1@end

; 1998 : 			_Tmp += _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T253943[ebp], ecx
	mov	edx, DWORD PTR $T253943[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN1@end:

; 1999 : 		return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2000 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
PUBLIC	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -372						; size = 4
__Tmp$254460 = -368					; size = 8
$T254439 = -360						; size = 4
$T254417 = -356						; size = 4
$T254442 = -352						; size = 4
$T254282 = -228						; size = 4
$T254260 = -224						; size = 4
$T254284 = -220						; size = 4
$T254248 = -216						; size = 8
$T254247 = -208						; size = 8
$T254246 = -200						; size = 8
__Cat$254241 = -164					; size = 1
$T254239 = -163						; size = 1
$T254238 = -162						; size = 1
$T254237 = -161						; size = 1
$T254093 = -136						; size = 4
$T254071 = -132						; size = 4
$T254095 = -128						; size = 4
$T253949 = -60						; size = 8
$T253948 = -52						; size = 8
$T253947 = -44						; size = 8
$T253946 = -36						; size = 8
__Off$ = -28						; size = 4
__Last$ = -24						; size = 8
__First$ = -16						; size = 8
__Next$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2221 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	mov	DWORD PTR _this$[ebp], ecx

; 2222 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2223 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2224 : 		size_type _Off = _First - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T254071[ebp], ecx
	mov	edx, DWORD PTR $T254071[ebp]
	mov	DWORD PTR $T254095[ebp], edx
	mov	eax, DWORD PTR $T254095[ebp]
	mov	DWORD PTR $T254093[ebp], eax
	mov	ecx, DWORD PTR $T254093[ebp]
	mov	DWORD PTR $T253946[ebp], ecx
	mov	DWORD PTR $T253946[ebp+4], 0
	mov	edx, DWORD PTR __First$[ebp]
	sub	edx, DWORD PTR $T253946[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __First$[ebp+4]
	sub	edx, DWORD PTR $T253946[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2225 : 
; 2226 :  #if _HAS_ITERATOR_DEBUGGING
; 2227 : 		if (_Last < _First || end() < _Last)
; 2228 : 			_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2229 : 		iterator _Next = std::copy(_Last, end(), _First);
; 2230 : 		size_type _Newsize = _Next - begin();
; 2231 : 		_Orphan_range(_Newsize, _Mysize);
; 2232 : 		_Trim(_Newsize);
; 2233 : 
; 2234 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 2235 : 		iterator _Next = std::copy(_Last, end(), _First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T254248[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T254248[ebp+4], ecx
	lea	edx, DWORD PTR $T253947[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T254247[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T254247[ebp+4], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T254246[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR $T254246[ebp+4], ecx
	xor	edx, edx
	mov	BYTE PTR $T254237[ebp], dl
	mov	al, BYTE PTR __Cat$254241[ebp]
	mov	BYTE PTR $T254238[ebp], al
	movzx	ecx, BYTE PTR $T254237[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T254238[ebp]
	push	edx
	movzx	eax, BYTE PTR $T254239[ebp]
	push	eax
	mov	ecx, DWORD PTR $T254248[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T254248[ebp]
	push	edx
	mov	eax, DWORD PTR $T254247[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T254247[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254246[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T254246[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H

; 2236 : 		_Trim(_Next - begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T254260[ebp], eax
	mov	ecx, DWORD PTR $T254260[ebp]
	mov	DWORD PTR $T254284[ebp], ecx
	mov	edx, DWORD PTR $T254284[ebp]
	mov	DWORD PTR $T254282[ebp], edx
	mov	eax, DWORD PTR $T254282[ebp]
	mov	DWORD PTR $T253948[ebp], eax
	mov	DWORD PTR $T253948[ebp+4], 0
	mov	ecx, DWORD PTR __Next$[ebp]
	sub	ecx, DWORD PTR $T253948[ebp]
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Next$[ebp+4]
	sub	ecx, DWORD PTR $T253948[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2237 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2238 : 
; 2239 : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T254417[ebp], eax
	mov	ecx, DWORD PTR $T254417[ebp]
	mov	DWORD PTR $T254442[ebp], ecx
	mov	edx, DWORD PTR $T254442[ebp]
	mov	DWORD PTR $T254439[ebp], edx
	mov	eax, DWORD PTR $T254439[ebp]
	mov	DWORD PTR $T253949[ebp], eax
	mov	DWORD PTR $T253949[ebp+4], 0
	mov	ecx, DWORD PTR $T253949[ebp]
	mov	edx, DWORD PTR $T253949[ebp+4]
	mov	DWORD PTR __Tmp$254460[ebp], ecx
	mov	DWORD PTR __Tmp$254460[ebp+4], edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$254460[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$254460[ebp]
	mov	edx, DWORD PTR __Tmp$254460[ebp+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2240 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T254497 = -30						; size = 1
$T254484 = -29						; size = 1
$T254480 = -28						; size = 4
$T254473 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T254497[ebp]
	mov	DWORD PTR $T254473[ebp], eax
	lea	ecx, DWORD PTR $T254484[ebp]
	mov	DWORD PTR $T254480[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T254659 = -44						; size = 4
$T254636 = -40						; size = 4
$T254614 = -36						; size = 4
$T254639 = -32						; size = 4
$T254587 = -28						; size = 4
$T254565 = -24						; size = 4
$T254590 = -20						; size = 4
$T254553 = -16						; size = 8
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2011 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2012 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T254565[ebp], ecx
	mov	edx, DWORD PTR $T254565[ebp]
	mov	DWORD PTR $T254590[ebp], edx
	mov	eax, DWORD PTR $T254590[ebp]
	mov	DWORD PTR $T254587[ebp], eax
	mov	ecx, DWORD PTR $T254587[ebp]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], 0

; 2013 : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN1@Make_iter

; 2014 : 			_Tmp += _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T254614[ebp], ecx
	mov	edx, DWORD PTR $T254614[ebp]
	mov	DWORD PTR $T254639[ebp], edx
	mov	eax, DWORD PTR $T254639[ebp]
	mov	DWORD PTR $T254636[ebp], eax
	mov	ecx, DWORD PTR $T254636[ebp]
	mov	DWORD PTR $T254553[ebp], ecx
	mov	DWORD PTR $T254553[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T254553[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T254553[ebp+4]
	mov	DWORD PTR $T254659[ebp], edx
	mov	eax, DWORD PTR $T254659[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN1@Make_iter:

; 2015 : 		return (_Tmp);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv142 = -188						; size = 4
tv149 = -184						; size = 4
tv158 = -180						; size = 4
_this$ = -176						; size = 4
__Tmp$254756 = -120					; size = 4
$T254739 = -116						; size = 4
$T254723 = -112						; size = 4
$T254713 = -108						; size = 4
__Count$254695 = -36					; size = 4
__Maxsize$254688 = -32					; size = 4
$T254667 = -28						; size = 4
$T254666 = -24						; size = 4
$T254665 = -20						; size = 4
$T254664 = -16						; size = 4
$T254663 = -12						; size = 4
$T254662 = -8						; size = 4
__Words$ = -4						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 2360 : 		{	// trim base vector to exact length in bits

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	DWORD PTR _this$[ebp], ecx

; 2361 : 		if (max_size() < _Size)

	mov	DWORD PTR __Count$254695[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$254695[ebp], 0
	jbe	SHORT $LN14@Trim
	mov	eax, DWORD PTR __Count$254695[ebp]
	mov	DWORD PTR tv158[ebp], eax
	jmp	SHORT $LN10@Trim
$LN14@Trim:
	mov	DWORD PTR tv158[ebp], 1
$LN10@Trim:
	mov	ecx, DWORD PTR tv158[ebp]
	mov	DWORD PTR __Maxsize$254688[ebp], ecx
	cmp	DWORD PTR __Maxsize$254688[ebp], 134217727 ; 07ffffffH
	jae	SHORT $LN8@Trim
	mov	edx, DWORD PTR __Maxsize$254688[ebp]
	shl	edx, 5
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN6@Trim
$LN8@Trim:
	mov	DWORD PTR tv149[ebp], -1
$LN6@Trim:
	mov	eax, DWORD PTR tv149[ebp]
	cmp	eax, DWORD PTR __Size$[ebp]
	jae	SHORT $LN22@Trim

; 2362 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen

; 2363 : 		size_type _Words = _Nw(_Size);

$LN22@Trim:
	mov	ecx, DWORD PTR __Size$[ebp]
	add	ecx, 31					; 0000001fH
	shr	ecx, 5
	mov	DWORD PTR __Words$[ebp], ecx

; 2364 : 
; 2365 : 		if (_Words < _Myvec.size())

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T254713[ebp], edx
	mov	eax, DWORD PTR $T254713[ebp]
	mov	ecx, DWORD PTR $T254713[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR __Words$[ebp], edx
	jae	SHORT $LN2@Trim

; 2366 : 			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T254723[ebp], ecx
	mov	edx, DWORD PTR $T254723[ebp]
	mov	DWORD PTR $T254663[ebp], edx
	mov	eax, DWORD PTR $T254663[ebp]
	mov	DWORD PTR $T254662[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254739[ebp], edx
	mov	eax, DWORD PTR $T254739[ebp]
	mov	DWORD PTR $T254665[ebp], eax
	mov	ecx, DWORD PTR $T254665[ebp]
	mov	DWORD PTR __Tmp$254756[ebp], ecx
	mov	edx, DWORD PTR __Words$[ebp]
	mov	eax, DWORD PTR __Tmp$254756[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$254756[ebp], ecx
	mov	edx, DWORD PTR __Tmp$254756[ebp]
	mov	DWORD PTR $T254666[ebp], edx
	mov	eax, DWORD PTR $T254666[ebp]
	mov	DWORD PTR $T254664[ebp], eax
	mov	ecx, DWORD PTR $T254662[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254664[ebp]
	push	edx
	lea	eax, DWORD PTR $T254667[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN2@Trim:

; 2367 : 		_Mysize = _Size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Size$[ebp]
	mov	DWORD PTR [ecx], edx

; 2368 : 		_Size %= _VBITS;

	mov	eax, DWORD PTR __Size$[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	DWORD PTR __Size$[ebp], edx

; 2369 : 		if (0 < _Size)

	cmp	DWORD PTR __Size$[ebp], 0
	jbe	SHORT $LN4@Trim

; 2370 : 			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Words$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR tv142[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR __Size$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR tv142[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Trim:

; 2371 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$254871 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$254871[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$254871[ebp], 0
	jbe	SHORT $LN11@Buy@5
	mov	eax, DWORD PTR __Count$254871[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@5
$LN11@Buy@5:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@5:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@5:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T254937 = -28						; size = 4
$T254936 = -24						; size = 4
$T254932 = -20						; size = 4
$T254931 = -16						; size = 4
$T254920 = -12						; size = 4
$T254919 = -8						; size = 4
__Cat$254927 = -2					; size = 1
$T254925 = -1						; size = 1
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254932[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T254931[ebp], ecx
	mov	edx, DWORD PTR $T254932[ebp]
	mov	DWORD PTR $T254920[ebp], edx
	mov	eax, DWORD PTR $T254931[ebp]
	mov	DWORD PTR $T254919[ebp], eax
	mov	cl, BYTE PTR __Cat$254927[ebp]
	mov	BYTE PTR $T254925[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T254937[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T254936[ebp], eax
	mov	ecx, DWORD PTR $T254936[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2
__ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T254941 = -80						; size = 28
$T254940 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 2374 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2375 : 		_THROW(length_error, "vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254941[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T254940[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T254940[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T254941[ebp]
	push	eax
	lea	ecx, DWORD PTR $T254940[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T254940[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254940[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T254941[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 2376 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0:
	lea	ecx, DWORD PTR $T254941[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2:
	lea	ecx, DWORD PTR $T254940[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T255052 = -52						; size = 4
$T255041 = -48						; size = 4
$T255040 = -44						; size = 4
__Cat$255047 = -40					; size = 1
$T255044 = -39						; size = 1
__Ptr$211089 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$211089[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T255052[ebp], edx
	mov	eax, DWORD PTR $T255052[ebp]
	mov	DWORD PTR $T255041[ebp], eax
	mov	ecx, DWORD PTR __Ptr$211089[ebp]
	mov	DWORD PTR $T255040[ebp], ecx
	mov	dl, BYTE PTR __Cat$255047[ebp]
	mov	BYTE PTR $T255044[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$211089[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T255056 = -80						; size = 28
$T255055 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T255056[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T255055[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T255055[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T255056[ebp]
	push	eax
	lea	ecx, DWORD PTR $T255055[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T255055[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T255055[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T255056[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T255056[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T255055[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1603 : 		if (_Off == 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jne	SHORT $LN3@operator@9

; 1604 : 			return (*this); // early out

	mov	eax, DWORD PTR _this$[ebp]
	jmp	$LN6@operator@9
$LN3@operator@9:

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	cmp	DWORD PTR __Off$[ebp], 0
	jge	SHORT $LN2@operator@9
	xor	eax, eax
	sub	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jae	SHORT $LN2@operator@9

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	or	eax, -1
	sub	eax, DWORD PTR [edx+4]
	shr	eax, 5
	lea	ecx, DWORD PTR [eax*4+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1618 : 			this->_Myoff %= _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1619 : 			}
; 1620 : 		else

	jmp	SHORT $LN1@operator@9
$LN2@operator@9:

; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN1@operator@9:

; 1625 : 			}
; 1626 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@operator@9:

; 1627 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T255099 = -26						; size = 1
$T255098 = -25						; size = 1
$T255097 = -24						; size = 4
$T255096 = -20						; size = 4
__Off$255092 = -16					; size = 4
__Result$255093 = -12					; size = 4
__Cat$255085 = -4					; size = 1
$T255081 = -3						; size = 1
$T255080 = -2						; size = 1
$T255079 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T255079[ebp], al
	mov	cl, BYTE PTR __Cat$255085[ebp]
	mov	BYTE PTR $T255080[ebp], cl
	mov	dl, BYTE PTR $T255079[ebp]
	mov	BYTE PTR $T255099[ebp], dl
	mov	al, BYTE PTR $T255081[ebp]
	mov	BYTE PTR $T255098[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T255097[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T255096[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T255096[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$255092[ebp], eax
	mov	ecx, DWORD PTR __Off$255092[ebp]
	mov	edx, DWORD PTR $T255097[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$255093[ebp], eax
	cmp	DWORD PTR __Off$255092[ebp], 0
	jle	SHORT $LN8@unchecked_@7
	mov	ecx, DWORD PTR __Off$255092[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T255096[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$255092[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T255097[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@7:
	mov	eax, DWORD PTR __Result$255093[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T255122 = -26						; size = 1
$T255121 = -25						; size = 1
$T255120 = -24						; size = 4
$T255119 = -20						; size = 4
__Off$255116 = -16					; size = 4
__Result$255117 = -12					; size = 4
__Cat$255108 = -4					; size = 1
$T255104 = -3						; size = 1
$T255103 = -2						; size = 1
$T255102 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T255102[ebp], al
	mov	cl, BYTE PTR __Cat$255108[ebp]
	mov	BYTE PTR $T255103[ebp], cl
	mov	dl, BYTE PTR $T255102[ebp]
	mov	BYTE PTR $T255122[ebp], dl
	mov	al, BYTE PTR $T255104[ebp]
	mov	BYTE PTR $T255121[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T255120[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T255119[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T255119[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$255116[ebp], eax
	mov	ecx, DWORD PTR __Off$255116[ebp]
	mov	edx, DWORD PTR $T255120[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$255117[ebp], eax
	cmp	DWORD PTR __Off$255116[ebp], 0
	jle	SHORT $LN8@unchecked_@8
	mov	ecx, DWORD PTR __Off$255116[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T255119[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$255116[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T255120[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@8:
	mov	eax, DWORD PTR __Result$255117[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T255129 = -16						; size = 4
$T255125 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T255129[ebp], 0
	lea	eax, DWORD PTR $T255129[ebp]
	push	eax
	lea	ecx, DWORD PTR $T255125[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T255125[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T255125[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T255136 = -8						; size = 4
$T255135 = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1465 : 		{	// construct with base

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T255136[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T255135[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T255135[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T255136[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1466 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv202 = -44						; size = 4
$T255220 = -32						; size = 4
$T255219 = -28						; size = 4
$T255203 = -24						; size = 4
$T255202 = -20						; size = 4
$T255140 = -16						; size = 8
$T255139 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@4
$LN2@Copy_opt@4:
	cmp	DWORD PTR __Dest$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN11@Copy_opt@4
	mov	eax, DWORD PTR __Dest$[ebp+4]
	add	eax, 1
	mov	DWORD PTR __Dest$[ebp+4], eax
	jmp	SHORT $LN6@Copy_opt@4
$LN11@Copy_opt@4:
	mov	DWORD PTR __Dest$[ebp+4], 0
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
$LN6@Copy_opt@4:
	cmp	DWORD PTR __First$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN19@Copy_opt@4
	mov	edx, DWORD PTR __First$[ebp+4]
	add	edx, 1
	mov	DWORD PTR __First$[ebp+4], edx
	jmp	SHORT $LN3@Copy_opt@4
$LN19@Copy_opt@4:
	mov	DWORD PTR __First$[ebp+4], 0
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN26@Copy_opt@4
	mov	edx, DWORD PTR __First$[ebp+4]
	cmp	edx, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN26@Copy_opt@4
	mov	DWORD PTR tv202[ebp], 1
	jmp	SHORT $LN22@Copy_opt@4
$LN26@Copy_opt@4:
	mov	DWORD PTR tv202[ebp], 0
$LN22@Copy_opt@4:
	movzx	eax, BYTE PTR tv202[ebp]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@4

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T255203[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T255202[ebp], eax
	mov	ecx, DWORD PTR $T255202[ebp]
	mov	DWORD PTR $T255140[ebp], ecx
	mov	edx, DWORD PTR $T255203[ebp]
	mov	DWORD PTR $T255140[ebp+4], edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR $T255220[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T255219[ebp], ecx
	mov	edx, DWORD PTR $T255219[ebp]
	mov	DWORD PTR $T255139[ebp], edx
	mov	eax, DWORD PTR $T255220[ebp]
	mov	DWORD PTR $T255139[ebp+4], eax
	lea	ecx, DWORD PTR $T255140[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T255139[ebp]
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
	jmp	$LN2@Copy_opt@4
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T255361 = -64						; size = 4
$T255351 = -60						; size = 4
$T255339 = -56						; size = 4
$T255329 = -49						; size = 1
$T255328 = -48						; size = 4
__Cat$255345 = -19					; size = 1
$T255343 = -18						; size = 1
$T255342 = -17						; size = 1
$T255280 = -16						; size = 4
$T255276 = -12						; size = 4
$T255275 = -8						; size = 4
$T255274 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T255280[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@7
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@7
$LN9@push_back@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@7:
	mov	ecx, DWORD PTR $T255280[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@7

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T255351[ebp], eax
	mov	ecx, DWORD PTR $T255351[ebp]
	mov	DWORD PTR $T255339[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T255342[ebp], dl
	mov	al, BYTE PTR __Cat$255345[ebp]
	mov	BYTE PTR $T255343[ebp], al
	mov	cl, BYTE PTR $T255342[ebp]
	mov	BYTE PTR $T255329[ebp], cl
	mov	edx, DWORD PTR $T255339[ebp]
	mov	DWORD PTR $T255328[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T255328[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T255351[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@7
$LN2@push_back@7:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T255361[ebp], edx
	mov	eax, DWORD PTR $T255361[ebp]
	mov	DWORD PTR $T255275[ebp], eax
	mov	ecx, DWORD PTR $T255275[ebp]
	mov	DWORD PTR $T255274[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T255274[ebp]
	push	eax
	lea	ecx, DWORD PTR $T255276[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back@7:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv130 = -28						; size = 4
tv91 = -24						; size = 4
_this$ = -20						; size = 4
$T255455 = -16						; size = 4
$T255448 = -12						; size = 4
$T255443 = -5						; size = 1
$T255433 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1470 : 		{	// assign _Vb_reference _Right to bit

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1471 : 		return (*this = bool(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T255433[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	mov	ecx, DWORD PTR $T255433[ebp]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR $T255443[ebp], al
	movzx	edx, BYTE PTR $T255443[ebp]
	test	edx, edx
	je	SHORT $LN10@operator@10
	mov	eax, DWORD PTR $T255448[ebp]
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv91[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv91[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN11@operator@10
$LN10@operator@10:
	mov	edx, DWORD PTR $T255455[ebp]
	mov	DWORD PTR tv130[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv130[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv130[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR [edx], eax
$LN11@operator@10:
	mov	eax, DWORD PTR _this$[ebp]

; 1472 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$255530 = -24					; size = 4
$T255508 = -20						; size = 4
$T255489 = -16						; size = 4
$T255476 = -12						; size = 4
$T255473 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@4
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T255489[ebp], ecx
	mov	edx, DWORD PTR $T255489[ebp]
	mov	DWORD PTR $T255473[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T255473[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@4:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T255508[ebp], edx
	mov	eax, DWORD PTR $T255508[ebp]
	mov	DWORD PTR $T255476[ebp], eax
	mov	ecx, DWORD PTR $T255476[ebp]
	mov	DWORD PTR __Tmp$255530[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$255530[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$255530[ebp], ecx
	mov	edx, DWORD PTR __Tmp$255530[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T256084 = -412						; size = 4
$T256032 = -368						; size = 4
$T256020 = -364						; size = 4
$T256010 = -357						; size = 1
$T256009 = -356						; size = 4
__Cat$256028 = -327					; size = 1
$T256026 = -326						; size = 1
$T256025 = -325						; size = 1
$T255981 = -324						; size = 4
$T255973 = -320						; size = 4
$T255965 = -316						; size = 4
$T255954 = -312						; size = 4
$T255953 = -308						; size = 4
__Cat$255961 = -302					; size = 1
$T255959 = -301						; size = 1
$T255882 = -276						; size = 4
$T255863 = -272						; size = 4
$T255846 = -265						; size = 1
$T255845 = -264						; size = 4
$T255835 = -260						; size = 4
$T255834 = -256						; size = 4
__Cat$255879 = -250					; size = 1
$T255877 = -249						; size = 1
$T255876 = -248						; size = 1
__Cat$255871 = -247					; size = 1
$T255868 = -246						; size = 1
$T255867 = -245						; size = 1
$T255810 = -244						; size = 4
$T255809 = -240						; size = 4
$T255805 = -236						; size = 4
$T255804 = -232						; size = 4
$T255793 = -228						; size = 4
$T255792 = -224						; size = 4
__Cat$255800 = -218					; size = 1
$T255798 = -217						; size = 1
$T255757 = -216						; size = 4
$T255756 = -212						; size = 4
__Cat$255764 = -206					; size = 1
$T255762 = -205						; size = 1
$T255727 = -204						; size = 4
$T255726 = -200						; size = 4
__Cat$255734 = -194					; size = 1
$T255732 = -193						; size = 1
$T255707 = -192						; size = 4
$T255695 = -188						; size = 4
$T255685 = -181						; size = 1
$T255684 = -180						; size = 4
__Cat$255703 = -175					; size = 1
$T255700 = -174						; size = 1
$T255699 = -173						; size = 1
$T255672 = -172						; size = 4
$T255660 = -168						; size = 4
$T255650 = -161						; size = 1
$T255649 = -160						; size = 4
__Cat$255668 = -155					; size = 1
$T255665 = -154						; size = 1
$T255664 = -153						; size = 1
$T255637 = -152						; size = 4
$T255625 = -148						; size = 4
$T255615 = -141						; size = 1
$T255614 = -140						; size = 4
__Cat$255632 = -135					; size = 1
$T255630 = -134						; size = 1
$T255629 = -133						; size = 1
__Count$255588 = -120					; size = 4
__Count$255562 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@4
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@4
$LN29@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@4:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@4
	jmp	$LN16@Insert_n@4
$LN14@Insert_n@4:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$255562[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$255562[ebp], 0
	jbe	SHORT $LN35@Insert_n@4
	mov	edx, DWORD PTR __Count$255562[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@4
$LN35@Insert_n@4:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n@4

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$255588[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$255588[ebp], 0
	jbe	SHORT $LN48@Insert_n@4
	mov	ecx, DWORD PTR __Count$255588[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@4
$LN48@Insert_n@4:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@4:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@4:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@4:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T255637[ebp], edx
	mov	eax, DWORD PTR $T255637[ebp]
	mov	DWORD PTR $T255625[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T255629[ebp], cl
	mov	dl, BYTE PTR __Cat$255632[ebp]
	mov	BYTE PTR $T255630[ebp], dl
	mov	al, BYTE PTR $T255629[ebp]
	mov	BYTE PTR $T255615[ebp], al
	mov	ecx, DWORD PTR $T255625[ebp]
	mov	DWORD PTR $T255614[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255614[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T255672[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T255660[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T255664[ebp], al
	mov	cl, BYTE PTR __Cat$255668[ebp]
	mov	BYTE PTR $T255665[ebp], cl
	mov	dl, BYTE PTR $T255664[ebp]
	mov	BYTE PTR $T255650[ebp], dl
	mov	eax, DWORD PTR $T255660[ebp]
	mov	DWORD PTR $T255649[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255649[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255672[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255707[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T255695[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T255699[ebp], dl
	mov	al, BYTE PTR __Cat$255703[ebp]
	mov	BYTE PTR $T255700[ebp], al
	mov	cl, BYTE PTR $T255699[ebp]
	mov	BYTE PTR $T255685[ebp], cl
	mov	edx, DWORD PTR $T255695[ebp]
	mov	DWORD PTR $T255684[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255684[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255707[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@4
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n@4

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T255727[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T255726[ebp], ecx
	mov	dl, BYTE PTR __Cat$255734[ebp]
	mov	BYTE PTR $T255732[ebp], dl
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T255757[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T255756[ebp], ecx
	mov	dl, BYTE PTR __Cat$255764[ebp]
	mov	BYTE PTR $T255762[ebp], dl
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@4
	ret	0
$LN19@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T255805[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T255804[ebp], edx
	mov	eax, DWORD PTR $T255805[ebp]
	mov	DWORD PTR $T255793[ebp], eax
	mov	ecx, DWORD PTR $T255804[ebp]
	mov	DWORD PTR $T255792[ebp], ecx
	mov	dl, BYTE PTR __Cat$255800[ebp]
	mov	BYTE PTR $T255798[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T255810[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T255809[ebp], ecx
	mov	edx, DWORD PTR $T255809[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@4
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T255882[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T255863[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T255867[ebp], cl
	mov	dl, BYTE PTR __Cat$255871[ebp]
	mov	BYTE PTR $T255868[ebp], dl
	mov	al, BYTE PTR $T255867[ebp]
	mov	BYTE PTR $T255846[ebp], al
	mov	ecx, DWORD PTR $T255863[ebp]
	mov	DWORD PTR $T255845[ebp], ecx
	mov	edx, DWORD PTR $T255845[ebp]
	mov	DWORD PTR $T255835[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T255834[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T255876[ebp], cl
	mov	dl, BYTE PTR __Cat$255879[ebp]
	mov	BYTE PTR $T255877[ebp], dl
	movzx	eax, BYTE PTR $T255876[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T255877[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T255835[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255882[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255834[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@4
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T255965[ebp], eax
	mov	ecx, DWORD PTR $T255965[ebp]
	mov	DWORD PTR $T255954[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T255953[ebp], ecx
	mov	dl, BYTE PTR __Cat$255961[ebp]
	mov	BYTE PTR $T255959[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T255981[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T255973[ebp], edx
	jmp	SHORT $LN151@Insert_n@4
$LN150@Insert_n@4:
	mov	eax, DWORD PTR $T255973[ebp]
	add	eax, 4
	mov	DWORD PTR $T255973[ebp], eax
$LN151@Insert_n@4:
	mov	ecx, DWORD PTR $T255973[ebp]
	cmp	ecx, DWORD PTR $T255981[ebp]
	je	SHORT $LN147@Insert_n@4
	mov	edx, DWORD PTR $T255973[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@4
$LN147@Insert_n@4:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256032[ebp], eax
	mov	ecx, DWORD PTR $T256032[ebp]
	mov	DWORD PTR $T256020[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256025[ebp], dl
	mov	al, BYTE PTR __Cat$256028[ebp]
	mov	BYTE PTR $T256026[ebp], al
	mov	cl, BYTE PTR $T256025[ebp]
	mov	BYTE PTR $T256010[ebp], cl
	mov	edx, DWORD PTR $T256020[ebp]
	mov	DWORD PTR $T256009[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256009[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256084[ebp], ecx
	jmp	SHORT $LN186@Insert_n@4
$LN185@Insert_n@4:
	mov	edx, DWORD PTR $T256084[ebp]
	add	edx, 4
	mov	DWORD PTR $T256084[ebp], edx
$LN186@Insert_n@4:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T256084[ebp], edx
	je	SHORT $LN16@Insert_n@4
	mov	eax, DWORD PTR $T256084[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@4
$LN16@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T256155 = -40						; size = 4
$T256145 = -33						; size = 1
$T256144 = -32						; size = 4
__Cat$256151 = -3					; size = 1
$T256148 = -2						; size = 1
$T256147 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T256155[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256147[ebp], cl
	mov	dl, BYTE PTR __Cat$256151[ebp]
	mov	BYTE PTR $T256148[ebp], dl
	mov	al, BYTE PTR $T256147[ebp]
	mov	BYTE PTR $T256145[ebp], al
	mov	ecx, DWORD PTR $T256155[ebp]
	mov	DWORD PTR $T256144[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256144[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
; Function compile flags: /Odtp
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z
_TEXT	SEGMENT
_this$ = -212						; size = 4
$T256477 = -208						; size = 8
$T256476 = -200						; size = 8
__Tmp$256389 = -172					; size = 8
$T256367 = -164						; size = 4
$T256345 = -160						; size = 4
$T256370 = -156						; size = 4
__Tmp$256330 = -152					; size = 8
$T256309 = -144						; size = 4
$T256287 = -140						; size = 4
$T256311 = -136						; size = 4
$T256161 = -36						; size = 8
$T256160 = -28						; size = 8
$T256159 = -20						; size = 8
$T256158 = -12						; size = 8
__Off$ = -4						; size = 4
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 1
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2290 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	DWORD PTR _this$[ebp], ecx

; 2291 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
	mov	DWORD PTR __Off$[ebp], eax

; 2292 : 		std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256287[ebp], ecx
	mov	edx, DWORD PTR $T256287[ebp]
	mov	DWORD PTR $T256311[ebp], edx
	mov	eax, DWORD PTR $T256311[ebp]
	mov	DWORD PTR $T256309[ebp], eax
	mov	ecx, DWORD PTR $T256309[ebp]
	mov	DWORD PTR $T256158[ebp], ecx
	mov	DWORD PTR $T256158[ebp+4], 0
	mov	edx, DWORD PTR $T256158[ebp]
	mov	eax, DWORD PTR $T256158[ebp+4]
	mov	DWORD PTR __Tmp$256330[ebp], edx
	mov	DWORD PTR __Tmp$256330[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$256330[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$256330[ebp]
	mov	eax, DWORD PTR __Tmp$256330[ebp+4]
	mov	DWORD PTR $T256159[ebp], edx
	mov	DWORD PTR $T256159[ebp+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T256345[ebp], edx
	mov	eax, DWORD PTR $T256345[ebp]
	mov	DWORD PTR $T256370[ebp], eax
	mov	ecx, DWORD PTR $T256370[ebp]
	mov	DWORD PTR $T256367[ebp], ecx
	mov	edx, DWORD PTR $T256367[ebp]
	mov	DWORD PTR $T256160[ebp], edx
	mov	DWORD PTR $T256160[ebp+4], 0
	mov	eax, DWORD PTR $T256160[ebp]
	mov	ecx, DWORD PTR $T256160[ebp+4]
	mov	DWORD PTR __Tmp$256389[ebp], eax
	mov	DWORD PTR __Tmp$256389[ebp+4], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$256389[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR __Tmp$256389[ebp]
	mov	ecx, DWORD PTR __Tmp$256389[ebp+4]
	mov	DWORD PTR $T256161[ebp], eax
	mov	DWORD PTR $T256161[ebp+4], ecx
	mov	edx, DWORD PTR $T256159[ebp]
	mov	DWORD PTR $T256477[ebp], edx
	mov	eax, DWORD PTR $T256159[ebp+4]
	mov	DWORD PTR $T256477[ebp+4], eax
	mov	ecx, DWORD PTR $T256161[ebp]
	mov	DWORD PTR $T256476[ebp], ecx
	mov	edx, DWORD PTR $T256161[ebp+4]
	mov	DWORD PTR $T256476[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256477[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T256477[ebp]
	push	edx
	mov	eax, DWORD PTR $T256476[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T256476[ebp]
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H

; 2293 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
PUBLIC	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
; Function compile flags: /Odtp
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z
_TEXT	SEGMENT
tv191 = -348						; size = 4
tv200 = -344						; size = 4
_this$ = -340						; size = 4
__Tmp$256836 = -268					; size = 8
$T256814 = -260						; size = 4
$T256792 = -256						; size = 4
$T256817 = -252						; size = 4
$T256672 = -200						; size = 4
$T256583 = -148						; size = 4
$T256571 = -76						; size = 4
__Count$256564 = -72					; size = 4
__Maxsize$256557 = -68					; size = 4
$T256518 = -64						; size = 4
$T256496 = -60						; size = 4
$T256521 = -56						; size = 4
$T256484 = -52						; size = 8
$T256483 = -44						; size = 8
$T256482 = -36						; size = 8
$T256481 = -28						; size = 8
$T256480 = -20						; size = 8
__Oldend$214955 = -12					; size = 8
__Off$ = -4						; size = 4
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2296 : 		{	// make room to insert _Count elements at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	DWORD PTR _this$[ebp], ecx

; 2297 : 		size_type _Off = _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256496[ebp], ecx
	mov	edx, DWORD PTR $T256496[ebp]
	mov	DWORD PTR $T256521[ebp], edx
	mov	eax, DWORD PTR $T256521[ebp]
	mov	DWORD PTR $T256518[ebp], eax
	mov	ecx, DWORD PTR $T256518[ebp]
	mov	DWORD PTR $T256480[ebp], ecx
	mov	DWORD PTR $T256480[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T256480[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T256480[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2298 : 
; 2299 :  #if _HAS_ITERATOR_DEBUGGING
; 2300 : 		if (end() < _Where)
; 2301 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2302 : 		bool _Realloc = capacity() - size() < _Count;
; 2303 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2304 : 
; 2305 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN6@Insert_x
	jmp	$LN5@Insert_x
$LN6@Insert_x:

; 2306 : 			;
; 2307 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$256564[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$256564[ebp], 0
	jbe	SHORT $LN33@Insert_x
	mov	eax, DWORD PTR __Count$256564[ebp]
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN29@Insert_x
$LN33@Insert_x:
	mov	DWORD PTR tv200[ebp], 1
$LN29@Insert_x:
	mov	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR __Maxsize$256557[ebp], ecx
	cmp	DWORD PTR __Maxsize$256557[ebp], 134217727 ; 07ffffffH
	jae	SHORT $LN27@Insert_x
	mov	edx, DWORD PTR __Maxsize$256557[ebp]
	shl	edx, 5
	mov	DWORD PTR tv191[ebp], edx
	jmp	SHORT $LN25@Insert_x
$LN27@Insert_x:
	mov	DWORD PTR tv191[ebp], -1
$LN25@Insert_x:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T256571[ebp], ecx
	mov	edx, DWORD PTR tv191[ebp]
	sub	edx, DWORD PTR $T256571[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Insert_x

; 2308 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen

; 2309 : 		else

	jmp	$LN5@Insert_x
$LN4@Insert_x:

; 2310 : 			{	// worth doing
; 2311 : 			_Myvec.resize(_Nw(size() + _Count), 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T256583[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR $T256583[ebp]
	lea	ecx, DWORD PTR [eax+edx+31]
	shr	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 2312 : 			if (size() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T256672[ebp], eax
	cmp	DWORD PTR $T256672[ebp], 0
	jne	SHORT $LN2@Insert_x

; 2313 : 				_Mysize += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 2314 : 			else

	jmp	$LN5@Insert_x
$LN2@Insert_x:

; 2315 : 				{	// make room and copy down suffix
; 2316 : 				iterator _Oldend = end();

	lea	ecx, DWORD PTR __Oldend$214955[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end

; 2317 : 				_Mysize += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 2318 : 				std::copy_backward(begin() + _Off, _Oldend, end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256792[ebp], eax
	mov	ecx, DWORD PTR $T256792[ebp]
	mov	DWORD PTR $T256817[ebp], ecx
	mov	edx, DWORD PTR $T256817[ebp]
	mov	DWORD PTR $T256814[ebp], edx
	mov	eax, DWORD PTR $T256814[ebp]
	mov	DWORD PTR $T256482[ebp], eax
	mov	DWORD PTR $T256482[ebp+4], 0
	mov	ecx, DWORD PTR $T256482[ebp]
	mov	edx, DWORD PTR $T256482[ebp+4]
	mov	DWORD PTR __Tmp$256836[ebp], ecx
	mov	DWORD PTR __Tmp$256836[ebp+4], edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$256836[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$256836[ebp]
	mov	edx, DWORD PTR __Tmp$256836[ebp+4]
	mov	DWORD PTR $T256483[ebp], ecx
	mov	DWORD PTR $T256483[ebp+4], edx
	lea	eax, DWORD PTR $T256481[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Oldend$214955[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Oldend$214955[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256483[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T256483[ebp]
	push	eax
	lea	ecx, DWORD PTR $T256484[ebp]
	push	ecx
	call	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
	add	esp, 28					; 0000001cH
$LN5@Insert_x:

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, DWORD PTR __Off$[ebp]

; 2327 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
__Tmp$257046 = -48					; size = 4
$T257024 = -44						; size = 4
$T257008 = -40						; size = 4
$T256986 = -36						; size = 4
$T256973 = -32						; size = 4
$T256972 = -28						; size = 4
$T256971 = -24						; size = 4
$T256970 = -20						; size = 4
$T256969 = -16						; size = 4
$T256968 = -12						; size = 4
$T256967 = -8						; size = 4
$T256966 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN16@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256986[ebp], ecx
	mov	edx, DWORD PTR $T256986[ebp]
	mov	DWORD PTR $T256967[ebp], edx
	mov	eax, DWORD PTR $T256967[ebp]
	mov	DWORD PTR $T256966[ebp], eax
	lea	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR $T256966[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
	jmp	SHORT $LN4@resize@2

; 720  : 		else if (_Newsize < size())

$LN16@resize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257008[ebp], edx
	mov	eax, DWORD PTR $T257008[ebp]
	mov	DWORD PTR $T256969[ebp], eax
	mov	ecx, DWORD PTR $T256969[ebp]
	mov	DWORD PTR $T256968[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257024[ebp], eax
	mov	ecx, DWORD PTR $T257024[ebp]
	mov	DWORD PTR $T256971[ebp], ecx
	mov	edx, DWORD PTR $T256971[ebp]
	mov	DWORD PTR __Tmp$257046[ebp], edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Tmp$257046[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$257046[ebp], edx
	mov	eax, DWORD PTR __Tmp$257046[ebp]
	mov	DWORD PTR $T256972[ebp], eax
	mov	ecx, DWORD PTR $T256972[ebp]
	mov	DWORD PTR $T256970[ebp], ecx
	mov	edx, DWORD PTR $T256968[ebp]
	push	edx
	mov	eax, DWORD PTR $T256970[ebp]
	push	eax
	lea	ecx, DWORD PTR $T256973[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN4@resize@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0
__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T257692 = -412						; size = 4
$T257640 = -368						; size = 4
$T257628 = -364						; size = 4
$T257618 = -357						; size = 1
$T257617 = -356						; size = 4
__Cat$257635 = -327					; size = 1
$T257633 = -326						; size = 1
$T257632 = -325						; size = 1
$T257589 = -324						; size = 4
$T257581 = -320						; size = 4
$T257573 = -316						; size = 4
$T257562 = -312						; size = 4
$T257561 = -308						; size = 4
__Cat$257569 = -302					; size = 1
$T257567 = -301						; size = 1
$T257490 = -276						; size = 4
$T257471 = -272						; size = 4
$T257454 = -265						; size = 1
$T257453 = -264						; size = 4
$T257443 = -260						; size = 4
$T257442 = -256						; size = 4
__Cat$257486 = -250					; size = 1
$T257484 = -249						; size = 1
$T257483 = -248						; size = 1
__Cat$257478 = -247					; size = 1
$T257476 = -246						; size = 1
$T257475 = -245						; size = 1
$T257418 = -244						; size = 4
$T257417 = -240						; size = 4
$T257413 = -236						; size = 4
$T257412 = -232						; size = 4
$T257401 = -228						; size = 4
$T257400 = -224						; size = 4
__Cat$257408 = -218					; size = 1
$T257406 = -217						; size = 1
$T257365 = -216						; size = 4
$T257364 = -212						; size = 4
__Cat$257372 = -206					; size = 1
$T257370 = -205						; size = 1
$T257335 = -204						; size = 4
$T257334 = -200						; size = 4
__Cat$257342 = -194					; size = 1
$T257340 = -193						; size = 1
$T257315 = -192						; size = 4
$T257303 = -188						; size = 4
$T257293 = -181						; size = 1
$T257292 = -180						; size = 4
__Cat$257310 = -175					; size = 1
$T257308 = -174						; size = 1
$T257307 = -173						; size = 1
$T257280 = -172						; size = 4
$T257268 = -168						; size = 4
$T257258 = -161						; size = 1
$T257257 = -160						; size = 4
__Cat$257275 = -155					; size = 1
$T257273 = -154						; size = 1
$T257272 = -153						; size = 1
$T257245 = -152						; size = 4
$T257233 = -148						; size = 4
$T257223 = -141						; size = 1
$T257222 = -140						; size = 4
__Cat$257240 = -135					; size = 1
$T257238 = -134						; size = 1
$T257237 = -133						; size = 1
__Count$257199 = -120					; size = 4
__Count$257173 = -48					; size = 4
__Tmp$215030 = -44					; size = 4
__Oldend$215031 = -40					; size = 4
__Tmp$215020 = -36					; size = 4
__Ncopied$215007 = -32					; size = 4
__Newvec$215005 = -28					; size = 4
__Whereoff$215006 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@5
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@5
$LN29@Insert_n@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@5:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@5
	jmp	$LN16@Insert_n@5
$LN14@Insert_n@5:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$257173[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$257173[ebp], 0
	jbe	SHORT $LN35@Insert_n@5
	mov	edx, DWORD PTR __Count$257173[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@5
$LN35@Insert_n@5:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
	jmp	$LN16@Insert_n@5

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$257199[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$257199[ebp], 0
	jbe	SHORT $LN48@Insert_n@5
	mov	ecx, DWORD PTR __Count$257199[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@5
$LN48@Insert_n@5:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@5:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@5:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@5:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8
	mov	DWORD PTR __Newvec$215005[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$215006[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$215007[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$215006[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T257245[ebp], edx
	mov	eax, DWORD PTR $T257245[ebp]
	mov	DWORD PTR $T257233[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257237[ebp], cl
	mov	dl, BYTE PTR __Cat$257240[ebp]
	mov	BYTE PTR $T257238[ebp], dl
	mov	al, BYTE PTR $T257237[ebp]
	mov	BYTE PTR $T257223[ebp], al
	mov	ecx, DWORD PTR $T257233[ebp]
	mov	DWORD PTR $T257222[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257222[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$215007[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$215007[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T257280[ebp], ecx
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR $T257268[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T257272[ebp], al
	mov	cl, BYTE PTR __Cat$257275[ebp]
	mov	BYTE PTR $T257273[ebp], cl
	mov	dl, BYTE PTR $T257272[ebp]
	mov	BYTE PTR $T257258[ebp], dl
	mov	eax, DWORD PTR $T257268[ebp]
	mov	DWORD PTR $T257257[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257257[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257280[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$215007[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$215007[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257315[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$215006[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T257303[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257307[ebp], dl
	mov	al, BYTE PTR __Cat$257310[ebp]
	mov	BYTE PTR $T257308[ebp], al
	mov	cl, BYTE PTR $T257307[ebp]
	mov	BYTE PTR $T257293[ebp], cl
	mov	edx, DWORD PTR $T257303[ebp]
	mov	DWORD PTR $T257292[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257292[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257315[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@5
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$215007[ebp], 1
	jle	SHORT $LN7@Insert_n@5

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$215006[ebp]
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T257335[ebp], eax
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR $T257334[ebp], ecx
	mov	dl, BYTE PTR __Cat$257342[ebp]
	mov	BYTE PTR $T257340[ebp], dl
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$215007[ebp], 0
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$215006[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T257365[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$215006[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T257364[ebp], ecx
	mov	dl, BYTE PTR __Cat$257372[ebp]
	mov	BYTE PTR $T257370[ebp], dl
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$215005[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@5
	ret	0
$LN19@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257413[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T257412[ebp], edx
	mov	eax, DWORD PTR $T257413[ebp]
	mov	DWORD PTR $T257401[ebp], eax
	mov	ecx, DWORD PTR $T257412[ebp]
	mov	DWORD PTR $T257400[ebp], ecx
	mov	dl, BYTE PTR __Cat$257408[ebp]
	mov	BYTE PTR $T257406[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T257418[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T257417[ebp], ecx
	mov	edx, DWORD PTR $T257417[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@5
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$215020[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257490[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T257471[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257475[ebp], cl
	mov	dl, BYTE PTR __Cat$257478[ebp]
	mov	BYTE PTR $T257476[ebp], dl
	mov	al, BYTE PTR $T257475[ebp]
	mov	BYTE PTR $T257454[ebp], al
	mov	ecx, DWORD PTR $T257471[ebp]
	mov	DWORD PTR $T257453[ebp], ecx
	mov	edx, DWORD PTR $T257453[ebp]
	mov	DWORD PTR $T257443[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257442[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257483[ebp], cl
	mov	dl, BYTE PTR __Cat$257486[ebp]
	mov	BYTE PTR $T257484[ebp], dl
	movzx	eax, BYTE PTR $T257483[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T257484[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T257443[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257490[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257442[ebp]
	push	edx
	call	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$215020[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@5
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T257573[ebp], eax
	mov	ecx, DWORD PTR $T257573[ebp]
	mov	DWORD PTR $T257562[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T257561[ebp], ecx
	mov	dl, BYTE PTR __Cat$257569[ebp]
	mov	BYTE PTR $T257567[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3
	ret	0
$LN21@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T257589[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257581[ebp], edx
	jmp	SHORT $LN151@Insert_n@5
$LN150@Insert_n@5:
	mov	eax, DWORD PTR $T257581[ebp]
	add	eax, 4
	mov	DWORD PTR $T257581[ebp], eax
$LN151@Insert_n@5:
	mov	ecx, DWORD PTR $T257581[ebp]
	cmp	ecx, DWORD PTR $T257589[ebp]
	je	SHORT $LN147@Insert_n@5
	mov	edx, DWORD PTR $T257581[ebp]
	mov	eax, DWORD PTR __Tmp$215020[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@5
$LN147@Insert_n@5:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$215030[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$215031[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257640[ebp], eax
	mov	ecx, DWORD PTR $T257640[ebp]
	mov	DWORD PTR $T257628[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257632[ebp], dl
	mov	al, BYTE PTR __Cat$257635[ebp]
	mov	BYTE PTR $T257633[ebp], al
	mov	cl, BYTE PTR $T257632[ebp]
	mov	BYTE PTR $T257618[ebp], cl
	mov	edx, DWORD PTR $T257628[ebp]
	mov	DWORD PTR $T257617[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257617[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$215031[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$215031[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$215031[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$215031[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257692[ebp], ecx
	jmp	SHORT $LN186@Insert_n@5
$LN185@Insert_n@5:
	mov	edx, DWORD PTR $T257692[ebp]
	add	edx, 4
	mov	DWORD PTR $T257692[ebp], edx
$LN186@Insert_n@5:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T257692[ebp], edx
	je	SHORT $LN16@Insert_n@5
	mov	eax, DWORD PTR $T257692[ebp]
	mov	ecx, DWORD PTR __Tmp$215030[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@5
$LN16@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T257763 = -40						; size = 4
$T257753 = -33						; size = 1
$T257752 = -32						; size = 4
__Cat$257758 = -3					; size = 1
$T257756 = -2						; size = 1
$T257755 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T257763[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257755[ebp], cl
	mov	dl, BYTE PTR __Cat$257758[ebp]
	mov	BYTE PTR $T257756[ebp], dl
	mov	al, BYTE PTR $T257755[ebp]
	mov	BYTE PTR $T257753[ebp], al
	mov	ecx, DWORD PTR $T257763[ebp]
	mov	DWORD PTR $T257752[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257752[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T257808 = -38						; size = 1
$T257807 = -37						; size = 1
$T257806 = -36						; size = 4
$T257805 = -32						; size = 4
$T257792 = -25						; size = 1
$T257791 = -24						; size = 4
$T257790 = -20						; size = 4
__Off$257800 = -16					; size = 4
__Result$257801 = -12					; size = 4
__Cat$257797 = -8					; size = 1
$T257795 = -7						; size = 1
$T257794 = -6						; size = 1
__Cat$257772 = -4					; size = 1
$T257768 = -3						; size = 1
$T257767 = -2						; size = 1
$T257766 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T257766[ebp], al
	mov	cl, BYTE PTR __Cat$257772[ebp]
	mov	BYTE PTR $T257767[ebp], cl
	mov	dl, BYTE PTR $T257766[ebp]
	mov	BYTE PTR $T257808[ebp], dl
	mov	al, BYTE PTR $T257768[ebp]
	mov	BYTE PTR $T257807[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T257806[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T257805[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T257794[ebp], al
	mov	cl, BYTE PTR __Cat$257797[ebp]
	mov	BYTE PTR $T257795[ebp], cl
	mov	dl, BYTE PTR $T257794[ebp]
	mov	BYTE PTR $T257792[ebp], dl
	mov	eax, DWORD PTR $T257806[ebp]
	mov	DWORD PTR $T257791[ebp], eax
	mov	ecx, DWORD PTR $T257805[ebp]
	mov	DWORD PTR $T257790[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T257790[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$257800[ebp], edx
	mov	eax, DWORD PTR __Off$257800[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T257791[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$257801[ebp], ecx
	cmp	DWORD PTR __Off$257800[ebp], 0
	jle	SHORT $LN7@Unchecked_@4
	mov	edx, DWORD PTR __Off$257800[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T257790[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$257800[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$257801[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@4:
	mov	eax, DWORD PTR __Result$257801[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
__Cat$257816 = -4					; size = 1
$T257813 = -3						; size = 1
$T257812 = -2						; size = 1
$T257811 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2740 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2741 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2742 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T257811[ebp], al
	mov	cl, BYTE PTR __Cat$257816[ebp]
	mov	BYTE PTR $T257812[ebp], cl
	movzx	edx, BYTE PTR $T257811[ebp]
	push	edx
	movzx	eax, BYTE PTR $T257812[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T257813[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2743 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T258000 = -38						; size = 1
$T257999 = -37						; size = 1
$T257998 = -36						; size = 4
$T257997 = -32						; size = 4
$T257984 = -25						; size = 1
$T257983 = -24						; size = 4
$T257982 = -20						; size = 4
__Off$257993 = -16					; size = 4
__Result$257994 = -12					; size = 4
__Cat$257990 = -8					; size = 1
$T257988 = -7						; size = 1
$T257987 = -6						; size = 1
__Cat$257963 = -4					; size = 1
$T257960 = -3						; size = 1
$T257959 = -2						; size = 1
$T257958 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T257958[ebp], al
	mov	cl, BYTE PTR __Cat$257963[ebp]
	mov	BYTE PTR $T257959[ebp], cl
	mov	dl, BYTE PTR $T257958[ebp]
	mov	BYTE PTR $T258000[ebp], dl
	mov	al, BYTE PTR $T257960[ebp]
	mov	BYTE PTR $T257999[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T257998[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T257997[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T257987[ebp], al
	mov	cl, BYTE PTR __Cat$257990[ebp]
	mov	BYTE PTR $T257988[ebp], cl
	mov	dl, BYTE PTR $T257987[ebp]
	mov	BYTE PTR $T257984[ebp], dl
	mov	eax, DWORD PTR $T257998[ebp]
	mov	DWORD PTR $T257983[ebp], eax
	mov	ecx, DWORD PTR $T257997[ebp]
	mov	DWORD PTR $T257982[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T257982[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$257993[ebp], edx
	mov	eax, DWORD PTR __Off$257993[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T257983[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$257994[ebp], ecx
	cmp	DWORD PTR __Off$257993[ebp], 0
	jle	SHORT $LN7@Unchecked_@5
	mov	edx, DWORD PTR __Off$257993[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T257982[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$257993[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$257994[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@5:
	mov	eax, DWORD PTR __Result$257994[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
tv190 = -32						; size = 4
tv179 = -28						; size = 4
tv171 = -24						; size = 4
$T258081 = -17						; size = 1
$T258045 = -16						; size = 4
$T258044 = -12						; size = 4
$T258003 = -8						; size = 8
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	cmp	DWORD PTR __First$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN11@Fill
	mov	eax, DWORD PTR __First$[ebp+4]
	add	eax, 1
	mov	DWORD PTR __First$[ebp+4], eax
	jmp	SHORT $LN3@Fill
$LN11@Fill:
	mov	DWORD PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN18@Fill
	mov	eax, DWORD PTR __First$[ebp+4]
	cmp	eax, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN18@Fill
	mov	DWORD PTR tv171[ebp], 1
	jmp	SHORT $LN14@Fill
$LN18@Fill:
	mov	DWORD PTR tv171[ebp], 0
$LN14@Fill:
	movzx	ecx, BYTE PTR tv171[ebp]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T258045[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T258044[ebp], ecx
	mov	edx, DWORD PTR $T258044[ebp]
	mov	DWORD PTR $T258003[ebp], edx
	mov	eax, DWORD PTR $T258045[ebp]
	mov	DWORD PTR $T258003[ebp+4], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T258081[ebp], dl
	movzx	eax, BYTE PTR $T258081[ebp]
	test	eax, eax
	je	SHORT $LN34@Fill
	mov	ecx, DWORD PTR $T258003[ebp]
	mov	DWORD PTR tv179[ebp], ecx
	mov	edx, 1
	mov	ecx, DWORD PTR $T258003[ebp+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv179[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv179[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN28@Fill
$LN34@Fill:
	mov	edx, DWORD PTR $T258003[ebp]
	mov	DWORD PTR tv190[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR $T258003[ebp+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv190[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv190[ebp]
	mov	DWORD PTR [edx], eax
$LN28@Fill:
	jmp	$LN2@Fill
$LN4@Fill:

; 3160 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv150 = -44						; size = 4
$T258165 = -32						; size = 4
$T258164 = -28						; size = 4
$T258127 = -24						; size = 4
$T258126 = -20						; size = 4
$T258085 = -16						; size = 8
$T258084 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
$LN2@Copy_backw@2:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN9@Copy_backw@2
	mov	ecx, DWORD PTR __First$[ebp+4]
	cmp	ecx, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN9@Copy_backw@2
	mov	DWORD PTR tv150[ebp], 1
	jmp	SHORT $LN5@Copy_backw@2
$LN9@Copy_backw@2:
	mov	DWORD PTR tv150[ebp], 0
$LN5@Copy_backw@2:
	movzx	edx, BYTE PTR tv150[ebp]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN1@Copy_backw@2

; 2676 : 		*--_Dest = *--_Last;

	cmp	DWORD PTR __Last$[ebp+4], 0
	je	SHORT $LN16@Copy_backw@2
	mov	ecx, DWORD PTR __Last$[ebp+4]
	sub	ecx, 1
	mov	DWORD PTR __Last$[ebp+4], ecx
	jmp	SHORT $LN11@Copy_backw@2
$LN16@Copy_backw@2:
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Last$[ebp], edx
	mov	DWORD PTR __Last$[ebp+4], 31		; 0000001fH
$LN11@Copy_backw@2:
	mov	eax, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR $T258127[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T258126[ebp], ecx
	mov	edx, DWORD PTR $T258126[ebp]
	mov	DWORD PTR $T258085[ebp], edx
	mov	eax, DWORD PTR $T258127[ebp]
	mov	DWORD PTR $T258085[ebp+4], eax
	cmp	DWORD PTR __Dest$[ebp+4], 0
	je	SHORT $LN30@Copy_backw@2
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	sub	ecx, 1
	mov	DWORD PTR __Dest$[ebp+4], ecx
	jmp	SHORT $LN25@Copy_backw@2
$LN30@Copy_backw@2:
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], 31		; 0000001fH
$LN25@Copy_backw@2:
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR $T258165[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T258164[ebp], ecx
	mov	edx, DWORD PTR $T258164[ebp]
	mov	DWORD PTR $T258084[ebp], edx
	mov	eax, DWORD PTR $T258165[ebp]
	mov	DWORD PTR $T258084[ebp+4], eax
	lea	ecx, DWORD PTR $T258085[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T258084[ebp]
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
	jmp	$LN2@Copy_backw@2
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T258246 = -22						; size = 1
$T258245 = -21						; size = 1
$T258244 = -20						; size = 4
$T258235 = -13						; size = 1
$T258234 = -12						; size = 4
$T258233 = -8						; size = 4
$T258237 = -4						; size = 1
$T258220 = -2						; size = 1
$T258219 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T258219[ebp], al
	mov	cl, BYTE PTR $T258219[ebp]
	mov	BYTE PTR $T258246[ebp], cl
	mov	dl, BYTE PTR $T258220[ebp]
	mov	BYTE PTR $T258245[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T258244[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258237[ebp], cl
	mov	dl, BYTE PTR $T258237[ebp]
	mov	BYTE PTR $T258235[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T258234[ebp], eax
	mov	ecx, DWORD PTR $T258244[ebp]
	mov	DWORD PTR $T258233[ebp], ecx
	jmp	SHORT $LN9@unchecked_@9
$LN8@unchecked_@9:
	mov	edx, DWORD PTR $T258234[ebp]
	sub	edx, 1
	mov	DWORD PTR $T258234[ebp], edx
	mov	eax, DWORD PTR $T258233[ebp]
	add	eax, 4
	mov	DWORD PTR $T258233[ebp], eax
$LN9@unchecked_@9:
	cmp	DWORD PTR $T258234[ebp], 0
	jbe	SHORT $LN1@unchecked_@9
	mov	ecx, DWORD PTR $T258233[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@9
$LN1@unchecked_@9:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
$T258276 = -22						; size = 1
$T258275 = -21						; size = 1
$T258274 = -20						; size = 4
$T258265 = -13						; size = 1
$T258264 = -12						; size = 4
$T258263 = -8						; size = 4
$T258267 = -4						; size = 1
$T258250 = -2						; size = 1
$T258249 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T258249[ebp], al
	mov	cl, BYTE PTR $T258249[ebp]
	mov	BYTE PTR $T258276[ebp], cl
	mov	dl, BYTE PTR $T258250[ebp]
	mov	BYTE PTR $T258275[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T258274[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258267[ebp], cl
	mov	dl, BYTE PTR $T258267[ebp]
	mov	BYTE PTR $T258265[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T258264[ebp], eax
	mov	ecx, DWORD PTR $T258274[ebp]
	mov	DWORD PTR $T258263[ebp], ecx
	jmp	SHORT $LN9@unchecked_@10
$LN8@unchecked_@10:
	mov	edx, DWORD PTR $T258264[ebp]
	sub	edx, 1
	mov	DWORD PTR $T258264[ebp], edx
	mov	eax, DWORD PTR $T258263[ebp]
	add	eax, 4
	mov	DWORD PTR $T258263[ebp], eax
$LN9@unchecked_@10:
	cmp	DWORD PTR $T258264[ebp], 0
	jbe	SHORT $LN1@unchecked_@10
	mov	ecx, DWORD PTR $T258263[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@10
$LN1@unchecked_@10:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T258293 = -21						; size = 1
$T258292 = -20						; size = 4
$T258291 = -16						; size = 4
__Result$258289 = -12					; size = 4
__Count$258288 = -8					; size = 4
__Cat$258283 = -3					; size = 1
$T258280 = -2						; size = 1
$T258279 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T258279[ebp], al
	mov	cl, BYTE PTR __Cat$258283[ebp]
	mov	BYTE PTR $T258280[ebp], cl
	mov	dl, BYTE PTR $T258279[ebp]
	mov	BYTE PTR $T258293[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T258292[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T258291[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T258291[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$258288[ebp], edx
	mov	eax, DWORD PTR __Count$258288[ebp]
	mov	ecx, DWORD PTR $T258292[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$258289[ebp], edx
	cmp	DWORD PTR __Count$258288[ebp], 0
	jbe	SHORT $LN6@unchecked_@11
	mov	eax, DWORD PTR __Count$258288[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T258291[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$258288[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T258292[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@11:
	mov	eax, DWORD PTR __Result$258289[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
$T258310 = -21						; size = 1
$T258309 = -20						; size = 4
$T258308 = -16						; size = 4
__Result$258306 = -12					; size = 4
__Count$258305 = -8					; size = 4
__Cat$258300 = -3					; size = 1
$T258297 = -2						; size = 1
$T258296 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T258296[ebp], al
	mov	cl, BYTE PTR __Cat$258300[ebp]
	mov	BYTE PTR $T258297[ebp], cl
	mov	dl, BYTE PTR $T258296[ebp]
	mov	BYTE PTR $T258310[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T258309[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T258308[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T258308[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$258305[ebp], edx
	mov	eax, DWORD PTR __Count$258305[ebp]
	mov	ecx, DWORD PTR $T258309[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$258306[ebp], edx
	cmp	DWORD PTR __Count$258305[ebp], 0
	jbe	SHORT $LN6@unchecked_@12
	mov	eax, DWORD PTR __Count$258305[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T258308[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$258305[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T258309[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@12:
	mov	eax, DWORD PTR __Result$258306[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@7

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@7:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@8

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@8:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
END
