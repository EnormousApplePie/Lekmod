; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDealAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??0CvDealAI@@QAE@XZ				; CvDealAI::CvDealAI
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ??0CvDealAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvDealAI@@QAE@XZ PROC				; CvDealAI::CvDealAI, COMDAT
; _this$ = ecx

; 26   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 27   : #ifdef AUI_WARNING_FIXES
; 28   : 	Init(NULL);
; 29   : #endif
; 30   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvDealAI@@QAE@XZ ENDP				; CvDealAI::CvDealAI
_TEXT	ENDS
PUBLIC	?Uninit@CvDealAI@@QAEXXZ			; CvDealAI::Uninit
PUBLIC	??1CvDealAI@@QAE@XZ				; CvDealAI::~CvDealAI
; Function compile flags: /Odtp
;	COMDAT ??1CvDealAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvDealAI@@QAE@XZ PROC				; CvDealAI::~CvDealAI, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvDealAI@@QAEXXZ		; CvDealAI::Uninit

; 36   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvDealAI@@QAE@XZ ENDP				; CvDealAI::~CvDealAI
_TEXT	ENDS
PUBLIC	?Reset@CvDealAI@@QAEXXZ				; CvDealAI::Reset
PUBLIC	?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z		; CvDealAI::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z PROC		; CvDealAI::Init, COMDAT
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax], ecx

; 42   : 
; 43   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvDealAI@@QAEXXZ			; CvDealAI::Reset

; 44   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvDealAI@@QAEXPAVCvPlayer@@@Z ENDP		; CvDealAI::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@CvDealAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninit@CvDealAI@@QAEXXZ PROC				; CvDealAI::Uninit, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvDealAI@@QAEXXZ ENDP				; CvDealAI::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Reset@CvDealAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Reset@CvDealAI@@QAEXXZ PROC				; CvDealAI::Reset, COMDAT
; _this$ = ecx

; 53   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 54   : 	m_iCachedValueOfPeaceWithHuman = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 55   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvDealAI@@QAEXXZ ENDP				; CvDealAI::Reset
_TEXT	ENDS
PUBLIC	?Read@CvDealAI@@QAEXAAVFDataStream@@@Z		; CvDealAI::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvDealAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvDealAI@@QAEXAAVFDataStream@@@Z PROC		; CvDealAI::Read, COMDAT
; _this$ = ecx

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 	// Version number to maintain backwards compatibility
; 61   : 	uint uiVersion;
; 62   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvDealAI@@QAEXAAVFDataStream@@@Z ENDP		; CvDealAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvDealAI@@QBEXAAVFDataStream@@@Z		; CvDealAI::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvDealAI@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvDealAI@@QBEXAAVFDataStream@@@Z PROC		; CvDealAI::Write, COMDAT
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 	// Current version number
; 69   : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 70   : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvDealAI@@QBEXAAVFDataStream@@@Z ENDP		; CvDealAI::Write
_TEXT	ENDS
PUBLIC	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ		; CvDealAI::GetPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ PROC		; CvDealAI::GetPlayer, COMDAT
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 	return m_pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ ENDP		; CvDealAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ		; CvDealAI::GetTeam
; Function compile flags: /Odtp
;	COMDAT ?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T224240 = -4						; size = 4
?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ PROC		; CvDealAI::GetTeam, COMDAT
; _this$ = ecx

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	return m_pPlayer->getTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224240[ebp], ecx
	mov	edx, DWORD PTR $T224240[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4

; 83   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ ENDP		; CvDealAI::GetTeam
_TEXT	ENDS
PUBLIC	?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ	; CvDealAI::GetDealPercentLeewayWithAI
; Function compile flags: /Odtp
;	COMDAT ?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ PROC	; CvDealAI::GetDealPercentLeewayWithAI, COMDAT
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 	return 25;

	mov	eax, 25					; 00000019H

; 89   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ ENDP	; CvDealAI::GetDealPercentLeewayWithAI
_TEXT	ENDS
PUBLIC	?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ	; CvDealAI::GetDealPercentLeewayWithHuman
; Function compile flags: /Odtp
;	COMDAT ?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ PROC	; CvDealAI::GetDealPercentLeewayWithHuman, COMDAT
; _this$ = ecx

; 93   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 	return 10;

	mov	eax, 10					; 0000000aH

; 95   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ ENDP	; CvDealAI::GetDealPercentLeewayWithHuman
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
PUBLIC	?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z ; CvDealAI::DoAcceptedDeal
PUBLIC	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z ; CvDealAI::DoHumanOfferDealToThisAI
EXTRN	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetDiploStringForMessage
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	??1CvDeal@@UAE@XZ:PROC				; CvDeal::~CvDeal
EXTRN	?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z:PROC ; CvGlobals::WrapDealPointer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	??0CvDeal@@QAE@ABV0@@Z:PROC			; CvDeal::CvDeal
EXTRN	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsPeaceTreatyTrade
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$2
__ehfuncinfo$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
tv266 = -268						; size = 4
tv255 = -264						; size = 4
tv226 = -260						; size = 4
tv172 = -256						; size = 4
tv148 = -252						; size = 4
_this$ = -248						; size = 4
$T224351 = -244						; size = 4
$T224350 = -240						; size = 4
$T224341 = -236						; size = 4
$T224337 = -232						; size = 4
$T224333 = -228						; size = 4
_inst$224328 = -224					; size = 4
$T224324 = -220						; size = 4
$T224315 = -216						; size = 4
$T224314 = -212						; size = 4
$T224305 = -208						; size = 4
$T224301 = -204						; size = 4
_inst$224296 = -200					; size = 4
$T224292 = -196						; size = 4
$T224283 = -192						; size = 4
__Ptr$224282 = -188					; size = 4
$T224278 = -184						; size = 4
__Cvtptr$224276 = -180					; size = 4
__Ans$224277 = -176					; size = 4
$T224267 = -172						; size = 4
$T224263 = -168						; size = 4
$T224259 = -164						; size = 4
$T224255 = -160						; size = 4
$T224248 = -156						; size = 4
$T224247 = -152						; size = 4
_iTimesDealOffered$221478 = -148			; size = 4
_pDllDeal$221450 = -144					; size = 4
_kDeal$221401 = -140					; size = 76
_bDealAcceptable$ = -57					; size = 1
_iValueImOffering$ = -56				; size = 4
_iAmountUnderWeWillOffer$ = -52				; size = 4
_szText$ = -48						; size = 4
_iValueTheyreOffering$ = -44				; size = 4
_eAnimation$ = -40					; size = 4
_iDealValueToMe$ = -36					; size = 4
_eFromPlayer$ = -32					; size = 4
_iAmountOverWeWillRequest$ = -28			; size = 4
_bCantMatchOffer$ = -22					; size = 1
_bFromIsActivePlayer$ = -21				; size = 1
_eResponse$ = -20					; size = 4
_eUIState$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::DoHumanOfferDealToThisAI, COMDAT
; _this$ = ecx

; 99   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 	DealOfferResponseTypes eResponse = NO_DEAL_RESPONSE_TYPE;

	mov	DWORD PTR _eResponse$[ebp], -1

; 101  : 	DiploUIStateTypes eUIState = NO_DIPLO_UI_STATE;

	mov	DWORD PTR _eUIState$[ebp], -1

; 102  : 
; 103  : 	const char* szText = "";

	mov	DWORD PTR _szText$[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@

; 104  : 	LeaderheadAnimationTypes eAnimation = NO_LEADERHEAD_ANIM;

	mov	DWORD PTR _eAnimation$[ebp], -1

; 105  : 
; 106  : 	PlayerTypes eFromPlayer = GC.getGame().getActivePlayer();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224255[ebp], eax
	mov	ecx, DWORD PTR $T224255[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eFromPlayer$[ebp], eax

; 107  : 
; 108  : 	bool bFromIsActivePlayer = eFromPlayer == GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224259[ebp], ecx
	mov	ecx, DWORD PTR $T224259[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	xor	edx, edx
	cmp	DWORD PTR _eFromPlayer$[ebp], eax
	sete	dl
	mov	BYTE PTR _bFromIsActivePlayer$[ebp], dl

; 109  : 
; 110  : 	int iDealValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer;
; 111  : 	bool bCantMatchOffer;
; 112  : 	bool bDealAcceptable = IsDealWithHumanAcceptable(pDeal, eFromPlayer, /*Passed by reference*/ iDealValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, bCantMatchOffer);

	lea	eax, DWORD PTR _bCantMatchOffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iDealValueToMe$[ebp]
	push	edx
	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable
	mov	BYTE PTR _bDealAcceptable$[ebp], al

; 113  : 
; 114  : 	// If they're actually giving us more than we're asking for (e.g. a gift) then accept the deal
; 115  : 	if(!bDealAcceptable)

	movzx	edx, BYTE PTR _bDealAcceptable$[ebp]
	test	edx, edx
	jne	SHORT $LN15@DoHumanOff

; 116  : 	{
; 117  : 		if(!pDeal->IsPeaceTreatyTrade(eFromPlayer) && iValueTheyreOffering > iValueImOffering)

	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@DoHumanOff
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	cmp	edx, DWORD PTR _iValueImOffering$[ebp]
	jle	SHORT $LN15@DoHumanOff

; 118  : 		{
; 119  : 			bDealAcceptable = true;

	mov	BYTE PTR _bDealAcceptable$[ebp], 1
$LN15@DoHumanOff:

; 120  : 		}
; 121  : 	}
; 122  : 
; 123  : 	if(bDealAcceptable)

	movzx	eax, BYTE PTR _bDealAcceptable$[ebp]
	test	eax, eax
	je	$LN13@DoHumanOff

; 124  : 	{
; 125  : 		CvDeal kDeal = *pDeal;

	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$221401[ebp]
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 126  : 
; 127  : 		// If it's from a human, send it through the network
; 128  : 		if(GET_PLAYER(eFromPlayer).isHuman())

	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224263[ebp], edx
	mov	ecx, DWORD PTR $T224263[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	$LN12@DoHumanOff

; 129  : 		{
; 130  : 			GC.GetEngineUserInterface()->SetDealInTransit(true);

	mov	ecx, DWORD PTR $T224267[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv148[ebp], edx
	push	1
	mov	eax, DWORD PTR tv148[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv148[ebp]
	mov	eax, DWORD PTR [edx+564]
	call	eax

; 131  : 			auto_ptr<ICvDeal1> pDllDeal = GC.WrapDealPointer(&kDeal);

	lea	ecx, DWORD PTR _kDeal$221401[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224247[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z ; CvGlobals::WrapDealPointer
	mov	DWORD PTR $T224278[ebp], eax
	mov	eax, DWORD PTR $T224278[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Cvtptr$224276[ebp], ecx
	mov	edx, DWORD PTR __Cvtptr$224276[ebp]
	mov	DWORD PTR __Ans$224277[ebp], edx
	mov	eax, DWORD PTR $T224278[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR __Ans$224277[ebp]
	mov	DWORD PTR $T224248[ebp], ecx
	mov	edx, DWORD PTR $T224248[ebp]
	mov	DWORD PTR $T224283[ebp], edx
	mov	eax, DWORD PTR $T224283[ebp]
	mov	DWORD PTR __Ptr$224282[ebp], eax
	mov	DWORD PTR $T224283[ebp], 0
	mov	ecx, DWORD PTR __Ptr$224282[ebp]
	mov	DWORD PTR _pDllDeal$221450[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T224247[ebp]
	mov	DWORD PTR $T224292[ebp], edx
	cmp	DWORD PTR $T224292[ebp], 0
	je	SHORT $LN35@DoHumanOff
	mov	eax, DWORD PTR $T224292[ebp]
	mov	DWORD PTR _inst$224296[ebp], eax
	mov	ecx, DWORD PTR _inst$224296[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _inst$224296[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+4]
	call	ecx
$LN35@DoHumanOff:

; 132  : 			gDLL->sendNetDealAccepted(eFromPlayer, GetPlayer()->GetID(), pDllDeal.get(), iDealValueToMe, iValueImOffering, iValueTheyreOffering);

	mov	edx, DWORD PTR $T224301[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv172[ebp], eax
	mov	ecx, DWORD PTR _pDllDeal$221450[ebp]
	mov	DWORD PTR $T224305[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224314[ebp], eax
	mov	edx, DWORD PTR $T224314[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T224315[ebp], eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDealValueToMe$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224305[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224315[ebp]
	push	edx
	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv172[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv172[ebp]
	mov	eax, DWORD PTR [edx+360]
	call	eax

; 133  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _pDllDeal$221450[ebp]
	mov	DWORD PTR $T224324[ebp], ecx
	cmp	DWORD PTR $T224324[ebp], 0
	je	SHORT $LN48@DoHumanOff
	mov	edx, DWORD PTR $T224324[ebp]
	mov	DWORD PTR _inst$224328[ebp], edx
	mov	eax, DWORD PTR _inst$224328[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$224328[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN48@DoHumanOff:

; 134  : 		// Deal between AI players, we can process it immediately
; 135  : 		else

	jmp	SHORT $LN11@DoHumanOff
$LN12@DoHumanOff:

; 136  : 		{
; 137  : 			DoAcceptedDeal(eFromPlayer, kDeal, iDealValueToMe, iValueImOffering, iValueTheyreOffering);

	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDealValueToMe$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kDeal$221401[ebp]
	push	ecx
	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z ; CvDealAI::DoAcceptedDeal
$LN11@DoHumanOff:

; 138  : 		}
; 139  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kDeal$221401[ebp]
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal

; 140  : 	// We want more from this Deal
; 141  : 	else if(iDealValueToMe > -75 &&

	jmp	$LN10@DoHumanOff
$LN13@DoHumanOff:

; 142  : 	        iValueImOffering < (iValueTheyreOffering * 5))	// The total value of the deal might not be that bad, but if he's asking for WAY more than he's offering (e.g. something for nothing) then it's not unacceptable, but insulting

	cmp	DWORD PTR _iDealValueToMe$[ebp], -75	; ffffffb5H
	jle	SHORT $LN9@DoHumanOff
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	imul	eax, 5
	cmp	DWORD PTR _iValueImOffering$[ebp], eax
	jge	SHORT $LN9@DoHumanOff

; 143  : 	{
; 144  : 		eResponse = DEAL_RESPONSE_UNACCEPTABLE;

	mov	DWORD PTR _eResponse$[ebp], 2

; 145  : 		eUIState = DIPLO_UI_STATE_TRADE_AI_REJECTS_OFFER;

	mov	DWORD PTR _eUIState$[ebp], 6

; 146  : 
; 147  : 		if(bFromIsActivePlayer)

	movzx	ecx, BYTE PTR _bFromIsActivePlayer$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@DoHumanOff

; 148  : 		{
; 149  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_REJECT_UNACCEPTABLE);

	push	-1
	push	138					; 0000008aH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$[ebp], eax

; 150  : 			eAnimation = LEADERHEAD_ANIM_NO;

	mov	DWORD PTR _eAnimation$[ebp], 17		; 00000011H
$LN8@DoHumanOff:

; 151  : 		}
; 152  : 	}
; 153  : 	// Pretty bad deal for us
; 154  : 	else

	jmp	SHORT $LN10@DoHumanOff
$LN9@DoHumanOff:

; 155  : 	{
; 156  : 		eResponse = DEAL_RESPONSE_INSULTING;

	mov	DWORD PTR _eResponse$[ebp], 3

; 157  : 		eUIState = DIPLO_UI_STATE_TRADE_AI_REJECTS_OFFER;

	mov	DWORD PTR _eUIState$[ebp], 6

; 158  : 
; 159  : 		if(bFromIsActivePlayer)

	movzx	edx, BYTE PTR _bFromIsActivePlayer$[ebp]
	test	edx, edx
	je	SHORT $LN10@DoHumanOff

; 160  : 		{
; 161  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_REJECT_INSULTING);

	push	-1
	push	139					; 0000008bH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$[ebp], eax

; 162  : 			eAnimation = LEADERHEAD_ANIM_NO;

	mov	DWORD PTR _eAnimation$[ebp], 17		; 00000011H
$LN10@DoHumanOff:

; 163  : 		}
; 164  : 	}
; 165  : 
; 166  : 	if(bFromIsActivePlayer)

	movzx	eax, BYTE PTR _bFromIsActivePlayer$[ebp]
	test	eax, eax
	je	$LN5@DoHumanOff

; 167  : 	{
; 168  : 		// Modify response if the player's offered a deal lot
; 169  : 		if(eResponse >= DEAL_RESPONSE_UNACCEPTABLE)

	cmp	DWORD PTR _eResponse$[ebp], 2
	jl	$LN5@DoHumanOff

; 170  : 		{
; 171  : 			int iTimesDealOffered = GC.GetEngineUserInterface()->GetOfferTradeRepeatCount();

	mov	ecx, DWORD PTR $T224333[ebp]
	mov	DWORD PTR tv226[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv226[ebp], edx
	mov	eax, DWORD PTR tv226[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv226[ebp]
	mov	eax, DWORD PTR [edx+488]
	call	eax
	mov	DWORD PTR _iTimesDealOffered$221478[ebp], eax

; 172  : 			if(iTimesDealOffered > 4)

	cmp	DWORD PTR _iTimesDealOffered$221478[ebp], 4
	jle	SHORT $LN3@DoHumanOff

; 173  : 			{
; 174  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_TRADE_TOO_MUCH);

	push	-1
	push	132					; 00000084H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$[ebp], eax
	jmp	SHORT $LN2@DoHumanOff
$LN3@DoHumanOff:

; 175  : 			}
; 176  : 			else if(iTimesDealOffered > 1)

	cmp	DWORD PTR _iTimesDealOffered$221478[ebp], 1
	jle	SHORT $LN2@DoHumanOff

; 177  : 			{
; 178  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_REPEAT_TRADE);

	push	-1
	push	133					; 00000085H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$[ebp], eax
$LN2@DoHumanOff:

; 179  : 			}
; 180  : 
; 181  : 			GC.GetEngineUserInterface()->ChangeOfferTradeRepeatCount(1);

	mov	ecx, DWORD PTR $T224337[ebp]
	mov	DWORD PTR tv255[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv255[ebp], edx
	push	1
	mov	eax, DWORD PTR tv255[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv255[ebp]
	mov	eax, DWORD PTR [edx+496]
	call	eax

; 182  : 			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), eUIState, szText, eAnimation);

	mov	ecx, DWORD PTR $T224341[ebp]
	mov	DWORD PTR tv266[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv266[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224350[ebp], eax
	mov	eax, DWORD PTR $T224350[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T224351[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _eAnimation$[ebp]
	push	edx
	mov	eax, DWORD PTR _szText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUIState$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224351[ebp]
	push	edx
	mov	eax, DWORD PTR tv266[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv266[ebp]
	mov	eax, DWORD PTR [edx+736]
	call	eax
$LN5@DoHumanOff:

; 183  : 		}
; 184  : 	}
; 185  : 
; 186  : 	return eResponse;

	mov	eax, DWORD PTR _eResponse$[ebp]

; 187  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _kDeal$221401[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z$2:
	lea	ecx, DWORD PTR _pDllDeal$221450[ebp]
	jmp	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ	; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
__ehhandler$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoHumanOfferDealToThisAI@CvDealAI@@QAE?AW4DealOfferResponseTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::DoHumanOfferDealToThisAI
PUBLIC	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman
PUBLIC	?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ ; CvDealAI::GetCachedValueOfPeaceWithHuman
EXTRN	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ:PROC ; CvDeal::GetPeaceTreatyType
EXTRN	?ChangeRecentTradeValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeRecentTradeValue
EXTRN	?ChangeRecentAssistValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDiplomacyAI::ChangeRecentAssistValue
EXTRN	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ:PROC ; CvDeal::GetRequestingPlayer
EXTRN	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ:PROC ; CvDeal::GetDemandingPlayer
EXTRN	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z:PROC ; CvGameDeals::FinalizeDeal
EXTRN	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z:PROC ; CvGameDeals::AddProposedDeal
EXTRN	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ:PROC ; CvGame::GetGameDeals
EXTRN	?ClearDealToRenew@CvDiplomacyAI@@QAEXXZ:PROC	; CvDiplomacyAI::ClearDealToRenew
EXTRN	?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z:PROC ; CvGameDeals::PrepareRenewDeal
EXTRN	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z:PROC ; CvDiplomacyAI::GetDealToRenew
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z$0
__ehfuncinfo$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
_TEXT	SEGMENT
tv358 = -188						; size = 4
tv325 = -184						; size = 4
tv306 = -180						; size = 4
tv240 = -176						; size = 4
tv201 = -172						; size = 4
tv171 = -168						; size = 4
tv362 = -164						; size = 4
tv355 = -160						; size = 4
_this$ = -156						; size = 4
$T224500 = -152						; size = 4
$T224496 = -148						; size = 4
$T224495 = -144						; size = 4
$T224486 = -140						; size = 4
$T224482 = -136						; size = 4
$T224478 = -132						; size = 4
$T224477 = -128						; size = 4
$T224468 = -124						; size = 4
$T224464 = -120						; size = 4
$T224460 = -116						; size = 4
$T224456 = -112						; size = 4
$T224452 = -108						; size = 4
$T224451 = -104						; size = 4
$T224442 = -100						; size = 4
$T224438 = -96						; size = 4
$T224434 = -92						; size = 4
$T224433 = -88						; size = 4
$T224424 = -84						; size = 4
$T224423 = -80						; size = 4
$T224414 = -76						; size = 4
$T224410 = -72						; size = 4
$T224406 = -68						; size = 4
$T224405 = -64						; size = 4
$T224396 = -60						; size = 4
$T224392 = -56						; size = 4
$T224388 = -52						; size = 4
$T224384 = -48						; size = 4
$T224380 = -44						; size = 4
$T224379 = -40						; size = 4
$T224370 = -36						; size = 4
$T224365 = -32						; size = 4
_szText$221498 = -28					; size = 4
_eAnimation$221495 = -24				; size = 4
_eUIState$221497 = -20					; size = 4
_iDealType$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eFromPlayer$ = 8					; size = 4
_kDeal$ = 12						; size = 4
_iDealValueToMe$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z PROC ; CvDealAI::DoAcceptedDeal, COMDAT
; _this$ = ecx

; 191  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 192  : 	int iDealType = -1;

	mov	DWORD PTR _iDealType$[ebp], -1

; 193  : 	if(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(&iDealType))

	lea	eax, DWORD PTR _iDealType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	test	eax, eax
	je	SHORT $LN16@DoAccepted

; 194  : 	{
; 195  : 		if (iDealType != 0) // if it's not a historic deal

	cmp	DWORD PTR _iDealType$[ebp], 0
	je	SHORT $LN15@DoAccepted

; 196  : 		{
; 197  : 			// make the deal not remove resources when processed
; 198  : 			CvGameDeals::PrepareRenewDeal(m_pPlayer->GetDiplomacyAI()->GetDealToRenew(), &kDeal);

	mov	edx, DWORD PTR _kDeal$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDealToRenew@CvDiplomacyAI@@QAEPAVCvDeal@@PAH@Z ; CvDiplomacyAI::GetDealToRenew
	push	eax
	call	?PrepareRenewDeal@CvGameDeals@@SAXPAVCvDeal@@PBV2@@Z ; CvGameDeals::PrepareRenewDeal
	add	esp, 8
$LN15@DoAccepted:

; 199  : 		}
; 200  : 		m_pPlayer->GetDiplomacyAI()->ClearDealToRenew();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ClearDealToRenew@CvDiplomacyAI@@QAEXXZ	; CvDiplomacyAI::ClearDealToRenew
$LN16@DoAccepted:

; 201  : 	}
; 202  : 
; 203  : 	GC.getGame().GetGameDeals()->AddProposedDeal(kDeal);

	sub	esp, 76					; 0000004cH
	mov	ecx, esp
	mov	DWORD PTR $T224365[ebp], esp
	mov	edx, DWORD PTR _kDeal$[ebp]
	push	edx
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	DWORD PTR tv355[ebp], eax
	mov	eax, DWORD PTR tv355[ebp]
	mov	DWORD PTR tv362[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224370[ebp], ecx
	mov	ecx, DWORD PTR $T224370[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, eax
	call	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z ; CvGameDeals::AddProposedDeal

; 204  : 	GC.getGame().GetGameDeals()->FinalizeDeal(eFromPlayer, GetPlayer()->GetID(), true);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224379[ebp], eax
	mov	edx, DWORD PTR $T224379[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T224380[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224384[ebp], ecx
	push	1
	mov	edx, DWORD PTR $T224380[ebp]
	push	edx
	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224384[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal

; 205  : 
; 206  : 	if(GET_PLAYER(eFromPlayer).isHuman())

	mov	ecx, DWORD PTR _eFromPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224388[ebp], ecx
	mov	ecx, DWORD PTR $T224388[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	$LN14@DoAccepted

; 207  : 	{
; 208  : 		iDealValueToMe -= GetCachedValueOfPeaceWithHuman();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ ; CvDealAI::GetCachedValueOfPeaceWithHuman
	mov	ecx, DWORD PTR _iDealValueToMe$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iDealValueToMe$[ebp], ecx

; 209  : 
; 210  : 		// Reset cached values
; 211  : 		SetCachedValueOfPeaceWithHuman(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman

; 212  : 
; 213  : 		LeaderheadAnimationTypes eAnimation;
; 214  : 		// This signals Lua to do some interface cleanup, we only want to do this on the local machine.
; 215  : 		if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224392[ebp], edx
	mov	ecx, DWORD PTR $T224392[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN13@DoAccepted

; 216  : 			gDLL->DoClearDiplomacyTradeTable();

	mov	eax, DWORD PTR $T224396[ebp]
	mov	DWORD PTR tv171[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv171[ebp], ecx
	mov	edx, DWORD PTR tv171[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv171[ebp]
	mov	edx, DWORD PTR [eax+732]
	call	edx
$LN13@DoAccepted:

; 217  : 
; 218  : 		DiploUIStateTypes eUIState = NO_DIPLO_UI_STATE;

	mov	DWORD PTR _eUIState$221497[ebp], -1

; 219  : 
; 220  : 		const char* szText = 0;

	mov	DWORD PTR _szText$221498[ebp], 0

; 221  : 
; 222  : 		// We made a demand and they gave in
; 223  : 		if(kDeal.GetDemandingPlayer() == GetPlayer()->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224405[ebp], eax
	mov	eax, DWORD PTR $T224405[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T224406[ebp], ecx
	mov	ecx, DWORD PTR _kDeal$[ebp]
	call	?GetDemandingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetDemandingPlayer
	cmp	eax, DWORD PTR $T224406[ebp]
	jne	$LN12@DoAccepted

; 224  : 		{
; 225  : 			if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224410[ebp], edx
	mov	ecx, DWORD PTR $T224410[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN11@DoAccepted

; 226  : 			{
; 227  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_ACCEPT_AI_DEMAND);

	push	-1
	push	136					; 00000088H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$221498[ebp], eax

; 228  : 				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION_MEAN_AI, szText, LEADERHEAD_ANIM_POSITIVE);

	mov	eax, DWORD PTR $T224414[ebp]
	mov	DWORD PTR tv201[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv201[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224423[ebp], eax
	mov	edx, DWORD PTR $T224423[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T224424[ebp], eax
	push	-1
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _szText$221498[ebp]
	push	ecx
	push	14					; 0000000eH
	mov	edx, DWORD PTR $T224424[ebp]
	push	edx
	mov	eax, DWORD PTR tv201[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv201[ebp]
	mov	eax, DWORD PTR [edx+736]
	call	eax
$LN11@DoAccepted:

; 229  : 			}
; 230  : 
; 231  : 			return;

	jmp	$LN17@DoAccepted
$LN12@DoAccepted:

; 232  : 		}
; 233  : 
; 234  : 		// We made a request and they agreed
; 235  : 		if(kDeal.GetRequestingPlayer() == GetPlayer()->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224433[ebp], eax
	mov	ecx, DWORD PTR $T224433[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T224434[ebp], edx
	mov	ecx, DWORD PTR _kDeal$[ebp]
	call	?GetRequestingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetRequestingPlayer
	cmp	eax, DWORD PTR $T224434[ebp]
	jne	$LN10@DoAccepted

; 236  : 		{
; 237  : 			if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224438[ebp], eax
	mov	ecx, DWORD PTR $T224438[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN9@DoAccepted

; 238  : 			{
; 239  : 				szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_THANKFUL);

	push	-1
	push	69					; 00000045H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$221498[ebp], eax

; 240  : 				gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), DIPLO_UI_STATE_BLANK_DISCUSSION, szText, LEADERHEAD_ANIM_POSITIVE);

	mov	ecx, DWORD PTR $T224442[ebp]
	mov	DWORD PTR tv240[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv240[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224451[ebp], eax
	mov	eax, DWORD PTR $T224451[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T224452[ebp], ecx
	push	-1
	push	30					; 0000001eH
	mov	edx, DWORD PTR _szText$221498[ebp]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T224452[ebp]
	push	eax
	mov	ecx, DWORD PTR tv240[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv240[ebp]
	mov	eax, DWORD PTR [edx+736]
	call	eax
$LN9@DoAccepted:

; 241  : 			}
; 242  : 			GetPlayer()->GetDiplomacyAI()->ChangeRecentAssistValue(eFromPlayer, -iDealValueToMe);

	mov	ecx, DWORD PTR _iDealValueToMe$[ebp]
	neg	ecx
	push	ecx
	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeRecentAssistValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeRecentAssistValue

; 243  : 			return;

	jmp	$LN17@DoAccepted
$LN10@DoAccepted:

; 244  : 		}
; 245  : 
; 246  : 		eUIState = DIPLO_UI_STATE_BLANK_DISCUSSION;

	mov	DWORD PTR _eUIState$221497[ebp], 12	; 0000000cH

; 247  : 
; 248  : 		// Good deal for us
; 249  : 		if(iDealValueToMe >= 100 ||
; 250  : 		        iValueTheyreOffering > (iValueImOffering * 5))	// A deal can be generous if we're getting a lot overall, OR a lot more than we're giving up

	cmp	DWORD PTR _iDealValueToMe$[ebp], 100	; 00000064H
	jge	SHORT $LN7@DoAccepted
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	imul	eax, 5
	cmp	DWORD PTR _iValueTheyreOffering$[ebp], eax
	jle	SHORT $LN8@DoAccepted
$LN7@DoAccepted:

; 251  : 		{
; 252  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_ACCEPT_GENEROUS);

	push	-1
	push	134					; 00000086H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$221498[ebp], eax

; 253  : 			eAnimation = LEADERHEAD_ANIM_YES;

	mov	DWORD PTR _eAnimation$221495[ebp], 16	; 00000010H

; 254  : 			GetPlayer()->GetDiplomacyAI()->ChangeRecentTradeValue(eFromPlayer, iDealValueToMe);

	mov	ecx, DWORD PTR _iDealValueToMe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeRecentTradeValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeRecentTradeValue

; 255  : 		}
; 256  : 		// Acceptable deal for us
; 257  : 		else

	jmp	SHORT $LN6@DoAccepted
$LN8@DoAccepted:

; 258  : 		{
; 259  : 			szText = GetPlayer()->GetDiplomacyAI()->GetDiploStringForMessage(DIPLO_MESSAGE_TRADE_ACCEPT_ACCEPTABLE);

	push	-1
	push	135					; 00000087H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetDiploStringForMessage@CvDiplomacyAI@@QAEPBDW4DiploMessageTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetDiploStringForMessage
	mov	DWORD PTR _szText$221498[ebp], eax

; 260  : 			eAnimation = LEADERHEAD_ANIM_YES;

	mov	DWORD PTR _eAnimation$221495[ebp], 16	; 00000010H

; 261  : 			GetPlayer()->GetDiplomacyAI()->ChangeRecentTradeValue(eFromPlayer, (iDealValueToMe / 2));

	mov	eax, DWORD PTR _iDealValueToMe$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ChangeRecentTradeValue@CvDiplomacyAI@@QAEXW4PlayerTypes@@H@Z ; CvDiplomacyAI::ChangeRecentTradeValue
$LN6@DoAccepted:

; 262  : 		}
; 263  : 
; 264  : 		if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224456[ebp], ecx
	mov	ecx, DWORD PTR $T224456[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN5@DoAccepted

; 265  : 			GC.GetEngineUserInterface()->SetOfferTradeRepeatCount(0);

	mov	edx, DWORD PTR $T224460[ebp]
	mov	DWORD PTR tv306[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv306[ebp], eax
	push	0
	mov	ecx, DWORD PTR tv306[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv306[ebp]
	mov	eax, DWORD PTR [edx+492]
	call	eax
$LN5@DoAccepted:

; 266  : 
; 267  : 		// If this was a peace deal then use that animation instead
; 268  : 		if(kDeal.GetPeaceTreatyType() != NO_PEACE_TREATY_TYPE)

	mov	ecx, DWORD PTR _kDeal$[ebp]
	call	?GetPeaceTreatyType@CvDeal@@QBE?AW4PeaceTreatyTypes@@XZ ; CvDeal::GetPeaceTreatyType
	cmp	eax, -1
	je	SHORT $LN4@DoAccepted

; 269  : 		{
; 270  : 			eAnimation = LEADERHEAD_ANIM_PEACEFUL;

	mov	DWORD PTR _eAnimation$221495[ebp], 3
$LN4@DoAccepted:

; 271  : 		}
; 272  : 
; 273  : 		// Send message back to diplo UI
; 274  : 		if(GC.getGame().getActivePlayer() == eFromPlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224464[ebp], ecx
	mov	ecx, DWORD PTR $T224464[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _eFromPlayer$[ebp]
	jne	SHORT $LN14@DoAccepted

; 275  : 			gDLL->GameplayDiplomacyAILeaderMessage(GetPlayer()->GetID(), eUIState, szText, eAnimation);

	mov	edx, DWORD PTR $T224468[ebp]
	mov	DWORD PTR tv325[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv325[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224477[ebp], eax
	mov	ecx, DWORD PTR $T224477[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T224478[ebp], edx
	push	-1
	mov	eax, DWORD PTR _eAnimation$221495[ebp]
	push	eax
	mov	ecx, DWORD PTR _szText$221498[ebp]
	push	ecx
	mov	edx, DWORD PTR _eUIState$221497[ebp]
	push	edx
	mov	eax, DWORD PTR $T224478[ebp]
	push	eax
	mov	ecx, DWORD PTR tv325[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv325[ebp]
	mov	eax, DWORD PTR [edx+736]
	call	eax
$LN14@DoAccepted:

; 276  : 	}
; 277  : 
; 278  : 	if(GC.getGame().getActivePlayer() == eFromPlayer || GC.getGame().getActivePlayer() == GetPlayer()->GetID())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224482[ebp], ecx
	mov	ecx, DWORD PTR $T224482[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _eFromPlayer$[ebp]
	je	SHORT $LN1@DoAccepted
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224486[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224495[ebp], eax
	mov	eax, DWORD PTR $T224495[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T224496[ebp], ecx
	mov	ecx, DWORD PTR $T224486[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR $T224496[ebp]
	jne	SHORT $LN17@DoAccepted
$LN1@DoAccepted:

; 279  : 	{
; 280  : 		GC.GetEngineUserInterface()->makeInterfaceDirty();

	mov	edx, DWORD PTR $T224500[ebp]
	mov	DWORD PTR tv358[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv358[ebp], eax
	mov	ecx, DWORD PTR tv358[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv358[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
$LN17@DoAccepted:

; 281  : 	}
; 282  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z$0:
	mov	ecx, DWORD PTR $T224365[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__ehhandler$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-180]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAcceptedDeal@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@HHH@Z ENDP ; CvDealAI::DoAcceptedDeal
PUBLIC	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
PUBLIC	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
PUBLIC	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
PUBLIC	??_C@_0EL@KKMPAGGO@Deal?5AI?3?5ASYNC?5RAND?5call?5to?5dete@ ; `string'
PUBLIC	?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z ; CvDealAI::DoHumanDemand
EXTRN	?DoFromUIDiploEvent@CvGame@@QAEXW4FromUIDiploEventTypes@@W4PlayerTypes@@HH@Z:PROC ; CvGame::DoFromUIDiploEvent
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?CalculateBaseNetGold@CvTreasury@@QAEHXZ:PROC	; CvTreasury::CalculateBaseNetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?getAsyncRandNum@CvGame@@QAEHHPBD@Z:PROC	; CvGame::getAsyncRandNum
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
EXTRN	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMajorCivOpinion
EXTRN	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z:PROC ; CvPlayer::GetProximityToPlayer
EXTRN	?GetMilitaryAggressivePosture@CvDiplomacyAI@@QBE?AW4AggressivePostureTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMilitaryAggressivePosture
EXTRN	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?IsDemandTooSoon@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsDemandTooSoon
;	COMDAT ??_C@_0EL@KKMPAGGO@Deal?5AI?3?5ASYNC?5RAND?5call?5to?5dete@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
CONST	SEGMENT
??_C@_0EL@KKMPAGGO@Deal?5AI?3?5ASYNC?5RAND?5call?5to?5dete@ DB 'Deal AI: '
	DB	'ASYNC RAND call to determine if AI will give into a human dem'
	DB	'and.', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$5
__ehfuncinfo$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
tv305 = -364						; size = 4
tv281 = -360						; size = 4
tv503 = -356						; size = 4
tv221 = -352						; size = 4
tv319 = -348						; size = 4
tv151 = -344						; size = 4
_this$ = -340						; size = 4
_inst$224959 = -336					; size = 4
$T224955 = -332						; size = 4
$T224945 = -328						; size = 4
$T224944 = -324						; size = 4
$T224935 = -320						; size = 4
$T224931 = -316						; size = 4
_inst$224927 = -312					; size = 4
$T224923 = -308						; size = 4
$T224913 = -304						; size = 4
__Ptr$224911 = -300					; size = 4
$T224908 = -296						; size = 4
__Cvtptr$224903 = -292					; size = 4
__Ans$224904 = -288					; size = 4
$T224897 = -284						; size = 4
$T224893 = -280						; size = 4
$T224846 = -276						; size = 4
$T224814 = -272						; size = 4
$T224782 = -268						; size = 4
$T224776 = -264						; size = 4
$T224749 = -260						; size = 4
$T224741 = -256						; size = 4
$T224708 = -252						; size = 4
$T224676 = -248						; size = 4
$T224644 = -244						; size = 4
$T224621 = -240						; size = 4
$T224605 = -236						; size = 4
$T224601 = -232						; size = 4
$T224592 = -228						; size = 4
$T224544 = -224						; size = 4
$T224540 = -220						; size = 4
$T224536 = -216						; size = 4
$T224532 = -212						; size = 4
$T224523 = -208						; size = 4
$T224513 = -204						; size = 4
$T224512 = -200						; size = 4
$T224511 = -196						; size = 8
$T224510 = -185						; size = 1
$T224509 = -184						; size = 8
_pDllDeal$221695 = -176					; size = 4
_kDeal$221693 = -172					; size = 76
_eUsage$221683 = -88					; size = 4
_eResource$221681 = -84					; size = 4
_iTempGold$221555 = -80					; size = 4
_iValueDemanded$221553 = -76				; size = 4
_iGPT$221554 = -72					; size = 4
_iModdedGoldValue$221556 = -68				; size = 4
_it$221664 = -64					; size = 8
_iOddsOfGivingIn$221534 = -56				; size = 4
_iAsyncRand$221549 = -52				; size = 4
_eProximity$221525 = -48				; size = 4
_eMilitaryStrength$221523 = -44				; size = 4
_eMilitaryPosture$221524 = -40				; size = 4
_eApproach$221522 = -36					; size = 4
_eMyPlayer$ = -32					; size = 4
_eFromPlayer$ = -28					; size = 4
_pDiploAI$ = -24					; size = 4
_iValueWillingToGiveUp$ = -20				; size = 4
_eResponse$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::DoHumanDemand, COMDAT
; _this$ = ecx

; 286  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 	DemandResponseTypes eResponse = NO_DEMAND_RESPONSE_TYPE;

	mov	DWORD PTR _eResponse$[ebp], -1

; 288  : 
; 289  : 	PlayerTypes eFromPlayer = GC.getGame().getActivePlayer();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224523[ebp], eax
	mov	ecx, DWORD PTR $T224523[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eFromPlayer$[ebp], eax

; 290  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224532[ebp], eax
	mov	ecx, DWORD PTR $T224532[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _eMyPlayer$[ebp], edx

; 291  : 
; 292  : 	int iValueWillingToGiveUp = 0;

	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], 0

; 293  : 
; 294  : 	CvDiplomacyAI* pDiploAI = GET_PLAYER(eMyPlayer).GetDiplomacyAI();

	mov	eax, DWORD PTR _eMyPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224536[ebp], eax
	mov	ecx, DWORD PTR $T224536[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pDiploAI$[ebp], eax

; 295  : 	// Too soon for another demand?
; 296  : 	if(pDiploAI->IsDemandTooSoon(eFromPlayer))

	mov	ecx, DWORD PTR _eFromPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?IsDemandTooSoon@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsDemandTooSoon
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN44@DoHumanDem

; 297  : 		eResponse = DEMAND_RESPONSE_REFUSE_TOO_SOON;

	mov	DWORD PTR _eResponse$[ebp], 4

; 298  : 
; 299  : 	// Not too soon for a demand
; 300  : 	else

	jmp	$LN43@DoHumanDem
$LN44@DoHumanDem:

; 301  : 	{
; 302  : 		MajorCivApproachTypes eApproach = pDiploAI->GetMajorCivApproach(eFromPlayer, /*bHideTrueFeelings*/ true);

	push	1
	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR _eApproach$221522[ebp], eax

; 303  : 		StrengthTypes eMilitaryStrength = pDiploAI->GetPlayerMilitaryStrengthComparedToUs(eFromPlayer);

	mov	ecx, DWORD PTR _eFromPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetPlayerMilitaryStrengthComparedToUs@CvDiplomacyAI@@QBE?AW4StrengthTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetPlayerMilitaryStrengthComparedToUs
	mov	DWORD PTR _eMilitaryStrength$221523[ebp], eax

; 304  : 		AggressivePostureTypes eMilitaryPosture = pDiploAI->GetMilitaryAggressivePosture(eFromPlayer);

	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMilitaryAggressivePosture@CvDiplomacyAI@@QBE?AW4AggressivePostureTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMilitaryAggressivePosture
	mov	DWORD PTR _eMilitaryPosture$221524[ebp], eax

; 305  : 		PlayerProximityTypes eProximity = GET_PLAYER(eMyPlayer).GetProximityToPlayer(eFromPlayer);

	mov	eax, DWORD PTR _eMyPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224540[ebp], eax
	mov	ecx, DWORD PTR _eFromPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T224540[ebp]
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	mov	DWORD PTR _eProximity$221525[ebp], eax

; 306  : 
; 307  : 		// Unforgivable: AI will never give in
; 308  : 		if(pDiploAI->GetMajorCivOpinion(eFromPlayer) == MAJOR_CIV_OPINION_UNFORGIVABLE)

	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	test	eax, eax
	jne	SHORT $LN42@DoHumanDem

; 309  : 			eResponse = DEMAND_RESPONSE_REFUSE_HOSTILE;

	mov	DWORD PTR _eResponse$[ebp], 2
	jmp	$LN43@DoHumanDem
$LN42@DoHumanDem:

; 310  : 
; 311  : 		// Hostile: AI will never give in
; 312  : 		else if(eApproach == MAJOR_CIV_APPROACH_HOSTILE)

	cmp	DWORD PTR _eApproach$221522[ebp], 1
	jne	SHORT $LN40@DoHumanDem

; 313  : 			eResponse = DEMAND_RESPONSE_REFUSE_HOSTILE;

	mov	DWORD PTR _eResponse$[ebp], 2
	jmp	$LN43@DoHumanDem
$LN40@DoHumanDem:

; 314  : 
; 315  : 		// Our military is stronger: AI will never give in
; 316  : 		else if(eMilitaryStrength < STRENGTH_AVERAGE)

	cmp	DWORD PTR _eMilitaryStrength$221523[ebp], 3
	jge	SHORT $LN38@DoHumanDem

; 317  : 			eResponse = DEMAND_RESPONSE_REFUSE_WEAK;

	mov	DWORD PTR _eResponse$[ebp], 1
	jmp	$LN43@DoHumanDem
$LN38@DoHumanDem:

; 318  : 
; 319  : 		// They are very far away and have no units near us (from what we can tell): AI will never give in
; 320  : 		else if(eProximity <= PLAYER_PROXIMITY_FAR && eMilitaryPosture == AGGRESSIVE_POSTURE_NONE)

	cmp	DWORD PTR _eProximity$221525[ebp], 1
	jg	SHORT $LN36@DoHumanDem
	cmp	DWORD PTR _eMilitaryPosture$221524[ebp], 0
	jne	SHORT $LN36@DoHumanDem

; 321  : 			eResponse = DEMAND_RESPONSE_REFUSE_WEAK;

	mov	DWORD PTR _eResponse$[ebp], 1

; 322  : 
; 323  : 		// Willing to give in to demand
; 324  : 		else

	jmp	$LN43@DoHumanDem
$LN36@DoHumanDem:

; 325  : 		{
; 326  : 			// Initial odds of giving in to ANY demand are based on the player's boldness (which is also tied to the player's likelihood of going for world conquest)
; 327  : 			int iOddsOfGivingIn = (10 - pDiploAI->GetBoldness()) * 10;

	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	mov	ecx, 10					; 0000000aH
	sub	ecx, eax
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], ecx

; 328  : 
; 329  : 			iValueWillingToGiveUp = 0;

	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], 0

; 330  : 
; 331  : 			// If we're afraid we're more likely to give in
; 332  : 			if(eApproach == MAJOR_CIV_APPROACH_AFRAID)

	cmp	DWORD PTR _eApproach$221522[ebp], 4
	jne	SHORT $LN34@DoHumanDem

; 333  : 			{
; 334  : 				iOddsOfGivingIn += 50;

	mov	edx, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], edx

; 335  : 				iValueWillingToGiveUp += 200;

	mov	eax, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	eax, 200				; 000000c8H
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], eax

; 336  : 			}
; 337  : 			// Not afraid
; 338  : 			else

	jmp	$LN33@DoHumanDem
$LN34@DoHumanDem:

; 339  : 			{
; 340  : 				// How strong are they compared to us?
; 341  : 				switch(eMilitaryStrength)

	mov	ecx, DWORD PTR _eMilitaryStrength$221523[ebp]
	mov	DWORD PTR tv151[ebp], ecx
	cmp	DWORD PTR tv151[ebp], 6
	ja	$LN33@DoHumanDem
	mov	edx, DWORD PTR tv151[ebp]
	jmp	DWORD PTR $LN216@DoHumanDem[edx*4]
$LN30@DoHumanDem:

; 342  : 				{
; 343  : 				case STRENGTH_PATHETIC:
; 344  : 					iOddsOfGivingIn += -100;

	mov	eax, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	sub	eax, 100				; 00000064H
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], eax

; 345  : 					iValueWillingToGiveUp += 10;

	mov	ecx, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], ecx

; 346  : 					break;

	jmp	SHORT $LN33@DoHumanDem
$LN29@DoHumanDem:

; 347  : 				case STRENGTH_WEAK:
; 348  : 					iOddsOfGivingIn += -100;

	mov	edx, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	sub	edx, 100				; 00000064H
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], edx

; 349  : 					iValueWillingToGiveUp += 10;

	mov	eax, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], eax

; 350  : 					break;

	jmp	SHORT $LN33@DoHumanDem
$LN28@DoHumanDem:

; 351  : 				case STRENGTH_POOR:
; 352  : 					iOddsOfGivingIn += -100;

	mov	ecx, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	sub	ecx, 100				; 00000064H
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], ecx

; 353  : 					iValueWillingToGiveUp += 20;

	mov	edx, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], edx

; 354  : 					break;

	jmp	SHORT $LN33@DoHumanDem
$LN27@DoHumanDem:

; 355  : 				case STRENGTH_AVERAGE:
; 356  : 					iOddsOfGivingIn += -10;

	mov	eax, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	sub	eax, 10					; 0000000aH
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], eax

; 357  : 					iValueWillingToGiveUp += 50;

	mov	ecx, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	ecx, 50					; 00000032H
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], ecx

; 358  : 					break;

	jmp	SHORT $LN33@DoHumanDem
$LN26@DoHumanDem:

; 359  : 				case STRENGTH_STRONG:
; 360  : 					iOddsOfGivingIn += 10;

	mov	edx, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], edx

; 361  : 					iValueWillingToGiveUp += 120;

	mov	eax, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], eax

; 362  : 					break;

	jmp	SHORT $LN33@DoHumanDem
$LN25@DoHumanDem:

; 363  : 				case STRENGTH_POWERFUL:
; 364  : 					iOddsOfGivingIn += 20;

	mov	ecx, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], ecx

; 365  : 					iValueWillingToGiveUp += 200;

	mov	edx, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	edx, 200				; 000000c8H
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], edx

; 366  : 					break;

	jmp	SHORT $LN33@DoHumanDem
$LN24@DoHumanDem:

; 367  : 				case STRENGTH_IMMENSE:
; 368  : 					iOddsOfGivingIn += 35;

	mov	eax, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	add	eax, 35					; 00000023H
	mov	DWORD PTR _iOddsOfGivingIn$221534[ebp], eax

; 369  : 					iValueWillingToGiveUp += 200;

	mov	ecx, DWORD PTR _iValueWillingToGiveUp$[ebp]
	add	ecx, 200				; 000000c8H
	mov	DWORD PTR _iValueWillingToGiveUp$[ebp], ecx
$LN33@DoHumanDem:

; 370  : 					break;
; 371  : 				default:
; 372  : 					break;
; 373  : 				}
; 374  : 			}
; 375  : 
; 376  : 			// IMPORTANT NOTE: This APPEARS to be very bad for multiplayer, but the only changes made to the game state are the fact that the human
; 377  : 			// made a demand, and if the deal went through. These are both sent over the network later in this function.
; 378  : 
; 379  : 			int iAsyncRand = GC.getGame().getAsyncRandNum(100, "Deal AI: ASYNC RAND call to determine if AI will give into a human demand.");

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224544[ebp], edx
	push	OFFSET ??_C@_0EL@KKMPAGGO@Deal?5AI?3?5ASYNC?5RAND?5call?5to?5dete@
	push	100					; 00000064H
	mov	ecx, DWORD PTR $T224544[ebp]
	call	?getAsyncRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getAsyncRandNum
	mov	DWORD PTR _iAsyncRand$221549[ebp], eax

; 380  : 
; 381  : 			// Are they going to say no matter what?
; 382  : 			if(iAsyncRand > iOddsOfGivingIn)

	mov	eax, DWORD PTR _iAsyncRand$221549[ebp]
	cmp	eax, DWORD PTR _iOddsOfGivingIn$221534[ebp]
	jle	SHORT $LN43@DoHumanDem

; 383  : 				eResponse = DEMAND_RESPONSE_REFUSE_HOSTILE;

	mov	DWORD PTR _eResponse$[ebp], 2
$LN43@DoHumanDem:

; 384  : 		}
; 385  : 	}
; 386  : 
; 387  : 	// Possibility exists that the AI will accept
; 388  : #ifdef AUI_WARNING_FIXES
; 389  : 	if (eResponse == NO_DEMAND_RESPONSE_TYPE)
; 390  : #else
; 391  : 	if(eResponse == NO_DEAL_RESPONSE_TYPE)

	cmp	DWORD PTR _eResponse$[ebp], -1
	jne	$LN21@DoHumanDem

; 392  : #endif
; 393  : 	{
; 394  : 		int iValueDemanded = 0;

	mov	DWORD PTR _iValueDemanded$221553[ebp], 0

; 395  : 
; 396  : 		int iGPT = GetPlayer()->GetTreasury()->CalculateBaseNetGold();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?CalculateBaseNetGold@CvTreasury@@QAEHXZ ; CvTreasury::CalculateBaseNetGold
	mov	DWORD PTR _iGPT$221554[ebp], eax

; 397  : 		int iTempGold;
; 398  : 		int iModdedGoldValue;
; 399  : 
; 400  : 		// Loop through items in this deal
; 401  : 		TradedItemList::iterator it;

	mov	DWORD PTR _it$221664[ebp], 0
	mov	DWORD PTR _it$221664[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 402  : 		for(it = pDeal->m_TradedItems.begin(); it != pDeal->m_TradedItems.end(); ++it)

	lea	ecx, DWORD PTR $T224509[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv319[ebp], eax
	mov	edx, DWORD PTR tv319[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _it$221664[ebp], eax
	mov	DWORD PTR _it$221664[ebp+4], ecx
	jmp	SHORT $LN20@DoHumanDem
$LN19@DoHumanDem:
	cmp	DWORD PTR _it$221664[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN84@DoHumanDem
	mov	edx, DWORD PTR _it$221664[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _it$221664[ebp+4], eax
	jmp	SHORT $LN20@DoHumanDem
$LN84@DoHumanDem:
	mov	ecx, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224592[ebp], ecx
	mov	edx, DWORD PTR _it$221664[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T224592[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224601[ebp], edx
	mov	ecx, DWORD PTR $T224601[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T224605[ebp], edx
	mov	eax, DWORD PTR $T224605[ebp]
	mov	DWORD PTR _it$221664[ebp+4], eax
$LN20@DoHumanDem:
	lea	ecx, DWORD PTR $T224511[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T224621[ebp], eax
	mov	edx, DWORD PTR $T224621[ebp]
	mov	eax, DWORD PTR _it$221664[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setne	cl
	mov	BYTE PTR $T224510[ebp], cl
	movzx	edx, BYTE PTR $T224510[ebp]
	test	edx, edx
	je	$LN18@DoHumanDem

; 403  : 		{
; 404  : 			// Item from this AI
; 405  : 			if(it->m_eFromPlayer == eMyPlayer)

	mov	eax, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224644[ebp], eax
	mov	ecx, DWORD PTR _it$221664[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T224644[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+36]
	cmp	ecx, DWORD PTR _eMyPlayer$[ebp]
	jne	$LN17@DoHumanDem

; 406  : 			{
; 407  : 				switch(it->m_eItemType)

	mov	edx, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224676[ebp], edx
	mov	eax, DWORD PTR _it$221664[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T224676[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR tv221[ebp], 6
	ja	$LN5@DoHumanDem
	mov	ecx, DWORD PTR tv221[ebp]
	jmp	DWORD PTR $LN217@DoHumanDem[ecx*4]
$LN14@DoHumanDem:

; 408  : 				{
; 409  : 					// Gold
; 410  : 				case TRADE_ITEM_GOLD:
; 411  : 				{
; 412  : 					iTempGold = it->m_iData1;

	mov	edx, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224708[ebp], edx
	mov	eax, DWORD PTR _it$221664[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T224708[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR _iTempGold$221555[ebp], eax

; 413  : 					if (iGPT > 0)

	cmp	DWORD PTR _iGPT$221554[ebp], 0
	jle	SHORT $LN13@DoHumanDem

; 414  : 						iModdedGoldValue = iTempGold * 10 / iGPT;

	mov	eax, DWORD PTR _iTempGold$221555[ebp]
	imul	eax, 10					; 0000000aH
	cdq
	idiv	DWORD PTR _iGPT$221554[ebp]
	mov	DWORD PTR _iModdedGoldValue$221556[ebp], eax

; 415  : 					else

	jmp	SHORT $LN12@DoHumanDem
$LN13@DoHumanDem:

; 416  : 						iModdedGoldValue = 0;

	mov	DWORD PTR _iModdedGoldValue$221556[ebp], 0
$LN12@DoHumanDem:

; 417  : 
; 418  : 					iValueDemanded += max(iTempGold, iModdedGoldValue);

	mov	ecx, DWORD PTR _iTempGold$221555[ebp]
	cmp	ecx, DWORD PTR _iModdedGoldValue$221556[ebp]
	jge	SHORT $LN137@DoHumanDem
	lea	edx, DWORD PTR _iModdedGoldValue$221556[ebp]
	mov	DWORD PTR tv503[ebp], edx
	jmp	SHORT $LN138@DoHumanDem
$LN137@DoHumanDem:
	lea	eax, DWORD PTR _iTempGold$221555[ebp]
	mov	DWORD PTR tv503[ebp], eax
$LN138@DoHumanDem:
	mov	ecx, DWORD PTR tv503[ebp]
	mov	DWORD PTR $T224741[ebp], ecx
	mov	edx, DWORD PTR $T224741[ebp]
	mov	eax, DWORD PTR _iValueDemanded$221553[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _iValueDemanded$221553[ebp], eax

; 419  : 					break;

	jmp	$LN17@DoHumanDem
$LN11@DoHumanDem:

; 420  : 				}
; 421  : 
; 422  : 				// GPT
; 423  : 				case TRADE_ITEM_GOLD_PER_TURN:
; 424  : 				{
; 425  : 					iValueDemanded += (it->m_iData1 * it->m_iDuration * 80 / 100);

	mov	ecx, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224749[ebp], ecx
	mov	edx, DWORD PTR _it$221664[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T224749[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T224776[ebp], edx
	mov	eax, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224782[ebp], eax
	mov	ecx, DWORD PTR _it$221664[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T224782[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR $T224776[ebp]
	mov	edx, DWORD PTR [edx+12]
	imul	edx, DWORD PTR [eax+ecx+12]
	imul	edx, 80					; 00000050H
	mov	eax, edx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _iValueDemanded$221553[ebp]
	mov	DWORD PTR _iValueDemanded$221553[ebp], eax

; 426  : 					break;

	jmp	$LN17@DoHumanDem
$LN10@DoHumanDem:

; 427  : 				}
; 428  : 
; 429  : 				// Resources
; 430  : 				case TRADE_ITEM_RESOURCES:
; 431  : 				{
; 432  : 					ResourceTypes eResource = (ResourceTypes) it->m_iData1;

	mov	edx, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224814[ebp], edx
	mov	eax, DWORD PTR _it$221664[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T224814[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+20]
	mov	DWORD PTR _eResource$221681[ebp], eax

; 433  : 					ResourceUsageTypes eUsage = GC.getResourceInfo(eResource)->getResourceUsage();

	mov	ecx, DWORD PTR _eResource$221681[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eUsage$221683[ebp], eax

; 434  : 
; 435  : 					if(eUsage == RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _eUsage$221683[ebp], 2
	jne	SHORT $LN9@DoHumanDem

; 436  : 						iValueDemanded += 200;

	mov	edx, DWORD PTR _iValueDemanded$221553[ebp]
	add	edx, 200				; 000000c8H
	mov	DWORD PTR _iValueDemanded$221553[ebp], edx
	jmp	SHORT $LN8@DoHumanDem
$LN9@DoHumanDem:

; 437  : 					else if(eUsage == RESOURCEUSAGE_STRATEGIC)

	cmp	DWORD PTR _eUsage$221683[ebp], 1
	jne	SHORT $LN8@DoHumanDem

; 438  : 						iValueDemanded += (40 * it->m_iData2);

	mov	eax, DWORD PTR _it$221664[ebp]
	mov	DWORD PTR $T224846[ebp], eax
	mov	ecx, DWORD PTR _it$221664[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T224846[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+ecx+24]
	imul	ecx, 40					; 00000028H
	add	ecx, DWORD PTR _iValueDemanded$221553[ebp]
	mov	DWORD PTR _iValueDemanded$221553[ebp], ecx
$LN8@DoHumanDem:

; 439  : 
; 440  : 					break;

	jmp	SHORT $LN17@DoHumanDem
$LN6@DoHumanDem:

; 441  : 				}
; 442  : 
; 443  : 				// Open Borders
; 444  : 				case TRADE_ITEM_OPEN_BORDERS:
; 445  : 				{
; 446  : 					iValueDemanded += 50;

	mov	edx, DWORD PTR _iValueDemanded$221553[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _iValueDemanded$221553[ebp], edx

; 447  : 					break;

	jmp	SHORT $LN17@DoHumanDem
$LN5@DoHumanDem:

; 448  : 				}
; 449  : 
; 450  : 				case TRADE_ITEM_CITIES:
; 451  : 				case TRADE_ITEM_DEFENSIVE_PACT:
; 452  : 				case TRADE_ITEM_RESEARCH_AGREEMENT:
; 453  : 				case TRADE_ITEM_PERMANENT_ALLIANCE:
; 454  : 				case TRADE_ITEM_THIRD_PARTY_PEACE:
; 455  : 				case TRADE_ITEM_THIRD_PARTY_WAR:
; 456  : 				case TRADE_ITEM_THIRD_PARTY_EMBARGO:
; 457  : 				default:
; 458  : 					eResponse = DEMAND_RESPONSE_REFUSE_TOO_MUCH;

	mov	DWORD PTR _eResponse$[ebp], 3
$LN17@DoHumanDem:

; 459  : 					break;
; 460  : 				}
; 461  : 			}
; 462  : 		}

	jmp	$LN19@DoHumanDem
$LN18@DoHumanDem:

; 463  : 
; 464  : 		// No illegal items in the demand
; 465  : #ifdef AUI_WARNING_FIXES
; 466  : 		if (eResponse == NO_DEMAND_RESPONSE_TYPE)
; 467  : #else
; 468  : 		if(eResponse == NO_DEAL_RESPONSE_TYPE)

	cmp	DWORD PTR _eResponse$[ebp], -1
	jne	SHORT $LN4@DoHumanDem

; 469  : #endif
; 470  : 		{
; 471  : 			if(iValueDemanded <= iValueWillingToGiveUp)

	mov	eax, DWORD PTR _iValueDemanded$221553[ebp]
	cmp	eax, DWORD PTR _iValueWillingToGiveUp$[ebp]
	jg	SHORT $LN3@DoHumanDem

; 472  : 				eResponse = DEMAND_RESPONSE_ACCEPT;

	mov	DWORD PTR _eResponse$[ebp], 0

; 473  : 			else

	jmp	SHORT $LN4@DoHumanDem
$LN3@DoHumanDem:

; 474  : 				eResponse = DEMAND_RESPONSE_REFUSE_TOO_MUCH;

	mov	DWORD PTR _eResponse$[ebp], 3
$LN4@DoHumanDem:

; 475  : 		}
; 476  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN21@DoHumanDem:

; 477  : 
; 478  : 	// Have to sent AI response through the network  - it affects AI behavior
; 479  : 	GC.getGame().DoFromUIDiploEvent(FROM_UI_DIPLO_EVENT_HUMAN_DEMAND, eMyPlayer, /*iData1*/ eResponse, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224893[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _eResponse$[ebp]
	push	edx
	mov	eax, DWORD PTR _eMyPlayer$[ebp]
	push	eax
	push	24					; 00000018H
	mov	ecx, DWORD PTR $T224893[ebp]
	call	?DoFromUIDiploEvent@CvGame@@QAEXW4FromUIDiploEventTypes@@W4PlayerTypes@@HH@Z ; CvGame::DoFromUIDiploEvent

; 480  : 
; 481  : 	// Demand agreed to
; 482  : 	if(eResponse == DEMAND_RESPONSE_ACCEPT)

	cmp	DWORD PTR _eResponse$[ebp], 0
	jne	$LN1@DoHumanDem

; 483  : 	{
; 484  : 		CvDeal kDeal = *pDeal;

	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kDeal$221693[ebp]
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 485  : 		//gDLL->sendNetDealAccepted(eFromPlayer, GetPlayer()->GetID(), kDeal, -1, -1, -1);
; 486  : 		GC.GetEngineUserInterface()->SetDealInTransit(true);

	mov	edx, DWORD PTR $T224897[ebp]
	mov	DWORD PTR tv281[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv281[ebp], eax
	push	1
	mov	ecx, DWORD PTR tv281[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv281[ebp]
	mov	eax, DWORD PTR [edx+564]
	call	eax

; 487  : 
; 488  : 		auto_ptr<ICvDeal1> pDllDeal = GC.WrapDealPointer(&kDeal);

	lea	ecx, DWORD PTR _kDeal$221693[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224512[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapDealPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvDeal1@@@std@@PAVCvDeal@@@Z ; CvGlobals::WrapDealPointer
	mov	DWORD PTR $T224908[ebp], eax
	mov	eax, DWORD PTR $T224908[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Cvtptr$224903[ebp], ecx
	mov	edx, DWORD PTR __Cvtptr$224903[ebp]
	mov	DWORD PTR __Ans$224904[ebp], edx
	mov	eax, DWORD PTR $T224908[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR __Ans$224904[ebp]
	mov	DWORD PTR $T224513[ebp], ecx
	mov	edx, DWORD PTR $T224513[ebp]
	mov	DWORD PTR $T224913[ebp], edx
	mov	eax, DWORD PTR $T224913[ebp]
	mov	DWORD PTR __Ptr$224911[ebp], eax
	mov	DWORD PTR $T224913[ebp], 0
	mov	ecx, DWORD PTR __Ptr$224911[ebp]
	mov	DWORD PTR _pDllDeal$221695[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T224512[ebp]
	mov	DWORD PTR $T224923[ebp], edx
	cmp	DWORD PTR $T224923[ebp], 0
	je	SHORT $LN197@DoHumanDem
	mov	eax, DWORD PTR $T224923[ebp]
	mov	DWORD PTR _inst$224927[ebp], eax
	mov	ecx, DWORD PTR _inst$224927[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _inst$224927[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+4]
	call	ecx
$LN197@DoHumanDem:

; 489  : 		gDLL->sendNetDemandAccepted(eFromPlayer, GetPlayer()->GetID(), pDllDeal.get());

	mov	edx, DWORD PTR $T224931[ebp]
	mov	DWORD PTR tv305[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv305[ebp], eax
	mov	ecx, DWORD PTR _pDllDeal$221695[ebp]
	mov	DWORD PTR $T224935[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224944[ebp], eax
	mov	edx, DWORD PTR $T224944[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T224945[ebp], eax
	mov	ecx, DWORD PTR $T224935[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224945[ebp]
	push	edx
	mov	eax, DWORD PTR _eFromPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv305[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv305[ebp]
	mov	eax, DWORD PTR [edx+364]
	call	eax

; 490  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _pDllDeal$221695[ebp]
	mov	DWORD PTR $T224955[ebp], ecx
	cmp	DWORD PTR $T224955[ebp], 0
	je	SHORT $LN210@DoHumanDem
	mov	edx, DWORD PTR $T224955[ebp]
	mov	DWORD PTR _inst$224959[ebp], edx
	mov	eax, DWORD PTR _inst$224959[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$224959[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN210@DoHumanDem:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kDeal$221693[ebp]
	call	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
$LN1@DoHumanDem:

; 491  : 
; 492  : 	return eResponse;

	mov	eax, DWORD PTR _eResponse$[ebp]

; 493  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN216@DoHumanDem:
	DD	$LN30@DoHumanDem
	DD	$LN29@DoHumanDem
	DD	$LN28@DoHumanDem
	DD	$LN27@DoHumanDem
	DD	$LN26@DoHumanDem
	DD	$LN25@DoHumanDem
	DD	$LN24@DoHumanDem
$LN217@DoHumanDem:
	DD	$LN14@DoHumanDem
	DD	$LN11@DoHumanDem
	DD	$LN5@DoHumanDem
	DD	$LN10@DoHumanDem
	DD	$LN5@DoHumanDem
	DD	$LN5@DoHumanDem
	DD	$LN6@DoHumanDem
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$0:
	lea	ecx, DWORD PTR _it$221664[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$3:
	lea	ecx, DWORD PTR _kDeal$221693[ebp]
	jmp	??1CvDeal@@UAE@XZ			; CvDeal::~CvDeal
__unwindfunclet$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z$5:
	lea	ecx, DWORD PTR _pDllDeal$221695[ebp]
	jmp	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ	; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
__ehhandler$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoHumanDemand@CvDealAI@@QAE?AW4DemandResponseTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::DoHumanDemand
PUBLIC	?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z ; CvDealAI::DoAcceptedDemand
; Function compile flags: /Odtp
;	COMDAT ?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z
_TEXT	SEGMENT
tv134 = -40						; size = 4
tv138 = -36						; size = 4
_this$ = -32						; size = 4
$T224987 = -28						; size = 4
$T224983 = -24						; size = 4
$T224970 = -20						; size = 4
_pGameDeals$ = -16					; size = 4
_ePlayer$ = -12						; size = 4
_kGame$ = -8						; size = 4
_eActivePlayer$ = -4					; size = 4
_eFromPlayer$ = 8					; size = 4
_kDeal$ = 12						; size = 4
?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z PROC ; CvDealAI::DoAcceptedDemand, COMDAT
; _this$ = ecx

; 497  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 498  : 	CvGame& kGame = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], eax

; 499  : 	CvGameDeals* pGameDeals = kGame.GetGameDeals();

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	DWORD PTR _pGameDeals$[ebp], eax

; 500  : 	const PlayerTypes eActivePlayer = kGame.getActivePlayer();

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$[ebp], eax

; 501  : 	const PlayerTypes ePlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T224983[ebp], eax
	mov	ecx, DWORD PTR $T224983[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _ePlayer$[ebp], edx

; 502  : 
; 503  : 	pGameDeals->AddProposedDeal(kDeal);

	sub	esp, 76					; 0000004cH
	mov	ecx, esp
	mov	DWORD PTR $T224970[ebp], esp
	mov	eax, DWORD PTR _kDeal$[ebp]
	push	eax
	call	??0CvDeal@@QAE@ABV0@@Z			; CvDeal::CvDeal
	mov	DWORD PTR tv138[ebp], eax
	mov	ecx, DWORD PTR _pGameDeals$[ebp]
	call	?AddProposedDeal@CvGameDeals@@QAEXVCvDeal@@@Z ; CvGameDeals::AddProposedDeal

; 504  : 	pGameDeals->FinalizeDeal(eFromPlayer, ePlayer, true);

	push	1
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eFromPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pGameDeals$[ebp]
	call	?FinalizeDeal@CvGameDeals@@QAE_NW4PlayerTypes@@0_N@Z ; CvGameDeals::FinalizeDeal

; 505  : 	if(eActivePlayer == eFromPlayer || eActivePlayer == ePlayer)

	mov	eax, DWORD PTR _eActivePlayer$[ebp]
	cmp	eax, DWORD PTR _eFromPlayer$[ebp]
	je	SHORT $LN1@DoAccepted@2
	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	cmp	ecx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN3@DoAccepted@2
$LN1@DoAccepted@2:

; 506  : 	{
; 507  : 		GC.GetEngineUserInterface()->makeInterfaceDirty();

	mov	edx, DWORD PTR $T224987[ebp]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
$LN3@DoAccepted@2:

; 508  : 	}
; 509  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DoAcceptedDemand@CvDealAI@@QAEXW4PlayerTypes@@ABVCvDeal@@@Z ENDP ; CvDealAI::DoAcceptedDemand
_TEXT	ENDS
PUBLIC	??_C@_0CG@NMJJCELJ@GAMEOPTION_AI_GIMP_ALWAYS_WHITE_@ ; `string'
PUBLIC	??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@	; `string'
PUBLIC	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z	; CvDealAI::GetDealValue
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ:PROC ; CvDeal::GetSurrenderingPlayer
EXTRN	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z:PROC ; CvDeal::GetGoldTrade
;	COMDAT ??_C@_0CG@NMJJCELJ@GAMEOPTION_AI_GIMP_ALWAYS_WHITE_@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
??_C@_0CG@NMJJCELJ@GAMEOPTION_AI_GIMP_ALWAYS_WHITE_@ DB 'GAMEOPTION_AI_GI'
	DB	'MP_ALWAYS_WHITE_PEACE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
CONST	SEGMENT
??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@ DB 'GAMEOPTION_AI_TWEAKS', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
CONST	ENDS
;	COMDAT ?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T225020 = -48						; size = 4
$T225016 = -44						; size = 4
$T225012 = -40						; size = 4
$T225008 = -36						; size = 4
$T225007 = -32						; size = 4
$T224998 = -28						; size = 4
_iPeaceValueRequired$221732 = -24			; size = 4
_iDiff$221725 = -20					; size = 4
_iOneGPT$221724 = -16					; size = 4
_iPercentUnderWeWillOffer$ = -12			; size = 4
_iDealSumValue$ = -8					; size = 4
_iPercentOverWeWillRequest$ = -4			; size = 4
_pDeal$ = 8						; size = 4
_eOtherPlayer$ = 12					; size = 4
_iTotalValueToMe$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_iAmountOverWeWillRequest$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bCantMatchOffer$ = 36					; size = 4
?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z PROC ; CvDealAI::IsDealWithHumanAcceptable, COMDAT
; _this$ = ecx

; 513  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 514  : 	CvAssertMsg(GET_PLAYER(eOtherPlayer).isHuman(), "DEAL_AI: Trying to see if AI will accept a deal with human player... but it's not human.  Please show Jon.");
; 515  : 
; 516  : 	int iPercentOverWeWillRequest;
; 517  : 	int iPercentUnderWeWillOffer;
; 518  : 
; 519  : 	bCantMatchOffer = false;

	mov	eax, DWORD PTR _bCantMatchOffer$[ebp]
	mov	BYTE PTR [eax], 0

; 520  : 
; 521  : 	// Deal leeway with human
; 522  : 	iPercentOverWeWillRequest = GetDealPercentLeewayWithHuman();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealPercentLeewayWithHuman@CvDealAI@@QBEHXZ ; CvDealAI::GetDealPercentLeewayWithHuman
	mov	DWORD PTR _iPercentOverWeWillRequest$[ebp], eax

; 523  : 	iPercentUnderWeWillOffer = 0;

	mov	DWORD PTR _iPercentUnderWeWillOffer$[ebp], 0

; 524  : 
; 525  : 	// Now do the valuation
; 526  : 	iTotalValueToMe = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValueToMe$[ebp]
	mov	DWORD PTR [ecx], eax

; 527  : 
; 528  : 	// If no Gold in deal and within value of 1 GPT, then it's close enough
; 529  : 	if (pDeal->GetGoldTrade(eOtherPlayer) == 0 && pDeal->GetGoldTrade(m_pPlayer->GetID()) == 0)

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	SHORT $LN13@IsDealWith
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T224998[ebp], edx
	mov	eax, DWORD PTR $T224998[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	SHORT $LN13@IsDealWith

; 530  : 	{
; 531  : 		int iOneGPT = 25;

	mov	DWORD PTR _iOneGPT$221724[ebp], 25	; 00000019H

; 532  : 		int iDiff = abs(iValueTheyreOffering - iValueImOffering);

	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDiff$221725[ebp], eax

; 533  : 		if (iDiff < iOneGPT)

	mov	eax, DWORD PTR _iDiff$221725[ebp]
	cmp	eax, DWORD PTR _iOneGPT$221724[ebp]
	jge	SHORT $LN13@IsDealWith

; 534  : 		{
; 535  : 			return true;

	mov	al, 1
	jmp	$LN14@IsDealWith
$LN13@IsDealWith:

; 536  : 		}
; 537  : 	}
; 538  : 
; 539  : 	int iDealSumValue = iValueImOffering + iValueTheyreOffering;

	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _iDealSumValue$[ebp], edx

; 540  : 
; 541  : 	iAmountOverWeWillRequest = iDealSumValue;

	mov	ecx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	mov	edx, DWORD PTR _iDealSumValue$[ebp]
	mov	DWORD PTR [ecx], edx

; 542  : 	iAmountOverWeWillRequest *= iPercentOverWeWillRequest;

	mov	eax, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _iPercentOverWeWillRequest$[ebp]
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	mov	DWORD PTR [edx], ecx

; 543  : 	iAmountOverWeWillRequest /= 100;

	mov	eax, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	mov	DWORD PTR [edx], eax

; 544  : 
; 545  : 	iAmountUnderWeWillOffer = iDealSumValue;

	mov	eax, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	mov	ecx, DWORD PTR _iDealSumValue$[ebp]
	mov	DWORD PTR [eax], ecx

; 546  : 	iAmountUnderWeWillOffer *= iPercentUnderWeWillOffer;

	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, DWORD PTR _iPercentUnderWeWillOffer$[ebp]
	mov	ecx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	mov	DWORD PTR [ecx], eax

; 547  : 	iAmountUnderWeWillOffer /= 100;

	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	mov	DWORD PTR [edx], eax

; 548  : 
; 549  : 	// We're surrendering
; 550  : 	if(pDeal->GetSurrenderingPlayer() == GetPlayer()->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225007[ebp], eax
	mov	eax, DWORD PTR $T225007[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T225008[ebp], ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
	cmp	eax, DWORD PTR $T225008[ebp]
	jne	SHORT $LN11@IsDealWith

; 551  : 	{
; 552  : 		if (iTotalValueToMe >= GetCachedValueOfPeaceWithHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ ; CvDealAI::GetCachedValueOfPeaceWithHuman
	mov	edx, DWORD PTR _iTotalValueToMe$[ebp]
	cmp	DWORD PTR [edx], eax
	jl	SHORT $LN10@IsDealWith

; 553  : 		{
; 554  : 			return true;

	mov	al, 1
	jmp	$LN14@IsDealWith
$LN10@IsDealWith:

; 555  : 		}
; 556  : 	}

	jmp	$LN9@IsDealWith
$LN11@IsDealWith:

; 557  : 
; 558  : 	// Peace deal where we're not surrendering, value must equal cached value
; 559  : 	else if (pDeal->IsPeaceTreatyTrade(eOtherPlayer))

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@IsDealWith

; 560  : 	{
; 561  : #ifdef NQM_AI_GIMP_ALWAYS_WHITE_PEACE
; 562  : 		int iPeaceValueRequired = GetCachedValueOfPeaceWithHuman();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ ; CvDealAI::GetCachedValueOfPeaceWithHuman
	mov	DWORD PTR _iPeaceValueRequired$221732[ebp], eax

; 563  : 		if ((GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_ALWAYS_WHITE_PEACE")) && iPeaceValueRequired > 0 && GET_PLAYER(eOtherPlayer).isHuman())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225012[ebp], edx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T225012[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@IsDealWith
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225016[ebp], ecx
	push	OFFSET ??_C@_0CG@NMJJCELJ@GAMEOPTION_AI_GIMP_ALWAYS_WHITE_@
	mov	ecx, DWORD PTR $T225016[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@IsDealWith
$LN6@IsDealWith:
	cmp	DWORD PTR _iPeaceValueRequired$221732[ebp], 0
	jle	SHORT $LN7@IsDealWith
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225020[ebp], eax
	mov	ecx, DWORD PTR $T225020[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@IsDealWith

; 564  : 			iPeaceValueRequired = 0;

	mov	DWORD PTR _iPeaceValueRequired$221732[ebp], 0
$LN7@IsDealWith:

; 565  : 		if (iTotalValueToMe >= iPeaceValueRequired)

	mov	edx, DWORD PTR _iTotalValueToMe$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _iPeaceValueRequired$221732[ebp]
	jl	SHORT $LN5@IsDealWith

; 566  : #else
; 567  : 		if (iTotalValueToMe >= GetCachedValueOfPeaceWithHuman())
; 568  : #endif
; 569  : 		{
; 570  : 			return true;

	mov	al, 1
	jmp	SHORT $LN14@IsDealWith
$LN5@IsDealWith:

; 571  : 		}
; 572  : 	}

	jmp	SHORT $LN9@IsDealWith
$LN8@IsDealWith:

; 573  : 
; 574  : 	// If we've gotten the deal to a point where we're happy, offer it up
; 575  : 	else if(iTotalValueToMe <= iAmountOverWeWillRequest && iTotalValueToMe >= iAmountUnderWeWillOffer)

	mov	ecx, DWORD PTR _iTotalValueToMe$[ebp]
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jg	SHORT $LN3@IsDealWith
	mov	ecx, DWORD PTR _iTotalValueToMe$[ebp]
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jl	SHORT $LN3@IsDealWith

; 576  : 	{
; 577  : 		return true;

	mov	al, 1
	jmp	SHORT $LN14@IsDealWith
	jmp	SHORT $LN9@IsDealWith
$LN3@IsDealWith:

; 578  : 	}
; 579  : 	else if (iTotalValueToMe > iAmountOverWeWillRequest)

	mov	ecx, DWORD PTR _iTotalValueToMe$[ebp]
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN9@IsDealWith

; 580  : 	{
; 581  : 		bCantMatchOffer = true;

	mov	ecx, DWORD PTR _bCantMatchOffer$[ebp]
	mov	BYTE PTR [ecx], 1
$LN9@IsDealWith:

; 582  : 	}
; 583  : 
; 584  : 	return false;

	xor	al, al
$LN14@IsDealWith:

; 585  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ENDP ; CvDealAI::IsDealWithHumanAcceptable
_TEXT	ENDS
PUBLIC	?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddCitiesToUs
PUBLIC	?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromThem
PUBLIC	?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromUs
PUBLIC	?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromUs
PUBLIC	?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromThem
PUBLIC	?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToUs
PUBLIC	?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToThem
PUBLIC	?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToUs
PUBLIC	?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToThem
PUBLIC	?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToUs
PUBLIC	?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToThem
PUBLIC	?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToUs
PUBLIC	?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToThem
PUBLIC	?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToUs
PUBLIC	?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToThem
PUBLIC	?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToUs
PUBLIC	?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToThem
PUBLIC	?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z ; CvDealAI::IsOfferPeace
PUBLIC	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
EXTRN	?ClearItems@CvDeal@@QAEXXZ:PROC			; CvDeal::ClearItems
EXTRN	?GetDealDuration@CvGame@@QAEHXZ:PROC		; CvGame::GetDealDuration
; Function compile flags: /Odtp
;	COMDAT ?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T225043 = -48						; size = 4
$T225035 = -44						; size = 4
$T225030 = -40						; size = 4
$T225026 = -36						; size = 4
_bUseEvenValue$221764 = -29				; size = 1
_iTotalValueToMe$221755 = -28				; size = 4
_iValueImOffering$221756 = -24				; size = 4
_iAmountUnderWeWillOffer$221759 = -20			; size = 4
_iValueTheyreOffering$221757 = -16			; size = 4
_iAmountOverWeWillRequest$221758 = -12			; size = 4
_iDealDuration$ = -8					; size = 4
_bMakeOffer$ = -1					; size = 1
_pDeal$ = 8						; size = 4
_eOtherPlayer$ = 12					; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_bDontChangeTheirExistingItems$ = 20			; size = 1
_bDealGoodToBeginWith$ = 24				; size = 4
_bCantMatchOffer$ = 28					; size = 4
?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z PROC ; CvDealAI::DoEqualizeDealWithHuman, COMDAT
; _this$ = ecx

; 589  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 590  : 	bool bMakeOffer;
; 591  : #ifdef CVASSERT_ENABLE
; 592  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 593  : 	DEBUG_VARIABLE(eMyPlayer);
; 594  : 
; 595  : 	CvAssert(eOtherPlayer >= 0);
; 596  : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 597  : 	CvAssertMsg(eMyPlayer != eOtherPlayer, "DEAL_AI: Trying to equalize human deal, but both players are the same.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 598  : #endif
; 599  : 
; 600  : 	int iDealDuration = GC.getGame().GetDealDuration();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225026[ebp], eax
	mov	ecx, DWORD PTR $T225026[ebp]
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	mov	DWORD PTR _iDealDuration$[ebp], eax

; 601  : 	bCantMatchOffer = false;

	mov	ecx, DWORD PTR _bCantMatchOffer$[ebp]
	mov	BYTE PTR [ecx], 0

; 602  : 
; 603  : 	// Is this a peace deal?
; 604  : 	if (pDeal->IsPeaceTreatyTrade(eOtherPlayer))

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPeaceTreatyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsPeaceTreatyTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@DoEqualize

; 605  : 	{
; 606  : 		pDeal->ClearItems();

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 607  : 		bMakeOffer = IsOfferPeace(eOtherPlayer, pDeal, true /*bEqualizingDeals*/);

	push	1
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z ; CvDealAI::IsOfferPeace
	mov	BYTE PTR _bMakeOffer$[ebp], al

; 608  : 	}
; 609  : 	else

	jmp	$LN8@DoEqualize
$LN9@DoEqualize:

; 610  : 	{
; 611  : 		int iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer;
; 612  : 		bMakeOffer = IsDealWithHumanAcceptable(pDeal, GC.getGame().getActivePlayer(), /*Passed by reference*/ iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, bCantMatchOffer);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225030[ebp], eax
	mov	ecx, DWORD PTR _bCantMatchOffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iAmountUnderWeWillOffer$221759[ebp]
	push	edx
	lea	eax, DWORD PTR _iAmountOverWeWillRequest$221758[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueImOffering$221756[ebp]
	push	edx
	lea	eax, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225030[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable
	mov	BYTE PTR _bMakeOffer$[ebp], al

; 613  : 
; 614  : 		if (iTotalValueToMe < 0 && bDontChangeTheirExistingItems)

	cmp	DWORD PTR _iTotalValueToMe$221755[ebp], 0
	jge	SHORT $LN7@DoEqualize
	movzx	edx, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	edx, edx
	je	SHORT $LN7@DoEqualize

; 615  : 		{
; 616  : 			return false;

	xor	al, al
	jmp	$LN10@DoEqualize
$LN7@DoEqualize:

; 617  : 		}
; 618  : 
; 619  : 		if(bMakeOffer)

	movzx	eax, BYTE PTR _bMakeOffer$[ebp]
	test	eax, eax
	je	SHORT $LN6@DoEqualize

; 620  : 		{
; 621  : 			bDealGoodToBeginWith = true;

	mov	ecx, DWORD PTR _bDealGoodToBeginWith$[ebp]
	mov	BYTE PTR [ecx], 1

; 622  : 		}
; 623  : 		else

	jmp	SHORT $LN5@DoEqualize
$LN6@DoEqualize:

; 624  : 		{
; 625  : 			bDealGoodToBeginWith = false;

	mov	edx, DWORD PTR _bDealGoodToBeginWith$[ebp]
	mov	BYTE PTR [edx], 0
$LN5@DoEqualize:

; 626  : 		}
; 627  : 
; 628  : 		if(!bMakeOffer)

	movzx	eax, BYTE PTR _bMakeOffer$[ebp]
	test	eax, eax
	jne	$LN8@DoEqualize

; 629  : 		{
; 630  : 			/////////////////////////////
; 631  : 			// See if there are items we can add or remove from either side to balance out the deal if it's not already even
; 632  : 			/////////////////////////////
; 633  : 
; 634  : 			bool bUseEvenValue = false;

	mov	BYTE PTR _bUseEvenValue$221764[ebp], 0

; 635  : 
; 636  : 			// Maybe reorder these based on the AI's priorities (e.g. if it really doesn't want to give up Strategic Resources try adding those from us last)
; 637  : 
; 638  : 			//DoAddCitiesToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);
; 639  : 
; 640  : 			DoAddVoteCommitmentToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$221758[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToThem

; 641  : 			DoAddVoteCommitmentToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAmountUnderWeWillOffer$221759[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$221756[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToUs

; 642  : 
; 643  : 			DoAddEmbassyToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	edx
	mov	eax, DWORD PTR _iAmountOverWeWillRequest$221758[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueImOffering$221756[ebp]
	push	edx
	lea	eax, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToThem

; 644  : 			DoAddEmbassyToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$221759[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddEmbassyToUs

; 645  : 
; 646  : 			DoAddResourceToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$221758[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToThem

; 647  : 			DoAddResourceToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$221759[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToUs

; 648  : 
; 649  : 			DoAddOpenBordersToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$221758[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToThem

; 650  : 			DoAddOpenBordersToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$221759[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToUs

; 651  : 
; 652  : 			DoAddGPTToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$221756[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToThem

; 653  : 			DoAddGPTToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	edx
	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueImOffering$221756[ebp]
	push	edx
	lea	eax, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToUs

; 654  : 
; 655  : 			DoAddGoldToThem(pDeal, eOtherPlayer, bDontChangeTheirExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$221756[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToThem

; 656  : 			DoAddGoldToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToUs

; 657  : 
; 658  : 			if (!bDontChangeTheirExistingItems)

	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	eax, eax
	jne	SHORT $LN3@DoEqualize

; 659  : 			{
; 660  : 				DoRemoveGPTFromThem(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromThem
$LN3@DoEqualize:

; 661  : 			}
; 662  : 			if (!bDontChangeMyExistingItems)

	movzx	edx, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	edx, edx
	jne	SHORT $LN2@DoEqualize

; 663  : 			{
; 664  : 				DoRemoveGPTFromUs(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$221756[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromUs
$LN2@DoEqualize:

; 665  : 			}
; 666  : 
; 667  : 			DoRemoveGoldFromUs(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$221756[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromUs

; 668  : 			DoRemoveGoldFromThem(pDeal, eOtherPlayer, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$221756[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromThem

; 669  : 
; 670  : 			DoAddCitiesToUs(pDeal, eOtherPlayer, bDontChangeMyExistingItems, iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221764[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$221759[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddCitiesToUs

; 671  : 
; 672  : 			// Make sure we haven't removed everything from the deal!
; 673  : 			if(pDeal->m_TradedItems.size() > 0)

	mov	eax, DWORD PTR _pDeal$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR $T225035[ebp], ecx
	cmp	DWORD PTR $T225035[ebp], 0
	jbe	SHORT $LN8@DoEqualize

; 674  : 			{
; 675  : 				bMakeOffer = IsDealWithHumanAcceptable(pDeal, GC.getGame().getActivePlayer(), /*Passed by reference*/ iTotalValueToMe, iValueImOffering, iValueTheyreOffering, iAmountOverWeWillRequest, iAmountUnderWeWillOffer, /*passed by reference*/bCantMatchOffer);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225043[ebp], edx
	mov	eax, DWORD PTR _bCantMatchOffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iAmountUnderWeWillOffer$221759[ebp]
	push	ecx
	lea	edx, DWORD PTR _iAmountOverWeWillRequest$221758[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyreOffering$221757[ebp]
	push	eax
	lea	ecx, DWORD PTR _iValueImOffering$221756[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValueToMe$221755[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225043[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDealWithHumanAcceptable@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@AAH2222AA_N@Z ; CvDealAI::IsDealWithHumanAcceptable
	mov	BYTE PTR _bMakeOffer$[ebp], al
$LN8@DoEqualize:

; 676  : 			}
; 677  : 		}
; 678  : 	}
; 679  : 
; 680  : 	return bMakeOffer;

	mov	al, BYTE PTR _bMakeOffer$[ebp]
$LN10@DoEqualize:

; 681  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ENDP ; CvDealAI::DoEqualizeDealWithHuman
_TEXT	ENDS
PUBLIC	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
EXTRN	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ:PROC	; CvPlayer::GetDealAI
EXTRN	?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z:PROC ; CvGameDeals::SetTempDeal
EXTRN	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ:PROC	; CvGameDeals::GetTempDeal
; Function compile flags: /Odtp
;	COMDAT ?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T225078 = -100						; size = 4
$T225074 = -96						; size = 4
$T225066 = -92						; size = 4
$T225061 = -88						; size = 4
$T225057 = -84						; size = 4
$T225053 = -80						; size = 4
$T225049 = -76						; size = 4
_iValueIThinkImGetting$221790 = -72			; size = 4
_iLowEndOfWhatIWillAccept$221791 = -68			; size = 4
_iLowEndOfWhatTheyWillAccept$221795 = -64		; size = 4
_iValueIThinkImOffering$221789 = -60			; size = 4
_iValueTheyThinkTheyreOffering$221793 = -56		; size = 4
_iValueTheyThinkTheyreGetting$221794 = -52		; size = 4
_bUseEvenValue$221787 = -45				; size = 1
_iAmountUnderWeWillOffer$ = -44				; size = 4
_iEvenValueTheyreOffering$ = -40			; size = 4
_iTotalValue$ = -36					; size = 4
_iEvenValueImOffering$ = -32				; size = 4
_iDealDuration$ = -28					; size = 4
_iPercentUnderWeWillOffer$ = -24			; size = 4
_bMakeOffer$ = -17					; size = 1
_iDealSumValue$ = -16					; size = 4
_iAmountOverWeWillRequest$ = -12			; size = 4
_pCounterDeal$ = -8					; size = 4
_iPercentOverWeWillRequest$ = -4			; size = 4
_pDeal$ = 8						; size = 4
_eOtherPlayer$ = 12					; size = 4
?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z PROC ; CvDealAI::DoEqualizeDealWithAI, COMDAT
; _this$ = ecx

; 686  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 687  : #ifdef CVASSERT_ENABLE
; 688  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();
; 689  : 	DEBUG_VARIABLE(eMyPlayer);
; 690  : 
; 691  : 	CvAssert(eOtherPlayer >= 0);
; 692  : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 693  : 	CvAssertMsg(eMyPlayer != eOtherPlayer, "DEAL_AI: Trying to equalize AI deal, but both players are the same.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 694  : #endif
; 695  : 
; 696  : 	int iEvenValueImOffering;
; 697  : 	int iEvenValueTheyreOffering;
; 698  : 	int iTotalValue = GetDealValue(pDeal, iEvenValueImOffering, iEvenValueTheyreOffering, /*bUseEvenValue*/ true);

	push	1
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	DWORD PTR _iTotalValue$[ebp], eax

; 699  : 
; 700  : 	int iDealDuration = GC.getGame().GetDealDuration();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225049[ebp], eax
	mov	ecx, DWORD PTR $T225049[ebp]
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	mov	DWORD PTR _iDealDuration$[ebp], eax

; 701  : 
; 702  : 	bool bMakeOffer = false;

	mov	BYTE PTR _bMakeOffer$[ebp], 0

; 703  : 
; 704  : 	/////////////////////////////
; 705  : 	// Outline the boundaries for an acceptable deal
; 706  : 	/////////////////////////////
; 707  : 
; 708  : 	int iPercentOverWeWillRequest = GetDealPercentLeewayWithAI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ ; CvDealAI::GetDealPercentLeewayWithAI
	mov	DWORD PTR _iPercentOverWeWillRequest$[ebp], eax

; 709  : 	int iPercentUnderWeWillOffer = -GetDealPercentLeewayWithAI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ ; CvDealAI::GetDealPercentLeewayWithAI
	neg	eax
	mov	DWORD PTR _iPercentUnderWeWillOffer$[ebp], eax

; 710  : 
; 711  : 	int iDealSumValue = iEvenValueImOffering + iEvenValueTheyreOffering;

	mov	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	add	ecx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	mov	DWORD PTR _iDealSumValue$[ebp], ecx

; 712  : 
; 713  : 	int iAmountOverWeWillRequest = iDealSumValue;

	mov	edx, DWORD PTR _iDealSumValue$[ebp]
	mov	DWORD PTR _iAmountOverWeWillRequest$[ebp], edx

; 714  : 	iAmountOverWeWillRequest *= iPercentOverWeWillRequest;

	mov	eax, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	imul	eax, DWORD PTR _iPercentOverWeWillRequest$[ebp]
	mov	DWORD PTR _iAmountOverWeWillRequest$[ebp], eax

; 715  : 	iAmountOverWeWillRequest /= 100;

	mov	eax, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iAmountOverWeWillRequest$[ebp], eax

; 716  : 
; 717  : 	int iAmountUnderWeWillOffer = iDealSumValue;

	mov	edx, DWORD PTR _iDealSumValue$[ebp]
	mov	DWORD PTR _iAmountUnderWeWillOffer$[ebp], edx

; 718  : 	iAmountUnderWeWillOffer *= iPercentUnderWeWillOffer;

	mov	eax, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	imul	eax, DWORD PTR _iPercentUnderWeWillOffer$[ebp]
	mov	DWORD PTR _iAmountUnderWeWillOffer$[ebp], eax

; 719  : 	iAmountUnderWeWillOffer /= 100;

	mov	eax, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iAmountUnderWeWillOffer$[ebp], eax

; 720  : 
; 721  : 	// Deal is already even enough for us
; 722  : 	if(iTotalValue <= iAmountOverWeWillRequest && iTotalValue >= iAmountUnderWeWillOffer)

	mov	edx, DWORD PTR _iTotalValue$[ebp]
	cmp	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	jg	SHORT $LN6@DoEqualize@2
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	cmp	eax, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	jl	SHORT $LN6@DoEqualize@2

; 723  : 	{
; 724  : 		bMakeOffer = true;

	mov	BYTE PTR _bMakeOffer$[ebp], 1
$LN6@DoEqualize@2:

; 725  : 	}
; 726  : 
; 727  : 	// If we set this pointer again it clears the data out!
; 728  : 	if(pDeal != GC.getGame().GetGameDeals()->GetTempDeal())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225053[ebp], ecx
	mov	ecx, DWORD PTR $T225053[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ; CvGameDeals::GetTempDeal
	cmp	DWORD PTR _pDeal$[ebp], eax
	je	SHORT $LN5@DoEqualize@2

; 729  : 	{
; 730  : 		GC.getGame().GetGameDeals()->SetTempDeal(pDeal);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225057[ebp], edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225057[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?SetTempDeal@CvGameDeals@@QAEXPAVCvDeal@@@Z ; CvGameDeals::SetTempDeal
$LN5@DoEqualize@2:

; 731  : 	}
; 732  : 
; 733  : 	CvDeal* pCounterDeal = GC.getGame().GetGameDeals()->GetTempDeal();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225061[ebp], ecx
	mov	ecx, DWORD PTR $T225061[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ; CvGameDeals::GetTempDeal
	mov	DWORD PTR _pCounterDeal$[ebp], eax

; 734  : 
; 735  : 	if(!bMakeOffer)

	movzx	edx, BYTE PTR _bMakeOffer$[ebp]
	test	edx, edx
	jne	$LN4@DoEqualize@2

; 736  : 	{
; 737  : 		/////////////////////////////
; 738  : 		// See if there are items we can add or remove from either side to balance out the deal if it's not already even
; 739  : 		/////////////////////////////
; 740  : 
; 741  : 		bool bUseEvenValue = true;

	mov	BYTE PTR _bUseEvenValue$221787[ebp], 1

; 742  : 
; 743  : 		DoAddVoteCommitmentToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountOverWeWillRequest, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221787[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueImOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValue$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCounterDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToThem

; 744  : 		DoAddVoteCommitmentToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountUnderWeWillOffer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValue$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCounterDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddVoteCommitmentToUs

; 745  : 
; 746  : 		DoAddResourceToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	edx
	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueImOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValue$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCounterDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToThem

; 747  : 		DoAddResourceToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCounterDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddResourceToUs

; 748  : 
; 749  : 		DoAddOpenBordersToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ true, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountOverWeWillRequest, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221787[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValue$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCounterDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToThem

; 750  : 		DoAddOpenBordersToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ true, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iAmountUnderWeWillOffer, iDealDuration, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	edx
	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueImOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValue$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCounterDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ; CvDealAI::DoAddOpenBordersToUs

; 751  : 
; 752  : 		DoAddGPTToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValue$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCounterDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToThem

; 753  : 		DoAddGPTToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	edx
	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCounterDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ; CvDealAI::DoAddGPTToUs

; 754  : 
; 755  : 		DoAddGoldToThem(pCounterDeal, eOtherPlayer, /*bDontChangeTheirExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221787[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCounterDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToThem

; 756  : 		DoAddGoldToUs(pCounterDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221787[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iTotalValue$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCounterDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ; CvDealAI::DoAddGoldToUs

; 757  : 
; 758  : 		DoRemoveGPTFromThem(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$221787[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueImOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTotalValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCounterDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromThem

; 759  : 		DoRemoveGPTFromUs(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, iDealDuration, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCounterDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ; CvDealAI::DoRemoveGPTFromUs

; 760  : 
; 761  : 		DoRemoveGoldFromUs(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCounterDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromUs

; 762  : 		DoRemoveGoldFromThem(pCounterDeal, eOtherPlayer, iTotalValue, iEvenValueImOffering, iEvenValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$221787[ebp]
	push	edx
	lea	eax, DWORD PTR _iEvenValueTheyreOffering$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iEvenValueImOffering$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iTotalValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCounterDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ; CvDealAI::DoRemoveGoldFromThem

; 763  : 
; 764  : 		// Make sure we haven't removed everything from the deal!
; 765  : 		if(pCounterDeal->m_TradedItems.size() > 0)

	mov	edx, DWORD PTR _pCounterDeal$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR $T225066[ebp], eax
	cmp	DWORD PTR $T225066[ebp], 0
	jbe	$LN4@DoEqualize@2

; 766  : 		{
; 767  : 			int iValueIThinkImOffering, iValueIThinkImGetting;
; 768  : 			GetDealValue(pDeal, iValueIThinkImOffering, iValueIThinkImGetting, /*bUseEvenValue*/ false);

	push	0
	lea	ecx, DWORD PTR _iValueIThinkImGetting$221790[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueIThinkImOffering$221789[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 769  : 
; 770  : 			// We don't think we're getting enough for what's on our side of the table
; 771  : 			int iLowEndOfWhatIWillAccept = iValueIThinkImOffering - (iValueIThinkImOffering * -iPercentUnderWeWillOffer / 100);

	mov	ecx, DWORD PTR _iPercentUnderWeWillOffer$[ebp]
	neg	ecx
	mov	eax, ecx
	imul	eax, DWORD PTR _iValueIThinkImOffering$221789[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iValueIThinkImOffering$221789[ebp]
	sub	edx, eax
	mov	DWORD PTR _iLowEndOfWhatIWillAccept$221791[ebp], edx

; 772  : 			if(iValueIThinkImGetting < iLowEndOfWhatIWillAccept)

	mov	eax, DWORD PTR _iValueIThinkImGetting$221790[ebp]
	cmp	eax, DWORD PTR _iLowEndOfWhatIWillAccept$221791[ebp]
	jge	SHORT $LN2@DoEqualize@2

; 773  : 			{
; 774  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@DoEqualize@2
$LN2@DoEqualize@2:

; 775  : 			}
; 776  : 
; 777  : 			int iValueTheyThinkTheyreOffering, iValueTheyThinkTheyreGetting;
; 778  : 			GET_PLAYER(eOtherPlayer).GetDealAI()->GetDealValue(pDeal, iValueTheyThinkTheyreOffering, iValueTheyThinkTheyreGetting, /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225074[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iValueTheyThinkTheyreGetting$221794[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueTheyThinkTheyreOffering$221793[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225074[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 779  : 
; 780  : 			// They don't think they're getting enough for what's on their side of the table
; 781  : 			int iLowEndOfWhatTheyWillAccept = iValueTheyThinkTheyreOffering - (iValueTheyThinkTheyreOffering * GET_PLAYER(eOtherPlayer).GetDealAI()->GetDealPercentLeewayWithAI() / 100);

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225078[ebp], edx
	mov	ecx, DWORD PTR $T225078[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetDealPercentLeewayWithAI@CvDealAI@@QBEHXZ ; CvDealAI::GetDealPercentLeewayWithAI
	imul	eax, DWORD PTR _iValueTheyThinkTheyreOffering$221793[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iValueTheyThinkTheyreOffering$221793[ebp]
	sub	edx, eax
	mov	DWORD PTR _iLowEndOfWhatTheyWillAccept$221795[ebp], edx

; 782  : 			if(iValueTheyThinkTheyreGetting < iLowEndOfWhatTheyWillAccept)

	mov	eax, DWORD PTR _iValueTheyThinkTheyreGetting$221794[ebp]
	cmp	eax, DWORD PTR _iLowEndOfWhatTheyWillAccept$221795[ebp]
	jge	SHORT $LN1@DoEqualize@2

; 783  : 			{
; 784  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@DoEqualize@2
$LN1@DoEqualize@2:

; 785  : 			}
; 786  : 
; 787  : 			bMakeOffer = true;

	mov	BYTE PTR _bMakeOffer$[ebp], 1
$LN4@DoEqualize@2:

; 788  : 		}
; 789  : 	}
; 790  : 
; 791  : 	return bMakeOffer;

	mov	al, BYTE PTR _bMakeOffer$[ebp]
$LN7@DoEqualize@2:

; 792  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ENDP ; CvDealAI::DoEqualizeDealWithAI
_TEXT	ENDS
PUBLIC	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
EXTRN	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z:PROC ; CvDeal::GetOtherPlayer
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
xdata$x	SEGMENT
__unwindtable$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z$0
__ehfuncinfo$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z
_TEXT	SEGMENT
tv187 = -156						; size = 4
tv72 = -152						; size = 4
_this$ = -148						; size = 4
$T225454 = -144						; size = 4
$T225427 = -140						; size = 4
$T225421 = -136						; size = 4
$T225394 = -132						; size = 4
$T225388 = -128						; size = 4
$T225361 = -124						; size = 4
$T225355 = -120						; size = 4
$T225328 = -116						; size = 4
$T225322 = -112						; size = 4
$T225295 = -108						; size = 4
$T225289 = -104						; size = 4
$T225262 = -100						; size = 4
$T225230 = -96						; size = 4
$T225198 = -92						; size = 4
$T225175 = -88						; size = 4
$T225159 = -84						; size = 4
$T225155 = -80						; size = 4
$T225146 = -76						; size = 4
$T225098 = -72						; size = 4
$T225086 = -68						; size = 4
$T225085 = -64						; size = 8
$T225084 = -53						; size = 1
$T225083 = -52						; size = 8
_iValueMultiplier$221818 = -44				; size = 4
_eMyPlayer$ = -40					; size = 4
_bFromMe$ = -33						; size = 1
_eOtherPlayer$ = -32					; size = 4
_iDealValue$ = -28					; size = 4
_iItemValue$ = -24					; size = 4
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
_iValueImOffering$ = 12					; size = 4
_iValueTheyreOffering$ = 16				; size = 4
_bUseEvenValue$ = 20					; size = 1
?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z PROC	; CvDealAI::GetDealValue, COMDAT
; _this$ = ecx

; 802  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 803  : 	int iDealValue = 0;

	mov	DWORD PTR _iDealValue$[ebp], 0

; 804  : 	iValueImOffering = 0;

	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	mov	DWORD PTR [eax], 0

; 805  : 	iValueTheyreOffering = 0;

	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	mov	DWORD PTR [ecx], 0

; 806  : 
; 807  : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225098[ebp], eax
	mov	edx, DWORD PTR $T225098[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$[ebp], eax

; 808  : 
; 809  : 	int iItemValue;
; 810  : 
; 811  : 	bool bFromMe;
; 812  : 	PlayerTypes eOtherPlayer;
; 813  : 
; 814  : 	eOtherPlayer = pDeal->m_eFromPlayer == eMyPlayer ? pDeal->m_eToPlayer : pDeal->m_eFromPlayer;

	mov	ecx, DWORD PTR _pDeal$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _eMyPlayer$[ebp]
	jne	SHORT $LN10@GetDealVal
	mov	eax, DWORD PTR _pDeal$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN11@GetDealVal
$LN10@GetDealVal:
	mov	edx, DWORD PTR _pDeal$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv72[ebp], eax
$LN11@GetDealVal:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _eOtherPlayer$[ebp], ecx

; 815  : 
; 816  : 	TradedItemList::iterator it;

	mov	DWORD PTR _it$[ebp], 0
	mov	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 817  : 	for(it = pDeal->m_TradedItems.begin(); it != pDeal->m_TradedItems.end(); ++it)

	lea	edx, DWORD PTR $T225083[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::begin
	mov	DWORD PTR tv187[ebp], eax
	mov	eax, DWORD PTR tv187[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$[ebp], ecx
	mov	DWORD PTR _it$[ebp+4], edx
	jmp	SHORT $LN7@GetDealVal
$LN6@GetDealVal:
	cmp	DWORD PTR _it$[ebp+4], 268435455	; 0fffffffH
	jne	SHORT $LN38@GetDealVal
	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _it$[ebp+4], ecx
	jmp	SHORT $LN7@GetDealVal
$LN38@GetDealVal:
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225146[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T225146[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T225155[ebp], eax
	mov	edx, DWORD PTR $T225155[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225159[ebp], eax
	mov	ecx, DWORD PTR $T225159[ebp]
	mov	DWORD PTR _it$[ebp+4], ecx
$LN7@GetDealVal:
	lea	edx, DWORD PTR $T225085[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	add	ecx, 44					; 0000002cH
	call	?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ; FFastList<CvTradedItem,21,0>::end
	mov	DWORD PTR $T225175[ebp], eax
	mov	eax, DWORD PTR $T225175[ebp]
	mov	ecx, DWORD PTR _it$[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setne	dl
	mov	BYTE PTR $T225084[ebp], dl
	movzx	eax, BYTE PTR $T225084[ebp]
	test	eax, eax
	je	$LN5@GetDealVal

; 818  : 	{
; 819  : 		if(eMyPlayer == it->m_eFromPlayer)

	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225198[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T225198[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _eMyPlayer$[ebp]
	cmp	eax, DWORD PTR [ecx+edx+36]
	jne	SHORT $LN4@GetDealVal

; 820  : 		{
; 821  : 			bFromMe = true;

	mov	BYTE PTR _bFromMe$[ebp], 1

; 822  : 			eOtherPlayer = pDeal->GetOtherPlayer(eMyPlayer);

	mov	ecx, DWORD PTR _eMyPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetOtherPlayer@CvDeal@@QBE?AW4PlayerTypes@@W42@@Z ; CvDeal::GetOtherPlayer
	mov	DWORD PTR _eOtherPlayer$[ebp], eax

; 823  : 		}
; 824  : 		else

	jmp	SHORT $LN3@GetDealVal
$LN4@GetDealVal:

; 825  : 		{
; 826  : 			bFromMe = false;

	mov	BYTE PTR _bFromMe$[ebp], 0

; 827  : 			eOtherPlayer = it->m_eFromPlayer;

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225230[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T225230[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+eax+36]
	mov	DWORD PTR _eOtherPlayer$[ebp], eax
$LN3@GetDealVal:

; 828  : 		}
; 829  : 
; 830  : 		// Multiplier is -1 if we're giving something away, 1 if we're receiving something
; 831  : 		int iValueMultiplier = bFromMe ? -1 : 1;

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 1
	mov	DWORD PTR _iValueMultiplier$221818[ebp], ecx

; 832  : 
; 833  : 		iItemValue = GetTradeItemValue(it->m_eItemType, bFromMe, eOtherPlayer, it->m_iData1, it->m_iData2, it->m_iData3, it->m_bFlag1, it->m_iDuration, bUseEvenValue);

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225262[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T225262[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T225289[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225295[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T225295[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T225322[ebp], edx
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225328[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T225328[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T225355[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225361[ebp], edx
	mov	eax, DWORD PTR _it$[ebp+4]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR $T225361[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+eax+8]
	mov	DWORD PTR $T225388[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225394[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp+4]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR $T225394[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR $T225421[ebp], edx
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T225427[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR $T225427[ebp]
	mov	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [eax+ecx+8]
	mov	DWORD PTR $T225454[ebp], ecx
	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR $T225289[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR $T225322[ebp]
	movzx	eax, BYTE PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR $T225355[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR $T225388[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR $T225421[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bFromMe$[ebp]
	push	edx
	mov	eax, DWORD PTR $T225454[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$[ebp], eax

; 834  : 
; 835  : 		iItemValue *= iValueMultiplier;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, DWORD PTR _iValueMultiplier$221818[ebp]
	mov	DWORD PTR _iItemValue$[ebp], edx

; 836  : 		iDealValue += iItemValue;

	mov	eax, DWORD PTR _iDealValue$[ebp]
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iDealValue$[ebp], eax

; 837  : 
; 838  : 		// Figure out who's offering what, and keep track of the overall value on both sides of the deal
; 839  : 		if(iItemValue < 0)

	cmp	DWORD PTR _iItemValue$[ebp], 0
	jge	SHORT $LN2@GetDealVal

; 840  : 		{
; 841  : 			iValueImOffering -= iItemValue;

	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _iItemValue$[ebp]
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	mov	DWORD PTR [eax], edx

; 842  : 		}
; 843  : 		else

	jmp	SHORT $LN1@GetDealVal
$LN2@GetDealVal:

; 844  : 		{
; 845  : 			iValueTheyreOffering += iItemValue;

	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _iItemValue$[ebp]
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	mov	DWORD PTR [eax], edx
$LN1@GetDealVal:

; 846  : 		}
; 847  : 	}

	jmp	$LN6@GetDealVal
$LN5@GetDealVal:

; 848  : 
; 849  : 	return iDealValue;

	mov	ecx, DWORD PTR _iDealValue$[ebp]
	mov	DWORD PTR $T225086[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T225086[ebp]

; 850  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z$0:
	lea	ecx, DWORD PTR _it$[ebp]
	jmp	??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ; FFastList<CvTradedItem,21,0>::iterator::~iterator
__ehhandler$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ENDP	; CvDealAI::GetDealValue
PUBLIC	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue
PUBLIC	?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyWarValue
PUBLIC	?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyPeaceValue
PUBLIC	?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z ; CvDealAI::GetPeaceTreatyValue
PUBLIC	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue
PUBLIC	?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetResearchAgreementValue
PUBLIC	?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetDefensivePactValue
PUBLIC	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue
PUBLIC	?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetEmbassyValue
PUBLIC	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
PUBLIC	?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ; CvDealAI::GetResourceValue
PUBLIC	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
PUBLIC	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
; Function compile flags: /Odtp
;	COMDAT ?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iItemValue$ = -4					; size = 4
_eItem$ = 8						; size = 4
_bFromMe$ = 12						; size = 1
_eOtherPlayer$ = 16					; size = 4
_iData1$ = 20						; size = 4
_iData2$ = 24						; size = 4
_iData3$ = 28						; size = 4
_bFlag1$ = 32						; size = 1
_iDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z PROC ; CvDealAI::GetTradeItemValue, COMDAT
; _this$ = ecx

; 854  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 855  : 	CvAssert(eOtherPlayer >= 0);
; 856  : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 857  : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to get deal item value for trading to oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 858  : 	CvAssertMsg(eItem != TRADE_ITEM_NONE, "DEAL_AI: Trying to get value of TRADE_ITEM_NONE.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 859  : 
; 860  : 	int iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 861  : 
; 862  : 	if(eItem == TRADE_ITEM_GOLD)

	cmp	DWORD PTR _eItem$[ebp], 0
	jne	SHORT $LN25@GetTradeIt

; 863  : 		iItemValue = GetGoldForForValueExchange(/*Gold Amount*/ iData1, /*bNumGoldFromValue*/ false, bFromMe, eOtherPlayer, bUseEvenValue, /*bRoundUp*/ false);

	push	0
	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bFromMe$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _iData1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN25@GetTradeIt:

; 864  : 	else if(eItem == TRADE_ITEM_GOLD_PER_TURN)

	cmp	DWORD PTR _eItem$[ebp], 1
	jne	SHORT $LN23@GetTradeIt

; 865  : 		iItemValue = GetGPTforForValueExchange(/*Gold Per Turn Amount*/ iData1, /*bNumGPTFromValue*/ false, iDuration, bFromMe, eOtherPlayer, bUseEvenValue, /*bRoundUp*/ false);

	push	0
	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFromMe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDuration$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN23@GetTradeIt:

; 866  : 	else if(eItem == TRADE_ITEM_RESOURCES)

	cmp	DWORD PTR _eItem$[ebp], 3
	jne	SHORT $LN21@GetTradeIt

; 867  : 		iItemValue = GetResourceValue(/*ResourceType*/ (ResourceTypes) iData1, /*Quantity*/ iData2, iDuration, bFromMe, eOtherPlayer);

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ; CvDealAI::GetResourceValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN21@GetTradeIt:

; 868  : 	else if(eItem == TRADE_ITEM_CITIES)

	cmp	DWORD PTR _eItem$[ebp], 4
	jne	SHORT $LN19@GetTradeIt

; 869  : 		iItemValue = GetCityValue(/*iX*/ iData1, /*iY*/ iData2, bFromMe, eOtherPlayer, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData2$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN19@GetTradeIt:

; 870  : 	else if(eItem == TRADE_ITEM_ALLOW_EMBASSY)

	cmp	DWORD PTR _eItem$[ebp], 17		; 00000011H
	jne	SHORT $LN17@GetTradeIt

; 871  : 		iItemValue = GetEmbassyValue(bFromMe, eOtherPlayer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFromMe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetEmbassyValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN17@GetTradeIt:

; 872  : 	else if(eItem == TRADE_ITEM_OPEN_BORDERS)

	cmp	DWORD PTR _eItem$[ebp], 6
	jne	SHORT $LN15@GetTradeIt

; 873  : 		iItemValue = GetOpenBordersValue(bFromMe, eOtherPlayer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFromMe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN15@GetTradeIt:

; 874  : 	else if(eItem == TRADE_ITEM_DEFENSIVE_PACT)

	cmp	DWORD PTR _eItem$[ebp], 7
	jne	SHORT $LN13@GetTradeIt

; 875  : 		iItemValue = GetDefensivePactValue(bFromMe, eOtherPlayer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFromMe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetDefensivePactValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN13@GetTradeIt:

; 876  : 	else if(eItem == TRADE_ITEM_RESEARCH_AGREEMENT)

	cmp	DWORD PTR _eItem$[ebp], 8
	jne	SHORT $LN11@GetTradeIt

; 877  : 		iItemValue = GetResearchAgreementValue(bFromMe, eOtherPlayer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFromMe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetResearchAgreementValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN11@GetTradeIt:

; 878  : 	else if(eItem == TRADE_ITEM_TRADE_AGREEMENT)

	cmp	DWORD PTR _eItem$[ebp], 9
	jne	SHORT $LN9@GetTradeIt

; 879  : 		iItemValue = GetTradeAgreementValue(bFromMe, eOtherPlayer, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFromMe$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN24@GetTradeIt
$LN9@GetTradeIt:

; 880  : 	else if(eItem == TRADE_ITEM_PEACE_TREATY)

	cmp	DWORD PTR _eItem$[ebp], 13		; 0000000dH
	jne	SHORT $LN7@GetTradeIt

; 881  : 		iItemValue = GetPeaceTreatyValue(eOtherPlayer);

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z ; CvDealAI::GetPeaceTreatyValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN24@GetTradeIt
$LN7@GetTradeIt:

; 882  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_PEACE)

	cmp	DWORD PTR _eItem$[ebp], 14		; 0000000eH
	jne	SHORT $LN5@GetTradeIt

; 883  : 		iItemValue = GetThirdPartyPeaceValue(bFromMe, eOtherPlayer, /*eWithTeam*/ (TeamTypes) iData1);

	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyPeaceValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN24@GetTradeIt
$LN5@GetTradeIt:

; 884  : 	else if(eItem == TRADE_ITEM_THIRD_PARTY_WAR)

	cmp	DWORD PTR _eItem$[ebp], 15		; 0000000fH
	jne	SHORT $LN3@GetTradeIt

; 885  : 		iItemValue = GetThirdPartyWarValue(bFromMe, eOtherPlayer, /*eWithTeam*/ (TeamTypes) iData1);

	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDealAI::GetThirdPartyWarValue
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN24@GetTradeIt
$LN3@GetTradeIt:

; 886  : 	else if(eItem == TRADE_ITEM_VOTE_COMMITMENT)

	cmp	DWORD PTR _eItem$[ebp], 19		; 00000013H
	jne	SHORT $LN24@GetTradeIt

; 887  : 		iItemValue = GetVoteCommitmentValue(bFromMe, eOtherPlayer, iData1, iData2, iData3, bFlag1, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFlag1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData2$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bFromMe$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN24@GetTradeIt:

; 888  : 
; 889  : 	CvAssertMsg(iItemValue >= 0, "DEAL_AI: Trade Item value is negative.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 890  : 
; 891  : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]

; 892  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ENDP ; CvDealAI::GetTradeItemValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z
_TEXT	SEGMENT
tv130 = -40						; size = 4
tv82 = -36						; size = 4
_this$ = -32						; size = 4
$T225501 = -28						; size = 4
$T225497 = -24						; size = 4
$T225496 = -20						; size = 4
_iDivisor$ = -16					; size = 4
_iReturnValue$ = -12					; size = 4
_iMultiplier$ = -8					; size = 4
_iModifier$ = -4					; size = 4
_iGoldOrValue$ = 8					; size = 4
_bNumGoldFromValue$ = 12				; size = 1
_bFromMe$ = 16						; size = 1
_eOtherPlayer$ = 20					; size = 4
_bUseEvenValue$ = 24					; size = 1
_bRoundUp$ = 28						; size = 1
?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z PROC ; CvDealAI::GetGoldForForValueExchange, COMDAT
; _this$ = ecx

; 896  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 897  : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of Gold with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 898  : 
; 899  : 	int iMultiplier;
; 900  : 	int iDivisor;
; 901  : 
; 902  : 	// We passed in Value, we want to know how much Gold we get for it
; 903  : 	if(bNumGoldFromValue)

	movzx	eax, BYTE PTR _bNumGoldFromValue$[ebp]
	test	eax, eax
	je	SHORT $LN28@GetGoldFor

; 904  : 	{
; 905  : 		iMultiplier = 100;

	mov	DWORD PTR _iMultiplier$[ebp], 100	; 00000064H

; 906  : 		iDivisor = /*100*/ GC.getEACH_GOLD_VALUE_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6068
	mov	DWORD PTR _iDivisor$[ebp], ecx

; 907  : 		// Protect against a modder setting this to 0
; 908  : 		if(iDivisor == 0)

	cmp	DWORD PTR _iDivisor$[ebp], 0
	jne	SHORT $LN27@GetGoldFor

; 909  : 			iDivisor = 1;

	mov	DWORD PTR _iDivisor$[ebp], 1
$LN27@GetGoldFor:

; 910  : 	}
; 911  : 	// We passed in an amount of Gold, we want to know how much it's worth
; 912  : 	else

	jmp	SHORT $LN26@GetGoldFor
$LN28@GetGoldFor:

; 913  : 	{
; 914  : 		iMultiplier = /*100*/ GC.getEACH_GOLD_VALUE_PERCENT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6068
	mov	DWORD PTR _iMultiplier$[ebp], edx

; 915  : 		iDivisor = 100;

	mov	DWORD PTR _iDivisor$[ebp], 100		; 00000064H
$LN26@GetGoldFor:

; 916  : 	}
; 917  : 
; 918  : 	// Convert based on the rules above
; 919  : 	int iReturnValue = iGoldOrValue * iMultiplier;

	mov	eax, DWORD PTR _iGoldOrValue$[ebp]
	imul	eax, DWORD PTR _iMultiplier$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 920  : 
; 921  : 	int iModifier;
; 922  : 
; 923  : 	// While we have a big number shall we apply some modifiers to it?
; 924  : 	if(bFromMe)

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	je	$LN25@GetGoldFor

; 925  : 	{
; 926  : 		// Approach is important
; 927  : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	push	1
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv82[ebp], eax
	mov	eax, DWORD PTR tv82[ebp]
	sub	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	cmp	DWORD PTR tv82[ebp], 5
	ja	SHORT $LN17@GetGoldFor
	mov	ecx, DWORD PTR tv82[ebp]
	jmp	DWORD PTR $LN41@GetGoldFor[ecx*4]
$LN22@GetGoldFor:

; 928  : 		{
; 929  : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 930  : 			iModifier = 150;

	mov	DWORD PTR _iModifier$[ebp], 150		; 00000096H

; 931  : 			break;

	jmp	SHORT $LN23@GetGoldFor
$LN21@GetGoldFor:

; 932  : 		case MAJOR_CIV_APPROACH_GUARDED:
; 933  : 			iModifier = 110;

	mov	DWORD PTR _iModifier$[ebp], 110		; 0000006eH

; 934  : 			break;

	jmp	SHORT $LN23@GetGoldFor
$LN20@GetGoldFor:

; 935  : 		case MAJOR_CIV_APPROACH_AFRAID:
; 936  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H

; 937  : 			break;

	jmp	SHORT $LN23@GetGoldFor
$LN19@GetGoldFor:

; 938  : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 939  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H

; 940  : 			break;

	jmp	SHORT $LN23@GetGoldFor
$LN18@GetGoldFor:

; 941  : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 942  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H

; 943  : 			break;

	jmp	SHORT $LN23@GetGoldFor
$LN17@GetGoldFor:

; 944  : 		default:
; 945  : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 946  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H
$LN23@GetGoldFor:

; 947  : 			break;
; 948  : 		}
; 949  : 
; 950  : 		// See whether we should multiply or divide
; 951  : 		if(!bNumGoldFromValue)

	movzx	edx, BYTE PTR _bNumGoldFromValue$[ebp]
	test	edx, edx
	jne	SHORT $LN16@GetGoldFor

; 952  : 		{
; 953  : 			iReturnValue *= iModifier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	imul	eax, DWORD PTR _iModifier$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 954  : 			iReturnValue /= 100;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 955  : 		}
; 956  : 		else

	jmp	SHORT $LN15@GetGoldFor
$LN16@GetGoldFor:

; 957  : 		{
; 958  : 			iReturnValue *= 100;

	mov	edx, DWORD PTR _iReturnValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iReturnValue$[ebp], edx

; 959  : 			iReturnValue /= iModifier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	idiv	DWORD PTR _iModifier$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax
$LN15@GetGoldFor:

; 960  : 		}
; 961  : 
; 962  : 		// Opinion also matters
; 963  : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR tv130[ebp], eax
	cmp	DWORD PTR tv130[ebp], 6
	ja	SHORT $LN5@GetGoldFor
	mov	ecx, DWORD PTR tv130[ebp]
	jmp	DWORD PTR $LN42@GetGoldFor[ecx*4]
$LN12@GetGoldFor:

; 964  : 		{
; 965  : 		case MAJOR_CIV_OPINION_ALLY:
; 966  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H

; 967  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN11@GetGoldFor:

; 968  : 		case MAJOR_CIV_OPINION_FRIEND:
; 969  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H

; 970  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN10@GetGoldFor:

; 971  : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 972  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H

; 973  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN9@GetGoldFor:

; 974  : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 975  : 			iModifier = 100;

	mov	DWORD PTR _iModifier$[ebp], 100		; 00000064H

; 976  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN8@GetGoldFor:

; 977  : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 978  : 			iModifier = 115;

	mov	DWORD PTR _iModifier$[ebp], 115		; 00000073H

; 979  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN7@GetGoldFor:

; 980  : 		case MAJOR_CIV_OPINION_ENEMY:
; 981  : 			iModifier = 140;

	mov	DWORD PTR _iModifier$[ebp], 140		; 0000008cH

; 982  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN6@GetGoldFor:

; 983  : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 984  : 			iModifier = 200;

	mov	DWORD PTR _iModifier$[ebp], 200		; 000000c8H

; 985  : 			break;

	jmp	SHORT $LN13@GetGoldFor
$LN5@GetGoldFor:

; 986  : 		default:
; 987  : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 988  : 			iReturnValue *= 100;

	mov	edx, DWORD PTR _iReturnValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iReturnValue$[ebp], edx
$LN13@GetGoldFor:

; 989  : 			break;
; 990  : 		}
; 991  : 
; 992  : 		// See whether we should multiply or divide
; 993  : 		if(!bNumGoldFromValue)

	movzx	eax, BYTE PTR _bNumGoldFromValue$[ebp]
	test	eax, eax
	jne	SHORT $LN4@GetGoldFor

; 994  : 		{
; 995  : 			iReturnValue *= iModifier;

	mov	ecx, DWORD PTR _iReturnValue$[ebp]
	imul	ecx, DWORD PTR _iModifier$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], ecx

; 996  : 			iReturnValue /= 100;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 997  : 		}
; 998  : 		else

	jmp	SHORT $LN25@GetGoldFor
$LN4@GetGoldFor:

; 999  : 		{
; 1000 : 			iReturnValue *= 100;

	mov	edx, DWORD PTR _iReturnValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iReturnValue$[ebp], edx

; 1001 : 			iReturnValue /= iModifier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	idiv	DWORD PTR _iModifier$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax
$LN25@GetGoldFor:

; 1002 : 		}
; 1003 : 	}
; 1004 : 
; 1005 : 	// Sometimes we want to round up.  Let's say a the AI offers a deal to the human.  We have to ensure that the human can also offer that deal back and the AI will accept (and vice versa)
; 1006 : 	if(bRoundUp)

	movzx	eax, BYTE PTR _bRoundUp$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetGoldFor

; 1007 : 	{
; 1008 : 		iReturnValue += 99;

	mov	ecx, DWORD PTR _iReturnValue$[ebp]
	add	ecx, 99					; 00000063H
	mov	DWORD PTR _iReturnValue$[ebp], ecx
$LN2@GetGoldFor:

; 1009 : 	}
; 1010 : 
; 1011 : 	iReturnValue /= iDivisor;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	idiv	DWORD PTR _iDivisor$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1012 : 
; 1013 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1014 : 	if(bUseEvenValue)

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetGoldFor

; 1015 : 	{
; 1016 : 		iReturnValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetGoldForForValueExchange(iGoldOrValue, bNumGoldFromValue, !bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false, bRoundUp);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225496[ebp], eax
	mov	eax, DWORD PTR $T225496[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T225497[ebp], ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225501[ebp], edx
	movzx	eax, BYTE PTR _bRoundUp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR $T225497[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bFromMe$[ebp]
	test	edx, edx
	sete	al
	movzx	ecx, al
	push	ecx
	movzx	edx, BYTE PTR _bNumGoldFromValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _iGoldOrValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225501[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	add	eax, DWORD PTR _iReturnValue$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1017 : 
; 1018 : 		iReturnValue /= 2;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iReturnValue$[ebp], eax
$LN1@GetGoldFor:

; 1019 : 	}
; 1020 : 
; 1021 : 	return iReturnValue;

	mov	eax, DWORD PTR _iReturnValue$[ebp]

; 1022 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN41@GetGoldFor:
	DD	$LN22@GetGoldFor
	DD	$LN17@GetGoldFor
	DD	$LN21@GetGoldFor
	DD	$LN20@GetGoldFor
	DD	$LN19@GetGoldFor
	DD	$LN18@GetGoldFor
$LN42@GetGoldFor:
	DD	$LN6@GetGoldFor
	DD	$LN7@GetGoldFor
	DD	$LN8@GetGoldFor
	DD	$LN9@GetGoldFor
	DD	$LN10@GetGoldFor
	DD	$LN11@GetGoldFor
	DD	$LN12@GetGoldFor
?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ENDP ; CvDealAI::GetGoldForForValueExchange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z
_TEXT	SEGMENT
tv136 = -48						; size = 4
tv88 = -44						; size = 4
_this$ = -40						; size = 4
$T225525 = -36						; size = 4
$T225521 = -32						; size = 4
$T225520 = -28						; size = 4
_iModifier$221928 = -24					; size = 4
_iDivisor$ = -20					; size = 4
_iPreCalculationDurationMultiplier$ = -16		; size = 4
_iReturnValue$ = -12					; size = 4
_iPostCalculationDurationDivider$ = -8			; size = 4
_iMultiplier$ = -4					; size = 4
_iGPTorValue$ = 8					; size = 4
_bNumGPTFromValue$ = 12					; size = 1
_iNumTurns$ = 16					; size = 4
_bFromMe$ = 20						; size = 1
_eOtherPlayer$ = 24					; size = 4
_bUseEvenValue$ = 28					; size = 1
_bRoundUp$ = 32						; size = 1
?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z PROC ; CvDealAI::GetGPTforForValueExchange, COMDAT
; _this$ = ecx

; 1026 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1027 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of GPT with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1028 : 
; 1029 : 	int iPreCalculationDurationMultiplier;
; 1030 : 	int iMultiplier;
; 1031 : 	int iDivisor;
; 1032 : 	int iPostCalculationDurationDivider;
; 1033 : 
; 1034 : 	// We passed in Value, we want to know how much GPT we get for it
; 1035 : 	if(bNumGPTFromValue)

	movzx	eax, BYTE PTR _bNumGPTFromValue$[ebp]
	test	eax, eax
	je	SHORT $LN29@GetGPTforF

; 1036 : 	{
; 1037 : 		iPreCalculationDurationMultiplier = 1;

	mov	DWORD PTR _iPreCalculationDurationMultiplier$[ebp], 1

; 1038 : 		iMultiplier = 100;

	mov	DWORD PTR _iMultiplier$[ebp], 100	; 00000064H

; 1039 : 		iDivisor = /*80*/ GC.getEACH_GOLD_PER_TURN_VALUE_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6072
	mov	DWORD PTR _iDivisor$[ebp], ecx

; 1040 : 		iPostCalculationDurationDivider = iNumTurns;	// Divide value by number of turns to get GPT

	mov	edx, DWORD PTR _iNumTurns$[ebp]
	mov	DWORD PTR _iPostCalculationDurationDivider$[ebp], edx

; 1041 : 
; 1042 : 		// Example: want amount of GPT for 100 value.
; 1043 : 		// 100v * 1 = 100
; 1044 : 		// 100 * 100 / 80 = 125
; 1045 : 		// 125 / 20 turns = 6.25GPT
; 1046 : 	}
; 1047 : 	// We passed in an amount of GPT, we want to know how much it's worth
; 1048 : 	else

	jmp	SHORT $LN28@GetGPTforF
$LN29@GetGPTforF:

; 1049 : 	{
; 1050 : 		iPreCalculationDurationMultiplier = iNumTurns;	// Multiply GPT by number of turns to get value

	mov	eax, DWORD PTR _iNumTurns$[ebp]
	mov	DWORD PTR _iPreCalculationDurationMultiplier$[ebp], eax

; 1051 : 		iMultiplier = /*80*/ GC.getEACH_GOLD_PER_TURN_VALUE_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6072
	mov	DWORD PTR _iMultiplier$[ebp], ecx

; 1052 : 		iDivisor = 100;

	mov	DWORD PTR _iDivisor$[ebp], 100		; 00000064H

; 1053 : 		iPostCalculationDurationDivider = 1;

	mov	DWORD PTR _iPostCalculationDurationDivider$[ebp], 1
$LN28@GetGPTforF:

; 1054 : 
; 1055 : 		// Example: want value for 6 GPT
; 1056 : 		// 6GPT * 20 turns = 120
; 1057 : 		// 120 * 80 / 100 = 96
; 1058 : 		// 96 / 1 = 96v
; 1059 : 	}
; 1060 : 
; 1061 : 	// Convert based on the rules above
; 1062 : 	int iReturnValue = iGPTorValue * iPreCalculationDurationMultiplier;

	mov	edx, DWORD PTR _iGPTorValue$[ebp]
	imul	edx, DWORD PTR _iPreCalculationDurationMultiplier$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], edx

; 1063 : 	iReturnValue *= iMultiplier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	imul	eax, DWORD PTR _iMultiplier$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1064 : 
; 1065 : 	// While we have a big number shall we apply some modifiers to it?
; 1066 : 	if(bFromMe)

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	je	$LN27@GetGPTforF

; 1067 : 	{
; 1068 : 		// AI values it's GPT more highly because it's easy to exploit this
; 1069 : 		// See whether we should multiply or divide
; 1070 : 		if(!bNumGPTFromValue)

	movzx	edx, BYTE PTR _bNumGPTFromValue$[ebp]
	test	edx, edx
	jne	SHORT $LN26@GetGPTforF

; 1071 : 		{
; 1072 : 			iReturnValue *= 130;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	imul	eax, 130				; 00000082H
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1073 : 			iReturnValue /= 100;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1074 : 		}
; 1075 : 		else

	jmp	SHORT $LN25@GetGPTforF
$LN26@GetGPTforF:

; 1076 : 		{
; 1077 : 			iReturnValue *= 100;

	mov	edx, DWORD PTR _iReturnValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iReturnValue$[ebp], edx

; 1078 : 			iReturnValue /= 130;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	mov	ecx, 130				; 00000082H
	idiv	ecx
	mov	DWORD PTR _iReturnValue$[ebp], eax
$LN25@GetGPTforF:

; 1079 : 		}
; 1080 : 
; 1081 : 		int iModifier;
; 1082 : 
; 1083 : 		// Approach is important
; 1084 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	push	1
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv88[ebp], eax
	mov	eax, DWORD PTR tv88[ebp]
	sub	eax, 1
	mov	DWORD PTR tv88[ebp], eax
	cmp	DWORD PTR tv88[ebp], 5
	ja	SHORT $LN17@GetGPTforF
	mov	ecx, DWORD PTR tv88[ebp]
	jmp	DWORD PTR $LN42@GetGPTforF[ecx*4]
$LN22@GetGPTforF:

; 1085 : 		{
; 1086 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1087 : 			iModifier = 150;

	mov	DWORD PTR _iModifier$221928[ebp], 150	; 00000096H

; 1088 : 			break;

	jmp	SHORT $LN23@GetGPTforF
$LN21@GetGPTforF:

; 1089 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1090 : 			iModifier = 110;

	mov	DWORD PTR _iModifier$221928[ebp], 110	; 0000006eH

; 1091 : 			break;

	jmp	SHORT $LN23@GetGPTforF
$LN20@GetGPTforF:

; 1092 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1093 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H

; 1094 : 			break;

	jmp	SHORT $LN23@GetGPTforF
$LN19@GetGPTforF:

; 1095 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1096 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H

; 1097 : 			break;

	jmp	SHORT $LN23@GetGPTforF
$LN18@GetGPTforF:

; 1098 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1099 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H

; 1100 : 			break;

	jmp	SHORT $LN23@GetGPTforF
$LN17@GetGPTforF:

; 1101 : 		default:
; 1102 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1103 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H
$LN23@GetGPTforF:

; 1104 : 			break;
; 1105 : 		}
; 1106 : 
; 1107 : 		// See whether we should multiply or divide
; 1108 : 		if(!bNumGPTFromValue)

	movzx	edx, BYTE PTR _bNumGPTFromValue$[ebp]
	test	edx, edx
	jne	SHORT $LN16@GetGPTforF

; 1109 : 		{
; 1110 : 			iReturnValue *= iModifier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	imul	eax, DWORD PTR _iModifier$221928[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1111 : 			iReturnValue /= 100;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1112 : 		}
; 1113 : 		else

	jmp	SHORT $LN15@GetGPTforF
$LN16@GetGPTforF:

; 1114 : 		{
; 1115 : 			iReturnValue *= 100;

	mov	edx, DWORD PTR _iReturnValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iReturnValue$[ebp], edx

; 1116 : 			iReturnValue /= iModifier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	idiv	DWORD PTR _iModifier$221928[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax
$LN15@GetGPTforF:

; 1117 : 		}
; 1118 : 
; 1119 : 		// Opinion also matters
; 1120 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR tv136[ebp], eax
	cmp	DWORD PTR tv136[ebp], 6
	ja	SHORT $LN5@GetGPTforF
	mov	ecx, DWORD PTR tv136[ebp]
	jmp	DWORD PTR $LN43@GetGPTforF[ecx*4]
$LN12@GetGPTforF:

; 1121 : 		{
; 1122 : 		case MAJOR_CIV_OPINION_ALLY:
; 1123 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H

; 1124 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN11@GetGPTforF:

; 1125 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1126 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H

; 1127 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN10@GetGPTforF:

; 1128 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1129 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H

; 1130 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN9@GetGPTforF:

; 1131 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1132 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H

; 1133 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN8@GetGPTforF:

; 1134 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1135 : 			iModifier = 115;

	mov	DWORD PTR _iModifier$221928[ebp], 115	; 00000073H

; 1136 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN7@GetGPTforF:

; 1137 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1138 : 			iModifier = 140;

	mov	DWORD PTR _iModifier$221928[ebp], 140	; 0000008cH

; 1139 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN6@GetGPTforF:

; 1140 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1141 : 			iModifier = 200;

	mov	DWORD PTR _iModifier$221928[ebp], 200	; 000000c8H

; 1142 : 			break;

	jmp	SHORT $LN13@GetGPTforF
$LN5@GetGPTforF:

; 1143 : 		default:
; 1144 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Gold valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1145 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221928[ebp], 100	; 00000064H
$LN13@GetGPTforF:

; 1146 : 			break;
; 1147 : 		}
; 1148 : 
; 1149 : 		// See whether we should multiply or divide
; 1150 : 		if(!bNumGPTFromValue)

	movzx	edx, BYTE PTR _bNumGPTFromValue$[ebp]
	test	edx, edx
	jne	SHORT $LN4@GetGPTforF

; 1151 : 		{
; 1152 : 			iReturnValue *= iModifier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	imul	eax, DWORD PTR _iModifier$221928[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1153 : 			iReturnValue /= 100;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1154 : 		}
; 1155 : 		else

	jmp	SHORT $LN27@GetGPTforF
$LN4@GetGPTforF:

; 1156 : 		{
; 1157 : 			iReturnValue *= 100;

	mov	edx, DWORD PTR _iReturnValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iReturnValue$[ebp], edx

; 1158 : 			iReturnValue /= iModifier;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	idiv	DWORD PTR _iModifier$221928[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax
$LN27@GetGPTforF:

; 1159 : 		}
; 1160 : 	}
; 1161 : 
; 1162 : 	// Sometimes we want to round up.  Let's say a the AI offers a deal to the human.  We have to ensure that the human can also offer that deal back and the AI will accept (and vice versa)
; 1163 : 	if(bRoundUp)

	movzx	eax, BYTE PTR _bRoundUp$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetGPTforF

; 1164 : 	{
; 1165 : 		iReturnValue += 99;

	mov	ecx, DWORD PTR _iReturnValue$[ebp]
	add	ecx, 99					; 00000063H
	mov	DWORD PTR _iReturnValue$[ebp], ecx
$LN2@GetGPTforF:

; 1166 : 	}
; 1167 : 
; 1168 : 	iReturnValue /= iDivisor;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	idiv	DWORD PTR _iDivisor$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1169 : 
; 1170 : 	iReturnValue /= iPostCalculationDurationDivider;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	idiv	DWORD PTR _iPostCalculationDurationDivider$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1171 : 
; 1172 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1173 : 	if(bUseEvenValue)

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetGPTforF

; 1174 : 	{
; 1175 : 		iReturnValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetGPTforForValueExchange(iGPTorValue, bNumGPTFromValue, iNumTurns, !bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false, bRoundUp);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225520[ebp], eax
	mov	eax, DWORD PTR $T225520[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T225521[ebp], ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225525[ebp], edx
	movzx	eax, BYTE PTR _bRoundUp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR $T225521[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bFromMe$[ebp]
	test	edx, edx
	sete	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _iNumTurns$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bNumGPTFromValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iGPTorValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225525[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	add	eax, DWORD PTR _iReturnValue$[ebp]
	mov	DWORD PTR _iReturnValue$[ebp], eax

; 1176 : 
; 1177 : 		iReturnValue /= 2;

	mov	eax, DWORD PTR _iReturnValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iReturnValue$[ebp], eax
$LN1@GetGPTforF:

; 1178 : 	}
; 1179 : 
; 1180 : 	return iReturnValue;

	mov	eax, DWORD PTR _iReturnValue$[ebp]

; 1181 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	2
$LN42@GetGPTforF:
	DD	$LN22@GetGPTforF
	DD	$LN17@GetGPTforF
	DD	$LN21@GetGPTforF
	DD	$LN20@GetGPTforF
	DD	$LN19@GetGPTforF
	DD	$LN18@GetGPTforF
$LN43@GetGPTforF:
	DD	$LN6@GetGPTforF
	DD	$LN7@GetGPTforF
	DD	$LN8@GetGPTforF
	DD	$LN9@GetGPTforF
	DD	$LN10@GetGPTforF
	DD	$LN11@GetGPTforF
	DD	$LN12@GetGPTforF
?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ENDP ; CvDealAI::GetGPTforForValueExchange
_TEXT	ENDS
EXTRN	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z:PROC ; CvTeam::IsResourceObsolete
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
EXTRN	?getHappiness@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getHappiness
EXTRN	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z:PROC ; CvGameLeagues::IsLuxuryHappinessBanned
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
; Function compile flags: /Odtp
;	COMDAT ?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv199 = -88						; size = 4
tv189 = -84						; size = 4
tv163 = -80						; size = 4
tv209 = -76						; size = 4
_this$ = -72						; size = 4
$T225582 = -68						; size = 4
$T225578 = -64						; size = 4
$T225577 = -60						; size = 4
$T225566 = -56						; size = 4
$T225557 = -52						; size = 4
$T225550 = -48						; size = 4
$T225549 = -44						; size = 4
$T225545 = -40						; size = 4
$T225541 = -36						; size = 4
$T225540 = -32						; size = 4
$T225531 = -28						; size = 4
$T225530 = -24						; size = 4
_iModifier$221991 = -20					; size = 4
_iHappinessFromResource$221972 = -16			; size = 4
_eUsage$ = -12						; size = 4
_iItemValue$ = -8					; size = 4
_pkResourceInfo$ = -4					; size = 4
_eResource$ = 8						; size = 4
_iResourceQuantity$ = 12				; size = 4
_iNumTurns$ = 16					; size = 4
_bFromMe$ = 20						; size = 1
_eOtherPlayer$ = 24					; size = 4
?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z PROC ; CvDealAI::GetResourceValue, COMDAT
; _this$ = ecx

; 1185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1186 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Resource with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1187 : 
; 1188 : 	int iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 1189 : 
; 1190 : 	const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$[ebp], eax

; 1191 : 	CvAssert(pkResourceInfo != NULL);
; 1192 : 	if (pkResourceInfo == NULL)

	cmp	DWORD PTR _pkResourceInfo$[ebp], 0
	jne	SHORT $LN33@GetResourc

; 1193 : 		return 0;

	xor	eax, eax
	jmp	$LN34@GetResourc
$LN33@GetResourc:

; 1194 : 
; 1195 : 	ResourceUsageTypes eUsage = pkResourceInfo->getResourceUsage();

	mov	ecx, DWORD PTR _pkResourceInfo$[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eUsage$[ebp], eax

; 1196 : 
; 1197 : 	// Luxury Resource
; 1198 : 	if(eUsage == RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _eUsage$[ebp], 2
	jne	$LN32@GetResourc

; 1199 : 	{
; 1200 : 		if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetPlayer()->GetID(), eResource))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225540[ebp], eax
	mov	ecx, DWORD PTR $T225540[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T225541[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225545[ebp], eax
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225541[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225545[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@GetResourc

; 1201 : 		{
; 1202 : 			iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 1203 : 		}
; 1204 : 		else

	jmp	SHORT $LN30@GetResourc
$LN31@GetResourc:

; 1205 : 		{
; 1206 : 			int iHappinessFromResource = pkResourceInfo->getHappiness();

	mov	ecx, DWORD PTR _pkResourceInfo$[ebp]
	call	?getHappiness@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getHappiness
	mov	DWORD PTR _iHappinessFromResource$221972[ebp], eax

; 1207 : 			iItemValue += (iResourceQuantity * iHappinessFromResource * iNumTurns * 2);	// Ex: 1 Silk for 4 Happiness * 30 turns * 2 = 240

	mov	ecx, DWORD PTR _iResourceQuantity$[ebp]
	imul	ecx, DWORD PTR _iHappinessFromResource$221972[ebp]
	imul	ecx, DWORD PTR _iNumTurns$[ebp]
	mov	edx, DWORD PTR _iItemValue$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1208 : 
; 1209 : 			// If we only have 1 of a Luxury then we value it much more
; 1210 : 			if(bFromMe)

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@GetResourc

; 1211 : 			{
; 1212 : 				if(GetPlayer()->getNumResourceAvailable(eResource) == 1)

	push	1
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	cmp	eax, 1
	jne	SHORT $LN30@GetResourc

; 1213 : 				{
; 1214 : 					iItemValue *= 3;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 3
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1215 : 					if(GetPlayer()->GetPlayerTraits()->GetLuxuryHappinessRetention() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T225549[ebp], eax
	mov	ecx, DWORD PTR $T225549[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	DWORD PTR $T225550[ebp], edx
	cmp	DWORD PTR $T225550[ebp], 0
	jle	SHORT $LN30@GetResourc

; 1216 : 					{
; 1217 : 						iItemValue /= 2;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN30@GetResourc:

; 1218 : 					}
; 1219 : 				}
; 1220 : 			}
; 1221 : 		}

	jmp	$LN26@GetResourc
$LN32@GetResourc:

; 1222 : 	}
; 1223 : 	// Strategic Resource
; 1224 : 	else if(eUsage == RESOURCEUSAGE_STRATEGIC)

	cmp	DWORD PTR _eUsage$[ebp], 1
	jne	$LN26@GetResourc

; 1225 : 	{
; 1226 : 		//tricksy humans trying to sploit us
; 1227 : 		if(!bFromMe)

	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	jne	$LN24@GetResourc

; 1228 : 		{
; 1229 : 			// if we already have a big surplus of this resource
; 1230 : 			if(GetPlayer()->getNumResourceAvailable(eResource) > GetPlayer()->getNumCities())

	push	1
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	esi, eax
	jle	SHORT $LN23@GetResourc

; 1231 : 			{
; 1232 : 				iResourceQuantity = 0;

	mov	DWORD PTR _iResourceQuantity$[ebp], 0

; 1233 : 			}
; 1234 : 			else

	jmp	SHORT $LN24@GetResourc
$LN23@GetResourc:

; 1235 : 			{
; 1236 : 				iResourceQuantity = min(max(5,GetPlayer()->getNumCities()), iResourceQuantity);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR $T225530[ebp], eax
	mov	DWORD PTR $T225531[ebp], 5
	mov	edx, DWORD PTR $T225531[ebp]
	cmp	edx, DWORD PTR $T225530[ebp]
	jge	SHORT $LN46@GetResourc
	lea	eax, DWORD PTR $T225530[ebp]
	mov	DWORD PTR tv209[ebp], eax
	jmp	SHORT $LN47@GetResourc
$LN46@GetResourc:
	lea	ecx, DWORD PTR $T225531[ebp]
	mov	DWORD PTR tv209[ebp], ecx
$LN47@GetResourc:
	mov	edx, DWORD PTR tv209[ebp]
	mov	DWORD PTR $T225557[ebp], edx
	mov	eax, DWORD PTR $T225557[ebp]
	mov	ecx, DWORD PTR _iResourceQuantity$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN50@GetResourc
	lea	edx, DWORD PTR _iResourceQuantity$[ebp]
	mov	DWORD PTR tv163[ebp], edx
	jmp	SHORT $LN51@GetResourc
$LN50@GetResourc:
	mov	eax, DWORD PTR $T225557[ebp]
	mov	DWORD PTR tv163[ebp], eax
$LN51@GetResourc:
	mov	ecx, DWORD PTR tv163[ebp]
	mov	DWORD PTR $T225566[ebp], ecx
	mov	edx, DWORD PTR $T225566[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iResourceQuantity$[ebp], eax
$LN24@GetResourc:

; 1237 : 			}
; 1238 : 		}
; 1239 : 		if(!GET_TEAM(GetPlayer()->getTeam()).IsResourceObsolete(eResource))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225577[ebp], eax
	mov	ecx, DWORD PTR $T225577[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225578[ebp], eax
	mov	eax, DWORD PTR $T225578[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225582[ebp], eax
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225582[ebp]
	call	?IsResourceObsolete@CvTeam@@QAE_NW4ResourceTypes@@@Z ; CvTeam::IsResourceObsolete
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN21@GetResourc

; 1240 : 		{
; 1241 : 			iItemValue += (iResourceQuantity * iNumTurns * 150 / 100);	// Ex: 5 Iron for 30 turns * 2 = value of 300

	mov	eax, DWORD PTR _iResourceQuantity$[ebp]
	imul	eax, DWORD PTR _iNumTurns$[ebp]
	imul	eax, 150				; 00000096H
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1242 : 		}
; 1243 : 		else

	jmp	SHORT $LN26@GetResourc
$LN21@GetResourc:

; 1244 : 		{
; 1245 : 			iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0
$LN26@GetResourc:

; 1246 : 		}
; 1247 : 	}
; 1248 : 
; 1249 : 	// Increase value if it's from us and we don't like the guy
; 1250 : 	if(bFromMe)

	movzx	edx, BYTE PTR _bFromMe$[ebp]
	test	edx, edx
	je	$LN19@GetResourc

; 1251 : 	{
; 1252 : 		int iModifier = 0;

	mov	DWORD PTR _iModifier$221991[ebp], 0

; 1253 : 
; 1254 : 		// Opinion also matters
; 1255 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR tv189[ebp], eax
	cmp	DWORD PTR tv189[ebp], 6
	ja	SHORT $LN9@GetResourc
	mov	ecx, DWORD PTR tv189[ebp]
	jmp	DWORD PTR $LN58@GetResourc[ecx*4]
$LN16@GetResourc:

; 1256 : 		{
; 1257 : 		case MAJOR_CIV_OPINION_ALLY:
; 1258 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221991[ebp], 100	; 00000064H

; 1259 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN15@GetResourc:

; 1260 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1261 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221991[ebp], 100	; 00000064H

; 1262 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN14@GetResourc:

; 1263 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1264 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221991[ebp], 100	; 00000064H

; 1265 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN13@GetResourc:

; 1266 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1267 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221991[ebp], 100	; 00000064H

; 1268 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN12@GetResourc:

; 1269 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1270 : 			iModifier = 175;

	mov	DWORD PTR _iModifier$221991[ebp], 175	; 000000afH

; 1271 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN11@GetResourc:

; 1272 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1273 : 			iModifier = 400;

	mov	DWORD PTR _iModifier$221991[ebp], 400	; 00000190H

; 1274 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN10@GetResourc:

; 1275 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1276 : 			iModifier = 1000;

	mov	DWORD PTR _iModifier$221991[ebp], 1000	; 000003e8H

; 1277 : 			break;

	jmp	SHORT $LN17@GetResourc
$LN9@GetResourc:

; 1278 : 		default:
; 1279 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Resource valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1280 : 			iModifier = 100;

	mov	DWORD PTR _iModifier$221991[ebp], 100	; 00000064H
$LN17@GetResourc:

; 1281 : 			break;
; 1282 : 		}
; 1283 : 
; 1284 : 		// Approach is important
; 1285 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	push	1
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR tv199[ebp]
	sub	eax, 1
	mov	DWORD PTR tv199[ebp], eax
	cmp	DWORD PTR tv199[ebp], 5
	ja	SHORT $LN1@GetResourc
	mov	ecx, DWORD PTR tv199[ebp]
	jmp	DWORD PTR $LN59@GetResourc[ecx*4]
$LN6@GetResourc:

; 1286 : 		{
; 1287 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1288 : 			iModifier += 300;

	mov	edx, DWORD PTR _iModifier$221991[ebp]
	add	edx, 300				; 0000012cH
	mov	DWORD PTR _iModifier$221991[ebp], edx

; 1289 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN5@GetResourc:

; 1290 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1291 : 			iModifier += 150;

	mov	eax, DWORD PTR _iModifier$221991[ebp]
	add	eax, 150				; 00000096H
	mov	DWORD PTR _iModifier$221991[ebp], eax

; 1292 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN4@GetResourc:

; 1293 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1294 : 			iModifier = 200;	// Forced value

	mov	DWORD PTR _iModifier$221991[ebp], 200	; 000000c8H

; 1295 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN3@GetResourc:

; 1296 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1297 : 			iModifier = 200;	// Forced value

	mov	DWORD PTR _iModifier$221991[ebp], 200	; 000000c8H

; 1298 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN2@GetResourc:

; 1299 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1300 : 			iModifier += 100;

	mov	ecx, DWORD PTR _iModifier$221991[ebp]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _iModifier$221991[ebp], ecx

; 1301 : 			break;

	jmp	SHORT $LN7@GetResourc
$LN1@GetResourc:

; 1302 : 		default:
; 1303 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Resource valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1304 : 			iModifier += 100;

	mov	edx, DWORD PTR _iModifier$221991[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _iModifier$221991[ebp], edx
$LN7@GetResourc:

; 1305 : 			break;
; 1306 : 		}
; 1307 : 
; 1308 : 		iItemValue *= iModifier;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, DWORD PTR _iModifier$221991[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1309 : 		iItemValue /= 200;	// 200 because we've added two mods together

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 200				; 000000c8H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN19@GetResourc:

; 1310 : 	}
; 1311 : 
; 1312 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]
$LN34@GetResourc:

; 1313 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN58@GetResourc:
	DD	$LN10@GetResourc
	DD	$LN11@GetResourc
	DD	$LN12@GetResourc
	DD	$LN13@GetResourc
	DD	$LN14@GetResourc
	DD	$LN15@GetResourc
	DD	$LN16@GetResourc
$LN59@GetResourc:
	DD	$LN6@GetResourc
	DD	$LN1@GetResourc
	DD	$LN5@GetResourc
	DD	$LN4@GetResourc
	DD	$LN3@GetResourc
	DD	$LN2@GetResourc
?GetResourceValue@CvDealAI@@QAEHW4ResourceTypes@@HH_NW4PlayerTypes@@@Z ENDP ; CvDealAI::GetResourceValue
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
EXTRN	?IsOriginalMajorCapital@CvCity@@QBE_NXZ:PROC	; CvCity::IsOriginalMajorCapital
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetWarProjection
EXTRN	?hasActiveWorldWonder@CvCity@@QBE_NXZ:PROC	; CvCity::hasActiveWorldWonder
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getMaxTurns@CvGame@@QBEHXZ:PROC		; CvGame::getMaxTurns
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getNonObsoleteResourceType
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?GetCityPurchaseID@CvPlot@@QAEHXZ:PROC		; CvPlot::GetCityPurchaseID
EXTRN	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z:PROC ; CvCityCitizens::GetCityPlotFromIndex
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?GetBuyPlotCost@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetBuyPlotCost
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
; Function compile flags: /Odtp
;	COMDAT ?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv284 = -316						; size = 4
tv280 = -312						; size = 4
tv207 = -308						; size = 4
tv161 = -304						; size = 4
tv400 = -300						; size = 4
tv378 = -296						; size = 4
_this$ = -292						; size = 4
$T225861 = -288						; size = 4
$T225857 = -284						; size = 4
$T225856 = -280						; size = 4
$T225762 = -196						; size = 4
$T225753 = -192						; size = 4
$T225744 = -188						; size = 4
$T225743 = -184						; size = 4
$T225739 = -180						; size = 4
$T225727 = -176						; size = 4
$T225726 = -172						; size = 4
$T225722 = -168						; size = 4
$T225713 = -164						; size = 4
$T225707 = -160						; size = 4
$T225698 = -156						; size = 4
$T225691 = -152						; size = 4
$T225687 = -148						; size = 4
$T225683 = -144						; size = 4
$T225682 = -140						; size = 4
$T225673 = -136						; size = 4
$T225659 = -128						; size = 4
$T225628 = -124						; size = 4
$T225623 = -120						; size = 4
$T225619 = -113						; size = 1
$T225608 = -112						; size = 4
$T225604 = -105						; size = 1
_iMapY$225658 = -104					; size = 4
_iMapX$225657 = -100					; size = 4
$T225597 = -96						; size = 4
$T225589 = -92						; size = 4
$T225588 = -88						; size = 4
$T225587 = -84						; size = 4
_iDistFromThisCity$222078 = -80				; size = 4
_iBestDistance$222074 = -76				; size = 4
_iCityLoop$222073 = -72					; size = 4
_pLoopCity$222072 = -68					; size = 4
_theOtherPlayer$222069 = -64				; size = 4
_iNumTurns$222053 = -60					; size = 4
_iHappinessFromResource$222048 = -56			; size = 4
_iNumTurns$222044 = -52					; size = 4
_iResourceQuantity$222042 = -48				; size = 4
_eUsage$222041 = -44					; size = 4
_pkResourceInfo$222039 = -40				; size = 4
_eResource$222037 = -36					; size = 4
_pLoopPlot$222033 = -32					; size = 4
_iI$222029 = -28					; size = 4
_iGoldValueOfImprovedPlots$222027 = -24			; size = 4
_iGoldValueOfPlots$222026 = -20				; size = 4
_iGoldValueOfResourcePlots$222028 = -16			; size = 4
_goldPerPlot$222025 = -12				; size = 4
_pCity$ = -8						; size = 4
_iItemValue$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_bFromMe$ = 16						; size = 1
_eOtherPlayer$ = 20					; size = 4
_bUseEvenValue$ = 24					; size = 1
?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z PROC	; CvDealAI::GetCityValue, COMDAT
; _this$ = ecx

; 1317 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of City with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1319 : 
; 1320 : 	int iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 1321 : 
; 1322 : 	CvCity* pCity = GC.getMap().plot(iX, iY)->getPlotCity();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225597[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN44@GetCityVal
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN45@GetCityVal
$LN44@GetCityVal:
	mov	DWORD PTR $T225659[ebp], 0
	jmp	$LN46@GetCityVal
$LN45@GetCityVal:
	mov	ecx, DWORD PTR $T225597[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T225604[ebp], dl
	mov	eax, DWORD PTR $T225597[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225608[ebp], ecx
	movzx	edx, BYTE PTR $T225604[ebp]
	test	edx, edx
	je	SHORT $LN57@GetCityVal
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN56@GetCityVal
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T225608[ebp]
	add	edx, DWORD PTR $T225608[ebp]
	mov	DWORD PTR _iMapX$225657[ebp], edx
	jmp	SHORT $LN58@GetCityVal
	jmp	SHORT $LN57@GetCityVal
$LN56@GetCityVal:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T225608[ebp]
	jl	SHORT $LN57@GetCityVal
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T225608[ebp]
	mov	DWORD PTR _iMapX$225657[ebp], edx
	jmp	SHORT $LN58@GetCityVal
$LN57@GetCityVal:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$225657[ebp], ecx
$LN58@GetCityVal:
	mov	edx, DWORD PTR $T225597[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T225619[ebp], al
	mov	ecx, DWORD PTR $T225597[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T225623[ebp], edx
	movzx	eax, BYTE PTR $T225619[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225623[ebp]
	push	ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$225658[ebp], eax
	mov	eax, DWORD PTR _iMapY$225658[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$225657[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225597[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN48@GetCityVal
	mov	edx, DWORD PTR $T225597[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T225628[ebp], eax
	mov	ecx, DWORD PTR _iMapY$225658[ebp]
	imul	ecx, DWORD PTR $T225628[ebp]
	add	ecx, DWORD PTR _iMapX$225657[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T225597[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv378[ebp], ecx
	jmp	SHORT $LN49@GetCityVal
$LN48@GetCityVal:
	mov	DWORD PTR tv378[ebp], 0
$LN49@GetCityVal:
	mov	eax, DWORD PTR tv378[ebp]
	mov	DWORD PTR $T225659[ebp], eax
$LN46@GetCityVal:
	mov	ecx, DWORD PTR $T225659[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 1323 : 
; 1324 : 	if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN35@GetCityVal

; 1325 : 	{
; 1326 : 		iItemValue = 440 + (pCity->getPopulation() * 200);

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, 200				; 000000c8H
	add	eax, 440				; 000001b8H
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1327 : 
; 1328 : 		// add in the value of every plot this city owns (plus improvements and resources)
; 1329 : 		// okay, I'm only going to count in the 3-rings plots since we can't actually use any others (I realize there may be a resource way out there)
; 1330 : 
; 1331 : 		int goldPerPlot = GetPlayer()->GetBuyPlotCost(); // this is how much ANY plot is worth to me right now

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetBuyPlotCost@CvPlayer@@QBEHXZ	; CvPlayer::GetBuyPlotCost
	mov	DWORD PTR _goldPerPlot$222025[ebp], eax

; 1332 : 
; 1333 : 		int iGoldValueOfPlots = 0;

	mov	DWORD PTR _iGoldValueOfPlots$222026[ebp], 0

; 1334 : 		int iGoldValueOfImprovedPlots = 0;

	mov	DWORD PTR _iGoldValueOfImprovedPlots$222027[ebp], 0

; 1335 : 		int iGoldValueOfResourcePlots = 0;

	mov	DWORD PTR _iGoldValueOfResourcePlots$222028[ebp], 0

; 1336 : 		for(int iI = 0; iI < NUM_CITY_PLOTS; iI++)

	mov	DWORD PTR _iI$222029[ebp], 0
	jmp	SHORT $LN34@GetCityVal
$LN33@GetCityVal:
	mov	ecx, DWORD PTR _iI$222029[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$222029[ebp], ecx
$LN34@GetCityVal:
	cmp	DWORD PTR _iI$222029[ebp], 37		; 00000025H
	jge	$LN32@GetCityVal

; 1337 : 		{
; 1338 : 			CvPlot* pLoopPlot = pCity->GetCityCitizens()->GetCityPlotFromIndex(iI);

	mov	edx, DWORD PTR _iI$222029[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?GetCityPlotFromIndex@CvCityCitizens@@QBEPAVCvPlot@@H@Z ; CvCityCitizens::GetCityPlotFromIndex
	mov	DWORD PTR _pLoopPlot$222033[ebp], eax

; 1339 : 			if(NULL != pLoopPlot && pCity->GetID() == pLoopPlot->GetCityPurchaseID())

	cmp	DWORD PTR _pLoopPlot$222033[ebp], 0
	je	$LN31@GetCityVal
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR $T225673[ebp], ecx
	mov	ecx, DWORD PTR _pLoopPlot$222033[ebp]
	call	?GetCityPurchaseID@CvPlot@@QAEHXZ	; CvPlot::GetCityPurchaseID
	cmp	DWORD PTR $T225673[ebp], eax
	jne	$LN31@GetCityVal

; 1340 : 			{
; 1341 : 				if(iI > 6)

	cmp	DWORD PTR _iI$222029[ebp], 6
	jle	SHORT $LN30@GetCityVal

; 1342 : 				{
; 1343 : 					iGoldValueOfPlots += goldPerPlot; // this is a bargain, but at least it's in the ballpark

	mov	edx, DWORD PTR _iGoldValueOfPlots$222026[ebp]
	add	edx, DWORD PTR _goldPerPlot$222025[ebp]
	mov	DWORD PTR _iGoldValueOfPlots$222026[ebp], edx
$LN30@GetCityVal:

; 1344 : 				}
; 1345 : 				if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pLoopPlot$222033[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN29@GetCityVal

; 1346 : 				{
; 1347 : 					iGoldValueOfImprovedPlots += goldPerPlot * 25;

	mov	eax, DWORD PTR _goldPerPlot$222025[ebp]
	imul	eax, 25					; 00000019H
	add	eax, DWORD PTR _iGoldValueOfImprovedPlots$222027[ebp]
	mov	DWORD PTR _iGoldValueOfImprovedPlots$222027[ebp], eax
$LN29@GetCityVal:

; 1348 : 				}
; 1349 : 				ResourceTypes eResource = pLoopPlot->getNonObsoleteResourceType(GetPlayer()->getTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225682[ebp], eax
	mov	ecx, DWORD PTR $T225682[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225683[ebp], eax
	mov	eax, DWORD PTR $T225683[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$222033[ebp]
	call	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
	mov	DWORD PTR _eResource$222037[ebp], eax

; 1350 : 				if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$222037[ebp], -1
	je	$LN31@GetCityVal

; 1351 : 				{
; 1352 : 					const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	ecx, DWORD PTR _eResource$222037[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$222039[ebp], eax

; 1353 : 					if (pkResourceInfo)

	cmp	DWORD PTR _pkResourceInfo$222039[ebp], 0
	je	$LN31@GetCityVal

; 1354 : 					{
; 1355 : 						ResourceUsageTypes eUsage = pkResourceInfo->getResourceUsage();

	mov	ecx, DWORD PTR _pkResourceInfo$222039[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eUsage$222041[ebp], eax

; 1356 : 						int iResourceQuantity = pLoopPlot->getNumResource();

	mov	ecx, DWORD PTR _pLoopPlot$222033[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	DWORD PTR _iResourceQuantity$222042[ebp], eax

; 1357 : 						// Luxury Resource
; 1358 : 						if(eUsage == RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _eUsage$222041[ebp], 2
	jne	$LN26@GetCityVal

; 1359 : 						{
; 1360 : #ifdef AUI_WARNING_FIXES
; 1361 : 							int iNumTurns = MIN(1, GC.getGame().getMaxTurns() - GC.getGame().getGameTurn());
; 1362 : 							iNumTurns = MAX(120, iNumTurns); // let's not go hog wild here
; 1363 : #else
; 1364 : 							int iNumTurns = min(1,GC.getGame().getMaxTurns() - GC.getGame().getGameTurn());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225687[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225691[ebp], eax
	mov	ecx, DWORD PTR $T225687[ebp]
	call	?getMaxTurns@CvGame@@QBEHXZ		; CvGame::getMaxTurns
	mov	esi, eax
	mov	ecx, DWORD PTR $T225691[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	esi, eax
	mov	DWORD PTR $T225587[ebp], esi
	mov	DWORD PTR $T225588[ebp], 1
	mov	ecx, DWORD PTR $T225587[ebp]
	cmp	ecx, DWORD PTR $T225588[ebp]
	jge	SHORT $LN87@GetCityVal
	lea	edx, DWORD PTR $T225587[ebp]
	mov	DWORD PTR tv400[ebp], edx
	jmp	SHORT $LN88@GetCityVal
$LN87@GetCityVal:
	lea	eax, DWORD PTR $T225588[ebp]
	mov	DWORD PTR tv400[ebp], eax
$LN88@GetCityVal:
	mov	ecx, DWORD PTR tv400[ebp]
	mov	DWORD PTR $T225698[ebp], ecx
	mov	edx, DWORD PTR $T225698[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iNumTurns$222044[ebp], eax

; 1365 : 							iNumTurns = max(120,iNumTurns); // let's not go hog wild here

	mov	DWORD PTR $T225589[ebp], 120		; 00000078H
	mov	ecx, DWORD PTR $T225589[ebp]
	cmp	ecx, DWORD PTR _iNumTurns$222044[ebp]
	jge	SHORT $LN91@GetCityVal
	lea	edx, DWORD PTR _iNumTurns$222044[ebp]
	mov	DWORD PTR tv161[ebp], edx
	jmp	SHORT $LN92@GetCityVal
$LN91@GetCityVal:
	lea	eax, DWORD PTR $T225589[ebp]
	mov	DWORD PTR tv161[ebp], eax
$LN92@GetCityVal:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T225707[ebp], ecx
	mov	edx, DWORD PTR $T225707[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iNumTurns$222044[ebp], eax

; 1366 : #endif
; 1367 : 							int iHappinessFromResource = pkResourceInfo->getHappiness();

	mov	ecx, DWORD PTR _pkResourceInfo$222039[ebp]
	call	?getHappiness@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getHappiness
	mov	DWORD PTR _iHappinessFromResource$222048[ebp], eax

; 1368 : 							iGoldValueOfResourcePlots += (iResourceQuantity * iHappinessFromResource * iNumTurns * 2);	// Ex: 1 Silk for 4 Happiness * 30 turns * 2 = 240

	mov	ecx, DWORD PTR _iResourceQuantity$222042[ebp]
	imul	ecx, DWORD PTR _iHappinessFromResource$222048[ebp]
	imul	ecx, DWORD PTR _iNumTurns$222044[ebp]
	mov	edx, DWORD PTR _iGoldValueOfResourcePlots$222028[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _iGoldValueOfResourcePlots$222028[ebp], eax

; 1369 : 							// If we only have 1 of a Luxury then we value it much more
; 1370 : 							if(bFromMe)

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	je	SHORT $LN25@GetCityVal

; 1371 : 							{
; 1372 : 								if(GetPlayer()->getNumResourceAvailable(eResource) == 1)

	push	1
	mov	edx, DWORD PTR _eResource$222037[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	cmp	eax, 1
	jne	SHORT $LN25@GetCityVal

; 1373 : 								{
; 1374 : 									iGoldValueOfResourcePlots += (iResourceQuantity * iHappinessFromResource * iNumTurns * 4);

	mov	eax, DWORD PTR _iResourceQuantity$222042[ebp]
	imul	eax, DWORD PTR _iHappinessFromResource$222048[ebp]
	imul	eax, DWORD PTR _iNumTurns$222044[ebp]
	mov	ecx, DWORD PTR _iGoldValueOfResourcePlots$222028[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _iGoldValueOfResourcePlots$222028[ebp], edx
$LN25@GetCityVal:

; 1375 : 								}
; 1376 : 							}
; 1377 : 						}

	jmp	SHORT $LN31@GetCityVal
$LN26@GetCityVal:

; 1378 : 						// Strategic Resource
; 1379 : 						else if(eUsage == RESOURCEUSAGE_STRATEGIC)

	cmp	DWORD PTR _eUsage$222041[ebp], 1
	jne	SHORT $LN31@GetCityVal

; 1380 : 						{
; 1381 : 							int iNumTurns = 60; // okay, this is a reasonable estimate

	mov	DWORD PTR _iNumTurns$222053[ebp], 60	; 0000003cH

; 1382 : 							iGoldValueOfResourcePlots += (iResourceQuantity * iNumTurns * 150 / 100);

	mov	eax, DWORD PTR _iResourceQuantity$222042[ebp]
	imul	eax, DWORD PTR _iNumTurns$222053[ebp]
	imul	eax, 150				; 00000096H
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _iGoldValueOfResourcePlots$222028[ebp]
	mov	DWORD PTR _iGoldValueOfResourcePlots$222028[ebp], eax
$LN31@GetCityVal:

; 1383 : 						}
; 1384 : 					}
; 1385 : 				}
; 1386 : 			}
; 1387 : 		}

	jmp	$LN33@GetCityVal
$LN32@GetCityVal:

; 1388 : 		iGoldValueOfImprovedPlots /= 100;

	mov	eax, DWORD PTR _iGoldValueOfImprovedPlots$222027[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGoldValueOfImprovedPlots$222027[ebp], eax

; 1389 : 
; 1390 : 		iItemValue = iItemValue + iGoldValueOfPlots + iGoldValueOfImprovedPlots + iGoldValueOfResourcePlots;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	add	edx, DWORD PTR _iGoldValueOfPlots$222026[ebp]
	add	edx, DWORD PTR _iGoldValueOfImprovedPlots$222027[ebp]
	add	edx, DWORD PTR _iGoldValueOfResourcePlots$222028[ebp]
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1391 : 
; 1392 : 		// add in the (gold) value of the buildings (Or should we?  Will they transfer?)
; 1393 : 
; 1394 : 		// From this player - add extra weight (don't want the human giving the AI a bit of gold for good cities)
; 1395 : 		if(bFromMe)

	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	je	$LN101@GetCityVal

; 1396 : 		{
; 1397 : 			// Wonders are nice
; 1398 : 			if(pCity->hasActiveWorldWonder())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?hasActiveWorldWonder@CvCity@@QBE_NXZ	; CvCity::hasActiveWorldWonder
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@GetCityVal

; 1399 : 				iItemValue *= 2;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	shl	edx, 1
	mov	DWORD PTR _iItemValue$[ebp], edx
$LN20@GetCityVal:

; 1400 : 
; 1401 : 			// Adjust for how well a war against this player would go (or is going)
; 1402 : 			switch(GetPlayer()->GetDiplomacyAI()->GetWarProjection(eOtherPlayer))

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection
	mov	DWORD PTR tv207[ebp], eax
	cmp	DWORD PTR tv207[ebp], 5
	ja	SHORT $LN11@GetCityVal
	mov	ecx, DWORD PTR tv207[ebp]
	jmp	DWORD PTR $LN181@GetCityVal[ecx*4]
$LN17@GetCityVal:

; 1403 : 			{
; 1404 : 			case WAR_PROJECTION_DESTRUCTION:
; 1405 : 				iItemValue *= 100;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1406 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN16@GetCityVal:

; 1407 : 			case WAR_PROJECTION_DEFEAT:
; 1408 : 				iItemValue *= 180;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 180				; 000000b4H
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1409 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN15@GetCityVal:

; 1410 : 			case WAR_PROJECTION_STALEMATE:
; 1411 : 				iItemValue *= 220;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 220				; 000000dcH
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1412 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN14@GetCityVal:

; 1413 : 			case WAR_PROJECTION_UNKNOWN:
; 1414 : 				iItemValue *= 250;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 250				; 000000faH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1415 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN13@GetCityVal:

; 1416 : 			case WAR_PROJECTION_GOOD:
; 1417 : 				iItemValue *= 400;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 400				; 00000190H
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1418 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN12@GetCityVal:

; 1419 : 			case WAR_PROJECTION_VERY_GOOD:
; 1420 : 				iItemValue *= 400;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 400				; 00000190H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1421 : 				break;

	jmp	SHORT $LN18@GetCityVal
$LN11@GetCityVal:

; 1422 : 			default:
; 1423 : 				CvAssertMsg(false, "DEAL_AI: AI player has no valid War Projection for City valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1424 : 				iItemValue *= 300;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 300				; 0000012cH
	mov	DWORD PTR _iItemValue$[ebp], edx
$LN18@GetCityVal:

; 1425 : 				break;
; 1426 : 			}
; 1427 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1428 : 
; 1429 : 			// AI players should be less willing to trade cities when not at war
; 1430 : 			if(!GET_TEAM(GetTeam()).isAtWar(GET_PLAYER(eOtherPlayer).getTeam()))

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225713[ebp], edx
	mov	eax, DWORD PTR $T225713[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225722[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ	; CvDealAI::GetTeam
	mov	DWORD PTR $T225726[ebp], eax
	mov	edx, DWORD PTR $T225726[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225727[ebp], edx
	mov	eax, DWORD PTR $T225722[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225727[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@GetCityVal

; 1431 : 			{
; 1432 : 				iItemValue *= 2;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	shl	edx, 1
	mov	DWORD PTR _iItemValue$[ebp], edx
$LN10@GetCityVal:

; 1433 : 			}
; 1434 : 
; 1435 : 		}	// END bFromMe
; 1436 : 		else

	jmp	$LN9@GetCityVal

; 1437 : 		{
; 1438 : 			CvPlayerAI& theOtherPlayer = GET_PLAYER(eOtherPlayer);

$LN101@GetCityVal:
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _theOtherPlayer$222069[ebp], eax

; 1439 : 			if(!GET_TEAM(GetTeam()).isAtWar(theOtherPlayer.getTeam()))

	mov	ecx, DWORD PTR _theOtherPlayer$222069[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225739[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ	; CvDealAI::GetTeam
	mov	DWORD PTR $T225743[ebp], eax
	mov	eax, DWORD PTR $T225743[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225744[ebp], eax
	mov	ecx, DWORD PTR $T225739[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225744[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	jne	$LN9@GetCityVal

; 1440 : 			{
; 1441 : 				if(theOtherPlayer.isHuman())  // he is obviously trying to trick us

	mov	ecx, DWORD PTR _theOtherPlayer$222069[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	$LN9@GetCityVal

; 1442 : 				{
; 1443 : 					CvCity* pLoopCity;
; 1444 : 					int iCityLoop;
; 1445 : 					int iBestDistance = 99;

	mov	DWORD PTR _iBestDistance$222074[ebp], 99 ; 00000063H

; 1446 : 					for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$222073[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$222072[ebp], eax
	jmp	SHORT $LN6@GetCityVal
$LN5@GetCityVal:
	push	0
	lea	eax, DWORD PTR _iCityLoop$222073[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$222072[ebp], eax
$LN6@GetCityVal:
	cmp	DWORD PTR _pLoopCity$222072[ebp], 0
	je	SHORT $LN4@GetCityVal

; 1447 : 					{
; 1448 : 						int iDistFromThisCity = plotDistance(iX, iY, pLoopCity->getX(), pLoopCity->getY());

	mov	edx, DWORD PTR _pLoopCity$222072[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T225753[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$222072[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T225762[ebp], edx
	mov	eax, DWORD PTR $T225753[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225762[ebp]
	push	ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistFromThisCity$222078[ebp], eax

; 1449 : 						if(iDistFromThisCity < iBestDistance)

	mov	ecx, DWORD PTR _iDistFromThisCity$222078[ebp]
	cmp	ecx, DWORD PTR _iBestDistance$222074[ebp]
	jge	SHORT $LN3@GetCityVal

; 1450 : 						{
; 1451 : 							iBestDistance = iDistFromThisCity;

	mov	edx, DWORD PTR _iDistFromThisCity$222078[ebp]
	mov	DWORD PTR _iBestDistance$222074[ebp], edx
$LN3@GetCityVal:

; 1452 : 						}
; 1453 : 					}

	jmp	SHORT $LN5@GetCityVal
$LN4@GetCityVal:

; 1454 : 					iBestDistance = (iBestDistance > 4) ? iBestDistance : 5;

	cmp	DWORD PTR _iBestDistance$222074[ebp], 4
	jle	SHORT $LN38@GetCityVal
	mov	eax, DWORD PTR _iBestDistance$222074[ebp]
	mov	DWORD PTR tv280[ebp], eax
	jmp	SHORT $LN39@GetCityVal
$LN38@GetCityVal:
	mov	DWORD PTR tv280[ebp], 5
$LN39@GetCityVal:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR _iBestDistance$222074[ebp], ecx

; 1455 : 					iItemValue /= iBestDistance - 4;

	mov	ecx, DWORD PTR _iBestDistance$222074[ebp]
	sub	ecx, 4
	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1456 : 					iItemValue = (iItemValue >= 100) ? iItemValue : 100;

	cmp	DWORD PTR _iItemValue$[ebp], 100	; 00000064H
	jl	SHORT $LN40@GetCityVal
	mov	edx, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR tv284[ebp], edx
	jmp	SHORT $LN41@GetCityVal
$LN40@GetCityVal:
	mov	DWORD PTR tv284[ebp], 100		; 00000064H
$LN41@GetCityVal:
	mov	eax, DWORD PTR tv284[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN9@GetCityVal:

; 1457 : 				}
; 1458 : 			}
; 1459 : 		}
; 1460 : 
; 1461 : 		// slewis - Due to rule changes, value of major capitals should go up quite a bit because someone can win the game by owning them
; 1462 : 		if (pCity->IsOriginalMajorCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsOriginalMajorCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalMajorCapital
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@GetCityVal

; 1463 : 		{
; 1464 : 			iItemValue *= 2;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	shl	edx, 1
	mov	DWORD PTR _iItemValue$[ebp], edx
$LN35@GetCityVal:

; 1465 : 		}
; 1466 : 	}
; 1467 : 
; 1468 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1469 : 	if(bUseEvenValue)

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	test	eax, eax
	je	SHORT $LN1@GetCityVal

; 1470 : 	{
; 1471 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetCityValue(iX, iY, !bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T225856[ebp], eax
	mov	ecx, DWORD PTR $T225856[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T225857[ebp], edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225861[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T225857[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bFromMe$[ebp]
	test	edx, edx
	sete	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225861[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1472 : 
; 1473 : 		iItemValue /= 2;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN1@GetCityVal:

; 1474 : 	}
; 1475 : 
; 1476 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]

; 1477 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN181@GetCityVal:
	DD	$LN17@GetCityVal
	DD	$LN16@GetCityVal
	DD	$LN15@GetCityVal
	DD	$LN14@GetCityVal
	DD	$LN13@GetCityVal
	DD	$LN12@GetCityVal
?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ENDP	; CvDealAI::GetCityValue
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T225946 = -80						; size = 4
$T225919 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T225919[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T225919[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T225919[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T225946[ebp], edx
	mov	eax, DWORD PTR $T225946[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T225969 = -16						; size = 4
$T225961 = -12						; size = 4
$T225957 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T225957[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225961[ebp], ecx
	movzx	edx, BYTE PTR $T225957[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T225961[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T225961[ebp]
	mov	DWORD PTR $T225969[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T225961[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T225961[ebp]
	mov	DWORD PTR $T225969[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T225969[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T225969[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T225990 = -16						; size = 4
$T225982 = -12						; size = 4
$T225978 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T225978[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T225982[ebp], ecx
	movzx	edx, BYTE PTR $T225978[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T225982[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T225982[ebp]
	mov	DWORD PTR $T225990[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T225982[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T225982[ebp]
	mov	DWORD PTR $T225990[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T225990[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T225990[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
EXTRN	?GetDealDuration@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::GetDealDuration
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z:PROC ; CvGlobals::getGameSpeedInfo
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
;	COMDAT ?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
_this$ = -32						; size = 4
$T226014 = -28						; size = 4
$T226010 = -24						; size = 4
$T226009 = -20						; size = 4
$T226000 = -16						; size = 4
$T225996 = -12						; size = 4
_pkStdSpeedInfo$ = -8					; size = 4
_iItemValue$ = -4					; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetEmbassyValue, COMDAT
; _this$ = ecx

; 1481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1482 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Embassy with oneself.  Please send slewis this with your last 5 autosaves and what changelist # you're playing.");
; 1483 : 
; 1484 : 	int iItemValue = 35;

	mov	DWORD PTR _iItemValue$[ebp], 35		; 00000023H

; 1485 : 
; 1486 : 	// Scale up or down by deal duration at this game speed
; 1487 : 	CvGameSpeedInfo *pkStdSpeedInfo = GC.getGameSpeedInfo((GameSpeedTypes)GC.getSTANDARD_GAMESPEED());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8464
	mov	DWORD PTR $T225996[ebp], eax
	mov	ecx, DWORD PTR $T225996[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo
	mov	DWORD PTR _pkStdSpeedInfo$[ebp], eax

; 1488 : 	if (pkStdSpeedInfo)

	cmp	DWORD PTR _pkStdSpeedInfo$[ebp], 0
	je	SHORT $LN11@GetEmbassy

; 1489 : 	{
; 1490 : 		iItemValue *= GC.getGame().getGameSpeedInfo().GetDealDuration();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226000[ebp], edx
	mov	ecx, DWORD PTR $T226000[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?GetDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::GetDealDuration
	imul	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1491 : 		iItemValue /= pkStdSpeedInfo->GetDealDuration();

	mov	ecx, DWORD PTR _pkStdSpeedInfo$[ebp]
	call	?GetDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::GetDealDuration
	mov	ecx, eax
	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN11@GetEmbassy:

; 1492 : 	}
; 1493 : 
; 1494 : 	if(bFromMe)  // giving the other player an embassy in my capital

	movzx	edx, BYTE PTR _bFromMe$[ebp]
	test	edx, edx
	je	$LN10@GetEmbassy

; 1495 : 	{
; 1496 : 		// Approach is important
; 1497 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	push	1
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR tv90[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv90[ebp], ecx
	cmp	DWORD PTR tv90[ebp], 5
	ja	SHORT $LN2@GetEmbassy
	mov	edx, DWORD PTR tv90[ebp]
	jmp	DWORD PTR $LN24@GetEmbassy[edx*4]
$LN7@GetEmbassy:

; 1498 : 		{
; 1499 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1500 : 			iItemValue *= 250;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 250				; 000000faH
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1501 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN6@GetEmbassy:

; 1502 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1503 : 			iItemValue *= 130;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 130				; 00000082H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1504 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN5@GetEmbassy:

; 1505 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1506 : 			iItemValue *= 80;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 80					; 00000050H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1507 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN4@GetEmbassy:

; 1508 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1509 : 			iItemValue *= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1510 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN3@GetEmbassy:

; 1511 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1512 : 			iItemValue *= 100;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1513 : 			break;

	jmp	SHORT $LN8@GetEmbassy
$LN2@GetEmbassy:

; 1514 : 		default:
; 1515 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Research Agreement valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1516 : 			iItemValue *= 100;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], edx
$LN8@GetEmbassy:

; 1517 : 			break;
; 1518 : 		}
; 1519 : 		iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN10@GetEmbassy:

; 1520 : 	}
; 1521 : 
; 1522 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1523 : 	if(bUseEvenValue)

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetEmbassy

; 1524 : 	{
; 1525 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetTradeAgreementValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226009[ebp], eax
	mov	eax, DWORD PTR $T226009[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T226010[ebp], ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226014[ebp], edx
	push	0
	mov	eax, DWORD PTR $T226010[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR $T226014[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1526 : 
; 1527 : 		iItemValue /= 2;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN1@GetEmbassy:

; 1528 : 	}
; 1529 : 
; 1530 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]

; 1531 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN24@GetEmbassy:
	DD	$LN7@GetEmbassy
	DD	$LN2@GetEmbassy
	DD	$LN6@GetEmbassy
	DD	$LN5@GetEmbassy
	DD	$LN4@GetEmbassy
	DD	$LN3@GetEmbassy
?GetEmbassyValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetEmbassyValue
_TEXT	ENDS
PUBLIC	??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@	; `string'
EXTRN	?IsCramped@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsCramped
EXTRN	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceLevel
EXTRN	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetNumCivsInfluentialOn
EXTRN	?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetNumCivsToBeInfluentialOn
EXTRN	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z:PROC ; CvPlayerCulture::GetCivLowestInfluence
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlayerCulture::GetInfluenceOn
EXTRN	?GetTourism@CvPlayerCulture@@QAEHXZ:PROC	; CvPlayerCulture::GetTourism
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z:PROC ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?GetNumOurEnemiesPlayerAtWarWith@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetNumOurEnemiesPlayerAtWarWith
;	COMDAT ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@ DB 'AIGRANDSTRATEGY_CULTU'
	DB	'RE', 00H					; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
CONST	ENDS
;	COMDAT ?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv181 = -64						; size = 4
tv85 = -60						; size = 4
tv75 = -56						; size = 4
_this$ = -52						; size = 4
$T226048 = -48						; size = 4
$T226044 = -44						; size = 4
$T226043 = -40						; size = 4
$T226034 = -36						; size = 4
$T226030 = -32						; size = 4
$T226029 = -28						; size = 4
_eCultureStrategy$222157 = -24				; size = 4
_kOtherPlayer$222144 = -20				; size = 4
_iNumEnemiesAtWarWith$222136 = -16			; size = 4
_eCultureStrategy$222140 = -12				; size = 4
_iItemValue$ = -8					; size = 4
_eApproach$ = -4					; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetOpenBordersValue, COMDAT
; _this$ = ecx

; 1535 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of Open Borders with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1537 : 
; 1538 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true);

	push	1
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR _eApproach$[ebp], eax

; 1539 : 
; 1540 : 	// If we're friends, then OB is always equally valuable to both parties
; 1541 : 	if(eApproach == MAJOR_CIV_APPROACH_FRIENDLY)

	cmp	DWORD PTR _eApproach$[ebp], 5
	jne	SHORT $LN43@GetOpenBor

; 1542 : 		return 50;

	mov	eax, 50					; 00000032H
	jmp	$LN44@GetOpenBor
$LN43@GetOpenBor:

; 1543 : 
; 1544 : 	int iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 1545 : 
; 1546 : 	// Me giving Open Borders to the other guy
; 1547 : 	if(bFromMe)

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	je	$LN42@GetOpenBor

; 1548 : 	{
; 1549 : 		// Approach is important
; 1550 : 		switch(eApproach)

	mov	edx, DWORD PTR _eApproach$[ebp]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR tv75[ebp]
	sub	eax, 1
	mov	DWORD PTR tv75[ebp], eax
	cmp	DWORD PTR tv75[ebp], 5
	ja	SHORT $LN34@GetOpenBor
	mov	ecx, DWORD PTR tv75[ebp]
	jmp	DWORD PTR $LN60@GetOpenBor[ecx*4]
$LN39@GetOpenBor:

; 1551 : 		{
; 1552 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1553 : 			iItemValue = 1000;

	mov	DWORD PTR _iItemValue$[ebp], 1000	; 000003e8H

; 1554 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN38@GetOpenBor:

; 1555 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1556 : 			iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 1557 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN37@GetOpenBor:

; 1558 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1559 : 			iItemValue = 20;

	mov	DWORD PTR _iItemValue$[ebp], 20		; 00000014H

; 1560 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN36@GetOpenBor:

; 1561 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1562 : 			iItemValue = 50;

	mov	DWORD PTR _iItemValue$[ebp], 50		; 00000032H

; 1563 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN35@GetOpenBor:

; 1564 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1565 : 			iItemValue = 75;

	mov	DWORD PTR _iItemValue$[ebp], 75		; 0000004bH

; 1566 : 			break;

	jmp	SHORT $LN40@GetOpenBor
$LN34@GetOpenBor:

; 1567 : 		default:
; 1568 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Open Borders valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1569 : 			iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H
$LN40@GetOpenBor:

; 1570 : 			break;
; 1571 : 		}
; 1572 : 
; 1573 : 		// Opinion also matters
; 1574 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR tv85[ebp], eax
	cmp	DWORD PTR tv85[ebp], 6
	ja	$LN32@GetOpenBor
	mov	eax, DWORD PTR tv85[ebp]
	jmp	DWORD PTR $LN61@GetOpenBor[eax*4]
$LN31@GetOpenBor:

; 1575 : 		{
; 1576 : 		case MAJOR_CIV_OPINION_ALLY:
; 1577 : 			iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 1578 : 			break;

	jmp	SHORT $LN32@GetOpenBor
$LN30@GetOpenBor:

; 1579 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1580 : 			iItemValue *= 35;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 35					; 00000023H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1581 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1582 : 			break;

	jmp	SHORT $LN32@GetOpenBor
$LN29@GetOpenBor:

; 1583 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1584 : 			iItemValue *= 70;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 70					; 00000046H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1585 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1586 : 			break;

	jmp	SHORT $LN32@GetOpenBor

; 1587 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1588 : 			break;

	jmp	SHORT $LN32@GetOpenBor
$LN27@GetOpenBor:

; 1589 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1590 : 			iItemValue *= 150;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 150				; 00000096H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1591 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1592 : 			break;

	jmp	SHORT $LN32@GetOpenBor
$LN26@GetOpenBor:

; 1593 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1594 : 			iItemValue *= 400;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 400				; 00000190H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1595 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1596 : 			break;

	jmp	SHORT $LN32@GetOpenBor
$LN25@GetOpenBor:

; 1597 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1598 : 			iItemValue = 10000;

	mov	DWORD PTR _iItemValue$[ebp], 10000	; 00002710H
$LN32@GetOpenBor:

; 1599 : 			break;
; 1600 : 		default:
; 1601 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Open Borders valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1602 : 			break;
; 1603 : 		}
; 1604 : 
; 1605 : 		// If they're at war with our enemies then we're more likely to give them OB
; 1606 : 		int iNumEnemiesAtWarWith = GetPlayer()->GetDiplomacyAI()->GetNumOurEnemiesPlayerAtWarWith(eOtherPlayer);

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetNumOurEnemiesPlayerAtWarWith@CvDiplomacyAI@@QAEHW4PlayerTypes@@@Z ; CvDiplomacyAI::GetNumOurEnemiesPlayerAtWarWith
	mov	DWORD PTR _iNumEnemiesAtWarWith$222136[ebp], eax

; 1607 : 		if(iNumEnemiesAtWarWith >= 2)

	cmp	DWORD PTR _iNumEnemiesAtWarWith$222136[ebp], 2
	jl	SHORT $LN23@GetOpenBor

; 1608 : 		{
; 1609 : 			iItemValue *= 10;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1610 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN22@GetOpenBor
$LN23@GetOpenBor:

; 1611 : 		}
; 1612 : 		else if(iNumEnemiesAtWarWith == 1)

	cmp	DWORD PTR _iNumEnemiesAtWarWith$222136[ebp], 1
	jne	SHORT $LN22@GetOpenBor

; 1613 : 		{
; 1614 : 			iItemValue *= 25;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 25					; 00000019H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1615 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN22@GetOpenBor:

; 1616 : 		}
; 1617 : 
; 1618 : 		// Do we think he's going for culture victory?
; 1619 : 		AIGrandStrategyTypes eCultureStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eCultureStrategy$222140[ebp], eax

; 1620 : 		if (eCultureStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetGuessOtherPlayerActiveGrandStrategy(eOtherPlayer) == eCultureStrategy)

	cmp	DWORD PTR _eCultureStrategy$222140[ebp], -1
	je	$LN20@GetOpenBor
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetGuessOtherPlayerActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@W4PlayerTypes@@@Z ; CvGrandStrategyAI::GetGuessOtherPlayerActiveGrandStrategy
	cmp	eax, DWORD PTR _eCultureStrategy$222140[ebp]
	jne	SHORT $LN20@GetOpenBor

; 1621 : 		{
; 1622 : 			CvPlayer &kOtherPlayer = GET_PLAYER(eOtherPlayer);

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kOtherPlayer$222144[ebp], eax

; 1623 : 
; 1624 : 			// If he has tourism and he's not influential on us yet, resist!
; 1625 : 			if (kOtherPlayer.GetCulture()->GetTourism() > 0 && kOtherPlayer.GetCulture()->GetInfluenceOn(GetPlayer()->GetID()) < INFLUENCE_LEVEL_INFLUENTIAL)

	mov	ecx, DWORD PTR _kOtherPlayer$222144[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	test	eax, eax
	jle	SHORT $LN20@GetOpenBor
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226029[ebp], eax
	mov	ecx, DWORD PTR $T226029[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T226030[ebp], edx
	mov	eax, DWORD PTR $T226030[ebp]
	push	eax
	mov	ecx, DWORD PTR _kOtherPlayer$222144[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceOn@CvPlayerCulture@@QBEHW4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceOn
	cmp	eax, 4
	jge	SHORT $LN20@GetOpenBor

; 1626 : 			{
; 1627 : 				iItemValue *= 500;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 500				; 000001f4H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1628 : 				iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN20@GetOpenBor:

; 1629 : 			}
; 1630 : 		}
; 1631 : 	}
; 1632 : 	// Other guy giving me Open Borders
; 1633 : 	else

	jmp	$LN18@GetOpenBor
$LN42@GetOpenBor:

; 1634 : 	{
; 1635 : 		// Proximity is very important
; 1636 : 		switch(GetPlayer()->GetProximityToPlayer(eOtherPlayer))

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	mov	DWORD PTR tv181[ebp], eax
	cmp	DWORD PTR tv181[ebp], 3
	ja	SHORT $LN11@GetOpenBor
	mov	eax, DWORD PTR tv181[ebp]
	jmp	DWORD PTR $LN62@GetOpenBor[eax*4]
$LN15@GetOpenBor:

; 1637 : 		{
; 1638 : 		case PLAYER_PROXIMITY_DISTANT:
; 1639 : 			iItemValue = 5;

	mov	DWORD PTR _iItemValue$[ebp], 5

; 1640 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN14@GetOpenBor:

; 1641 : 		case PLAYER_PROXIMITY_FAR:
; 1642 : 			iItemValue = 10;

	mov	DWORD PTR _iItemValue$[ebp], 10		; 0000000aH

; 1643 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN13@GetOpenBor:

; 1644 : 		case PLAYER_PROXIMITY_CLOSE:
; 1645 : 			iItemValue = 15;

	mov	DWORD PTR _iItemValue$[ebp], 15		; 0000000fH

; 1646 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN12@GetOpenBor:

; 1647 : 		case PLAYER_PROXIMITY_NEIGHBORS:
; 1648 : 			iItemValue = 30;

	mov	DWORD PTR _iItemValue$[ebp], 30		; 0000001eH

; 1649 : 			break;

	jmp	SHORT $LN16@GetOpenBor
$LN11@GetOpenBor:

; 1650 : 		default:
; 1651 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Proximity for Open Borders valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1652 : 			iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0
$LN16@GetOpenBor:

; 1653 : 			break;
; 1654 : 		}
; 1655 : 
; 1656 : 		// Reduce value by half if the other guy only has a single City
; 1657 : 		if(GET_PLAYER(eOtherPlayer).getNumCities() == 1)

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226034[ebp], ecx
	mov	ecx, DWORD PTR $T226034[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jne	SHORT $LN10@GetOpenBor

; 1658 : 		{
; 1659 : 			iItemValue *= 50;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 50					; 00000032H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1660 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN10@GetOpenBor:

; 1661 : 		}
; 1662 : 
; 1663 : 		// Boost value greatly if we are going for a culture win
; 1664 : 		// If going for culture win always want open borders against civs we need influence on
; 1665 : 		AIGrandStrategyTypes eCultureStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eCultureStrategy$222157[ebp], eax

; 1666 : #ifdef AUI_WARNING_FIXES
; 1667 : 		const CvPlayerCulture* pPlayerCulture = GetPlayer()->GetCulture();
; 1668 : 		if (eCultureStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eCultureStrategy && pPlayerCulture->GetTourism() > 0)
; 1669 : 		{
; 1670 : 			// The civ we need influence on the most should ALWAYS be included
; 1671 : 			if (pPlayerCulture->GetCivLowestInfluence(false /*bCheckOpenBorders*/) == eOtherPlayer)
; 1672 : #else
; 1673 : 		if (eCultureStrategy != NO_AIGRANDSTRATEGY && GetPlayer()->GetGrandStrategyAI()->GetActiveGrandStrategy() == eCultureStrategy && GetPlayer()->GetCulture()->GetTourism() > 0 )

	cmp	DWORD PTR _eCultureStrategy$222157[ebp], -1
	je	$LN18@GetOpenBor
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eCultureStrategy$222157[ebp]
	jne	$LN18@GetOpenBor
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetTourism@CvPlayerCulture@@QAEHXZ	; CvPlayerCulture::GetTourism
	test	eax, eax
	jle	$LN18@GetOpenBor

; 1674 : 		{
; 1675 : 			// The civ we need influence on the most should ALWAYS be included
; 1676 : 			if (GetPlayer()->GetCulture()->GetCivLowestInfluence(false /*bCheckOpenBorders*/) == eOtherPlayer)

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetCivLowestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@_N@Z ; CvPlayerCulture::GetCivLowestInfluence
	cmp	eax, DWORD PTR _eOtherPlayer$[ebp]
	jne	SHORT $LN8@GetOpenBor

; 1677 : #endif
; 1678 : 			{
; 1679 : 				iItemValue *= 1000;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 1000				; 000003e8H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1680 : 				iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	$LN18@GetOpenBor
$LN8@GetOpenBor:

; 1681 : 			}
; 1682 : 
; 1683 : 			// If have influence over half the civs, want OB with the other half
; 1684 : #ifdef AUI_WARNING_FIXES
; 1685 : 			else if (pPlayerCulture->GetNumCivsToBeInfluentialOn() <= pPlayerCulture->GetNumCivsInfluentialOn())
; 1686 : 			{
; 1687 : 				if (pPlayerCulture->GetInfluenceLevel(eOtherPlayer) < INFLUENCE_LEVEL_INFLUENTIAL)
; 1688 : #else
; 1689 : 			else if (GetPlayer()->GetCulture()->GetNumCivsToBeInfluentialOn() <= GetPlayer()->GetCulture()->GetNumCivsInfluentialOn())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsToBeInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsToBeInfluentialOn
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumCivsInfluentialOn@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetNumCivsInfluentialOn
	cmp	esi, eax
	jg	SHORT $LN6@GetOpenBor

; 1690 : 			{
; 1691 : 				if (GetPlayer()->GetCulture()->GetInfluenceLevel(eOtherPlayer) < INFLUENCE_LEVEL_INFLUENTIAL)

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetInfluenceLevel@CvPlayerCulture@@QBE?AW4InfluenceLevelTypes@@W4PlayerTypes@@@Z ; CvPlayerCulture::GetInfluenceLevel
	cmp	eax, 4
	jge	SHORT $LN5@GetOpenBor

; 1692 : #endif
; 1693 : 				{
; 1694 : 					iItemValue *= 500;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 500				; 000001f4H
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1695 : 					iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN5@GetOpenBor:

; 1696 : 				}
; 1697 : 			}

	jmp	SHORT $LN18@GetOpenBor
$LN6@GetOpenBor:

; 1698 : 
; 1699 : 			else if (GetPlayer()->GetProximityToPlayer(eOtherPlayer) == PLAYER_PROXIMITY_NEIGHBORS)

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetProximityToPlayer@CvPlayer@@QBE?AW4PlayerProximityTypes@@W4PlayerTypes@@@Z ; CvPlayer::GetProximityToPlayer
	cmp	eax, 3
	jne	SHORT $LN18@GetOpenBor

; 1700 : 			{
; 1701 : 				// If we're cramped then we want OB more with our neighbors
; 1702 : 				if(GetPlayer()->IsCramped())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?IsCramped@CvPlayer@@QBE_NXZ		; CvPlayer::IsCramped
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@GetOpenBor

; 1703 : 				{
; 1704 : 					iItemValue *= 300;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 300				; 0000012cH
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1705 : 					iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN18@GetOpenBor:

; 1706 : 				}
; 1707 : 			}
; 1708 : 		}
; 1709 : 	}
; 1710 : 
; 1711 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1712 : 	if(bUseEvenValue)

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetOpenBor

; 1713 : 	{
; 1714 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetOpenBordersValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226043[ebp], eax
	mov	eax, DWORD PTR $T226043[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T226044[ebp], ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226048[ebp], edx
	push	0
	mov	eax, DWORD PTR $T226044[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR $T226048[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetOpenBordersValue
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1715 : 
; 1716 : 		iItemValue /= 2;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN1@GetOpenBor:

; 1717 : 	}
; 1718 : 
; 1719 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]
$LN44@GetOpenBor:

; 1720 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN60@GetOpenBor:
	DD	$LN39@GetOpenBor
	DD	$LN34@GetOpenBor
	DD	$LN38@GetOpenBor
	DD	$LN37@GetOpenBor
	DD	$LN36@GetOpenBor
	DD	$LN35@GetOpenBor
$LN61@GetOpenBor:
	DD	$LN25@GetOpenBor
	DD	$LN26@GetOpenBor
	DD	$LN27@GetOpenBor
	DD	$LN32@GetOpenBor
	DD	$LN29@GetOpenBor
	DD	$LN30@GetOpenBor
	DD	$LN31@GetOpenBor
$LN62@GetOpenBor:
	DD	$LN15@GetOpenBor
	DD	$LN14@GetOpenBor
	DD	$LN13@GetOpenBor
	DD	$LN12@GetOpenBor
?GetOpenBordersValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetOpenBordersValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv73 = -24						; size = 4
_this$ = -20						; size = 4
$T226067 = -16						; size = 4
$T226063 = -12						; size = 4
$T226062 = -8						; size = 4
_iItemValue$ = -4					; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetDefensivePactValue, COMDAT
; _this$ = ecx

; 1724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1725 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Defensive Pact with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1726 : 
; 1727 : 	int iItemValue;
; 1728 : 
; 1729 : 	// What is a Defensive Pact with eOtherPlayer worth to US?
; 1730 : 	if(!bFromMe)

	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	jne	SHORT $LN13@GetDefensi

; 1731 : 	{
; 1732 : 		iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 1733 : 		//	// How strong are they compared to us?
; 1734 : 		//	switch (GetPlayer()->GetDiplomacyAI()->GetPlayerMilitaryStrengthComparedToUs(eOtherPlayer))
; 1735 : 		//	{
; 1736 : 		//	case STRENGTH_PATHETIC:
; 1737 : 		//		iItemValue = 10;
; 1738 : 		//		break;
; 1739 : 		//	case STRENGTH_WEAK:
; 1740 : 		//		iItemValue = 40;
; 1741 : 		//		break;
; 1742 : 		//	case STRENGTH_POOR:
; 1743 : 		//		iItemValue = 70;
; 1744 : 		//		break;
; 1745 : 		//	case STRENGTH_AVERAGE:
; 1746 : 		//		iItemValue = 100;
; 1747 : 		//		break;
; 1748 : 		//	case STRENGTH_STRONG:
; 1749 : 		//		iItemValue = 130;
; 1750 : 		//		break;
; 1751 : 		//	case STRENGTH_POWERFUL:
; 1752 : 		//		iItemValue = 150;
; 1753 : 		//		break;
; 1754 : 		//	case STRENGTH_IMMENSE:
; 1755 : 		//		iItemValue = 200;
; 1756 : 		//		break;
; 1757 : 		//	default:
; 1758 : 		//		CvAssertMsg(false, "DEAL_AI: AI player has no valid MilitaryStrengthComparedToUs for Defensive Pact valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1759 : 		//		iItemValue = 100;
; 1760 : 		//		break;
; 1761 : 		//	}
; 1762 : 	}
; 1763 : 	// How much do we value giving away a Defensive Pact?
; 1764 : 	else

	jmp	SHORT $LN12@GetDefensi
$LN13@GetDefensi:

; 1765 : 	{
; 1766 : 		// Opinion also matters
; 1767 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivOpinion(eOtherPlayer))

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 6
	ja	SHORT $LN2@GetDefensi
	mov	edx, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN22@GetDefensi[edx*4]
$LN9@GetDefensi:

; 1768 : 		{
; 1769 : 		case MAJOR_CIV_OPINION_ALLY:
; 1770 : 			iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 1771 : 			break;

	jmp	SHORT $LN12@GetDefensi
$LN8@GetDefensi:

; 1772 : 		case MAJOR_CIV_OPINION_FRIEND:
; 1773 : 			iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 1774 : 			break;

	jmp	SHORT $LN12@GetDefensi
$LN7@GetDefensi:

; 1775 : 		case MAJOR_CIV_OPINION_FAVORABLE:
; 1776 : 			iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 1777 : 			break;

	jmp	SHORT $LN12@GetDefensi
$LN6@GetDefensi:

; 1778 : 		case MAJOR_CIV_OPINION_NEUTRAL:
; 1779 : 			iItemValue = 100000;

	mov	DWORD PTR _iItemValue$[ebp], 100000	; 000186a0H

; 1780 : 			break;

	jmp	SHORT $LN12@GetDefensi
$LN5@GetDefensi:

; 1781 : 		case MAJOR_CIV_OPINION_COMPETITOR:
; 1782 : 			iItemValue = 100000;

	mov	DWORD PTR _iItemValue$[ebp], 100000	; 000186a0H

; 1783 : 			break;

	jmp	SHORT $LN12@GetDefensi
$LN4@GetDefensi:

; 1784 : 		case MAJOR_CIV_OPINION_ENEMY:
; 1785 : 			iItemValue = 100000;

	mov	DWORD PTR _iItemValue$[ebp], 100000	; 000186a0H

; 1786 : 			break;

	jmp	SHORT $LN12@GetDefensi
$LN3@GetDefensi:

; 1787 : 		case MAJOR_CIV_OPINION_UNFORGIVABLE:
; 1788 : 			iItemValue = 100000;

	mov	DWORD PTR _iItemValue$[ebp], 100000	; 000186a0H

; 1789 : 			break;

	jmp	SHORT $LN12@GetDefensi
$LN2@GetDefensi:

; 1790 : 		default:
; 1791 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Opinion for Defensive Pact valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1792 : 			iItemValue = 100000;

	mov	DWORD PTR _iItemValue$[ebp], 100000	; 000186a0H
$LN12@GetDefensi:

; 1793 : 			break;
; 1794 : 		}
; 1795 : 
; 1796 : 		// Approach is important
; 1797 : 		//switch (GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))
; 1798 : 		//{
; 1799 : 		//case MAJOR_CIV_APPROACH_HOSTILE:
; 1800 : 		//	iItemValue *= 200;	// Value should already be increased above by Opinion as well
; 1801 : 		//	break;
; 1802 : 		//case MAJOR_CIV_APPROACH_GUARDED:
; 1803 : 		//	iItemValue *= 100;	// If we're guarded against someone, getting a Defensive Pact is kinda nice
; 1804 : 		//	break;
; 1805 : 		//case MAJOR_CIV_APPROACH_AFRAID:
; 1806 : 		//	iItemValue *= 80;		// If we're afraid of eOtherPlayer, we couldn't be happier to sign a Defensive Pact with them!
; 1807 : 		//	break;
; 1808 : 		//case MAJOR_CIV_APPROACH_FRIENDLY:
; 1809 : 		//	iItemValue *= 100;
; 1810 : 		//	break;
; 1811 : 		//case MAJOR_CIV_APPROACH_NEUTRAL:
; 1812 : 		//	iItemValue *= 100;
; 1813 : 		//	break;
; 1814 : 		//default:
; 1815 : 		//	CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Defensive Pact valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1816 : 		//	iItemValue *= 100;
; 1817 : 		//	break;
; 1818 : 		//}
; 1819 : 		//iItemValue /= 100;
; 1820 : 	}
; 1821 : 
; 1822 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1823 : 	if(bUseEvenValue)

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	test	eax, eax
	je	SHORT $LN1@GetDefensi

; 1824 : 	{
; 1825 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetDefensivePactValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226062[ebp], eax
	mov	ecx, DWORD PTR $T226062[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T226063[ebp], edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226067[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T226063[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bFromMe$[ebp]
	test	edx, edx
	sete	al
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR $T226067[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetDefensivePactValue
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1826 : 
; 1827 : 		iItemValue /= 2;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN1@GetDefensi:

; 1828 : 	}
; 1829 : 
; 1830 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]

; 1831 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN22@GetDefensi:
	DD	$LN3@GetDefensi
	DD	$LN4@GetDefensi
	DD	$LN5@GetDefensi
	DD	$LN6@GetDefensi
	DD	$LN7@GetDefensi
	DD	$LN8@GetDefensi
	DD	$LN9@GetDefensi
?GetDefensivePactValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetDefensivePactValue
_TEXT	ENDS
EXTRN	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ:PROC	; CvTeam::GetCurrentEra
; Function compile flags: /Odtp
;	COMDAT ?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv132 = -76						; size = 4
tv178 = -72						; size = 4
_this$ = -68						; size = 4
$T226126 = -64						; size = 4
$T226122 = -60						; size = 4
$T226121 = -56						; size = 4
$T226110 = -52						; size = 4
$T226103 = -48						; size = 4
$T226099 = -44						; size = 4
$T226090 = -40						; size = 4
$T226086 = -36						; size = 4
$T226082 = -32						; size = 4
$T226081 = -28						; size = 4
$T226072 = -24						; size = 4
$T226071 = -20						; size = 4
_eTheirEra$222199 = -16					; size = 4
_iAdditionalValue$222200 = -12				; size = 4
_eMyEra$222198 = -8					; size = 4
_iItemValue$ = -4					; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetResearchAgreementValue, COMDAT
; _this$ = ecx

; 1835 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 1836 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Research Agreement with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1837 : 
; 1838 : 	int iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 1839 : 
; 1840 : 	if(bFromMe)

	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	je	$LN10@GetResearc

; 1841 : 	{
; 1842 : 		// if they are ahead of me in tech by one or more eras ratchet up the value since they are more likely to get a good tech than I am
; 1843 : 		EraTypes eMyEra = GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226081[ebp], eax
	mov	ecx, DWORD PTR $T226081[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226082[ebp], eax
	mov	eax, DWORD PTR $T226082[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T226086[ebp], eax
	mov	ecx, DWORD PTR $T226086[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	DWORD PTR _eMyEra$222198[ebp], eax

; 1844 : 		EraTypes eTheirEra = GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226090[ebp], ecx
	mov	edx, DWORD PTR $T226090[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226099[ebp], eax
	mov	ecx, DWORD PTR $T226099[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T226103[ebp], ecx
	mov	ecx, DWORD PTR $T226103[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	DWORD PTR _eTheirEra$222199[ebp], eax

; 1845 : 
; 1846 : 		int iAdditionalValue = iItemValue * max(0,(int)(eTheirEra-eMyEra));

	mov	edx, DWORD PTR _eTheirEra$222199[ebp]
	sub	edx, DWORD PTR _eMyEra$222198[ebp]
	mov	DWORD PTR $T226071[ebp], edx
	mov	DWORD PTR $T226072[ebp], 0
	mov	eax, DWORD PTR $T226072[ebp]
	cmp	eax, DWORD PTR $T226071[ebp]
	jge	SHORT $LN29@GetResearc
	lea	ecx, DWORD PTR $T226071[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN30@GetResearc
$LN29@GetResearc:
	lea	edx, DWORD PTR $T226072[ebp]
	mov	DWORD PTR tv178[ebp], edx
$LN30@GetResearc:
	mov	eax, DWORD PTR tv178[ebp]
	mov	DWORD PTR $T226110[ebp], eax
	mov	ecx, DWORD PTR $T226110[ebp]
	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iAdditionalValue$222200[ebp], edx

; 1847 : 		iItemValue += iAdditionalValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	add	eax, DWORD PTR _iAdditionalValue$222200[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1848 : 
; 1849 : 		// Approach is important
; 1850 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	push	1
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv132[ebp], eax
	mov	edx, DWORD PTR tv132[ebp]
	sub	edx, 1
	mov	DWORD PTR tv132[ebp], edx
	cmp	DWORD PTR tv132[ebp], 5
	ja	SHORT $LN2@GetResearc
	mov	eax, DWORD PTR tv132[ebp]
	jmp	DWORD PTR $LN37@GetResearc[eax*4]
$LN7@GetResearc:

; 1851 : 		{
; 1852 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1853 : 			iItemValue *= 1000;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1854 : 			break;

	jmp	SHORT $LN8@GetResearc
$LN6@GetResearc:

; 1855 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1856 : 			iItemValue *= 100;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1857 : 			break;

	jmp	SHORT $LN8@GetResearc
$LN5@GetResearc:

; 1858 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1859 : 			iItemValue *= 80;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 80					; 00000050H
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1860 : 			break;

	jmp	SHORT $LN8@GetResearc
$LN4@GetResearc:

; 1861 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1862 : 			iItemValue *= 100;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1863 : 			break;

	jmp	SHORT $LN8@GetResearc
$LN3@GetResearc:

; 1864 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1865 : 			iItemValue *= 100;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1866 : 			break;

	jmp	SHORT $LN8@GetResearc
$LN2@GetResearc:

; 1867 : 		default:
; 1868 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Research Agreement valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1869 : 			iItemValue *= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN8@GetResearc:

; 1870 : 			break;
; 1871 : 		}
; 1872 : 		iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN10@GetResearc:

; 1873 : 
; 1874 : 	}
; 1875 : 
; 1876 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1877 : 	if(bUseEvenValue)

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetResearc

; 1878 : 	{
; 1879 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetResearchAgreementValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226121[ebp], eax
	mov	eax, DWORD PTR $T226121[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T226122[ebp], ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226126[ebp], edx
	push	0
	mov	eax, DWORD PTR $T226122[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR $T226126[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetResearchAgreementValue
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1880 : 
; 1881 : 		iItemValue /= 2;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN1@GetResearc:

; 1882 : 	}
; 1883 : 
; 1884 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]

; 1885 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN37@GetResearc:
	DD	$LN7@GetResearc
	DD	$LN2@GetResearc
	DD	$LN6@GetResearc
	DD	$LN5@GetResearc
	DD	$LN4@GetResearc
	DD	$LN3@GetResearc
?GetResearchAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetResearchAgreementValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
_this$ = -20						; size = 4
$T226143 = -16						; size = 4
$T226139 = -12						; size = 4
$T226138 = -8						; size = 4
_iItemValue$ = -4					; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_bUseEvenValue$ = 16					; size = 1
?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z PROC ; CvDealAI::GetTradeAgreementValue, COMDAT
; _this$ = ecx

; 1889 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1890 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Trade Agreement with oneself.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1891 : 
; 1892 : 	int iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 1893 : 
; 1894 : 	if(bFromMe)

	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	je	$LN10@GetTradeAg

; 1895 : 	{
; 1896 : 		// Approach is important
; 1897 : 		switch(GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ true))

	push	1
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	sub	edx, 1
	mov	DWORD PTR tv74[ebp], edx
	cmp	DWORD PTR tv74[ebp], 5
	ja	SHORT $LN2@GetTradeAg
	mov	eax, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN19@GetTradeAg[eax*4]
$LN7@GetTradeAg:

; 1898 : 		{
; 1899 : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 1900 : 			iItemValue *= 250;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 250				; 000000faH
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1901 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN6@GetTradeAg:

; 1902 : 		case MAJOR_CIV_APPROACH_GUARDED:
; 1903 : 			iItemValue *= 130;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 130				; 00000082H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1904 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN5@GetTradeAg:

; 1905 : 		case MAJOR_CIV_APPROACH_AFRAID:
; 1906 : 			iItemValue *= 80;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 80					; 00000050H
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1907 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN4@GetTradeAg:

; 1908 : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 1909 : 			iItemValue *= 100;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 1910 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN3@GetTradeAg:

; 1911 : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 1912 : 			iItemValue *= 110;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 110				; 0000006eH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 1913 : 			break;

	jmp	SHORT $LN8@GetTradeAg
$LN2@GetTradeAg:

; 1914 : 		default:
; 1915 : 			CvAssertMsg(false, "DEAL_AI: AI player has no valid Approach for Research Agreement valuation.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.")
; 1916 : 			iItemValue *= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN8@GetTradeAg:

; 1917 : 			break;
; 1918 : 		}
; 1919 : 		iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN10@GetTradeAg:

; 1920 : 	}
; 1921 : 
; 1922 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1923 : 	if(bUseEvenValue)

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	test	edx, edx
	je	SHORT $LN1@GetTradeAg

; 1924 : 	{
; 1925 : 		iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetTradeAgreementValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226138[ebp], eax
	mov	eax, DWORD PTR $T226138[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T226139[ebp], ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226143[ebp], edx
	push	0
	mov	eax, DWORD PTR $T226139[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR $T226143[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ; CvDealAI::GetTradeAgreementValue
	add	eax, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 1926 : 
; 1927 : 		iItemValue /= 2;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN1@GetTradeAg:

; 1928 : 	}
; 1929 : 
; 1930 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]

; 1931 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN19@GetTradeAg:
	DD	$LN7@GetTradeAg
	DD	$LN2@GetTradeAg
	DD	$LN6@GetTradeAg
	DD	$LN5@GetTradeAg
	DD	$LN4@GetTradeAg
	DD	$LN3@GetTradeAg
?GetTradeAgreementValue@CvDealAI@@QAEH_NW4PlayerTypes@@0@Z ENDP ; CvDealAI::GetTradeAgreementValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z PROC ; CvDealAI::GetPeaceTreatyValue, COMDAT
; _this$ = ecx

; 1942 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1943 : #endif
; 1944 : 	return 0;

	xor	eax, eax

; 1945 : 
; 1946 : 	// DEPRECATED
; 1947 : 
; 1948 : 	//int iItemValue = 500;
; 1949 : 
; 1950 : 	//// What I think me giving up peace is worth to them (if we're winning "our peace" is more valuable)
; 1951 : 	//if (bFromMe)
; 1952 : 	//{
; 1953 : 	//	if (GetPlayer()->GetDiplomacyAI()->IsWantsPeaceWithPlayer(eOtherPlayer))
; 1954 : 	//	{
; 1955 : 	//		iItemValue = 200;
; 1956 : 	//	}
; 1957 : 	//}
; 1958 : 	//// What I think them agreeing to peace with me is worth (if they're winning "their peace" is more valuable)
; 1959 : 	//else
; 1960 : 	//{
; 1961 : 	//	if (GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->IsWantsPeaceWithPlayer(GetPlayer()->GetID()))
; 1962 : 	//	{
; 1963 : 	//		iItemValue = 200;
; 1964 : 	//	}
; 1965 : 	//}
; 1966 : 
; 1967 : 	//// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 1968 : 	//if (bUseEvenValue)
; 1969 : 	//{
; 1970 : 	//	iItemValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetPeaceTreatyValue(!bFromMe, GetPlayer()->GetID(), /*bUseEvenValue*/ false);
; 1971 : 
; 1972 : 	//	iItemValue /= 2;
; 1973 : 	//}
; 1974 : 
; 1975 : 	//return iItemValue;
; 1976 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPeaceTreatyValue@CvDealAI@@QAEHW4PlayerTypes@@@Z ENDP ; CvDealAI::GetPeaceTreatyValue
_TEXT	ENDS
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Odtp
;	COMDAT ?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T226231 = -104						; size = 4
$T226222 = -100						; size = 4
$T226218 = -96						; size = 4
$T226214 = -92						; size = 4
$T226213 = -88						; size = 4
$T226204 = -84						; size = 4
$T226195 = -80						; size = 4
$T226191 = -76						; size = 4
$T226187 = -72						; size = 4
$T226183 = -68						; size = 4
$T226182 = -64						; size = 4
$T226165 = -60						; size = 4
$T226161 = -53						; size = 1
$T226152 = -52						; size = 4
_iExtraCost$222273 = -48				; size = 4
_eMinorAlly$222262 = -44				; size = 4
_ePlayer$222251 = -40					; size = 4
_ui$222247 = -36					; size = 4
_eOpinionTowardsWarPlayer$ = -32			; size = 4
_eWarProjection$ = -28					; size = 4
_eOpinionTowardsAskingPlayer$ = -24			; size = 4
_bMinor$ = -17						; size = 1
_iItemValue$ = -16					; size = 4
_pDiploAI$ = -12					; size = 4
_eOurEra$ = -8						; size = 4
_eWithPlayer$ = -4					; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_eWithTeam$ = 16					; size = 4
?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDealAI::GetThirdPartyPeaceValue, COMDAT
; _this$ = ecx

; 1980 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 1981 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Third Party Peace with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 1982 : 
; 1983 : 	int iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 1984 : 
; 1985 : 	CvDiplomacyAI* pDiploAI = GetPlayer()->GetDiplomacyAI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pDiploAI$[ebp], eax

; 1986 : 
; 1987 : 	PlayerTypes eWithPlayer = NO_PLAYER;

	mov	DWORD PTR _eWithPlayer$[ebp], -1

; 1988 : 
; 1989 : 	// find the first player associated with the team
; 1990 : 	for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	mov	DWORD PTR _ui$222247[ebp], 0
	jmp	SHORT $LN28@GetThirdPa
$LN27@GetThirdPa:
	mov	eax, DWORD PTR _ui$222247[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$222247[ebp], eax
$LN28@GetThirdPa:
	cmp	DWORD PTR _ui$222247[ebp], 63		; 0000003fH
	jae	SHORT $LN26@GetThirdPa

; 1991 : 	{
; 1992 : 		PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	ecx, DWORD PTR _ui$222247[ebp]
	mov	DWORD PTR _ePlayer$222251[ebp], ecx

; 1993 : 		if (GET_PLAYER(ePlayer).isAlive() && GET_PLAYER(ePlayer).getTeam() == eWithTeam) 

	mov	edx, DWORD PTR _ePlayer$222251[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226152[ebp], edx
	mov	eax, DWORD PTR $T226152[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T226161[ebp], cl
	movzx	edx, BYTE PTR $T226161[ebp]
	test	edx, edx
	je	SHORT $LN25@GetThirdPa
	mov	eax, DWORD PTR _ePlayer$222251[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226165[ebp], eax
	mov	ecx, DWORD PTR $T226165[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eWithTeam$[ebp]
	jne	SHORT $LN25@GetThirdPa

; 1994 : 		{
; 1995 : 			eWithPlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$222251[ebp]
	mov	DWORD PTR _eWithPlayer$[ebp], eax

; 1996 : 			break;

	jmp	SHORT $LN26@GetThirdPa
$LN25@GetThirdPa:

; 1997 : 		}
; 1998 : 	}

	jmp	SHORT $LN27@GetThirdPa
$LN26@GetThirdPa:

; 1999 : 
; 2000 : 	CvAssertMsg(eWithPlayer != NO_PLAYER, "eWithPlayer could not be found");
; 2001 : 	if (eWithPlayer == NO_PLAYER)

	cmp	DWORD PTR _eWithPlayer$[ebp], -1
	jne	SHORT $LN24@GetThirdPa

; 2002 : 	{
; 2003 : 		return 0;

	xor	eax, eax
	jmp	$LN29@GetThirdPa
$LN24@GetThirdPa:

; 2004 : 	}
; 2005 : 
; 2006 : 	WarProjectionTypes eWarProjection = pDiploAI->GetWarProjection(eWithPlayer);

	mov	ecx, DWORD PTR _eWithPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection
	mov	DWORD PTR _eWarProjection$[ebp], eax

; 2007 : 
; 2008 : 	EraTypes eOurEra = GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226182[ebp], eax
	mov	edx, DWORD PTR $T226182[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226183[ebp], eax
	mov	ecx, DWORD PTR $T226183[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T226187[ebp], ecx
	mov	ecx, DWORD PTR $T226187[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	DWORD PTR _eOurEra$[ebp], eax

; 2009 : 
; 2010 : 	MajorCivOpinionTypes eOpinionTowardsAskingPlayer = pDiploAI->GetMajorCivOpinion(eOtherPlayer);

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], eax

; 2011 : 	MajorCivOpinionTypes eOpinionTowardsWarPlayer = NO_MAJOR_CIV_OPINION_TYPE;

	mov	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], -1

; 2012 : 
; 2013 : 	bool bMinor = false;

	mov	BYTE PTR _bMinor$[ebp], 0

; 2014 : 
; 2015 : 	// Minor
; 2016 : 	if(GET_PLAYER(eWithPlayer).isMinorCiv())

	mov	eax, DWORD PTR _eWithPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226191[ebp], eax
	mov	ecx, DWORD PTR $T226191[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	$LN23@GetThirdPa

; 2017 : 	{
; 2018 : 		// if we're at war with the opponent, then this must be a peace deal. In this case we should evaluate minor civ peace deals as zero
; 2019 : 		if (GET_TEAM(m_pPlayer->getTeam()).isAtWar(GET_PLAYER(eOtherPlayer).getTeam()))

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226195[ebp], edx
	mov	eax, DWORD PTR $T226195[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226204[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226213[ebp], eax
	mov	ecx, DWORD PTR $T226213[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226214[ebp], eax
	mov	eax, DWORD PTR $T226214[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T226218[ebp], eax
	mov	ecx, DWORD PTR $T226204[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226218[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@GetThirdPa

; 2020 : 		{
; 2021 : 			PlayerTypes eMinorAlly = GET_PLAYER(eWithPlayer).GetMinorCivAI()->GetAlly();

	mov	eax, DWORD PTR _eWithPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226222[ebp], eax
	mov	ecx, DWORD PTR $T226222[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR _eMinorAlly$222262[ebp], eax

; 2022 : 			// if they are allied with the city state or we are allied with the city state
; 2023 : 			if (eMinorAlly == eOtherPlayer || eMinorAlly == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _eMinorAlly$222262[ebp]
	cmp	ecx, DWORD PTR _eOtherPlayer$[ebp]
	je	SHORT $LN20@GetThirdPa
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T226231[ebp], ecx
	mov	edx, DWORD PTR _eMinorAlly$222262[ebp]
	cmp	edx, DWORD PTR $T226231[ebp]
	jne	SHORT $LN22@GetThirdPa
$LN20@GetThirdPa:

; 2024 : 			{
; 2025 : 				return 0;

	xor	eax, eax
	jmp	$LN29@GetThirdPa
$LN22@GetThirdPa:

; 2026 : 			}
; 2027 : 		}
; 2028 : 
; 2029 : 		bMinor = true;

	mov	BYTE PTR _bMinor$[ebp], 1

; 2030 : 	}
; 2031 : 	// Major
; 2032 : 	else

	jmp	SHORT $LN19@GetThirdPa
$LN23@GetThirdPa:

; 2033 : 		eOpinionTowardsWarPlayer = pDiploAI->GetMajorCivOpinion(eWithPlayer);

	mov	eax, DWORD PTR _eWithPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], eax
$LN19@GetThirdPa:

; 2034 : 
; 2035 : 	// From me
; 2036 : 	if(bFromMe)

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	je	$LN18@GetThirdPa

; 2037 : 	{
; 2038 : 		if(eWarProjection == WAR_PROJECTION_VERY_GOOD)

	cmp	DWORD PTR _eWarProjection$[ebp], 5
	jne	SHORT $LN17@GetThirdPa

; 2039 : 			iItemValue = 600;

	mov	DWORD PTR _iItemValue$[ebp], 600	; 00000258H
	jmp	SHORT $LN16@GetThirdPa
$LN17@GetThirdPa:

; 2040 : 		else if(eWarProjection == WAR_PROJECTION_GOOD)

	cmp	DWORD PTR _eWarProjection$[ebp], 4
	jne	SHORT $LN15@GetThirdPa

; 2041 : 			iItemValue = 400;

	mov	DWORD PTR _iItemValue$[ebp], 400	; 00000190H
	jmp	SHORT $LN16@GetThirdPa
$LN15@GetThirdPa:

; 2042 : 		else if(eWarProjection == WAR_PROJECTION_UNKNOWN)

	cmp	DWORD PTR _eWarProjection$[ebp], 3
	jne	SHORT $LN13@GetThirdPa

; 2043 : 			iItemValue = 250;

	mov	DWORD PTR _iItemValue$[ebp], 250	; 000000faH

; 2044 : 		else

	jmp	SHORT $LN16@GetThirdPa
$LN13@GetThirdPa:

; 2045 : 			iItemValue = 200;

	mov	DWORD PTR _iItemValue$[ebp], 200	; 000000c8H
$LN16@GetThirdPa:

; 2046 : 
; 2047 : 		// Add 50 gold per era
; 2048 : 		int iExtraCost = eOurEra * 50;

	mov	edx, DWORD PTR _eOurEra$[ebp]
	imul	edx, 50					; 00000032H
	mov	DWORD PTR _iExtraCost$222273[ebp], edx

; 2049 : 		iItemValue += iExtraCost;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	add	eax, DWORD PTR _iExtraCost$222273[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 2050 : 
; 2051 : 		// Minors
; 2052 : 		if(bMinor)

	movzx	ecx, BYTE PTR _bMinor$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@GetThirdPa

; 2053 : 		{
; 2054 : 		}
; 2055 : 		// Majors
; 2056 : 		else

	jmp	SHORT $LN10@GetThirdPa
$LN11@GetThirdPa:

; 2057 : 		{
; 2058 : 			// Modify for our feelings towards the player we're at war with
; 2059 : 			if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_UNFORGIVABLE)

	cmp	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], 0
	jne	SHORT $LN9@GetThirdPa

; 2060 : 			{
; 2061 : 				iItemValue *= 300;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 300				; 0000012cH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2062 : 				iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN10@GetThirdPa
$LN9@GetThirdPa:

; 2063 : 			}
; 2064 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_ENEMY)

	cmp	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], 1
	jne	SHORT $LN10@GetThirdPa

; 2065 : 			{
; 2066 : 				iItemValue *= 200;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 200				; 000000c8H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2067 : 				iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN10@GetThirdPa:

; 2068 : 			}
; 2069 : 		}
; 2070 : 
; 2071 : 		// Modify for our feelings towards the asking player
; 2072 : 		if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_ALLY)

	cmp	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], 6
	jne	SHORT $LN6@GetThirdPa

; 2073 : 		{
; 2074 : 			iItemValue *= 30;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 30					; 0000001eH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2075 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN5@GetThirdPa
$LN6@GetThirdPa:

; 2076 : 		}
; 2077 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FRIEND)

	cmp	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], 5
	jne	SHORT $LN4@GetThirdPa

; 2078 : 		{
; 2079 : 			iItemValue *= 50;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 50					; 00000032H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2080 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN5@GetThirdPa
$LN4@GetThirdPa:

; 2081 : 		}
; 2082 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FAVORABLE)

	cmp	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], 4
	jne	SHORT $LN5@GetThirdPa

; 2083 : 		{
; 2084 : 			iItemValue *= 75;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 75					; 0000004bH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2085 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN5@GetThirdPa:

; 2086 : 		}
; 2087 : 	}
; 2088 : 	// From them
; 2089 : 	else

	jmp	SHORT $LN1@GetThirdPa
$LN18@GetThirdPa:

; 2090 : 	{
; 2091 : 		iItemValue = -10000;

	mov	DWORD PTR _iItemValue$[ebp], -10000	; ffffd8f0H
$LN1@GetThirdPa:

; 2092 : 	}
; 2093 : 
; 2094 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]
$LN29@GetThirdPa:

; 2095 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetThirdPartyPeaceValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDealAI::GetThirdPartyPeaceValue
_TEXT	ENDS
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z:PROC ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias
; Function compile flags: /Odtp
;	COMDAT ?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T226267 = -84						; size = 4
$T226263 = -80						; size = 4
$T226259 = -76						; size = 4
$T226255 = -72						; size = 4
$T226254 = -68						; size = 4
$T226237 = -64						; size = 4
_iExtraCost$222318 = -60				; size = 4
_iWarMod$222320 = -56					; size = 4
_iWarBias$222319 = -52					; size = 4
_ePlayer$222300 = -48					; size = 4
_ui$222296 = -44					; size = 4
_eOpinionTowardsWarPlayer$ = -40			; size = 4
_eWarProjection$ = -36					; size = 4
_iWarApproachWeight$ = -32				; size = 4
_eOpinionTowardsAskingPlayer$ = -28			; size = 4
_eMinorApproachTowardsWarPlayer$ = -24			; size = 4
_bMinor$ = -17						; size = 1
_iItemValue$ = -16					; size = 4
_pDiploAI$ = -12					; size = 4
_eOurEra$ = -8						; size = 4
_eWithPlayer$ = -4					; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_eWithTeam$ = 16					; size = 4
?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvDealAI::GetThirdPartyWarValue, COMDAT
; _this$ = ecx

; 2099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 2100 : 	CvAssertMsg(GetPlayer()->GetID() != eOtherPlayer, "DEAL_AI: Trying to check value of a Third Party War with oneself. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 2101 : 
; 2102 : 	int iItemValue = 0;

	mov	DWORD PTR _iItemValue$[ebp], 0

; 2103 : 
; 2104 : 	CvDiplomacyAI* pDiploAI = GetPlayer()->GetDiplomacyAI();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	DWORD PTR _pDiploAI$[ebp], eax

; 2105 : 
; 2106 : 	// How much does this AI like to go to war? If it's a 3 or less, never accept
; 2107 : 	int iWarApproachWeight = pDiploAI->GetPersonalityMajorCivApproachBias(MAJOR_CIV_APPROACH_WAR);

	push	0
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetPersonalityMajorCivApproachBias@CvDiplomacyAI@@QBEHW4MajorCivApproachTypes@@@Z ; CvDiplomacyAI::GetPersonalityMajorCivApproachBias
	mov	DWORD PTR _iWarApproachWeight$[ebp], eax

; 2108 : 	if(bFromMe && iWarApproachWeight < 4)

	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	je	SHORT $LN38@GetThirdPa@2
	cmp	DWORD PTR _iWarApproachWeight$[ebp], 4
	jge	SHORT $LN38@GetThirdPa@2

; 2109 : 		return 100000;

	mov	eax, 100000				; 000186a0H
	jmp	$LN39@GetThirdPa@2
$LN38@GetThirdPa@2:

; 2110 : 
; 2111 : 
; 2112 : 	PlayerTypes eWithPlayer = NO_PLAYER;

	mov	DWORD PTR _eWithPlayer$[ebp], -1

; 2113 : 	// find the first player associated with the team
; 2114 : 	for (uint ui = 0; ui < MAX_CIV_PLAYERS; ui++)

	mov	DWORD PTR _ui$222296[ebp], 0
	jmp	SHORT $LN37@GetThirdPa@2
$LN36@GetThirdPa@2:
	mov	ecx, DWORD PTR _ui$222296[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$222296[ebp], ecx
$LN37@GetThirdPa@2:
	cmp	DWORD PTR _ui$222296[ebp], 63		; 0000003fH
	jae	SHORT $LN35@GetThirdPa@2

; 2115 : 	{
; 2116 : 		PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	edx, DWORD PTR _ui$222296[ebp]
	mov	DWORD PTR _ePlayer$222300[ebp], edx

; 2117 : 		if (GET_PLAYER(ePlayer).getTeam() == eWithTeam) 

	mov	eax, DWORD PTR _ePlayer$222300[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226237[ebp], eax
	mov	ecx, DWORD PTR $T226237[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eWithTeam$[ebp]
	jne	SHORT $LN34@GetThirdPa@2

; 2118 : 		{
; 2119 : 			eWithPlayer = ePlayer;

	mov	eax, DWORD PTR _ePlayer$222300[ebp]
	mov	DWORD PTR _eWithPlayer$[ebp], eax

; 2120 : 			break;

	jmp	SHORT $LN35@GetThirdPa@2
$LN34@GetThirdPa@2:

; 2121 : 		}
; 2122 : 	}

	jmp	SHORT $LN36@GetThirdPa@2
$LN35@GetThirdPa@2:

; 2123 : 	WarProjectionTypes eWarProjection = pDiploAI->GetWarProjection(eWithPlayer);

	mov	ecx, DWORD PTR _eWithPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetWarProjection@CvDiplomacyAI@@QBE?AW4WarProjectionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetWarProjection
	mov	DWORD PTR _eWarProjection$[ebp], eax

; 2124 : 
; 2125 : 	EraTypes eOurEra = GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226254[ebp], eax
	mov	edx, DWORD PTR $T226254[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226255[ebp], eax
	mov	ecx, DWORD PTR $T226255[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T226259[ebp], ecx
	mov	ecx, DWORD PTR $T226259[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	mov	DWORD PTR _eOurEra$[ebp], eax

; 2126 : 
; 2127 : 	MajorCivOpinionTypes eOpinionTowardsAskingPlayer = pDiploAI->GetMajorCivOpinion(eOtherPlayer);

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], eax

; 2128 : 	MajorCivOpinionTypes eOpinionTowardsWarPlayer = NO_MAJOR_CIV_OPINION_TYPE;

	mov	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], -1

; 2129 : 	MinorCivApproachTypes eMinorApproachTowardsWarPlayer = NO_MINOR_CIV_APPROACH;

	mov	DWORD PTR _eMinorApproachTowardsWarPlayer$[ebp], -1

; 2130 : 
; 2131 : 	bool bMinor = false;

	mov	BYTE PTR _bMinor$[ebp], 0

; 2132 : 
; 2133 : 	// Minor
; 2134 : 	if(GET_PLAYER(eWithPlayer).isMinorCiv())

	mov	eax, DWORD PTR _eWithPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226263[ebp], eax
	mov	ecx, DWORD PTR $T226263[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@GetThirdPa@2

; 2135 : 	{
; 2136 : 		bMinor = true;

	mov	BYTE PTR _bMinor$[ebp], 1

; 2137 : 		eMinorApproachTowardsWarPlayer = pDiploAI->GetMinorCivApproach(eWithPlayer);

	mov	edx, DWORD PTR _eWithPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	mov	DWORD PTR _eMinorApproachTowardsWarPlayer$[ebp], eax

; 2138 : 	}
; 2139 : 	// Major
; 2140 : 	else

	jmp	SHORT $LN32@GetThirdPa@2
$LN33@GetThirdPa@2:

; 2141 : 		eOpinionTowardsWarPlayer = pDiploAI->GetMajorCivOpinion(eWithPlayer);

	mov	eax, DWORD PTR _eWithPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDiploAI$[ebp]
	call	?GetMajorCivOpinion@CvDiplomacyAI@@QBE?AW4MajorCivOpinionTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMajorCivOpinion
	mov	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], eax
$LN32@GetThirdPa@2:

; 2142 : 
; 2143 : 	// From me
; 2144 : 	if(bFromMe)

	movzx	ecx, BYTE PTR _bFromMe$[ebp]
	test	ecx, ecx
	je	$LN31@GetThirdPa@2

; 2145 : 	{
; 2146 : 		if(eWarProjection >= WAR_PROJECTION_GOOD)

	cmp	DWORD PTR _eWarProjection$[ebp], 4
	jl	SHORT $LN30@GetThirdPa@2

; 2147 : 			iItemValue = 400;

	mov	DWORD PTR _iItemValue$[ebp], 400	; 00000190H
	jmp	SHORT $LN29@GetThirdPa@2
$LN30@GetThirdPa@2:

; 2148 : 		else if(eWarProjection == WAR_PROJECTION_UNKNOWN)

	cmp	DWORD PTR _eWarProjection$[ebp], 3
	jne	SHORT $LN28@GetThirdPa@2

; 2149 : 			iItemValue = 600;

	mov	DWORD PTR _iItemValue$[ebp], 600	; 00000258H
	jmp	SHORT $LN29@GetThirdPa@2
$LN28@GetThirdPa@2:

; 2150 : 		else if(eWarProjection == WAR_PROJECTION_STALEMATE)

	cmp	DWORD PTR _eWarProjection$[ebp], 2
	jne	SHORT $LN26@GetThirdPa@2

; 2151 : 			iItemValue = 1000;

	mov	DWORD PTR _iItemValue$[ebp], 1000	; 000003e8H

; 2152 : 		else

	jmp	SHORT $LN29@GetThirdPa@2
$LN26@GetThirdPa@2:

; 2153 : 			iItemValue = 50000;

	mov	DWORD PTR _iItemValue$[ebp], 50000	; 0000c350H
$LN29@GetThirdPa@2:

; 2154 : 
; 2155 : 		// Add 50 gold per era
; 2156 : 		int iExtraCost = eOurEra * 50;

	mov	edx, DWORD PTR _eOurEra$[ebp]
	imul	edx, 50					; 00000032H
	mov	DWORD PTR _iExtraCost$222318[ebp], edx

; 2157 : 		iItemValue += iExtraCost;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	add	eax, DWORD PTR _iExtraCost$222318[ebp]
	mov	DWORD PTR _iItemValue$[ebp], eax

; 2158 : 
; 2159 : 		// Modify based on our War Approach
; 2160 : 		int iWarBias = /*5*/ GC.getDEFAULT_FLAVOR_VALUE() - iWarApproachWeight;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1864
	mov	DWORD PTR $T226267[ebp], ecx
	mov	edx, DWORD PTR $T226267[ebp]
	sub	edx, DWORD PTR _iWarApproachWeight$[ebp]
	mov	DWORD PTR _iWarBias$222319[ebp], edx

; 2161 : 		int iWarMod = iWarBias * 10;	// EX: 5 - War Approach of 9 = -4 * 10 = -40% cost

	mov	eax, DWORD PTR _iWarBias$222319[ebp]
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _iWarMod$222320[ebp], eax

; 2162 : 		iWarMod *= iItemValue;

	mov	ecx, DWORD PTR _iWarMod$222320[ebp]
	imul	ecx, DWORD PTR _iItemValue$[ebp]
	mov	DWORD PTR _iWarMod$222320[ebp], ecx

; 2163 : 		iWarMod /= 100;

	mov	eax, DWORD PTR _iWarMod$222320[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iWarMod$222320[ebp], eax

; 2164 : 
; 2165 : 		iItemValue += iWarMod;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	add	edx, DWORD PTR _iWarMod$222320[ebp]
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2166 : 
; 2167 : 		// Minor
; 2168 : 		if(bMinor)

	movzx	eax, BYTE PTR _bMinor$[ebp]
	test	eax, eax
	je	SHORT $LN24@GetThirdPa@2

; 2169 : 		{
; 2170 : 			if(eMinorApproachTowardsWarPlayer == MINOR_CIV_APPROACH_FRIENDLY)

	cmp	DWORD PTR _eMinorApproachTowardsWarPlayer$[ebp], 1
	jne	SHORT $LN23@GetThirdPa@2

; 2171 : 				iItemValue = 100000;

	mov	DWORD PTR _iItemValue$[ebp], 100000	; 000186a0H
	jmp	SHORT $LN22@GetThirdPa@2
$LN23@GetThirdPa@2:

; 2172 : 			else if(eMinorApproachTowardsWarPlayer == MINOR_CIV_APPROACH_PROTECTIVE)

	cmp	DWORD PTR _eMinorApproachTowardsWarPlayer$[ebp], 2
	jne	SHORT $LN22@GetThirdPa@2

; 2173 : 				iItemValue = 100000;

	mov	DWORD PTR _iItemValue$[ebp], 100000	; 000186a0H
$LN22@GetThirdPa@2:

; 2174 : 		}
; 2175 : 		// Major
; 2176 : 		else

	jmp	SHORT $LN20@GetThirdPa@2
$LN24@GetThirdPa@2:

; 2177 : 		{
; 2178 : 			// Modify for our feelings towards the player we're would go to war with
; 2179 : 			if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_UNFORGIVABLE)

	cmp	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], 0
	jne	SHORT $LN19@GetThirdPa@2

; 2180 : 			{
; 2181 : 				iItemValue *= 25;

	mov	ecx, DWORD PTR _iItemValue$[ebp]
	imul	ecx, 25					; 00000019H
	mov	DWORD PTR _iItemValue$[ebp], ecx

; 2182 : 				iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN20@GetThirdPa@2
$LN19@GetThirdPa@2:

; 2183 : 			}
; 2184 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_ENEMY)

	cmp	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], 1
	jne	SHORT $LN17@GetThirdPa@2

; 2185 : 			{
; 2186 : 				iItemValue *= 50;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 50					; 00000032H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2187 : 				iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN20@GetThirdPa@2
$LN17@GetThirdPa@2:

; 2188 : 			}
; 2189 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_COMPETITOR)

	cmp	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], 2
	jne	SHORT $LN20@GetThirdPa@2

; 2190 : 			{
; 2191 : 				iItemValue *= 75;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 75					; 0000004bH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2192 : 				iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN20@GetThirdPa@2:

; 2193 : 			}
; 2194 : 		}
; 2195 : 
; 2196 : 		// Modify for our feelings towards the asking player
; 2197 : 		if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_ALLY)

	cmp	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], 6
	jne	SHORT $LN14@GetThirdPa@2

; 2198 : 		{
; 2199 : 			iItemValue *= 50;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 50					; 00000032H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2200 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN13@GetThirdPa@2
$LN14@GetThirdPa@2:

; 2201 : 		}
; 2202 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FRIEND)

	cmp	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], 5
	jne	SHORT $LN12@GetThirdPa@2

; 2203 : 		{
; 2204 : 			iItemValue *= 75;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 75					; 0000004bH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2205 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN13@GetThirdPa@2
$LN12@GetThirdPa@2:

; 2206 : 		}
; 2207 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_FAVORABLE)

	cmp	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], 4
	jne	SHORT $LN10@GetThirdPa@2

; 2208 : 		{
; 2209 : 			iItemValue *= 85;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 85					; 00000055H
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2210 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
	jmp	SHORT $LN13@GetThirdPa@2
$LN10@GetThirdPa@2:

; 2211 : 		}
; 2212 : 		else if(eOpinionTowardsAskingPlayer == MAJOR_CIV_OPINION_COMPETITOR)

	cmp	DWORD PTR _eOpinionTowardsAskingPlayer$[ebp], 2
	jne	SHORT $LN13@GetThirdPa@2

; 2213 : 		{
; 2214 : 			iItemValue *= 125;

	mov	edx, DWORD PTR _iItemValue$[ebp]
	imul	edx, 125				; 0000007dH
	mov	DWORD PTR _iItemValue$[ebp], edx

; 2215 : 			iItemValue /= 100;

	mov	eax, DWORD PTR _iItemValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iItemValue$[ebp], eax
$LN13@GetThirdPa@2:

; 2216 : 		}
; 2217 : 	}
; 2218 : 
; 2219 : 	// From them
; 2220 : 	else

	jmp	SHORT $LN7@GetThirdPa@2
$LN31@GetThirdPa@2:

; 2221 : 	{
; 2222 : 		// Minor
; 2223 : 		if(bMinor)

	movzx	edx, BYTE PTR _bMinor$[ebp]
	test	edx, edx
	je	SHORT $LN6@GetThirdPa@2

; 2224 : 			iItemValue = -100000;

	mov	DWORD PTR _iItemValue$[ebp], -100000	; fffe7960H

; 2225 : 
; 2226 : 		// Major
; 2227 : 		else

	jmp	SHORT $LN7@GetThirdPa@2
$LN6@GetThirdPa@2:

; 2228 : 		{
; 2229 : 			// Modify for our feelings towards the player they would go to war with
; 2230 : 			if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_UNFORGIVABLE)

	cmp	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], 0
	jne	SHORT $LN4@GetThirdPa@2

; 2231 : 				iItemValue = 200;

	mov	DWORD PTR _iItemValue$[ebp], 200	; 000000c8H
	jmp	SHORT $LN7@GetThirdPa@2
$LN4@GetThirdPa@2:

; 2232 : 			else if(eOpinionTowardsWarPlayer == MAJOR_CIV_OPINION_ENEMY)

	cmp	DWORD PTR _eOpinionTowardsWarPlayer$[ebp], 1
	jne	SHORT $LN2@GetThirdPa@2

; 2233 : 				iItemValue = 100;

	mov	DWORD PTR _iItemValue$[ebp], 100	; 00000064H

; 2234 : 			else

	jmp	SHORT $LN7@GetThirdPa@2
$LN2@GetThirdPa@2:

; 2235 : 				iItemValue = -100000;

	mov	DWORD PTR _iItemValue$[ebp], -100000	; fffe7960H
$LN7@GetThirdPa@2:

; 2236 : 		}
; 2237 : 	}
; 2238 : 
; 2239 : 	return iItemValue;

	mov	eax, DWORD PTR _iItemValue$[ebp]
$LN39@GetThirdPa@2:

; 2240 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetThirdPartyWarValue@CvDealAI@@QAEH_NW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvDealAI::GetThirdPartyWarValue
_TEXT	ENDS
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
EXTRN	?CalculateStartingVotesForMember@CvLeague@@QAEHW4PlayerTypes@@_N@Z:PROC ; CvLeague::CalculateStartingVotesForMember
EXTRN	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ:PROC ; CvGameLeagues::GetActiveLeague
EXTRN	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ:PROC	; CvGameLeagues::GetNumActiveLeagues
EXTRN	?EvaluateAlignment@CvLeagueAI@@QAE?AW4AlignmentLevels@1@W4PlayerTypes@@@Z:PROC ; CvLeagueAI::EvaluateAlignment
EXTRN	?EvaluateVoteForTrade@CvLeagueAI@@QAE?AW4DesireLevels@1@HHH_N@Z:PROC ; CvLeagueAI::EvaluateVoteForTrade
EXTRN	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ:PROC ; CvPlayer::GetLeagueAI
EXTRN	__fltused:DWORD
;	COMDAT __real@3e800000
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
CONST	ENDS
;	COMDAT ?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z
_TEXT	SEGMENT
tv219 = -80						; size = 4
tv309 = -76						; size = 4
tv153 = -72						; size = 4
tv92 = -68						; size = 4
tv76 = -64						; size = 4
_this$ = -60						; size = 4
$T226301 = -56						; size = 4
$T226297 = -52						; size = 4
$T226296 = -48						; size = 4
$T226285 = -44						; size = 4
$T226278 = -40						; size = 4
$T226274 = -36						; size = 4
$T226270 = -32						; size = 4
_fVotesRatio$222401 = -28				; size = 4
_pLeague$222399 = -24					; size = 4
_eDesire$222387 = -20					; size = 4
_eOtherPlayerApproach$222383 = -16			; size = 4
_eAlignment$222369 = -12				; size = 4
_eDesire$222357 = -8					; size = 4
_iValue$ = -4						; size = 4
_bFromMe$ = 8						; size = 1
_eOtherPlayer$ = 12					; size = 4
_iProposalID$ = 16					; size = 4
_iVoteChoice$ = 20					; size = 4
_iNumVotes$ = 24					; size = 4
_bRepeal$ = 28						; size = 1
_bUseEvenValue$ = 32					; size = 1
?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z PROC ; CvDealAI::GetVoteCommitmentValue, COMDAT
; _this$ = ecx

; 2244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 2245 : 	int iValue = 0;

	mov	DWORD PTR _iValue$[ebp], 0

; 2246 : 
; 2247 : 	// Giving our votes to them - Higher value for voting on things we dislike
; 2248 : 	if (bFromMe)

	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	je	$LN39@GetVoteCom

; 2249 : 	{
; 2250 : 		// Adjust based on LeagueAI
; 2251 : 		CvLeagueAI::DesireLevels eDesire = GetPlayer()->GetLeagueAI()->EvaluateVoteForTrade(iProposalID, iVoteChoice, iNumVotes, bRepeal);

	movzx	ecx, BYTE PTR _bRepeal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumVotes$[ebp]
	push	edx
	mov	eax, DWORD PTR _iVoteChoice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iProposalID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?EvaluateVoteForTrade@CvLeagueAI@@QAE?AW4DesireLevels@1@HHH_N@Z ; CvLeagueAI::EvaluateVoteForTrade
	mov	DWORD PTR _eDesire$222357[ebp], eax

; 2252 : 		switch(eDesire)

	mov	edx, DWORD PTR _eDesire$222357[ebp]
	mov	DWORD PTR tv76[ebp], edx
	cmp	DWORD PTR tv76[ebp], 8
	ja	SHORT $LN31@GetVoteCom
	mov	eax, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN56@GetVoteCom[eax*4]
$LN36@GetVoteCom:

; 2253 : 		{
; 2254 : 		case CvLeagueAI::DESIRE_NEVER:
; 2255 : 		case CvLeagueAI::DESIRE_STRONG_DISLIKE:
; 2256 : 			iValue += 100000;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, 100000				; 000186a0H
	mov	DWORD PTR _iValue$[ebp], ecx

; 2257 : 			break;

	jmp	SHORT $LN37@GetVoteCom
$LN35@GetVoteCom:

; 2258 : 		case CvLeagueAI::DESIRE_DISLIKE:
; 2259 : 			iValue += 300;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, 300				; 0000012cH
	mov	DWORD PTR _iValue$[ebp], edx

; 2260 : 			break;

	jmp	SHORT $LN37@GetVoteCom
$LN34@GetVoteCom:

; 2261 : 		case CvLeagueAI::DESIRE_WEAK_DISLIKE:
; 2262 : 			iValue += 200;

	mov	eax, DWORD PTR _iValue$[ebp]
	add	eax, 200				; 000000c8H
	mov	DWORD PTR _iValue$[ebp], eax

; 2263 : 			break;

	jmp	SHORT $LN37@GetVoteCom
$LN33@GetVoteCom:

; 2264 : 		case CvLeagueAI::DESIRE_NEUTRAL:
; 2265 : 		case CvLeagueAI::DESIRE_WEAK_LIKE:
; 2266 : 		case CvLeagueAI::DESIRE_LIKE:
; 2267 : 			iValue += 150;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, 150				; 00000096H
	mov	DWORD PTR _iValue$[ebp], ecx

; 2268 : 			break;

	jmp	SHORT $LN37@GetVoteCom
$LN32@GetVoteCom:

; 2269 : 		case CvLeagueAI::DESIRE_STRONG_LIKE:
; 2270 : 		case CvLeagueAI::DESIRE_ALWAYS:
; 2271 : 			iValue += 50;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _iValue$[ebp], edx

; 2272 : 			break;

	jmp	SHORT $LN37@GetVoteCom
$LN31@GetVoteCom:

; 2273 : 		default:
; 2274 : 			iValue += 100000;

	mov	eax, DWORD PTR _iValue$[ebp]
	add	eax, 100000				; 000186a0H
	mov	DWORD PTR _iValue$[ebp], eax
$LN37@GetVoteCom:

; 2275 : 			break;
; 2276 : 		}
; 2277 : 
; 2278 : 		// Adjust based on relationship
; 2279 : 		CvAssert(eOtherPlayer != NO_PLAYER);
; 2280 : 		if (eOtherPlayer != NO_PLAYER)

	cmp	DWORD PTR _eOtherPlayer$[ebp], -1
	je	$LN18@GetVoteCom

; 2281 : 		{
; 2282 : 			CvLeagueAI::AlignmentLevels eAlignment = GetPlayer()->GetLeagueAI()->EvaluateAlignment(eOtherPlayer);

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?EvaluateAlignment@CvLeagueAI@@QAE?AW4AlignmentLevels@1@W4PlayerTypes@@@Z ; CvLeagueAI::EvaluateAlignment
	mov	DWORD PTR _eAlignment$222369[ebp], eax

; 2283 : 			switch (eAlignment)

	mov	edx, DWORD PTR _eAlignment$222369[ebp]
	mov	DWORD PTR tv92[ebp], edx
	cmp	DWORD PTR tv92[ebp], 10			; 0000000aH
	ja	SHORT $LN19@GetVoteCom
	mov	eax, DWORD PTR tv92[ebp]
	jmp	DWORD PTR $LN57@GetVoteCom[eax*4]
$LN27@GetVoteCom:

; 2284 : 			{
; 2285 : 			case CvLeagueAI::ALIGNMENT_LIBERATOR:
; 2286 : 			case CvLeagueAI::ALIGNMENT_LEADER:
; 2287 : 				iValue += -50;

	mov	ecx, DWORD PTR _iValue$[ebp]
	sub	ecx, 50					; 00000032H
	mov	DWORD PTR _iValue$[ebp], ecx

; 2288 : 				break;

	jmp	SHORT $LN28@GetVoteCom

; 2289 : 			case CvLeagueAI::ALIGNMENT_SELF:
; 2290 : 				CvAssertMsg(false, "ALIGNMENT_SELF found when evaluating a trade deal for delegates. Please send Anton your save file and version.");
; 2291 : 				break;

	jmp	SHORT $LN28@GetVoteCom
$LN25@GetVoteCom:

; 2292 : 			case CvLeagueAI::ALIGNMENT_ALLY:
; 2293 : 				iValue += -35;

	mov	edx, DWORD PTR _iValue$[ebp]
	sub	edx, 35					; 00000023H
	mov	DWORD PTR _iValue$[ebp], edx

; 2294 : 				break;

	jmp	SHORT $LN28@GetVoteCom
$LN24@GetVoteCom:

; 2295 : 			case CvLeagueAI::ALIGNMENT_CONFIDANT:
; 2296 : 			case CvLeagueAI::ALIGNMENT_FRIEND:
; 2297 : 				iValue += -25;

	mov	eax, DWORD PTR _iValue$[ebp]
	sub	eax, 25					; 00000019H
	mov	DWORD PTR _iValue$[ebp], eax

; 2298 : 				break;

	jmp	SHORT $LN28@GetVoteCom

; 2299 : 			case CvLeagueAI::ALIGNMENT_NEUTRAL:
; 2300 : 				break;

	jmp	SHORT $LN28@GetVoteCom
$LN22@GetVoteCom:

; 2301 : 			case CvLeagueAI::ALIGNMENT_RIVAL:
; 2302 : 				iValue += 25;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, 25					; 00000019H
	mov	DWORD PTR _iValue$[ebp], ecx

; 2303 : 				break;

	jmp	SHORT $LN28@GetVoteCom
$LN21@GetVoteCom:

; 2304 : 			case CvLeagueAI::ALIGNMENT_HATRED:
; 2305 : 				iValue += 50;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _iValue$[ebp], edx

; 2306 : 				break;

	jmp	SHORT $LN28@GetVoteCom
$LN20@GetVoteCom:

; 2307 : 			case CvLeagueAI::ALIGNMENT_ENEMY:
; 2308 : 			case CvLeagueAI::ALIGNMENT_WAR:
; 2309 : 				iValue += 100000;

	mov	eax, DWORD PTR _iValue$[ebp]
	add	eax, 100000				; 000186a0H
	mov	DWORD PTR _iValue$[ebp], eax
$LN19@GetVoteCom:
$LN28@GetVoteCom:

; 2310 : 				break;
; 2311 : 			default:
; 2312 : 				break;
; 2313 : 			}
; 2314 : 
; 2315 : 			MajorCivApproachTypes eOtherPlayerApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR _eOtherPlayerApproach$222383[ebp], eax

; 2316 : 			if (eOtherPlayerApproach == MAJOR_CIV_APPROACH_HOSTILE || eOtherPlayerApproach == MAJOR_CIV_APPROACH_WAR)

	cmp	DWORD PTR _eOtherPlayerApproach$222383[ebp], 1
	je	SHORT $LN17@GetVoteCom
	cmp	DWORD PTR _eOtherPlayerApproach$222383[ebp], 0
	jne	SHORT $LN18@GetVoteCom
$LN17@GetVoteCom:

; 2317 : 			{
; 2318 : 				iValue += 100000;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, 100000				; 000186a0H
	mov	DWORD PTR _iValue$[ebp], edx
$LN18@GetVoteCom:

; 2319 : 			}
; 2320 : 		}
; 2321 : 	}
; 2322 : 	// Giving their votes to us - Higher value for voting on things we like
; 2323 : 	else

	jmp	$LN2@GetVoteCom
$LN39@GetVoteCom:

; 2324 : 	{
; 2325 : 		// Adjust based on LeagueAI
; 2326 : 		CvLeagueAI::DesireLevels eDesire = GetPlayer()->GetLeagueAI()->EvaluateVoteForTrade(iProposalID, iVoteChoice, iNumVotes, bRepeal);

	movzx	eax, BYTE PTR _bRepeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumVotes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iVoteChoice$[ebp]
	push	edx
	mov	eax, DWORD PTR _iProposalID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?EvaluateVoteForTrade@CvLeagueAI@@QAE?AW4DesireLevels@1@HHH_N@Z ; CvLeagueAI::EvaluateVoteForTrade
	mov	DWORD PTR _eDesire$222387[ebp], eax

; 2327 : 		switch(eDesire)

	mov	ecx, DWORD PTR _eDesire$222387[ebp]
	mov	DWORD PTR tv153[ebp], ecx
	cmp	DWORD PTR tv153[ebp], 8
	ja	SHORT $LN8@GetVoteCom
	mov	edx, DWORD PTR tv153[ebp]
	jmp	DWORD PTR $LN58@GetVoteCom[edx*4]
$LN13@GetVoteCom:

; 2328 : 		{
; 2329 : 		case CvLeagueAI::DESIRE_NEVER:
; 2330 : 		case CvLeagueAI::DESIRE_STRONG_DISLIKE:
; 2331 : 		case CvLeagueAI::DESIRE_WEAK_DISLIKE:
; 2332 : 		case CvLeagueAI::DESIRE_NEUTRAL:
; 2333 : 			iValue += -100000;

	mov	eax, DWORD PTR _iValue$[ebp]
	sub	eax, 100000				; 000186a0H
	mov	DWORD PTR _iValue$[ebp], eax

; 2334 : 			break;

	jmp	SHORT $LN14@GetVoteCom
$LN12@GetVoteCom:

; 2335 : 		case CvLeagueAI::DESIRE_WEAK_LIKE:
; 2336 : 			iValue += 50;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, 50					; 00000032H
	mov	DWORD PTR _iValue$[ebp], ecx

; 2337 : 			break;

	jmp	SHORT $LN14@GetVoteCom
$LN11@GetVoteCom:

; 2338 : 		case CvLeagueAI::DESIRE_LIKE:
; 2339 : 			iValue += 100;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _iValue$[ebp], edx

; 2340 : 			break;

	jmp	SHORT $LN14@GetVoteCom
$LN10@GetVoteCom:

; 2341 : 		case CvLeagueAI::DESIRE_STRONG_LIKE:
; 2342 : 			iValue += 150;

	mov	eax, DWORD PTR _iValue$[ebp]
	add	eax, 150				; 00000096H
	mov	DWORD PTR _iValue$[ebp], eax

; 2343 : 			break;

	jmp	SHORT $LN14@GetVoteCom
$LN9@GetVoteCom:

; 2344 : 		case CvLeagueAI::DESIRE_ALWAYS:
; 2345 : 			iValue += 200;

	mov	ecx, DWORD PTR _iValue$[ebp]
	add	ecx, 200				; 000000c8H
	mov	DWORD PTR _iValue$[ebp], ecx

; 2346 : 			break;

	jmp	SHORT $LN14@GetVoteCom
$LN8@GetVoteCom:

; 2347 : 		default:
; 2348 : 			iValue += -100000;

	mov	edx, DWORD PTR _iValue$[ebp]
	sub	edx, 100000				; 000186a0H
	mov	DWORD PTR _iValue$[ebp], edx
$LN14@GetVoteCom:

; 2349 : 			break;
; 2350 : 		}
; 2351 : 
; 2352 : 		// Adjust based on their vote total - Having lots of votes left means they could counter these ones and exploit us
; 2353 : #ifndef AUI_LEAGUES_FIX_POSSIBLE_DEALLOCATION_CRASH
; 2354 : 		if (GC.getGame().GetGameLeagues()->GetNumActiveLeagues() > 0)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226274[ebp], eax
	mov	ecx, DWORD PTR $T226274[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetNumActiveLeagues@CvGameLeagues@@QAEHXZ ; CvGameLeagues::GetNumActiveLeagues
	test	eax, eax
	jle	SHORT $LN2@GetVoteCom

; 2355 : #endif
; 2356 : 		{
; 2357 : 			CvLeague* pLeague = GC.getGame().GetGameLeagues()->GetActiveLeague();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226278[ebp], ecx
	mov	ecx, DWORD PTR $T226278[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetActiveLeague@CvGameLeagues@@QAEPAVCvLeague@@XZ ; CvGameLeagues::GetActiveLeague
	mov	DWORD PTR _pLeague$222399[ebp], eax

; 2358 : 			if (pLeague)

	cmp	DWORD PTR _pLeague$222399[ebp], 0
	je	SHORT $LN2@GetVoteCom

; 2359 : 			{
; 2360 : 				float fVotesRatio = (float)iNumVotes / (float)pLeague->CalculateStartingVotesForMember(eOtherPlayer);

	cvtsi2ss xmm0, DWORD PTR _iNumVotes$[ebp]
	push	0
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLeague$222399[ebp]
	movss	DWORD PTR tv309[ebp], xmm0
	call	?CalculateStartingVotesForMember@CvLeague@@QAEHW4PlayerTypes@@_N@Z ; CvLeague::CalculateStartingVotesForMember
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv309[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _fVotesRatio$222401[ebp], xmm1

; 2361 : 				if (fVotesRatio > 0.5f)

	movss	xmm0, DWORD PTR _fVotesRatio$222401[ebp]
	comiss	xmm0, DWORD PTR __real@3f000000
	jbe	SHORT $LN5@GetVoteCom
	jmp	SHORT $LN2@GetVoteCom
$LN5@GetVoteCom:

; 2362 : 				{
; 2363 : 					// More than half their votes...they probably aren't going to screw us
; 2364 : 				}
; 2365 : 				else if (fVotesRatio > 0.25f)

	movss	xmm0, DWORD PTR _fVotesRatio$222401[ebp]
	comiss	xmm0, DWORD PTR __real@3e800000
	jbe	SHORT $LN3@GetVoteCom

; 2366 : 				{
; 2367 : 					// They have a lot of remaining votes
; 2368 : 					iValue += -20;

	mov	eax, DWORD PTR _iValue$[ebp]
	sub	eax, 20					; 00000014H
	mov	DWORD PTR _iValue$[ebp], eax

; 2369 : 				}
; 2370 : 				else

	jmp	SHORT $LN2@GetVoteCom
$LN3@GetVoteCom:

; 2371 : 				{
; 2372 : 					// They have a hoard of votes
; 2373 : 					iValue += -40;

	mov	ecx, DWORD PTR _iValue$[ebp]
	sub	ecx, 40					; 00000028H
	mov	DWORD PTR _iValue$[ebp], ecx
$LN2@GetVoteCom:

; 2374 : 				}
; 2375 : 			}
; 2376 : 		}
; 2377 : 	}
; 2378 : 
; 2379 : 	iValue = MAX(iValue, 0);

	mov	DWORD PTR $T226270[ebp], 0
	mov	edx, DWORD PTR _iValue$[ebp]
	cmp	edx, DWORD PTR $T226270[ebp]
	jge	SHORT $LN48@GetVoteCom
	lea	eax, DWORD PTR $T226270[ebp]
	mov	DWORD PTR tv219[ebp], eax
	jmp	SHORT $LN49@GetVoteCom
$LN48@GetVoteCom:
	lea	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR tv219[ebp], ecx
$LN49@GetVoteCom:
	mov	edx, DWORD PTR tv219[ebp]
	mov	DWORD PTR $T226285[ebp], edx
	mov	eax, DWORD PTR $T226285[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iValue$[ebp], ecx

; 2380 : 
; 2381 : 	// Adjust based on how many votes
; 2382 : 	iValue *= iNumVotes;

	mov	edx, DWORD PTR _iValue$[ebp]
	imul	edx, DWORD PTR _iNumVotes$[ebp]
	mov	DWORD PTR _iValue$[ebp], edx

; 2383 : 
; 2384 : 	// Are we trying to find the middle point between what we think this item is worth and what another player thinks it's worth?
; 2385 : 	if (bUseEvenValue)

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	test	eax, eax
	je	SHORT $LN1@GetVoteCom

; 2386 : 	{
; 2387 : 		iValue += GET_PLAYER(eOtherPlayer).GetDealAI()->GetVoteCommitmentValue(!bFromMe, GetPlayer()->GetID(), iProposalID, iVoteChoice, iNumVotes, bRepeal, /*bUseEvenValue*/ false);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226296[ebp], eax
	mov	ecx, DWORD PTR $T226296[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T226297[ebp], edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226301[ebp], eax
	push	0
	movzx	ecx, BYTE PTR _bRepeal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumVotes$[ebp]
	push	edx
	mov	eax, DWORD PTR _iVoteChoice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iProposalID$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226297[ebp]
	push	edx
	movzx	eax, BYTE PTR _bFromMe$[ebp]
	test	eax, eax
	sete	cl
	movzx	edx, cl
	push	edx
	mov	ecx, DWORD PTR $T226301[ebp]
	call	?GetDealAI@CvPlayer@@QBEPAVCvDealAI@@XZ	; CvPlayer::GetDealAI
	mov	ecx, eax
	call	?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ; CvDealAI::GetVoteCommitmentValue
	add	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax

; 2388 : 
; 2389 : 		iValue /= 2;

	mov	eax, DWORD PTR _iValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iValue$[ebp], eax
$LN1@GetVoteCom:

; 2390 : 	}
; 2391 : 
; 2392 : 	return iValue;

	mov	eax, DWORD PTR _iValue$[ebp]

; 2393 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	2
$LN56@GetVoteCom:
	DD	$LN36@GetVoteCom
	DD	$LN36@GetVoteCom
	DD	$LN35@GetVoteCom
	DD	$LN34@GetVoteCom
	DD	$LN33@GetVoteCom
	DD	$LN33@GetVoteCom
	DD	$LN33@GetVoteCom
	DD	$LN32@GetVoteCom
	DD	$LN32@GetVoteCom
$LN57@GetVoteCom:
	DD	$LN20@GetVoteCom
	DD	$LN20@GetVoteCom
	DD	$LN21@GetVoteCom
	DD	$LN22@GetVoteCom
	DD	$LN19@GetVoteCom
	DD	$LN24@GetVoteCom
	DD	$LN24@GetVoteCom
	DD	$LN25@GetVoteCom
	DD	$LN19@GetVoteCom
	DD	$LN27@GetVoteCom
	DD	$LN27@GetVoteCom
$LN58@GetVoteCom:
	DD	$LN13@GetVoteCom
	DD	$LN13@GetVoteCom
	DD	$LN8@GetVoteCom
	DD	$LN13@GetVoteCom
	DD	$LN13@GetVoteCom
	DD	$LN12@GetVoteCom
	DD	$LN11@GetVoteCom
	DD	$LN10@GetVoteCom
	DD	$LN9@GetVoteCom
?GetVoteCommitmentValue@CvDealAI@@QAEH_NW4PlayerTypes@@HHH00@Z ENDP ; CvDealAI::GetVoteCommitmentValue
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>
PUBLIC	??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
PUBLIC	?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free
PUBLIC	__$ArrayPad$
EXTRN	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z:PROC ; CvDeal::AddVoteCommitment
EXTRN	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z:PROC ; CvDeal::IsPossibleToTradeItem
EXTRN	?GetDesiredVoteCommitments@CvLeagueAI@@QAE?AV?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@W4PlayerTypes@@@Z:PROC ; CvLeagueAI::GetDesiredVoteCommitments
EXTRN	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsVoteCommitmentTrade
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$1
__ehfuncinfo$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T226322 = -144						; size = 4
_iItemValue$222436 = -140				; size = 4
_iVoteChoice$222432 = -136				; size = 4
_bRepeal$222434 = -129					; size = 1
_iProposalID$222431 = -128				; size = 4
_iNumVotes$222433 = -124				; size = 4
_it$222427 = -120					; size = 4
_vDesiredCommitments$222425 = -116			; size = 96
__$ArrayPad$ = -20					; size = 4
_eMyPlayer$222423 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddVoteCommitmentToThem, COMDAT
; _this$ = ecx

; 2397 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2398 : 	CvAssert(eThem >= 0);
; 2399 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2400 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Vote Commitment to Them, but them is us. Please send Anton your save file and version.");
; 2401 : 
; 2402 : 	if(!bDontChangeTheirExistingItems)

	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	eax, eax
	jne	$LN9@DoAddVoteC

; 2403 : 	{
; 2404 : 		if(iTotalValue < 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	$LN9@DoAddVoteC

; 2405 : 		{
; 2406 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226322[ebp], eax
	mov	edx, DWORD PTR $T226322[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222423[ebp], eax

; 2407 : 
; 2408 : 			// Can't already be a Vote Commitment in the Deal
; 2409 : 			if(!pDeal->IsVoteCommitmentTrade(eThem) && !pDeal->IsVoteCommitmentTrade(eMyPlayer))

	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	movzx	edx, al
	test	edx, edx
	jne	$LN9@DoAddVoteC
	mov	eax, DWORD PTR _eMyPlayer$222423[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN9@DoAddVoteC

; 2410 : 			{
; 2411 : 				CvLeagueAI::VoteCommitmentList vDesiredCommitments = GetPlayer()->GetLeagueAI()->GetDesiredVoteCommitments(eThem);

	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDesiredCommitments$222425[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?GetDesiredVoteCommitments@CvLeagueAI@@QAE?AV?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@W4PlayerTypes@@@Z ; CvLeagueAI::GetDesiredVoteCommitments
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2412 : 				for (CvLeagueAI::VoteCommitmentList::iterator it = vDesiredCommitments.begin(); it != vDesiredCommitments.end(); ++it)

	mov	ecx, DWORD PTR _vDesiredCommitments$222425[ebp]
	mov	DWORD PTR _it$222427[ebp], ecx
	jmp	SHORT $LN18@DoAddVoteC
$LN4@DoAddVoteC:
	mov	edx, DWORD PTR _it$222427[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _it$222427[ebp], edx
$LN18@DoAddVoteC:
	mov	eax, DWORD PTR _vDesiredCommitments$222425[ebp+4]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR _vDesiredCommitments$222425[ebp]
	cmp	DWORD PTR _it$222427[ebp], eax
	je	$LN3@DoAddVoteC

; 2413 : 				{
; 2414 : 					int iProposalID = it->iResolutionID;

	mov	ecx, DWORD PTR _it$222427[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _iProposalID$222431[ebp], edx

; 2415 : 					int iVoteChoice = it->iVoteChoice;

	mov	eax, DWORD PTR _it$222427[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _iVoteChoice$222432[ebp], ecx

; 2416 : 					int iNumVotes = it->iNumVotes;

	mov	edx, DWORD PTR _it$222427[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _iNumVotes$222433[ebp], eax

; 2417 : 					bool bRepeal = !it->bEnact;

	mov	ecx, DWORD PTR _it$222427[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	mov	BYTE PTR _bRepeal$222434[ebp], dl

; 2418 : 
; 2419 : 					if (iProposalID != -1 && pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_VOTE_COMMITMENT, iProposalID, iVoteChoice, iNumVotes, bRepeal))

	cmp	DWORD PTR _iProposalID$222431[ebp], -1
	je	$LN2@DoAddVoteC
	push	0
	push	1
	movzx	eax, BYTE PTR _bRepeal$222434[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumVotes$222433[ebp]
	push	ecx
	mov	edx, DWORD PTR _iVoteChoice$222432[ebp]
	push	edx
	mov	eax, DWORD PTR _iProposalID$222431[ebp]
	push	eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR _eMyPlayer$222423[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	$LN2@DoAddVoteC

; 2420 : 					{
; 2421 : 						int iItemValue = GetTradeItemValue(TRADE_ITEM_VOTE_COMMITMENT, /*bFromMe*/ false, eThem, iProposalID, iVoteChoice, iNumVotes, bRepeal, -1, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	push	-1
	movzx	edx, BYTE PTR _bRepeal$222434[ebp]
	push	edx
	mov	eax, DWORD PTR _iNumVotes$222433[ebp]
	push	eax
	mov	ecx, DWORD PTR _iVoteChoice$222432[ebp]
	push	ecx
	mov	edx, DWORD PTR _iProposalID$222431[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	push	0
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222436[ebp], eax

; 2422 : 
; 2423 : 						// If adding this to the deal doesn't take it over the limit, do it
; 2424 : 						if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	edx, DWORD PTR _iItemValue$222436[ebp]
	add	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	jg	SHORT $LN2@DoAddVoteC

; 2425 : 						{
; 2426 : 							pDeal->AddVoteCommitment(eThem, iProposalID, iVoteChoice, iNumVotes, bRepeal);

	movzx	eax, BYTE PTR _bRepeal$222434[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumVotes$222433[ebp]
	push	ecx
	mov	edx, DWORD PTR _iVoteChoice$222432[ebp]
	push	edx
	mov	eax, DWORD PTR _iProposalID$222431[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::AddVoteCommitment

; 2427 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@DoAddVoteC:

; 2428 : 						}
; 2429 : 					}
; 2430 : 				}

	jmp	$LN4@DoAddVoteC
$LN3@DoAddVoteC:

; 2431 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _vDesiredCommitments$222425[ebp+4]
	push	edx
	mov	eax, DWORD PTR _vDesiredCommitments$222425[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDesiredCommitments$222425[ebp]
	call	?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN9@DoAddVoteC:

; 2432 : 		}
; 2433 : 	}
; 2434 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0:
	lea	ecx, DWORD PTR _vDesiredCommitments$222425[ebp]
	jmp	??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
__unwindfunclet$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$1:
	lea	ecx, DWORD PTR _vDesiredCommitments$222425[ebp]
	jmp	??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>
__ehhandler$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddVoteCommitmentToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddVoteCommitmentToThem
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$1
__ehfuncinfo$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -160						; size = 4
$T226377 = -148						; size = 4
$T226373 = -144						; size = 4
_iItemValue$222464 = -140				; size = 4
_iVoteChoice$222460 = -136				; size = 4
_bRepeal$222462 = -129					; size = 1
_iProposalID$222459 = -128				; size = 4
_iNumVotes$222461 = -124				; size = 4
_it$222455 = -120					; size = 4
_vDesiredCommitments$222453 = -116			; size = 96
__$ArrayPad$ = -20					; size = 4
_eMyPlayer$222451 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddVoteCommitmentToUs, COMDAT
; _this$ = ecx

; 2438 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2439 : 	CvAssert(eThem >= 0);
; 2440 : 	CvAssert(eThem < MAX_MAJOR_CIVS)
; 2441 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Vote Commitment to Us, but them is us. Please send Anton your save file and version.");
; 2442 : 
; 2443 : 	if(!bDontChangeMyExistingItems)

	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	eax, eax
	jne	$LN9@DoAddVoteC@2

; 2444 : 	{
; 2445 : 		if(iTotalValue > 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	$LN9@DoAddVoteC@2

; 2446 : 		{
; 2447 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226373[ebp], eax
	mov	edx, DWORD PTR $T226373[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222451[ebp], eax

; 2448 : 
; 2449 : 			// Can't already be a Vote Commitment in the Deal
; 2450 : 			if(!pDeal->IsVoteCommitmentTrade(eThem) && !pDeal->IsVoteCommitmentTrade(eMyPlayer))

	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	movzx	edx, al
	test	edx, edx
	jne	$LN9@DoAddVoteC@2
	mov	eax, DWORD PTR _eMyPlayer$222451[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsVoteCommitmentTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsVoteCommitmentTrade
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN9@DoAddVoteC@2

; 2451 : 			{
; 2452 : 				CvLeagueAI::VoteCommitmentList vDesiredCommitments = GET_PLAYER(eThem).GetLeagueAI()->GetDesiredVoteCommitments(eMyPlayer);

	mov	edx, DWORD PTR _eThem$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226377[ebp], edx
	mov	eax, DWORD PTR _eMyPlayer$222451[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDesiredCommitments$222453[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226377[ebp]
	call	?GetLeagueAI@CvPlayer@@QBEPAVCvLeagueAI@@XZ ; CvPlayer::GetLeagueAI
	mov	ecx, eax
	call	?GetDesiredVoteCommitments@CvLeagueAI@@QAE?AV?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@W4PlayerTypes@@@Z ; CvLeagueAI::GetDesiredVoteCommitments
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2453 : 				for (CvLeagueAI::VoteCommitmentList::iterator it = vDesiredCommitments.begin(); it != vDesiredCommitments.end(); ++it)

	mov	edx, DWORD PTR _vDesiredCommitments$222453[ebp]
	mov	DWORD PTR _it$222455[ebp], edx
	jmp	SHORT $LN20@DoAddVoteC@2
$LN4@DoAddVoteC@2:
	mov	eax, DWORD PTR _it$222455[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _it$222455[ebp], eax
$LN20@DoAddVoteC@2:
	mov	ecx, DWORD PTR _vDesiredCommitments$222453[ebp+4]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR _vDesiredCommitments$222453[ebp]
	cmp	DWORD PTR _it$222455[ebp], ecx
	je	$LN3@DoAddVoteC@2

; 2454 : 				{
; 2455 : 					int iProposalID = it->iResolutionID;

	mov	edx, DWORD PTR _it$222455[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iProposalID$222459[ebp], eax

; 2456 : 					int iVoteChoice = it->iVoteChoice;

	mov	ecx, DWORD PTR _it$222455[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _iVoteChoice$222460[ebp], edx

; 2457 : 					int iNumVotes = it->iNumVotes;

	mov	eax, DWORD PTR _it$222455[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iNumVotes$222461[ebp], ecx

; 2458 : 					bool bRepeal = !it->bEnact;

	mov	edx, DWORD PTR _it$222455[ebp]
	movzx	eax, BYTE PTR [edx+16]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	mov	BYTE PTR _bRepeal$222462[ebp], al

; 2459 : 
; 2460 : 					if (iProposalID != -1 && pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_VOTE_COMMITMENT, iProposalID, iVoteChoice, iNumVotes, bRepeal))

	cmp	DWORD PTR _iProposalID$222459[ebp], -1
	je	$LN2@DoAddVoteC@2
	push	0
	push	1
	movzx	ecx, BYTE PTR _bRepeal$222462[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumVotes$222461[ebp]
	push	edx
	mov	eax, DWORD PTR _iVoteChoice$222460[ebp]
	push	eax
	mov	ecx, DWORD PTR _iProposalID$222459[ebp]
	push	ecx
	push	19					; 00000013H
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	eax, DWORD PTR _eMyPlayer$222451[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@DoAddVoteC@2

; 2461 : 					{
; 2462 : 						int iItemValue = GetTradeItemValue(TRADE_ITEM_VOTE_COMMITMENT, /*bFromMe*/ true, eThem, iProposalID, iVoteChoice, iNumVotes, bRepeal, -1, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	push	-1
	movzx	eax, BYTE PTR _bRepeal$222462[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumVotes$222461[ebp]
	push	ecx
	mov	edx, DWORD PTR _iVoteChoice$222460[ebp]
	push	edx
	mov	eax, DWORD PTR _iProposalID$222459[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	push	1
	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222464[ebp], eax

; 2463 : 
; 2464 : 						// If adding this to the deal doesn't take it under the min limit, do it
; 2465 : 						if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	edx, DWORD PTR _iItemValue$222464[ebp]
	neg	edx
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	add	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	jl	SHORT $LN2@DoAddVoteC@2

; 2466 : 						{
; 2467 : 							pDeal->AddVoteCommitment(eMyPlayer, iProposalID, iVoteChoice, iNumVotes, bRepeal);

	movzx	ecx, BYTE PTR _bRepeal$222462[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumVotes$222461[ebp]
	push	edx
	mov	eax, DWORD PTR _iVoteChoice$222460[ebp]
	push	eax
	mov	ecx, DWORD PTR _iProposalID$222459[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$222451[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddVoteCommitment@CvDeal@@QAEXW4PlayerTypes@@HHH_N@Z ; CvDeal::AddVoteCommitment

; 2468 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@DoAddVoteC@2:

; 2469 : 						}
; 2470 : 					}
; 2471 : 				}

	jmp	$LN4@DoAddVoteC@2
$LN3@DoAddVoteC@2:

; 2472 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _vDesiredCommitments$222453[ebp+4]
	push	edx
	mov	eax, DWORD PTR _vDesiredCommitments$222453[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDesiredCommitments$222453[ebp]
	call	?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN9@DoAddVoteC@2:

; 2473 : 		}
; 2474 : 	}
; 2475 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0:
	lea	ecx, DWORD PTR _vDesiredCommitments$222453[ebp]
	jmp	??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
__unwindfunclet$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$1:
	lea	ecx, DWORD PTR _vDesiredCommitments$222453[ebp]
	jmp	??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>
__ehhandler$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddVoteCommitmentToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddVoteCommitmentToUs
EXTRN	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z:PROC ; CvDeal::AddResourceTrade
EXTRN	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z:PROC ; CvDeal::ChangeResourceTrade
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
; Function compile flags: /Odtp
;	COMDAT ?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
tv254 = -60						; size = 4
_this$ = -56						; size = 4
$T226445 = -52						; size = 4
$T226439 = -48						; size = 4
$T226435 = -44						; size = 4
$T226431 = -40						; size = 4
$T226427 = -36						; size = 4
$T226418 = -32						; size = 4
_pkResourceInfo$222501 = -28				; size = 4
_pkResourceInfo$222489 = -24				; size = 4
_iResourceLoop$222482 = -20				; size = 4
_iResourceQuantity$222484 = -16				; size = 4
_eMyPlayer$222480 = -12					; size = 4
_iItemValue$222481 = -8					; size = 4
_eResource$222483 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddResourceToThem, COMDAT
; _this$ = ecx

; 2479 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 2480 : 	CvAssert(eThem >= 0);
; 2481 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2482 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Resource to Them, but them is us.  Please show Jon");
; 2483 : 
; 2484 : 	if(!bDontChangeTheirExistingItems)

	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	eax, eax
	jne	$LN22@DoAddResou

; 2485 : 	{
; 2486 : 		if(iTotalValue < 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	$LN22@DoAddResou

; 2487 : 		{
; 2488 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226427[ebp], eax
	mov	edx, DWORD PTR $T226427[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222480[ebp], eax

; 2489 : 
; 2490 : 			int iItemValue;
; 2491 : 
; 2492 : #ifdef AUI_WARNING_FIXES
; 2493 : 			uint iResourceLoop;
; 2494 : #else
; 2495 : 			int iResourceLoop;
; 2496 : #endif
; 2497 : 			ResourceTypes eResource;
; 2498 : 			int iResourceQuantity;
; 2499 : 
; 2500 : 			// Look to trade Luxuries first
; 2501 : 			for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$222482[ebp], 0
	jmp	SHORT $LN19@DoAddResou
$LN18@DoAddResou:
	mov	ecx, DWORD PTR _iResourceLoop$222482[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$222482[ebp], ecx
$LN19@DoAddResou:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222482[ebp], eax
	jge	$LN17@DoAddResou

; 2502 : 			{
; 2503 : 				eResource = (ResourceTypes) iResourceLoop;

	mov	edx, DWORD PTR _iResourceLoop$222482[ebp]
	mov	DWORD PTR _eResource$222483[ebp], edx

; 2504 : 
; 2505 : 				const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$222483[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$222489[ebp], eax

; 2506 : 				if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _pkResourceInfo$222489[ebp], 0
	je	SHORT $LN15@DoAddResou
	mov	ecx, DWORD PTR _pkResourceInfo$222489[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	je	SHORT $LN16@DoAddResou
$LN15@DoAddResou:

; 2507 : 					continue;

	jmp	SHORT $LN18@DoAddResou
$LN16@DoAddResou:

; 2508 : 
; 2509 : 				iResourceQuantity = GET_PLAYER(eThem).getNumResourceAvailable(eResource, false);

	mov	ecx, DWORD PTR _eThem$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226431[ebp], ecx
	push	0
	mov	edx, DWORD PTR _eResource$222483[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226431[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iResourceQuantity$222484[ebp], eax

; 2510 : 
; 2511 : 				// Don't bother looking at this Resource if the other player doesn't even have any of it
; 2512 : 				if(iResourceQuantity <= 0)

	cmp	DWORD PTR _iResourceQuantity$222484[ebp], 0
	jg	SHORT $LN14@DoAddResou

; 2513 : 					continue;

	jmp	SHORT $LN18@DoAddResou
$LN14@DoAddResou:

; 2514 : 
; 2515 : 				// Don't bother if we wouldn't get Happiness from it due to World Congress
; 2516 : 				if(GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(eMyPlayer, eResource))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226435[ebp], eax
	mov	ecx, DWORD PTR _eResource$222483[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$222480[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226435[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@DoAddResou

; 2517 : 					continue;

	jmp	$LN18@DoAddResou
$LN13@DoAddResou:

; 2518 : 
; 2519 : 				// Quantity is always 1 if it's a Luxury, 5 if Strategic
; 2520 : 				iResourceQuantity = 1;

	mov	DWORD PTR _iResourceQuantity$222484[ebp], 1

; 2521 : 
; 2522 : 				// See if they can actually trade it to us
; 2523 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR _iResourceQuantity$222484[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$222483[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _eMyPlayer$222480[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	$LN12@DoAddResou

; 2524 : 				{
; 2525 : 					iItemValue = GetTradeItemValue(TRADE_ITEM_RESOURCES, /*bFromMe*/ false, eThem, eResource, iResourceQuantity, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	push	0
	push	-1
	mov	edx, DWORD PTR _iResourceQuantity$222484[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222483[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222481[ebp], eax

; 2526 : 
; 2527 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2528 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	eax, DWORD PTR _iItemValue$222481[ebp]
	add	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	jg	SHORT $LN12@DoAddResou

; 2529 : 					{
; 2530 : 						// Try to change the current item if it already exists, otherwise add it
; 2531 : 						if(!pDeal->ChangeResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration))

	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iResourceQuantity$222484[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222483[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@DoAddResou

; 2532 : 						{
; 2533 : 							pDeal->AddResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration);

	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iResourceQuantity$222484[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$222483[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 2534 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN12@DoAddResou:

; 2535 : 						}
; 2536 : 					}
; 2537 : 				}
; 2538 : 			}

	jmp	$LN18@DoAddResou
$LN17@DoAddResou:

; 2539 : 
; 2540 : 			// Now look at Strategic Resources
; 2541 : 			for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$222482[ebp], 0
	jmp	SHORT $LN9@DoAddResou
$LN8@DoAddResou:
	mov	eax, DWORD PTR _iResourceLoop$222482[ebp]
	add	eax, 1
	mov	DWORD PTR _iResourceLoop$222482[ebp], eax
$LN9@DoAddResou:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222482[ebp], eax
	jge	$LN22@DoAddResou

; 2542 : 			{
; 2543 : 				eResource = (ResourceTypes) iResourceLoop;

	mov	ecx, DWORD PTR _iResourceLoop$222482[ebp]
	mov	DWORD PTR _eResource$222483[ebp], ecx

; 2544 : 
; 2545 : 				const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	edx, DWORD PTR _eResource$222483[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$222501[ebp], eax

; 2546 : 				if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _pkResourceInfo$222501[ebp], 0
	je	SHORT $LN5@DoAddResou
	mov	ecx, DWORD PTR _pkResourceInfo$222501[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN6@DoAddResou
$LN5@DoAddResou:

; 2547 : 					continue;

	jmp	SHORT $LN8@DoAddResou
$LN6@DoAddResou:

; 2548 : 
; 2549 : 				iResourceQuantity = GET_PLAYER(eThem).getNumResourceAvailable(eResource, false);

	mov	eax, DWORD PTR _eThem$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226439[ebp], eax
	push	0
	mov	ecx, DWORD PTR _eResource$222483[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226439[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iResourceQuantity$222484[ebp], eax

; 2550 : 
; 2551 : 				// Don't bother looking at this Resource if the other player doesn't even have any of it
; 2552 : 				if(iResourceQuantity <= 0)

	cmp	DWORD PTR _iResourceQuantity$222484[ebp], 0
	jg	SHORT $LN4@DoAddResou

; 2553 : 					continue;

	jmp	SHORT $LN8@DoAddResou
$LN4@DoAddResou:

; 2554 : 
; 2555 : 				// Quantity is always 1 if it's a Luxury, 5 if Strategic
; 2556 : 				iResourceQuantity = min(5, iResourceQuantity);	// 5 or what they have, whichever is less

	mov	DWORD PTR $T226418[ebp], 5
	mov	edx, DWORD PTR _iResourceQuantity$222484[ebp]
	cmp	edx, DWORD PTR $T226418[ebp]
	jge	SHORT $LN36@DoAddResou
	lea	eax, DWORD PTR _iResourceQuantity$222484[ebp]
	mov	DWORD PTR tv254[ebp], eax
	jmp	SHORT $LN37@DoAddResou
$LN36@DoAddResou:
	lea	ecx, DWORD PTR $T226418[ebp]
	mov	DWORD PTR tv254[ebp], ecx
$LN37@DoAddResou:
	mov	edx, DWORD PTR tv254[ebp]
	mov	DWORD PTR $T226445[ebp], edx
	mov	eax, DWORD PTR $T226445[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iResourceQuantity$222484[ebp], ecx

; 2557 : 
; 2558 : 				// See if they can actually trade it to us
; 2559 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	push	0
	push	1
	push	0
	push	-1
	mov	edx, DWORD PTR _iResourceQuantity$222484[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222483[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _eMyPlayer$222480[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	$LN3@DoAddResou

; 2560 : 				{
; 2561 : 					iItemValue = GetTradeItemValue(TRADE_ITEM_RESOURCES, /*bFromMe*/ false, eThem, eResource, iResourceQuantity, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	push	0
	push	-1
	mov	eax, DWORD PTR _iResourceQuantity$222484[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$222483[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222481[ebp], eax

; 2562 : 
; 2563 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2564 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	eax, DWORD PTR _iTotalValue$[ebp]
	mov	ecx, DWORD PTR _iItemValue$222481[ebp]
	add	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	jg	SHORT $LN3@DoAddResou

; 2565 : 					{
; 2566 : 						// Try to change the current item if it already exists, otherwise add it
; 2567 : 						if(!pDeal->ChangeResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration))

	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _iResourceQuantity$222484[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$222483[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@DoAddResou

; 2568 : 						{
; 2569 : 							pDeal->AddResourceTrade(eThem, eResource, iResourceQuantity, iDealDuration);

	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iResourceQuantity$222484[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222483[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 2570 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@DoAddResou:

; 2571 : 						}
; 2572 : 					}
; 2573 : 				}
; 2574 : 			}

	jmp	$LN8@DoAddResou
$LN22@DoAddResou:

; 2575 : 		}
; 2576 : 	}
; 2577 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?DoAddResourceToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddResourceToThem
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
tv185 = -52						; size = 4
_this$ = -48						; size = 4
$T226474 = -44						; size = 4
$T226468 = -40						; size = 4
$T226464 = -36						; size = 4
$T226460 = -32						; size = 4
$T226451 = -28						; size = 4
_pkResourceInfo$222533 = -24				; size = 4
_iResourceLoop$222527 = -20				; size = 4
_iResourceQuantity$222526 = -16				; size = 4
_eMyPlayer$222523 = -12					; size = 4
_iItemValue$222524 = -8					; size = 4
_eResource$222525 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddResourceToUs, COMDAT
; _this$ = ecx

; 2581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 2582 : 	CvAssert(eThem >= 0);
; 2583 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2584 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Resource to Us, but them is us.  Please show Jon");
; 2585 : 
; 2586 : 	if(!bDontChangeMyExistingItems)

	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	eax, eax
	jne	$LN14@DoAddResou@2

; 2587 : 	{
; 2588 : 		if(iTotalValue > 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	$LN14@DoAddResou@2

; 2589 : 		{
; 2590 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226460[ebp], eax
	mov	edx, DWORD PTR $T226460[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222523[ebp], eax

; 2591 : 
; 2592 : 			int iItemValue;
; 2593 : 
; 2594 : 			ResourceTypes eResource;
; 2595 : 			int iResourceQuantity;
; 2596 : #ifdef AUI_WARNING_FIXES
; 2597 : 			for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2598 : #else
; 2599 : 			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$222527[ebp], 0
	jmp	SHORT $LN11@DoAddResou@2
$LN10@DoAddResou@2:
	mov	ecx, DWORD PTR _iResourceLoop$222527[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$222527[ebp], ecx
$LN11@DoAddResou@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222527[ebp], eax
	jge	$LN14@DoAddResou@2

; 2600 : #endif
; 2601 : 			{
; 2602 : 				eResource = (ResourceTypes) iResourceLoop;

	mov	edx, DWORD PTR _iResourceLoop$222527[ebp]
	mov	DWORD PTR _eResource$222525[ebp], edx

; 2603 : 				iResourceQuantity = GET_PLAYER(eMyPlayer).getNumResourceAvailable(eResource, false);

	mov	eax, DWORD PTR _eMyPlayer$222523[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226464[ebp], eax
	push	0
	mov	ecx, DWORD PTR _eResource$222525[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226464[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iResourceQuantity$222526[ebp], eax

; 2604 : 
; 2605 : 				// Don't bother looking at this Resource if we don't even have any of it
; 2606 : 				if(iResourceQuantity == 0)

	cmp	DWORD PTR _iResourceQuantity$222526[ebp], 0
	jne	SHORT $LN8@DoAddResou@2

; 2607 : 				{
; 2608 : 					continue;

	jmp	SHORT $LN10@DoAddResou@2
$LN8@DoAddResou@2:

; 2609 : 				}
; 2610 : 
; 2611 : 				const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	edx, DWORD PTR _eResource$222525[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$222533[ebp], eax

; 2612 : 				if (pkResourceInfo == NULL)

	cmp	DWORD PTR _pkResourceInfo$222533[ebp], 0
	jne	SHORT $LN7@DoAddResou@2

; 2613 : 					continue;

	jmp	SHORT $LN10@DoAddResou@2
$LN7@DoAddResou@2:

; 2614 : 
; 2615 : 				// Quantity is always 1 if it's a Luxury, 5 if Strategic
; 2616 : 				if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _pkResourceInfo$222533[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN6@DoAddResou@2

; 2617 : 				{
; 2618 : 					iResourceQuantity = 1;

	mov	DWORD PTR _iResourceQuantity$222526[ebp], 1

; 2619 : 
; 2620 : 					// Don't bother if they wouldn't get Happiness from it due to World Congress
; 2621 : 					if(GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(eThem, eResource))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226468[ebp], eax
	mov	ecx, DWORD PTR _eResource$222525[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226468[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@DoAddResou@2

; 2622 : 						continue;

	jmp	$LN10@DoAddResou@2
$LN5@DoAddResou@2:

; 2623 : 				}
; 2624 : 				else

	jmp	SHORT $LN4@DoAddResou@2
$LN6@DoAddResou@2:

; 2625 : 				{
; 2626 : 					iResourceQuantity = min(5, iResourceQuantity);	// 5 or what we have, whichever is less

	mov	DWORD PTR $T226451[ebp], 5
	mov	ecx, DWORD PTR _iResourceQuantity$222526[ebp]
	cmp	ecx, DWORD PTR $T226451[ebp]
	jge	SHORT $LN26@DoAddResou@2
	lea	edx, DWORD PTR _iResourceQuantity$222526[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $LN27@DoAddResou@2
$LN26@DoAddResou@2:
	lea	eax, DWORD PTR $T226451[ebp]
	mov	DWORD PTR tv185[ebp], eax
$LN27@DoAddResou@2:
	mov	ecx, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T226474[ebp], ecx
	mov	edx, DWORD PTR $T226474[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iResourceQuantity$222526[ebp], eax
$LN4@DoAddResou@2:

; 2627 : 				}
; 2628 : 
; 2629 : 				// See if we can actually trade it to them
; 2630 : 				if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR _iResourceQuantity$222526[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$222525[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyPlayer$222523[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	$LN3@DoAddResou@2

; 2631 : 				{
; 2632 : 					iItemValue = GetTradeItemValue(TRADE_ITEM_RESOURCES, /*bFromMe*/ true, eThem, eResource, iResourceQuantity, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	push	0
	push	-1
	mov	edx, DWORD PTR _iResourceQuantity$222526[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222525[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	push	1
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222524[ebp], eax

; 2633 : 
; 2634 : 					// If adding this to the deal doesn't take it under the min limit, do it
; 2635 : 					if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	edx, DWORD PTR _iItemValue$222524[ebp]
	neg	edx
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	add	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	jl	SHORT $LN3@DoAddResou@2

; 2636 : 					{
; 2637 : 						// Try to change the current item if it already exists, otherwise add it
; 2638 : 						if(!pDeal->ChangeResourceTrade(eMyPlayer, eResource, iResourceQuantity, iDealDuration))

	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iResourceQuantity$222526[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$222525[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyPlayer$222523[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeResourceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::ChangeResourceTrade
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@DoAddResou@2

; 2639 : 						{
; 2640 : 							pDeal->AddResourceTrade(eMyPlayer, eResource, iResourceQuantity, iDealDuration);

	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iResourceQuantity$222526[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$222525[ebp]
	push	edx
	mov	eax, DWORD PTR _eMyPlayer$222523[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 2641 : 							iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@DoAddResou@2:

; 2642 : 						}
; 2643 : 					}
; 2644 : 				}
; 2645 : 			}

	jmp	$LN10@DoAddResou@2
$LN14@DoAddResou@2:

; 2646 : 		}
; 2647 : 	}
; 2648 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?DoAddResourceToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddResourceToUs
_TEXT	ENDS
EXTRN	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::AddAllowEmbassy
EXTRN	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsAllowEmbassyTrade
; Function compile flags: /Odtp
;	COMDAT ?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T226488 = -12						; size = 4
_iItemValue$222558 = -8					; size = 4
_eMyPlayer$222556 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddEmbassyToThem, COMDAT
; _this$ = ecx

; 2653 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2654 : 	CvAssert(eThem >= 0);
; 2655 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2656 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Embassy to Them, but them is us.  Please show Jon");
; 2657 : 
; 2658 : 	if(!bDontChangeTheirExistingItems)

	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	eax, eax
	jne	$LN6@DoAddEmbas

; 2659 : 	{
; 2660 : 		if(iTotalValue < 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	$LN6@DoAddEmbas

; 2661 : 		{
; 2662 : 			if(!pDeal->IsAllowEmbassyTrade(eThem))

	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsAllowEmbassyTrade
	movzx	eax, al
	test	eax, eax
	jne	$LN6@DoAddEmbas

; 2663 : 			{
; 2664 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226488[ebp], eax
	mov	ecx, DWORD PTR $T226488[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _eMyPlayer$222556[ebp], edx

; 2665 : 
; 2666 : 				// See if they can actually trade it to us
; 2667 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_ALLOW_EMBASSY))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	mov	eax, DWORD PTR _eMyPlayer$222556[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@DoAddEmbas

; 2668 : 				{
; 2669 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_ALLOW_EMBASSY, /*bFromMe*/ false, eThem, -1, -1, -1, /*bFlag1*/false, -1, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	push	-1
	push	0
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	push	0
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222558[ebp], eax

; 2670 : 
; 2671 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2672 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	eax, DWORD PTR _iItemValue$222558[ebp]
	add	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	jg	SHORT $LN6@DoAddEmbas

; 2673 : 					{
; 2674 : 						pDeal->AddAllowEmbassy(eThem);

	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddAllowEmbassy

; 2675 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@DoAddEmbas:

; 2676 : 					}
; 2677 : 				}
; 2678 : 			}
; 2679 : 		}
; 2680 : 	}
; 2681 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DoAddEmbassyToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddEmbassyToThem
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T226499 = -12						; size = 4
_iItemValue$222576 = -8					; size = 4
_eMyPlayer$222573 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddEmbassyToUs, COMDAT
; _this$ = ecx

; 2685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2686 : 	CvAssert(eThem >= 0);
; 2687 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2688 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Embassy to Us, but them is us.  Please show Jon");
; 2689 : 
; 2690 : 	if(!bDontChangeMyExistingItems)

	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	eax, eax
	jne	$LN6@DoAddEmbas@2

; 2691 : 	{
; 2692 : 		if(iTotalValue > 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	$LN6@DoAddEmbas@2

; 2693 : 		{
; 2694 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226499[ebp], eax
	mov	edx, DWORD PTR $T226499[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222573[ebp], eax

; 2695 : 
; 2696 : 			if(!pDeal->IsAllowEmbassyTrade(eMyPlayer))

	mov	ecx, DWORD PTR _eMyPlayer$222573[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsAllowEmbassyTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsAllowEmbassyTrade
	movzx	edx, al
	test	edx, edx
	jne	$LN6@DoAddEmbas@2

; 2697 : 			{
; 2698 : 				// See if we can actually trade it to them
; 2699 : 				if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_ALLOW_EMBASSY))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyPlayer$222573[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@DoAddEmbas@2

; 2700 : 				{
; 2701 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_ALLOW_EMBASSY, /*bFromMe*/ true, eThem, -1, -1, -1, /*bFlag1*/false, -1, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	push	-1
	push	0
	push	-1
	push	-1
	push	-1
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	push	1
	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222576[ebp], eax

; 2702 : 
; 2703 : 					// If adding this to the deal doesn't take it under the min limit, do it
; 2704 : 					if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	edx, DWORD PTR _iItemValue$222576[ebp]
	neg	edx
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	add	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	jl	SHORT $LN6@DoAddEmbas@2

; 2705 : 					{
; 2706 : 						pDeal->AddAllowEmbassy(eMyPlayer);

	mov	ecx, DWORD PTR _eMyPlayer$222573[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddAllowEmbassy

; 2707 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@DoAddEmbas@2:

; 2708 : 					}
; 2709 : 				}
; 2710 : 			}
; 2711 : 		}
; 2712 : 	}
; 2713 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DoAddEmbassyToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddEmbassyToUs
_TEXT	ENDS
EXTRN	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddOpenBorders
EXTRN	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDeal::IsOpenBordersTrade
; Function compile flags: /Odtp
;	COMDAT ?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T226510 = -12						; size = 4
_iItemValue$222595 = -8					; size = 4
_eMyPlayer$222593 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountOverWeWillRequest$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddOpenBordersToThem, COMDAT
; _this$ = ecx

; 2717 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2718 : 	CvAssert(eThem >= 0);
; 2719 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2720 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Open Borders to Them, but them is us.  Please show Jon");
; 2721 : 
; 2722 : 	if(!bDontChangeTheirExistingItems)

	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	eax, eax
	jne	$LN6@DoAddOpenB

; 2723 : 	{
; 2724 : 		if(iTotalValue < 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	$LN6@DoAddOpenB

; 2725 : 		{
; 2726 : 			if(!pDeal->IsOpenBordersTrade(eThem))

	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsOpenBordersTrade
	movzx	eax, al
	test	eax, eax
	jne	$LN6@DoAddOpenB

; 2727 : 			{
; 2728 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226510[ebp], eax
	mov	ecx, DWORD PTR $T226510[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _eMyPlayer$222593[ebp], edx

; 2729 : 
; 2730 : 				// See if they can actually trade it to us
; 2731 : 				if(pDeal->IsPossibleToTradeItem(eThem, eMyPlayer, TRADE_ITEM_OPEN_BORDERS))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	mov	eax, DWORD PTR _eMyPlayer$222593[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@DoAddOpenB

; 2732 : 				{
; 2733 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_OPEN_BORDERS, /*bFromMe*/ false, eThem, -1, -1, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	push	0
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	push	0
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222595[ebp], eax

; 2734 : 
; 2735 : 					// If adding this to the deal doesn't take it over the limit, do it
; 2736 : 					if(iItemValue + iTotalValue <= iAmountOverWeWillRequest)

	mov	eax, DWORD PTR _iTotalValue$[ebp]
	mov	ecx, DWORD PTR _iItemValue$222595[ebp]
	add	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _iAmountOverWeWillRequest$[ebp]
	jg	SHORT $LN6@DoAddOpenB

; 2737 : 					{
; 2738 : 						pDeal->AddOpenBorders(eThem, iDealDuration);

	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders

; 2739 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@DoAddOpenB:

; 2740 : 					}
; 2741 : 				}
; 2742 : 			}
; 2743 : 		}
; 2744 : 	}
; 2745 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?DoAddOpenBordersToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddOpenBordersToThem
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T226521 = -12						; size = 4
_iItemValue$222614 = -8					; size = 4
_eMyPlayer$222611 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_iDealDuration$ = 36					; size = 4
_bUseEvenValue$ = 40					; size = 1
?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z PROC ; CvDealAI::DoAddOpenBordersToUs, COMDAT
; _this$ = ecx

; 2749 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2750 : 	CvAssert(eThem >= 0);
; 2751 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2752 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Open Borders to Us, but them is us.  Please show Jon");
; 2753 : 
; 2754 : 	if(!bDontChangeMyExistingItems)

	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	eax, eax
	jne	$LN6@DoAddOpenB@2

; 2755 : 	{
; 2756 : 		if(iTotalValue > 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	$LN6@DoAddOpenB@2

; 2757 : 		{
; 2758 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226521[ebp], eax
	mov	edx, DWORD PTR $T226521[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222611[ebp], eax

; 2759 : 
; 2760 : 			if(!pDeal->IsOpenBordersTrade(eMyPlayer))

	mov	ecx, DWORD PTR _eMyPlayer$222611[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsOpenBordersTrade@CvDeal@@QAE_NW4PlayerTypes@@@Z ; CvDeal::IsOpenBordersTrade
	movzx	edx, al
	test	edx, edx
	jne	$LN6@DoAddOpenB@2

; 2761 : 			{
; 2762 : 				// See if we can actually trade it to them
; 2763 : 				if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_OPEN_BORDERS))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyPlayer$222611[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@DoAddOpenB@2

; 2764 : 				{
; 2765 : 					int iItemValue = GetTradeItemValue(TRADE_ITEM_OPEN_BORDERS, /*bFromMe*/ true, eThem, -1, -1, -1, /*bFlag1*/false, iDealDuration, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	push	0
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	push	1
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTradeItemValue@CvDealAI@@QAEHW4TradeableItems@@_NW4PlayerTypes@@HHH1H1@Z ; CvDealAI::GetTradeItemValue
	mov	DWORD PTR _iItemValue$222614[ebp], eax

; 2766 : 
; 2767 : 					// If adding this to the deal doesn't take it under the min limit, do it
; 2768 : 					if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	eax, DWORD PTR _iItemValue$222614[ebp]
	neg	eax
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	add	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	jl	SHORT $LN6@DoAddOpenB@2

; 2769 : 					{
; 2770 : 						pDeal->AddOpenBorders(eMyPlayer, iDealDuration);

	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _eMyPlayer$222611[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders

; 2771 : 						iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@DoAddOpenB@2:

; 2772 : 					}
; 2773 : 				}
; 2774 : 			}
; 2775 : 		}
; 2776 : 	}
; 2777 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?DoAddOpenBordersToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33HH2@Z ENDP ; CvDealAI::DoAddOpenBordersToUs
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@H$00$0A@@@QAE@XZ		; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
PUBLIC	?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ	; CvWeightedVector<int,1,0>::SortItems
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
PUBLIC	__$ArrayPad$
EXTRN	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddCityTrade
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0
__ehfuncinfo$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
_this$ = -212						; size = 4
$T226698 = -196						; size = 4
$T226689 = -192						; size = 4
$T226680 = -188						; size = 4
$T226671 = -184						; size = 4
$T226650 = -180						; size = 4
_weightedElem$226630 = -168				; size = 8
$T226624 = -160						; size = 4
$T226578 = -112						; size = 4
$T226569 = -108						; size = 4
$T226556 = -104						; size = 4
$T226547 = -100						; size = 4
$T226535 = -96						; size = 4
$T226525 = -92						; size = 4
_iItemValue$222869 = -88				; size = 4
_iSortedCityIndex$222864 = -84				; size = 4
_iWinnerCapitalX$ = -80					; size = 4
_iCityLoop$ = -76					; size = 4
_eMyPlayer$ = -72					; size = 4
_iSortedCityID$ = -68					; size = 4
_pWinnerCapital$ = -64					; size = 4
_iCityDistanceFromWinnersCapital$ = -60			; size = 4
_viCityProximities$ = -56				; size = 24
__$ArrayPad$ = -32					; size = 4
_pLosingPlayer$ = -28					; size = 4
_iWinnerCapitalY$ = -24					; size = 4
_pLoopCity$ = -20					; size = 4
_pWinningPlayer$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iAmountUnderWeWillOffer$ = 32				; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddCitiesToUs, COMDAT
; _this$ = ecx

; 2781 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2782 : 	CvAssert(eThem >= 0);
; 2783 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2784 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Open Borders to Us, but them is us.  Please show Jon");
; 2785 : 
; 2786 : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226535[ebp], eax
	mov	eax, DWORD PTR $T226535[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _eMyPlayer$[ebp], ecx

; 2787 : 
; 2788 : 	// If we're not the one surrendering here, don't bother
; 2789 : 	if(pDeal->GetSurrenderingPlayer() != eMyPlayer)

	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetSurrenderingPlayer@CvDeal@@QBE?AW4PlayerTypes@@XZ ; CvDeal::GetSurrenderingPlayer
	cmp	eax, DWORD PTR _eMyPlayer$[ebp]
	je	SHORT $LN15@DoAddCitie

; 2790 : 		return;

	jmp	$LN16@DoAddCitie
$LN15@DoAddCitie:

; 2791 : 
; 2792 : 	// Don't change things
; 2793 : 	if(bDontChangeMyExistingItems)

	movzx	edx, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	edx, edx
	je	SHORT $LN14@DoAddCitie

; 2794 : 		return;

	jmp	$LN16@DoAddCitie
$LN14@DoAddCitie:

; 2795 : 
; 2796 : 	// We don't owe them anything
; 2797 : 	if(iTotalValue <= 0)

	mov	eax, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN13@DoAddCitie

; 2798 : 		return;

	jmp	$LN16@DoAddCitie
$LN13@DoAddCitie:

; 2799 : 
; 2800 : 	CvPlayer* pLosingPlayer = GetPlayer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR _pLosingPlayer$[ebp], eax

; 2801 : 	CvPlayer* pWinningPlayer = &GET_PLAYER(eThem);

	mov	ecx, DWORD PTR _eThem$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pWinningPlayer$[ebp], ecx

; 2802 : 
; 2803 : 	// If the player only has 1 City then we can't get any more from him
; 2804 : 	if(pLosingPlayer->getNumCities() == 1)

	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jne	SHORT $LN12@DoAddCitie

; 2805 : 		return;

	jmp	$LN16@DoAddCitie
$LN12@DoAddCitie:

; 2806 : 
; 2807 : 	//int iCityValue = 0;
; 2808 : 
; 2809 : 	int iCityDistanceFromWinnersCapital = 0;

	mov	DWORD PTR _iCityDistanceFromWinnersCapital$[ebp], 0

; 2810 : 	int iWinnerCapitalX = -1, iWinnerCapitalY = -1;

	mov	DWORD PTR _iWinnerCapitalX$[ebp], -1
	mov	DWORD PTR _iWinnerCapitalY$[ebp], -1

; 2811 : 
; 2812 : 	// If winner has no capital then we can't use proximity - it will stay at 0
; 2813 : 	CvCity* pWinnerCapital = pWinningPlayer->getCapitalCity();

	mov	ecx, DWORD PTR _pWinningPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pWinnerCapital$[ebp], eax

; 2814 : 	if(pWinnerCapital != NULL)

	cmp	DWORD PTR _pWinnerCapital$[ebp], 0
	je	SHORT $LN11@DoAddCitie

; 2815 : 	{
; 2816 : 		iWinnerCapitalX = pWinningPlayer->getCapitalCity()->getX();

	mov	ecx, DWORD PTR _pWinningPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR $T226547[ebp], eax
	mov	edx, DWORD PTR $T226547[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iWinnerCapitalX$[ebp], eax

; 2817 : 		iWinnerCapitalY = pWinningPlayer->getCapitalCity()->getY();

	mov	ecx, DWORD PTR _pWinningPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR $T226556[ebp], eax
	mov	ecx, DWORD PTR $T226556[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iWinnerCapitalY$[ebp], edx
$LN11@DoAddCitie:

; 2818 : 	}
; 2819 : 
; 2820 : 	// Create vector of the losing players' Cities so we can see which are the closest to the winner
; 2821 : 	CvWeightedVector<int> viCityProximities;

	lea	ecx, DWORD PTR _viCityProximities$[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2822 : 
; 2823 : 	// Loop through all of the loser's Cities
; 2824 : 	CvCity* pLoopCity;
; 2825 : 	int iCityLoop;
; 2826 : 	for(pLoopCity = pLosingPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pLosingPlayer->nextCity(&iCityLoop))

	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN10@DoAddCitie
$LN9@DoAddCitie:
	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN10@DoAddCitie:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN8@DoAddCitie

; 2827 : 	{
; 2828 : 		// Get total city value of the loser
; 2829 : 		//iCityValue += GetCityValue(pLoopCity->getX(), pLoopCity->getY(), /*bFromMe*/ true, eThem, bUseEvenValue);
; 2830 : 		//iCityValue += GetCityValue(pLoopCity->getX(), pLoopCity->getY(), /*bFromMe*/ true, eThem, /*bUseEvenValue*/ true);
; 2831 : 
; 2832 : 		// If winner has no capital, Distance defaults to 0
; 2833 : 		if(pWinnerCapital != NULL)

	cmp	DWORD PTR _pWinnerCapital$[ebp], 0
	je	SHORT $LN7@DoAddCitie

; 2834 : 		{
; 2835 : 			iCityDistanceFromWinnersCapital = plotDistance(iWinnerCapitalX, iWinnerCapitalY, pLoopCity->getX(), pLoopCity->getY());

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T226569[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T226578[ebp], edx
	mov	eax, DWORD PTR $T226569[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226578[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWinnerCapitalY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iWinnerCapitalX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iCityDistanceFromWinnersCapital$[ebp], eax
$LN7@DoAddCitie:

; 2836 : 		}
; 2837 : 
; 2838 : 		// Don't include the capital in the list of Cities the winner can receive
; 2839 : 		if(!pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@DoAddCitie

; 2840 : 		{
; 2841 : 			viCityProximities.push_back(pLoopCity->GetID(), iCityDistanceFromWinnersCapital);

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR $T226624[ebp], eax
	mov	ecx, DWORD PTR $T226624[ebp]
	mov	DWORD PTR $T226525[ebp], ecx
	mov	DWORD PTR _weightedElem$226630[ebp], 0
	mov	DWORD PTR _weightedElem$226630[ebp+4], 0
	mov	edx, DWORD PTR $T226525[ebp]
	mov	DWORD PTR _weightedElem$226630[ebp], edx
	mov	eax, DWORD PTR _iCityDistanceFromWinnersCapital$[ebp]
	mov	DWORD PTR _weightedElem$226630[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$226630[ebp]
	push	ecx
	lea	ecx, DWORD PTR _viCityProximities$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back
$LN6@DoAddCitie:

; 2842 : 		}
; 2843 : 	}

	jmp	$LN9@DoAddCitie
$LN8@DoAddCitie:

; 2844 : 
; 2845 : 	// Sort the vector based on distance from winner's capital
; 2846 : 	viCityProximities.SortItems();

	lea	ecx, DWORD PTR _viCityProximities$[ebp]
	call	?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ ; CvWeightedVector<int,1,0>::SortItems

; 2847 : 
; 2848 : 	// Loop through sorted Cities and add them to the deal if they're under the amount to give up - start from the back of the list, because that's where the CLOSEST cities are
; 2849 : 	int iSortedCityID;
; 2850 : 	//			for (int iSortedCityIndex = 0; iSortedCityIndex < viCityProximities.size(); iSortedCityIndex++)
; 2851 : 	for(int iSortedCityIndex = viCityProximities.size() - 1; iSortedCityIndex > -1 ; iSortedCityIndex--)

	mov	edx, DWORD PTR _viCityProximities$[ebp+4]
	mov	DWORD PTR $T226650[ebp], edx
	mov	eax, DWORD PTR $T226650[ebp]
	sub	eax, 1
	mov	DWORD PTR _iSortedCityIndex$222864[ebp], eax
	jmp	SHORT $LN5@DoAddCitie
$LN4@DoAddCitie:
	mov	ecx, DWORD PTR _iSortedCityIndex$222864[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iSortedCityIndex$222864[ebp], ecx
$LN5@DoAddCitie:
	cmp	DWORD PTR _iSortedCityIndex$222864[ebp], -1
	jle	$LN3@DoAddCitie

; 2852 : 	{
; 2853 : 		iSortedCityID = viCityProximities.GetElement(iSortedCityIndex);

	mov	edx, DWORD PTR _iSortedCityIndex$222864[ebp]
	mov	eax, DWORD PTR _viCityProximities$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _iSortedCityID$[ebp], ecx

; 2854 : 		pLoopCity = pLosingPlayer->getCity(iSortedCityID);

	mov	edx, DWORD PTR _iSortedCityID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pLoopCity$[ebp], eax

; 2855 : 
; 2856 : 		//iCityValue = GetCityValue(pLoopCity->getX(), pLoopCity->getY(), bMeSurrendering, eOtherPlayer, /*bUseEvenValue*/ true);
; 2857 : 
; 2858 : 		// See if we can actually trade it to them
; 2859 : 		if(pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T226671[ebp], ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T226680[ebp], eax
	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR $T226671[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226680[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@DoAddCitie

; 2860 : 			//if (pDeal->IsPossibleToTradeItem(eMyPlayer, eThem, TRADE_ITEM_OPEN_BORDERS))
; 2861 : 		{
; 2862 : 			int iItemValue = GetCityValue(pLoopCity->getX(), pLoopCity->getY(), /*bFromMe*/ true, eThem, bUseEvenValue);

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T226689[ebp], ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T226698[ebp], eax
	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T226689[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226698[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	mov	DWORD PTR _iItemValue$222869[ebp], eax

; 2863 : 			//int iItemValue = GetTradeItemValue(TRADE_ITEM_CITIES, /*bFromMe*/ true, eThem, pLoopCity->getX(), pLoopCity->getY(), iDealDuration, bUseEvenValue);
; 2864 : 			//int iItemValue = GetTradeItemValue(TRADE_ITEM_OPEN_BORDERS, /*bFromMe*/ true, eThem, -1, -1, iDealDuration, bUseEvenValue);
; 2865 : 
; 2866 : 			// If adding this to the deal doesn't take it under the min limit, do it
; 2867 : 			if(-iItemValue + iTotalValue >= iAmountUnderWeWillOffer)

	mov	edx, DWORD PTR _iItemValue$222869[ebp]
	neg	edx
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	add	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR _iAmountUnderWeWillOffer$[ebp]
	jl	SHORT $LN2@DoAddCitie

; 2868 : 			{
; 2869 : 				//pDeal->AddOpenBorders(eMyPlayer, iDealDuration);
; 2870 : 				pDeal->AddCityTrade(eMyPlayer, iSortedCityID);

	mov	ecx, DWORD PTR _iSortedCityID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade

; 2871 : 				iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@DoAddCitie:

; 2872 : 			}
; 2873 : 		}
; 2874 : 
; 2875 : 		// City is worth less than what is left to be added to the deal, so add it
; 2876 : 		//if (iCityValue < iCityValueToSurrender)
; 2877 : 		//{
; 2878 : 		//	if (pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))
; 2879 : 		//	{
; 2880 : 		//		pDeal->AddCityTrade(eLosingPlayer, iSortedCityID);
; 2881 : 
; 2882 : 		//		// Remove GPT from this City so we don't give more than we can support
; 2883 : 		//		iGPTToGive -= pLoopCity->getYieldRate(YIELD_GOLD);
; 2884 : 
; 2885 : 		//		iCityValueToSurrender -= iCityValue;
; 2886 : 		//	}
; 2887 : 		//}
; 2888 : 	}

	jmp	$LN4@DoAddCitie
$LN3@DoAddCitie:

; 2889 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _viCityProximities$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
$LN16@DoAddCitie:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z$0:
	lea	ecx, DWORD PTR _viCityProximities$[ebp]
	jmp	??1?$CvWeightedVector@H$00$0A@@@QAE@XZ	; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
__ehhandler$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddCitiesToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddCitiesToUs
EXTRN	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddGoldTrade
EXTRN	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z:PROC ; CvDeal::ChangeGoldTrade
EXTRN	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z:PROC ; CvDeal::GetGoldAvailable
; Function compile flags: /Odtp
;	COMDAT ?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z
_TEXT	SEGMENT
tv69 = -32						; size = 4
_this$ = -28						; size = 4
$T226754 = -24						; size = 4
$T226747 = -20						; size = 4
$T226738 = -16						; size = 4
_iNumGold$222885 = -12					; size = 4
_iNumGoldAlreadyInTrade$222886 = -8			; size = 4
_eMyPlayer$222883 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_bUseEvenValue$ = 32					; size = 1
?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z PROC ; CvDealAI::DoAddGoldToThem, COMDAT
; _this$ = ecx

; 2893 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2894 : 	CvAssert(eThem >= 0);
; 2895 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2896 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Gold to Them, but them is us.  Please show Jon");
; 2897 : 
; 2898 : 	if(!bDontChangeTheirExistingItems)

	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	eax, eax
	jne	$LN5@DoAddGoldT

; 2899 : 	{
; 2900 : 		if(iTotalValue < 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	$LN5@DoAddGoldT

; 2901 : 		{
; 2902 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226747[ebp], eax
	mov	edx, DWORD PTR $T226747[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222883[ebp], eax

; 2903 : 
; 2904 : 			// Can't already be Gold from the other player in the Deal
; 2905 : 			if(pDeal->GetGoldTrade(eMyPlayer) == 0)

	mov	ecx, DWORD PTR _eMyPlayer$222883[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	$LN5@DoAddGoldT

; 2906 : 			{
; 2907 : 				int iNumGold = GetGoldForForValueExchange(-iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ false);

	push	0
	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	push	0
	push	1
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	mov	DWORD PTR _iNumGold$222885[ebp], eax

; 2908 : 				int iNumGoldAlreadyInTrade = pDeal->GetGoldTrade(eThem);

	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	DWORD PTR _iNumGoldAlreadyInTrade$222886[ebp], eax

; 2909 : 				iNumGold += iNumGoldAlreadyInTrade;

	mov	ecx, DWORD PTR _iNumGold$222885[ebp]
	add	ecx, DWORD PTR _iNumGoldAlreadyInTrade$222886[ebp]
	mov	DWORD PTR _iNumGold$222885[ebp], ecx

; 2910 : 				iNumGold = min(iNumGold, pDeal->GetGoldAvailable(eThem, TRADE_ITEM_GOLD));

	push	0
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
	mov	DWORD PTR $T226738[ebp], eax
	mov	eax, DWORD PTR $T226738[ebp]
	cmp	eax, DWORD PTR _iNumGold$222885[ebp]
	jge	SHORT $LN13@DoAddGoldT
	lea	ecx, DWORD PTR $T226738[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN14@DoAddGoldT
$LN13@DoAddGoldT:
	lea	edx, DWORD PTR _iNumGold$222885[ebp]
	mov	DWORD PTR tv69[ebp], edx
$LN14@DoAddGoldT:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR $T226754[ebp], eax
	mov	ecx, DWORD PTR $T226754[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumGold$222885[ebp], edx

; 2911 : 				//iNumGold = min(iNumGold, GET_PLAYER(eThem).GetTreasury()->GetGold());
; 2912 : 
; 2913 : 				if(iNumGold != iNumGoldAlreadyInTrade && !pDeal->ChangeGoldTrade(eThem, iNumGold))

	mov	eax, DWORD PTR _iNumGold$222885[ebp]
	cmp	eax, DWORD PTR _iNumGoldAlreadyInTrade$222886[ebp]
	je	SHORT $LN1@DoAddGoldT
	mov	ecx, DWORD PTR _iNumGold$222885[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@DoAddGoldT

; 2914 : 				{
; 2915 : 					pDeal->AddGoldTrade(eThem, iNumGold);

	mov	ecx, DWORD PTR _iNumGold$222885[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade
$LN1@DoAddGoldT:

; 2916 : 				}
; 2917 : 
; 2918 : 				iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@DoAddGoldT:

; 2919 : 			}
; 2920 : 		}
; 2921 : 	}
; 2922 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?DoAddGoldToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ENDP ; CvDealAI::DoAddGoldToThem
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z
_TEXT	SEGMENT
tv73 = -32						; size = 4
_this$ = -28						; size = 4
$T226775 = -24						; size = 4
$T226768 = -20						; size = 4
$T226759 = -16						; size = 4
_iNumGold$222903 = -12					; size = 4
_iNumGoldAlreadyInTrade$222904 = -8			; size = 4
_eMyPlayer$222902 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_bUseEvenValue$ = 32					; size = 1
?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z PROC ; CvDealAI::DoAddGoldToUs, COMDAT
; _this$ = ecx

; 2926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2927 : 	CvAssert(eThem >= 0);
; 2928 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2929 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add Gold to Us, but them is us.  Please show Jon");
; 2930 : 
; 2931 : 	if(!bDontChangeMyExistingItems)

	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	eax, eax
	jne	$LN5@DoAddGoldT@2

; 2932 : 	{
; 2933 : 		if(iTotalValue > 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	$LN5@DoAddGoldT@2

; 2934 : 		{
; 2935 : 			// Can't already be Gold from the other player in the Deal
; 2936 : 			if(pDeal->GetGoldTrade(eThem) == 0)

	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	test	eax, eax
	jne	$LN5@DoAddGoldT@2

; 2937 : 			{
; 2938 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226768[ebp], eax
	mov	eax, DWORD PTR $T226768[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _eMyPlayer$222902[ebp], ecx

; 2939 : 
; 2940 : 				int iNumGold = GetGoldForForValueExchange(iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ false);

	push	0
	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	mov	DWORD PTR _iNumGold$222903[ebp], eax

; 2941 : 				int iNumGoldAlreadyInTrade = pDeal->GetGoldTrade(eMyPlayer);

	mov	eax, DWORD PTR _eMyPlayer$222902[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	DWORD PTR _iNumGoldAlreadyInTrade$222904[ebp], eax

; 2942 : 				iNumGold += iNumGoldAlreadyInTrade;

	mov	ecx, DWORD PTR _iNumGold$222903[ebp]
	add	ecx, DWORD PTR _iNumGoldAlreadyInTrade$222904[ebp]
	mov	DWORD PTR _iNumGold$222903[ebp], ecx

; 2943 : 				iNumGold = min(iNumGold, pDeal->GetGoldAvailable(eMyPlayer, TRADE_ITEM_GOLD));

	push	0
	mov	edx, DWORD PTR _eMyPlayer$222902[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
	mov	DWORD PTR $T226759[ebp], eax
	mov	eax, DWORD PTR $T226759[ebp]
	cmp	eax, DWORD PTR _iNumGold$222903[ebp]
	jge	SHORT $LN13@DoAddGoldT@2
	lea	ecx, DWORD PTR $T226759[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN14@DoAddGoldT@2
$LN13@DoAddGoldT@2:
	lea	edx, DWORD PTR _iNumGold$222903[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN14@DoAddGoldT@2:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T226775[ebp], eax
	mov	ecx, DWORD PTR $T226775[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumGold$222903[ebp], edx

; 2944 : 				//iNumGold = min(iNumGold, GET_PLAYER(eMyPlayer).GetTreasury()->GetGold());
; 2945 : 
; 2946 : 				if(iNumGold != iNumGoldAlreadyInTrade && !pDeal->ChangeGoldTrade(eMyPlayer, iNumGold))

	mov	eax, DWORD PTR _iNumGold$222903[ebp]
	cmp	eax, DWORD PTR _iNumGoldAlreadyInTrade$222904[ebp]
	je	SHORT $LN1@DoAddGoldT@2
	mov	ecx, DWORD PTR _iNumGold$222903[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$222902[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@DoAddGoldT@2

; 2947 : 				{
; 2948 : 					pDeal->AddGoldTrade(eMyPlayer, iNumGold);

	mov	ecx, DWORD PTR _iNumGold$222903[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$222902[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade
$LN1@DoAddGoldT@2:

; 2949 : 				}
; 2950 : 
; 2951 : 				iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@DoAddGoldT@2:

; 2952 : 			}
; 2953 : 		}
; 2954 : 	}
; 2955 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?DoAddGoldToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH332@Z ENDP ; CvDealAI::DoAddGoldToUs
_TEXT	ENDS
EXTRN	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z:PROC ; CvDeal::AddGoldPerTurnTrade
EXTRN	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z:PROC ; CvDeal::ChangeGoldPerTurnTrade
EXTRN	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z:PROC ; CvDeal::GetGoldPerTurnTrade
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
; Function compile flags: /Odtp
;	COMDAT ?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
tv161 = -40						; size = 4
_this$ = -36						; size = 4
$T226804 = -32						; size = 4
$T226797 = -28						; size = 4
$T226793 = -24						; size = 4
$T226784 = -20						; size = 4
$T226780 = -16						; size = 4
_iNumGPTAlreadyInTrade$222924 = -12			; size = 4
_iNumGPT$222923 = -8					; size = 4
_eMyPlayer$222921 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeTheirExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iDealDuration$ = 32					; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddGPTToThem, COMDAT
; _this$ = ecx

; 2959 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2960 : 	CvAssert(eThem >= 0);
; 2961 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2962 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add GPT to Them, but them is us.  Please show Jon");
; 2963 : 
; 2964 : 	if(!bDontChangeTheirExistingItems)

	movzx	eax, BYTE PTR _bDontChangeTheirExistingItems$[ebp]
	test	eax, eax
	jne	$LN6@DoAddGPTTo

; 2965 : 	{
; 2966 : 		if(iTotalValue < 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	$LN6@DoAddGPTTo

; 2967 : 		{
; 2968 : 			if(GET_PLAYER(eThem).calculateGoldRate() > 0)

	mov	edx, DWORD PTR _eThem$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226784[ebp], edx
	mov	ecx, DWORD PTR $T226784[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	test	eax, eax
	jle	$LN6@DoAddGPTTo

; 2969 : 			{
; 2970 : 				PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226793[ebp], eax
	mov	eax, DWORD PTR $T226793[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _eMyPlayer$222921[ebp], ecx

; 2971 : 
; 2972 : 				// Can't already be GPT from the other player in the Deal
; 2973 : 				if(pDeal->GetGoldPerTurnTrade(eMyPlayer) == 0)

	mov	edx, DWORD PTR _eMyPlayer$222921[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	test	eax, eax
	jne	$LN6@DoAddGPTTo

; 2974 : 				{
; 2975 : 					int iNumGPT = GetGPTforForValueExchange(-iTotalValue, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ false);

	push	0
	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	mov	DWORD PTR _iNumGPT$222923[ebp], eax

; 2976 : 					int iNumGPTAlreadyInTrade = pDeal->GetGoldPerTurnTrade(eThem);

	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	mov	DWORD PTR _iNumGPTAlreadyInTrade$222924[ebp], eax

; 2977 : 					iNumGPT += iNumGPTAlreadyInTrade;

	mov	eax, DWORD PTR _iNumGPT$222923[ebp]
	add	eax, DWORD PTR _iNumGPTAlreadyInTrade$222924[ebp]
	mov	DWORD PTR _iNumGPT$222923[ebp], eax

; 2978 : 					iNumGPT = min(iNumGPT, GET_PLAYER(eThem).calculateGoldRate());

	mov	ecx, DWORD PTR _eThem$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226797[ebp], ecx
	mov	ecx, DWORD PTR $T226797[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	mov	DWORD PTR $T226780[ebp], eax
	mov	edx, DWORD PTR $T226780[ebp]
	cmp	edx, DWORD PTR _iNumGPT$222923[ebp]
	jge	SHORT $LN18@DoAddGPTTo
	lea	eax, DWORD PTR $T226780[ebp]
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN19@DoAddGPTTo
$LN18@DoAddGPTTo:
	lea	ecx, DWORD PTR _iNumGPT$222923[ebp]
	mov	DWORD PTR tv161[ebp], ecx
$LN19@DoAddGPTTo:
	mov	edx, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T226804[ebp], edx
	mov	eax, DWORD PTR $T226804[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNumGPT$222923[ebp], ecx

; 2979 : 
; 2980 : 					if(iNumGPT != iNumGPTAlreadyInTrade && !pDeal->ChangeGoldPerTurnTrade(eThem, iNumGPT, iDealDuration))

	mov	edx, DWORD PTR _iNumGPT$222923[ebp]
	cmp	edx, DWORD PTR _iNumGPTAlreadyInTrade$222924[ebp]
	je	SHORT $LN1@DoAddGPTTo
	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumGPT$222923[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@DoAddGPTTo

; 2981 : 					{
; 2982 : 						pDeal->AddGoldPerTurnTrade(eThem, iNumGPT, iDealDuration);

	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumGPT$222923[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
$LN1@DoAddGPTTo:

; 2983 : 					}
; 2984 : 
; 2985 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@DoAddGPTTo:

; 2986 : 				}
; 2987 : 			}
; 2988 : 		}
; 2989 : 	}
; 2990 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DoAddGPTToThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddGPTToThem
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z
_TEXT	SEGMENT
tv162 = -40						; size = 4
_this$ = -36						; size = 4
$T226833 = -32						; size = 4
$T226826 = -28						; size = 4
$T226822 = -24						; size = 4
$T226818 = -20						; size = 4
$T226809 = -16						; size = 4
_iNumGPTAlreadyInTrade$222944 = -12			; size = 4
_iNumGPT$222943 = -8					; size = 4
_eMyPlayer$222940 = -4					; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_bDontChangeMyExistingItems$ = 16			; size = 1
_iTotalValue$ = 20					; size = 4
_iValueImOffering$ = 24					; size = 4
_iValueTheyreOffering$ = 28				; size = 4
_iDealDuration$ = 32					; size = 4
_bUseEvenValue$ = 36					; size = 1
?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z PROC ; CvDealAI::DoAddGPTToUs, COMDAT
; _this$ = ecx

; 2994 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2995 : 	CvAssert(eThem >= 0);
; 2996 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 2997 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to add GPT to Us, but them is us.  Please show Jon");
; 2998 : 
; 2999 : 	if(!bDontChangeMyExistingItems)

	movzx	eax, BYTE PTR _bDontChangeMyExistingItems$[ebp]
	test	eax, eax
	jne	$LN6@DoAddGPTTo@2

; 3000 : 	{
; 3001 : 		if(iTotalValue > 0)

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [ecx], 0
	jle	$LN6@DoAddGPTTo@2

; 3002 : 		{
; 3003 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226818[ebp], eax
	mov	edx, DWORD PTR $T226818[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$222940[ebp], eax

; 3004 : 
; 3005 : 			if(GET_PLAYER(eMyPlayer).calculateGoldRate() > 0)

	mov	ecx, DWORD PTR _eMyPlayer$222940[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226822[ebp], ecx
	mov	ecx, DWORD PTR $T226822[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	test	eax, eax
	jle	$LN6@DoAddGPTTo@2

; 3006 : 			{
; 3007 : 				// Can't already be GPT from the other player in the Deal
; 3008 : 				if(pDeal->GetGoldPerTurnTrade(eThem) == 0)

	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	test	eax, eax
	jne	$LN6@DoAddGPTTo@2

; 3009 : 				{
; 3010 : 					int iNumGPT = GetGPTforForValueExchange(iTotalValue, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ false);

	push	0
	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	mov	DWORD PTR _iNumGPT$222943[ebp], eax

; 3011 : 					int iNumGPTAlreadyInTrade = pDeal->GetGoldPerTurnTrade(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$222940[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	mov	DWORD PTR _iNumGPTAlreadyInTrade$222944[ebp], eax

; 3012 : 					iNumGPT += iNumGPTAlreadyInTrade;

	mov	eax, DWORD PTR _iNumGPT$222943[ebp]
	add	eax, DWORD PTR _iNumGPTAlreadyInTrade$222944[ebp]
	mov	DWORD PTR _iNumGPT$222943[ebp], eax

; 3013 : 					iNumGPT = min(iNumGPT, GET_PLAYER(eMyPlayer).calculateGoldRate());

	mov	ecx, DWORD PTR _eMyPlayer$222940[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226826[ebp], ecx
	mov	ecx, DWORD PTR $T226826[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	mov	DWORD PTR $T226809[ebp], eax
	mov	edx, DWORD PTR $T226809[ebp]
	cmp	edx, DWORD PTR _iNumGPT$222943[ebp]
	jge	SHORT $LN18@DoAddGPTTo@2
	lea	eax, DWORD PTR $T226809[ebp]
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN19@DoAddGPTTo@2
$LN18@DoAddGPTTo@2:
	lea	ecx, DWORD PTR _iNumGPT$222943[ebp]
	mov	DWORD PTR tv162[ebp], ecx
$LN19@DoAddGPTTo@2:
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR $T226833[ebp], edx
	mov	eax, DWORD PTR $T226833[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNumGPT$222943[ebp], ecx

; 3014 : 
; 3015 : 					if(iNumGPT != iNumGPTAlreadyInTrade && !pDeal->ChangeGoldPerTurnTrade(eMyPlayer, iNumGPT, iDealDuration))

	mov	edx, DWORD PTR _iNumGPT$222943[ebp]
	cmp	edx, DWORD PTR _iNumGPTAlreadyInTrade$222944[ebp]
	je	SHORT $LN1@DoAddGPTTo@2
	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumGPT$222943[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$222940[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@DoAddGPTTo@2

; 3016 : 					{
; 3017 : 						pDeal->AddGoldPerTurnTrade(eMyPlayer, iNumGPT, iDealDuration);

	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumGPT$222943[ebp]
	push	edx
	mov	eax, DWORD PTR _eMyPlayer$222940[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
$LN1@DoAddGPTTo@2:

; 3018 : 					}
; 3019 : 
; 3020 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@DoAddGPTTo@2:

; 3021 : 				}
; 3022 : 			}
; 3023 : 		}
; 3024 : 	}
; 3025 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DoAddGPTToUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@_NAAH33H2@Z ENDP ; CvDealAI::DoAddGPTToUs
_TEXT	ENDS
EXTRN	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z:PROC ; CvDeal::RemoveByType
; Function compile flags: /Odtp
;	COMDAT ?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z
_TEXT	SEGMENT
tv140 = -24						; size = 4
_this$ = -20						; size = 4
$T226844 = -16						; size = 4
_iNumGoldPerTurnInThisDeal$222960 = -12			; size = 4
_iValueToRemove$222958 = -8				; size = 4
_iNumGoldPerTurnToRemove$222959 = -4			; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_iDealDuration$ = 28					; size = 4
_bUseEvenValue$ = 32					; size = 1
?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z PROC ; CvDealAI::DoRemoveGPTFromThem, COMDAT
; _this$ = ecx

; 3029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3030 : 	CvAssert(eThem >= 0);
; 3031 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3032 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove GPT from Them, but them is us.  Please show Jon");
; 3033 : 
; 3034 : //	if (!bDontChangeTheirExistingItems)
; 3035 : 	{
; 3036 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jle	$LN6@DoRemoveGP

; 3037 : 		{
; 3038 : 			// Try to remove a bit more than the actual value discrepancy, as this should get us closer to even in the long-run
; 3039 : 			int iValueToRemove = iTotalValue * 150;

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 150				; 00000096H
	mov	DWORD PTR _iValueToRemove$222958[ebp], edx

; 3040 : 			iValueToRemove /= 100;

	mov	eax, DWORD PTR _iValueToRemove$222958[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValueToRemove$222958[ebp], eax

; 3041 : 
; 3042 : 			int iNumGoldPerTurnToRemove = GetGPTforForValueExchange(iValueToRemove, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ true);

	push	1
	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _iValueToRemove$222958[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	mov	DWORD PTR _iNumGoldPerTurnToRemove$222959[ebp], eax

; 3043 : 
; 3044 : 			int iNumGoldPerTurnInThisDeal = pDeal->GetGoldPerTurnTrade(eThem);

	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	mov	DWORD PTR _iNumGoldPerTurnInThisDeal$222960[ebp], eax

; 3045 : 			if(iNumGoldPerTurnInThisDeal > 0)

	cmp	DWORD PTR _iNumGoldPerTurnInThisDeal$222960[ebp], 0
	jle	$LN6@DoRemoveGP

; 3046 : 			{
; 3047 : 				// Found some GoldPerTurn to remove
; 3048 : 				iNumGoldPerTurnToRemove = min(iNumGoldPerTurnToRemove, iNumGoldPerTurnInThisDeal);

	mov	ecx, DWORD PTR _iNumGoldPerTurnInThisDeal$222960[ebp]
	cmp	ecx, DWORD PTR _iNumGoldPerTurnToRemove$222959[ebp]
	jge	SHORT $LN10@DoRemoveGP
	lea	edx, DWORD PTR _iNumGoldPerTurnInThisDeal$222960[ebp]
	mov	DWORD PTR tv140[ebp], edx
	jmp	SHORT $LN11@DoRemoveGP
$LN10@DoRemoveGP:
	lea	eax, DWORD PTR _iNumGoldPerTurnToRemove$222959[ebp]
	mov	DWORD PTR tv140[ebp], eax
$LN11@DoRemoveGP:
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR $T226844[ebp], ecx
	mov	edx, DWORD PTR $T226844[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iNumGoldPerTurnToRemove$222959[ebp], eax

; 3049 : 				iNumGoldPerTurnInThisDeal -= iNumGoldPerTurnToRemove;

	mov	ecx, DWORD PTR _iNumGoldPerTurnInThisDeal$222960[ebp]
	sub	ecx, DWORD PTR _iNumGoldPerTurnToRemove$222959[ebp]
	mov	DWORD PTR _iNumGoldPerTurnInThisDeal$222960[ebp], ecx

; 3050 : 
; 3051 : 				// Removing ALL GoldPerTurn, so just erase the item from the deal
; 3052 : 				if(iNumGoldPerTurnInThisDeal == 0)

	jne	SHORT $LN3@DoRemoveGP

; 3053 : 				{
; 3054 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD_PER_TURN);

	push	-1
	push	1
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3055 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 3056 : 				}
; 3057 : 				// Remove some of the GoldPerTurn from the deal
; 3058 : 				else

	jmp	SHORT $LN6@DoRemoveGP
$LN3@DoRemoveGP:

; 3059 : 				{
; 3060 : 					if(!pDeal->ChangeGoldPerTurnTrade(eThem, iNumGoldPerTurnInThisDeal, iDealDuration))

	mov	edx, DWORD PTR _iDealDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNumGoldPerTurnInThisDeal$222960[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade

; 3061 : 					{
; 3062 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove GoldPerTurn from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3063 : 					}
; 3064 : 
; 3065 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@DoRemoveGP:

; 3066 : 				}
; 3067 : 			}
; 3068 : 		}
; 3069 : 	}
; 3070 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?DoRemoveGPTFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ENDP ; CvDealAI::DoRemoveGPTFromThem
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z
_TEXT	SEGMENT
tv79 = -32						; size = 4
_this$ = -28						; size = 4
$T226864 = -24						; size = 4
$T226857 = -20						; size = 4
_iNumGoldPerTurnInThisDeal$222979 = -16			; size = 4
_iValueToRemove$222976 = -12				; size = 4
_eMyPlayer$222978 = -8					; size = 4
_iNumGoldPerTurnToRemove$222977 = -4			; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_iDealDuration$ = 28					; size = 4
_bUseEvenValue$ = 32					; size = 1
?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z PROC ; CvDealAI::DoRemoveGPTFromUs, COMDAT
; _this$ = ecx

; 3074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 3075 : 	CvAssert(eThem >= 0);
; 3076 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3077 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove GPT from Us, but them is us.  Please show Jon");
; 3078 : 
; 3079 : //	if (!bDontChangeMyExistingItems)
; 3080 : 	{
; 3081 : 		if(iTotalValue < 0)

	mov	eax, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	$LN6@DoRemoveGP@2

; 3082 : 		{
; 3083 : 			// Try to remove a bit more than the actual value discrepancy, as this should get us closer to even in the long-run
; 3084 : 			int iValueToRemove = -iTotalValue * 150;

	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	neg	edx
	imul	edx, 150				; 00000096H
	mov	DWORD PTR _iValueToRemove$222976[ebp], edx

; 3085 : 			iValueToRemove /= 100;

	mov	eax, DWORD PTR _iValueToRemove$222976[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iValueToRemove$222976[ebp], eax

; 3086 : 
; 3087 : 			int iNumGoldPerTurnToRemove = GetGPTforForValueExchange(iValueToRemove, /*bNumGPTFromValue*/ true, iDealDuration, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ true);

	push	1
	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _iDealDuration$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _iValueToRemove$222976[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGPTforForValueExchange@CvDealAI@@QAEHH_NH0W4PlayerTypes@@00@Z ; CvDealAI::GetGPTforForValueExchange
	mov	DWORD PTR _iNumGoldPerTurnToRemove$222977[ebp], eax

; 3088 : 
; 3089 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226857[ebp], eax
	mov	eax, DWORD PTR $T226857[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _eMyPlayer$222978[ebp], ecx

; 3090 : 
; 3091 : 			int iNumGoldPerTurnInThisDeal = pDeal->GetGoldPerTurnTrade(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$222978[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldPerTurnTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldPerTurnTrade
	mov	DWORD PTR _iNumGoldPerTurnInThisDeal$222979[ebp], eax

; 3092 : 			if(iNumGoldPerTurnInThisDeal > 0)

	cmp	DWORD PTR _iNumGoldPerTurnInThisDeal$222979[ebp], 0
	jle	$LN6@DoRemoveGP@2

; 3093 : 			{
; 3094 : 				// Found some GoldPerTurn to remove
; 3095 : 				iNumGoldPerTurnToRemove = min(iNumGoldPerTurnToRemove, iNumGoldPerTurnInThisDeal);

	mov	eax, DWORD PTR _iNumGoldPerTurnInThisDeal$222979[ebp]
	cmp	eax, DWORD PTR _iNumGoldPerTurnToRemove$222977[ebp]
	jge	SHORT $LN14@DoRemoveGP@2
	lea	ecx, DWORD PTR _iNumGoldPerTurnInThisDeal$222979[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN15@DoRemoveGP@2
$LN14@DoRemoveGP@2:
	lea	edx, DWORD PTR _iNumGoldPerTurnToRemove$222977[ebp]
	mov	DWORD PTR tv79[ebp], edx
$LN15@DoRemoveGP@2:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T226864[ebp], eax
	mov	ecx, DWORD PTR $T226864[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumGoldPerTurnToRemove$222977[ebp], edx

; 3096 : 				iNumGoldPerTurnInThisDeal -= iNumGoldPerTurnToRemove;

	mov	eax, DWORD PTR _iNumGoldPerTurnInThisDeal$222979[ebp]
	sub	eax, DWORD PTR _iNumGoldPerTurnToRemove$222977[ebp]
	mov	DWORD PTR _iNumGoldPerTurnInThisDeal$222979[ebp], eax

; 3097 : 
; 3098 : 				// Removing ALL GoldPerTurn, so just erase the item from the deal
; 3099 : 				if(iNumGoldPerTurnInThisDeal == 0)

	jne	SHORT $LN3@DoRemoveGP@2

; 3100 : 				{
; 3101 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD_PER_TURN);

	push	-1
	push	1
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3102 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax

; 3103 : 				}
; 3104 : 				// Remove some of the GoldPerTurn from the deal
; 3105 : 				else

	jmp	SHORT $LN6@DoRemoveGP@2
$LN3@DoRemoveGP@2:

; 3106 : 				{
; 3107 : 					if(!pDeal->ChangeGoldPerTurnTrade(eMyPlayer, iNumGoldPerTurnInThisDeal, iDealDuration))

	mov	eax, DWORD PTR _iDealDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumGoldPerTurnInThisDeal$222979[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$222978[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldPerTurnTrade@CvDeal@@QAE_NW4PlayerTypes@@HH@Z ; CvDeal::ChangeGoldPerTurnTrade

; 3108 : 					{
; 3109 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove GoldPerTurn from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3110 : 					}
; 3111 : 
; 3112 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@DoRemoveGP@2:

; 3113 : 				}
; 3114 : 			}
; 3115 : 		}
; 3116 : 	}
; 3117 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?DoRemoveGPTFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22H_N@Z ENDP ; CvDealAI::DoRemoveGPTFromUs
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z
_TEXT	SEGMENT
tv136 = -24						; size = 4
_this$ = -20						; size = 4
$T226876 = -16						; size = 4
$T226869 = -12						; size = 4
_iNumGoldToRemove$222996 = -8				; size = 4
_iNumGoldInThisDeal$222994 = -4				; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_bUseEvenValue$ = 28					; size = 1
?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z PROC ; CvDealAI::DoRemoveGoldFromThem, COMDAT
; _this$ = ecx

; 3121 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3122 : 	CvAssert(eThem >= 0);
; 3123 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3124 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove Gold from Them, but them is us.  Please show Jon");
; 3125 : 
; 3126 : //	if (!bDontChangeTheirExistingItems)
; 3127 : 	{
; 3128 : 		if(iTotalValue > 0)

	mov	eax, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jle	$LN6@DoRemoveGo

; 3129 : 		{
; 3130 : 			int iNumGoldInThisDeal = pDeal->GetGoldTrade(eThem);

	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	DWORD PTR _iNumGoldInThisDeal$222994[ebp], eax

; 3131 : 			if(iNumGoldInThisDeal > 0)

	cmp	DWORD PTR _iNumGoldInThisDeal$222994[ebp], 0
	jle	$LN6@DoRemoveGo

; 3132 : 			{
; 3133 : 				// Found some Gold to remove
; 3134 : 				int iNumGoldToRemove = min(iNumGoldInThisDeal, GetGoldForForValueExchange(iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ false, eThem, bUseEvenValue, /*bRoundUp*/ true));

	push	1
	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eThem$[ebp]
	push	eax
	push	0
	push	1
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	mov	DWORD PTR $T226869[ebp], eax
	mov	eax, DWORD PTR $T226869[ebp]
	cmp	eax, DWORD PTR _iNumGoldInThisDeal$222994[ebp]
	jge	SHORT $LN10@DoRemoveGo
	lea	ecx, DWORD PTR $T226869[ebp]
	mov	DWORD PTR tv136[ebp], ecx
	jmp	SHORT $LN11@DoRemoveGo
$LN10@DoRemoveGo:
	lea	edx, DWORD PTR _iNumGoldInThisDeal$222994[ebp]
	mov	DWORD PTR tv136[ebp], edx
$LN11@DoRemoveGo:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR $T226876[ebp], eax
	mov	ecx, DWORD PTR $T226876[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNumGoldToRemove$222996[ebp], edx

; 3135 : 				iNumGoldInThisDeal -= iNumGoldToRemove;

	mov	eax, DWORD PTR _iNumGoldInThisDeal$222994[ebp]
	sub	eax, DWORD PTR _iNumGoldToRemove$222996[ebp]
	mov	DWORD PTR _iNumGoldInThisDeal$222994[ebp], eax

; 3136 : 
; 3137 : 				// Removing ALL Gold, so just erase the item from the deal
; 3138 : 				if(iNumGoldInThisDeal == 0)

	jne	SHORT $LN3@DoRemoveGo

; 3139 : 				{
; 3140 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3141 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueImOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	edx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [edx], eax

; 3142 : 				}
; 3143 : 				// Remove some of the Gold from the deal
; 3144 : 				else

	jmp	SHORT $LN6@DoRemoveGo
$LN3@DoRemoveGo:

; 3145 : 				{
; 3146 : 					if(!pDeal->ChangeGoldTrade(eThem, iNumGoldInThisDeal))

	mov	eax, DWORD PTR _iNumGoldInThisDeal$222994[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade

; 3147 : 					{
; 3148 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove Gold from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3149 : 					}
; 3150 : 
; 3151 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@DoRemoveGo:

; 3152 : 				}
; 3153 : 			}
; 3154 : 		}
; 3155 : 	}
; 3156 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DoRemoveGoldFromThem@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ENDP ; CvDealAI::DoRemoveGoldFromThem
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z
_TEXT	SEGMENT
tv67 = -32						; size = 4
_this$ = -28						; size = 4
$T226897 = -24						; size = 4
$T226890 = -20						; size = 4
$T226881 = -16						; size = 4
_iNumGoldToRemove$223014 = -12				; size = 4
_eMyPlayer$223011 = -8					; size = 4
_iNumGoldInThisDeal$223012 = -4				; size = 4
_pDeal$ = 8						; size = 4
_eThem$ = 12						; size = 4
_iTotalValue$ = 16					; size = 4
_iValueImOffering$ = 20					; size = 4
_iValueTheyreOffering$ = 24				; size = 4
_bUseEvenValue$ = 28					; size = 1
?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z PROC ; CvDealAI::DoRemoveGoldFromUs, COMDAT
; _this$ = ecx

; 3160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 3161 : 	CvAssert(eThem >= 0);
; 3162 : 	CvAssert(eThem < MAX_MAJOR_CIVS);
; 3163 : 	CvAssertMsg(eThem != GetPlayer()->GetID(), "DEAL_AI: Trying to remove Gold from Us, but them is us.  Please show Jon");
; 3164 : 
; 3165 : //	if (!bDontChangeMyExistingItems)
; 3166 : 	{
; 3167 : 		if(iTotalValue < 0)

	mov	eax, DWORD PTR _iTotalValue$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	$LN6@DoRemoveGo@2

; 3168 : 		{
; 3169 : 			PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226890[ebp], eax
	mov	ecx, DWORD PTR $T226890[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _eMyPlayer$223011[ebp], edx

; 3170 : 
; 3171 : 			int iNumGoldInThisDeal = pDeal->GetGoldTrade(eMyPlayer);

	mov	eax, DWORD PTR _eMyPlayer$223011[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldTrade@CvDeal@@QAEHW4PlayerTypes@@@Z ; CvDeal::GetGoldTrade
	mov	DWORD PTR _iNumGoldInThisDeal$223012[ebp], eax

; 3172 : 			if(iNumGoldInThisDeal > 0)

	cmp	DWORD PTR _iNumGoldInThisDeal$223012[ebp], 0
	jle	$LN6@DoRemoveGo@2

; 3173 : 			{
; 3174 : 				// Found some Gold to remove
; 3175 : 				int iNumGoldToRemove = min(iNumGoldInThisDeal, GetGoldForForValueExchange(-iTotalValue, /*bNumGoldFromValue*/ true, /*bFromMe*/ true, eThem, bUseEvenValue, /*bRoundUp*/ true));

	push	1
	movzx	ecx, BYTE PTR _bUseEvenValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThem$[ebp]
	push	edx
	push	1
	push	1
	mov	eax, DWORD PTR _iTotalValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGoldForForValueExchange@CvDealAI@@QAEHH_N0W4PlayerTypes@@00@Z ; CvDealAI::GetGoldForForValueExchange
	mov	DWORD PTR $T226881[ebp], eax
	mov	edx, DWORD PTR $T226881[ebp]
	cmp	edx, DWORD PTR _iNumGoldInThisDeal$223012[ebp]
	jge	SHORT $LN14@DoRemoveGo@2
	lea	eax, DWORD PTR $T226881[ebp]
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN15@DoRemoveGo@2
$LN14@DoRemoveGo@2:
	lea	ecx, DWORD PTR _iNumGoldInThisDeal$223012[ebp]
	mov	DWORD PTR tv67[ebp], ecx
$LN15@DoRemoveGo@2:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR $T226897[ebp], edx
	mov	eax, DWORD PTR $T226897[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNumGoldToRemove$223014[ebp], ecx

; 3176 : 				iNumGoldInThisDeal -= iNumGoldToRemove;

	mov	edx, DWORD PTR _iNumGoldInThisDeal$223012[ebp]
	sub	edx, DWORD PTR _iNumGoldToRemove$223014[ebp]
	mov	DWORD PTR _iNumGoldInThisDeal$223012[ebp], edx

; 3177 : 
; 3178 : 				// Removing ALL Gold, so just erase the item from the deal
; 3179 : 				if(iNumGoldInThisDeal == 0)

	jne	SHORT $LN3@DoRemoveGo@2

; 3180 : 				{
; 3181 : 					pDeal->RemoveByType(TRADE_ITEM_GOLD);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?RemoveByType@CvDeal@@QAEXW4TradeableItems@@W4PlayerTypes@@@Z ; CvDeal::RemoveByType

; 3182 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	eax, BYTE PTR _bUseEvenValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueTheyreOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iValueImOffering$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 3183 : 				}
; 3184 : 				// Remove some of the Gold from the deal
; 3185 : 				else

	jmp	SHORT $LN6@DoRemoveGo@2
$LN3@DoRemoveGo@2:

; 3186 : 				{
; 3187 : 					if(!pDeal->ChangeGoldTrade(eMyPlayer, iNumGoldInThisDeal))

	mov	edx, DWORD PTR _iNumGoldInThisDeal$223012[ebp]
	push	edx
	mov	eax, DWORD PTR _eMyPlayer$223011[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?ChangeGoldTrade@CvDeal@@QAE_NW4PlayerTypes@@H@Z ; CvDeal::ChangeGoldTrade

; 3188 : 					{
; 3189 : 						CvAssertMsg(false, "DEAL_AI: DealAI is trying to remove Gold from a deal but couldn't find the item for some reason.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 3190 : 					}
; 3191 : 
; 3192 : 					iTotalValue = GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, bUseEvenValue);

	movzx	edx, BYTE PTR _bUseEvenValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _iValueTheyreOffering$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iValueImOffering$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue
	mov	ecx, DWORD PTR _iTotalValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN6@DoRemoveGo@2:

; 3193 : 				}
; 3194 : 			}
; 3195 : 		}
; 3196 : 	}
; 3197 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DoRemoveGoldFromUs@CvDealAI@@QAEXPAVCvDeal@@W4PlayerTypes@@AAH22_N@Z ENDP ; CvDealAI::DoRemoveGoldFromUs
_TEXT	ENDS
PUBLIC	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty
PUBLIC	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty
EXTRN	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddPeaceTreaty
EXTRN	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getPeaceDealDuration
EXTRN	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z:PROC ; CvDeal::SetPeaceTreatyType
EXTRN	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::SetSurrenderingPlayer
EXTRN	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetTreatyWillingToAccept
EXTRN	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetTreatyWillingToOffer
; Function compile flags: /Odtp
;	COMDAT ?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z
_TEXT	SEGMENT
tv330 = -120						; size = 4
_this$ = -116						; size = 4
$T226975 = -112						; size = 4
$T226971 = -108						; size = 4
$T226967 = -104						; size = 4
$T226963 = -100						; size = 4
$T226959 = -96						; size = 4
$T226955 = -92						; size = 4
$T226949 = -88						; size = 4
$T226942 = -84						; size = 4
$T226938 = -80						; size = 4
$T226934 = -76						; size = 4
$T226930 = -72						; size = 4
$T226921 = -68						; size = 4
$T226920 = -64						; size = 4
$T226911 = -60						; size = 4
$T226910 = -56						; size = 4
_iValueImOffering$223058 = -52				; size = 4
_iValueTheyreOffering$223059 = -48			; size = 4
_iValueImOffering$223053 = -44				; size = 4
_iValueTheyreOffering$223054 = -40			; size = 4
_iPeaceTreatyLength$223062 = -36			; size = 4
_iAmountToReduce$223037 = -32				; size = 4
_ePeaceTreatyTheyreWillingToOffer$223033 = -28		; size = 4
_ePeaceTreatyTheyreWillingToAccept$223032 = -24		; size = 4
_iPeaceTreatyLength$223048 = -20			; size = 4
_result$ = -13						; size = 1
_eMyPlayer$ = -12					; size = 4
_ePeaceTreatyImWillingToOffer$ = -8			; size = 4
_ePeaceTreatyImWillingToAccept$ = -4			; size = 4
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
_bEqualizingDeals$ = 16					; size = 1
?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z PROC ; CvDealAI::IsOfferPeace, COMDAT
; _this$ = ecx

; 3201 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 3202 : 	bool result = false;

	mov	BYTE PTR _result$[ebp], 0

; 3203 : 	CvAssert(eOtherPlayer >= 0);
; 3204 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3205 : 
; 3206 : 	// Can we actually complete this deal?
; 3207 : 
; 3208 : 	if(!pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), eOtherPlayer, TRADE_ITEM_PEACE_TREATY))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226910[ebp], eax
	mov	eax, DWORD PTR $T226910[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T226911[ebp], ecx
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	13					; 0000000dH
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR $T226911[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN22@IsOfferPea

; 3209 : 	{
; 3210 : 		return false;

	xor	al, al
	jmp	$LN23@IsOfferPea
$LN22@IsOfferPea:

; 3211 : 	}
; 3212 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_PEACE_TREATY))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226920[ebp], eax
	mov	edx, DWORD PTR $T226920[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T226921[ebp], eax
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	13					; 0000000dH
	mov	ecx, DWORD PTR $T226921[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN21@IsOfferPea

; 3213 : 	{
; 3214 : 		return false;

	xor	al, al
	jmp	$LN23@IsOfferPea
$LN21@IsOfferPea:

; 3215 : 	}
; 3216 : 
; 3217 : 	PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226930[ebp], eax
	mov	ecx, DWORD PTR $T226930[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _eMyPlayer$[ebp], edx

; 3218 : 
; 3219 : 	PeaceTreatyTypes ePeaceTreatyImWillingToOffer = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToOffer(eOtherPlayer);

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToOffer
	mov	DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp], eax

; 3220 : 	PeaceTreatyTypes ePeaceTreatyImWillingToAccept = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToAccept(eOtherPlayer);

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToAccept
	mov	DWORD PTR _ePeaceTreatyImWillingToAccept$[ebp], eax

; 3221 : 
; 3222 : 	// Peace between AI players
; 3223 : 	if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226934[ebp], edx
	mov	ecx, DWORD PTR $T226934[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	$LN20@IsOfferPea

; 3224 : 	{
; 3225 : 		PeaceTreatyTypes ePeaceTreatyTheyreWillingToAccept = GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->GetTreatyWillingToAccept(eMyPlayer);

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226938[ebp], ecx
	mov	edx, DWORD PTR _eMyPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226938[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToAccept
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToAccept$223032[ebp], eax

; 3226 : 		PeaceTreatyTypes ePeaceTreatyTheyreWillingToOffer = GET_PLAYER(eOtherPlayer).GetDiplomacyAI()->GetTreatyWillingToOffer(eMyPlayer);

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226942[ebp], eax
	mov	ecx, DWORD PTR _eMyPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226942[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToOffer
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp], eax

; 3227 : 
; 3228 : 		// Is what we're willing to offer acceptable to eOtherPlayer?
; 3229 : 		if(ePeaceTreatyImWillingToOffer < ePeaceTreatyTheyreWillingToAccept)

	mov	edx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	cmp	edx, DWORD PTR _ePeaceTreatyTheyreWillingToAccept$223032[ebp]
	jge	SHORT $LN19@IsOfferPea

; 3230 : 		{
; 3231 : 			return false;

	xor	al, al
	jmp	$LN23@IsOfferPea
$LN19@IsOfferPea:

; 3232 : 		}
; 3233 : 		// Is what eOtherPalyer is willing to offer acceptable to us?
; 3234 : 		if(ePeaceTreatyTheyreWillingToOffer < ePeaceTreatyImWillingToAccept)

	mov	eax, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	cmp	eax, DWORD PTR _ePeaceTreatyImWillingToAccept$[ebp]
	jge	SHORT $LN18@IsOfferPea

; 3235 : 		{
; 3236 : 			return false;

	xor	al, al
	jmp	$LN23@IsOfferPea
$LN18@IsOfferPea:

; 3237 : 		}
; 3238 : 
; 3239 : 		// If we're both willing to give something up (for whatever reason) reduce the surrender level of both parties until White Peace is on one side
; 3240 : 		if(ePeaceTreatyImWillingToOffer > PEACE_TREATY_WHITE_PEACE && ePeaceTreatyTheyreWillingToOffer > PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp], 0
	jle	SHORT $LN17@IsOfferPea
	cmp	DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp], 0
	jle	SHORT $LN17@IsOfferPea

; 3241 : 		{
; 3242 : 			int iAmountToReduce = min(ePeaceTreatyImWillingToOffer, ePeaceTreatyTheyreWillingToOffer);

	mov	ecx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	cmp	ecx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	jge	SHORT $LN45@IsOfferPea
	lea	edx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	mov	DWORD PTR tv330[ebp], edx
	jmp	SHORT $LN46@IsOfferPea
$LN45@IsOfferPea:
	lea	eax, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	mov	DWORD PTR tv330[ebp], eax
$LN46@IsOfferPea:
	mov	ecx, DWORD PTR tv330[ebp]
	mov	DWORD PTR $T226949[ebp], ecx
	mov	edx, DWORD PTR $T226949[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iAmountToReduce$223037[ebp], eax

; 3243 : 
; 3244 : 			ePeaceTreatyImWillingToOffer = PeaceTreatyTypes(ePeaceTreatyImWillingToOffer - iAmountToReduce);

	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	sub	ecx, DWORD PTR _iAmountToReduce$223037[ebp]
	mov	DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp], ecx

; 3245 : 			ePeaceTreatyTheyreWillingToOffer = PeaceTreatyTypes(ePeaceTreatyTheyreWillingToOffer - iAmountToReduce);

	mov	edx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	sub	edx, DWORD PTR _iAmountToReduce$223037[ebp]
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp], edx
$LN17@IsOfferPea:

; 3246 : 		}
; 3247 : 
; 3248 : 		// Get the Peace in between if there's a gap
; 3249 : 		if(ePeaceTreatyImWillingToOffer > ePeaceTreatyTheyreWillingToAccept)

	mov	eax, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	cmp	eax, DWORD PTR _ePeaceTreatyTheyreWillingToAccept$223032[ebp]
	jle	SHORT $LN16@IsOfferPea

; 3250 : 		{
; 3251 : 			ePeaceTreatyImWillingToOffer = PeaceTreatyTypes((ePeaceTreatyImWillingToOffer + ePeaceTreatyTheyreWillingToAccept) / 2);

	mov	eax, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	add	eax, DWORD PTR _ePeaceTreatyTheyreWillingToAccept$223032[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp], eax
$LN16@IsOfferPea:

; 3252 : 		}
; 3253 : 		if(ePeaceTreatyTheyreWillingToOffer > ePeaceTreatyImWillingToAccept)

	mov	ecx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	cmp	ecx, DWORD PTR _ePeaceTreatyImWillingToAccept$[ebp]
	jle	SHORT $LN15@IsOfferPea

; 3254 : 		{
; 3255 : 			ePeaceTreatyTheyreWillingToOffer = PeaceTreatyTypes((ePeaceTreatyTheyreWillingToOffer + ePeaceTreatyImWillingToAccept) / 2);

	mov	eax, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	add	eax, DWORD PTR _ePeaceTreatyImWillingToAccept$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp], eax
$LN15@IsOfferPea:

; 3256 : 		}
; 3257 : 
; 3258 : 		CvAssertMsg(ePeaceTreatyImWillingToOffer >= PEACE_TREATY_WHITE_PEACE, "DEAL_AI: I'm offering a peace treaty with negative ID.  Please show Jon");
; 3259 : 		CvAssertMsg(ePeaceTreatyTheyreWillingToOffer >= PEACE_TREATY_WHITE_PEACE, "DEAL_AI: They're offering a peace treaty with negative ID.  Please show Jon");
; 3260 : 
; 3261 : 		// I'm surrendering in this deal
; 3262 : 		if(ePeaceTreatyImWillingToOffer > ePeaceTreatyTheyreWillingToOffer)

	mov	edx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	cmp	edx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	jle	SHORT $LN14@IsOfferPea

; 3263 : 		{
; 3264 : 			pDeal->SetSurrenderingPlayer(eMyPlayer);

	mov	eax, DWORD PTR _eMyPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3265 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToOffer);

	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3266 : 
; 3267 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyImWillingToOffer, /*bMeSurrendering*/ true);

	push	1
	mov	edx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty
	jmp	SHORT $LN13@IsOfferPea
$LN14@IsOfferPea:

; 3268 : 		}
; 3269 : 		// They're surrendering in this deal
; 3270 : 		else if(ePeaceTreatyImWillingToOffer < ePeaceTreatyTheyreWillingToOffer)

	mov	edx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	cmp	edx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	jge	SHORT $LN13@IsOfferPea

; 3271 : 		{
; 3272 : 			pDeal->SetSurrenderingPlayer(eOtherPlayer);

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3273 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyTheyreWillingToOffer);

	mov	ecx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3274 : 
; 3275 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyTheyreWillingToOffer, /*bMeSurrendering*/ false);

	push	0
	mov	edx, DWORD PTR _ePeaceTreatyTheyreWillingToOffer$223033[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty
$LN13@IsOfferPea:

; 3276 : 		}
; 3277 : 
; 3278 : 		// Add the peace items to the deal so that we actually stop the war
; 3279 : #ifdef AI_PEACE_TURNS
; 3280 : 		int iPeaceTreatyLength;
; 3281 : 		if (GET_PLAYER(eMyPlayer).isHuman() && GET_PLAYER(eOtherPlayer).isHuman())

	mov	edx, DWORD PTR _eMyPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226955[ebp], edx
	mov	ecx, DWORD PTR $T226955[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@IsOfferPea
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226959[ebp], ecx
	mov	ecx, DWORD PTR $T226959[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@IsOfferPea

; 3282 : 		{
; 3283 : 			iPeaceTreatyLength = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226963[ebp], eax
	mov	ecx, DWORD PTR $T226963[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	mov	DWORD PTR _iPeaceTreatyLength$223048[ebp], eax

; 3284 : 		}
; 3285 : 		else

	jmp	SHORT $LN10@IsOfferPea
$LN11@IsOfferPea:

; 3286 : 		{
; 3287 : 			iPeaceTreatyLength = 5 /*GC.getGame().getGameSpeedInfo().getPeaceDealDuration()*/;

	mov	DWORD PTR _iPeaceTreatyLength$223048[ebp], 5
$LN10@IsOfferPea:

; 3288 : 		}
; 3289 : #else
; 3290 : 		int iPeaceTreatyLength = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();
; 3291 : #endif
; 3292 : 		pDeal->AddPeaceTreaty(eMyPlayer, iPeaceTreatyLength);

	mov	ecx, DWORD PTR _iPeaceTreatyLength$223048[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 3293 : 		pDeal->AddPeaceTreaty(eOtherPlayer, iPeaceTreatyLength);

	mov	eax, DWORD PTR _iPeaceTreatyLength$223048[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 3294 : 
; 3295 : 		result = true;

	mov	BYTE PTR _result$[ebp], 1

; 3296 : 	}
; 3297 : 
; 3298 : 	// Peace with a human
; 3299 : 	else

	jmp	$LN9@IsOfferPea
$LN20@IsOfferPea:

; 3300 : 	{
; 3301 : 		// AI is surrendering
; 3302 : 		if(ePeaceTreatyImWillingToOffer > PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp], 0
	jle	SHORT $LN8@IsOfferPea

; 3303 : 		{
; 3304 : 			pDeal->SetSurrenderingPlayer(eMyPlayer);

	mov	edx, DWORD PTR _eMyPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3305 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToOffer);

	mov	eax, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3306 : 
; 3307 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyImWillingToOffer, /*bMeSurrendering*/ true);

	push	1
	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToOffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3308 : 
; 3309 : 			// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3310 : 			int iValueImOffering, iValueTheyreOffering;
; 3311 : 			GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	ecx, DWORD PTR _iValueTheyreOffering$223054[ebp]
	push	ecx
	lea	edx, DWORD PTR _iValueImOffering$223053[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3312 : 			if (!bEqualizingDeals)

	movzx	ecx, BYTE PTR _bEqualizingDeals$[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@IsOfferPea

; 3313 : 			{
; 3314 : 				SetCachedValueOfPeaceWithHuman(-iValueImOffering);

	mov	edx, DWORD PTR _iValueImOffering$223053[ebp]
	neg	edx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman
$LN7@IsOfferPea:

; 3315 : 			}
; 3316 : 		}

	jmp	SHORT $LN6@IsOfferPea
$LN8@IsOfferPea:

; 3317 : 		// AI is asking human to surrender
; 3318 : 		else if(ePeaceTreatyImWillingToAccept > PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToAccept$[ebp], 0
	jle	SHORT $LN5@IsOfferPea

; 3319 : 		{
; 3320 : 			pDeal->SetSurrenderingPlayer(eOtherPlayer);

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3321 : 			pDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToAccept);

	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToAccept$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3322 : 
; 3323 : 			DoAddItemsToDealForPeaceTreaty(eOtherPlayer, pDeal, ePeaceTreatyImWillingToAccept, /*bMeSurrendering*/ false);

	push	0
	mov	edx, DWORD PTR _ePeaceTreatyImWillingToAccept$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3324 : 
; 3325 : 			// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3326 : 			int iValueImOffering, iValueTheyreOffering;
; 3327 : 			GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$223059[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$223058[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3328 : 			if (!bEqualizingDeals)

	movzx	edx, BYTE PTR _bEqualizingDeals$[ebp]
	test	edx, edx
	jne	SHORT $LN4@IsOfferPea

; 3329 : 			{
; 3330 : 				SetCachedValueOfPeaceWithHuman(iValueTheyreOffering);

	mov	eax, DWORD PTR _iValueTheyreOffering$223059[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman
$LN4@IsOfferPea:

; 3331 : 			}
; 3332 : 		}
; 3333 : 		else

	jmp	SHORT $LN6@IsOfferPea
$LN5@IsOfferPea:

; 3334 : 		{
; 3335 : 			// if the case is that we both want white peace, don't forget to add the city-states into the peace deal.
; 3336 : 			DoAddPlayersAlliesToTreaty(eOtherPlayer, pDeal);

	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty
$LN6@IsOfferPea:

; 3337 : 		}
; 3338 : 
; 3339 : #ifdef AI_PEACE_TURNS
; 3340 : 		int iPeaceTreatyLength;
; 3341 : 		if (GET_PLAYER(eMyPlayer).isHuman() && GET_PLAYER(eOtherPlayer).isHuman())

	mov	eax, DWORD PTR _eMyPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226967[ebp], eax
	mov	ecx, DWORD PTR $T226967[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsOfferPea
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226971[ebp], edx
	mov	ecx, DWORD PTR $T226971[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@IsOfferPea

; 3342 : 		{
; 3343 : 			iPeaceTreatyLength = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226975[ebp], ecx
	mov	ecx, DWORD PTR $T226975[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	mov	DWORD PTR _iPeaceTreatyLength$223062[ebp], eax

; 3344 : 		}
; 3345 : 		else

	jmp	SHORT $LN1@IsOfferPea
$LN2@IsOfferPea:

; 3346 : 		{
; 3347 : 			iPeaceTreatyLength = 5 /*GC.getGame().getGameSpeedInfo().getPeaceDealDuration()*/;

	mov	DWORD PTR _iPeaceTreatyLength$223062[ebp], 5
$LN1@IsOfferPea:

; 3348 : 		}
; 3349 : #else
; 3350 : 		int iPeaceTreatyLength = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();
; 3351 : #endif
; 3352 : 		pDeal->AddPeaceTreaty(eMyPlayer, iPeaceTreatyLength);

	mov	edx, DWORD PTR _iPeaceTreatyLength$223062[ebp]
	push	edx
	mov	eax, DWORD PTR _eMyPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 3353 : 		pDeal->AddPeaceTreaty(eOtherPlayer, iPeaceTreatyLength);

	mov	ecx, DWORD PTR _iPeaceTreatyLength$223062[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 3354 : 
; 3355 : 		result = true;

	mov	BYTE PTR _result$[ebp], 1
$LN9@IsOfferPea:

; 3356 : 	}
; 3357 : 
; 3358 : 	return result;

	mov	al, BYTE PTR _result$[ebp]
$LN23@IsOfferPea:

; 3359 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?IsOfferPeace@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@_N@Z ENDP ; CvDealAI::IsOfferPeace
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ:PROC ; CvCity::getOriginalOwner
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z$0
__ehfuncinfo$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
_TEXT	SEGMENT
tv435 = -388						; size = 4
tv90 = -384						; size = 4
tv77 = -380						; size = 4
tv64 = -376						; size = 4
_this$ = -372						; size = 4
$T227302 = -356						; size = 4
$T227293 = -352						; size = 4
$T227284 = -348						; size = 4
$T227275 = -344						; size = 4
$T227254 = -340						; size = 4
$T227237 = -336						; size = 4
_weightedElem$227205 = -304				; size = 8
$T227187 = -296						; size = 4
$T227117 = -224						; size = 4
$T227108 = -220						; size = 4
$T227099 = -216						; size = 4
$T227090 = -212						; size = 4
$T227056 = -208						; size = 4
$T227047 = -204						; size = 4
$T227038 = -200						; size = 4
$T227027 = -196						; size = 4
$T227020 = -192						; size = 4
$T227013 = -188						; size = 4
$T227012 = -184						; size = 4
$T227000 = -180						; size = 4
$T226999 = -176						; size = 4
$T226990 = -172						; size = 4
$T226985 = -168						; size = 4
$T226984 = -164						; size = 4
$T226983 = -160						; size = 4
_iSortedCityIndex$223155 = -156				; size = 4
_iCityValueToSurrender$223154 = -152			; size = 4
_iWinnerCapitalX$223138 = -148				; size = 4
_iCityValue$223136 = -144				; size = 4
_iSortedCityID$223151 = -140				; size = 4
_pWinnerCapital$223140 = -136				; size = 4
_iCityDistanceFromWinnersCapital$223137 = -132		; size = 4
_viCityProximities$223143 = -128			; size = 24
__$ArrayPad$ = -104					; size = 4
_iWinnerCapitalY$223139 = -100				; size = 4
_pkResourceInfo$223119 = -96				; size = 4
_iResourceLoop$223114 = -92				; size = 4
_bGiveUpLuxuryResources$ = -85				; size = 1
_iDuration$ = -84					; size = 4
_bGiveUpStratResources$ = -77				; size = 1
_iResourceQuantity$ = -76				; size = 4
_iCityLoop$ = -72					; size = 4
_eUsage$ = -68						; size = 4
_bGiveOnlyOneCity$ = -61				; size = 1
_iPercentCitiesGiveUp$ = -60				; size = 4
_iPercentGPTToGive$ = -56				; size = 4
_bGiveOpenBorders$ = -49				; size = 1
_iPercentGoldToGive$ = -48				; size = 4
_pLosingPlayer$ = -44					; size = 4
_iGold$ = -40						; size = 4
_eWinningPlayer$ = -36					; size = 4
_pLoopCity$ = -32					; size = 4
_eLosingPlayer$ = -28					; size = 4
_pWinningPlayer$ = -24					; size = 4
_iGPT$ = -20						; size = 4
_eResource$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
_eTreaty$ = 16						; size = 4
_bMeSurrendering$ = 20					; size = 1
?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z PROC ; CvDealAI::DoAddItemsToDealForPeaceTreaty, COMDAT
; _this$ = ecx

; 3363 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 376				; 00000178H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3364 : 	int iPercentGoldToGive = 0;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 0

; 3365 : 	int iPercentGPTToGive = 0;

	mov	DWORD PTR _iPercentGPTToGive$[ebp], 0

; 3366 : 	bool bGiveOpenBorders = false;

	mov	BYTE PTR _bGiveOpenBorders$[ebp], 0

; 3367 : 	bool bGiveOnlyOneCity = false;

	mov	BYTE PTR _bGiveOnlyOneCity$[ebp], 0

; 3368 : 	int iPercentCitiesGiveUp = 0; /* 100 = all but capital */

	mov	DWORD PTR _iPercentCitiesGiveUp$[ebp], 0

; 3369 : 	bool bGiveUpStratResources = false;

	mov	BYTE PTR _bGiveUpStratResources$[ebp], 0

; 3370 : 	bool bGiveUpLuxuryResources = false;

	mov	BYTE PTR _bGiveUpLuxuryResources$[ebp], 0

; 3371 : 
; 3372 : 	// Setup what needs to be given up based on the level of the treaty
; 3373 : 	switch (eTreaty)

	mov	eax, DWORD PTR _eTreaty$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 7
	ja	$LN51@DoAddItems
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN256@DoAddItems[edx*4]

; 3374 : 	{
; 3375 : 	case PEACE_TREATY_WHITE_PEACE:
; 3376 : 		// White Peace: nothing changes hands
; 3377 : 		break;

	jmp	$LN51@DoAddItems
$LN49@DoAddItems:

; 3378 : 
; 3379 : 	case PEACE_TREATY_ARMISTICE:
; 3380 : 		iPercentGoldToGive = 50;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 50	; 00000032H

; 3381 : 		iPercentGPTToGive = 50;

	mov	DWORD PTR _iPercentGPTToGive$[ebp], 50	; 00000032H

; 3382 : 		break;

	jmp	SHORT $LN51@DoAddItems
$LN48@DoAddItems:

; 3383 : 
; 3384 : 	case PEACE_TREATY_SETTLEMENT:
; 3385 : 		iPercentGoldToGive = 100;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 100 ; 00000064H

; 3386 : 		iPercentGPTToGive = 100;

	mov	DWORD PTR _iPercentGPTToGive$[ebp], 100	; 00000064H

; 3387 : 		break;

	jmp	SHORT $LN51@DoAddItems
$LN47@DoAddItems:

; 3388 : 
; 3389 : 	case PEACE_TREATY_BACKDOWN:
; 3390 : 		iPercentGoldToGive = 100;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 100 ; 00000064H

; 3391 : 		iPercentGPTToGive = 100;

	mov	DWORD PTR _iPercentGPTToGive$[ebp], 100	; 00000064H

; 3392 : 		bGiveOpenBorders = true;

	mov	BYTE PTR _bGiveOpenBorders$[ebp], 1

; 3393 : 		bGiveUpStratResources = true;

	mov	BYTE PTR _bGiveUpStratResources$[ebp], 1

; 3394 : 		break;

	jmp	SHORT $LN51@DoAddItems
$LN46@DoAddItems:

; 3395 : 
; 3396 : 	case PEACE_TREATY_SUBMISSION:
; 3397 : 		iPercentGoldToGive = 100;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 100 ; 00000064H

; 3398 : 		iPercentGPTToGive = 100;

	mov	DWORD PTR _iPercentGPTToGive$[ebp], 100	; 00000064H

; 3399 : 		bGiveOpenBorders = true;

	mov	BYTE PTR _bGiveOpenBorders$[ebp], 1

; 3400 : 		bGiveUpStratResources = true;

	mov	BYTE PTR _bGiveUpStratResources$[ebp], 1

; 3401 : 		bGiveUpLuxuryResources = true;

	mov	BYTE PTR _bGiveUpLuxuryResources$[ebp], 1

; 3402 : 		break;

	jmp	SHORT $LN51@DoAddItems
$LN45@DoAddItems:

; 3403 : 
; 3404 : 	case PEACE_TREATY_SURRENDER:
; 3405 : 		bGiveOnlyOneCity = true;

	mov	BYTE PTR _bGiveOnlyOneCity$[ebp], 1

; 3406 : 		break;

	jmp	SHORT $LN51@DoAddItems
$LN44@DoAddItems:

; 3407 : 
; 3408 : 	case PEACE_TREATY_CESSION:
; 3409 : 		iPercentCitiesGiveUp = 25;

	mov	DWORD PTR _iPercentCitiesGiveUp$[ebp], 25 ; 00000019H

; 3410 : 		iPercentGoldToGive = 50;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 50	; 00000032H

; 3411 : 		break;

	jmp	SHORT $LN51@DoAddItems
$LN43@DoAddItems:

; 3412 : 
; 3413 : 	case PEACE_TREATY_CAPITULATION:
; 3414 : 		iPercentCitiesGiveUp = 33;

	mov	DWORD PTR _iPercentCitiesGiveUp$[ebp], 33 ; 00000021H

; 3415 : 		iPercentGoldToGive = 100;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 100 ; 00000064H

; 3416 : 		break;

	jmp	SHORT $LN51@DoAddItems
$LN42@DoAddItems:

; 3417 : 
; 3418 : 	case PEACE_TREATY_UNCONDITIONAL_SURRENDER:
; 3419 : 		iPercentCitiesGiveUp = 100;

	mov	DWORD PTR _iPercentCitiesGiveUp$[ebp], 100 ; 00000064H

; 3420 : 		iPercentGoldToGive = 100;

	mov	DWORD PTR _iPercentGoldToGive$[ebp], 100 ; 00000064H
$LN51@DoAddItems:

; 3421 : 		break;
; 3422 : 	}
; 3423 : 
; 3424 : 	int iDuration = GC.getGame().GetDealDuration();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226990[ebp], eax
	mov	ecx, DWORD PTR $T226990[ebp]
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	mov	DWORD PTR _iDuration$[ebp], eax

; 3425 : 
; 3426 : 	PlayerTypes eLosingPlayer = bMeSurrendering ? GetPlayer()->GetID() : eOtherPlayer;

	movzx	ecx, BYTE PTR _bMeSurrendering$[ebp]
	test	ecx, ecx
	je	SHORT $LN55@DoAddItems
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T226999[ebp], eax
	mov	edx, DWORD PTR $T227000[ebp]
	mov	DWORD PTR tv77[ebp], edx
	mov	eax, DWORD PTR $T226999[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN56@DoAddItems
$LN55@DoAddItems:
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	mov	DWORD PTR tv77[ebp], edx
$LN56@DoAddItems:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR _eLosingPlayer$[ebp], eax

; 3427 : 	CvPlayer* pLosingPlayer = &GET_PLAYER(eLosingPlayer);

	mov	ecx, DWORD PTR _eLosingPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pLosingPlayer$[ebp], ecx

; 3428 : 	PlayerTypes eWinningPlayer = bMeSurrendering ? eOtherPlayer : GetPlayer()->GetID();

	movzx	edx, BYTE PTR _bMeSurrendering$[ebp]
	test	edx, edx
	je	SHORT $LN57@DoAddItems
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN58@DoAddItems
$LN57@DoAddItems:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227012[ebp], eax
	mov	ecx, DWORD PTR $T227013[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	mov	edx, DWORD PTR $T227012[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR tv90[ebp], eax
$LN58@DoAddItems:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _eWinningPlayer$[ebp], ecx

; 3429 : 	CvPlayer* pWinningPlayer = &GET_PLAYER(eWinningPlayer);

	mov	edx, DWORD PTR _eWinningPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pWinningPlayer$[ebp], edx

; 3430 : 
; 3431 : 	DoAddPlayersAlliesToTreaty(eOtherPlayer, pDeal);

	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty

; 3432 : 
; 3433 : 	CvCity* pLoopCity;
; 3434 : 	int iCityLoop;
; 3435 : 
; 3436 : 	// Gold
; 3437 : 	int iGold = 0;

	mov	DWORD PTR _iGold$[ebp], 0

; 3438 : 	if (iPercentGoldToGive > 0)

	cmp	DWORD PTR _iPercentGoldToGive$[ebp], 0
	jle	SHORT $LN41@DoAddItems

; 3439 : 	{
; 3440 : 		iGold = pDeal->GetGoldAvailable(eLosingPlayer, TRADE_ITEM_GOLD);

	push	0
	mov	edx, DWORD PTR _eLosingPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
	mov	DWORD PTR _iGold$[ebp], eax

; 3441 : 		if(iGold > 0)

	cmp	DWORD PTR _iGold$[ebp], 0
	jle	SHORT $LN41@DoAddItems

; 3442 : 		{
; 3443 : 			iGold = iGold * iPercentGoldToGive / 100;

	mov	eax, DWORD PTR _iGold$[ebp]
	imul	eax, DWORD PTR _iPercentGoldToGive$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGold$[ebp], eax

; 3444 : 
; 3445 : 			if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_GOLD, iGold))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	edx, DWORD PTR _iGold$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _eWinningPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLosingPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN41@DoAddItems

; 3446 : 			{
; 3447 : 				pDeal->AddGoldTrade(eLosingPlayer, iGold);

	mov	eax, DWORD PTR _iGold$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLosingPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade
$LN41@DoAddItems:

; 3448 : 			}
; 3449 : 		}
; 3450 : 	}
; 3451 : 
; 3452 : 	// Gold per turn
; 3453 : 	int iGPT = 0;

	mov	DWORD PTR _iGPT$[ebp], 0

; 3454 : 	if (iPercentGPTToGive > 0)

	cmp	DWORD PTR _iPercentGPTToGive$[ebp], 0
	jle	$LN38@DoAddItems

; 3455 : 	{
; 3456 : 		iGPT = min(pLosingPlayer->calculateGoldRate(), pWinningPlayer->calculateGoldRate() / /*3*/ GC.getARMISTICE_GPT_DIVISOR());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+5028
	mov	DWORD PTR $T227020[ebp], edx
	mov	ecx, DWORD PTR _pWinningPlayer$[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	cdq
	idiv	DWORD PTR $T227020[ebp]
	mov	DWORD PTR $T226983[ebp], eax
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	mov	DWORD PTR $T226984[ebp], eax
	mov	eax, DWORD PTR $T226983[ebp]
	cmp	eax, DWORD PTR $T226984[ebp]
	jge	SHORT $LN78@DoAddItems
	lea	ecx, DWORD PTR $T226983[ebp]
	mov	DWORD PTR tv435[ebp], ecx
	jmp	SHORT $LN79@DoAddItems
$LN78@DoAddItems:
	lea	edx, DWORD PTR $T226984[ebp]
	mov	DWORD PTR tv435[ebp], edx
$LN79@DoAddItems:
	mov	eax, DWORD PTR tv435[ebp]
	mov	DWORD PTR $T227027[ebp], eax
	mov	ecx, DWORD PTR $T227027[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iGPT$[ebp], edx

; 3457 : 		if (iGPT > 0)

	cmp	DWORD PTR _iGPT$[ebp], 0
	jle	SHORT $LN38@DoAddItems

; 3458 : 		{
; 3459 : 			iGPT = iGPT * iPercentGPTToGive / 100;

	mov	eax, DWORD PTR _iGPT$[ebp]
	imul	eax, DWORD PTR _iPercentGPTToGive$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGPT$[ebp], eax

; 3460 : 
; 3461 : 			if(iGPT > 0 && pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_GOLD_PER_TURN, iGPT, iDuration))

	cmp	DWORD PTR _iGPT$[ebp], 0
	jle	SHORT $LN38@DoAddItems
	push	0
	push	1
	push	0
	push	-1
	mov	edx, DWORD PTR _iDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _iGPT$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _eWinningPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eLosingPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN38@DoAddItems

; 3462 : 			{
; 3463 : 				pDeal->AddGoldPerTurnTrade(eLosingPlayer, iGPT, iDuration);

	mov	ecx, DWORD PTR _iDuration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iGPT$[ebp]
	push	edx
	mov	eax, DWORD PTR _eLosingPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddGoldPerTurnTrade@CvDeal@@QAEXW4PlayerTypes@@HH@Z ; CvDeal::AddGoldPerTurnTrade
$LN38@DoAddItems:

; 3464 : 			}
; 3465 : 		}
; 3466 : 	}
; 3467 : 
; 3468 : 	// Open Borders
; 3469 : 	if (bGiveOpenBorders)

	movzx	ecx, BYTE PTR _bGiveOpenBorders$[ebp]
	test	ecx, ecx
	je	SHORT $LN35@DoAddItems

; 3470 : 	{
; 3471 : 		if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_OPEN_BORDERS))

	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	mov	edx, DWORD PTR _eWinningPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eLosingPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@DoAddItems

; 3472 : 		{
; 3473 : 			pDeal->AddOpenBorders(eLosingPlayer, iDuration);

	mov	edx, DWORD PTR _iDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _eLosingPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders
$LN35@DoAddItems:

; 3474 : 		}
; 3475 : 	}
; 3476 : 
; 3477 : 	// Resources
; 3478 : 	ResourceUsageTypes eUsage;
; 3479 : 	ResourceTypes eResource;
; 3480 : 	int iResourceQuantity;
; 3481 : #ifdef AUI_WARNING_FIXES
; 3482 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 3483 : #else
; 3484 : 	for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$223114[ebp], 0
	jmp	SHORT $LN33@DoAddItems
$LN32@DoAddItems:
	mov	ecx, DWORD PTR _iResourceLoop$223114[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$223114[ebp], ecx
$LN33@DoAddItems:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$223114[ebp], eax
	jge	$LN31@DoAddItems

; 3485 : #endif
; 3486 : 	{
; 3487 : 		eResource = (ResourceTypes) iResourceLoop;

	mov	edx, DWORD PTR _iResourceLoop$223114[ebp]
	mov	DWORD PTR _eResource$[ebp], edx

; 3488 : 
; 3489 : 		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$223119[ebp], eax

; 3490 : 		if (pkResourceInfo == NULL)

	cmp	DWORD PTR _pkResourceInfo$223119[ebp], 0
	jne	SHORT $LN30@DoAddItems

; 3491 : 			continue;

	jmp	SHORT $LN32@DoAddItems
$LN30@DoAddItems:

; 3492 : 
; 3493 : 		eUsage = pkResourceInfo->getResourceUsage();

	mov	ecx, DWORD PTR _pkResourceInfo$223119[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eUsage$[ebp], eax

; 3494 : 
; 3495 : 		// Can't trade bonus Resources
; 3496 : 		if(eUsage == RESOURCEUSAGE_BONUS)

	cmp	DWORD PTR _eUsage$[ebp], 0
	jne	SHORT $LN29@DoAddItems

; 3497 : 		{
; 3498 : 			continue;

	jmp	SHORT $LN32@DoAddItems
$LN29@DoAddItems:

; 3499 : 		}
; 3500 : 
; 3501 : 		iResourceQuantity = pLosingPlayer->getNumResourceAvailable(eResource, false);

	push	0
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	mov	DWORD PTR _iResourceQuantity$[ebp], eax

; 3502 : 
; 3503 : 		// Don't bother looking at this Resource if the other player doesn't even have any of it
; 3504 : 		if (iResourceQuantity == 0)

	cmp	DWORD PTR _iResourceQuantity$[ebp], 0
	jne	SHORT $LN28@DoAddItems

; 3505 : 		{
; 3506 : 			continue;

	jmp	SHORT $LN32@DoAddItems
$LN28@DoAddItems:

; 3507 : 		}
; 3508 : 
; 3509 : 		// Match with deal type
; 3510 : 		if (eUsage == RESOURCEUSAGE_LUXURY && !bGiveUpLuxuryResources)

	cmp	DWORD PTR _eUsage$[ebp], 2
	jne	SHORT $LN27@DoAddItems
	movzx	edx, BYTE PTR _bGiveUpLuxuryResources$[ebp]
	test	edx, edx
	jne	SHORT $LN27@DoAddItems

; 3511 : 		{
; 3512 : 			continue;

	jmp	SHORT $LN32@DoAddItems
$LN27@DoAddItems:

; 3513 : 		}
; 3514 : 
; 3515 : 		if (eUsage == RESOURCEUSAGE_STRATEGIC && !bGiveUpStratResources)

	cmp	DWORD PTR _eUsage$[ebp], 1
	jne	SHORT $LN26@DoAddItems
	movzx	eax, BYTE PTR _bGiveUpStratResources$[ebp]
	test	eax, eax
	jne	SHORT $LN26@DoAddItems

; 3516 : 		{
; 3517 : 			continue;

	jmp	$LN32@DoAddItems
$LN26@DoAddItems:

; 3518 : 		}
; 3519 : 
; 3520 : 		// Can only get 1 copy of a Luxury
; 3521 : 		if (eUsage == RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _eUsage$[ebp], 2
	jne	SHORT $LN25@DoAddItems

; 3522 : 		{
; 3523 : 			iResourceQuantity = 1;

	mov	DWORD PTR _iResourceQuantity$[ebp], 1
$LN25@DoAddItems:

; 3524 : 		}
; 3525 : 
; 3526 : 		if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_RESOURCES, eResource, iResourceQuantity))

	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR _iResourceQuantity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _eWinningPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLosingPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN24@DoAddItems

; 3527 : 		{
; 3528 : 			pDeal->AddResourceTrade(eLosingPlayer, eResource, iResourceQuantity, iDuration);

	mov	eax, DWORD PTR _iDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iResourceQuantity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _eLosingPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade
$LN24@DoAddItems:

; 3529 : 		}
; 3530 : 	}

	jmp	$LN32@DoAddItems
$LN31@DoAddItems:

; 3531 : 
; 3532 : 	//	Give up all but capital?
; 3533 : 	if (iPercentCitiesGiveUp == 100)

	cmp	DWORD PTR _iPercentCitiesGiveUp$[ebp], 100 ; 00000064H
	jne	$LN23@DoAddItems

; 3534 : 	{
; 3535 : 		// All Cities but the capital
; 3536 : 		for(pLoopCity = pLosingPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pLosingPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN22@DoAddItems
$LN21@DoAddItems:
	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN22@DoAddItems:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN20@DoAddItems

; 3537 : 		{
; 3538 : #ifndef AUI_DEAL_ALLOW_CAPITOL_GIFTING
; 3539 : 			if(pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN82@DoAddItems

; 3540 : 			{
; 3541 : 				continue;

	jmp	SHORT $LN21@DoAddItems

; 3542 : 			}
; 3543 : #endif
; 3544 : 
; 3545 : 			if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))

$LN82@DoAddItems:
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T227038[ebp], edx
	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T227047[ebp], ecx
	push	0
	push	1
	push	0
	push	-1
	mov	edx, DWORD PTR $T227038[ebp]
	push	edx
	mov	eax, DWORD PTR $T227047[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _eWinningPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eLosingPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@DoAddItems

; 3546 : 			{
; 3547 : 				pDeal->AddCityTrade(eLosingPlayer, pLoopCity->GetID());

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR $T227056[ebp], edx
	mov	eax, DWORD PTR $T227056[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLosingPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade
$LN18@DoAddItems:

; 3548 : 			}
; 3549 : 		}

	jmp	$LN21@DoAddItems
$LN20@DoAddItems:

; 3550 : 	}
; 3551 : 
; 3552 : 	// If the player only has 1 City then we can't get any more from him
; 3553 : #ifdef AUI_WARNING_FIXES
; 3554 : 	else if (iPercentCitiesGiveUp > 0 || (bGiveOnlyOneCity && pLosingPlayer->getNumCities() > 1))
; 3555 : #else
; 3556 : 	else if (iPercentCitiesGiveUp > 0 || bGiveOnlyOneCity && pLosingPlayer->getNumCities() > 1)

	jmp	$LN53@DoAddItems
$LN23@DoAddItems:
	cmp	DWORD PTR _iPercentCitiesGiveUp$[ebp], 0
	jg	SHORT $LN15@DoAddItems
	movzx	edx, BYTE PTR _bGiveOnlyOneCity$[ebp]
	test	edx, edx
	je	$LN53@DoAddItems
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jle	$LN53@DoAddItems
$LN15@DoAddItems:

; 3557 : #endif
; 3558 : 	{
; 3559 : 		int iCityValue = 0;

	mov	DWORD PTR _iCityValue$223136[ebp], 0

; 3560 : 		int iCityDistanceFromWinnersCapital = 0;

	mov	DWORD PTR _iCityDistanceFromWinnersCapital$223137[ebp], 0

; 3561 : 		int iWinnerCapitalX = -1, iWinnerCapitalY = -1;

	mov	DWORD PTR _iWinnerCapitalX$223138[ebp], -1
	mov	DWORD PTR _iWinnerCapitalY$223139[ebp], -1

; 3562 : 
; 3563 : 		// If winner has no capital then we can't use proximity - it will stay at 0
; 3564 : 		CvCity* pWinnerCapital = pWinningPlayer->getCapitalCity();

	mov	ecx, DWORD PTR _pWinningPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pWinnerCapital$223140[ebp], eax

; 3565 : 		if(pWinnerCapital != NULL)

	cmp	DWORD PTR _pWinnerCapital$223140[ebp], 0
	je	SHORT $LN14@DoAddItems

; 3566 : 		{
; 3567 : 			iWinnerCapitalX = pWinnerCapital->getX();

	mov	eax, DWORD PTR _pWinnerCapital$223140[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _iWinnerCapitalX$223138[ebp], ecx

; 3568 : 			iWinnerCapitalY = pWinnerCapital->getY();

	mov	edx, DWORD PTR _pWinnerCapital$223140[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR _iWinnerCapitalY$223139[ebp], eax
$LN14@DoAddItems:

; 3569 : 		}
; 3570 : 
; 3571 : 		// Create vector of the losing players' Cities so we can see which are the closest to the winner
; 3572 : 		CvWeightedVector<int> viCityProximities;

	lea	ecx, DWORD PTR _viCityProximities$223143[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3573 : 
; 3574 : 		// Loop through all of the loser's Cities
; 3575 : 		for(pLoopCity = pLosingPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pLosingPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN13@DoAddItems
$LN12@DoAddItems:
	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN13@DoAddItems:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN11@DoAddItems

; 3576 : 		{
; 3577 : 			// Get total city value of the loser
; 3578 : 			iCityValue += GetCityValue(pLoopCity->getX(), pLoopCity->getY(), bMeSurrendering, eOtherPlayer, /*bUseEvenValue*/ true);

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T227090[ebp], ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T227099[ebp], eax
	push	1
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bMeSurrendering$[ebp]
	push	edx
	mov	eax, DWORD PTR $T227090[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227099[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	add	eax, DWORD PTR _iCityValue$223136[ebp]
	mov	DWORD PTR _iCityValue$223136[ebp], eax

; 3579 : 
; 3580 : 			// If winner has no capital, Distance defaults to 0
; 3581 : 			if(pWinnerCapital != NULL)

	cmp	DWORD PTR _pWinnerCapital$223140[ebp], 0
	je	SHORT $LN10@DoAddItems

; 3582 : 			{
; 3583 : 				iCityDistanceFromWinnersCapital = plotDistance(iWinnerCapitalX, iWinnerCapitalY, pLoopCity->getX(), pLoopCity->getY());

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T227108[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T227117[ebp], edx
	mov	eax, DWORD PTR $T227108[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227117[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWinnerCapitalY$223139[ebp]
	push	edx
	mov	eax, DWORD PTR _iWinnerCapitalX$223138[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iCityDistanceFromWinnersCapital$223137[ebp], eax
$LN10@DoAddItems:

; 3584 : 			}
; 3585 : 
; 3586 : 			// Divide the distance by three if the city was originally owned by the winning player to make these cities more likely
; 3587 : 			if (pLoopCity->getOriginalOwner() == eWinningPlayer)

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getOriginalOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ; CvCity::getOriginalOwner
	cmp	eax, DWORD PTR _eWinningPlayer$[ebp]
	jne	SHORT $LN9@DoAddItems

; 3588 : 			{
; 3589 : 				iCityDistanceFromWinnersCapital /= 3;

	mov	eax, DWORD PTR _iCityDistanceFromWinnersCapital$223137[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _iCityDistanceFromWinnersCapital$223137[ebp], eax
$LN9@DoAddItems:

; 3590 : 			}
; 3591 : 
; 3592 : 			// Don't include the capital in the list of Cities the winner can receive
; 3593 : 			if(!pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@DoAddItems

; 3594 : 			{
; 3595 : 				viCityProximities.push_back(pLoopCity->GetID(), iCityDistanceFromWinnersCapital);

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR $T227187[ebp], ecx
	mov	edx, DWORD PTR $T227187[ebp]
	mov	DWORD PTR $T226985[ebp], edx
	mov	DWORD PTR _weightedElem$227205[ebp], 0
	mov	DWORD PTR _weightedElem$227205[ebp+4], 0
	mov	eax, DWORD PTR $T226985[ebp]
	mov	DWORD PTR _weightedElem$227205[ebp], eax
	mov	ecx, DWORD PTR _iCityDistanceFromWinnersCapital$223137[ebp]
	mov	DWORD PTR _weightedElem$227205[ebp+4], ecx
	lea	edx, DWORD PTR _weightedElem$227205[ebp]
	push	edx
	lea	ecx, DWORD PTR _viCityProximities$223143[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back
$LN8@DoAddItems:

; 3596 : 			}
; 3597 : 		}

	jmp	$LN12@DoAddItems
$LN11@DoAddItems:

; 3598 : 
; 3599 : 		// Sort the vector based on distance from winner's capital
; 3600 : 		viCityProximities.SortItems();

	lea	ecx, DWORD PTR _viCityProximities$223143[ebp]
	call	?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ ; CvWeightedVector<int,1,0>::SortItems

; 3601 : 		int iSortedCityID;
; 3602 : 
; 3603 : 		// Just one city?
; 3604 : 		if (bGiveOnlyOneCity)

	movzx	eax, BYTE PTR _bGiveOnlyOneCity$[ebp]
	test	eax, eax
	je	SHORT $LN7@DoAddItems

; 3605 : 		{
; 3606 : 			iSortedCityID = viCityProximities.GetElement(viCityProximities.size() - 1);

	mov	ecx, DWORD PTR _viCityProximities$223143[ebp+4]
	mov	DWORD PTR $T227237[ebp], ecx
	mov	edx, DWORD PTR $T227237[ebp]
	mov	eax, DWORD PTR _viCityProximities$223143[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	DWORD PTR _iSortedCityID$223151[ebp], ecx

; 3607 : 			pDeal->AddCityTrade(eLosingPlayer, iSortedCityID);

	mov	edx, DWORD PTR _iSortedCityID$223151[ebp]
	push	edx
	mov	eax, DWORD PTR _eLosingPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade

; 3608 : 		}
; 3609 : 
; 3610 : 		else

	jmp	$LN6@DoAddItems
$LN7@DoAddItems:

; 3611 : 		{
; 3612 : 			// Determine the value of Cities to be given up
; 3613 : 			int iCityValueToSurrender = iCityValue * iPercentCitiesGiveUp / 100;

	mov	eax, DWORD PTR _iCityValue$223136[ebp]
	imul	eax, DWORD PTR _iPercentCitiesGiveUp$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCityValueToSurrender$223154[ebp], eax

; 3614 : 
; 3615 : 			// Loop through sorted Cities and add them to the deal if they're under the amount to give up - start from the back of the list, because that's where the CLOSEST cities are
; 3616 : 			for(int iSortedCityIndex = viCityProximities.size() - 1; iSortedCityIndex > -1 ; iSortedCityIndex--)

	mov	edx, DWORD PTR _viCityProximities$223143[ebp+4]
	mov	DWORD PTR $T227254[ebp], edx
	mov	eax, DWORD PTR $T227254[ebp]
	sub	eax, 1
	mov	DWORD PTR _iSortedCityIndex$223155[ebp], eax
	jmp	SHORT $LN5@DoAddItems
$LN4@DoAddItems:
	mov	ecx, DWORD PTR _iSortedCityIndex$223155[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iSortedCityIndex$223155[ebp], ecx
$LN5@DoAddItems:
	cmp	DWORD PTR _iSortedCityIndex$223155[ebp], -1
	jle	$LN6@DoAddItems

; 3617 : 			{
; 3618 : 				iSortedCityID = viCityProximities.GetElement(iSortedCityIndex);

	mov	edx, DWORD PTR _iSortedCityIndex$223155[ebp]
	mov	eax, DWORD PTR _viCityProximities$223143[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _iSortedCityID$223151[ebp], ecx

; 3619 : 				pLoopCity = pLosingPlayer->getCity(iSortedCityID);

	mov	edx, DWORD PTR _iSortedCityID$223151[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLosingPlayer$[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	DWORD PTR _pLoopCity$[ebp], eax

; 3620 : 
; 3621 : 				iCityValue = GetCityValue(pLoopCity->getX(), pLoopCity->getY(), bMeSurrendering, eOtherPlayer, /*bUseEvenValue*/ true);

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T227275[ebp], ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T227284[ebp], eax
	push	1
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bMeSurrendering$[ebp]
	push	edx
	mov	eax, DWORD PTR $T227275[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227284[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityValue@CvDealAI@@QAEHHH_NW4PlayerTypes@@0@Z ; CvDealAI::GetCityValue
	mov	DWORD PTR _iCityValue$223136[ebp], eax

; 3622 : 
; 3623 : 				// City is worth less than what is left to be added to the deal, so add it
; 3624 : 				if(iCityValue < iCityValueToSurrender)

	mov	edx, DWORD PTR _iCityValue$223136[ebp]
	cmp	edx, DWORD PTR _iCityValueToSurrender$223154[ebp]
	jge	SHORT $LN2@DoAddItems

; 3625 : 				{
; 3626 : 					if(pDeal->IsPossibleToTradeItem(eLosingPlayer, eWinningPlayer, TRADE_ITEM_CITIES, pLoopCity->getX(), pLoopCity->getY()))

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T227293[ebp], ecx
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T227302[ebp], eax
	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR $T227293[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227302[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _eWinningPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLosingPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@DoAddItems

; 3627 : 					{
; 3628 : 						pDeal->AddCityTrade(eLosingPlayer, iSortedCityID);

	mov	eax, DWORD PTR _iSortedCityID$223151[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLosingPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddCityTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddCityTrade

; 3629 : 						iCityValueToSurrender -= iCityValue;

	mov	edx, DWORD PTR _iCityValueToSurrender$223154[ebp]
	sub	edx, DWORD PTR _iCityValue$223136[ebp]
	mov	DWORD PTR _iCityValueToSurrender$223154[ebp], edx
$LN2@DoAddItems:

; 3630 : 					}
; 3631 : 				}
; 3632 : 			}

	jmp	$LN4@DoAddItems
$LN6@DoAddItems:

; 3633 : 		}
; 3634 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _viCityProximities$223143[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
$LN53@DoAddItems:

; 3635 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN256@DoAddItems:
	DD	$LN49@DoAddItems
	DD	$LN48@DoAddItems
	DD	$LN47@DoAddItems
	DD	$LN46@DoAddItems
	DD	$LN45@DoAddItems
	DD	$LN44@DoAddItems
	DD	$LN43@DoAddItems
	DD	$LN42@DoAddItems
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _viCityProximities$223143[ebp]
	jmp	??1?$CvWeightedVector@H$00$0A@@@QAE@XZ	; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
__ehhandler$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-380]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ENDP ; CvDealAI::DoAddItemsToDealForPeaceTreaty
; Function compile flags: /Odtp
;	COMDAT ?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ PROC	; CvDealAI::GetCachedValueOfPeaceWithHuman, COMDAT
; _this$ = ecx

; 3639 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3640 : 	return m_iCachedValueOfPeaceWithHuman;		// NOT SERIALIZED

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 3641 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCachedValueOfPeaceWithHuman@CvDealAI@@QAEHXZ ENDP	; CvDealAI::GetCachedValueOfPeaceWithHuman
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iValue$ = 8						; size = 4
?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z PROC	; CvDealAI::SetCachedValueOfPeaceWithHuman, COMDAT
; _this$ = ecx

; 3645 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3646 : 	m_iCachedValueOfPeaceWithHuman = iValue;		// NOT SERIALIZED

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 3647 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ENDP	; CvDealAI::SetCachedValueOfPeaceWithHuman
_TEXT	ENDS
EXTRN	?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z:PROC ; CvDeal::AddThirdPartyPeace
EXTRN	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvDeal::IsThirdPartyPeaceTrade
EXTRN	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z:PROC ; CvMinorCivAI::IsPermanentWar
; Function compile flags: /Odtp
;	COMDAT ?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
$T227510 = -124						; size = 4
$T227509 = -120						; size = 4
$T227500 = -116						; size = 4
$T227491 = -112						; size = 4
$T227482 = -108						; size = 4
$T227473 = -104						; size = 4
$T227469 = -100						; size = 4
$T227465 = -96						; size = 4
$T227456 = -92						; size = 4
$T227452 = -88						; size = 4
$T227443 = -84						; size = 4
$T227442 = -80						; size = 4
$T227433 = -76						; size = 4
$T227432 = -72						; size = 4
$T227423 = -68						; size = 4
$T227414 = -64						; size = 4
$T227413 = -60						; size = 4
$T227404 = -56						; size = 4
$T227395 = -52						; size = 4
$T227394 = -48						; size = 4
$T227385 = -44						; size = 4
$T227376 = -40						; size = 4
$T227375 = -36						; size = 4
$T227371 = -32						; size = 4
$T227362 = -25						; size = 1
$T227350 = -24						; size = 4
_eAlly$223182 = -20					; size = 4
_iMinorLoop$223176 = -16				; size = 4
_eMinor$ = -12						; size = 4
_pMinor$ = -8						; size = 4
_iPeaceDuration$ = -4					; size = 4
_eToPlayer$ = 8						; size = 4
_pDeal$ = 12						; size = 4
?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::DoAddPlayersAlliesToTreaty, COMDAT
; _this$ = ecx

; 3651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 3652 : 	int iPeaceDuration = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227350[ebp], eax
	mov	ecx, DWORD PTR $T227350[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	mov	DWORD PTR _iPeaceDuration$[ebp], eax

; 3653 : 	PlayerTypes eMinor;
; 3654 : 	CvPlayer* pMinor;
; 3655 : 	for(int iMinorLoop = MAX_MAJOR_CIVS; iMinorLoop < MAX_CIV_PLAYERS; iMinorLoop++)

	mov	DWORD PTR _iMinorLoop$223176[ebp], 22	; 00000016H
	jmp	SHORT $LN13@DoAddPlaye
$LN12@DoAddPlaye:
	mov	ecx, DWORD PTR _iMinorLoop$223176[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMinorLoop$223176[ebp], ecx
$LN13@DoAddPlaye:
	cmp	DWORD PTR _iMinorLoop$223176[ebp], 63	; 0000003fH
	jge	$LN14@DoAddPlaye

; 3656 : 	{
; 3657 : 		eMinor = (PlayerTypes) iMinorLoop;

	mov	edx, DWORD PTR _iMinorLoop$223176[ebp]
	mov	DWORD PTR _eMinor$[ebp], edx

; 3658 : 		pMinor = &GET_PLAYER(eMinor);

	mov	eax, DWORD PTR _eMinor$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pMinor$[ebp], eax

; 3659 : 
; 3660 : 		// Minor not alive?
; 3661 : 		if(!pMinor->isAlive())

	mov	ecx, DWORD PTR _pMinor$[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T227362[ebp], dl
	movzx	eax, BYTE PTR $T227362[ebp]
	test	eax, eax
	jne	SHORT $LN10@DoAddPlaye

; 3662 : 			continue;

	jmp	SHORT $LN12@DoAddPlaye
$LN10@DoAddPlaye:

; 3663 : 
; 3664 : 		PlayerTypes eAlly = pMinor->GetMinorCivAI()->GetAlly();

	mov	ecx, DWORD PTR _pMinor$[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR _eAlly$223182[ebp], eax

; 3665 : 		// ally of other player
; 3666 : 		if (eAlly == eToPlayer)

	mov	ecx, DWORD PTR _eAlly$223182[ebp]
	cmp	ecx, DWORD PTR _eToPlayer$[ebp]
	jne	$LN9@DoAddPlaye

; 3667 : 		{
; 3668 : 			// if they are not at war with us, continue
; 3669 : 			if (!GET_TEAM(GetTeam()).isAtWar(pMinor->getTeam()))

	mov	edx, DWORD PTR _pMinor$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227371[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ	; CvDealAI::GetTeam
	mov	DWORD PTR $T227375[ebp], eax
	mov	ecx, DWORD PTR $T227375[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227376[ebp], ecx
	mov	edx, DWORD PTR $T227371[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227376[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@DoAddPlaye

; 3670 : 			{
; 3671 : 				continue;

	jmp	$LN12@DoAddPlaye
$LN8@DoAddPlaye:

; 3672 : 			}
; 3673 : 
; 3674 : 			// if they are always at war with us, continue
; 3675 : 			if (pMinor->GetMinorCivAI()->IsPermanentWar(GetTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ	; CvDealAI::GetTeam
	push	eax
	mov	ecx, DWORD PTR _pMinor$[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN32@DoAddPlaye

; 3676 : 			{
; 3677 : 				continue;

	jmp	$LN12@DoAddPlaye

; 3678 : 			}
; 3679 : 
; 3680 : 			// Add peace with this minor to the deal
; 3681 : 			// slewis - if there is not a peace deal with them already on the table and we can trade it
; 3682 : 			if(!pDeal->IsThirdPartyPeaceTrade(GetPlayer()->GetID(), pMinor->getTeam()) && pDeal->IsPossibleToTradeItem(GetPlayer()->GetID(), eToPlayer, TRADE_ITEM_THIRD_PARTY_PEACE, pMinor->getTeam()))

$LN32@DoAddPlaye:
	mov	edx, DWORD PTR _pMinor$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227385[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227394[ebp], eax
	mov	ecx, DWORD PTR $T227394[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227395[ebp], edx
	mov	eax, DWORD PTR $T227385[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227395[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyPeaceTrade
	movzx	edx, al
	test	edx, edx
	jne	$LN6@DoAddPlaye
	mov	eax, DWORD PTR _pMinor$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227404[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227413[ebp], eax
	mov	edx, DWORD PTR $T227413[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227414[ebp], eax
	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T227404[ebp]
	push	ecx
	push	14					; 0000000eH
	mov	edx, DWORD PTR _eToPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR $T227414[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@DoAddPlaye

; 3683 : 			{
; 3684 : 				pDeal->AddThirdPartyPeace(GetPlayer()->GetID(), pMinor->getTeam(), iPeaceDuration);

	mov	edx, DWORD PTR _pMinor$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227423[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227432[ebp], eax
	mov	ecx, DWORD PTR $T227432[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227433[ebp], edx
	mov	eax, DWORD PTR _iPeaceDuration$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227423[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227433[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::AddThirdPartyPeace
$LN6@DoAddPlaye:

; 3685 : 			}
; 3686 : 		}

	jmp	$LN5@DoAddPlaye
$LN9@DoAddPlaye:

; 3687 : 		// ally with us
; 3688 : 		else if (eAlly == GetPlayer()->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227442[ebp], eax
	mov	eax, DWORD PTR $T227442[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227443[ebp], ecx
	mov	edx, DWORD PTR _eAlly$223182[ebp]
	cmp	edx, DWORD PTR $T227443[ebp]
	jne	$LN5@DoAddPlaye

; 3689 : 		{
; 3690 : 			// if they are not at war with the opponent, continue
; 3691 : 			if (!GET_TEAM(GET_PLAYER(eToPlayer).getTeam()).isAtWar(pMinor->getTeam()))

	mov	eax, DWORD PTR _pMinor$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227452[ebp], eax
	mov	edx, DWORD PTR _eToPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227456[ebp], edx
	mov	eax, DWORD PTR $T227456[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227465[ebp], eax
	mov	edx, DWORD PTR $T227465[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227469[ebp], edx
	mov	eax, DWORD PTR $T227452[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227469[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@DoAddPlaye

; 3692 : 			{
; 3693 : 				continue;

	jmp	$LN12@DoAddPlaye
$LN3@DoAddPlaye:

; 3694 : 			}
; 3695 : 
; 3696 : 			// if they are always at war with them, continue
; 3697 : 			if (pMinor->GetMinorCivAI()->IsPermanentWar(GET_PLAYER(eToPlayer).getTeam()))

	mov	edx, DWORD PTR _eToPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227473[ebp], edx
	mov	eax, DWORD PTR $T227473[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227482[ebp], eax
	mov	edx, DWORD PTR $T227482[ebp]
	push	edx
	mov	ecx, DWORD PTR _pMinor$[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPermanentWar@CvMinorCivAI@@QBE_NW4TeamTypes@@@Z ; CvMinorCivAI::IsPermanentWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN78@DoAddPlaye

; 3698 : 			{
; 3699 : 				continue;

	jmp	$LN12@DoAddPlaye

; 3700 : 			}
; 3701 : 
; 3702 : 			// Add peace with this minor to the deal
; 3703 : 			// slewis - if there is not a peace deal with them already on the table and we can trade it
; 3704 : 			if(!pDeal->IsThirdPartyPeaceTrade(eToPlayer, pMinor->getTeam()) && pDeal->IsPossibleToTradeItem(eToPlayer, GetPlayer()->GetID(), TRADE_ITEM_THIRD_PARTY_PEACE, pMinor->getTeam()))

$LN78@DoAddPlaye:
	mov	ecx, DWORD PTR _pMinor$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227491[ebp], eax
	mov	eax, DWORD PTR $T227491[ebp]
	push	eax
	mov	ecx, DWORD PTR _eToPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsThirdPartyPeaceTrade@CvDeal@@QAE_NW4PlayerTypes@@W4TeamTypes@@@Z ; CvDeal::IsThirdPartyPeaceTrade
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN5@DoAddPlaye
	mov	eax, DWORD PTR _pMinor$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227500[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227509[ebp], eax
	mov	edx, DWORD PTR $T227509[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227510[ebp], eax
	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T227500[ebp]
	push	ecx
	push	14					; 0000000eH
	mov	edx, DWORD PTR $T227510[ebp]
	push	edx
	mov	eax, DWORD PTR _eToPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@DoAddPlaye

; 3705 : 			{
; 3706 : 				pDeal->AddThirdPartyPeace(eToPlayer, pMinor->getTeam(), iPeaceDuration);

	mov	edx, DWORD PTR _iPeaceDuration$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMinor$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _eToPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddThirdPartyPeace@CvDeal@@QAEXW4PlayerTypes@@W4TeamTypes@@H@Z ; CvDeal::AddThirdPartyPeace
$LN5@DoAddPlaye:

; 3707 : 			}
; 3708 : 		}

	jmp	$LN12@DoAddPlaye
$LN14@DoAddPlaye:

; 3709 : 	}
; 3710 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::DoAddPlayersAlliesToTreaty
_TEXT	ENDS
PUBLIC	?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeDemand
EXTRN	?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::SetDemandingPlayer
; Function compile flags: /Odtp
;	COMDAT ?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
tv152 = -48						; size = 4
_this$ = -44						; size = 4
$T227566 = -40						; size = 4
$T227565 = -36						; size = 4
$T227553 = -32						; size = 4
$T227547 = -28						; size = 4
$T227543 = -24						; size = 4
$T227534 = -20						; size = 4
$T227530 = -16						; size = 4
$T227529 = -12						; size = 4
_iMaxGold$ = -8						; size = 4
_iGold$ = -4						; size = 4
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeDemand, COMDAT
; _this$ = ecx

; 3714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 3715 : 	CvAssert(eOtherPlayer >= 0);
; 3716 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3717 : 
; 3718 : 	// Set that this CvDeal is a demand
; 3719 : 	pDeal->SetDemandingPlayer(GetPlayer()->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227529[ebp], eax
	mov	eax, DWORD PTR $T227529[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227530[ebp], ecx
	mov	edx, DWORD PTR $T227530[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?SetDemandingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetDemandingPlayer

; 3720 : 
; 3721 : 	int iGold = pDeal->GetGoldAvailable(eOtherPlayer, TRADE_ITEM_GOLD);

	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?GetGoldAvailable@CvDeal@@QAEHW4PlayerTypes@@W4TradeableItems@@@Z ; CvDeal::GetGoldAvailable
	mov	DWORD PTR _iGold$[ebp], eax

; 3722 : 
; 3723 : 	// Don't ask for too much
; 3724 : 	int iMaxGold = 200 + (GET_TEAM(GET_PLAYER(eOtherPlayer).getTeam()).GetCurrentEra() * 150);

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227534[ebp], ecx
	mov	edx, DWORD PTR $T227534[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T227543[ebp], eax
	mov	ecx, DWORD PTR $T227543[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227547[ebp], ecx
	mov	ecx, DWORD PTR $T227547[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	imul	eax, 150				; 00000096H
	add	eax, 200				; 000000c8H
	mov	DWORD PTR _iMaxGold$[ebp], eax

; 3725 : 	iGold = min(iMaxGold, iGold);

	mov	edx, DWORD PTR _iGold$[ebp]
	cmp	edx, DWORD PTR _iMaxGold$[ebp]
	jge	SHORT $LN18@IsMakeDema
	lea	eax, DWORD PTR _iGold$[ebp]
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN19@IsMakeDema
$LN18@IsMakeDema:
	lea	ecx, DWORD PTR _iMaxGold$[ebp]
	mov	DWORD PTR tv152[ebp], ecx
$LN19@IsMakeDema:
	mov	edx, DWORD PTR tv152[ebp]
	mov	DWORD PTR $T227553[ebp], edx
	mov	eax, DWORD PTR $T227553[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iGold$[ebp], ecx

; 3726 : 
; 3727 : 	if(pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_GOLD, iGold))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227565[ebp], eax
	mov	edx, DWORD PTR $T227565[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227566[ebp], eax
	push	0
	push	1
	push	0
	push	-1
	push	-1
	mov	ecx, DWORD PTR _iGold$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR $T227566[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@IsMakeDema

; 3728 : 	{
; 3729 : 		pDeal->AddGoldTrade(eOtherPlayer, iGold);

	mov	edx, DWORD PTR _iGold$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddGoldTrade@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddGoldTrade

; 3730 : 
; 3731 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsMakeDema
$LN1@IsMakeDema:

; 3732 : 	}
; 3733 : 
; 3734 : 	return false;

	xor	al, al
$LN2@IsMakeDema:

; 3735 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsMakeDemand@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeDemand
_TEXT	ENDS
PUBLIC	?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeOfferForLuxuryResource
; Function compile flags: /Odtp
;	COMDAT ?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T227604 = -56						; size = 4
$T227600 = -52						; size = 4
$T227596 = -48						; size = 4
$T227595 = -44						; size = 4
$T227586 = -40						; size = 4
$T227582 = -36						; size = 4
$T227578 = -32						; size = 4
$T227577 = -28						; size = 4
_bUselessReferenceVariable$223225 = -23			; size = 1
_bCantMatchOffer$223226 = -22				; size = 1
_bDealAcceptable$223222 = -21				; size = 1
_pkResourceInfo$223215 = -20				; size = 4
_iResourceLoop$ = -16					; size = 4
_eLuxuryFromThem$ = -12					; size = 4
_eApproach$ = -8					; size = 4
_eResource$ = -4					; size = 4
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeOfferForLuxuryResource, COMDAT
; _this$ = ecx

; 3739 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 3740 : 	CvAssert(eOtherPlayer >= 0);
; 3741 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3742 : 
; 3743 : 	ResourceTypes eLuxuryFromThem = NO_RESOURCE;

	mov	DWORD PTR _eLuxuryFromThem$[ebp], -1

; 3744 : 
; 3745 : 	// Don't ask for a Luxury if we're hostile or planning a war
; 3746 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR _eApproach$[ebp], eax

; 3747 : 	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE ||
; 3748 : 	        eApproach == MAJOR_CIV_APPROACH_WAR)

	cmp	DWORD PTR _eApproach$[ebp], 1
	je	SHORT $LN12@IsMakeOffe
	cmp	DWORD PTR _eApproach$[ebp], 0
	jne	SHORT $LN13@IsMakeOffe
$LN12@IsMakeOffe:

; 3749 : 	{
; 3750 : 		return false;

	xor	al, al
	jmp	$LN14@IsMakeOffe
$LN13@IsMakeOffe:

; 3751 : 	}
; 3752 : 
; 3753 : #ifdef AUI_WARNING_FIXES
; 3754 : 	uint iResourceLoop;
; 3755 : #else
; 3756 : 	int iResourceLoop;
; 3757 : #endif
; 3758 : 	ResourceTypes eResource;
; 3759 : 
; 3760 : 	// See if the other player has a Resource to trade
; 3761 : 	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$[ebp], 0
	jmp	SHORT $LN11@IsMakeOffe
$LN10@IsMakeOffe:
	mov	ecx, DWORD PTR _iResourceLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$[ebp], ecx
$LN11@IsMakeOffe:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$[ebp], eax
	jge	$LN9@IsMakeOffe

; 3762 : 	{
; 3763 : 		eResource = (ResourceTypes) iResourceLoop;

	mov	edx, DWORD PTR _iResourceLoop$[ebp]
	mov	DWORD PTR _eResource$[ebp], edx

; 3764 : 
; 3765 : 		// Only look at Luxuries
; 3766 : 		const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$223215[ebp], eax

; 3767 : 		if(pkResourceInfo == NULL || pkResourceInfo->getResourceUsage() != RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _pkResourceInfo$223215[ebp], 0
	je	SHORT $LN7@IsMakeOffe
	mov	ecx, DWORD PTR _pkResourceInfo$223215[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	je	SHORT $LN8@IsMakeOffe
$LN7@IsMakeOffe:

; 3768 : 		{
; 3769 : 			continue;

	jmp	SHORT $LN10@IsMakeOffe
$LN8@IsMakeOffe:

; 3770 : 		}
; 3771 : 
; 3772 : 		// Must not be banned by World Congress
; 3773 : 		if (GC.getGame().GetGameLeagues()->IsLuxuryHappinessBanned(GetPlayer()->GetID(), eResource))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227577[ebp], eax
	mov	ecx, DWORD PTR $T227577[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227578[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227582[ebp], eax
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227578[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227582[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?IsLuxuryHappinessBanned@CvGameLeagues@@QAE_NW4PlayerTypes@@W4ResourceTypes@@@Z ; CvGameLeagues::IsLuxuryHappinessBanned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@IsMakeOffe

; 3774 : 		{
; 3775 : 			continue;

	jmp	$LN10@IsMakeOffe
$LN6@IsMakeOffe:

; 3776 : 		}
; 3777 : 
; 3778 : 		// Any extras?
; 3779 : 		if(GET_PLAYER(eOtherPlayer).getNumResourceAvailable(eResource, false) > 1)

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227586[ebp], ecx
	push	0
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T227586[ebp]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	cmp	eax, 1
	jle	SHORT $LN5@IsMakeOffe

; 3780 : 		{
; 3781 : 			eLuxuryFromThem = eResource;

	mov	eax, DWORD PTR _eResource$[ebp]
	mov	DWORD PTR _eLuxuryFromThem$[ebp], eax

; 3782 : 			break;

	jmp	SHORT $LN9@IsMakeOffe
$LN5@IsMakeOffe:

; 3783 : 		}
; 3784 : 	}

	jmp	$LN10@IsMakeOffe
$LN9@IsMakeOffe:

; 3785 : 
; 3786 : 	// Extra Luxury found!
; 3787 : 	if(eLuxuryFromThem != NO_RESOURCE)

	cmp	DWORD PTR _eLuxuryFromThem$[ebp], -1
	je	$LN4@IsMakeOffe

; 3788 : 	{
; 3789 : 		// Can we actually complete this deal?
; 3790 : 		if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_RESOURCES, eLuxuryFromThem, 1))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227595[ebp], eax
	mov	ecx, DWORD PTR $T227595[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227596[ebp], edx
	push	0
	push	1
	push	0
	push	-1
	push	1
	mov	eax, DWORD PTR _eLuxuryFromThem$[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR $T227596[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@IsMakeOffe

; 3791 : 		{
; 3792 : 			return false;

	xor	al, al
	jmp	$LN14@IsMakeOffe
$LN3@IsMakeOffe:

; 3793 : 		}
; 3794 : 
; 3795 : 		// Seed the deal with the item we want
; 3796 : 		pDeal->AddResourceTrade(eOtherPlayer, eLuxuryFromThem, 1, GC.getGame().GetDealDuration());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227600[ebp], ecx
	mov	ecx, DWORD PTR $T227600[ebp]
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	push	1
	mov	edx, DWORD PTR _eLuxuryFromThem$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddResourceTrade@CvDeal@@QAEXW4PlayerTypes@@W4ResourceTypes@@HH@Z ; CvDeal::AddResourceTrade

; 3797 : 
; 3798 : 		bool bDealAcceptable = false;

	mov	BYTE PTR _bDealAcceptable$223222[ebp], 0

; 3799 : 
; 3800 : 		// AI evaluation
; 3801 : 		if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227604[ebp], ecx
	mov	ecx, DWORD PTR $T227604[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@IsMakeOffe

; 3802 : 		{
; 3803 : 			bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	mov	BYTE PTR _bDealAcceptable$223222[ebp], al

; 3804 : 		}
; 3805 : 		else

	jmp	SHORT $LN1@IsMakeOffe
$LN2@IsMakeOffe:

; 3806 : 		{
; 3807 : 			bool bUselessReferenceVariable;
; 3808 : 			bool bCantMatchOffer;
; 3809 : 			bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, /*bDontChangeMyExistingItems*/ false, /*bDontChangeTheirExistingItems*/ true, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	edx, DWORD PTR _bCantMatchOffer$223226[ebp]
	push	edx
	lea	eax, DWORD PTR _bUselessReferenceVariable$223225[ebp]
	push	eax
	push	1
	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	mov	BYTE PTR _bDealAcceptable$223222[ebp], al
$LN1@IsMakeOffe:

; 3810 : 		}
; 3811 : 
; 3812 : 		return bDealAcceptable;

	mov	al, BYTE PTR _bDealAcceptable$223222[ebp]
	jmp	SHORT $LN14@IsMakeOffe
$LN4@IsMakeOffe:

; 3813 : 	}
; 3814 : 
; 3815 : 	return false;

	xor	al, al
$LN14@IsMakeOffe:

; 3816 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsMakeOfferForLuxuryResource@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeOfferForLuxuryResource
_TEXT	ENDS
PUBLIC	?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::MakeOfferForEmbassy
EXTRN	?WantsEmbassyAtPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::WantsEmbassyAtPlayer
; Function compile flags: /Odtp
;	COMDAT ?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T227620 = -20						; size = 4
$T227616 = -16						; size = 4
$T227615 = -12						; size = 4
_bUselessReferenceVariable$223240 = -7			; size = 1
_bCantMatchOffer$223241 = -6				; size = 1
_bDealAcceptable$223237 = -5				; size = 1
_eApproach$ = -4					; size = 4
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::MakeOfferForEmbassy, COMDAT
; _this$ = ecx

; 3820 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3821 : 	CvAssert(eOtherPlayer >= 0);
; 3822 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3823 : 
; 3824 : 	// Don't ask for Open Borders if we're hostile or planning war
; 3825 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR _eApproach$[ebp], eax

; 3826 : 	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE ||
; 3827 : 	        eApproach == MAJOR_CIV_APPROACH_WAR		||
; 3828 : 	        eApproach == MAJOR_CIV_APPROACH_GUARDED)

	cmp	DWORD PTR _eApproach$[ebp], 1
	je	SHORT $LN5@MakeOfferF
	cmp	DWORD PTR _eApproach$[ebp], 0
	je	SHORT $LN5@MakeOfferF
	cmp	DWORD PTR _eApproach$[ebp], 3
	jne	SHORT $LN6@MakeOfferF
$LN5@MakeOfferF:

; 3829 : 	{
; 3830 : 		return false;

	xor	al, al
	jmp	$LN7@MakeOfferF
$LN6@MakeOfferF:

; 3831 : 	}
; 3832 : 
; 3833 : 	// Can we actually complete this deal?
; 3834 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_ALLOW_EMBASSY))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227615[ebp], eax
	mov	ecx, DWORD PTR $T227615[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227616[ebp], edx
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	17					; 00000011H
	mov	eax, DWORD PTR $T227616[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@MakeOfferF

; 3835 : 	{
; 3836 : 		return false;

	xor	al, al
	jmp	$LN7@MakeOfferF
$LN4@MakeOfferF:

; 3837 : 	}
; 3838 : 
; 3839 : 	// Do we actually want OB with eOtherPlayer?
; 3840 : 	if(GetPlayer()->GetDiplomacyAI()->WantsEmbassyAtPlayer(eOtherPlayer))

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?WantsEmbassyAtPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::WantsEmbassyAtPlayer
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@MakeOfferF

; 3841 : 	{
; 3842 : 		// Seed the deal with the item we want
; 3843 : 		pDeal->AddAllowEmbassy(eOtherPlayer);

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddAllowEmbassy@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::AddAllowEmbassy

; 3844 : 		bool bDealAcceptable = false;

	mov	BYTE PTR _bDealAcceptable$223237[ebp], 0

; 3845 : 
; 3846 : 		// AI evaluation
; 3847 : 		if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227620[ebp], eax
	mov	ecx, DWORD PTR $T227620[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@MakeOfferF

; 3848 : 		{
; 3849 : 			bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	mov	BYTE PTR _bDealAcceptable$223237[ebp], al

; 3850 : 		}
; 3851 : 		else

	jmp	SHORT $LN1@MakeOfferF
$LN2@MakeOfferF:

; 3852 : 		{
; 3853 : 			bool bUselessReferenceVariable;
; 3854 : 			bool bCantMatchOffer;
; 3855 : 			bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, false, true, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	ecx, DWORD PTR _bCantMatchOffer$223241[ebp]
	push	ecx
	lea	edx, DWORD PTR _bUselessReferenceVariable$223240[ebp]
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	mov	BYTE PTR _bDealAcceptable$223237[ebp], al
$LN1@MakeOfferF:

; 3856 : 		}
; 3857 : 
; 3858 : 		return bDealAcceptable;

	mov	al, BYTE PTR _bDealAcceptable$223237[ebp]
	jmp	SHORT $LN7@MakeOfferF
$LN3@MakeOfferF:

; 3859 : 	}
; 3860 : 
; 3861 : 	return false;

	xor	al, al
$LN7@MakeOfferF:

; 3862 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeOfferForEmbassy@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::MakeOfferForEmbassy
_TEXT	ENDS
PUBLIC	?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeOfferForOpenBorders
EXTRN	?IsWantsOpenBordersWithPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsWantsOpenBordersWithPlayer
; Function compile flags: /Odtp
;	COMDAT ?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T227640 = -24						; size = 4
$T227636 = -20						; size = 4
$T227632 = -16						; size = 4
$T227631 = -12						; size = 4
_bUselessReferenceVariable$223255 = -7			; size = 1
_bCantMatchOffer$223256 = -6				; size = 1
_bDealAcceptable$223252 = -5				; size = 1
_eApproach$ = -4					; size = 4
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeOfferForOpenBorders, COMDAT
; _this$ = ecx

; 3866 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 3867 : 	CvAssert(eOtherPlayer >= 0);
; 3868 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3869 : 
; 3870 : 	// Don't ask for Open Borders if we're hostile or planning war
; 3871 : 	MajorCivApproachTypes eApproach = GetPlayer()->GetDiplomacyAI()->GetMajorCivApproach(eOtherPlayer, /*bHideTrueFeelings*/ false);

	push	0
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR _eApproach$[ebp], eax

; 3872 : 	if(eApproach == MAJOR_CIV_APPROACH_HOSTILE ||
; 3873 : 	        eApproach == MAJOR_CIV_APPROACH_WAR)

	cmp	DWORD PTR _eApproach$[ebp], 1
	je	SHORT $LN5@IsMakeOffe@2
	cmp	DWORD PTR _eApproach$[ebp], 0
	jne	SHORT $LN6@IsMakeOffe@2
$LN5@IsMakeOffe@2:

; 3874 : 	{
; 3875 : 		return false;

	xor	al, al
	jmp	$LN7@IsMakeOffe@2
$LN6@IsMakeOffe@2:

; 3876 : 	}
; 3877 : 
; 3878 : 	// Can we actually complete this deal?
; 3879 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_OPEN_BORDERS))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227631[ebp], eax
	mov	ecx, DWORD PTR $T227631[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T227632[ebp], edx
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	6
	mov	eax, DWORD PTR $T227632[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@IsMakeOffe@2

; 3880 : 	{
; 3881 : 		return false;

	xor	al, al
	jmp	$LN7@IsMakeOffe@2
$LN4@IsMakeOffe@2:

; 3882 : 	}
; 3883 : 
; 3884 : 	// Do we actually want OB with eOtherPlayer?
; 3885 : 	if(GetPlayer()->GetDiplomacyAI()->IsWantsOpenBordersWithPlayer(eOtherPlayer))

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsWantsOpenBordersWithPlayer@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsWantsOpenBordersWithPlayer
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@IsMakeOffe@2

; 3886 : 	{
; 3887 : 		// Seed the deal with the item we want
; 3888 : 		pDeal->AddOpenBorders(eOtherPlayer, GC.getGame().GetDealDuration());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227636[ebp], edx
	mov	ecx, DWORD PTR $T227636[ebp]
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddOpenBorders@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddOpenBorders

; 3889 : 
; 3890 : 		bool bDealAcceptable = false;

	mov	BYTE PTR _bDealAcceptable$223252[ebp], 0

; 3891 : 
; 3892 : 		// AI evaluation
; 3893 : 		if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227640[ebp], ecx
	mov	ecx, DWORD PTR $T227640[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@IsMakeOffe@2

; 3894 : 		{
; 3895 : 			bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	mov	BYTE PTR _bDealAcceptable$223252[ebp], al

; 3896 : 		}
; 3897 : 		else

	jmp	SHORT $LN1@IsMakeOffe@2
$LN2@IsMakeOffe@2:

; 3898 : 		{
; 3899 : 			bool bUselessReferenceVariable;
; 3900 : 			bool bCantMatchOffer;
; 3901 : 			bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, false, true, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	edx, DWORD PTR _bCantMatchOffer$223256[ebp]
	push	edx
	lea	eax, DWORD PTR _bUselessReferenceVariable$223255[ebp]
	push	eax
	push	1
	push	0
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	mov	BYTE PTR _bDealAcceptable$223252[ebp], al
$LN1@IsMakeOffe@2:

; 3902 : 		}
; 3903 : 
; 3904 : 		return bDealAcceptable;

	mov	al, BYTE PTR _bDealAcceptable$223252[ebp]
	jmp	SHORT $LN7@IsMakeOffe@2
$LN3@IsMakeOffe@2:

; 3905 : 	}
; 3906 : 
; 3907 : 	return false;

	xor	al, al
$LN7@IsMakeOffe@2:

; 3908 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsMakeOfferForOpenBorders@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeOfferForOpenBorders
_TEXT	ENDS
PUBLIC	?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::IsMakeOfferForResearchAgreement
EXTRN	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z:PROC ; CvDeal::AddResearchAgreement
; Function compile flags: /Odtp
;	COMDAT ?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T227674 = -32						; size = 4
$T227670 = -28						; size = 4
$T227666 = -24						; size = 4
$T227665 = -20						; size = 4
$T227656 = -16						; size = 4
$T227652 = -12						; size = 4
$T227651 = -8						; size = 4
_bUselessReferenceVariable$223266 = -3			; size = 1
_bCantMatchOffer$223267 = -2				; size = 1
_bDealAcceptable$ = -1					; size = 1
_eOtherPlayer$ = 8					; size = 4
_pDeal$ = 12						; size = 4
?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z PROC ; CvDealAI::IsMakeOfferForResearchAgreement, COMDAT
; _this$ = ecx

; 3912 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3913 : 	CvAssert(eOtherPlayer >= 0);
; 3914 : 	CvAssert(eOtherPlayer < MAX_MAJOR_CIVS);
; 3915 : 
; 3916 : 	// Logic for when THIS AI wants to make a RA is in the Diplo AI
; 3917 : 
; 3918 : 	// Can we actually complete this deal?
; 3919 : 	if(!pDeal->IsPossibleToTradeItem(eOtherPlayer, GetPlayer()->GetID(), TRADE_ITEM_RESEARCH_AGREEMENT))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227651[ebp], eax
	mov	eax, DWORD PTR $T227651[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227652[ebp], ecx
	push	0
	push	1
	push	0
	push	-1
	push	-1
	push	-1
	push	8
	mov	edx, DWORD PTR $T227652[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?IsPossibleToTradeItem@CvDeal@@QAE_NW4PlayerTypes@@0W4TradeableItems@@HHH_N22@Z ; CvDeal::IsPossibleToTradeItem
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@IsMakeOffe@3

; 3920 : 	{
; 3921 : 		return false;

	xor	al, al
	jmp	$LN4@IsMakeOffe@3
$LN3@IsMakeOffe@3:

; 3922 : 	}
; 3923 : 
; 3924 : 	// Seed the deal with the item we want
; 3925 : 	pDeal->AddResearchAgreement(GetPlayer()->GetID(), GC.getGame().GetDealDuration());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227656[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227665[ebp], eax
	mov	eax, DWORD PTR $T227665[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T227666[ebp], ecx
	mov	ecx, DWORD PTR $T227656[ebp]
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	mov	edx, DWORD PTR $T227666[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddResearchAgreement

; 3926 : 	pDeal->AddResearchAgreement(eOtherPlayer, GC.getGame().GetDealDuration());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227670[ebp], eax
	mov	ecx, DWORD PTR $T227670[ebp]
	call	?GetDealDuration@CvGame@@QAEHXZ		; CvGame::GetDealDuration
	push	eax
	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$[ebp]
	call	?AddResearchAgreement@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddResearchAgreement

; 3927 : 
; 3928 : 	bool bDealAcceptable = false;

	mov	BYTE PTR _bDealAcceptable$[ebp], 0

; 3929 : 
; 3930 : 	// AI evaluation
; 3931 : 	if(!GET_PLAYER(eOtherPlayer).isHuman())

	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227674[ebp], edx
	mov	ecx, DWORD PTR $T227674[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsMakeOffe@3

; 3932 : 	{
; 3933 : 		bDealAcceptable = DoEqualizeDealWithAI(pDeal, eOtherPlayer);	// Change the deal as necessary to make it work

	mov	ecx, DWORD PTR _eOtherPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDeal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithAI@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@@Z ; CvDealAI::DoEqualizeDealWithAI
	mov	BYTE PTR _bDealAcceptable$[ebp], al

; 3934 : 	}
; 3935 : 	else

	jmp	SHORT $LN1@IsMakeOffe@3
$LN2@IsMakeOffe@3:

; 3936 : 	{
; 3937 : 		bool bUselessReferenceVariable;
; 3938 : 		bool bCantMatchOffer;
; 3939 : 		bDealAcceptable = DoEqualizeDealWithHuman(pDeal, eOtherPlayer, true, false, bUselessReferenceVariable, bCantMatchOffer);	// Change the deal as necessary to make it work

	lea	eax, DWORD PTR _bCantMatchOffer$223267[ebp]
	push	eax
	lea	ecx, DWORD PTR _bUselessReferenceVariable$223266[ebp]
	push	ecx
	push	0
	push	1
	mov	edx, DWORD PTR _eOtherPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoEqualizeDealWithHuman@CvDealAI@@QAE_NPAVCvDeal@@W4PlayerTypes@@_N2AA_N3@Z ; CvDealAI::DoEqualizeDealWithHuman
	mov	BYTE PTR _bDealAcceptable$[ebp], al
$LN1@IsMakeOffe@3:

; 3940 : 	}
; 3941 : 
; 3942 : 	return bDealAcceptable;

	mov	al, BYTE PTR _bDealAcceptable$[ebp]
$LN4@IsMakeOffe@3:

; 3943 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsMakeOfferForResearchAgreement@CvDealAI@@QAE_NW4PlayerTypes@@PAVCvDeal@@@Z ENDP ; CvDealAI::IsMakeOfferForResearchAgreement
_TEXT	ENDS
PUBLIC	?DoTradeScreenOpened@CvDealAI@@QAEXXZ		; CvDealAI::DoTradeScreenOpened
EXTRN	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC	; CvDeal::SetToPlayer
EXTRN	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z:PROC ; CvDeal::SetFromPlayer
EXTRN	?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z:PROC ; CvGlobals::UnwrapDealPointer
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?DoTradeScreenOpened@CvDealAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTradeScreenOpened@CvDealAI@@QAEXXZ$0
__ehfuncinfo$?DoTradeScreenOpened@CvDealAI@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoTradeScreenOpened@CvDealAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdealai.cpp
xdata$x	ENDS
;	COMDAT ?DoTradeScreenOpened@CvDealAI@@QAEXXZ
_TEXT	SEGMENT
tv142 = -128						; size = 4
_this$ = -124						; size = 4
_inst$227741 = -120					; size = 4
$T227737 = -116						; size = 4
$T227727 = -112						; size = 4
$T227723 = -108						; size = 4
$T227719 = -104						; size = 4
$T227715 = -100						; size = 4
$T227711 = -96						; size = 4
$T227707 = -92						; size = 4
$T227703 = -88						; size = 4
$T227699 = -84						; size = 4
$T227690 = -80						; size = 4
$T227689 = -76						; size = 4
$T227685 = -72						; size = 4
$T227681 = -68						; size = 4
_iValueImOffering$223287 = -64				; size = 4
_iValueTheyreOffering$223288 = -60			; size = 4
_iValueImOffering$223283 = -56				; size = 4
_iValueTheyreOffering$223284 = -52			; size = 4
_pUIDeal$223279 = -48					; size = 4
_pDeal$223281 = -44					; size = 4
_iPeaceTreatyLength$223289 = -40			; size = 4
_pkUIDeal$223280 = -36					; size = 4
_eMyPlayer$223274 = -32					; size = 4
_ePeaceTreatyImWillingToOffer$223275 = -28		; size = 4
_ePeaceTreatyImWillingToAccept$223276 = -24		; size = 4
_eActiveTeam$ = -20					; size = 4
_eActivePlayer$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?DoTradeScreenOpened@CvDealAI@@QAEXXZ PROC		; CvDealAI::DoTradeScreenOpened, COMDAT
; _this$ = ecx

; 3947 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoTradeScreenOpened@CvDealAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3948 : 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227681[ebp], eax
	mov	ecx, DWORD PTR $T227681[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eActiveTeam$[ebp], eax

; 3949 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227685[ebp], ecx
	mov	ecx, DWORD PTR $T227685[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$[ebp], eax

; 3950 : 
; 3951 : 	if(GET_TEAM(GetTeam()).isAtWar(eActiveTeam))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTeam@CvDealAI@@QAE?AW4TeamTypes@@XZ	; CvDealAI::GetTeam
	mov	DWORD PTR $T227689[ebp], eax
	mov	edx, DWORD PTR $T227689[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T227690[ebp], edx
	mov	eax, DWORD PTR _eActiveTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227690[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@DoTradeScr

; 3952 : 	{
; 3953 : 		PlayerTypes eMyPlayer = GetPlayer()->GetID();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	DWORD PTR $T227699[ebp], eax
	mov	edx, DWORD PTR $T227699[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _eMyPlayer$223274[ebp], eax

; 3954 : 
; 3955 : 		PeaceTreatyTypes ePeaceTreatyImWillingToOffer = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToOffer(eActivePlayer);

	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToOffer@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToOffer
	mov	DWORD PTR _ePeaceTreatyImWillingToOffer$223275[ebp], eax

; 3956 : 		PeaceTreatyTypes ePeaceTreatyImWillingToAccept = GetPlayer()->GetDiplomacyAI()->GetTreatyWillingToAccept(eActivePlayer);

	mov	edx, DWORD PTR _eActivePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetTreatyWillingToAccept@CvDiplomacyAI@@QBE?AW4PeaceTreatyTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetTreatyWillingToAccept
	mov	DWORD PTR _ePeaceTreatyImWillingToAccept$223276[ebp], eax

; 3957 : 
; 3958 : 		// Does the AI actually want peace?
; 3959 : 		if(ePeaceTreatyImWillingToOffer >= PEACE_TREATY_WHITE_PEACE && ePeaceTreatyImWillingToAccept >= PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToOffer$223275[ebp], 0
	jl	$LN8@DoTradeScr
	cmp	DWORD PTR _ePeaceTreatyImWillingToAccept$223276[ebp], 0
	jl	$LN8@DoTradeScr

; 3960 : 		{
; 3961 : 			// Clear out UI deal first, we're going to add a couple things to it
; 3962 : 			auto_ptr<ICvDeal1> pUIDeal(GC.GetEngineUserInterface()->GetScratchDeal());

	mov	eax, DWORD PTR $T227703[ebp]
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv142[ebp], ecx
	mov	edx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
	mov	DWORD PTR $T227707[ebp], eax
	mov	eax, DWORD PTR $T227707[ebp]
	mov	DWORD PTR _pUIDeal$223279[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3963 : 			CvDeal* pkUIDeal = GC.UnwrapDealPointer(pUIDeal.get());

	mov	ecx, DWORD PTR _pUIDeal$223279[ebp]
	mov	DWORD PTR $T227711[ebp], ecx
	mov	edx, DWORD PTR $T227711[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?UnwrapDealPointer@CvGlobals@@QAEPAVCvDeal@@PAVICvDeal1@@@Z ; CvGlobals::UnwrapDealPointer
	mov	DWORD PTR _pkUIDeal$223280[ebp], eax

; 3964 : 			pkUIDeal->ClearItems();

	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 3965 : 
; 3966 : 			CvDeal* pDeal = GC.getGame().GetGameDeals()->GetTempDeal();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227715[ebp], eax
	mov	ecx, DWORD PTR $T227715[ebp]
	call	?GetGameDeals@CvGame@@QAEPAVCvGameDeals@@XZ ; CvGame::GetGameDeals
	mov	ecx, eax
	call	?GetTempDeal@CvGameDeals@@QAEPAVCvDeal@@XZ ; CvGameDeals::GetTempDeal
	mov	DWORD PTR _pDeal$223281[ebp], eax

; 3967 : 			pDeal->ClearItems();

	mov	ecx, DWORD PTR _pDeal$223281[ebp]
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 3968 : 			pDeal->SetFromPlayer(eActivePlayer);	// The order of these is very important!

	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pDeal$223281[ebp]
	call	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetFromPlayer

; 3969 : 			pDeal->SetToPlayer(eMyPlayer);	// The order of these is very important!

	mov	edx, DWORD PTR _eMyPlayer$223274[ebp]
	push	edx
	mov	ecx, DWORD PTR _pDeal$223281[ebp]
	call	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetToPlayer

; 3970 : 
; 3971 : 			// AI is surrendering
; 3972 : 			if(ePeaceTreatyImWillingToOffer > PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToOffer$223275[ebp], 0
	jle	SHORT $LN5@DoTradeScr

; 3973 : 			{
; 3974 : 				pkUIDeal->SetSurrenderingPlayer(eMyPlayer);

	mov	eax, DWORD PTR _eMyPlayer$223274[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3975 : 				pkUIDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToOffer);

	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToOffer$223275[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3976 : 
; 3977 : 				DoAddItemsToDealForPeaceTreaty(eActivePlayer, pDeal, ePeaceTreatyImWillingToOffer, /*bMeSurrendering*/ true);

	push	1
	mov	edx, DWORD PTR _ePeaceTreatyImWillingToOffer$223275[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$223281[ebp]
	push	eax
	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3978 : 
; 3979 : 				// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3980 : 				int iValueImOffering, iValueTheyreOffering;
; 3981 : 				GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$223284[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$223283[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$223281[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3982 : 				SetCachedValueOfPeaceWithHuman(-iValueImOffering);

	mov	edx, DWORD PTR _iValueImOffering$223283[ebp]
	neg	edx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman
	jmp	SHORT $LN4@DoTradeScr
$LN5@DoTradeScr:

; 3983 : 			}
; 3984 : 			// AI is asking human to surrender
; 3985 : 			else if(ePeaceTreatyImWillingToAccept > PEACE_TREATY_WHITE_PEACE)

	cmp	DWORD PTR _ePeaceTreatyImWillingToAccept$223276[ebp], 0
	jle	SHORT $LN4@DoTradeScr

; 3986 : 			{
; 3987 : 				pkUIDeal->SetSurrenderingPlayer(eActivePlayer);

	mov	eax, DWORD PTR _eActivePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?SetSurrenderingPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetSurrenderingPlayer

; 3988 : 				pkUIDeal->SetPeaceTreatyType(ePeaceTreatyImWillingToAccept);

	mov	ecx, DWORD PTR _ePeaceTreatyImWillingToAccept$223276[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 3989 : 
; 3990 : 				DoAddItemsToDealForPeaceTreaty(eActivePlayer, pDeal, ePeaceTreatyImWillingToAccept, /*bMeSurrendering*/ false);

	push	0
	mov	edx, DWORD PTR _ePeaceTreatyImWillingToAccept$223276[ebp]
	push	edx
	mov	eax, DWORD PTR _pDeal$223281[ebp]
	push	eax
	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddItemsToDealForPeaceTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@W4PeaceTreatyTypes@@_N@Z ; CvDealAI::DoAddItemsToDealForPeaceTreaty

; 3991 : 
; 3992 : 				// Store the value of the deal with the human so that we have a number to use for renegotiation (if necessary)
; 3993 : 				int iValueImOffering, iValueTheyreOffering;
; 3994 : 				GetDealValue(pDeal, iValueImOffering, iValueTheyreOffering, /*bUseEvenValue*/ false);

	push	0
	lea	edx, DWORD PTR _iValueTheyreOffering$223288[ebp]
	push	edx
	lea	eax, DWORD PTR _iValueImOffering$223287[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDeal$223281[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDealValue@CvDealAI@@QAEHPAVCvDeal@@AAH1_N@Z ; CvDealAI::GetDealValue

; 3995 : 				SetCachedValueOfPeaceWithHuman(iValueTheyreOffering);

	mov	edx, DWORD PTR _iValueTheyreOffering$223288[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman
$LN4@DoTradeScr:

; 3996 : 			}
; 3997 : 
; 3998 : 			pDeal->ClearItems();

	mov	ecx, DWORD PTR _pDeal$223281[ebp]
	call	?ClearItems@CvDeal@@QAEXXZ		; CvDeal::ClearItems

; 3999 : 
; 4000 : 			// Now add peace items to the UI deal so that it's ready for us to make an offer
; 4001 : 			pkUIDeal->SetFromPlayer(eActivePlayer);	// The order of these is very important!

	mov	eax, DWORD PTR _eActivePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?SetFromPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetFromPlayer

; 4002 : 			pkUIDeal->SetToPlayer(eMyPlayer);	// The order of these is very important!

	mov	ecx, DWORD PTR _eMyPlayer$223274[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?SetToPlayer@CvDeal@@QAEXW4PlayerTypes@@@Z ; CvDeal::SetToPlayer

; 4003 : #ifdef AI_PEACE_TURNS
; 4004 : 			int iPeaceTreatyLength;
; 4005 : 			if (GET_PLAYER(eMyPlayer).isHuman() && GET_PLAYER(eActivePlayer).isHuman())

	mov	edx, DWORD PTR _eMyPlayer$223274[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227719[ebp], edx
	mov	ecx, DWORD PTR $T227719[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@DoTradeScr
	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227723[ebp], ecx
	mov	ecx, DWORD PTR $T227723[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@DoTradeScr

; 4006 : 			{
; 4007 : 				iPeaceTreatyLength = GC.getGame().getGameSpeedInfo().getPeaceDealDuration();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227727[ebp], eax
	mov	ecx, DWORD PTR $T227727[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getPeaceDealDuration@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getPeaceDealDuration
	mov	DWORD PTR _iPeaceTreatyLength$223289[ebp], eax

; 4008 : 			}
; 4009 : 			else

	jmp	SHORT $LN1@DoTradeScr
$LN2@DoTradeScr:

; 4010 : 			{
; 4011 : 				iPeaceTreatyLength = 5 /*GC.getGame().getGameSpeedInfo().getPeaceDealDuration()*/;

	mov	DWORD PTR _iPeaceTreatyLength$223289[ebp], 5
$LN1@DoTradeScr:

; 4012 : 			}
; 4013 : 			pkUIDeal->AddPeaceTreaty(eMyPlayer, iPeaceTreatyLength);

	mov	ecx, DWORD PTR _iPeaceTreatyLength$223289[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyPlayer$223274[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 4014 : 			pkUIDeal->AddPeaceTreaty(eActivePlayer, iPeaceTreatyLength);

	mov	eax, DWORD PTR _iPeaceTreatyLength$223289[ebp]
	push	eax
	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?AddPeaceTreaty@CvDeal@@QAEXW4PlayerTypes@@H@Z ; CvDeal::AddPeaceTreaty

; 4015 : #else
; 4016 : 			pkUIDeal->AddPeaceTreaty(eMyPlayer, GC.getGame().getGameSpeedInfo().getPeaceDealDuration());
; 4017 : 			pkUIDeal->AddPeaceTreaty(eActivePlayer, GC.getGame().getGameSpeedInfo().getPeaceDealDuration());
; 4018 : #endif
; 4019 : 			
; 4020 : 			// slewis - adding third party city-states into the deal automatically
; 4021 : 			DoAddPlayersAlliesToTreaty(eActivePlayer, pkUIDeal);

	mov	edx, DWORD PTR _pkUIDeal$223280[ebp]
	push	edx
	mov	eax, DWORD PTR _eActivePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAddPlayersAlliesToTreaty@CvDealAI@@QAEXW4PlayerTypes@@PAVCvDeal@@@Z ; CvDealAI::DoAddPlayersAlliesToTreaty

; 4022 : 
; 4023 : 			// Start off as a white peace
; 4024 : 			pkUIDeal->SetPeaceTreatyType(PEACE_TREATY_WHITE_PEACE);

	push	0
	mov	ecx, DWORD PTR _pkUIDeal$223280[ebp]
	call	?SetPeaceTreatyType@CvDeal@@QAEXW4PeaceTreatyTypes@@@Z ; CvDeal::SetPeaceTreatyType

; 4025 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pUIDeal$223279[ebp]
	mov	DWORD PTR $T227737[ebp], ecx
	cmp	DWORD PTR $T227737[ebp], 0
	je	SHORT $LN8@DoTradeScr
	mov	edx, DWORD PTR $T227737[ebp]
	mov	DWORD PTR _inst$227741[ebp], edx
	mov	eax, DWORD PTR _inst$227741[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$227741[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN8@DoTradeScr:

; 4026 : 	}
; 4027 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTradeScreenOpened@CvDealAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _pUIDeal$223279[ebp]
	jmp	??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ	; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
__ehhandler$?DoTradeScreenOpened@CvDealAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoTradeScreenOpened@CvDealAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTradeScreenOpened@CvDealAI@@QAEXXZ ENDP		; CvDealAI::DoTradeScreenOpened
PUBLIC	?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z		; CvDealAI::DoTradeScreenClosed
EXTRN	?DoCancelWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::DoCancelWantsResearchAgreementWithPlayer
EXTRN	?IsCanMakeResearchAgreementRightNow@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsCanMakeResearchAgreementRightNow
EXTRN	?IsWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::IsWantsResearchAgreementWithPlayer
; Function compile flags: /Odtp
;	COMDAT ?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z
_TEXT	SEGMENT
tv88 = -28						; size = 4
tv77 = -24						; size = 4
_this$ = -20						; size = 4
$T227761 = -16						; size = 4
$T227757 = -12						; size = 4
$T227753 = -8						; size = 4
_eActivePlayer$ = -4					; size = 4
_bAIWasMakingOffer$ = 8					; size = 1
?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z PROC		; CvDealAI::DoTradeScreenClosed, COMDAT
; _this$ = ecx

; 4031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4032 : 	PlayerTypes eActivePlayer = GC.getGame().getActivePlayer();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227753[ebp], eax
	mov	ecx, DWORD PTR $T227753[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _eActivePlayer$[ebp], eax

; 4033 : 
; 4034 : 	// Reset cached values each time screen closed
; 4035 : 	SetCachedValueOfPeaceWithHuman(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCachedValueOfPeaceWithHuman@CvDealAI@@QAEXH@Z ; CvDealAI::SetCachedValueOfPeaceWithHuman

; 4036 : 
; 4037 : 	GC.GetEngineUserInterface()->SetAIRequestingConcessions(false);

	mov	ecx, DWORD PTR $T227757[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv77[ebp], edx
	push	0
	mov	eax, DWORD PTR tv77[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv77[ebp]
	mov	eax, DWORD PTR [edx+464]
	call	eax

; 4038 : 	GC.GetEngineUserInterface()->SetHumanMakingDemand(false);

	mov	ecx, DWORD PTR $T227761[ebp]
	mov	DWORD PTR tv88[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv88[ebp], edx
	push	0
	mov	eax, DWORD PTR tv88[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv88[ebp]
	mov	eax, DWORD PTR [edx+472]
	call	eax

; 4039 : 
; 4040 : #ifdef AUI_WARNING_FIXES
; 4041 : 	CvDiplomacyAI* pDiplomacyAI = GetPlayer()->GetDiplomacyAI();
; 4042 : 	pDiplomacyAI->ClearDealToRenew();
; 4043 : 
; 4044 : 	if (bAIWasMakingOffer)
; 4045 : 	{
; 4046 : 		// If AI was planning on a mutual Research Agreement, cancel it because the human left :(
; 4047 : 		// May want to do this slightly differently, as we can't be 100% sure this is what the AI was asking about (although if we make it through both of the following if statements there's an awful lot of circumstantial evidence)
; 4048 : 		if (pDiplomacyAI->IsWantsResearchAgreementWithPlayer(eActivePlayer))
; 4049 : 		{
; 4050 : 			if (pDiplomacyAI->IsCanMakeResearchAgreementRightNow(eActivePlayer))
; 4051 : 			{
; 4052 : 				pDiplomacyAI->DoCancelWantsResearchAgreementWithPlayer(eActivePlayer);
; 4053 : #else
; 4054 : 	GetPlayer()->GetDiplomacyAI()->ClearDealToRenew();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?ClearDealToRenew@CvDiplomacyAI@@QAEXXZ	; CvDiplomacyAI::ClearDealToRenew

; 4055 : 
; 4056 : 	if(bAIWasMakingOffer)

	movzx	ecx, BYTE PTR _bAIWasMakingOffer$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@DoTradeScr@2

; 4057 : 	{
; 4058 : 		// If AI was planning on a mutual Research Agreement, cancel it because the human left :(
; 4059 : 		// May want to do this slightly differently, as we can't be 100% sure this is what the AI was asking about (although if we make it through both of the following if statements there's an awful lot of circumstantial evidence)
; 4060 : 		if(GetPlayer()->GetDiplomacyAI()->IsWantsResearchAgreementWithPlayer(eActivePlayer))

	mov	edx, DWORD PTR _eActivePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QBE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsWantsResearchAgreementWithPlayer
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@DoTradeScr@2

; 4061 : 		{
; 4062 : 			if(GetPlayer()->GetDiplomacyAI()->IsCanMakeResearchAgreementRightNow(eActivePlayer))

	mov	ecx, DWORD PTR _eActivePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsCanMakeResearchAgreementRightNow@CvDiplomacyAI@@QAE_NW4PlayerTypes@@@Z ; CvDiplomacyAI::IsCanMakeResearchAgreementRightNow
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@DoTradeScr@2

; 4063 : 			{
; 4064 : 				GetPlayer()->GetDiplomacyAI()->DoCancelWantsResearchAgreementWithPlayer(eActivePlayer);

	mov	eax, DWORD PTR _eActivePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvDealAI@@QAEPAVCvPlayer@@XZ	; CvDealAI::GetPlayer
	mov	ecx, eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?DoCancelWantsResearchAgreementWithPlayer@CvDiplomacyAI@@QAEXW4PlayerTypes@@@Z ; CvDiplomacyAI::DoCancelWantsResearchAgreementWithPlayer
$LN4@DoTradeScr@2:

; 4065 : #endif
; 4066 : 			}
; 4067 : 		}
; 4068 : 	}
; 4069 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoTradeScreenClosed@CvDealAI@@QAEX_N@Z ENDP		; CvDealAI::DoTradeScreenClosed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
_TEXT	ENDS
;	COMDAT ?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T227793 = -8						; size = 4
$T227765 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::begin, COMDAT
; _this$ = ecx

; 199  : 	iterator begin(){ return iterator( m_uiFirst, this ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T227765[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T227793[ebp], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T227793[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR $T227765[ebp]
	or	eax, 1
	mov	DWORD PTR $T227765[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227797 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ PROC ; FFastList<CvTradedItem,21,0>::end, COMDAT
; _this$ = ecx

; 200  : 	iterator end(){ return iterator( ANCHOR_NODE_INDEX, this ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T227797[ebp], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 268435455		; 0fffffffH
	mov	eax, DWORD PTR $T227797[ebp]
	or	eax, 1
	mov	DWORD PTR $T227797[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE?AViterator@1@XZ ENDP ; FFastList<CvTradedItem,21,0>::end
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>
__ehhandler$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::~FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$227861 = -8					; size = 4
$T227856 = -4						; size = 4
??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T227856[ebp], ecx
	cmp	DWORD PTR $T227856[ebp], 0
	je	SHORT $LN1@auto_ptr
	mov	edx, DWORD PTR $T227856[ebp]
	mov	DWORD PTR _inst$227861[ebp], edx
	mov	eax, DWORD PTR _inst$227861[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$227861[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvDeal1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvDeal1>::~auto_ptr<ICvDeal1>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastlist.h
_TEXT	ENDS
;	COMDAT ??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ PROC ; FFastList<CvTradedItem,21,0>::iterator::~iterator, COMDAT
; _this$ = ecx

; 136  : 		~iterator(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1iterator@?$FFastList@UCvTradedItem@@$0BF@$0A@@@QAE@XZ ENDP ; FFastList<CvTradedItem,21,0>::iterator::~iterator
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@H$00$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@H$00$0A@@@QAE@XZ PROC		; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@H$00$0A@@@QAE@XZ ENDP		; CvWeightedVector<int,1,0>::~CvWeightedVector<int,1,0>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
; Function compile flags: /Odtp
;	COMDAT ?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T227913 = -8						; size = 4
$T227909 = -4						; size = 4
?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ PROC	; CvWeightedVector<int,1,0>::SortItems, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T227909[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227913[ebp], eax
	mov	ecx, DWORD PTR $T227909[ebp]
	sub	ecx, DWORD PTR $T227913[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T227909[ebp]
	push	edx
	mov	eax, DWORD PTR $T227913[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SortItems@?$CvWeightedVector@H$00$0A@@@QAEXXZ ENDP	; CvWeightedVector<int,1,0>::SortItems
_TEXT	ENDS
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??1VoteCommitment@CvLeagueAI@@QAE@XZ:PROC	; CvLeagueAI::VoteCommitment::~VoteCommitment
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T228099 = -8						; size = 4
_i$228102 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z PROC ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free, COMDAT
; _this$ = ecx

; 809  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@Free
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@Free
	mov	DWORD PTR _i$228102[ebp], 0
	jmp	SHORT $LN7@Free
$LN6@Free:
	mov	edx, DWORD PTR _i$228102[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228102[ebp], edx
$LN7@Free:
	mov	eax, DWORD PTR _i$228102[ebp]
	cmp	eax, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN2@Free
	mov	ecx, DWORD PTR _i$228102[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR $T228099[ebp], ecx
	mov	ecx, DWORD PTR $T228099[ebp]
	call	??1VoteCommitment@CvLeagueAI@@QAE@XZ	; CvLeagueAI::VoteCommitment::~VoteCommitment
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN12@Free
	mov	eax, DWORD PTR $T228099[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Free:
	jmp	SHORT $LN6@Free
$LN2@Free:

; 811  : 		if( pVal != (T*)m_aData )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR _pVal$[ebp], ecx
	je	SHORT $LN3@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	mov	edx, DWORD PTR _pVal$[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN3@Free:

; 813  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Free@?$FStaticVector@UVoteCommitment@CvLeagueAI@@$03$0A@$0BCJ@$0A@@@IAEXPAUVoteCommitment@CvLeagueAI@@I@Z ENDP ; FStaticVector<CvLeagueAI::VoteCommitment,4,0,297,0>::Free
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ PROC ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UVoteCommitment@CvLeagueAI@@$0A@@@QAE@XZ ENDP ; BaseVector<CvLeagueAI::VoteCommitment,0>::~BaseVector<CvLeagueAI::VoteCommitment,0>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T228124 = -20						; size = 4
_pRet$228120 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228124[ebp], edx
	cmp	DWORD PTR $T228124[ebp], 1
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T228124[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$228120[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T228124[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$228120[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$228120[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T228155 = -24						; size = 4
$T228154 = -20						; size = 4
_i$228149 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228155[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T228154[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$228149[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$228149[ebp]
	add	eax, 1
	mov	DWORD PTR _i$228149[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$228149[ebp]
	cmp	ecx, DWORD PTR $T228155[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T228154[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T228154[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::~FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T228168 = -8						; size = 4
$T228167 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+20], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T228168[ebp], ecx
	cmp	DWORD PTR $T228168[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T228168[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T228168[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T228168[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T228167[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$00$0A@@@@Z ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::push_back
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T228262 = -44						; size = 4
$T228261 = -40						; size = 4
_i$228256 = -36						; size = 4
$T228240 = -32						; size = 4
$T228233 = -28						; size = 4
_pRet$228229 = -24					; size = 4
$T228223 = -20						; size = 4
$T228222 = -16						; size = 4
_i$223442 = -12						; size = 4
_uiNewSize$223434 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$223434[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$223434[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$223434[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T228233[ebp], ecx
	cmp	DWORD PTR $T228233[ebp], 1
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T228233[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$228229[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T228233[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$228229[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$228229[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	xor	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$223442[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$223442[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223442[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223442[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$223442[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T228223[ebp], ecx
	cmp	DWORD PTR $T228223[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$223442[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T228240[ebp], edx
	mov	eax, DWORD PTR $T228223[ebp]
	mov	ecx, DWORD PTR $T228240[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T228223[ebp]
	mov	ecx, DWORD PTR $T228240[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T228223[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T228222[ebp], ecx
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T228262[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T228261[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN24@GrowSize
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN24@GrowSize
	mov	DWORD PTR _i$228256[ebp], 0
	jmp	SHORT $LN29@GrowSize
$LN28@GrowSize:
	mov	edx, DWORD PTR _i$228256[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228256[ebp], edx
$LN29@GrowSize:
	mov	eax, DWORD PTR _i$228256[ebp]
	cmp	eax, DWORD PTR $T228262[ebp]
	jae	SHORT $LN24@GrowSize
	jmp	SHORT $LN28@GrowSize
$LN24@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T228261[ebp], ecx
	je	SHORT $LN25@GrowSize
	mov	edx, DWORD PTR $T228261[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+20], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$00$0A@$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,1,0>::WeightedElement,1,0,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$00$0A@@@$0A@@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>::~BaseVector<CvWeightedVector<int,1,0>::WeightedElement,0>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z
_TEXT	SEGMENT
$T228392 = -128						; size = 4
__Mid$223547 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$223547[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$223547[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$223547[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$223547[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$223547[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$223547[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$223547[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T228392[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T228392[ebp]
	sub	eax, 8
	mov	DWORD PTR $T228392[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T228392[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T228392[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T228392[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,1,0>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z
_TEXT	SEGMENT
$T228635 = -124						; size = 4
__Tmp$228633 = -120					; size = 8
$T228615 = -112						; size = 4
$T228614 = -108						; size = 4
__Tmp$228612 = -104					; size = 8
$T228594 = -96						; size = 4
__Tmp$228592 = -92					; size = 8
$T228574 = -84						; size = 4
$T228573 = -80						; size = 4
__Tmp$228571 = -76					; size = 8
$T228553 = -68						; size = 4
$T228552 = -64						; size = 4
__Tmp$228550 = -60					; size = 8
$T228529 = -52						; size = 4
$T228528 = -48						; size = 4
__Tmp$228526 = -44					; size = 8
$T228502 = -36						; size = 4
__Tmp$228500 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T228502[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T228502[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T228502[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$228500[ebp], edx
	mov	eax, DWORD PTR $T228502[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$228500[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T228502[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$228500[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$228500[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T228529[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T228528[ebp], edx
	mov	eax, DWORD PTR $T228528[ebp]
	cmp	eax, DWORD PTR $T228529[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T228528[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$228526[ebp], edx
	mov	eax, DWORD PTR $T228528[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$228526[ebp+4], ecx
	mov	edx, DWORD PTR $T228529[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T228528[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T228529[ebp]
	mov	ecx, DWORD PTR __Tmp$228526[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$228526[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T228553[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T228552[ebp], eax
	mov	ecx, DWORD PTR $T228552[ebp]
	cmp	ecx, DWORD PTR $T228553[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T228552[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$228550[ebp], eax
	mov	ecx, DWORD PTR $T228552[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$228550[ebp+4], edx
	mov	eax, DWORD PTR $T228553[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T228552[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T228553[ebp]
	mov	edx, DWORD PTR __Tmp$228550[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$228550[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T228574[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T228573[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T228573[ebp]
	cmp	eax, DWORD PTR $T228574[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T228573[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$228571[ebp], edx
	mov	eax, DWORD PTR $T228573[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$228571[ebp+4], ecx
	mov	edx, DWORD PTR $T228574[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T228573[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T228574[ebp]
	mov	ecx, DWORD PTR __Tmp$228571[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$228571[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T228594[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T228594[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$228592[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$228592[ebp+4], eax
	mov	ecx, DWORD PTR $T228594[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T228594[ebp]
	mov	eax, DWORD PTR __Tmp$228592[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$228592[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T228615[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T228614[ebp], ecx
	mov	edx, DWORD PTR $T228614[ebp]
	cmp	edx, DWORD PTR $T228615[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T228614[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$228612[ebp], ecx
	mov	edx, DWORD PTR $T228614[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$228612[ebp+4], eax
	mov	ecx, DWORD PTR $T228615[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T228614[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T228615[ebp]
	mov	eax, DWORD PTR __Tmp$228612[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$228612[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T228635[ebp], eax
	mov	ecx, DWORD PTR $T228635[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T228635[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$228633[ebp], eax
	mov	ecx, DWORD PTR $T228635[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$228633[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T228635[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$228633[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$228633[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
__Step$223691 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$223691[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$223691[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$223691[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$223691[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$223691[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$223691[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$223691[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$223691[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$223691[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Median<CvWeightedVector<int,1,0>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z
_TEXT	SEGMENT
$T228948 = -20						; size = 4
$T228947 = -16						; size = 4
__Hole$223709 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$223709[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$223709[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$223709[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$223709[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$223709[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T228948[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T228947[ebp], esp
	mov	edx, DWORD PTR $T228947[ebp]
	mov	eax, DWORD PTR $T228948[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T228947[ebp]
	mov	eax, DWORD PTR $T228948[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$223709[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
$T229018 = -52						; size = 4
$T229017 = -48						; size = 4
$T229001 = -42						; size = 1
$T229000 = -41						; size = 1
$T228999 = -40						; size = 4
$T228998 = -36						; size = 4
$T228997 = -32						; size = 4
__Cat$229009 = -24					; size = 1
$T229006 = -23						; size = 1
$T229005 = -22						; size = 1
$T229004 = -21						; size = 1
__First1$223750 = -20					; size = 4
__Val$223740 = -16					; size = 8
__Next1$223739 = -8					; size = 4
__Next$223735 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$223735[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$223735[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$223735[ebp], edx
	mov	eax, DWORD PTR __Next$223735[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$223735[ebp]
	mov	DWORD PTR __Next1$223739[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$223735[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$223740[ebp], eax
	mov	ecx, DWORD PTR __Next$223735[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$223740[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$223740[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$223739[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$223739[ebp], ecx
	mov	edx, DWORD PTR __Next1$223739[ebp]
	mov	DWORD PTR $T229018[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229017[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229004[ebp], cl
	mov	dl, BYTE PTR __Cat$229009[ebp]
	mov	BYTE PTR $T229005[ebp], dl
	mov	al, BYTE PTR $T229004[ebp]
	mov	BYTE PTR $T229001[ebp], al
	mov	cl, BYTE PTR $T229006[ebp]
	mov	BYTE PTR $T229000[ebp], cl
	mov	edx, DWORD PTR $T229018[ebp]
	mov	DWORD PTR $T228999[ebp], edx
	mov	eax, DWORD PTR __Next$223735[ebp]
	mov	DWORD PTR $T228998[ebp], eax
	mov	ecx, DWORD PTR $T229017[ebp]
	mov	DWORD PTR $T228997[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T228997[ebp]
	cmp	edx, DWORD PTR $T228998[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T228998[ebp]
	sub	eax, 8
	mov	DWORD PTR $T228998[ebp], eax
	mov	ecx, DWORD PTR $T228999[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T228999[ebp], ecx
	mov	edx, DWORD PTR $T228998[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T228999[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$223740[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$223740[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$223739[ebp]
	mov	DWORD PTR __First1$223750[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$223750[ebp]
	mov	DWORD PTR __Next1$223739[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$223750[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$223750[ebp], edx
	mov	eax, DWORD PTR __First1$223750[ebp]
	mov	ecx, DWORD PTR __Val$223740[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$223750[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$223739[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$223739[ebp]
	mov	eax, DWORD PTR __Val$223740[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$223740[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
__Tmp$229086 = -24					; size = 8
__Tmp$229064 = -16					; size = 8
__Tmp$229042 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$229042[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$229042[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$229042[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$229042[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$229064[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$229064[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$229064[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$229064[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$229086[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$229086[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$229086[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$229086[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,1,0>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z
_TEXT	SEGMENT
$T229113 = -32						; size = 4
$T229112 = -28						; size = 8
__Idx$229105 = -20					; size = 4
$T229099 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T229112[ebp]
	mov	DWORD PTR $T229099[ebp], edx
	mov	eax, DWORD PTR $T229099[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T229099[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T229113[ebp], ecx
	mov	eax, DWORD PTR $T229113[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$229105[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T229113[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$229105[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T229113[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$229105[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T229112[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$229105[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T229113[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$229105[ebp]
	mov	DWORD PTR $T229113[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T229113[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T229112[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T229112[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z
_TEXT	SEGMENT
$T229159 = -60						; size = 8
$T229130 = -20						; size = 4
$T229124 = -12						; size = 4
$T229123 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T229124[ebp], eax
	lea	ecx, DWORD PTR $T229159[ebp]
	mov	DWORD PTR $T229123[ebp], ecx
	mov	edx, DWORD PTR $T229123[ebp]
	mov	eax, DWORD PTR $T229124[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T229123[ebp]
	mov	eax, DWORD PTR $T229124[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T229130[ebp], esp
	mov	eax, DWORD PTR $T229130[ebp]
	mov	ecx, DWORD PTR $T229159[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T229130[ebp]
	mov	eax, DWORD PTR $T229159[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,1,0>::WeightedElement *,int,CvWeightedVector<int,1,0>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$00$0A@@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$00$0A@@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,1,0>::WeightedElement *,CvWeightedVector<int,1,0>::WeightedElement>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T229170 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T229170[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T229170[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T229184 = -8						; size = 4
$T229180 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T229180[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T229180[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T229184[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T229184[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
END
