; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTraitClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
_CALENDAR_START DD 0c542865br			; -3112.4
_DAYS_IN_BAKTUN DD 0480ca000r			; 144000
_DAYS_IN_KATUN DD 045e10000r			; 7200
_DAYS_IN_TUN DD	043b40000r			; 360
_DAYS_IN_WINAL DD 041a00000r			; 20
_DAYS_IN_YEAR DD 043b69f00r			; 365.242
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
PUBLIC	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
PUBLIC	??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >
PUBLIC	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	??_7CvTraitEntry@@6B@				; CvTraitEntry::`vftable'
PUBLIC	??0CvTraitEntry@@QAE@XZ				; CvTraitEntry::CvTraitEntry
PUBLIC	?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTraitEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_7CvTraitEntry@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
CONST	SEGMENT
??_7CvTraitEntry@@6B@ DD FLAT:?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTraitEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvTraitEntry@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0CvTraitEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvTraitEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$11
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$3
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvTraitEntry@@QAE@XZ$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvTraitEntry@@QAE@XZ
_TEXT	SEGMENT
tv312 = -428						; size = 4
tv388 = -424						; size = 4
_this$ = -420						; size = 4
$T227924 = -168						; size = 4
$T227874 = -74						; size = 1
$T227861 = -73						; size = 1
$T227857 = -72						; size = 4
$T227850 = -64						; size = 4
$T227843 = -56						; size = 4
$T227839 = -18						; size = 1
$T227838 = -17						; size = 1
$T227750 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTraitEntry@@QAE@XZ PROC				; CvTraitEntry::CvTraitEntry, COMDAT
; _this$ = ecx

; 173  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTraitEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 416				; 000001a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTraitEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+304], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+316], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+336], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+340], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+348], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+352], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+356], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+364], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+368], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+372], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+376], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+380], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+392], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+404], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+408], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+412], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+424], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+428], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+432], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+436], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+440], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+444], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+448], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+452], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+456], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+460], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+472], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+476], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+480], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+484], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+496], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+500], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+504], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+508], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+512], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+516], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+524], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+528], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+532], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+556], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+564], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+568], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+572], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+576], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+580], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+584], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+585], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+586], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+587], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+588], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+589], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+590], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+591], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+592], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+593], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+594], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+595], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+596], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+597], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+598], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+599], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+600], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+601], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+602], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+603], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+604], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+605], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 608				; 00000260H
	mov	DWORD PTR $T227750[ebp], edx
	mov	ecx, DWORD PTR $T227750[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+636], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+640], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+644], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+648], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+652], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+656], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+660], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+664], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+668], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+672], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+684], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+688], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+692], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	mov	DWORD PTR $T227843[ebp], ecx
	lea	edx, DWORD PTR $T227838[ebp]
	push	edx
	lea	eax, DWORD PTR $T227839[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227843[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 708				; 000002c4H
	mov	DWORD PTR $T227924[ebp], ecx
	lea	edx, DWORD PTR $T227874[ebp]
	mov	DWORD PTR $T227850[ebp], edx
	lea	eax, DWORD PTR $T227861[ebp]
	mov	DWORD PTR $T227857[ebp], eax
	mov	ecx, DWORD PTR $T227924[ebp]
	mov	DWORD PTR tv388[ebp], ecx
	mov	edx, DWORD PTR $T227924[ebp]
	mov	DWORD PTR tv312[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	0
	mov	ecx, DWORD PTR $T227924[ebp]
	call	?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	call	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	call	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >

; 174  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 608				; 00000260H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$11:
	mov	ecx, DWORD PTR $T227924[ebp]
	jmp	??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 708				; 000002c4H
	jmp	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
__unwindfunclet$??0CvTraitEntry@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$??0CvTraitEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-420]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTraitEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTraitEntry@@QAE@XZ ENDP				; CvTraitEntry::CvTraitEntry
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T228182 = -48						; size = 4
$T228177 = -44						; size = 4
$T228172 = -40						; size = 4
$T228167 = -36						; size = 4
$T228162 = -32						; size = 4
$T228157 = -28						; size = 4
$T228152 = -24						; size = 4
$T228147 = -20						; size = 4
$T228142 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T228142[ebp], eax
	mov	ecx, DWORD PTR $T228142[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T228147[ebp], ecx
	mov	ecx, DWORD PTR $T228147[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T228152[ebp], edx
	mov	ecx, DWORD PTR $T228152[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T228157[ebp], eax
	mov	ecx, DWORD PTR $T228157[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T228162[ebp], ecx
	mov	ecx, DWORD PTR $T228162[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T228167[ebp], edx
	mov	ecx, DWORD PTR $T228167[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T228172[ebp], eax
	mov	ecx, DWORD PTR $T228172[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T228177[ebp], ecx
	mov	ecx, DWORD PTR $T228177[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T228182[ebp], edx
	mov	ecx, DWORD PTR $T228182[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
PUBLIC	?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	??1CvTraitEntry@@QAE@XZ				; CvTraitEntry::~CvTraitEntry
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvTraitEntry@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??1CvTraitEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvTraitEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$8
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$10
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$12
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$14
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvTraitEntry@@QAE@XZ$17
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTraitEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -152						; size = 4
$T228786 = -112						; size = 4
$T228781 = -108						; size = 4
$T228622 = -64						; size = 4
$T228536 = -28						; size = 4
$T228522 = -24						; size = 4
$T228501 = -20						; size = 4
$T228487 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTraitEntry@@QAE@XZ PROC				; CvTraitEntry::~CvTraitEntry, COMDAT
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTraitEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvTraitEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 179  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 180  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges.first, m_ppiImprovementYieldChanges.second);
; 181  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiSpecialistYieldChanges.first, m_ppiSpecialistYieldChanges.second);
; 182  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiUnimprovedFeatureYieldChanges.first, m_ppiUnimprovedFeatureYieldChanges.second);
; 183  : #else
; 184  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 185  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiSpecialistYieldChanges);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 688				; 000002b0H
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 186  : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 187  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiAnySpecificSpecialistYieldChanges);
; 188  : #endif
; 189  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiUnimprovedFeatureYieldChanges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 692				; 000002b4H
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 190  : #endif
; 191  : #ifdef AUI_WARNING_FIXES
; 192  : 	SAFE_DELETE_ARRAY(m_paiExtraYieldThreshold);
; 193  : 	SAFE_DELETE_ARRAY(m_paiYieldChange);
; 194  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeStrategicResources);
; 195  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeLuxuryResources); // NQMP GJS - New Netherlands UA
; 196  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeNaturalWonder);
; 197  : 	SAFE_DELETE_ARRAY(m_paiYieldChangePerTradePartner);
; 198  : 	SAFE_DELETE_ARRAY(m_paiYieldChangeIncomingTradeRoute);
; 199  : 	SAFE_DELETE_ARRAY(m_paiYieldModifier);
; 200  : 	SAFE_DELETE_ARRAY(m_piStrategicResourceQuantityModifier);
; 201  : 	SAFE_DELETE_ARRAY(m_piResourceQuantityModifiers);
; 202  : 	SAFE_DELETE_ARRAY(m_piMovesChangeUnitCombats);
; 203  : 	SAFE_DELETE_ARRAY(m_piMaintenanceModifierUnitCombats);
; 204  : #endif
; 205  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	mov	DWORD PTR $T228501[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR $T228501[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T228501[ebp]
	add	eax, 4
	mov	DWORD PTR $T228487[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T228487[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	mov	DWORD PTR $T228536[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR $T228536[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T228536[ebp]
	add	eax, 4
	mov	DWORD PTR $T228522[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T228522[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 708				; 000002c4H
	mov	DWORD PTR $T228622[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T228622[ebp]
	call	?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 696				; 000002b8H
	mov	DWORD PTR $T228781[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T228781[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 608				; 00000260H
	mov	DWORD PTR $T228786[ebp], eax
	mov	ecx, DWORD PTR $T228786[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 608				; 00000260H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 708				; 000002c4H
	jmp	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$6:
	mov	ecx, DWORD PTR $T228501[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$8:
	mov	ecx, DWORD PTR $T228487[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$10:
	mov	ecx, DWORD PTR $T228536[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$12:
	mov	ecx, DWORD PTR $T228522[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$14:
	mov	ecx, DWORD PTR $T228622[ebp]
	jmp	??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvTraitEntry@@QAE@XZ$17:
	mov	ecx, DWORD PTR $T228781[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1CvTraitEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTraitEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTraitEntry@@QAE@XZ ENDP				; CvTraitEntry::~CvTraitEntry
PUBLIC	?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLevelExperienceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetLevelExperienceModifier, COMDAT
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 	return m_iLevelExperienceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+260]

; 211  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetLevelExperienceModifier
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatPeopleRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 215  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 	return m_iGreatPeopleRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+264]

; 217  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatScientistRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGreatScientistRateModifier, COMDAT
; _this$ = ecx

; 221  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 	return m_iGreatScientistRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGreatScientistRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatGeneralRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 227  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 228  : 	return m_iGreatGeneralRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 229  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetGreatGeneralExtraBonus
; Function compile flags: /Odtp
;	COMDAT ?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatGeneralExtraBonus, COMDAT
; _this$ = ecx

; 233  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 	return m_iGreatGeneralExtraBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatGeneralExtraBonus
_TEXT	ENDS
PUBLIC	?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatPersonGiftInfluence
; Function compile flags: /Odtp
;	COMDAT ?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGreatPersonGiftInfluence, COMDAT
; _this$ = ecx

; 239  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 	return m_iGreatPersonGiftInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGreatPersonGiftInfluence
_TEXT	ENDS
PUBLIC	?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxGlobalBuildingProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetMaxGlobalBuildingProductionModifier, COMDAT
; _this$ = ecx

; 245  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	return m_iMaxGlobalBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetMaxGlobalBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxTeamBuildingProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetMaxTeamBuildingProductionModifier, COMDAT
; _this$ = ecx

; 251  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 	return m_iMaxTeamBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 253  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetMaxTeamBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxPlayerBuildingProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetMaxPlayerBuildingProductionModifier, COMDAT
; _this$ = ecx

; 257  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 258  : 	return m_iMaxPlayerBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 259  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetMaxPlayerBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityUnhappinessModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCityUnhappinessModifier, COMDAT
; _this$ = ecx

; 263  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 	return m_iCityUnhappinessModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 265  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCityUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPopulationUnhappinessModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetPopulationUnhappinessModifier, COMDAT
; _this$ = ecx

; 269  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 270  : 	return m_iPopulationUnhappinessModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetPopulationUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCityStateBonusModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCityStateBonusModifier, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 	return m_iCityStateBonusModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]

; 277  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCityStateBonusModifier
_TEXT	ENDS
PUBLIC	?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityStateFriendshipModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCityStateFriendshipModifier, COMDAT
; _this$ = ecx

; 281  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 	return m_iCityStateFriendshipModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+308]

; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCityStateFriendshipModifier
_TEXT	ENDS
PUBLIC	?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityStateCombatModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCityStateCombatModifier, COMDAT
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	return m_iCityStateCombatModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+312]

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCityStateCombatModifier
_TEXT	ENDS
PUBLIC	?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandBarbarianConversionPercent
; Function compile flags: /Odtp
;	COMDAT ?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetLandBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 293  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 	return m_iLandBarbarianConversionPercent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]

; 295  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetLandBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandBarbarianConversionExtraUnits
; Function compile flags: /Odtp
;	COMDAT ?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetLandBarbarianConversionExtraUnits, COMDAT
; _this$ = ecx

; 299  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 	return m_iLandBarbarianConversionExtraUnits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+320]

; 301  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetLandBarbarianConversionExtraUnits
_TEXT	ENDS
PUBLIC	?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetSeaBarbarianConversionPercent
; Function compile flags: /Odtp
;	COMDAT ?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetSeaBarbarianConversionPercent, COMDAT
; _this$ = ecx

; 305  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 306  : 	return m_iSeaBarbarianConversionPercent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+324]

; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetSeaBarbarianConversionPercent
_TEXT	ENDS
PUBLIC	?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCapitalBuildingModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCapitalBuildingModifier, COMDAT
; _this$ = ecx

; 311  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 	return m_iCapitalBuildingModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+328]

; 313  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCapitalBuildingModifier
_TEXT	ENDS
PUBLIC	?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPlotBuyCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetPlotBuyCostModifier, COMDAT
; _this$ = ecx

; 317  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 318  : 	return m_iPlotBuyCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]

; 319  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetPlotBuyCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPlotCultureCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 323  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 	return m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+336]

; 325  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetSciencePerGreatPersonBorn
; Function compile flags: /Odtp
;	COMDAT ?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetSciencePerGreatPersonBorn, COMDAT
; _this$ = ecx

; 330  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 	return m_iSciencePerGreatPersonBorn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+340]

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetSciencePerGreatPersonBorn
_TEXT	ENDS
PUBLIC	?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNumTurnsBeforeMinorAlliesRefuseBribes
; Function compile flags: /Odtp
;	COMDAT ?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNumTurnsBeforeMinorAlliesRefuseBribes, COMDAT
; _this$ = ecx

; 338  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 	return m_iNumTurnsBeforeMinorAlliesRefuseBribes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+344]

; 340  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNumTurnsBeforeMinorAlliesRefuseBribes
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeTileBonusFaith
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeTileBonusFaith, COMDAT
; _this$ = ecx

; 346  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 	return m_iGoldenAgeTileBonusFaith;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+348]

; 348  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeTileBonusFaith
_TEXT	ENDS
PUBLIC	?GetCultureFromKills@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCultureFromKills
; Function compile flags: /Odtp
;	COMDAT ?GetCultureFromKills@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureFromKills@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetCultureFromKills, COMDAT
; _this$ = ecx

; 354  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return m_iCultureFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+352]

; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureFromKills@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetCultureFromKills
_TEXT	ENDS
PUBLIC	?GetFaithFromKills@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetFaithFromKills
; Function compile flags: /Odtp
;	COMDAT ?GetFaithFromKills@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFaithFromKills@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetFaithFromKills, COMDAT
; _this$ = ecx

; 360  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 	return m_iFaithFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+356]

; 362  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFaithFromKills@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetFaithFromKills
_TEXT	ENDS
PUBLIC	?GetCityCultureBonus@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCityCultureBonus
; Function compile flags: /Odtp
;	COMDAT ?GetCityCultureBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityCultureBonus@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetCityCultureBonus, COMDAT
; _this$ = ecx

; 366  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  : 	return m_iCityCultureBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+360]

; 368  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityCultureBonus@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetCityCultureBonus
_TEXT	ENDS
PUBLIC	?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCapitalThemingBonusModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCapitalThemingBonusModifier, COMDAT
; _this$ = ecx

; 372  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 373  : 	return m_iCapitalThemingBonusModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+364]

; 374  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCapitalThemingBonusModifier
_TEXT	ENDS
PUBLIC	?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPolicyCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetPolicyCostModifier, COMDAT
; _this$ = ecx

; 378  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 379  : 	return m_iPolicyCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+368]

; 380  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetPolicyCostModifier
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityConnectionTradeRouteChange
; Function compile flags: /Odtp
;	COMDAT ?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCityConnectionTradeRouteChange, COMDAT
; _this$ = ecx

; 384  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	return m_iCityConnectionTradeRouteChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+372]

; 386  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCityConnectionTradeRouteChange
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetWonderProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 390  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 	return m_iWonderProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+376]

; 392  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetPlunderModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPlunderModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPlunderModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlunderModifier@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetPlunderModifier, COMDAT
; _this$ = ecx

; 396  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 397  : 	return m_iPlunderModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+380]

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlunderModifier@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetPlunderModifier
_TEXT	ENDS
PUBLIC	?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetImprovementMaintenanceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetImprovementMaintenanceModifier, COMDAT
; _this$ = ecx

; 402  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 	return m_iImprovementMaintenanceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+384]

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetImprovementMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeDurationModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeDurationModifier, COMDAT
; _this$ = ecx

; 408  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return m_iGoldenAgeDurationModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+388]

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeDurationModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetGoldenAgeMoveChange
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeMoveChange, COMDAT
; _this$ = ecx

; 414  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 415  : 	return m_iGoldenAgeMoveChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+392]

; 416  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeMoveChange
_TEXT	ENDS
PUBLIC	?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeCombatModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeCombatModifier, COMDAT
; _this$ = ecx

; 420  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 	return m_iGoldenAgeCombatModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+396]

; 422  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeCombatModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetGoldenAgeTourismModifier, COMDAT
; _this$ = ecx

; 426  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 427  : 	return m_iGoldenAgeTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+400]

; 428  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetGoldenAgeTourismModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatArtistRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGoldenAgeGreatArtistRateModifier, COMDAT
; _this$ = ecx

; 432  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 433  : 	return m_iGoldenAgeGreatArtistRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+404]

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGoldenAgeGreatArtistRateModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatMusicianRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGoldenAgeGreatMusicianRateModifier, COMDAT
; _this$ = ecx

; 438  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 	return m_iGoldenAgeGreatMusicianRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+408]

; 440  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGoldenAgeGreatMusicianRateModifier
_TEXT	ENDS
PUBLIC	?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatWriterRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetGoldenAgeGreatWriterRateModifier, COMDAT
; _this$ = ecx

; 444  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 	return m_iGoldenAgeGreatWriterRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+412]

; 446  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetGoldenAgeGreatWriterRateModifier
_TEXT	ENDS
PUBLIC	?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetExtraEmbarkMoves
; Function compile flags: /Odtp
;	COMDAT ?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetExtraEmbarkMoves, COMDAT
; _this$ = ecx

; 450  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 451  : 	return m_iExtraEmbarkMoves;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+424]

; 452  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetExtraEmbarkMoves
_TEXT	ENDS
PUBLIC	?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetFreeUnitClassType
; Function compile flags: /Odtp
;	COMDAT ?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetFreeUnitClassType, COMDAT
; _this$ = ecx

; 456  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 	return m_iFreeUnitClassType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+428]

; 458  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetFreeUnitClassType
_TEXT	ENDS
PUBLIC	?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderFirstFinderGold
; Function compile flags: /Odtp
;	COMDAT ?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderFirstFinderGold, COMDAT
; _this$ = ecx

; 462  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 	return m_iNaturalWonderFirstFinderGold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+432]

; 464  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderFirstFinderGold
_TEXT	ENDS
PUBLIC	?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderSubsequentFinderGold
; Function compile flags: /Odtp
;	COMDAT ?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderSubsequentFinderGold, COMDAT
; _this$ = ecx

; 468  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 	return m_iNaturalWonderSubsequentFinderGold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+436]

; 470  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderSubsequentFinderGold
_TEXT	ENDS
PUBLIC	?GetNaturalWonderFirstFinderFaith@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderFirstFinderFaith
; Function compile flags: /Odtp
;	COMDAT ?GetNaturalWonderFirstFinderFaith@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNaturalWonderFirstFinderFaith@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderFirstFinderFaith, COMDAT
; _this$ = ecx

; 476  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 	return m_iNaturalWonderFirstFinderFaith;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+440]

; 478  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNaturalWonderFirstFinderFaith@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderFirstFinderFaith
_TEXT	ENDS
PUBLIC	?GetNaturalWonderSubsequentFinderFaith@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderSubsequentFinderFaith
; Function compile flags: /Odtp
;	COMDAT ?GetNaturalWonderSubsequentFinderFaith@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNaturalWonderSubsequentFinderFaith@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderSubsequentFinderFaith, COMDAT
; _this$ = ecx

; 482  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 483  : 	return m_iNaturalWonderSubsequentFinderFaith;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+444]

; 484  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNaturalWonderSubsequentFinderFaith@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderSubsequentFinderFaith
_TEXT	ENDS
PUBLIC	?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderYieldModifier, COMDAT
; _this$ = ecx

; 490  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 491  : 	return m_iNaturalWonderYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+448]

; 492  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderYieldModifier
_TEXT	ENDS
PUBLIC	?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderHappinessModifier
; Function compile flags: /Odtp
;	COMDAT ?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNaturalWonderHappinessModifier, COMDAT
; _this$ = ecx

; 496  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 	return m_iNaturalWonderHappinessModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+452]

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNaturalWonderHappinessModifier
_TEXT	ENDS
PUBLIC	?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNearbyImprovementCombatBonus
; Function compile flags: /Odtp
;	COMDAT ?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNearbyImprovementCombatBonus, COMDAT
; _this$ = ecx

; 502  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 	return m_iNearbyImprovementCombatBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+456]

; 504  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNearbyImprovementCombatBonus
_TEXT	ENDS
PUBLIC	?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNearbyImprovementBonusRange
; Function compile flags: /Odtp
;	COMDAT ?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNearbyImprovementBonusRange, COMDAT
; _this$ = ecx

; 508  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 509  : 	return m_iNearbyImprovementBonusRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+460]

; 510  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNearbyImprovementBonusRange
_TEXT	ENDS
PUBLIC	?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCultureBuildingYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetCultureBuildingYieldChange, COMDAT
; _this$ = ecx

; 514  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 	return m_iCultureBuildingYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+464]

; 516  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetCultureBuildingYieldChange
_TEXT	ENDS
PUBLIC	?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCombatBonusVsHigherTech
; Function compile flags: /Odtp
;	COMDAT ?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCombatBonusVsHigherTech, COMDAT
; _this$ = ecx

; 520  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return m_iCombatBonusVsHigherTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+468]

; 522  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCombatBonusVsHigherTech
_TEXT	ENDS
PUBLIC	?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetCombatBonusVsLargerCiv
; Function compile flags: /Odtp
;	COMDAT ?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetCombatBonusVsLargerCiv, COMDAT
; _this$ = ecx

; 526  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 527  : 	return m_iCombatBonusVsLargerCiv;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+472]

; 528  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetCombatBonusVsLargerCiv
_TEXT	ENDS
PUBLIC	?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetRazeSpeedModifier
; Function compile flags: /Odtp
;	COMDAT ?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetRazeSpeedModifier, COMDAT
; _this$ = ecx

; 532  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 	return m_iRazeSpeedModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+484]

; 534  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetRazeSpeedModifier
_TEXT	ENDS
PUBLIC	?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetDOFGreatPersonModifier
; Function compile flags: /Odtp
;	COMDAT ?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetDOFGreatPersonModifier, COMDAT
; _this$ = ecx

; 538  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 539  : 	return m_iDOFGreatPersonModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+488]

; 540  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetDOFGreatPersonModifier
_TEXT	ENDS
PUBLIC	?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandUnitMaintenanceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetLandUnitMaintenanceModifier, COMDAT
; _this$ = ecx

; 544  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 	return m_iLandUnitMaintenanceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+476]

; 546  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetLandUnitMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNavalUnitMaintenanceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetNavalUnitMaintenanceModifier, COMDAT
; _this$ = ecx

; 550  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 551  : 	return m_iNavalUnitMaintenanceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+480]

; 552  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetNavalUnitMaintenanceModifier
_TEXT	ENDS
PUBLIC	?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLuxuryHappinessRetention
; Function compile flags: /Odtp
;	COMDAT ?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetLuxuryHappinessRetention, COMDAT
; _this$ = ecx

; 556  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 	return m_iLuxuryHappinessRetention;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+492]

; 558  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetLuxuryHappinessRetention
_TEXT	ENDS
PUBLIC	?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetExtraHappinessPerLuxury
; Function compile flags: /Odtp
;	COMDAT ?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetExtraHappinessPerLuxury, COMDAT
; _this$ = ecx

; 563  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 	return m_iExtraHappinessPerLuxury;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+496]

; 565  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetExtraHappinessPerLuxury
_TEXT	ENDS
PUBLIC	?GetExtraSpies@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetExtraSpies
; Function compile flags: /Odtp
;	COMDAT ?GetExtraSpies@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraSpies@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetExtraSpies, COMDAT
; _this$ = ecx

; 571  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 572  : 	return m_iExtraSpies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+500]

; 573  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraSpies@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetExtraSpies
_TEXT	ENDS
PUBLIC	?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetHappinessPerReligion
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetHappinessPerReligion, COMDAT
; _this$ = ecx

; 578  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 579  : 	return m_iHappinessPerReligion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+504]

; 580  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetHappinessPerReligion
_TEXT	ENDS
PUBLIC	?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetUnresearchedTechBonusFromKills
; Function compile flags: /Odtp
;	COMDAT ?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetUnresearchedTechBonusFromKills, COMDAT
; _this$ = ecx

; 585  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 	return m_iUnresearchedTechBonusFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+508]

; 587  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetUnresearchedTechBonusFromKills
_TEXT	ENDS
PUBLIC	?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetExtraFoundedCityTerritoryClaimRange
; Function compile flags: /Odtp
;	COMDAT ?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetExtraFoundedCityTerritoryClaimRange, COMDAT
; _this$ = ecx

; 590  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 	return m_iExtraFoundedCityTerritoryClaimRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+512]

; 592  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetExtraFoundedCityTerritoryClaimRange
_TEXT	ENDS
PUBLIC	?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetFreeSocialPoliciesPerEra
; Function compile flags: /Odtp
;	COMDAT ?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetFreeSocialPoliciesPerEra, COMDAT
; _this$ = ecx

; 596  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 597  : 	return m_iFreeSocialPoliciesPerEra;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+516]

; 598  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetFreeSocialPoliciesPerEra
_TEXT	ENDS
PUBLIC	?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetNumTradeRoutesModifier
; Function compile flags: /Odtp
;	COMDAT ?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetNumTradeRoutesModifier, COMDAT
; _this$ = ecx

; 601  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 602  : 	return m_iNumTradeRoutesModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+520]

; 603  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetNumTradeRoutesModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetTradeRouteResourceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetTradeRouteResourceModifier, COMDAT
; _this$ = ecx

; 606  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 	return m_iTradeRouteResourceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+524]

; 608  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetTradeRouteResourceModifier
_TEXT	ENDS
PUBLIC	?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetUniqueLuxuryCities
; Function compile flags: /Odtp
;	COMDAT ?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetUniqueLuxuryCities, COMDAT
; _this$ = ecx

; 611  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 	return m_iUniqueLuxuryCities;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+528]

; 613  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetUniqueLuxuryCities
_TEXT	ENDS
PUBLIC	?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetUniqueLuxuryQuantity
; Function compile flags: /Odtp
;	COMDAT ?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetUniqueLuxuryQuantity, COMDAT
; _this$ = ecx

; 616  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 617  : 	return m_iUniqueLuxuryQuantity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+532]

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetUniqueLuxuryQuantity
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetWorkerSpeedModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 621  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+536]

; 623  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetAfraidMinorPerTurnInfluence
; Function compile flags: /Odtp
;	COMDAT ?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ PROC ; CvTraitEntry::GetAfraidMinorPerTurnInfluence, COMDAT
; _this$ = ecx

; 626  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 	return m_iAfraidMinorPerTurnInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+540]

; 628  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ ENDP ; CvTraitEntry::GetAfraidMinorPerTurnInfluence
_TEXT	ENDS
PUBLIC	?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandTradeRouteRangeBonus
; Function compile flags: /Odtp
;	COMDAT ?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetLandTradeRouteRangeBonus, COMDAT
; _this$ = ecx

; 631  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 	return m_iLandTradeRouteRangeBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+544]

; 633  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetLandTradeRouteRangeBonus
_TEXT	ENDS
PUBLIC	?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetTradeReligionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetTradeReligionModifier, COMDAT
; _this$ = ecx

; 636  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	return m_iTradeReligionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+548]

; 638  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetTradeReligionModifier
_TEXT	ENDS
PUBLIC	?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetTradeBuildingModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ PROC	; CvTraitEntry::GetTradeBuildingModifier, COMDAT
; _this$ = ecx

; 641  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 	return m_iTradeBuildingModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+552]

; 643  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ ENDP	; CvTraitEntry::GetTradeBuildingModifier
_TEXT	ENDS
PUBLIC	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeBuildingPrereqTech
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ PROC ; CvTraitEntry::GetFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 648  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 649  : 	return m_eFreeBuildingPrereqTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+572]

; 650  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ENDP ; CvTraitEntry::GetFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ PROC ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 652  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 653  : 	return m_eCapitalFreeBuildingPrereqTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+576]

; 654  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ENDP ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeUnitPrereqTech
; Function compile flags: /Odtp
;	COMDAT ?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ PROC ; CvTraitEntry::GetFreeUnitPrereqTech, COMDAT
; _this$ = ecx

; 658  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 659  : 	return m_eFreeUnitPrereqTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+556]

; 660  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ENDP ; CvTraitEntry::GetFreeUnitPrereqTech
_TEXT	ENDS
PUBLIC	?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ ; CvTraitEntry::GetCombatBonusImprovement
; Function compile flags: /Odtp
;	COMDAT ?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ PROC ; CvTraitEntry::GetCombatBonusImprovement, COMDAT
; _this$ = ecx

; 664  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 	return m_eCombatBonusImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+560]

; 666  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ ENDP ; CvTraitEntry::GetCombatBonusImprovement
_TEXT	ENDS
PUBLIC	?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvTraitEntry::GetFreeBuilding, COMDAT
; _this$ = ecx

; 670  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  : 	return m_eFreeBuilding;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+564]

; 672  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvTraitEntry::GetFreeBuilding
_TEXT	ENDS
PUBLIC	?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeCapitalBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvTraitEntry::GetFreeCapitalBuilding, COMDAT
; _this$ = ecx

; 676  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 	return m_eFreeCapitalBuilding;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+568]

; 678  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvTraitEntry::GetFreeCapitalBuilding
_TEXT	ENDS
PUBLIC	?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuildingOnConquest
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvTraitEntry::GetFreeBuildingOnConquest, COMDAT
; _this$ = ecx

; 682  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 683  : 	return m_eFreeBuildingOnConquest;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+580]

; 684  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvTraitEntry::GetFreeBuildingOnConquest
_TEXT	ENDS
PUBLIC	?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsFightWellDamaged
; Function compile flags: /Odtp
;	COMDAT ?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsFightWellDamaged, COMDAT
; _this$ = ecx

; 688  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 	return m_bFightWellDamaged;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+584]

; 690  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsFightWellDamaged
_TEXT	ENDS
PUBLIC	?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsMoveFriendlyWoodsAsRoad
; Function compile flags: /Odtp
;	COMDAT ?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsMoveFriendlyWoodsAsRoad, COMDAT
; _this$ = ecx

; 694  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 695  : 	return m_bMoveFriendlyWoodsAsRoad;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+585]

; 696  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsMoveFriendlyWoodsAsRoad
_TEXT	ENDS
PUBLIC	?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsFasterAlongRiver
; Function compile flags: /Odtp
;	COMDAT ?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsFasterAlongRiver, COMDAT
; _this$ = ecx

; 700  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 701  : 	return m_bFasterAlongRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+586]

; 702  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsFasterAlongRiver
_TEXT	ENDS
PUBLIC	?IsFasterInHills@CvTraitEntry@@QBE_NXZ		; CvTraitEntry::IsFasterInHills
; Function compile flags: /Odtp
;	COMDAT ?IsFasterInHills@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFasterInHills@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsFasterInHills, COMDAT
; _this$ = ecx

; 706  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 707  : 	return m_bFasterInHills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+587]

; 708  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFasterInHills@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsFasterInHills
_TEXT	ENDS
PUBLIC	?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsEmbarkedAllWater
; Function compile flags: /Odtp
;	COMDAT ?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsEmbarkedAllWater, COMDAT
; _this$ = ecx

; 712  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 	return m_bEmbarkedAllWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+588]

; 714  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsEmbarkedAllWater
_TEXT	ENDS
PUBLIC	?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsEmbarkedToLandFlatCost
; Function compile flags: /Odtp
;	COMDAT ?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsEmbarkedToLandFlatCost, COMDAT
; _this$ = ecx

; 718  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 719  : 	return m_bEmbarkedToLandFlatCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+589]

; 720  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsEmbarkedToLandFlatCost
_TEXT	ENDS
PUBLIC	?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsNoHillsImprovementMaintenance
; Function compile flags: /Odtp
;	COMDAT ?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsNoHillsImprovementMaintenance, COMDAT
; _this$ = ecx

; 724  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 	return m_bNoHillsImprovementMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+590]

; 726  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsNoHillsImprovementMaintenance
_TEXT	ENDS
PUBLIC	?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsTechBoostFromCapitalScienceBuildings
; Function compile flags: /Odtp
;	COMDAT ?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsTechBoostFromCapitalScienceBuildings, COMDAT
; _this$ = ecx

; 730  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 	return m_bTechBoostFromCapitalScienceBuildings;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+591]

; 732  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsTechBoostFromCapitalScienceBuildings
_TEXT	ENDS
PUBLIC	?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsStaysAliveZeroCities
; Function compile flags: /Odtp
;	COMDAT ?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsStaysAliveZeroCities, COMDAT
; _this$ = ecx

; 736  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 737  : 	return m_bStaysAliveZeroCities;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+592]

; 738  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsStaysAliveZeroCities
_TEXT	ENDS
PUBLIC	?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsFaithFromUnimprovedForest
; Function compile flags: /Odtp
;	COMDAT ?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsFaithFromUnimprovedForest, COMDAT
; _this$ = ecx

; 742  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	return m_bFaithFromUnimprovedForest;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+593]

; 744  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsFaithFromUnimprovedForest
_TEXT	ENDS
PUBLIC	?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsSeaTradeRoutesArePlunderImmune
; Function compile flags: /Odtp
;	COMDAT ?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsSeaTradeRoutesArePlunderImmune, COMDAT
; _this$ = ecx

; 749  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 750  : 	return m_bSeaTradeRoutesArePlunderImmune;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+594]

; 751  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsSeaTradeRoutesArePlunderImmune
_TEXT	ENDS
PUBLIC	?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsEarnsGreatPersonOnSlotOrGuild
; Function compile flags: /Odtp
;	COMDAT ?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsEarnsGreatPersonOnSlotOrGuild, COMDAT
; _this$ = ecx

; 757  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 758  : 	return m_bEarnsGreatPersonOnSlotOrGuild;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+595]

; 759  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsEarnsGreatPersonOnSlotOrGuild
_TEXT	ENDS
PUBLIC	?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsHasBuiltWritersGuild
; Function compile flags: /Odtp
;	COMDAT ?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsHasBuiltWritersGuild, COMDAT
; _this$ = ecx

; 762  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 763  : 	return m_bHasBuiltWritersGuild;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+596]

; 764  : };

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHasBuiltWritersGuild@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsHasBuiltWritersGuild
_TEXT	ENDS
PUBLIC	?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z	; CvTraitEntry::SetHasBuiltWritersGuild
; Function compile flags: /Odtp
;	COMDAT ?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hasBuilt$ = 8						; size = 1
?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z PROC	; CvTraitEntry::SetHasBuiltWritersGuild, COMDAT
; _this$ = ecx

; 767  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 768  : 	m_bHasBuiltWritersGuild = hasBuilt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _hasBuilt$[ebp]
	mov	BYTE PTR [eax+596], cl

; 769  : };

	mov	esp, ebp
	pop	ebp
	ret	4
?SetHasBuiltWritersGuild@CvTraitEntry@@QAEX_N@Z ENDP	; CvTraitEntry::SetHasBuiltWritersGuild
_TEXT	ENDS
PUBLIC	?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsHasBuiltArtistsGuild
; Function compile flags: /Odtp
;	COMDAT ?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsHasBuiltArtistsGuild, COMDAT
; _this$ = ecx

; 772  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 773  : 	return m_bHasBuiltArtistsGuild;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+597]

; 774  : };

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHasBuiltArtistsGuild@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsHasBuiltArtistsGuild
_TEXT	ENDS
PUBLIC	?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z	; CvTraitEntry::SetHasBuiltArtistsGuild
; Function compile flags: /Odtp
;	COMDAT ?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hasBuilt$ = 8						; size = 1
?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z PROC	; CvTraitEntry::SetHasBuiltArtistsGuild, COMDAT
; _this$ = ecx

; 777  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 778  : 	m_bHasBuiltArtistsGuild = hasBuilt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _hasBuilt$[ebp]
	mov	BYTE PTR [eax+597], cl

; 779  : };

	mov	esp, ebp
	pop	ebp
	ret	4
?SetHasBuiltArtistsGuild@CvTraitEntry@@QAEX_N@Z ENDP	; CvTraitEntry::SetHasBuiltArtistsGuild
_TEXT	ENDS
PUBLIC	?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsHasBuiltMusiciansGuild
; Function compile flags: /Odtp
;	COMDAT ?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsHasBuiltMusiciansGuild, COMDAT
; _this$ = ecx

; 782  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 783  : 	return m_bHasBuiltMusiciansGuild;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+598]

; 784  : };

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHasBuiltMusiciansGuild@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsHasBuiltMusiciansGuild
_TEXT	ENDS
PUBLIC	?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z ; CvTraitEntry::SetHasBuiltMusiciansGuild
; Function compile flags: /Odtp
;	COMDAT ?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hasBuilt$ = 8						; size = 1
?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z PROC	; CvTraitEntry::SetHasBuiltMusiciansGuild, COMDAT
; _this$ = ecx

; 787  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 788  : 	m_bHasBuiltMusiciansGuild = hasBuilt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _hasBuilt$[ebp]
	mov	BYTE PTR [eax+598], cl

; 789  : };

	mov	esp, ebp
	pop	ebp
	ret	4
?SetHasBuiltMusiciansGuild@CvTraitEntry@@QAEX_N@Z ENDP	; CvTraitEntry::SetHasBuiltMusiciansGuild
_TEXT	ENDS
PUBLIC	?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsBonusReligiousBelief
; Function compile flags: /Odtp
;	COMDAT ?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsBonusReligiousBelief, COMDAT
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	return m_bBonusReligiousBelief;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+599]

; 796  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsBonusReligiousBelief
_TEXT	ENDS
PUBLIC	?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsAbleToAnnexCityStates
; Function compile flags: /Odtp
;	COMDAT ?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsAbleToAnnexCityStates, COMDAT
; _this$ = ecx

; 800  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 801  : 	return m_bAbleToAnnexCityStates;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+600]

; 802  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsAbleToAnnexCityStates
_TEXT	ENDS
PUBLIC	?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsCrossesMountainsAfterGreatGeneral
; Function compile flags: /Odtp
;	COMDAT ?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsCrossesMountainsAfterGreatGeneral, COMDAT
; _this$ = ecx

; 806  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 807  : 	return m_bCrossesMountainsAfterGreatGeneral;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+601]

; 808  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsCrossesMountainsAfterGreatGeneral
_TEXT	ENDS
PUBLIC	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsMayaCalendarBonuses
; Function compile flags: /Odtp
;	COMDAT ?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsMayaCalendarBonuses, COMDAT
; _this$ = ecx

; 812  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 813  : 	return m_bMayaCalendarBonuses;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+602]

; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsMayaCalendarBonuses
_TEXT	ENDS
PUBLIC	?IsNoAnnexing@CvTraitEntry@@QBE_NXZ		; CvTraitEntry::IsNoAnnexing
; Function compile flags: /Odtp
;	COMDAT ?IsNoAnnexing@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoAnnexing@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsNoAnnexing, COMDAT
; _this$ = ecx

; 818  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 819  : 	return m_bNoAnnexing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+603]

; 820  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoAnnexing@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsNoAnnexing
_TEXT	ENDS
PUBLIC	?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsTechFromCityConquer
; Function compile flags: /Odtp
;	COMDAT ?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ PROC	; CvTraitEntry::IsTechFromCityConquer, COMDAT
; _this$ = ecx

; 824  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 825  : 	return m_bTechFromCityConquer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+604]

; 826  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ ENDP	; CvTraitEntry::IsTechFromCityConquer
_TEXT	ENDS
PUBLIC	?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsUniqueLuxuryRequiresNewArea
; Function compile flags: /Odtp
;	COMDAT ?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsUniqueLuxuryRequiresNewArea, COMDAT
; _this$ = ecx

; 830  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 831  : 	return m_bUniqueLuxuryRequiresNewArea;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+605]

; 832  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsUniqueLuxuryRequiresNewArea
_TEXT	ENDS
PUBLIC	?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ		; CvTraitEntry::IsRiverTradeRoad
; Function compile flags: /Odtp
;	COMDAT ?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ PROC		; CvTraitEntry::IsRiverTradeRoad, COMDAT
; _this$ = ecx

; 836  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 837  : 	return m_bRiverTradeRoad;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+606]

; 838  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ ENDP		; CvTraitEntry::IsRiverTradeRoad
_TEXT	ENDS
PUBLIC	?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsAngerFreeIntrusionOfCityStates
; Function compile flags: /Odtp
;	COMDAT ?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ PROC ; CvTraitEntry::IsAngerFreeIntrusionOfCityStates, COMDAT
; _this$ = ecx

; 842  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 	return m_bAngerFreeIntrusionOfCityStates;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+607]

; 844  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ ENDP ; CvTraitEntry::IsAngerFreeIntrusionOfCityStates
_TEXT	ENDS
PUBLIC	?getShortDescription@CvTraitEntry@@QBEPBDXZ	; CvTraitEntry::getShortDescription
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?getShortDescription@CvTraitEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getShortDescription@CvTraitEntry@@QBEPBDXZ PROC	; CvTraitEntry::getShortDescription, COMDAT
; _this$ = ecx

; 848  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 849  : 	return m_strShortDescription;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 608				; 00000260H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 850  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getShortDescription@CvTraitEntry@@QBEPBDXZ ENDP	; CvTraitEntry::getShortDescription
_TEXT	ENDS
PUBLIC	?setShortDescription@CvTraitEntry@@QAEXPBD@Z	; CvTraitEntry::setShortDescription
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?setShortDescription@CvTraitEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T229072 = -4						; size = 4
_szVal$ = 8						; size = 4
?setShortDescription@CvTraitEntry@@QAEXPBD@Z PROC	; CvTraitEntry::setShortDescription, COMDAT
; _this$ = ecx

; 854  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 855  : 	m_strShortDescription = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 608				; 00000260H
	mov	DWORD PTR $T229072[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN4@setShortDe
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229072[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@setShortDe
$LN4@setShortDe:
	mov	ecx, DWORD PTR $T229072[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@setShortDe:

; 856  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setShortDescription@CvTraitEntry@@QAEXPBD@Z ENDP	; CvTraitEntry::setShortDescription
_TEXT	ENDS
PUBLIC	?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z	; CvTraitEntry::GetExtraYieldThreshold
; Function compile flags: /Odtp
;	COMDAT ?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetExtraYieldThreshold, COMDAT
; _this$ = ecx

; 860  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 861  : 	return m_paiExtraYieldThreshold ? m_paiExtraYieldThreshold[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+636], 0
	je	SHORT $LN3@GetExtraYi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+636]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetExtraYi
$LN3@GetExtraYi:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetExtraYi:
	mov	eax, DWORD PTR tv69[ebp]

; 862  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetExtraYieldThreshold
_TEXT	ENDS
PUBLIC	?GetYieldChange@CvTraitEntry@@QBEHH@Z		; CvTraitEntry::GetYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChange@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChange@CvTraitEntry@@QBEHH@Z PROC		; CvTraitEntry::GetYieldChange, COMDAT
; _this$ = ecx

; 866  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 867  : 	return m_paiYieldChange ? m_paiYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+640], 0
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+640]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh
$LN3@GetYieldCh:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh:
	mov	eax, DWORD PTR tv69[ebp]

; 868  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChange@CvTraitEntry@@QBEHH@Z ENDP		; CvTraitEntry::GetYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeStrategicResources
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangeStrategicResources, COMDAT
; _this$ = ecx

; 872  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 873  : 	return m_paiYieldChangeStrategicResources ? m_paiYieldChangeStrategicResources[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+644], 0
	je	SHORT $LN3@GetYieldCh@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+644]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@2
$LN3@GetYieldCh@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh@2:
	mov	eax, DWORD PTR tv69[ebp]

; 874  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangeStrategicResources
_TEXT	ENDS
PUBLIC	?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeLuxuryResources
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangeLuxuryResources, COMDAT
; _this$ = ecx

; 879  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 880  : 	return m_paiYieldChangeLuxuryResources ? m_paiYieldChangeLuxuryResources[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+648], 0
	je	SHORT $LN3@GetYieldCh@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@3
$LN3@GetYieldCh@3:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh@3:
	mov	eax, DWORD PTR tv69[ebp]

; 881  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangeLuxuryResources
_TEXT	ENDS
PUBLIC	?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeNaturalWonder
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetYieldChangeNaturalWonder, COMDAT
; _this$ = ecx

; 886  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 	return m_paiYieldChangeNaturalWonder ? m_paiYieldChangeNaturalWonder[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+652], 0
	je	SHORT $LN3@GetYieldCh@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+652]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@4
$LN3@GetYieldCh@4:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh@4:
	mov	eax, DWORD PTR tv69[ebp]

; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetYieldChangeNaturalWonder
_TEXT	ENDS
PUBLIC	?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangePerTradePartner
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangePerTradePartner, COMDAT
; _this$ = ecx

; 892  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 893  : 	return m_paiYieldChangePerTradePartner ? m_paiYieldChangePerTradePartner[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+656], 0
	je	SHORT $LN3@GetYieldCh@5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+656]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@5
$LN3@GetYieldCh@5:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh@5:
	mov	eax, DWORD PTR tv69[ebp]

; 894  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangePerTradePartner
_TEXT	ENDS
PUBLIC	?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeIncomingTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetYieldChangeIncomingTradeRoute, COMDAT
; _this$ = ecx

; 898  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 899  : 	return m_paiYieldChangeIncomingTradeRoute ? m_paiYieldChangeIncomingTradeRoute[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+660], 0
	je	SHORT $LN3@GetYieldCh@6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@6
$LN3@GetYieldCh@6:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh@6:
	mov	eax, DWORD PTR tv69[ebp]

; 900  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetYieldChangeIncomingTradeRoute
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvTraitEntry@@QBEHH@Z		; CvTraitEntry::GetYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetYieldModifier@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldModifier@CvTraitEntry@@QBEHH@Z PROC		; CvTraitEntry::GetYieldModifier, COMDAT
; _this$ = ecx

; 904  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 905  : 	return m_paiYieldModifier ? m_paiYieldModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+664], 0
	je	SHORT $LN3@GetYieldMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+664]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldMo
$LN3@GetYieldMo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldMo:
	mov	eax, DWORD PTR tv69[ebp]

; 906  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldModifier@CvTraitEntry@@QBEHH@Z ENDP		; CvTraitEntry::GetYieldModifier
_TEXT	ENDS
PUBLIC	?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetStrategicResourceQuantityModifier
; Function compile flags: /Odtp
;	COMDAT ?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetStrategicResourceQuantityModifier, COMDAT
; _this$ = ecx

; 910  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 911  : 	return m_piStrategicResourceQuantityModifier ? m_piStrategicResourceQuantityModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+668], 0
	je	SHORT $LN3@GetStrateg
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+668]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetStrateg
$LN3@GetStrateg:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetStrateg:
	mov	eax, DWORD PTR tv69[ebp]

; 912  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetStrategicResourceQuantityModifier
_TEXT	ENDS
PUBLIC	?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetResourceQuantityModifier
; Function compile flags: /Odtp
;	COMDAT ?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetResourceQuantityModifier, COMDAT
; _this$ = ecx

; 916  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 917  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 918  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 919  : 	return m_piResourceQuantityModifiers ? m_piResourceQuantityModifiers[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetResourc
$LN3@GetResourc:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetResourc:
	mov	eax, DWORD PTR tv69[ebp]

; 920  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetResourceQuantityModifier
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetImprovementYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvTraitEntry::GetImprovementYieldChanges, COMDAT
; _this$ = ecx

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 925  : 	CvAssertMsg(eIndex1 < GC.getNumImprovementInfos(), "Index out of bounds");
; 926  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 927  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 928  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 929  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 930  : 	return m_ppiImprovementYieldChanges.first ? m_ppiImprovementYieldChanges.first[eIndex1][eIndex2] : 0;
; 931  : #else
; 932  : 	return m_ppiImprovementYieldChanges ? m_ppiImprovementYieldChanges[eIndex1][eIndex2] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+684], 0
	je	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+684]
	mov	eax, DWORD PTR _eIndex1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _eIndex2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetImprove
$LN3@GetImprove:
	mov	DWORD PTR tv71[ebp], 0
$LN4@GetImprove:
	mov	eax, DWORD PTR tv71[ebp]

; 933  : #endif
; 934  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvTraitEntry::GetImprovementYieldChanges
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetSpecialistYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z PROC ; CvTraitEntry::GetSpecialistYieldChanges, COMDAT
; _this$ = ecx

; 938  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 939  : 	CvAssertMsg(eIndex1 < GC.getNumSpecialistInfos(), "Index out of bounds");
; 940  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 941  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 942  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 943  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 944  : 	return m_ppiSpecialistYieldChanges.first ? m_ppiSpecialistYieldChanges.first[eIndex1][eIndex2] : 0;
; 945  : #else
; 946  : 	return m_ppiSpecialistYieldChanges ? m_ppiSpecialistYieldChanges[eIndex1][eIndex2] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+688], 0
	je	SHORT $LN3@GetSpecial
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _eIndex1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _eIndex2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetSpecial
$LN3@GetSpecial:
	mov	DWORD PTR tv71[ebp], 0
$LN4@GetSpecial:
	mov	eax, DWORD PTR tv71[ebp]

; 947  : #endif
; 948  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ENDP ; CvTraitEntry::GetSpecialistYieldChanges
_TEXT	ENDS
PUBLIC	?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetUnimprovedFeatureYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z PROC ; CvTraitEntry::GetUnimprovedFeatureYieldChanges, COMDAT
; _this$ = ecx

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 	CvAssertMsg(eIndex1 < GC.getNumFeatureInfos(), "Index out of bounds");
; 968  : 	CvAssertMsg(eIndex1 > -1, "Index out of bounds");
; 969  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "Index out of bounds");
; 970  : 	CvAssertMsg(eIndex2 > -1, "Index out of bounds");
; 971  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 972  : 	return m_ppiUnimprovedFeatureYieldChanges.first ? m_ppiUnimprovedFeatureYieldChanges.first[eIndex1][eIndex2] : 0;
; 973  : #else
; 974  : 	return m_ppiUnimprovedFeatureYieldChanges ? m_ppiUnimprovedFeatureYieldChanges[eIndex1][eIndex2] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+692], 0
	je	SHORT $LN3@GetUnimpro
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR _eIndex1$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _eIndex2$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetUnimpro
$LN3@GetUnimpro:
	mov	DWORD PTR tv71[ebp], 0
$LN4@GetUnimpro:
	mov	eax, DWORD PTR tv71[ebp]

; 975  : #endif
; 976  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ENDP ; CvTraitEntry::GetUnimprovedFeatureYieldChanges
_TEXT	ENDS
PUBLIC	?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z	; CvTraitEntry::GetMovesChangeUnitCombat
; Function compile flags: /Odtp
;	COMDAT ?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_unitCombatID$ = 8					; size = 4
?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z PROC	; CvTraitEntry::GetMovesChangeUnitCombat, COMDAT
; _this$ = ecx

; 980  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 981  : 	CvAssertMsg((unitCombatID >= 0), "unitCombatID is less than zero");
; 982  : 	CvAssertMsg((unitCombatID < GC.getNumUnitCombatClassInfos()), "unitCombatID exceeds number of combat classes");
; 983  : 
; 984  : 	return m_piMovesChangeUnitCombats[unitCombatID];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+676]
	mov	edx, DWORD PTR _unitCombatID$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 985  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z ENDP	; CvTraitEntry::GetMovesChangeUnitCombat
_TEXT	ENDS
PUBLIC	?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetMaintenanceModifierUnitCombat
; Function compile flags: /Odtp
;	COMDAT ?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_unitCombatID$ = 8					; size = 4
?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z PROC ; CvTraitEntry::GetMaintenanceModifierUnitCombat, COMDAT
; _this$ = ecx

; 989  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 990  : 	CvAssertMsg((unitCombatID >= 0), "unitCombatID is less than zero");
; 991  : 	CvAssertMsg((unitCombatID < GC.getNumUnitCombatClassInfos()), "unitCombatID exceeds number of combat classes");
; 992  : 
; 993  : 	return m_piMaintenanceModifierUnitCombats[unitCombatID];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	mov	edx, DWORD PTR _unitCombatID$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 994  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z ENDP ; CvTraitEntry::GetMaintenanceModifierUnitCombat
_TEXT	ENDS
PUBLIC	?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ; CvTraitEntry::GetFreeResourceXCities
; Function compile flags: /Odtp
;	COMDAT ?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_eResource$ = 12					; size = 4
?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z PROC ; CvTraitEntry::GetFreeResourceXCities, COMDAT
; _this$ = ecx

; 998  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 999  : 	return m_aFreeResourceXCities[(int)eResource];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	edx, DWORD PTR _eResource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1000 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ENDP ; CvTraitEntry::GetFreeResourceXCities
_TEXT	ENDS
PUBLIC	?GetObsoleteTech@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetObsoleteTech
; Function compile flags: /Odtp
;	COMDAT ?GetObsoleteTech@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObsoleteTech@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetObsoleteTech, COMDAT
; _this$ = ecx

; 1004 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1005 : 	return m_iObsoleteTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+416]

; 1006 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetObsoleteTech@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetObsoleteTech
_TEXT	ENDS
PUBLIC	?GetPrereqTech@CvTraitEntry@@QBEHXZ		; CvTraitEntry::GetPrereqTech
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqTech@CvTraitEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrereqTech@CvTraitEntry@@QBEHXZ PROC		; CvTraitEntry::GetPrereqTech, COMDAT
; _this$ = ecx

; 1010 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1011 : 	return m_iPrereqTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+420]

; 1012 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrereqTech@CvTraitEntry@@QBEHXZ ENDP		; CvTraitEntry::GetPrereqTech
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
PUBLIC	?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z ; CvTraitEntry::IsFreePromotionUnitCombat
; Function compile flags: /Odtp
;	COMDAT ?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T229252 = -60						; size = 4
$T229201 = -48						; size = 4
$T229140 = -12						; size = 4
_lastElement$221948 = -8				; size = 4
_it$ = -4						; size = 4
_promotionID$ = 8					; size = 4
_unitCombatID$ = 12					; size = 4
?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z PROC	; CvTraitEntry::IsFreePromotionUnitCombat, COMDAT
; _this$ = ecx

; 1016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 1017 : 	std::multimap<int, int>::const_iterator it = m_FreePromotionUnitCombats.find(promotionID);

	lea	eax, DWORD PTR _promotionID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find

; 1018 : 	if(it != m_FreePromotionUnitCombats.end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+700]
	mov	DWORD PTR $T229201[ebp], eax
	mov	ecx, DWORD PTR $T229201[ebp]
	mov	DWORD PTR $T229140[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T229140[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@IsFreeProm

; 1019 : 	{
; 1020 : 		// get an iterator to the element that is one past the last element associated with key
; 1021 : 		std::multimap<int, int>::const_iterator lastElement = m_FreePromotionUnitCombats.upper_bound(promotionID);

	lea	eax, DWORD PTR _promotionID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
	mov	DWORD PTR $T229252[ebp], eax
	mov	ecx, DWORD PTR $T229252[ebp]
	mov	DWORD PTR _lastElement$221948[ebp], ecx

; 1022 : 
; 1023 : 		// for each element in the sequence [itr, lastElement)
; 1024 : 		for(; it != lastElement; ++it)

	jmp	SHORT $LN106@IsFreeProm
$LN3@IsFreeProm:
	lea	ecx, DWORD PTR _it$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
$LN106@IsFreeProm:
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _lastElement$221948[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@IsFreeProm

; 1025 : 		{
; 1026 : 			if(it->second == unitCombatID)

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _unitCombatID$[ebp]
	jne	SHORT $LN1@IsFreeProm

; 1027 : 			{
; 1028 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@IsFreeProm
$LN1@IsFreeProm:

; 1029 : 			}
; 1030 : 		}

	jmp	SHORT $LN3@IsFreeProm
$LN5@IsFreeProm:

; 1031 : 	}
; 1032 : 
; 1033 : 	return false;

	xor	al, al
$LN6@IsFreeProm:

; 1034 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z ENDP	; CvTraitEntry::IsFreePromotionUnitCombat
_TEXT	ENDS
PUBLIC	?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ; CvTraitEntry::IsObsoleteByTech
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Odtp
;	COMDAT ?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T229333 = -4						; size = 4
_eTeam$ = 8						; size = 4
?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z PROC ; CvTraitEntry::IsObsoleteByTech, COMDAT
; _this$ = ecx

; 1038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 	if(m_iObsoleteTech != NO_TECH)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+416], -1
	je	SHORT $LN2@IsObsolete

; 1040 : 	{
; 1041 : 		if(GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)m_iObsoleteTech))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T229333[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+416]
	push	eax
	mov	ecx, DWORD PTR $T229333[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsObsolete

; 1042 : 		{
; 1043 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsObsolete
$LN2@IsObsolete:

; 1044 : 		}
; 1045 : 	}
; 1046 : 	return false;

	xor	al, al
$LN3@IsObsolete:

; 1047 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ENDP ; CvTraitEntry::IsObsoleteByTech
_TEXT	ENDS
PUBLIC	?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ; CvTraitEntry::IsEnabledByTech
; Function compile flags: /Odtp
;	COMDAT ?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T229339 = -4						; size = 4
_eTeam$ = 8						; size = 4
?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z PROC ; CvTraitEntry::IsEnabledByTech, COMDAT
; _this$ = ecx

; 1051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1052 : 	if(m_iPrereqTech != NO_TECH)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+420], -1
	je	SHORT $LN3@IsEnabledB

; 1053 : 	{
; 1054 : 		if(GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)m_iPrereqTech))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T229339[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+420]
	push	eax
	mov	ecx, DWORD PTR $T229339[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsEnabledB

; 1055 : 		{
; 1056 : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@IsEnabledB

; 1057 : 		}
; 1058 : 		else

	jmp	SHORT $LN3@IsEnabledB
$LN2@IsEnabledB:

; 1059 : 		{
; 1060 : 			return false;

	xor	al, al
	jmp	SHORT $LN4@IsEnabledB
$LN3@IsEnabledB:

; 1061 : 		}
; 1062 : 	}
; 1063 : 	return true;

	mov	al, 1
$LN4@IsEnabledB:

; 1064 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ENDP ; CvTraitEntry::IsEnabledByTech
_TEXT	ENDS
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC	?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z ; CvTraitEntry::NoTrain
; Function compile flags: /Odtp
;	COMDAT ?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T229436 = -60						; size = 4
$T229426 = -56						; size = 4
$T229342 = -8						; size = 8
_eUnitClass$ = 8					; size = 4
?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z PROC	; CvTraitEntry::NoTrain, COMDAT
; _this$ = ecx

; 1067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 	if (eUnitClass != NO_UNITCLASS)

	cmp	DWORD PTR _eUnitClass$[ebp], -1
	je	SHORT $LN2@NoTrain

; 1069 : 	{
; 1070 : 		return m_abNoTrainUnitClass[eUnitClass];

	mov	eax, DWORD PTR _eUnitClass$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229342[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T229436[ebp], eax
	mov	edx, DWORD PTR $T229436[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T229426[ebp], eax
	mov	ecx, DWORD PTR $T229436[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	eax, cl
	mov	edx, DWORD PTR $T229426[ebp]
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN3@NoTrain

; 1071 : 	}
; 1072 : 	else

	jmp	SHORT $LN3@NoTrain
$LN2@NoTrain:

; 1073 : 	{
; 1074 : 		return false;

	xor	al, al
$LN3@NoTrain:

; 1075 : 	}
; 1076 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z ENDP	; CvTraitEntry::NoTrain
_TEXT	ENDS
PUBLIC	?NoBuild@CvTraitEntry@@QAE_NW4ImprovementTypes@@@Z ; CvTraitEntry::NoBuild
; Function compile flags: /Odtp
;	COMDAT ?NoBuild@CvTraitEntry@@QAE_NW4ImprovementTypes@@@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T229533 = -60						; size = 4
$T229523 = -56						; size = 4
$T229439 = -8						; size = 8
_eImprovementType$ = 8					; size = 4
?NoBuild@CvTraitEntry@@QAE_NW4ImprovementTypes@@@Z PROC	; CvTraitEntry::NoBuild, COMDAT
; _this$ = ecx

; 1081 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 1082 : 	if (eImprovementType != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovementType$[ebp], -1
	je	SHORT $LN2@NoBuild

; 1083 : 	{
; 1084 : 		return m_abNoBuildImprovement[eImprovementType];

	mov	eax, DWORD PTR _eImprovementType$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229439[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T229533[ebp], eax
	mov	edx, DWORD PTR $T229533[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T229523[ebp], eax
	mov	ecx, DWORD PTR $T229533[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	eax, cl
	mov	edx, DWORD PTR $T229523[ebp]
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN3@NoBuild

; 1085 : 	}
; 1086 : 	else

	jmp	SHORT $LN3@NoBuild
$LN2@NoBuild:

; 1087 : 	{
; 1088 : 		return false;

	xor	al, al
$LN3@NoBuild:

; 1089 : 	}
; 1090 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NoBuild@CvTraitEntry@@QAE_NW4ImprovementTypes@@@Z ENDP	; CvTraitEntry::NoBuild
_TEXT	ENDS
PUBLIC	??_C@_0KN@EDAJGKBH@select?5Resources?4ID?5as?5ResourceI@ ; `string'
PUBLIC	??_C@_0BP@LEJJCALA@Trait_FreeResourceFirstXCities?$AA@ ; `string'
PUBLIC	?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back
PUBLIC	??_C@_0NB@LGAABOM@SELECT?5Traits?4ID?0?5Improvements?4I@ ; `string'
PUBLIC	??_C@_0O@DEFFCEIL@Trait_NoBuild?$AA@		; `string'
PUBLIC	??_C@_0MM@LPKCCPOE@SELECT?5Traits?4ID?0?5UnitClasses?4ID@ ; `string'
PUBLIC	??_C@_0O@GKGKBLJD@Trait_NoTrain?$AA@		; `string'
PUBLIC	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
PUBLIC	??_C@_0NK@BJHMDDLL@select?5Features?4ID?5as?5FeatureID?0@ ; `string'
PUBLIC	??_C@_0CE@ICBKMLMI@Trait_UnimprovedFeatureYieldChan@ ; `string'
PUBLIC	??_C@_08CLANBDND@Features?$AA@			; `string'
PUBLIC	??_C@_0OC@HBPDFFH@select?5Specialists?4ID?5as?5Special@ ; `string'
PUBLIC	??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0M@EENMFCNN@Specialists?$AA@		; `string'
PUBLIC	??_C@_0OI@DKABCEMC@select?5Improvements?4ID?5as?5Improv@ ; `string'
PUBLIC	??_C@_0BO@GHGAFJAB@Trait_ImprovementYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0N@CJDAHDJO@Improvements?$AA@		; `string'
PUBLIC	??_C@_06JAMLCLDI@Yields?$AA@			; `string'
PUBLIC	??_C@_0LC@MLJIIHHK@select?5UnitCombatInfos?4ID?0?5Maint@ ; `string'
PUBLIC	??_C@_0CF@FJLAILPM@Trait_MaintenanceModifierUnitCom@ ; `string'
PUBLIC	??_C@_0KC@CPPIJLAI@select?5UnitCombatInfos?4ID?0?5Moves@ ; `string'
PUBLIC	??_C@_0BN@PCNKEGGO@Trait_MovesChangeUnitCombats?$AA@ ; `string'
PUBLIC	??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@		; `string'
PUBLIC	??_C@_09FDCBPLKG@Resources?$AA@			; `string'
PUBLIC	??_C@_0CA@KDHCGIKB@Trait_ResourceQuantityModifiers?$AA@ ; `string'
PUBLIC	??_C@_0N@EPHJOCBJ@ResourceType?$AA@		; `string'
PUBLIC	??_C@_0BJ@PKPOGINB@ResourceQuantityModifier?$AA@ ; `string'
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
PUBLIC	??_C@_0NI@DOOOMALO@select?5UnitPromotions?4ID?0?5UnitCo@ ; `string'
PUBLIC	??_C@_0BJ@HAFNGCNE@FreePromotionUnitCombats?$AA@ ; `string'
PUBLIC	??_C@_0CC@ODCDLGED@StrategicResourceQuantityModifie@ ; `string'
PUBLIC	??_C@_09EINBFHAC@TerrainID?$AA@			; `string'
PUBLIC	??_C@_0KD@DPKDKHBJ@select?5TraitType?0?5Terrains?4ID?5as@ ; `string'
PUBLIC	??_C@_0P@GJDNFKFB@Trait_Terrains?$AA@		; `string'
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
PUBLIC	??_C@_0BF@FHEKODEE@Trait_YieldModifiers?$AA@	; `string'
PUBLIC	??_C@_0CF@CONFBLMP@Trait_YieldChangesIncomingTradeR@ ; `string'
PUBLIC	??_C@_0CC@KLPGMKPB@Trait_YieldChangesPerTradePartne@ ; `string'
PUBLIC	??_C@_0CA@BIAKPHGH@Trait_YieldChangesNaturalWonder?$AA@ ; `string'
PUBLIC	??_C@_0CC@DNGEBFJO@Trait_YieldChangesLuxuryResource@ ; `string'
PUBLIC	??_C@_0CF@INKJLPBJ@Trait_YieldChangesStrategicResou@ ; `string'
PUBLIC	??_C@_0BD@HFICJHBM@Trait_YieldChanges?$AA@	; `string'
PUBLIC	??_C@_0BL@FAHDJKGN@Trait_ExtraYieldThresholds?$AA@ ; `string'
PUBLIC	??_C@_09HHNMMNID@TraitType?$AA@			; `string'
PUBLIC	??_C@_0BP@IHDNKOKH@AngerFreeIntrusionOfCityStates?$AA@ ; `string'
PUBLIC	??_C@_0P@BMCPGFLA@RiverTradeRoad?$AA@		; `string'
PUBLIC	??_C@_0BM@IDFEDMKD@UniqueLuxuryRequiresNewArea?$AA@ ; `string'
PUBLIC	??_C@_0BE@KHGGKHH@TechFromCityConquer?$AA@	; `string'
PUBLIC	??_C@_0L@FIOLCHFG@NoAnnexing?$AA@		; `string'
PUBLIC	??_C@_0BE@KEFCGJDL@MayaCalendarBonuses?$AA@	; `string'
PUBLIC	??_C@_0CC@FJPEFFBL@CrossesMountainsAfterGreatGenera@ ; `string'
PUBLIC	??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@	; `string'
PUBLIC	??_C@_0BF@CKKILNFD@BonusReligiousBelief?$AA@	; `string'
PUBLIC	??_C@_0BO@JDKBCLKK@EarnsGreatPersonOnSlotOrGuild?$AA@ ; `string'
PUBLIC	??_C@_0BP@OLGOEANA@SeaTradeRoutesArePlunderImmune?$AA@ ; `string'
PUBLIC	??_C@_0BK@KEEAFDIB@FaithFromUnimprovedForest?$AA@ ; `string'
PUBLIC	??_C@_0BF@GOHJOIEH@StaysAliveZeroCities?$AA@	; `string'
PUBLIC	??_C@_0CF@EHDKIJNN@TechBoostFromCapitalScienceBuild@ ; `string'
PUBLIC	??_C@_0BO@BADJGMNH@NoHillsImprovementMaintenance?$AA@ ; `string'
PUBLIC	??_C@_0BH@HEPMOODJ@EmbarkedToLandFlatCost?$AA@	; `string'
PUBLIC	??_C@_0BB@COFEIKJH@EmbarkedAllWater?$AA@	; `string'
PUBLIC	??_C@_0O@BOLDEMDP@FasterInHills?$AA@		; `string'
PUBLIC	??_C@_0BB@HIJGMHHM@FasterAlongRiver?$AA@	; `string'
PUBLIC	??_C@_0BI@KHHPPHAJ@MoveFriendlyWoodsAsRoad?$AA@	; `string'
PUBLIC	??_C@_0BB@FFBACMEJ@FightWellDamaged?$AA@	; `string'
PUBLIC	??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@	; `string'
PUBLIC	??_C@_0BE@BMODEEBC@FreeCapitalBuilding?$AA@	; `string'
PUBLIC	??_C@_0N@EHKBNAC@FreeBuilding?$AA@		; `string'
PUBLIC	??_C@_0L@NJNFNDFO@PrereqTech?$AA@		; `string'
PUBLIC	??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@		; `string'
PUBLIC	??_C@_0BH@GMFFPLCG@CombatBonusImprovement?$AA@	; `string'
PUBLIC	??_C@_0BO@MEABIPHA@CapitalFreeBuildingPrereqTech?$AA@ ; `string'
PUBLIC	??_C@_0BH@NNAIEBBN@FreeBuildingPrereqTech?$AA@	; `string'
PUBLIC	??_C@_0BD@OEBDLCBD@FreeUnitPrereqTech?$AA@	; `string'
PUBLIC	??_C@_08PMODHGEM@FreeUnit?$AA@			; `string'
PUBLIC	??_C@_0BG@OOCFOBDJ@TradeBuildingModifier?$AA@	; `string'
PUBLIC	??_C@_0BG@CICGAOPI@TradeReligionModifier?$AA@	; `string'
PUBLIC	??_C@_0BJ@IPEHHBM@LandTradeRouteRangeBonus?$AA@	; `string'
PUBLIC	??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@ ; `string'
PUBLIC	??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@	; `string'
PUBLIC	??_C@_0BF@JCMHACMD@UniqueLuxuryQuantity?$AA@	; `string'
PUBLIC	??_C@_0BD@BNFGGMNB@UniqueLuxuryCities?$AA@	; `string'
PUBLIC	??_C@_0BL@OPNOFJAB@TradeRouteResourceModifier?$AA@ ; `string'
PUBLIC	??_C@_0BH@OHBFFHBN@NumTradeRoutesModifier?$AA@	; `string'
PUBLIC	??_C@_0BJ@NNFMBHPN@FreeSocialPoliciesPerEra?$AA@ ; `string'
PUBLIC	??_C@_0CE@BMKGAGFH@ExtraFoundedCityTerritoryClaimRa@ ; `string'
PUBLIC	??_C@_0BP@DEELJCPA@UnresearchedTechBonusFromKills?$AA@ ; `string'
PUBLIC	??_C@_0BF@OCPLAGIK@HappinessPerReligion?$AA@	; `string'
PUBLIC	??_C@_0L@MHOKHMFG@ExtraSpies?$AA@		; `string'
PUBLIC	??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@	; `string'
PUBLIC	??_C@_0BJ@FBADGCLK@LuxuryHappinessRetention?$AA@ ; `string'
PUBLIC	??_C@_0BH@MOOGPKPG@DOFGreatPersonModifier?$AA@	; `string'
PUBLIC	??_C@_0BC@HKIMEGAL@RazeSpeedModifier?$AA@	; `string'
PUBLIC	??_C@_0BN@FAJBHPKK@NavalUnitMaintenanceModifier?$AA@ ; `string'
PUBLIC	??_C@_0BM@IDILIMFG@LandUnitMaintenanceModifier?$AA@ ; `string'
PUBLIC	??_C@_0BH@HPFMENFC@CombatBonusVsLargerCiv?$AA@	; `string'
PUBLIC	??_C@_0BI@DGLMDOGP@CombatBonusVsHigherTech?$AA@	; `string'
PUBLIC	??_C@_0BL@DJIJFOPM@CultureBuildingYieldChange?$AA@ ; `string'
PUBLIC	??_C@_0BM@IFKLCMB@NearbyImprovementBonusRange?$AA@ ; `string'
PUBLIC	??_C@_0BN@BPMPNCFH@NearbyImprovementCombatBonus?$AA@ ; `string'
PUBLIC	??_C@_0BP@NGJNFACF@NaturalWonderHappinessModifier?$AA@ ; `string'
PUBLIC	??_C@_0BL@NAOBBDJO@NaturalWonderYieldModifier?$AA@ ; `string'
PUBLIC	??_C@_0CD@EBAKNJFP@NaturalWonderSubsequentFinderFai@ ; `string'
PUBLIC	??_C@_0BO@EBGIMHIP@NaturalWonderFirstFinderFaith?$AA@ ; `string'
PUBLIC	??_C@_0CC@NMHMFIPI@NaturalWonderSubsequentFinderGol@ ; `string'
PUBLIC	??_C@_0BN@LOGCIIPI@NaturalWonderFirstFinderGold?$AA@ ; `string'
PUBLIC	??_C@_0BB@BHJJBIH@ExtraEmbarkMoves?$AA@		; `string'
PUBLIC	??_C@_0CB@KEODKJBJ@GoldenAgeGreatWriterRateModifier@ ; `string'
PUBLIC	??_C@_0CD@MENCBKJL@GoldenAgeGreatMusicianRateModifi@ ; `string'
PUBLIC	??_C@_0CB@FOKFNPKD@GoldenAgeGreatArtistRateModifier@ ; `string'
PUBLIC	??_C@_0BJ@LPJPLOKH@GoldenAgeTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@MFCFAJNI@GoldenAgeCombatModifier?$AA@	; `string'
PUBLIC	??_C@_0BE@JJLHBCMM@GoldenAgeMoveChange?$AA@	; `string'
PUBLIC	??_C@_0BK@IIBCIDDC@GoldenAgeDurationModifier?$AA@ ; `string'
PUBLIC	??_C@_0BP@HHMKJBJK@ImprovementMaintenanceModifier?$AA@ ; `string'
PUBLIC	??_C@_0BA@MLDJOLFP@PlunderModifier?$AA@		; `string'
PUBLIC	??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BP@CGFEGMEN@CityConnectionTradeRouteChange?$AA@ ; `string'
PUBLIC	??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BM@NFLFOOON@CapitalThemingBonusModifier?$AA@ ; `string'
PUBLIC	??_C@_0BB@FEMBFCEN@CityCultureBonus?$AA@	; `string'
PUBLIC	??_C@_0P@POALJMFH@FaithFromKills?$AA@		; `string'
PUBLIC	??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@	; `string'
PUBLIC	??_C@_0BI@JGNHBIFC@GoldenAgeTileBonusFaith?$AA@	; `string'
PUBLIC	??_C@_0CG@DEMNCJFF@NumTurnsBeforeMinorAlliesRefuseB@ ; `string'
PUBLIC	??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@ ; `string'
PUBLIC	??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BI@MLKAEAMP@CapitalBuildingModifier?$AA@	; `string'
PUBLIC	??_C@_0BO@OOIEDACI@SeaBarbarianConversionPercent?$AA@ ; `string'
PUBLIC	??_C@_0CC@GPFEONPB@LandBarbarianConversionExtraUnit@ ; `string'
PUBLIC	??_C@_0BP@CBHCFKJC@LandBarbarianConversionPercent?$AA@ ; `string'
PUBLIC	??_C@_0BI@LLKLCJEP@CityStateCombatModifier?$AA@	; `string'
PUBLIC	??_C@_0BM@CJCOCPNL@CityStateFriendshipModifier?$AA@ ; `string'
PUBLIC	??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@	; `string'
PUBLIC	??_C@_0BO@DHGOHAIB@PopulationUnhappinessModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@COFBHJFM@CityUnhappinessModifier?$AA@	; `string'
PUBLIC	??_C@_0CE@NPEABLDP@MaxPlayerBuildingProductionModif@ ; `string'
PUBLIC	??_C@_0CC@LNEKPAPM@MaxTeamBuildingProductionModifie@ ; `string'
PUBLIC	??_C@_0CE@JPCAIMIG@MaxGlobalBuildingProductionModif@ ; `string'
PUBLIC	??_C@_0BJ@IGFDIHCA@GreatPersonGiftInfluence?$AA@ ; `string'
PUBLIC	??_C@_0BH@LHGCIMPK@GreatGeneralExtraBonus?$AA@	; `string'
PUBLIC	??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@	; `string'
PUBLIC	??_C@_0BI@IJFKMPJF@LevelExperienceModifier?$AA@	; `string'
PUBLIC	??_C@_0BB@GBLDMPKE@ShortDescription?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?getNumTerrainInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTerrainInfos
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT ??_C@_0KN@EDAJGKBH@select?5Resources?4ID?5as?5ResourceI@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_C@_0KN@EDAJGKBH@select?5Resources?4ID?5as?5ResourceI@ DB 'select Resou'
	DB	'rces.ID as ResourceID, ResourceQuantity, NumCities from Trait'
	DB	'_FreeResourceFirstXCities inner join Resources on Resources.T'
	DB	'ype = ResourceType where TraitType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LEJJCALA@Trait_FreeResourceFirstXCities?$AA@
CONST	SEGMENT
??_C@_0BP@LEJJCALA@Trait_FreeResourceFirstXCities?$AA@ DB 'Trait_FreeReso'
	DB	'urceFirstXCities', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0NB@LGAABOM@SELECT?5Traits?4ID?0?5Improvements?4I@
CONST	SEGMENT
??_C@_0NB@LGAABOM@SELECT?5Traits?4ID?0?5Improvements?4I@ DB 'SELECT Trait'
	DB	's.ID, Improvements.ID FROM Trait_NoBuild inner join Traits on'
	DB	' Trait_NoBuild.TraitType = Traits.Type inner join Improvement'
	DB	's on Trait_NoBuild.ImprovementType = Improvements.Type where '
	DB	'TraitType = ?', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DEFFCEIL@Trait_NoBuild?$AA@
CONST	SEGMENT
??_C@_0O@DEFFCEIL@Trait_NoBuild?$AA@ DB 'Trait_NoBuild', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MM@LPKCCPOE@SELECT?5Traits?4ID?0?5UnitClasses?4ID@
CONST	SEGMENT
??_C@_0MM@LPKCCPOE@SELECT?5Traits?4ID?0?5UnitClasses?4ID@ DB 'SELECT Trai'
	DB	'ts.ID, UnitClasses.ID FROM Trait_NoTrain inner join Traits on'
	DB	' Trait_NoTrain.TraitType = Traits.Type inner join UnitClasses'
	DB	' on Trait_NoTrain.UnitClassType = UnitClasses.Type where Trai'
	DB	'tType = ?', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKGKBLJD@Trait_NoTrain?$AA@
CONST	SEGMENT
??_C@_0O@GKGKBLJD@Trait_NoTrain?$AA@ DB 'Trait_NoTrain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NK@BJHMDDLL@select?5Features?4ID?5as?5FeatureID?0@
CONST	SEGMENT
??_C@_0NK@BJHMDDLL@select?5Features?4ID?5as?5FeatureID?0@ DB 'select Feat'
	DB	'ures.ID as FeatureID, Yields.ID as YieldID, Yield from Trait_'
	DB	'UnimprovedFeatureYieldChanges inner join Features on Features'
	DB	'.Type = FeatureType inner join Yields on Yields.Type = YieldT'
	DB	'ype where TraitType = ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ICBKMLMI@Trait_UnimprovedFeatureYieldChan@
CONST	SEGMENT
??_C@_0CE@ICBKMLMI@Trait_UnimprovedFeatureYieldChan@ DB 'Trait_Unimproved'
	DB	'FeatureYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLANBDND@Features?$AA@
CONST	SEGMENT
??_C@_08CLANBDND@Features?$AA@ DB 'Features', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OC@HBPDFFH@select?5Specialists?4ID?5as?5Special@
CONST	SEGMENT
??_C@_0OC@HBPDFFH@select?5Specialists?4ID?5as?5Special@ DB 'select Specia'
	DB	'lists.ID as SpecialistID, Yields.ID as YieldID, Yield from Tr'
	DB	'ait_SpecialistYieldChanges inner join Specialists on Speciali'
	DB	'sts.Type = SpecialistType inner join Yields on Yields.Type = '
	DB	'YieldType where TraitType = ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@
CONST	SEGMENT
??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@ DB 'Building_Speci'
	DB	'alistYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENMFCNN@Specialists?$AA@
CONST	SEGMENT
??_C@_0M@EENMFCNN@Specialists?$AA@ DB 'Specialists', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0OI@DKABCEMC@select?5Improvements?4ID?5as?5Improv@
CONST	SEGMENT
??_C@_0OI@DKABCEMC@select?5Improvements?4ID?5as?5Improv@ DB 'select Impro'
	DB	'vements.ID as ImprovementID, Yields.ID as YieldID, Yield from'
	DB	' Trait_ImprovementYieldChanges inner join Improvements on Imp'
	DB	'rovements.Type = ImprovementType inner join Yields on Yields.'
	DB	'Type = YieldType where TraitType = ?', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GHGAFJAB@Trait_ImprovementYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BO@GHGAFJAB@Trait_ImprovementYieldChanges?$AA@ DB 'Trait_Improveme'
	DB	'ntYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CJDAHDJO@Improvements?$AA@
CONST	SEGMENT
??_C@_0N@CJDAHDJO@Improvements?$AA@ DB 'Improvements', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JAMLCLDI@Yields?$AA@
CONST	SEGMENT
??_C@_06JAMLCLDI@Yields?$AA@ DB 'Yields', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0LC@MLJIIHHK@select?5UnitCombatInfos?4ID?0?5Maint@
CONST	SEGMENT
??_C@_0LC@MLJIIHHK@select?5UnitCombatInfos?4ID?0?5Maint@ DB 'select UnitC'
	DB	'ombatInfos.ID, MaintenanceModifier from Trait_MaintenanceModi'
	DB	'fierUnitCombats inner join UnitCombatInfos on UnitCombatInfos'
	DB	'.Type = UnitCombatType where TraitType = ?;', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FJLAILPM@Trait_MaintenanceModifierUnitCom@
CONST	SEGMENT
??_C@_0CF@FJLAILPM@Trait_MaintenanceModifierUnitCom@ DB 'Trait_Maintenanc'
	DB	'eModifierUnitCombats', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0KC@CPPIJLAI@select?5UnitCombatInfos?4ID?0?5Moves@
CONST	SEGMENT
??_C@_0KC@CPPIJLAI@select?5UnitCombatInfos?4ID?0?5Moves@ DB 'select UnitC'
	DB	'ombatInfos.ID, MovesChange from Trait_MovesChangeUnitCombats '
	DB	'inner join UnitCombatInfos on UnitCombatInfos.Type = UnitComb'
	DB	'atType where TraitType = ?;', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PCNKEGGO@Trait_MovesChangeUnitCombats?$AA@
CONST	SEGMENT
??_C@_0BN@PCNKEGGO@Trait_MovesChangeUnitCombats?$AA@ DB 'Trait_MovesChang'
	DB	'eUnitCombats', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
CONST	SEGMENT
??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@ DB 'UnitCombatInfos', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FDCBPLKG@Resources?$AA@
CONST	SEGMENT
??_C@_09FDCBPLKG@Resources?$AA@ DB 'Resources', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KDHCGIKB@Trait_ResourceQuantityModifiers?$AA@
CONST	SEGMENT
??_C@_0CA@KDHCGIKB@Trait_ResourceQuantityModifiers?$AA@ DB 'Trait_Resourc'
	DB	'eQuantityModifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
CONST	SEGMENT
??_C@_0N@EPHJOCBJ@ResourceType?$AA@ DB 'ResourceType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PKPOGINB@ResourceQuantityModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@PKPOGINB@ResourceQuantityModifier?$AA@ DB 'ResourceQuantityModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0NI@DOOOMALO@select?5UnitPromotions?4ID?0?5UnitCo@
CONST	SEGMENT
??_C@_0NI@DOOOMALO@select?5UnitPromotions?4ID?0?5UnitCo@ DB 'select UnitP'
	DB	'romotions.ID, UnitCombatInfos.ID from Trait_FreePromotionUnit'
	DB	'Combats, UnitPromotions, UnitCombatInfos where TraitType = ? '
	DB	'and PromotionType = UnitPromotions.Type and UnitCombatType = '
	DB	'UnitCombatInfos.Type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAFNGCNE@FreePromotionUnitCombats?$AA@
CONST	SEGMENT
??_C@_0BJ@HAFNGCNE@FreePromotionUnitCombats?$AA@ DB 'FreePromotionUnitCom'
	DB	'bats', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ODCDLGED@StrategicResourceQuantityModifie@
CONST	SEGMENT
??_C@_0CC@ODCDLGED@StrategicResourceQuantityModifie@ DB 'StrategicResourc'
	DB	'eQuantityModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EINBFHAC@TerrainID?$AA@
CONST	SEGMENT
??_C@_09EINBFHAC@TerrainID?$AA@ DB 'TerrainID', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0KD@DPKDKHBJ@select?5TraitType?0?5Terrains?4ID?5as@
CONST	SEGMENT
??_C@_0KD@DPKDKHBJ@select?5TraitType?0?5Terrains?4ID?5as@ DB 'select Trai'
	DB	'tType, Terrains.ID as TerrainID, StrategicResourceQuantityMod'
	DB	'ifier from Trait_Terrains join Terrains on Terrains.Type = Te'
	DB	'rrainType where TraitType = ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJDNFKFB@Trait_Terrains?$AA@
CONST	SEGMENT
??_C@_0P@GJDNFKFB@Trait_Terrains?$AA@ DB 'Trait_Terrains', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FHEKODEE@Trait_YieldModifiers?$AA@
CONST	SEGMENT
??_C@_0BF@FHEKODEE@Trait_YieldModifiers?$AA@ DB 'Trait_YieldModifiers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CONFBLMP@Trait_YieldChangesIncomingTradeR@
CONST	SEGMENT
??_C@_0CF@CONFBLMP@Trait_YieldChangesIncomingTradeR@ DB 'Trait_YieldChang'
	DB	'esIncomingTradeRoute', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KLPGMKPB@Trait_YieldChangesPerTradePartne@
CONST	SEGMENT
??_C@_0CC@KLPGMKPB@Trait_YieldChangesPerTradePartne@ DB 'Trait_YieldChang'
	DB	'esPerTradePartner', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BIAKPHGH@Trait_YieldChangesNaturalWonder?$AA@
CONST	SEGMENT
??_C@_0CA@BIAKPHGH@Trait_YieldChangesNaturalWonder?$AA@ DB 'Trait_YieldCh'
	DB	'angesNaturalWonder', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DNGEBFJO@Trait_YieldChangesLuxuryResource@
CONST	SEGMENT
??_C@_0CC@DNGEBFJO@Trait_YieldChangesLuxuryResource@ DB 'Trait_YieldChang'
	DB	'esLuxuryResources', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@INKJLPBJ@Trait_YieldChangesStrategicResou@
CONST	SEGMENT
??_C@_0CF@INKJLPBJ@Trait_YieldChangesStrategicResou@ DB 'Trait_YieldChang'
	DB	'esStrategicResources', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HFICJHBM@Trait_YieldChanges?$AA@
CONST	SEGMENT
??_C@_0BD@HFICJHBM@Trait_YieldChanges?$AA@ DB 'Trait_YieldChanges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FAHDJKGN@Trait_ExtraYieldThresholds?$AA@
CONST	SEGMENT
??_C@_0BL@FAHDJKGN@Trait_ExtraYieldThresholds?$AA@ DB 'Trait_ExtraYieldTh'
	DB	'resholds', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09HHNMMNID@TraitType?$AA@
CONST	SEGMENT
??_C@_09HHNMMNID@TraitType?$AA@ DB 'TraitType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IHDNKOKH@AngerFreeIntrusionOfCityStates?$AA@
CONST	SEGMENT
??_C@_0BP@IHDNKOKH@AngerFreeIntrusionOfCityStates?$AA@ DB 'AngerFreeIntru'
	DB	'sionOfCityStates', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMCPGFLA@RiverTradeRoad?$AA@
CONST	SEGMENT
??_C@_0P@BMCPGFLA@RiverTradeRoad?$AA@ DB 'RiverTradeRoad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IDFEDMKD@UniqueLuxuryRequiresNewArea?$AA@
CONST	SEGMENT
??_C@_0BM@IDFEDMKD@UniqueLuxuryRequiresNewArea?$AA@ DB 'UniqueLuxuryRequi'
	DB	'resNewArea', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KHGGKHH@TechFromCityConquer?$AA@
CONST	SEGMENT
??_C@_0BE@KHGGKHH@TechFromCityConquer?$AA@ DB 'TechFromCityConquer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FIOLCHFG@NoAnnexing?$AA@
CONST	SEGMENT
??_C@_0L@FIOLCHFG@NoAnnexing?$AA@ DB 'NoAnnexing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEFCGJDL@MayaCalendarBonuses?$AA@
CONST	SEGMENT
??_C@_0BE@KEFCGJDL@MayaCalendarBonuses?$AA@ DB 'MayaCalendarBonuses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FJPEFFBL@CrossesMountainsAfterGreatGenera@
CONST	SEGMENT
??_C@_0CC@FJPEFFBL@CrossesMountainsAfterGreatGenera@ DB 'CrossesMountains'
	DB	'AfterGreatGeneral', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@
CONST	SEGMENT
??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@ DB 'AbleToAnnexCityStates', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CKKILNFD@BonusReligiousBelief?$AA@
CONST	SEGMENT
??_C@_0BF@CKKILNFD@BonusReligiousBelief?$AA@ DB 'BonusReligiousBelief', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JDKBCLKK@EarnsGreatPersonOnSlotOrGuild?$AA@
CONST	SEGMENT
??_C@_0BO@JDKBCLKK@EarnsGreatPersonOnSlotOrGuild?$AA@ DB 'EarnsGreatPerso'
	DB	'nOnSlotOrGuild', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLGOEANA@SeaTradeRoutesArePlunderImmune?$AA@
CONST	SEGMENT
??_C@_0BP@OLGOEANA@SeaTradeRoutesArePlunderImmune?$AA@ DB 'SeaTradeRoutes'
	DB	'ArePlunderImmune', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KEEAFDIB@FaithFromUnimprovedForest?$AA@
CONST	SEGMENT
??_C@_0BK@KEEAFDIB@FaithFromUnimprovedForest?$AA@ DB 'FaithFromUnimproved'
	DB	'Forest', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOHJOIEH@StaysAliveZeroCities?$AA@
CONST	SEGMENT
??_C@_0BF@GOHJOIEH@StaysAliveZeroCities?$AA@ DB 'StaysAliveZeroCities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EHDKIJNN@TechBoostFromCapitalScienceBuild@
CONST	SEGMENT
??_C@_0CF@EHDKIJNN@TechBoostFromCapitalScienceBuild@ DB 'TechBoostFromCap'
	DB	'italScienceBuildings', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BADJGMNH@NoHillsImprovementMaintenance?$AA@
CONST	SEGMENT
??_C@_0BO@BADJGMNH@NoHillsImprovementMaintenance?$AA@ DB 'NoHillsImprovem'
	DB	'entMaintenance', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HEPMOODJ@EmbarkedToLandFlatCost?$AA@
CONST	SEGMENT
??_C@_0BH@HEPMOODJ@EmbarkedToLandFlatCost?$AA@ DB 'EmbarkedToLandFlatCost'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COFEIKJH@EmbarkedAllWater?$AA@
CONST	SEGMENT
??_C@_0BB@COFEIKJH@EmbarkedAllWater?$AA@ DB 'EmbarkedAllWater', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BOLDEMDP@FasterInHills?$AA@
CONST	SEGMENT
??_C@_0O@BOLDEMDP@FasterInHills?$AA@ DB 'FasterInHills', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HIJGMHHM@FasterAlongRiver?$AA@
CONST	SEGMENT
??_C@_0BB@HIJGMHHM@FasterAlongRiver?$AA@ DB 'FasterAlongRiver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KHHPPHAJ@MoveFriendlyWoodsAsRoad?$AA@
CONST	SEGMENT
??_C@_0BI@KHHPPHAJ@MoveFriendlyWoodsAsRoad?$AA@ DB 'MoveFriendlyWoodsAsRo'
	DB	'ad', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FFBACMEJ@FightWellDamaged?$AA@
CONST	SEGMENT
??_C@_0BB@FFBACMEJ@FightWellDamaged?$AA@ DB 'FightWellDamaged', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@
CONST	SEGMENT
??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@ DB 'FreeBuildingOnConquest'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BMODEEBC@FreeCapitalBuilding?$AA@
CONST	SEGMENT
??_C@_0BE@BMODEEBC@FreeCapitalBuilding?$AA@ DB 'FreeCapitalBuilding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHKBNAC@FreeBuilding?$AA@
CONST	SEGMENT
??_C@_0N@EHKBNAC@FreeBuilding?$AA@ DB 'FreeBuilding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NJNFNDFO@PrereqTech?$AA@
CONST	SEGMENT
??_C@_0L@NJNFNDFO@PrereqTech?$AA@ DB 'PrereqTech', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@
CONST	SEGMENT
??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@ DB 'ObsoleteTech', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GMFFPLCG@CombatBonusImprovement?$AA@
CONST	SEGMENT
??_C@_0BH@GMFFPLCG@CombatBonusImprovement?$AA@ DB 'CombatBonusImprovement'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MEABIPHA@CapitalFreeBuildingPrereqTech?$AA@
CONST	SEGMENT
??_C@_0BO@MEABIPHA@CapitalFreeBuildingPrereqTech?$AA@ DB 'CapitalFreeBuil'
	DB	'dingPrereqTech', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NNAIEBBN@FreeBuildingPrereqTech?$AA@
CONST	SEGMENT
??_C@_0BH@NNAIEBBN@FreeBuildingPrereqTech?$AA@ DB 'FreeBuildingPrereqTech'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEBDLCBD@FreeUnitPrereqTech?$AA@
CONST	SEGMENT
??_C@_0BD@OEBDLCBD@FreeUnitPrereqTech?$AA@ DB 'FreeUnitPrereqTech', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMODHGEM@FreeUnit?$AA@
CONST	SEGMENT
??_C@_08PMODHGEM@FreeUnit?$AA@ DB 'FreeUnit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OOCFOBDJ@TradeBuildingModifier?$AA@
CONST	SEGMENT
??_C@_0BG@OOCFOBDJ@TradeBuildingModifier?$AA@ DB 'TradeBuildingModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CICGAOPI@TradeReligionModifier?$AA@
CONST	SEGMENT
??_C@_0BG@CICGAOPI@TradeReligionModifier?$AA@ DB 'TradeReligionModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IPEHHBM@LandTradeRouteRangeBonus?$AA@
CONST	SEGMENT
??_C@_0BJ@IPEHHBM@LandTradeRouteRangeBonus?$AA@ DB 'LandTradeRouteRangeBo'
	DB	'nus', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@
CONST	SEGMENT
??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@ DB 'AfraidMinorPerTur'
	DB	'nInfluence', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
CONST	SEGMENT
??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@ DB 'WorkerSpeedModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCMHACMD@UniqueLuxuryQuantity?$AA@
CONST	SEGMENT
??_C@_0BF@JCMHACMD@UniqueLuxuryQuantity?$AA@ DB 'UniqueLuxuryQuantity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BNFGGMNB@UniqueLuxuryCities?$AA@
CONST	SEGMENT
??_C@_0BD@BNFGGMNB@UniqueLuxuryCities?$AA@ DB 'UniqueLuxuryCities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OPNOFJAB@TradeRouteResourceModifier?$AA@
CONST	SEGMENT
??_C@_0BL@OPNOFJAB@TradeRouteResourceModifier?$AA@ DB 'TradeRouteResource'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OHBFFHBN@NumTradeRoutesModifier?$AA@
CONST	SEGMENT
??_C@_0BH@OHBFFHBN@NumTradeRoutesModifier?$AA@ DB 'NumTradeRoutesModifier'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NNFMBHPN@FreeSocialPoliciesPerEra?$AA@
CONST	SEGMENT
??_C@_0BJ@NNFMBHPN@FreeSocialPoliciesPerEra?$AA@ DB 'FreeSocialPoliciesPe'
	DB	'rEra', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BMKGAGFH@ExtraFoundedCityTerritoryClaimRa@
CONST	SEGMENT
??_C@_0CE@BMKGAGFH@ExtraFoundedCityTerritoryClaimRa@ DB 'ExtraFoundedCity'
	DB	'TerritoryClaimRange', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DEELJCPA@UnresearchedTechBonusFromKills?$AA@
CONST	SEGMENT
??_C@_0BP@DEELJCPA@UnresearchedTechBonusFromKills?$AA@ DB 'UnresearchedTe'
	DB	'chBonusFromKills', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OCPLAGIK@HappinessPerReligion?$AA@
CONST	SEGMENT
??_C@_0BF@OCPLAGIK@HappinessPerReligion?$AA@ DB 'HappinessPerReligion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MHOKHMFG@ExtraSpies?$AA@
CONST	SEGMENT
??_C@_0L@MHOKHMFG@ExtraSpies?$AA@ DB 'ExtraSpies', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@
CONST	SEGMENT
??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@ DB 'ExtraHappinessPerLuxu'
	DB	'ry', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FBADGCLK@LuxuryHappinessRetention?$AA@
CONST	SEGMENT
??_C@_0BJ@FBADGCLK@LuxuryHappinessRetention?$AA@ DB 'LuxuryHappinessReten'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MOOGPKPG@DOFGreatPersonModifier?$AA@
CONST	SEGMENT
??_C@_0BH@MOOGPKPG@DOFGreatPersonModifier?$AA@ DB 'DOFGreatPersonModifier'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HKIMEGAL@RazeSpeedModifier?$AA@
CONST	SEGMENT
??_C@_0BC@HKIMEGAL@RazeSpeedModifier?$AA@ DB 'RazeSpeedModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FAJBHPKK@NavalUnitMaintenanceModifier?$AA@
CONST	SEGMENT
??_C@_0BN@FAJBHPKK@NavalUnitMaintenanceModifier?$AA@ DB 'NavalUnitMainten'
	DB	'anceModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IDILIMFG@LandUnitMaintenanceModifier?$AA@
CONST	SEGMENT
??_C@_0BM@IDILIMFG@LandUnitMaintenanceModifier?$AA@ DB 'LandUnitMaintenan'
	DB	'ceModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HPFMENFC@CombatBonusVsLargerCiv?$AA@
CONST	SEGMENT
??_C@_0BH@HPFMENFC@CombatBonusVsLargerCiv?$AA@ DB 'CombatBonusVsLargerCiv'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DGLMDOGP@CombatBonusVsHigherTech?$AA@
CONST	SEGMENT
??_C@_0BI@DGLMDOGP@CombatBonusVsHigherTech?$AA@ DB 'CombatBonusVsHigherTe'
	DB	'ch', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DJIJFOPM@CultureBuildingYieldChange?$AA@
CONST	SEGMENT
??_C@_0BL@DJIJFOPM@CultureBuildingYieldChange?$AA@ DB 'CultureBuildingYie'
	DB	'ldChange', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IFKLCMB@NearbyImprovementBonusRange?$AA@
CONST	SEGMENT
??_C@_0BM@IFKLCMB@NearbyImprovementBonusRange?$AA@ DB 'NearbyImprovementB'
	DB	'onusRange', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BPMPNCFH@NearbyImprovementCombatBonus?$AA@
CONST	SEGMENT
??_C@_0BN@BPMPNCFH@NearbyImprovementCombatBonus?$AA@ DB 'NearbyImprovemen'
	DB	'tCombatBonus', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NGJNFACF@NaturalWonderHappinessModifier?$AA@
CONST	SEGMENT
??_C@_0BP@NGJNFACF@NaturalWonderHappinessModifier?$AA@ DB 'NaturalWonderH'
	DB	'appinessModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NAOBBDJO@NaturalWonderYieldModifier?$AA@
CONST	SEGMENT
??_C@_0BL@NAOBBDJO@NaturalWonderYieldModifier?$AA@ DB 'NaturalWonderYield'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EBAKNJFP@NaturalWonderSubsequentFinderFai@
CONST	SEGMENT
??_C@_0CD@EBAKNJFP@NaturalWonderSubsequentFinderFai@ DB 'NaturalWonderSub'
	DB	'sequentFinderFaith', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EBGIMHIP@NaturalWonderFirstFinderFaith?$AA@
CONST	SEGMENT
??_C@_0BO@EBGIMHIP@NaturalWonderFirstFinderFaith?$AA@ DB 'NaturalWonderFi'
	DB	'rstFinderFaith', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NMHMFIPI@NaturalWonderSubsequentFinderGol@
CONST	SEGMENT
??_C@_0CC@NMHMFIPI@NaturalWonderSubsequentFinderGol@ DB 'NaturalWonderSub'
	DB	'sequentFinderGold', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LOGCIIPI@NaturalWonderFirstFinderGold?$AA@
CONST	SEGMENT
??_C@_0BN@LOGCIIPI@NaturalWonderFirstFinderGold?$AA@ DB 'NaturalWonderFir'
	DB	'stFinderGold', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BHJJBIH@ExtraEmbarkMoves?$AA@
CONST	SEGMENT
??_C@_0BB@BHJJBIH@ExtraEmbarkMoves?$AA@ DB 'ExtraEmbarkMoves', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KEODKJBJ@GoldenAgeGreatWriterRateModifier@
CONST	SEGMENT
??_C@_0CB@KEODKJBJ@GoldenAgeGreatWriterRateModifier@ DB 'GoldenAgeGreatWr'
	DB	'iterRateModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MENCBKJL@GoldenAgeGreatMusicianRateModifi@
CONST	SEGMENT
??_C@_0CD@MENCBKJL@GoldenAgeGreatMusicianRateModifi@ DB 'GoldenAgeGreatMu'
	DB	'sicianRateModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FOKFNPKD@GoldenAgeGreatArtistRateModifier@
CONST	SEGMENT
??_C@_0CB@FOKFNPKD@GoldenAgeGreatArtistRateModifier@ DB 'GoldenAgeGreatAr'
	DB	'tistRateModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LPJPLOKH@GoldenAgeTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@LPJPLOKH@GoldenAgeTourismModifier?$AA@ DB 'GoldenAgeTourismModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFCFAJNI@GoldenAgeCombatModifier?$AA@
CONST	SEGMENT
??_C@_0BI@MFCFAJNI@GoldenAgeCombatModifier?$AA@ DB 'GoldenAgeCombatModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JJLHBCMM@GoldenAgeMoveChange?$AA@
CONST	SEGMENT
??_C@_0BE@JJLHBCMM@GoldenAgeMoveChange?$AA@ DB 'GoldenAgeMoveChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IIBCIDDC@GoldenAgeDurationModifier?$AA@
CONST	SEGMENT
??_C@_0BK@IIBCIDDC@GoldenAgeDurationModifier?$AA@ DB 'GoldenAgeDurationMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HHMKJBJK@ImprovementMaintenanceModifier?$AA@
CONST	SEGMENT
??_C@_0BP@HHMKJBJK@ImprovementMaintenanceModifier?$AA@ DB 'ImprovementMai'
	DB	'ntenanceModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MLDJOLFP@PlunderModifier?$AA@
CONST	SEGMENT
??_C@_0BA@MLDJOLFP@PlunderModifier?$AA@ DB 'PlunderModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@ DB 'WonderProductionModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CGFEGMEN@CityConnectionTradeRouteChange?$AA@
CONST	SEGMENT
??_C@_0BP@CGFEGMEN@CityConnectionTradeRouteChange?$AA@ DB 'CityConnection'
	DB	'TradeRouteChange', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@
CONST	SEGMENT
??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@ DB 'PolicyCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NFLFOOON@CapitalThemingBonusModifier?$AA@
CONST	SEGMENT
??_C@_0BM@NFLFOOON@CapitalThemingBonusModifier?$AA@ DB 'CapitalThemingBon'
	DB	'usModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FEMBFCEN@CityCultureBonus?$AA@
CONST	SEGMENT
??_C@_0BB@FEMBFCEN@CityCultureBonus?$AA@ DB 'CityCultureBonus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@POALJMFH@FaithFromKills?$AA@
CONST	SEGMENT
??_C@_0P@POALJMFH@FaithFromKills?$AA@ DB 'FaithFromKills', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@
CONST	SEGMENT
??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@ DB 'CultureFromKills', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JGNHBIFC@GoldenAgeTileBonusFaith?$AA@
CONST	SEGMENT
??_C@_0BI@JGNHBIFC@GoldenAgeTileBonusFaith?$AA@ DB 'GoldenAgeTileBonusFai'
	DB	'th', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DEMNCJFF@NumTurnsBeforeMinorAlliesRefuseB@
CONST	SEGMENT
??_C@_0CG@DEMNCJFF@NumTurnsBeforeMinorAlliesRefuseB@ DB 'NumTurnsBeforeMi'
	DB	'norAlliesRefuseBribes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@
CONST	SEGMENT
??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@ DB 'SciencePerGreatPerso'
	DB	'nBorn', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@
CONST	SEGMENT
??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@ DB 'PlotCultureCostModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@
CONST	SEGMENT
??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@ DB 'PlotBuyCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MLKAEAMP@CapitalBuildingModifier?$AA@
CONST	SEGMENT
??_C@_0BI@MLKAEAMP@CapitalBuildingModifier?$AA@ DB 'CapitalBuildingModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OOIEDACI@SeaBarbarianConversionPercent?$AA@
CONST	SEGMENT
??_C@_0BO@OOIEDACI@SeaBarbarianConversionPercent?$AA@ DB 'SeaBarbarianCon'
	DB	'versionPercent', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GPFEONPB@LandBarbarianConversionExtraUnit@
CONST	SEGMENT
??_C@_0CC@GPFEONPB@LandBarbarianConversionExtraUnit@ DB 'LandBarbarianCon'
	DB	'versionExtraUnits', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CBHCFKJC@LandBarbarianConversionPercent?$AA@
CONST	SEGMENT
??_C@_0BP@CBHCFKJC@LandBarbarianConversionPercent?$AA@ DB 'LandBarbarianC'
	DB	'onversionPercent', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LLKLCJEP@CityStateCombatModifier?$AA@
CONST	SEGMENT
??_C@_0BI@LLKLCJEP@CityStateCombatModifier?$AA@ DB 'CityStateCombatModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CJCOCPNL@CityStateFriendshipModifier?$AA@
CONST	SEGMENT
??_C@_0BM@CJCOCPNL@CityStateFriendshipModifier?$AA@ DB 'CityStateFriendsh'
	DB	'ipModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@
CONST	SEGMENT
??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@ DB 'CityStateBonusModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DHGOHAIB@PopulationUnhappinessModifier?$AA@
CONST	SEGMENT
??_C@_0BO@DHGOHAIB@PopulationUnhappinessModifier?$AA@ DB 'PopulationUnhap'
	DB	'pinessModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@COFBHJFM@CityUnhappinessModifier?$AA@
CONST	SEGMENT
??_C@_0BI@COFBHJFM@CityUnhappinessModifier?$AA@ DB 'CityUnhappinessModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NPEABLDP@MaxPlayerBuildingProductionModif@
CONST	SEGMENT
??_C@_0CE@NPEABLDP@MaxPlayerBuildingProductionModif@ DB 'MaxPlayerBuildin'
	DB	'gProductionModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LNEKPAPM@MaxTeamBuildingProductionModifie@
CONST	SEGMENT
??_C@_0CC@LNEKPAPM@MaxTeamBuildingProductionModifie@ DB 'MaxTeamBuildingP'
	DB	'roductionModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JPCAIMIG@MaxGlobalBuildingProductionModif@
CONST	SEGMENT
??_C@_0CE@JPCAIMIG@MaxGlobalBuildingProductionModif@ DB 'MaxGlobalBuildin'
	DB	'gProductionModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IGFDIHCA@GreatPersonGiftInfluence?$AA@
CONST	SEGMENT
??_C@_0BJ@IGFDIHCA@GreatPersonGiftInfluence?$AA@ DB 'GreatPersonGiftInflu'
	DB	'ence', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LHGCIMPK@GreatGeneralExtraBonus?$AA@
CONST	SEGMENT
??_C@_0BH@LHGCIMPK@GreatGeneralExtraBonus?$AA@ DB 'GreatGeneralExtraBonus'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@ DB 'GreatGeneralRateModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@
CONST	SEGMENT
??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@ DB 'GreatScientistRate'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@
CONST	SEGMENT
??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@ DB 'GreatPeopleRateModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IJFKMPJF@LevelExperienceModifier?$AA@
CONST	SEGMENT
??_C@_0BI@IJFKMPJF@LevelExperienceModifier?$AA@ DB 'LevelExperienceModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GBLDMPKE@ShortDescription?$AA@
CONST	SEGMENT
??_C@_0BB@GBLDMPKE@ShortDescription?$AA@ DB 'ShortDescription', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv1860 = -1228						; size = 4
tv1810 = -1224						; size = 4
tv1600 = -1220						; size = 4
tv1565 = -1216						; size = 4
tv1231 = -1212						; size = 4
_this$ = -1208						; size = 4
$T230512 = -1148					; size = 4
$T230496 = -1144					; size = 4
$T230489 = -1140					; size = 4
$T230405 = -1092					; size = 4
$T230404 = -928						; size = 8
$T230403 = -920						; size = 8
$T230402 = -912						; size = 8
$T230150 = -904						; size = 4
$T230134 = -900						; size = 4
$T230127 = -896						; size = 4
$T230044 = -848						; size = 4
$T230042 = -700						; size = 8
$T230041 = -692						; size = 8
$T230040 = -684						; size = 8
$T229568 = -548						; size = 8
$T229542 = -532						; size = 8
$T229541 = -524						; size = 8
$T229540 = -516						; size = 12
$T229539 = -504						; size = 4
$T229538 = -500						; size = 8
$T229537 = -492						; size = 8
_temp$222356 = -484					; size = 8
_iResource$222357 = -476				; size = 4
_temp$222347 = -472					; size = 8
_iResourceLoop$222343 = -464				; size = 4
_pResults$222350 = -460					; size = 4
_strKey$222348 = -456					; size = 28
_iImprovementID$222341 = -428				; size = 4
_iImprovementLoop$222329 = -424				; size = 4
_pResults$222335 = -420					; size = 4
_strKey$222333 = -416					; size = 28
_iUnitClass$222326 = -384				; size = 4
_iUnitClassLoop$222314 = -380				; size = 4
_pResults$222320 = -376					; size = 4
_strKey$222318 = -372					; size = 28
_FeatureID$222311 = -344				; size = 4
_yield$222313 = -340					; size = 4
_YieldID$222312 = -336					; size = 4
_pResults$222305 = -332					; size = 4
_strKey$222303 = -328					; size = 28
_yield$222301 = -300					; size = 4
_SpecialistID$222299 = -296				; size = 4
_YieldID$222300 = -292					; size = 4
_pResults$222293 = -288					; size = 4
_strKey$222291 = -284					; size = 28
_yield$222289 = -256					; size = 4
_ImprovementID$222287 = -252				; size = 4
_YieldID$222288 = -248					; size = 4
_pResults$222281 = -244					; size = 4
_strKey$222279 = -240					; size = 28
_iMaintenanceModifier$222276 = -212			; size = 4
_iUnitCombatID$222275 = -208				; size = 4
_szSQL$222270 = -204					; size = 4
_pResults$222268 = -200					; size = 4
_iNumUnitCombatClasses$222265 = -196			; size = 4
_sqlKey$222266 = -192					; size = 28
_iMovesChange$222264 = -164				; size = 4
_iUnitCombatID$222263 = -160				; size = 4
_szSQL$222258 = -156					; size = 4
_pResults$222256 = -152					; size = 4
_iNumUnitCombatClasses$222252 = -148			; size = 4
_sqlKey$222254 = -144					; size = 28
_unitPromotionID$222172 = -116				; size = 4
_unitCombatInfoID$222173 = -112				; size = 4
_szSQL$222167 = -108					; size = 4
_pResults$222165 = -104					; size = 4
_sqlKey$222163 = -100					; size = 28
_iTerrainID$222159 = -72				; size = 4
_iStrategicResourceQuantityModifier$222161 = -68	; size = 4
_szSQL$222154 = -64					; size = 4
_pResults$222152 = -60					; size = 4
_sqlKey$222150 = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_iNumTerrains$ = -24					; size = 4
_szTextVal$ = -20					; size = 4
_szTraitType$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvTraitEntry::CacheResults, COMDAT
; _this$ = ecx

; 1094 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1216				; 000004c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1095 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN50@CacheResul

; 1096 : 		return false;

	xor	al, al
	jmp	$LN51@CacheResul
$LN50@CacheResul:

; 1097 : 
; 1098 : 	//Basic Properties
; 1099 : 	setShortDescription(kResults.GetText("ShortDescription"));

	push	OFFSET ??_C@_0BB@GBLDMPKE@ShortDescription?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setShortDescription@CvTraitEntry@@QAEXPBD@Z ; CvTraitEntry::setShortDescription

; 1100 : 
; 1101 : 	m_iLevelExperienceModifier				= kResults.GetInt("LevelExperienceModifier");

	push	OFFSET ??_C@_0BI@IJFKMPJF@LevelExperienceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], eax

; 1102 : 	m_iGreatPeopleRateModifier				= kResults.GetInt("GreatPeopleRateModifier");

	push	OFFSET ??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], eax

; 1103 : 	m_iGreatScientistRateModifier			= kResults.GetInt("GreatScientistRateModifier");

	push	OFFSET ??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 1104 : 	m_iGreatGeneralRateModifier				= kResults.GetInt("GreatGeneralRateModifier");

	push	OFFSET ??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 1105 : 	m_iGreatGeneralExtraBonus				= kResults.GetInt("GreatGeneralExtraBonus");

	push	OFFSET ??_C@_0BH@LHGCIMPK@GreatGeneralExtraBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 1106 : 	m_iGreatPersonGiftInfluence				= kResults.GetInt("GreatPersonGiftInfluence");

	push	OFFSET ??_C@_0BJ@IGFDIHCA@GreatPersonGiftInfluence?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+280], eax

; 1107 : 	m_iMaxGlobalBuildingProductionModifier	= kResults.GetInt("MaxGlobalBuildingProductionModifier");

	push	OFFSET ??_C@_0CE@JPCAIMIG@MaxGlobalBuildingProductionModif@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], eax

; 1108 : 	m_iMaxTeamBuildingProductionModifier	= kResults.GetInt("MaxTeamBuildingProductionModifier");

	push	OFFSET ??_C@_0CC@LNEKPAPM@MaxTeamBuildingProductionModifie@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], eax

; 1109 : 	m_iMaxPlayerBuildingProductionModifier	= kResults.GetInt("MaxPlayerBuildingProductionModifier");

	push	OFFSET ??_C@_0CE@NPEABLDP@MaxPlayerBuildingProductionModif@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], eax

; 1110 : 	m_iCityUnhappinessModifier           	= kResults.GetInt("CityUnhappinessModifier");

	push	OFFSET ??_C@_0BI@COFBHJFM@CityUnhappinessModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+296], eax

; 1111 : 	m_iPopulationUnhappinessModifier    	= kResults.GetInt("PopulationUnhappinessModifier");

	push	OFFSET ??_C@_0BO@DHGOHAIB@PopulationUnhappinessModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 1112 : 	m_iCityStateBonusModifier               = kResults.GetInt("CityStateBonusModifier");

	push	OFFSET ??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], eax

; 1113 : 	m_iCityStateFriendshipModifier          = kResults.GetInt("CityStateFriendshipModifier");

	push	OFFSET ??_C@_0BM@CJCOCPNL@CityStateFriendshipModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], eax

; 1114 : 	m_iCityStateCombatModifier				= kResults.GetInt("CityStateCombatModifier");

	push	OFFSET ??_C@_0BI@LLKLCJEP@CityStateCombatModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], eax

; 1115 : 	m_iLandBarbarianConversionPercent       = kResults.GetInt("LandBarbarianConversionPercent");

	push	OFFSET ??_C@_0BP@CBHCFKJC@LandBarbarianConversionPercent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 1116 : 	m_iLandBarbarianConversionExtraUnits    = kResults.GetInt("LandBarbarianConversionExtraUnits");

	push	OFFSET ??_C@_0CC@GPFEONPB@LandBarbarianConversionExtraUnit@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+320], eax

; 1117 : 	m_iSeaBarbarianConversionPercent        = kResults.GetInt("SeaBarbarianConversionPercent");

	push	OFFSET ??_C@_0BO@OOIEDACI@SeaBarbarianConversionPercent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], eax

; 1118 : 	m_iCapitalBuildingModifier				= kResults.GetInt("CapitalBuildingModifier");

	push	OFFSET ??_C@_0BI@MLKAEAMP@CapitalBuildingModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], eax

; 1119 : 	m_iPlotBuyCostModifier					= kResults.GetInt("PlotBuyCostModifier");

	push	OFFSET ??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], eax

; 1120 : 	m_iPlotCultureCostModifier              = kResults.GetInt("PlotCultureCostModifier");

	push	OFFSET ??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+336], eax

; 1121 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 1122 : 	m_iSciencePerGreatPersonBorn			= kResults.GetInt("SciencePerGreatPersonBorn");

	push	OFFSET ??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+340], eax

; 1123 : #endif
; 1124 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 1125 : 	m_iNumTurnsBeforeMinorAlliesRefuseBribes = kResults.GetInt("NumTurnsBeforeMinorAlliesRefuseBribes");

	push	OFFSET ??_C@_0CG@DEMNCJFF@NumTurnsBeforeMinorAlliesRefuseB@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], eax

; 1126 : #endif
; 1127 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 1128 : 	m_iGoldenAgeTileBonusFaith              = kResults.GetInt("GoldenAgeTileBonusFaith");

	push	OFFSET ??_C@_0BI@JGNHBIFC@GoldenAgeTileBonusFaith?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+348], eax

; 1129 : #endif
; 1130 : 	m_iCultureFromKills						= kResults.GetInt("CultureFromKills");

	push	OFFSET ??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+352], eax

; 1131 : 	m_iFaithFromKills						= kResults.GetInt("FaithFromKills");

	push	OFFSET ??_C@_0P@POALJMFH@FaithFromKills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+356], eax

; 1132 : 	m_iCityCultureBonus						= kResults.GetInt("CityCultureBonus");

	push	OFFSET ??_C@_0BB@FEMBFCEN@CityCultureBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], eax

; 1133 : 	m_iCapitalThemingBonusModifier          = kResults.GetInt("CapitalThemingBonusModifier");

	push	OFFSET ??_C@_0BM@NFLFOOON@CapitalThemingBonusModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+364], eax

; 1134 : 	m_iPolicyCostModifier					= kResults.GetInt("PolicyCostModifier");

	push	OFFSET ??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+368], eax

; 1135 : 	m_iCityConnectionTradeRouteChange		= kResults.GetInt("CityConnectionTradeRouteChange");

	push	OFFSET ??_C@_0BP@CGFEGMEN@CityConnectionTradeRouteChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 1136 : 	m_iWonderProductionModifier				= kResults.GetInt("WonderProductionModifier");

	push	OFFSET ??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+376], eax

; 1137 : 	m_iPlunderModifier						= kResults.GetInt("PlunderModifier");

	push	OFFSET ??_C@_0BA@MLDJOLFP@PlunderModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+380], eax

; 1138 : 	m_iImprovementMaintenanceModifier       = kResults.GetInt("ImprovementMaintenanceModifier");

	push	OFFSET ??_C@_0BP@HHMKJBJK@ImprovementMaintenanceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], eax

; 1139 : 	m_iGoldenAgeDurationModifier			= kResults.GetInt("GoldenAgeDurationModifier");

	push	OFFSET ??_C@_0BK@IIBCIDDC@GoldenAgeDurationModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+388], eax

; 1140 : 	m_iGoldenAgeMoveChange				    = kResults.GetInt("GoldenAgeMoveChange");

	push	OFFSET ??_C@_0BE@JJLHBCMM@GoldenAgeMoveChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+392], eax

; 1141 : 	m_iGoldenAgeCombatModifier				= kResults.GetInt("GoldenAgeCombatModifier");

	push	OFFSET ??_C@_0BI@MFCFAJNI@GoldenAgeCombatModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+396], eax

; 1142 : 	m_iGoldenAgeTourismModifier				= kResults.GetInt("GoldenAgeTourismModifier");

	push	OFFSET ??_C@_0BJ@LPJPLOKH@GoldenAgeTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+400], eax

; 1143 : 	m_iGoldenAgeGreatArtistRateModifier		= kResults.GetInt("GoldenAgeGreatArtistRateModifier");

	push	OFFSET ??_C@_0CB@FOKFNPKD@GoldenAgeGreatArtistRateModifier@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+404], eax

; 1144 : 	m_iGoldenAgeGreatMusicianRateModifier	= kResults.GetInt("GoldenAgeGreatMusicianRateModifier");

	push	OFFSET ??_C@_0CD@MENCBKJL@GoldenAgeGreatMusicianRateModifi@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+408], eax

; 1145 : 	m_iGoldenAgeGreatWriterRateModifier		= kResults.GetInt("GoldenAgeGreatWriterRateModifier");

	push	OFFSET ??_C@_0CB@KEODKJBJ@GoldenAgeGreatWriterRateModifier@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+412], eax

; 1146 : 	m_iExtraEmbarkMoves						= kResults.GetInt("ExtraEmbarkMoves");

	push	OFFSET ??_C@_0BB@BHJJBIH@ExtraEmbarkMoves?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+424], eax

; 1147 : 	m_iNaturalWonderFirstFinderGold         = kResults.GetInt("NaturalWonderFirstFinderGold");

	push	OFFSET ??_C@_0BN@LOGCIIPI@NaturalWonderFirstFinderGold?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], eax

; 1148 : 	m_iNaturalWonderSubsequentFinderGold    = kResults.GetInt("NaturalWonderSubsequentFinderGold");

	push	OFFSET ??_C@_0CC@NMHMFIPI@NaturalWonderSubsequentFinderGol@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+436], eax

; 1149 : 
; 1150 : 	//EAP: Faith for the Natural wonder findor
; 1151 : 	m_iNaturalWonderFirstFinderFaith         = kResults.GetInt("NaturalWonderFirstFinderFaith");

	push	OFFSET ??_C@_0BO@EBGIMHIP@NaturalWonderFirstFinderFaith?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+440], eax

; 1152 : 	m_iNaturalWonderSubsequentFinderFaith    = kResults.GetInt("NaturalWonderSubsequentFinderFaith");

	push	OFFSET ??_C@_0CD@EBAKNJFP@NaturalWonderSubsequentFinderFai@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+444], eax

; 1153 : 
; 1154 : 	m_iNaturalWonderYieldModifier           = kResults.GetInt("NaturalWonderYieldModifier");

	push	OFFSET ??_C@_0BL@NAOBBDJO@NaturalWonderYieldModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+448], eax

; 1155 : 	m_iNaturalWonderHappinessModifier       = kResults.GetInt("NaturalWonderHappinessModifier");

	push	OFFSET ??_C@_0BP@NGJNFACF@NaturalWonderHappinessModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+452], eax

; 1156 : 	m_iNearbyImprovementCombatBonus			= kResults.GetInt("NearbyImprovementCombatBonus");

	push	OFFSET ??_C@_0BN@BPMPNCFH@NearbyImprovementCombatBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+456], eax

; 1157 : 	m_iNearbyImprovementBonusRange			= kResults.GetInt("NearbyImprovementBonusRange");

	push	OFFSET ??_C@_0BM@IFKLCMB@NearbyImprovementBonusRange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+460], eax

; 1158 : 	m_iCultureBuildingYieldChange			= kResults.GetInt("CultureBuildingYieldChange");

	push	OFFSET ??_C@_0BL@DJIJFOPM@CultureBuildingYieldChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], eax

; 1159 : 	m_iCombatBonusVsHigherTech				= kResults.GetInt("CombatBonusVsHigherTech");

	push	OFFSET ??_C@_0BI@DGLMDOGP@CombatBonusVsHigherTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], eax

; 1160 : 	m_iCombatBonusVsLargerCiv				= kResults.GetInt("CombatBonusVsLargerCiv");

	push	OFFSET ??_C@_0BH@HPFMENFC@CombatBonusVsLargerCiv?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+472], eax

; 1161 : 	m_iLandUnitMaintenanceModifier          = kResults.GetInt("LandUnitMaintenanceModifier");

	push	OFFSET ??_C@_0BM@IDILIMFG@LandUnitMaintenanceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+476], eax

; 1162 : 	m_iNavalUnitMaintenanceModifier         = kResults.GetInt("NavalUnitMaintenanceModifier");

	push	OFFSET ??_C@_0BN@FAJBHPKK@NavalUnitMaintenanceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], eax

; 1163 : 	m_iRazeSpeedModifier					= kResults.GetInt("RazeSpeedModifier");

	push	OFFSET ??_C@_0BC@HKIMEGAL@RazeSpeedModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+484], eax

; 1164 : 	m_iDOFGreatPersonModifier				= kResults.GetInt("DOFGreatPersonModifier");

	push	OFFSET ??_C@_0BH@MOOGPKPG@DOFGreatPersonModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], eax

; 1165 : 	m_iLuxuryHappinessRetention				= kResults.GetInt("LuxuryHappinessRetention");

	push	OFFSET ??_C@_0BJ@FBADGCLK@LuxuryHappinessRetention?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], eax

; 1166 : 	m_iExtraHappinessPerLuxury				= kResults.GetInt("ExtraHappinessPerLuxury"); // NQMP GJS - New Netherlands UA

	push	OFFSET ??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+496], eax

; 1167 : 	m_iExtraSpies							= kResults.GetInt("ExtraSpies");

	push	OFFSET ??_C@_0L@MHOKHMFG@ExtraSpies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+500], eax

; 1168 : 	m_iHappinessPerReligion					= kResults.GetInt("HappinessPerReligion"); // NQMP GJS - New Ottoman UA

	push	OFFSET ??_C@_0BF@OCPLAGIK@HappinessPerReligion?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+504], eax

; 1169 : 	m_iUnresearchedTechBonusFromKills		= kResults.GetInt("UnresearchedTechBonusFromKills");

	push	OFFSET ??_C@_0BP@DEELJCPA@UnresearchedTechBonusFromKills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+508], eax

; 1170 : 	m_iExtraFoundedCityTerritoryClaimRange  = kResults.GetInt("ExtraFoundedCityTerritoryClaimRange");

	push	OFFSET ??_C@_0CE@BMKGAGFH@ExtraFoundedCityTerritoryClaimRa@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+512], eax

; 1171 : 	m_iFreeSocialPoliciesPerEra				= kResults.GetInt("FreeSocialPoliciesPerEra");

	push	OFFSET ??_C@_0BJ@NNFMBHPN@FreeSocialPoliciesPerEra?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+516], eax

; 1172 : 	m_iNumTradeRoutesModifier				= kResults.GetInt("NumTradeRoutesModifier");

	push	OFFSET ??_C@_0BH@OHBFFHBN@NumTradeRoutesModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+520], eax

; 1173 : 	m_iTradeRouteResourceModifier			= kResults.GetInt("TradeRouteResourceModifier");

	push	OFFSET ??_C@_0BL@OPNOFJAB@TradeRouteResourceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+524], eax

; 1174 : 	m_iUniqueLuxuryCities					= kResults.GetInt("UniqueLuxuryCities");

	push	OFFSET ??_C@_0BD@BNFGGMNB@UniqueLuxuryCities?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+528], eax

; 1175 : 	m_iUniqueLuxuryQuantity					= kResults.GetInt("UniqueLuxuryQuantity");

	push	OFFSET ??_C@_0BF@JCMHACMD@UniqueLuxuryQuantity?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+532], eax

; 1176 : 	m_iWorkerSpeedModifier					= kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+536], eax

; 1177 : 	m_iAfraidMinorPerTurnInfluence			= kResults.GetInt("AfraidMinorPerTurnInfluence");

	push	OFFSET ??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+540], eax

; 1178 : 	m_iLandTradeRouteRangeBonus				= kResults.GetInt("LandTradeRouteRangeBonus");

	push	OFFSET ??_C@_0BJ@IPEHHBM@LandTradeRouteRangeBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+544], eax

; 1179 : 	m_iTradeReligionModifier				= kResults.GetInt("TradeReligionModifier");

	push	OFFSET ??_C@_0BG@CICGAOPI@TradeReligionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+548], eax

; 1180 : 	m_iTradeBuildingModifier				= kResults.GetInt("TradeBuildingModifier");

	push	OFFSET ??_C@_0BG@OOCFOBDJ@TradeBuildingModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+552], eax

; 1181 : 
; 1182 : 	const char* szTextVal = NULL;

	mov	DWORD PTR _szTextVal$[ebp], 0

; 1183 : 	szTextVal = kResults.GetText("FreeUnit");

	push	OFFSET ??_C@_08PMODHGEM@FreeUnit?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1184 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN49@CacheResul

; 1185 : 	{
; 1186 : 		m_iFreeUnitClassType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+428], eax
$LN49@CacheResul:

; 1187 : 	}
; 1188 : 
; 1189 : 	szTextVal = kResults.GetText("FreeUnitPrereqTech");

	push	OFFSET ??_C@_0BD@OEBDLCBD@FreeUnitPrereqTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1190 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN48@CacheResul

; 1191 : 	{
; 1192 : 		m_eFreeUnitPrereqTech = (TechTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+556], eax
$LN48@CacheResul:

; 1193 : 	}
; 1194 : 
; 1195 : 	//// CMP DLL THING
; 1196 : 
; 1197 : 	szTextVal = kResults.GetText("FreeBuildingPrereqTech");

	push	OFFSET ??_C@_0BH@NNAIEBBN@FreeBuildingPrereqTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1198 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN47@CacheResul

; 1199 : 	{
; 1200 : 		m_eFreeBuildingPrereqTech = (TechTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+572], eax
$LN47@CacheResul:

; 1201 : 	}
; 1202 : 	szTextVal = kResults.GetText("CapitalFreeBuildingPrereqTech");

	push	OFFSET ??_C@_0BO@MEABIPHA@CapitalFreeBuildingPrereqTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1203 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN46@CacheResul

; 1204 : 	{
; 1205 : 		m_eCapitalFreeBuildingPrereqTech = (TechTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+576], eax
$LN46@CacheResul:

; 1206 : 	}
; 1207 : 
; 1208 : 	///
; 1209 : 
; 1210 : 
; 1211 : 	szTextVal = kResults.GetText("CombatBonusImprovement");

	push	OFFSET ??_C@_0BH@GMFFPLCG@CombatBonusImprovement?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1212 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN45@CacheResul

; 1213 : 	{
; 1214 : 		m_eCombatBonusImprovement = (ImprovementTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+560], eax
$LN45@CacheResul:

; 1215 : 	}
; 1216 : 
; 1217 : 	szTextVal = kResults.GetText("ObsoleteTech");

	push	OFFSET ??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1218 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN44@CacheResul

; 1219 : 	{
; 1220 : 		m_iObsoleteTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], eax
$LN44@CacheResul:

; 1221 : 	}
; 1222 : 
; 1223 : 	szTextVal = kResults.GetText("PrereqTech");

	push	OFFSET ??_C@_0L@NJNFNDFO@PrereqTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1224 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN43@CacheResul

; 1225 : 	{
; 1226 : 		m_iPrereqTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+420], eax
$LN43@CacheResul:

; 1227 : 	}
; 1228 : 
; 1229 : 	szTextVal = kResults.GetText("FreeBuilding");

	push	OFFSET ??_C@_0N@EHKBNAC@FreeBuilding?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1230 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN42@CacheResul

; 1231 : 	{
; 1232 : 		m_eFreeBuilding = (BuildingTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+564], eax
$LN42@CacheResul:

; 1233 : 	}
; 1234 : 
; 1235 : 	szTextVal = kResults.GetText("FreeCapitalBuilding");

	push	OFFSET ??_C@_0BE@BMODEEBC@FreeCapitalBuilding?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1236 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN41@CacheResul

; 1237 : 	{
; 1238 : 		m_eFreeCapitalBuilding = (BuildingTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+568], eax
$LN41@CacheResul:

; 1239 : 	}
; 1240 : 
; 1241 : 	szTextVal = kResults.GetText("FreeBuildingOnConquest");

	push	OFFSET ??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 1242 : 	if(szTextVal)

	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN40@CacheResul

; 1243 : 	{
; 1244 : 		m_eFreeBuildingOnConquest = (BuildingTypes)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+580], eax
$LN40@CacheResul:

; 1245 : 	}
; 1246 : 
; 1247 : 	m_bFightWellDamaged = kResults.GetBool("FightWellDamaged");

	push	OFFSET ??_C@_0BB@FFBACMEJ@FightWellDamaged?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+584], al

; 1248 : 	m_bMoveFriendlyWoodsAsRoad = kResults.GetBool("MoveFriendlyWoodsAsRoad");

	push	OFFSET ??_C@_0BI@KHHPPHAJ@MoveFriendlyWoodsAsRoad?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+585], al

; 1249 : 	m_bFasterAlongRiver = kResults.GetBool("FasterAlongRiver");

	push	OFFSET ??_C@_0BB@HIJGMHHM@FasterAlongRiver?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+586], al

; 1250 : 	m_bFasterInHills = kResults.GetBool("FasterInHills");

	push	OFFSET ??_C@_0O@BOLDEMDP@FasterInHills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+587], al

; 1251 : 	m_bEmbarkedAllWater = kResults.GetBool("EmbarkedAllWater");

	push	OFFSET ??_C@_0BB@COFEIKJH@EmbarkedAllWater?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+588], al

; 1252 : 	m_bEmbarkedToLandFlatCost = kResults.GetBool("EmbarkedToLandFlatCost");

	push	OFFSET ??_C@_0BH@HEPMOODJ@EmbarkedToLandFlatCost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+589], al

; 1253 : 	m_bNoHillsImprovementMaintenance = kResults.GetBool("NoHillsImprovementMaintenance");

	push	OFFSET ??_C@_0BO@BADJGMNH@NoHillsImprovementMaintenance?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+590], al

; 1254 : 	m_bTechBoostFromCapitalScienceBuildings = kResults.GetBool("TechBoostFromCapitalScienceBuildings");

	push	OFFSET ??_C@_0CF@EHDKIJNN@TechBoostFromCapitalScienceBuild@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+591], al

; 1255 : 	m_bStaysAliveZeroCities = kResults.GetBool("StaysAliveZeroCities");

	push	OFFSET ??_C@_0BF@GOHJOIEH@StaysAliveZeroCities?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+592], al

; 1256 : 	m_bFaithFromUnimprovedForest = kResults.GetBool("FaithFromUnimprovedForest");

	push	OFFSET ??_C@_0BK@KEEAFDIB@FaithFromUnimprovedForest?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+593], al

; 1257 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 1258 : 	m_bSeaTradeRoutesArePlunderImmune = kResults.GetBool("SeaTradeRoutesArePlunderImmune");

	push	OFFSET ??_C@_0BP@OLGOEANA@SeaTradeRoutesArePlunderImmune?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+594], al

; 1259 : #endif
; 1260 : 	m_bEarnsGreatPersonOnSlotOrGuild = kResults.GetBool("EarnsGreatPersonOnSlotOrGuild"); // NQMP GJS - New France UA

	push	OFFSET ??_C@_0BO@JDKBCLKK@EarnsGreatPersonOnSlotOrGuild?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+595], al

; 1261 : 	m_bBonusReligiousBelief = kResults.GetBool("BonusReligiousBelief");

	push	OFFSET ??_C@_0BF@CKKILNFD@BonusReligiousBelief?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+599], al

; 1262 : 	m_bAbleToAnnexCityStates = kResults.GetBool("AbleToAnnexCityStates");

	push	OFFSET ??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+600], al

; 1263 : 	m_bCrossesMountainsAfterGreatGeneral = kResults.GetBool("CrossesMountainsAfterGreatGeneral");

	push	OFFSET ??_C@_0CC@FJPEFFBL@CrossesMountainsAfterGreatGenera@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+601], al

; 1264 : 	m_bMayaCalendarBonuses = kResults.GetBool("MayaCalendarBonuses");

	push	OFFSET ??_C@_0BE@KEFCGJDL@MayaCalendarBonuses?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+602], al

; 1265 : 	m_bNoAnnexing = kResults.GetBool("NoAnnexing");

	push	OFFSET ??_C@_0L@FIOLCHFG@NoAnnexing?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+603], al

; 1266 : 	m_bTechFromCityConquer = kResults.GetBool("TechFromCityConquer");

	push	OFFSET ??_C@_0BE@KHGGKHH@TechFromCityConquer?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+604], al

; 1267 : 	m_bUniqueLuxuryRequiresNewArea = kResults.GetBool("UniqueLuxuryRequiresNewArea");

	push	OFFSET ??_C@_0BM@IDFEDMKD@UniqueLuxuryRequiresNewArea?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+605], al

; 1268 : 	m_bRiverTradeRoad = kResults.GetBool("RiverTradeRoad");

	push	OFFSET ??_C@_0P@BMCPGFLA@RiverTradeRoad?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+606], al

; 1269 : 	m_bAngerFreeIntrusionOfCityStates = kResults.GetBool("AngerFreeIntrusionOfCityStates");

	push	OFFSET ??_C@_0BP@IHDNKOKH@AngerFreeIntrusionOfCityStates?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+607], al

; 1270 : 
; 1271 : 	//Arrays
; 1272 : 	const char* szTraitType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szTraitType$[ebp], eax

; 1273 : 	kUtility.SetYields(m_paiExtraYieldThreshold, "Trait_ExtraYieldThresholds", "TraitType", szTraitType);

	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0BL@FAHDJKGN@Trait_ExtraYieldThresholds?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 636				; 0000027cH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1274 : 
; 1275 : 	kUtility.SetYields(m_paiYieldChange, "Trait_YieldChanges", "TraitType", szTraitType);

	mov	edx, DWORD PTR _szTraitType$[ebp]
	push	edx
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0BD@HFICJHBM@Trait_YieldChanges?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 640				; 00000280H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1276 : 	kUtility.SetYields(m_paiYieldChangeStrategicResources, "Trait_YieldChangesStrategicResources", "TraitType", szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[ebp]
	push	ecx
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0CF@INKJLPBJ@Trait_YieldChangesStrategicResou@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 644				; 00000284H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1277 : 	kUtility.SetYields(m_paiYieldChangeLuxuryResources, "Trait_YieldChangesLuxuryResources", "TraitType", szTraitType); // NQMP GJS - New Netherlands UA

	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0CC@DNGEBFJO@Trait_YieldChangesLuxuryResource@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1278 : 	kUtility.SetYields(m_paiYieldChangeNaturalWonder, "Trait_YieldChangesNaturalWonder", "TraitType", szTraitType);

	mov	edx, DWORD PTR _szTraitType$[ebp]
	push	edx
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0CA@BIAKPHGH@Trait_YieldChangesNaturalWonder?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 652				; 0000028cH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1279 : 	kUtility.SetYields(m_paiYieldChangePerTradePartner, "Trait_YieldChangesPerTradePartner", "TraitType", szTraitType);

	mov	ecx, DWORD PTR _szTraitType$[ebp]
	push	ecx
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0CC@KLPGMKPB@Trait_YieldChangesPerTradePartne@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 656				; 00000290H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1280 : 	kUtility.SetYields(m_paiYieldChangeIncomingTradeRoute, "Trait_YieldChangesIncomingTradeRoute", "TraitType", szTraitType);

	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0CF@CONFBLMP@Trait_YieldChangesIncomingTradeR@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1281 : 	kUtility.SetYields(m_paiYieldModifier, "Trait_YieldModifiers", "TraitType", szTraitType);

	mov	edx, DWORD PTR _szTraitType$[ebp]
	push	edx
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0BF@FHEKODEE@Trait_YieldModifiers?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 664				; 00000298H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 1282 : 
; 1283 : 	const int iNumTerrains = GC.getNumTerrainInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	mov	DWORD PTR _iNumTerrains$[ebp], eax

; 1284 : 
; 1285 : 	//Trait_Terrains
; 1286 : 	{
; 1287 : 		kUtility.InitializeArray(m_piStrategicResourceQuantityModifier, iNumTerrains, 0);

	push	0
	mov	ecx, DWORD PTR _iNumTerrains$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 668				; 0000029cH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 1288 : 
; 1289 : 		std::string sqlKey = "Trait_Terrains";

	push	OFFSET ??_C@_0P@GJDNFKFB@Trait_Terrains?$AA@
	lea	ecx, DWORD PTR _sqlKey$222150[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1290 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	eax, DWORD PTR _sqlKey$222150[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222152[ebp], eax

; 1291 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222152[ebp], 0
	jne	SHORT $LN39@CacheResul

; 1292 : 		{
; 1293 : 			const char* szSQL = "select TraitType, Terrains.ID as TerrainID, StrategicResourceQuantityModifier from Trait_Terrains join Terrains on Terrains.Type = TerrainType where TraitType = ?";

	mov	DWORD PTR _szSQL$222154[ebp], OFFSET ??_C@_0KD@DPKDKHBJ@select?5TraitType?0?5Terrains?4ID?5as@

; 1294 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _szSQL$222154[ebp]
	push	ecx
	lea	edx, DWORD PTR _sqlKey$222150[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222152[ebp], eax
$LN39@CacheResul:

; 1295 : 		}
; 1296 : 
; 1297 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$222152[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN38@CacheResul:

; 1298 : 
; 1299 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222152[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN37@CacheResul

; 1300 : 		{
; 1301 : 			const int iTerrainID = pResults->GetInt("TerrainID");

	push	OFFSET ??_C@_09EINBFHAC@TerrainID?$AA@
	mov	ecx, DWORD PTR _pResults$222152[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR _iTerrainID$222159[ebp], eax

; 1302 : 			CvAssert(iTerrainID > -1 && iTerrainID < iNumTerrains);
; 1303 : 
; 1304 : 			const int iStrategicResourceQuantityModifier = pResults->GetInt("StrategicResourceQuantityModifier");

	push	OFFSET ??_C@_0CC@ODCDLGED@StrategicResourceQuantityModifie@
	mov	ecx, DWORD PTR _pResults$222152[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR _iStrategicResourceQuantityModifier$222161[ebp], eax

; 1305 : 			m_piStrategicResourceQuantityModifier[iTerrainID] = iStrategicResourceQuantityModifier;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	mov	ecx, DWORD PTR _iTerrainID$222159[ebp]
	mov	edx, DWORD PTR _iStrategicResourceQuantityModifier$222161[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1306 : 		}

	jmp	SHORT $LN38@CacheResul
$LN37@CacheResul:

; 1307 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$222150[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1308 : 
; 1309 : 	//Populate m_FreePromotionUnitCombats
; 1310 : 	{
; 1311 : 		std::string sqlKey = "FreePromotionUnitCombats";

	push	OFFSET ??_C@_0BJ@HAFNGCNE@FreePromotionUnitCombats?$AA@
	lea	ecx, DWORD PTR _sqlKey$222163[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1312 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	eax, DWORD PTR _sqlKey$222163[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222165[ebp], eax

; 1313 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222165[ebp], 0
	jne	SHORT $LN36@CacheResul

; 1314 : 		{
; 1315 : 			const char* szSQL = "select UnitPromotions.ID, UnitCombatInfos.ID from Trait_FreePromotionUnitCombats, UnitPromotions, UnitCombatInfos where TraitType = ? and PromotionType = UnitPromotions.Type and UnitCombatType = UnitCombatInfos.Type";

	mov	DWORD PTR _szSQL$222167[ebp], OFFSET ??_C@_0NI@DOOOMALO@select?5UnitPromotions?4ID?0?5UnitCo@

; 1316 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _szSQL$222167[ebp]
	push	ecx
	lea	edx, DWORD PTR _sqlKey$222163[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222165[ebp], eax
$LN36@CacheResul:

; 1317 : 		}
; 1318 : 
; 1319 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$222165[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN35@CacheResul:

; 1320 : 
; 1321 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222165[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@CacheResul

; 1322 : 		{
; 1323 : 			const int unitPromotionID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222165[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _unitPromotionID$222172[ebp], eax

; 1324 : 			const int unitCombatInfoID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222165[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _unitCombatInfoID$222173[ebp], eax

; 1325 : 
; 1326 : 			m_FreePromotionUnitCombats.insert(std::pair<int, int>(unitPromotionID, unitCombatInfoID));

	mov	edx, DWORD PTR _unitPromotionID$222172[ebp]
	mov	DWORD PTR $T229538[ebp], edx
	mov	eax, DWORD PTR _unitCombatInfoID$222173[ebp]
	mov	DWORD PTR $T229538[ebp+4], eax
	mov	ecx, DWORD PTR $T229538[ebp]
	mov	DWORD PTR $T229537[ebp], ecx
	mov	edx, DWORD PTR $T229538[ebp+4]
	mov	DWORD PTR $T229537[ebp+4], edx
	lea	eax, DWORD PTR $T229537[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229568[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T229539[ebp], edx

; 1327 : 		}

	jmp	SHORT $LN35@CacheResul
$LN34@CacheResul:

; 1328 : 
; 1329 : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$222165[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 1330 : 
; 1331 : 		//Trim extra memory off container since this is mostly read-only.
; 1332 : 		std::multimap<int,int>(m_FreePromotionUnitCombats).swap(m_FreePromotionUnitCombats);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 696				; 000002b8H
	push	eax
	lea	ecx, DWORD PTR $T229540[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	lea	ecx, DWORD PTR $T229540[ebp]
	mov	DWORD PTR tv1231[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 696				; 000002b8H
	push	edx
	mov	ecx, DWORD PTR tv1231[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T229540[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1333 : 
; 1334 : 		kUtility.PopulateArrayByValue(m_piResourceQuantityModifiers, "Resources", "Trait_ResourceQuantityModifiers", "ResourceType", "TraitType", szTraitType, "ResourceQuantityModifier");

	push	0
	push	0
	push	OFFSET ??_C@_0BJ@PKPOGINB@ResourceQuantityModifier?$AA@
	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	OFFSET ??_C@_09HHNMMNID@TraitType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0CA@KDHCGIKB@Trait_ResourceQuantityModifiers?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 672				; 000002a0H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 1335 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$222163[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1336 : 
; 1337 : 	//Populate m_MovesChangeUnitCombats
; 1338 : 	{
; 1339 : 		const int iNumUnitCombatClasses = kUtility.MaxRows("UnitCombatInfos");

	push	OFFSET ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _iNumUnitCombatClasses$222252[ebp], eax

; 1340 : 		kUtility.InitializeArray(m_piMovesChangeUnitCombats, iNumUnitCombatClasses, 0);

	push	0
	mov	edx, DWORD PTR _iNumUnitCombatClasses$222252[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 676				; 000002a4H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 1341 : 
; 1342 : 		std::string sqlKey = "Trait_MovesChangeUnitCombats";

	push	OFFSET ??_C@_0BN@PCNKEGGO@Trait_MovesChangeUnitCombats?$AA@
	lea	ecx, DWORD PTR _sqlKey$222254[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 1343 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	ecx, DWORD PTR _sqlKey$222254[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222256[ebp], eax

; 1344 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222256[ebp], 0
	jne	SHORT $LN33@CacheResul

; 1345 : 		{
; 1346 : 			const char* szSQL = "select UnitCombatInfos.ID, MovesChange from Trait_MovesChangeUnitCombats inner join UnitCombatInfos on UnitCombatInfos.Type = UnitCombatType where TraitType = ?;";

	mov	DWORD PTR _szSQL$222258[ebp], OFFSET ??_C@_0KC@CPPIJLAI@select?5UnitCombatInfos?4ID?0?5Moves@

; 1347 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	edx, DWORD PTR _szSQL$222258[ebp]
	push	edx
	lea	eax, DWORD PTR _sqlKey$222254[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222256[ebp], eax
$LN33@CacheResul:

; 1348 : 		}
; 1349 : 
; 1350 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	ecx, DWORD PTR _szTraitType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$222256[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN32@CacheResul:

; 1351 : 
; 1352 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222256[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN31@CacheResul

; 1353 : 		{
; 1354 : 			const int iUnitCombatID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222256[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iUnitCombatID$222263[ebp], eax

; 1355 : 			CvAssert(iUnitCombatID > -1 && iUnitCombatID < iNumUnitCombatClasses);
; 1356 : 
; 1357 : 			const int iMovesChange = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222256[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iMovesChange$222264[ebp], eax

; 1358 : 			m_piMovesChangeUnitCombats[iUnitCombatID] = iMovesChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+676]
	mov	edx, DWORD PTR _iUnitCombatID$222263[ebp]
	mov	eax, DWORD PTR _iMovesChange$222264[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1359 : 		}

	jmp	SHORT $LN32@CacheResul
$LN31@CacheResul:

; 1360 : 
; 1361 : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$222256[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 1362 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$222254[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1363 : 
; 1364 : 	//Populate m_MaintenanceModifierUnitCombats
; 1365 : 	{
; 1366 : 		const int iNumUnitCombatClasses = kUtility.MaxRows("UnitCombatInfos");

	push	OFFSET ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _iNumUnitCombatClasses$222265[ebp], eax

; 1367 : 		kUtility.InitializeArray(m_piMaintenanceModifierUnitCombats, iNumUnitCombatClasses, 0);

	push	0
	mov	ecx, DWORD PTR _iNumUnitCombatClasses$222265[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 680				; 000002a8H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 1368 : 
; 1369 : 		std::string sqlKey = "Trait_MaintenanceModifierUnitCombats";

	push	OFFSET ??_C@_0CF@FJLAILPM@Trait_MaintenanceModifierUnitCom@
	lea	ecx, DWORD PTR _sqlKey$222266[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 1370 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	eax, DWORD PTR _sqlKey$222266[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222268[ebp], eax

; 1371 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222268[ebp], 0
	jne	SHORT $LN30@CacheResul

; 1372 : 		{
; 1373 : 			const char* szSQL = "select UnitCombatInfos.ID, MaintenanceModifier from Trait_MaintenanceModifierUnitCombats inner join UnitCombatInfos on UnitCombatInfos.Type = UnitCombatType where TraitType = ?;";

	mov	DWORD PTR _szSQL$222270[ebp], OFFSET ??_C@_0LC@MLJIIHHK@select?5UnitCombatInfos?4ID?0?5Maint@

; 1374 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _szSQL$222270[ebp]
	push	ecx
	lea	edx, DWORD PTR _sqlKey$222266[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222268[ebp], eax
$LN30@CacheResul:

; 1375 : 		}
; 1376 : 
; 1377 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$222268[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN29@CacheResul:

; 1378 : 
; 1379 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222268[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN28@CacheResul

; 1380 : 		{
; 1381 : 			const int iUnitCombatID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222268[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iUnitCombatID$222275[ebp], eax

; 1382 : 			CvAssert(iUnitCombatID > -1 && iUnitCombatID < iNumUnitCombatClasses);
; 1383 : 
; 1384 : 			const int iMaintenanceModifier = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222268[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iMaintenanceModifier$222276[ebp], eax

; 1385 : 			m_piMaintenanceModifierUnitCombats[iUnitCombatID] = iMaintenanceModifier;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+680]
	mov	ecx, DWORD PTR _iUnitCombatID$222275[ebp]
	mov	edx, DWORD PTR _iMaintenanceModifier$222276[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1386 : 		}

	jmp	SHORT $LN29@CacheResul
$LN28@CacheResul:

; 1387 : 
; 1388 : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$222268[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 1389 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$222266[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1390 : 
; 1391 : 	//ImprovementYieldChanges
; 1392 : 	{
; 1393 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1394 : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges.first, "Improvements", "Yields");
; 1395 : 		m_ppiImprovementYieldChanges.second = kUtility.MaxRows("Improvements");
; 1396 : #else
; 1397 : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges, "Improvements", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0N@CJDAHDJO@Improvements?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 684				; 000002acH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1398 : #endif
; 1399 : 
; 1400 : 		std::string strKey("Trait_ImprovementYieldChanges");

	push	OFFSET ??_C@_0BO@GHGAFJAB@Trait_ImprovementYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$222279[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 1401 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$222279[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222281[ebp], eax

; 1402 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222281[ebp], 0
	jne	SHORT $LN27@CacheResul

; 1403 : 		{
; 1404 : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Trait_ImprovementYieldChanges inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where TraitType = ?");

	push	OFFSET ??_C@_0OI@DKABCEMC@select?5Improvements?4ID?5as?5Improv@
	lea	edx, DWORD PTR _strKey$222279[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222281[ebp], eax
$LN27@CacheResul:

; 1405 : 		}
; 1406 : 
; 1407 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	eax, DWORD PTR _szTraitType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$222281[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN26@CacheResul:

; 1408 : 
; 1409 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222281[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@CacheResul

; 1410 : 		{
; 1411 : 			const int ImprovementID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222281[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _ImprovementID$222287[ebp], eax

; 1412 : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222281[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$222288[ebp], eax

; 1413 : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$222281[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$222289[ebp], eax

; 1414 : 
; 1415 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1416 : 			m_ppiImprovementYieldChanges.first[ImprovementID][YieldID] = yield;
; 1417 : #else
; 1418 : 			m_ppiImprovementYieldChanges[ImprovementID][YieldID] = yield;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+684]
	mov	ecx, DWORD PTR _ImprovementID$222287[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _YieldID$222288[ebp]
	mov	ecx, DWORD PTR _yield$222289[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 1419 : #endif
; 1420 : 		}

	jmp	SHORT $LN26@CacheResul
$LN25@CacheResul:

; 1421 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222279[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1422 : 
; 1423 : 	//SpecialistYieldChanges
; 1424 : 	{
; 1425 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1426 : 		kUtility.Initialize2DArray(m_ppiSpecialistYieldChanges.first, "Specialists", "Yields");
; 1427 : 		m_ppiSpecialistYieldChanges.second = kUtility.MaxRows("Specialists");
; 1428 : #else
; 1429 : 		kUtility.Initialize2DArray(m_ppiSpecialistYieldChanges, "Specialists", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0M@EENMFCNN@Specialists?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 688				; 000002b0H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1430 : #endif
; 1431 : 
; 1432 : 
; 1433 : 		std::string strKey("Building_SpecialistYieldChanges");

	push	OFFSET ??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$222291[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 1434 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$222291[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222293[ebp], eax

; 1435 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222293[ebp], 0
	jne	SHORT $LN24@CacheResul

; 1436 : 		{
; 1437 : 			pResults = kUtility.PrepareResults(strKey, "select Specialists.ID as SpecialistID, Yields.ID as YieldID, Yield from Trait_SpecialistYieldChanges inner join Specialists on Specialists.Type = SpecialistType inner join Yields on Yields.Type = YieldType where TraitType = ?");

	push	OFFSET ??_C@_0OC@HBPDFFH@select?5Specialists?4ID?5as?5Special@
	lea	ecx, DWORD PTR _strKey$222291[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222293[ebp], eax
$LN24@CacheResul:

; 1438 : 		}
; 1439 : 
; 1440 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	edx, DWORD PTR _szTraitType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$222293[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN23@CacheResul:

; 1441 : 
; 1442 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222293[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@CacheResul

; 1443 : 		{
; 1444 : 			const int SpecialistID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222293[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _SpecialistID$222299[ebp], eax

; 1445 : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222293[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$222300[ebp], eax

; 1446 : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$222293[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$222301[ebp], eax

; 1447 : 
; 1448 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1449 : 			m_ppiSpecialistYieldChanges.first[SpecialistID][YieldID] = yield;
; 1450 : #else
; 1451 : 			m_ppiSpecialistYieldChanges[SpecialistID][YieldID] = yield;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+688]
	mov	eax, DWORD PTR _SpecialistID$222299[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _YieldID$222300[ebp]
	mov	eax, DWORD PTR _yield$222301[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1452 : #endif
; 1453 : 
; 1454 : 		}

	jmp	SHORT $LN23@CacheResul
$LN22@CacheResul:

; 1455 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222291[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1456 : 
; 1457 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 1458 : 	//AnySpecificSpecialistYieldChanges
; 1459 : 	{
; 1460 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1461 : 		kUtility.Initialize2DArray(m_ppiAnySpecificSpecialistYieldChanges.first, "Specialists", "Yields");
; 1462 : 		m_ppiAnySpecificSpecialistYieldChanges.second = kUtility.MaxRows("Specialists");
; 1463 : #else
; 1464 : 		kUtility.Initialize2DArray(m_ppiAnySpecificSpecialistYieldChanges, "Specialists", "Yields");
; 1465 : #endif
; 1466 : 
; 1467 : 
; 1468 : 		std::string strKey("Building_SpecialistYieldChanges");
; 1469 : 		Database::Results* pResults = kUtility.GetResults(strKey);
; 1470 : 		if(pResults == NULL)
; 1471 : 		{
; 1472 : 			pResults = kUtility.PrepareResults(strKey, "select Specialists.ID as SpecialistID, Yields.ID as YieldID, Yield from Trait_AnySpecificSpecialistYieldChanges inner join Specialists on Specialists.Type = SpecialistType inner join Yields on Yields.Type = YieldType where TraitType = ?");
; 1473 : 		}
; 1474 : 
; 1475 : 		pResults->Bind(1, szTraitType);
; 1476 : 
; 1477 : 		while(pResults->Step())
; 1478 : 		{
; 1479 : 			const int SpecialistID = pResults->GetInt(0);
; 1480 : 			const int YieldID = pResults->GetInt(1);
; 1481 : 			const int yield = pResults->GetInt(2);
; 1482 : 
; 1483 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1484 : 			m_ppiAnySpecificSpecialistYieldChanges.first[SpecialistID][YieldID] = yield;
; 1485 : #else
; 1486 : 			m_ppiAnySpecificSpecialistYieldChanges[SpecialistID][YieldID] = yield;
; 1487 : #endif
; 1488 : 
; 1489 : 		}
; 1490 : 	}
; 1491 : #endif
; 1492 : 	//UnimprovedFeatureYieldChanges
; 1493 : 	{
; 1494 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1495 : 		kUtility.Initialize2DArray(m_ppiUnimprovedFeatureYieldChanges.first, "Features", "Yields");
; 1496 : 		m_ppiUnimprovedFeatureYieldChanges.second = kUtility.MaxRows("Features");
; 1497 : #else
; 1498 : 		kUtility.Initialize2DArray(m_ppiUnimprovedFeatureYieldChanges, "Features", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_08CLANBDND@Features?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 692				; 000002b4H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 1499 : #endif
; 1500 : 
; 1501 : 		std::string strKey("Trait_UnimprovedFeatureYieldChanges");

	push	OFFSET ??_C@_0CE@ICBKMLMI@Trait_UnimprovedFeatureYieldChan@
	lea	ecx, DWORD PTR _strKey$222303[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 8

; 1502 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$222303[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222305[ebp], eax

; 1503 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222305[ebp], 0
	jne	SHORT $LN21@CacheResul

; 1504 : 		{
; 1505 : 			pResults = kUtility.PrepareResults(strKey, "select Features.ID as FeatureID, Yields.ID as YieldID, Yield from Trait_UnimprovedFeatureYieldChanges inner join Features on Features.Type = FeatureType inner join Yields on Yields.Type = YieldType where TraitType = ?");

	push	OFFSET ??_C@_0NK@BJHMDDLL@select?5Features?4ID?5as?5FeatureID?0@
	lea	eax, DWORD PTR _strKey$222303[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222305[ebp], eax
$LN21@CacheResul:

; 1506 : 		}
; 1507 : 
; 1508 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	ecx, DWORD PTR _szTraitType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$222305[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN20@CacheResul:

; 1509 : 
; 1510 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222305[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN19@CacheResul

; 1511 : 		{
; 1512 : 			const int FeatureID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222305[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _FeatureID$222311[ebp], eax

; 1513 : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222305[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$222312[ebp], eax

; 1514 : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$222305[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$222313[ebp], eax

; 1515 : 
; 1516 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 1517 : 			m_ppiUnimprovedFeatureYieldChanges.first[FeatureID][YieldID] = yield;
; 1518 : #else
; 1519 : 			m_ppiUnimprovedFeatureYieldChanges[FeatureID][YieldID] = yield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR _FeatureID$222311[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _YieldID$222312[ebp]
	mov	edx, DWORD PTR _yield$222313[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 1520 : #endif
; 1521 : 		}

	jmp	SHORT $LN20@CacheResul
$LN19@CacheResul:

; 1522 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222303[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1523 : 
; 1524 : 	// NoTrain
; 1525 : 	{
; 1526 : #ifdef AUI_WARNING_FIXES
; 1527 : 		for (uint iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)
; 1528 : #else
; 1529 : 		int iUnitClassLoop;
; 1530 : 		for (iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)

	mov	DWORD PTR _iUnitClassLoop$222314[ebp], 0
	jmp	SHORT $LN18@CacheResul
$LN17@CacheResul:
	mov	eax, DWORD PTR _iUnitClassLoop$222314[ebp]
	add	eax, 1
	mov	DWORD PTR _iUnitClassLoop$222314[ebp], eax
$LN18@CacheResul:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iUnitClassLoop$222314[ebp], eax
	jge	SHORT $LN16@CacheResul

; 1531 : #endif
; 1532 : 		{
; 1533 : 			m_abNoTrainUnitClass.push_back(false);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	mov	DWORD PTR $T230044[ebp], ecx
	lea	edx, DWORD PTR $T230041[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230044[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230040[ebp], ecx
	mov	DWORD PTR $T230040[ebp+4], edx
	push	0
	mov	eax, DWORD PTR $T230040[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T230040[ebp]
	push	ecx
	lea	edx, DWORD PTR $T230042[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230044[ebp]
	call	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert

; 1534 : 		}

	jmp	SHORT $LN17@CacheResul
$LN16@CacheResul:

; 1535 : 
; 1536 : 		std::string strKey("Trait_NoTrain");

	push	OFFSET ??_C@_0O@GKGKBLJD@Trait_NoTrain?$AA@
	lea	ecx, DWORD PTR _strKey$222318[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 9

; 1537 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$222318[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222320[ebp], eax

; 1538 : 		if (pResults == NULL)

	cmp	DWORD PTR _pResults$222320[ebp], 0
	jne	SHORT $LN15@CacheResul

; 1539 : 		{
; 1540 : 			pResults = kUtility.PrepareResults(strKey, "SELECT Traits.ID, UnitClasses.ID FROM Trait_NoTrain inner join Traits on Trait_NoTrain.TraitType = Traits.Type inner join UnitClasses on Trait_NoTrain.UnitClassType = UnitClasses.Type where TraitType = ?");

	push	OFFSET ??_C@_0MM@LPKCCPOE@SELECT?5Traits?4ID?0?5UnitClasses?4ID@
	lea	ecx, DWORD PTR _strKey$222318[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222320[ebp], eax
$LN15@CacheResul:

; 1541 : 		}
; 1542 : 
; 1543 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	edx, DWORD PTR _szTraitType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$222320[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN14@CacheResul:

; 1544 : 
; 1545 : 		while (pResults->Step())

	mov	ecx, DWORD PTR _pResults$222320[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	$LN13@CacheResul

; 1546 : 		{
; 1547 : 			const int iUnitClass = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222320[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iUnitClass$222326[ebp], eax

; 1548 : 			m_abNoTrainUnitClass[iUnitClass] = true;

	mov	ecx, DWORD PTR _iUnitClass$222326[ebp]
	push	ecx
	lea	edx, DWORD PTR $T229541[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T230150[ebp], eax
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN301@CacheResul
	mov	ecx, DWORD PTR $T230127[ebp]
	mov	DWORD PTR tv1565[ebp], ecx
	mov	edx, DWORD PTR $T230150[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv1565[ebp], eax
	mov	ecx, DWORD PTR $T230150[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv1565[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1565[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN302@CacheResul
$LN301@CacheResul:
	mov	edx, DWORD PTR $T230134[ebp]
	mov	DWORD PTR tv1600[ebp], edx
	mov	eax, DWORD PTR $T230150[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv1600[ebp], ecx
	mov	edx, DWORD PTR $T230150[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv1600[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv1600[ebp]
	mov	DWORD PTR [edx], eax
$LN302@CacheResul:

; 1549 : 		}

	jmp	$LN14@CacheResul
$LN13@CacheResul:

; 1550 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222318[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1551 : 
; 1552 : 
; 1553 : 	// EAP: NoBuild
; 1554 : 	{
; 1555 : 
; 1556 : 		int iImprovementLoop;
; 1557 : 		for(int iImprovementLoop = 0; iImprovementLoop < GC.getNumImprovementInfos(); iImprovementLoop++)

	mov	DWORD PTR _iImprovementLoop$222329[ebp], 0
	jmp	SHORT $LN12@CacheResul
$LN11@CacheResul:
	mov	eax, DWORD PTR _iImprovementLoop$222329[ebp]
	add	eax, 1
	mov	DWORD PTR _iImprovementLoop$222329[ebp], eax
$LN12@CacheResul:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iImprovementLoop$222329[ebp], eax
	jge	SHORT $LN10@CacheResul

; 1558 : 
; 1559 : 		{
; 1560 : 			m_abNoBuildImprovement.push_back(false);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	mov	DWORD PTR $T230405[ebp], ecx
	lea	edx, DWORD PTR $T230403[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230405[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230402[ebp], ecx
	mov	DWORD PTR $T230402[ebp+4], edx
	push	0
	mov	eax, DWORD PTR $T230402[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T230402[ebp]
	push	ecx
	lea	edx, DWORD PTR $T230404[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230405[ebp]
	call	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert

; 1561 : 		}

	jmp	SHORT $LN11@CacheResul
$LN10@CacheResul:

; 1562 : 
; 1563 : 		std::string strKey("Trait_NoBuild");

	push	OFFSET ??_C@_0O@DEFFCEIL@Trait_NoBuild?$AA@
	lea	ecx, DWORD PTR _strKey$222333[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 1564 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$222333[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222335[ebp], eax

; 1565 : 		if (pResults == NULL)

	cmp	DWORD PTR _pResults$222335[ebp], 0
	jne	SHORT $LN9@CacheResul

; 1566 : 		{
; 1567 : 			pResults = kUtility.PrepareResults(strKey, "SELECT Traits.ID, Improvements.ID FROM Trait_NoBuild inner join Traits on Trait_NoBuild.TraitType = Traits.Type inner join Improvements on Trait_NoBuild.ImprovementType = Improvements.Type where TraitType = ?");

	push	OFFSET ??_C@_0NB@LGAABOM@SELECT?5Traits?4ID?0?5Improvements?4I@
	lea	ecx, DWORD PTR _strKey$222333[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222335[ebp], eax
$LN9@CacheResul:

; 1568 : 		}
; 1569 : 
; 1570 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	edx, DWORD PTR _szTraitType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$222335[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN8@CacheResul:

; 1571 : 
; 1572 : 		while (pResults->Step())

	mov	ecx, DWORD PTR _pResults$222335[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	$LN7@CacheResul

; 1573 : 		{
; 1574 : 			const int iImprovementID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222335[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iImprovementID$222341[ebp], eax

; 1575 : 			m_abNoBuildImprovement[iImprovementID] = true;

	mov	ecx, DWORD PTR _iImprovementID$222341[ebp]
	push	ecx
	lea	edx, DWORD PTR $T229542[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T230512[ebp], eax
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN429@CacheResul
	mov	ecx, DWORD PTR $T230489[ebp]
	mov	DWORD PTR tv1810[ebp], ecx
	mov	edx, DWORD PTR $T230512[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv1810[ebp], eax
	mov	ecx, DWORD PTR $T230512[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv1810[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1810[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN430@CacheResul
$LN429@CacheResul:
	mov	edx, DWORD PTR $T230496[ebp]
	mov	DWORD PTR tv1860[ebp], edx
	mov	eax, DWORD PTR $T230512[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv1860[ebp], ecx
	mov	edx, DWORD PTR $T230512[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv1860[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv1860[ebp]
	mov	DWORD PTR [edx], eax
$LN430@CacheResul:

; 1576 : 		}

	jmp	$LN8@CacheResul
$LN7@CacheResul:

; 1577 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222333[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1578 : 	
; 1579 : 
; 1580 : 	// FreeResourceXCities
; 1581 : 	{
; 1582 : 		// Init vector
; 1583 : #ifdef AUI_WARNING_FIXES
; 1584 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 1585 : #else
; 1586 : 		int iResourceLoop;
; 1587 : 		for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$222343[ebp], 0
	jmp	SHORT $LN6@CacheResul
$LN5@CacheResul:
	mov	eax, DWORD PTR _iResourceLoop$222343[ebp]
	add	eax, 1
	mov	DWORD PTR _iResourceLoop$222343[ebp], eax
$LN6@CacheResul:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222343[ebp], eax
	jge	SHORT $LN4@CacheResul

; 1588 : #endif
; 1589 : 		{
; 1590 : 			FreeResourceXCities temp;

	mov	DWORD PTR _temp$222347[ebp], 0
	mov	DWORD PTR _temp$222347[ebp+4], 0

; 1591 : 			m_aFreeResourceXCities.push_back(temp);

	lea	ecx, DWORD PTR _temp$222347[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 708				; 000002c4H
	call	?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back

; 1592 : 		}

	jmp	SHORT $LN5@CacheResul
$LN4@CacheResul:

; 1593 : 
; 1594 : 		std::string strKey("Trait_FreeResourceFirstXCities");

	push	OFFSET ??_C@_0BP@LEJJCALA@Trait_FreeResourceFirstXCities?$AA@
	lea	ecx, DWORD PTR _strKey$222348[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 1595 : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$222348[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$222350[ebp], eax

; 1596 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$222350[ebp], 0
	jne	SHORT $LN3@CacheResul

; 1597 : 		{
; 1598 : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, ResourceQuantity, NumCities from Trait_FreeResourceFirstXCities inner join Resources on Resources.Type = ResourceType where TraitType = ?");

	push	OFFSET ??_C@_0KN@EDAJGKBH@select?5Resources?4ID?5as?5ResourceI@
	lea	eax, DWORD PTR _strKey$222348[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$222350[ebp], eax
$LN3@CacheResul:

; 1599 : 		}
; 1600 : 
; 1601 : 		pResults->Bind(1, szTraitType);

	push	1
	mov	ecx, DWORD PTR _szTraitType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$222350[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN2@CacheResul:

; 1602 : 
; 1603 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$222350[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@CacheResul

; 1604 : 		{
; 1605 : 			FreeResourceXCities temp;

	mov	DWORD PTR _temp$222356[ebp], 0
	mov	DWORD PTR _temp$222356[ebp+4], 0

; 1606 : 
; 1607 : 			const int iResource = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$222350[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iResource$222357[ebp], eax

; 1608 : 			temp.m_iResourceQuantity = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$222350[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _temp$222356[ebp+4], eax

; 1609 : 			temp.m_iNumCities = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$222350[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _temp$222356[ebp], eax

; 1610 : 
; 1611 : 			m_aFreeResourceXCities[iResource] = temp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+712]
	mov	edx, DWORD PTR _iResource$222357[ebp]
	mov	eax, DWORD PTR _temp$222356[ebp]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR _temp$222356[ebp+4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 1612 : 		}

	jmp	$LN2@CacheResul
$LN1@CacheResul:

; 1613 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$222348[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1614 : 
; 1615 : 	return true;

	mov	al, 1
$LN51@CacheResul:

; 1616 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _sqlKey$222150[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _sqlKey$222163[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR $T229540[ebp]
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$19:
	lea	ecx, DWORD PTR $T229540[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _sqlKey$222254[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _sqlKey$222266[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _strKey$222279[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _strKey$222291[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7:
	lea	ecx, DWORD PTR _strKey$222303[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8:
	lea	ecx, DWORD PTR _strKey$222318[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9:
	lea	ecx, DWORD PTR _strKey$222333[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$10:
	lea	ecx, DWORD PTR _strKey$222348[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvTraitEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvTraitEntry::CacheResults
PUBLIC	??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Buy
PUBLIC	??0CvTraitXMLEntries@@QAE@XZ			; CvTraitXMLEntries::CvTraitXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvTraitXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTraitXMLEntries@@QAE@XZ$1
__ehfuncinfo$??0CvTraitXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTraitXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvTraitXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T230677 = -30						; size = 1
$T230664 = -29						; size = 1
$T230660 = -28						; size = 4
$T230653 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTraitXMLEntries@@QAE@XZ PROC			; CvTraitXMLEntries::CvTraitXMLEntries, COMDAT
; _this$ = ecx

; 1623 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTraitXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T230677[ebp]
	mov	DWORD PTR $T230653[ebp], eax
	lea	ecx, DWORD PTR $T230664[ebp]
	mov	DWORD PTR $T230660[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 1624 : 
; 1625 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTraitXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvTraitXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTraitXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTraitXMLEntries@@QAE@XZ ENDP			; CvTraitXMLEntries::CvTraitXMLEntries
PUBLIC	??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvTraitXMLEntries@@QAEXXZ		; CvTraitXMLEntries::DeleteArray
PUBLIC	??1CvTraitXMLEntries@@QAE@XZ			; CvTraitXMLEntries::~CvTraitXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvTraitXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTraitXMLEntries@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTraitXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvTraitXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvTraitXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTraitXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTraitXMLEntries@@QAE@XZ PROC			; CvTraitXMLEntries::~CvTraitXMLEntries, COMDAT
; _this$ = ecx

; 1629 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTraitXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1630 : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvTraitXMLEntries@@QAEXXZ	; CvTraitXMLEntries::DeleteArray

; 1631 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTraitXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
__unwindfunclet$??1CvTraitXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvTraitXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTraitXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTraitXMLEntries@@QAE@XZ ENDP			; CvTraitXMLEntries::~CvTraitXMLEntries
PUBLIC	?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ; CvTraitXMLEntries::GetTraitEntries
; Function compile flags: /Odtp
;	COMDAT ?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ PROC ; CvTraitXMLEntries::GetTraitEntries, COMDAT
; _this$ = ecx

; 1635 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1636 : 	return m_paTraitEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 1637 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTraitEntries@CvTraitXMLEntries@@QAEAAV?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@XZ ENDP ; CvTraitXMLEntries::GetTraitEntries
_TEXT	ENDS
PUBLIC	?GetNumTraits@CvTraitXMLEntries@@QAEHXZ		; CvTraitXMLEntries::GetNumTraits
; Function compile flags: /Odtp
;	COMDAT ?GetNumTraits@CvTraitXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumTraits@CvTraitXMLEntries@@QAEHXZ PROC		; CvTraitXMLEntries::GetNumTraits, COMDAT
; _this$ = ecx

; 1641 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1642 : 	return m_paTraitEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1643 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTraits@CvTraitXMLEntries@@QAEHXZ ENDP		; CvTraitXMLEntries::GetNumTraits
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::erase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvTraitXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv143 = -116						; size = 4
_this$ = -112						; size = 4
$T230919 = -56						; size = 4
$T230903 = -52						; size = 4
$T231023 = -48						; size = 4
$T231022 = -44						; size = 4
$T231021 = -40						; size = 4
$T231020 = -36						; size = 4
$T231019 = -32						; size = 4
$T230887 = -28						; size = 4
$T230880 = -24						; size = 4
$T230879 = -20						; size = 4
$T230846 = -16						; size = 4
$T230822 = -12						; size = 4
$T230812 = -8						; size = 4
_it$222533 = -4						; size = 4
?DeleteArray@CvTraitXMLEntries@@QAEXXZ PROC		; CvTraitXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 1647 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 1648 : 	for(std::vector<CvTraitEntry*>::iterator it = m_paTraitEntries.begin(); it != m_paTraitEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230822[ebp], ecx
	mov	edx, DWORD PTR $T230822[ebp]
	mov	DWORD PTR _it$222533[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$222533[ebp]
	add	eax, 4
	mov	DWORD PTR _it$222533[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T230846[ebp], edx
	mov	eax, DWORD PTR $T230846[ebp]
	mov	DWORD PTR $T230812[ebp], eax
	mov	ecx, DWORD PTR _it$222533[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T230812[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 1649 : 	{
; 1650 : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$222533[ebp]
	mov	DWORD PTR $T230887[ebp], edx
	mov	eax, DWORD PTR $T230887[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230880[ebp], ecx
	mov	edx, DWORD PTR $T230880[ebp]
	mov	DWORD PTR $T230879[ebp], edx
	cmp	DWORD PTR $T230879[ebp], 0
	je	SHORT $LN32@DeleteArra
	mov	ecx, DWORD PTR $T230879[ebp]
	call	??1CvTraitEntry@@QAE@XZ			; CvTraitEntry::~CvTraitEntry
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN35@DeleteArra
	mov	ecx, DWORD PTR $T230879[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@DeleteArra:
	mov	edx, DWORD PTR $T230879[ebp]
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv143[ebp], 0
$LN33@DeleteArra:
	mov	eax, DWORD PTR $T230887[ebp]
	mov	DWORD PTR [eax], 0

; 1651 : 	}

	jmp	$LN2@DeleteArra
$LN1@DeleteArra:

; 1652 : 
; 1653 : 	m_paTraitEntries.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T230903[ebp], edx
	mov	eax, DWORD PTR $T230903[ebp]
	mov	DWORD PTR $T231020[ebp], eax
	mov	ecx, DWORD PTR $T231020[ebp]
	mov	DWORD PTR $T231019[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T230919[ebp], eax
	mov	ecx, DWORD PTR $T230919[ebp]
	mov	DWORD PTR $T231022[ebp], ecx
	mov	edx, DWORD PTR $T231022[ebp]
	mov	DWORD PTR $T231021[ebp], edx
	mov	eax, DWORD PTR $T231019[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231021[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231023[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::erase

; 1654 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvTraitXMLEntries@@QAEXXZ ENDP		; CvTraitXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z ; CvTraitXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z PROC ; CvTraitXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 1658 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1659 : 	return m_paTraitEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1660 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z ENDP ; CvTraitXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
PUBLIC	??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
PUBLIC	??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
PUBLIC	??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
PUBLIC	??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
PUBLIC	??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
PUBLIC	??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::FStaticVector<FreeTraitUnit,5,1,297,0>
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::vector<enum TraitTypes,std::allocator<enum TraitTypes> >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0CvPlayerTraits@@QAE@XZ			; CvPlayerTraits::CvPlayerTraits
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$??0CvPlayerTraits@@QAE@XZ DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$??0CvPlayerTraits@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvPlayerTraits@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$18
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$3
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$20
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$4
	DD	07H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$5
	DD	08H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$6
	DD	09H
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$7
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$8
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$9
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$10
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$11
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$12
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlayerTraits@@QAE@XZ
_TEXT	SEGMENT
tv301 = -132						; size = 4
tv275 = -128						; size = 4
tv223 = -124						; size = 4
_this$ = -120						; size = 4
$T231131 = -76						; size = 4
$T231123 = -69						; size = 1
$T231119 = -68						; size = 4
$T231111 = -60						; size = 4
$T231103 = -53						; size = 1
$T231099 = -52						; size = 4
$T231077 = -28						; size = 4
$T231069 = -21						; size = 1
$T231065 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlayerTraits@@QAE@XZ PROC				; CvPlayerTraits::CvPlayerTraits, COMDAT
; _this$ = ecx

; 1667 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPlayerTraits@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T231077[ebp], eax
	lea	ecx, DWORD PTR $T231069[ebp]
	mov	DWORD PTR $T231065[ebp], ecx
	mov	edx, DWORD PTR $T231077[ebp]
	mov	DWORD PTR tv223[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T231077[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T231077[ebp]
	add	ecx, 4
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::vector<enum TraitTypes,std::allocator<enum TraitTypes> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	mov	DWORD PTR $T231111[ebp], ecx
	lea	edx, DWORD PTR $T231103[ebp]
	mov	DWORD PTR $T231099[ebp], edx
	mov	eax, DWORD PTR $T231111[ebp]
	mov	DWORD PTR tv275[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T231111[ebp]
	mov	DWORD PTR [ecx], 0
	mov	ecx, DWORD PTR $T231111[ebp]
	add	ecx, 4
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 648				; 00000288H
	mov	DWORD PTR $T231131[ebp], edx
	lea	eax, DWORD PTR $T231123[ebp]
	mov	DWORD PTR $T231119[ebp], eax
	mov	ecx, DWORD PTR $T231131[ebp]
	mov	DWORD PTR tv301[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR $T231131[ebp]
	mov	DWORD PTR [edx], 0
	mov	ecx, DWORD PTR $T231131[ebp]
	add	ecx, 4
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 668				; 0000029cH
	call	??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::FStaticVector<FreeTraitUnit,5,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 764				; 000002fcH
	call	??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	call	??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 828				; 0000033cH
	call	??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	call	??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 860				; 0000035cH
	call	??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >

; 1668 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$14:
	mov	ecx, DWORD PTR $T231077[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$18:
	mov	ecx, DWORD PTR $T231111[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$20:
	mov	ecx, DWORD PTR $T231131[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 668				; 0000029cH
	jmp	??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 764				; 000002fcH
	jmp	??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 828				; 0000033cH
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??0CvPlayerTraits@@QAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__ehhandler$??0CvPlayerTraits@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPlayerTraits@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlayerTraits@@QAE@XZ ENDP				; CvPlayerTraits::CvPlayerTraits
PUBLIC	??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::~_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >
PUBLIC	??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
PUBLIC	?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy
PUBLIC	?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy
PUBLIC	?Uninit@CvPlayerTraits@@QAEXXZ			; CvPlayerTraits::Uninit
PUBLIC	??1CvPlayerTraits@@QAE@XZ			; CvPlayerTraits::~CvPlayerTraits
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1CvPlayerTraits@@QAE@XZ DD 019930522H
	DD	01eH
	DD	FLAT:__unwindtable$??1CvPlayerTraits@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvPlayerTraits@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$13
	DD	0cH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$14
	DD	0bH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$16
	DD	0aH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$18
	DD	09H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$20
	DD	08H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$22
	DD	07H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$24
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$26
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$28
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$31
	DD	016H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$33
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$35
	DD	018H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$37
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$39
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$41
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$43
	DD	01cH
	DD	FLAT:__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$45
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlayerTraits@@QAE@XZ
_TEXT	SEGMENT
_this$ = -292						; size = 4
$T231816 = -288						; size = 4
$T231802 = -284						; size = 4
$T231743 = -252						; size = 4
$T231657 = -216						; size = 4
$T231601 = -184						; size = 4
$T231587 = -180						; size = 4
$T231566 = -176						; size = 4
$T231552 = -172						; size = 4
$T231519 = -160						; size = 4
$T231463 = -128						; size = 4
$T231377 = -92						; size = 4
$T231321 = -60						; size = 4
$T231265 = -28						; size = 4
$T231247 = -24						; size = 4
$T231229 = -20						; size = 4
$T231211 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlayerTraits@@QAE@XZ PROC				; CvPlayerTraits::~CvPlayerTraits, COMDAT
; _this$ = ecx

; 1672 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPlayerTraits@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH

; 1673 : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Uninit

; 1674 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 860				; 0000035cH
	mov	DWORD PTR $T231211[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR $T231211[ebp]
	call	?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	mov	DWORD PTR $T231229[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR $T231229[ebp]
	call	?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 828				; 0000033cH
	mov	DWORD PTR $T231247[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR $T231247[ebp]
	call	?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	mov	DWORD PTR $T231265[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	ecx, DWORD PTR $T231265[ebp]
	call	?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	mov	DWORD PTR $T231321[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR $T231321[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 780				; 0000030cH
	mov	DWORD PTR $T231377[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	ecx, DWORD PTR $T231377[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 764				; 000002fcH
	mov	DWORD PTR $T231463[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	mov	ecx, DWORD PTR $T231463[ebp]
	call	?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	mov	DWORD PTR $T231519[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	ecx, DWORD PTR $T231519[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 668				; 0000029cH
	call	??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 648				; 00000288H
	mov	DWORD PTR $T231566[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	mov	eax, DWORD PTR $T231566[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T231566[ebp]
	add	ecx, 4
	mov	DWORD PTR $T231552[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	mov	ecx, DWORD PTR $T231552[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 628				; 00000274H
	mov	DWORD PTR $T231601[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	mov	eax, DWORD PTR $T231601[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T231601[ebp]
	add	ecx, 4
	mov	DWORD PTR $T231587[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	mov	ecx, DWORD PTR $T231587[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 612				; 00000264H
	mov	DWORD PTR $T231657[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	mov	ecx, DWORD PTR $T231657[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T231743[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	mov	ecx, DWORD PTR $T231743[ebp]
	call	?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T231816[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 28		; 0000001cH
	mov	edx, DWORD PTR $T231816[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T231816[ebp]
	add	eax, 4
	mov	DWORD PTR $T231802[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	mov	ecx, DWORD PTR $T231802[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 668				; 0000029cH
	jmp	??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 764				; 000002fcH
	jmp	??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 828				; 0000033cH
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	jmp	??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 860				; 0000035cH
	jmp	??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$14:
	mov	ecx, DWORD PTR $T231211[ebp]
	jmp	??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$16:
	mov	ecx, DWORD PTR $T231229[ebp]
	jmp	??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$18:
	mov	ecx, DWORD PTR $T231247[ebp]
	jmp	??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$20:
	mov	ecx, DWORD PTR $T231265[ebp]
	jmp	??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$22:
	mov	ecx, DWORD PTR $T231321[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$24:
	mov	ecx, DWORD PTR $T231377[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$26:
	mov	ecx, DWORD PTR $T231463[ebp]
	jmp	??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$28:
	mov	ecx, DWORD PTR $T231519[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$31:
	mov	ecx, DWORD PTR $T231566[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$33:
	mov	ecx, DWORD PTR $T231552[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$35:
	mov	ecx, DWORD PTR $T231601[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$37:
	mov	ecx, DWORD PTR $T231587[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$39:
	mov	ecx, DWORD PTR $T231657[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$41:
	mov	ecx, DWORD PTR $T231743[ebp]
	jmp	??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$43:
	mov	ecx, DWORD PTR $T231816[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1CvPlayerTraits@@QAE@XZ$45:
	mov	ecx, DWORD PTR $T231802[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1CvPlayerTraits@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPlayerTraits@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlayerTraits@@QAE@XZ ENDP				; CvPlayerTraits::~CvPlayerTraits
PUBLIC	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase
PUBLIC	?Reset@CvPlayerTraits@@QAEXXZ			; CvPlayerTraits::Reset
PUBLIC	?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z ; CvPlayerTraits::Init
EXTRN	?getNumTraitInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTraitInfos
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$6
__ehfuncinfo$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
tv86 = -232						; size = 4
_this$ = -228						; size = 4
$T232210 = -224						; size = 4
$T232151 = -192						; size = 4
$T232150 = -188						; size = 4
$T232112 = -156						; size = 4
$T232016 = -124						; size = 4
$T232000 = -120						; size = 4
$T232098 = -116						; size = 4
$T232097 = -112						; size = 4
$T232096 = -108						; size = 4
$T232095 = -104						; size = 4
$T232094 = -100						; size = 4
$T231984 = -96						; size = 4
$T231858 = -60						; size = 4
$T231842 = -56						; size = 4
$T231970 = -52						; size = 4
$T231969 = -48						; size = 4
$T231968 = -44						; size = 4
$T231967 = -40						; size = 4
$T231966 = -36						; size = 4
$T231825 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_pTraits$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z PROC ; CvPlayerTraits::Init, COMDAT
; _this$ = ecx

; 1678 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1679 : 	// Store off the pointers to objects we'll need later
; 1680 : 	m_pTraits = pTraits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTraits$[ebp]
	mov	DWORD PTR [eax], ecx

; 1681 : 	m_pPlayer = pPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1682 : 
; 1683 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Reset

; 1684 : 
; 1685 : 	// Initialize items that can't be reset everytime we earn a new tech (which resets all the other
; 1686 : 	// trait data that can rebuilt from the trait entries)
; 1687 : 	m_iBaktunPreviousTurn = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+740], 0

; 1688 : 	m_aMayaBonusChoices.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 764				; 000002fcH
	mov	DWORD PTR $T231984[ebp], edx
	mov	eax, DWORD PTR $T231984[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T231842[ebp], ecx
	mov	edx, DWORD PTR $T231842[ebp]
	mov	DWORD PTR $T231967[ebp], edx
	mov	eax, DWORD PTR $T231967[ebp]
	mov	DWORD PTR $T231966[ebp], eax
	mov	ecx, DWORD PTR $T231984[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231858[ebp], edx
	mov	eax, DWORD PTR $T231858[ebp]
	mov	DWORD PTR $T231969[ebp], eax
	mov	ecx, DWORD PTR $T231969[ebp]
	mov	DWORD PTR $T231968[ebp], ecx
	mov	edx, DWORD PTR $T231966[ebp]
	push	edx
	mov	eax, DWORD PTR $T231968[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231970[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231984[ebp]
	call	?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase

; 1689 : 	m_iBaktun = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+744], 0

; 1690 : 	m_iKatun = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+748], 0

; 1691 : 	m_iTun = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+752], 0

; 1692 : 	m_iWinal = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+756], 0

; 1693 : 	m_iKin = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+760], 0

; 1694 : 
; 1695 : 	m_aUniqueLuxuryAreas.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	mov	DWORD PTR $T232112[ebp], ecx
	mov	edx, DWORD PTR $T232112[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T232000[ebp], eax
	mov	ecx, DWORD PTR $T232000[ebp]
	mov	DWORD PTR $T232095[ebp], ecx
	mov	edx, DWORD PTR $T232095[ebp]
	mov	DWORD PTR $T232094[ebp], edx
	mov	eax, DWORD PTR $T232112[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232016[ebp], ecx
	mov	edx, DWORD PTR $T232016[ebp]
	mov	DWORD PTR $T232097[ebp], edx
	mov	eax, DWORD PTR $T232097[ebp]
	mov	DWORD PTR $T232096[ebp], eax
	mov	ecx, DWORD PTR $T232094[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232096[ebp]
	push	edx
	lea	eax, DWORD PTR $T232098[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232112[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1696 : 	m_iUniqueLuxuryCitiesPlaced = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], 0

; 1697 : 
; 1698 : 	m_vLeaderHasTrait = std::vector<bool>( GC.getNumTraitInfos(), false );

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	push	eax
	lea	ecx, DWORD PTR $T231825[ebp]
	call	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
	mov	DWORD PTR tv86[ebp], eax
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T232151[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T232150[ebp], eax
	mov	ecx, DWORD PTR $T232150[ebp]
	mov	edx, DWORD PTR $T232151[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T232151[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR $T232150[ebp]
	add	ecx, 4
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T231825[ebp], 0
	lea	edx, DWORD PTR $T231825[ebp+4]
	mov	DWORD PTR $T232210[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T232210[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 1699 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR $T231825[ebp]
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$4:
	lea	ecx, DWORD PTR $T231825[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z$6:
	mov	ecx, DWORD PTR $T232210[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvPlayerTraits@@QAEXPAVCvTraitXMLEntries@@PAVCvPlayer@@@Z ENDP ; CvPlayerTraits::Init
PUBLIC	?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back
PUBLIC	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z	; CvPlayerTraits::HasTrait
PUBLIC	?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
PUBLIC	?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase
PUBLIC	?InitPlayerTraits@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::InitPlayerTraits
EXTRN	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumUnitCombatClassInfos
EXTRN	?getNumSpecialistInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumSpecialistInfos
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
EXTRN	?ChangeWoundedUnitDamageMod@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeWoundedUnitDamageMod
EXTRN	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z:PROC ; CvGlobals::getTraitInfo
EXTRN	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z:PROC	; CvLeaderHeadInfo::hasTrait
EXTRN	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ:PROC ; CvPlayer::getLeaderInfo
EXTRN	?isMajorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMajorCiv
; Function compile flags: /Odtp
;	COMDAT ?InitPlayerTraits@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
tv846 = -636						; size = 4
tv837 = -632						; size = 4
tv1318 = -628						; size = 4
tv1268 = -624						; size = 4
tv1218 = -620						; size = 4
tv1168 = -616						; size = 4
tv1060 = -612						; size = 4
tv1015 = -608						; size = 4
tv964 = -604						; size = 4
tv951 = -600						; size = 4
_this$ = -596						; size = 4
$T232904 = -549						; size = 1
$T232903 = -548						; size = 4
$T232887 = -544						; size = 4
$T232880 = -540						; size = 4
$T232796 = -489						; size = 1
$T232795 = -488						; size = 4
$T232779 = -484						; size = 4
$T232772 = -480						; size = 4
$T232688 = -432						; size = 4
$T232684 = -428						; size = 4
_i$232680 = -424					; size = 4
$T232667 = -420						; size = 4
$T232660 = -416						; size = 4
_i$232656 = -412					; size = 4
$T232643 = -408						; size = 4
$T232636 = -404						; size = 4
_i$232632 = -400					; size = 4
$T232619 = -396						; size = 4
$T232515 = -344						; size = 4
$T232499 = -340						; size = 4
$T232492 = -336						; size = 4
$T232409 = -285						; size = 1
$T232400 = -284						; size = 4
$T232384 = -280						; size = 4
$T232377 = -276						; size = 4
$T232294 = -228						; size = 4
$T232268 = -224						; size = 4
$T232252 = -220						; size = 4
$T232280 = -216						; size = 4
$T232279 = -212						; size = 4
$T232278 = -208						; size = 4
$T232277 = -204						; size = 4
$T232276 = -200						; size = 4
$T232236 = -196						; size = 8
$T232235 = -188						; size = 8
$T232234 = -180						; size = 4
$T232233 = -176						; size = 8
$T232232 = -168						; size = 8
_temp$222677 = -160					; size = 8
_iResourceLoop$222673 = -152				; size = 4
_jJ$222669 = -148					; size = 4
_iImprovement$222659 = -144				; size = 4
_iUnitClass$222653 = -140				; size = 4
_iResource$222649 = -136				; size = 4
_iTerrain$222645 = -132					; size = 4
_yields$222644 = -128					; size = 24
_iChange$222639 = -104					; size = 4
_iSpecialistLoop$222635 = -100				; size = 4
_yields$222634 = -96					; size = 24
_iChange$222629 = -72					; size = 4
_iImprovementLoop$222625 = -68				; size = 4
_yields$222624 = -64					; size = 24
_iChange$222619 = -40					; size = 4
_iFeatureLoop$222615 = -36				; size = 4
_iYield$222610 = -32					; size = 4
_iWoundedUnitDamageMod$222589 = -28			; size = 4
_trait$222586 = -24					; size = 4
_traitUnit$222665 = -20					; size = 8
_iNumUnitCombatClassInfos$222668 = -12			; size = 4
_iI$222580 = -8						; size = 4
_iI$222570 = -4						; size = 4
?InitPlayerTraits@CvPlayerTraits@@QAEXXZ PROC		; CvPlayerTraits::InitPlayerTraits, COMDAT
; _this$ = ecx

; 1703 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 636				; 0000027cH
	mov	DWORD PTR _this$[ebp], ecx

; 1704 : 
; 1705 : 	// precompute the traits our leader has
; 1706 : 	m_vPotentiallyActiveLeaderTraits.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T232294[ebp], eax
	mov	ecx, DWORD PTR $T232294[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T232252[ebp], edx
	mov	eax, DWORD PTR $T232252[ebp]
	mov	DWORD PTR $T232277[ebp], eax
	mov	ecx, DWORD PTR $T232277[ebp]
	mov	DWORD PTR $T232276[ebp], ecx
	mov	edx, DWORD PTR $T232294[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232268[ebp], eax
	mov	ecx, DWORD PTR $T232268[ebp]
	mov	DWORD PTR $T232279[ebp], ecx
	mov	edx, DWORD PTR $T232279[ebp]
	mov	DWORD PTR $T232278[ebp], edx
	mov	eax, DWORD PTR $T232276[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232278[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232280[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232294[ebp]
	call	?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase

; 1707 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	DWORD PTR _iI$222570[ebp], 0
	jmp	SHORT $LN65@InitPlayer
$LN64@InitPlayer:
	mov	eax, DWORD PTR _iI$222570[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222570[ebp], eax
$LN65@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	DWORD PTR _iI$222570[ebp], eax
	jge	$LN63@InitPlayer

; 1708 : 	{
; 1709 : 		m_vLeaderHasTrait[iI] = false;

	mov	ecx, DWORD PTR _iI$222570[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232232[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T232400[ebp], eax
	xor	eax, eax
	je	SHORT $LN109@InitPlayer
	mov	ecx, DWORD PTR $T232377[ebp]
	mov	DWORD PTR tv951[ebp], ecx
	mov	edx, DWORD PTR $T232400[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv951[ebp], eax
	mov	ecx, DWORD PTR $T232400[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv951[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv951[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN110@InitPlayer
$LN109@InitPlayer:
	mov	edx, DWORD PTR $T232384[ebp]
	mov	DWORD PTR tv964[ebp], edx
	mov	eax, DWORD PTR $T232400[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv964[ebp], ecx
	mov	edx, DWORD PTR $T232400[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv964[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv964[ebp]
	mov	DWORD PTR [edx], eax
$LN110@InitPlayer:

; 1710 : 		if (m_pPlayer && m_pPlayer->isMajorCiv() && m_pPlayer->isAlive() && m_pPlayer->getLeaderInfo().hasTrait( (TraitTypes)iI ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN62@InitPlayer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?isMajorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMajorCiv
	movzx	edx, al
	test	edx, edx
	je	$LN62@InitPlayer
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T232409[ebp], dl
	movzx	eax, BYTE PTR $T232409[ebp]
	test	eax, eax
	je	$LN62@InitPlayer
	mov	ecx, DWORD PTR _iI$222570[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	ecx, eax
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	movzx	eax, al
	test	eax, eax
	je	$LN62@InitPlayer

; 1711 : 		{
; 1712 : 			m_vLeaderHasTrait[iI] = true;

	mov	ecx, DWORD PTR _iI$222570[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232233[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T232515[ebp], eax
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN151@InitPlayer
	mov	ecx, DWORD PTR $T232492[ebp]
	mov	DWORD PTR tv1015[ebp], ecx
	mov	edx, DWORD PTR $T232515[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv1015[ebp], eax
	mov	ecx, DWORD PTR $T232515[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv1015[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1015[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN152@InitPlayer
$LN151@InitPlayer:
	mov	edx, DWORD PTR $T232499[ebp]
	mov	DWORD PTR tv1060[ebp], edx
	mov	eax, DWORD PTR $T232515[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv1060[ebp], ecx
	mov	edx, DWORD PTR $T232515[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv1060[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv1060[ebp]
	mov	DWORD PTR [edx], eax
$LN152@InitPlayer:

; 1713 : 			m_vPotentiallyActiveLeaderTraits.push_back( (TraitTypes)iI );

	mov	eax, DWORD PTR _iI$222570[ebp]
	mov	DWORD PTR $T232234[ebp], eax
	lea	ecx, DWORD PTR $T232234[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
$LN62@InitPlayer:

; 1714 : 		}
; 1715 : 	}

	jmp	$LN64@InitPlayer
$LN63@InitPlayer:

; 1716 : #ifdef AUI_WARNING_FIXES
; 1717 : 	for (uint iI = 0; iI < GC.getNumTraitInfos(); iI++)
; 1718 : #else
; 1719 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	DWORD PTR _iI$222580[ebp], 0
	jmp	SHORT $LN61@InitPlayer
$LN60@InitPlayer:
	mov	edx, DWORD PTR _iI$222580[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$222580[ebp], edx
$LN61@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	DWORD PTR _iI$222580[ebp], eax
	jge	$LN66@InitPlayer

; 1720 : #endif
; 1721 : 
; 1722 : 	{
; 1723 : 		if(HasTrait((TraitTypes)iI))

	mov	eax, DWORD PTR _iI$222580[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	ecx, al
	test	ecx, ecx
	je	$LN58@InitPlayer

; 1724 : 		{
; 1725 : 			CvTraitEntry* trait = GC.getTraitInfo((TraitTypes)iI);

	mov	edx, DWORD PTR _iI$222580[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _trait$222586[ebp], eax

; 1726 : 			m_iGreatPeopleRateModifier += trait->GetGreatPeopleRateModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGreatPeopleRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatPeopleRateModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], eax

; 1727 : 			m_iGreatScientistRateModifier += trait->GetGreatScientistRateModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGreatScientistRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatScientistRateModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+48]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], eax

; 1728 : 			m_iGreatGeneralRateModifier += trait->GetGreatGeneralRateModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGreatGeneralRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatGeneralRateModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax

; 1729 : 			m_iGreatGeneralExtraBonus += trait->GetGreatGeneralExtraBonus();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGreatGeneralExtraBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatGeneralExtraBonus
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], eax

; 1730 : 			m_iGreatPersonGiftInfluence += trait->GetGreatPersonGiftInfluence();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGreatPersonGiftInfluence@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGreatPersonGiftInfluence
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], eax

; 1731 : 			m_iLevelExperienceModifier += trait->GetLevelExperienceModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetLevelExperienceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLevelExperienceModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+64]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], eax

; 1732 : 			m_iMaxGlobalBuildingProductionModifier += trait->GetMaxGlobalBuildingProductionModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetMaxGlobalBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxGlobalBuildingProductionModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+68]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], eax

; 1733 : 			m_iMaxTeamBuildingProductionModifier += trait->GetMaxTeamBuildingProductionModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetMaxTeamBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxTeamBuildingProductionModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], eax

; 1734 : 			m_iMaxPlayerBuildingProductionModifier += trait->GetMaxPlayerBuildingProductionModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetMaxPlayerBuildingProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetMaxPlayerBuildingProductionModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], eax

; 1735 : 			m_iCityUnhappinessModifier += trait->GetCityUnhappinessModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCityUnhappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityUnhappinessModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+80]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], eax

; 1736 : 			m_iPopulationUnhappinessModifier += trait->GetPopulationUnhappinessModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetPopulationUnhappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPopulationUnhappinessModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+84]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], eax

; 1737 : 			m_iCityStateBonusModifier += trait->GetCityStateBonusModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCityStateBonusModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityStateBonusModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], eax

; 1738 : 			m_iCityStateFriendshipModifier += trait->GetCityStateFriendshipModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCityStateFriendshipModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityStateFriendshipModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+92]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], eax

; 1739 : 			m_iCityStateCombatModifier += trait->GetCityStateCombatModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCityStateCombatModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityStateCombatModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+96]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], eax

; 1740 : 			m_iLandBarbarianConversionPercent += trait->GetLandBarbarianConversionPercent();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetLandBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandBarbarianConversionPercent
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], eax

; 1741 : 			m_iLandBarbarianConversionExtraUnits += trait->GetLandBarbarianConversionExtraUnits();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetLandBarbarianConversionExtraUnits@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandBarbarianConversionExtraUnits
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], eax

; 1742 : 			m_iSeaBarbarianConversionPercent += trait->GetSeaBarbarianConversionPercent();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetSeaBarbarianConversionPercent@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetSeaBarbarianConversionPercent
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+108]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], eax

; 1743 : 			m_iCapitalBuildingModifier += trait->GetCapitalBuildingModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCapitalBuildingModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCapitalBuildingModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+112]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], eax

; 1744 : 			m_iPlotBuyCostModifier += trait->GetPlotBuyCostModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetPlotBuyCostModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPlotBuyCostModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], eax

; 1745 : 			m_iPlotCultureCostModifier += trait->GetPlotCultureCostModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetPlotCultureCostModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPlotCultureCostModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+120]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], eax

; 1746 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 1747 : 			m_iSciencePerGreatPersonBorn += trait->GetSciencePerGreatPersonBorn();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetSciencePerGreatPersonBorn@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetSciencePerGreatPersonBorn
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+124]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], eax

; 1748 : #endif
; 1749 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 1750 : 			m_iNumTurnsBeforeMinorAlliesRefuseBribes += trait->GetNumTurnsBeforeMinorAlliesRefuseBribes();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNumTurnsBeforeMinorAlliesRefuseBribes@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNumTurnsBeforeMinorAlliesRefuseBribes
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+128]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], eax

; 1751 : #endif
; 1752 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 1753 : 			m_iGoldenAgeTileBonusFaith += trait->GetGoldenAgeTileBonusFaith();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeTileBonusFaith@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeTileBonusFaith
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], eax

; 1754 : #endif
; 1755 : 			m_iCultureFromKills += trait->GetCultureFromKills();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCultureFromKills@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCultureFromKills
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+136]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], eax

; 1756 : 			m_iFaithFromKills += trait->GetFaithFromKills();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetFaithFromKills@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetFaithFromKills
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+140]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], eax

; 1757 : 			m_iCityCultureBonus += trait->GetCityCultureBonus();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCityCultureBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityCultureBonus
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+144]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], eax

; 1758 : 			m_iCapitalThemingBonusModifier += trait->GetCapitalThemingBonusModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCapitalThemingBonusModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCapitalThemingBonusModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+148]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], eax

; 1759 : 			m_iPolicyCostModifier += trait->GetPolicyCostModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetPolicyCostModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPolicyCostModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+152]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], eax

; 1760 : 			m_iCityConnectionTradeRouteChange += trait->GetCityConnectionTradeRouteChange();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCityConnectionTradeRouteChange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCityConnectionTradeRouteChange
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+156]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], eax

; 1761 : 			m_iWonderProductionModifier += trait->GetWonderProductionModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetWonderProductionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetWonderProductionModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+160], eax

; 1762 : 			m_iPlunderModifier += trait->GetPlunderModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetPlunderModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetPlunderModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+164]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], eax

; 1763 : 			m_iImprovementMaintenanceModifier += trait->GetImprovementMaintenanceModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetImprovementMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetImprovementMaintenanceModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+168]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], eax

; 1764 : 			m_iGoldenAgeDurationModifier += trait->GetGoldenAgeDurationModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeDurationModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeDurationModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+172]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+172], eax

; 1765 : 			m_iGoldenAgeMoveChange += trait->GetGoldenAgeMoveChange();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeMoveChange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeMoveChange
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+176]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+176], eax

; 1766 : 			m_iGoldenAgeCombatModifier += trait->GetGoldenAgeCombatModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeCombatModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeCombatModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+180]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+180], eax

; 1767 : 			m_iGoldenAgeTourismModifier += trait->GetGoldenAgeTourismModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeTourismModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeTourismModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+184]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+184], eax

; 1768 : 			m_iGoldenAgeGreatArtistRateModifier += trait->GetGoldenAgeGreatArtistRateModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeGreatArtistRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatArtistRateModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+188]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+188], eax

; 1769 : 			m_iGoldenAgeGreatMusicianRateModifier += trait->GetGoldenAgeGreatMusicianRateModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeGreatMusicianRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatMusicianRateModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+192]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+192], eax

; 1770 : 			m_iGoldenAgeGreatWriterRateModifier += trait->GetGoldenAgeGreatWriterRateModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetGoldenAgeGreatWriterRateModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetGoldenAgeGreatWriterRateModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+196]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], eax

; 1771 : 			m_iExtraEmbarkMoves += trait->GetExtraEmbarkMoves();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetExtraEmbarkMoves@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetExtraEmbarkMoves
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+200]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+200], eax

; 1772 : 			m_iNaturalWonderFirstFinderGold += trait->GetNaturalWonderFirstFinderGold();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNaturalWonderFirstFinderGold@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderFirstFinderGold
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+204]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+204], eax

; 1773 : 			m_iNaturalWonderSubsequentFinderGold += trait->GetNaturalWonderSubsequentFinderGold();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNaturalWonderSubsequentFinderGold@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderSubsequentFinderGold
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+208]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+208], eax

; 1774 : 		
; 1775 : 			//EAP: Natural wonder faith for the finder
; 1776 : 			m_iNaturalWonderFirstFinderFaith += trait->GetNaturalWonderFirstFinderFaith();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNaturalWonderFirstFinderFaith@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderFirstFinderFaith
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+216]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+216], eax

; 1777 : 			m_iNaturalWonderSubsequentFinderFaith += trait->GetNaturalWonderSubsequentFinderFaith();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNaturalWonderSubsequentFinderFaith@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderSubsequentFinderFaith
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+220]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+220], eax

; 1778 : 
; 1779 : 			m_iNaturalWonderYieldModifier += trait->GetNaturalWonderYieldModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNaturalWonderYieldModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderYieldModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+212]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+212], eax

; 1780 : 			m_iNaturalWonderHappinessModifier += trait->GetNaturalWonderHappinessModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNaturalWonderHappinessModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNaturalWonderHappinessModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+224]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+224], eax

; 1781 : 			m_iNearbyImprovementCombatBonus += trait->GetNearbyImprovementCombatBonus();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNearbyImprovementCombatBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNearbyImprovementCombatBonus
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+228]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+228], eax

; 1782 : 			m_iNearbyImprovementBonusRange += trait->GetNearbyImprovementBonusRange();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNearbyImprovementBonusRange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNearbyImprovementBonusRange
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+232]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+232], eax

; 1783 : 			m_iCultureBuildingYieldChange += trait->GetCultureBuildingYieldChange();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCultureBuildingYieldChange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCultureBuildingYieldChange
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+236]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], eax

; 1784 : 			m_iCombatBonusVsHigherTech += trait->GetCombatBonusVsHigherTech();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCombatBonusVsHigherTech@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCombatBonusVsHigherTech
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+240]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+240], eax

; 1785 : 			m_iCombatBonusVsLargerCiv += trait->GetCombatBonusVsLargerCiv();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCombatBonusVsLargerCiv@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetCombatBonusVsLargerCiv
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+244]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+244], eax

; 1786 : 			m_iLandUnitMaintenanceModifier += trait->GetLandUnitMaintenanceModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetLandUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandUnitMaintenanceModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+248]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+248], eax

; 1787 : 			m_iNavalUnitMaintenanceModifier += trait->GetNavalUnitMaintenanceModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNavalUnitMaintenanceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNavalUnitMaintenanceModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+252]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+252], eax

; 1788 : 			m_iRazeSpeedModifier += trait->GetRazeSpeedModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetRazeSpeedModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetRazeSpeedModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+256]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+256], eax

; 1789 : 			m_iDOFGreatPersonModifier += trait->GetDOFGreatPersonModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetDOFGreatPersonModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetDOFGreatPersonModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+260]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+260], eax

; 1790 : 			m_iLuxuryHappinessRetention += trait->GetLuxuryHappinessRetention();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetLuxuryHappinessRetention@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLuxuryHappinessRetention
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+264]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], eax

; 1791 : 			m_iExtraHappinessPerLuxury += trait->GetExtraHappinessPerLuxury(); // NQMP GJS - New Netherlands UA

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetExtraHappinessPerLuxury@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetExtraHappinessPerLuxury
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+268]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+268], eax

; 1792 : 			m_iExtraSpies += trait->GetExtraSpies();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetExtraSpies@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetExtraSpies
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+272]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 1793 : 			m_iHappinessPerReligion += trait->GetHappinessPerReligion(); // NQMP GJS - New Ottoman UA

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetHappinessPerReligion@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetHappinessPerReligion
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+276]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], eax

; 1794 : 			m_iUnresearchedTechBonusFromKills += trait->GetUnresearchedTechBonusFromKills();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetUnresearchedTechBonusFromKills@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetUnresearchedTechBonusFromKills
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+280]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+280], eax

; 1795 : 			m_iExtraFoundedCityTerritoryClaimRange += trait->GetExtraFoundedCityTerritoryClaimRange();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetExtraFoundedCityTerritoryClaimRange@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetExtraFoundedCityTerritoryClaimRange
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+284]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], eax

; 1796 : 			m_iFreeSocialPoliciesPerEra += trait->GetFreeSocialPoliciesPerEra();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetFreeSocialPoliciesPerEra@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetFreeSocialPoliciesPerEra
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+288]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], eax

; 1797 : 			m_iNumTradeRoutesModifier += trait->GetNumTradeRoutesModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetNumTradeRoutesModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetNumTradeRoutesModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+292]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], eax

; 1798 : 			m_iTradeRouteResourceModifier += trait->GetTradeRouteResourceModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetTradeRouteResourceModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetTradeRouteResourceModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+296]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+296], eax

; 1799 : 			m_iUniqueLuxuryCities += trait->GetUniqueLuxuryCities();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetUniqueLuxuryCities@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetUniqueLuxuryCities
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+300]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], eax

; 1800 : 			m_iUniqueLuxuryQuantity	+= trait->GetUniqueLuxuryQuantity();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetUniqueLuxuryQuantity@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetUniqueLuxuryQuantity
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+304]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], eax

; 1801 : 			m_iWorkerSpeedModifier += trait->GetWorkerSpeedModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetWorkerSpeedModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetWorkerSpeedModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+312]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], eax

; 1802 : 			m_iAfraidMinorPerTurnInfluence += trait->GetAfraidMinorPerTurnInfluence();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetAfraidMinorPerTurnInfluence@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetAfraidMinorPerTurnInfluence
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+316]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+316], eax

; 1803 : 			m_iLandTradeRouteRangeBonus += trait->GetLandTradeRouteRangeBonus();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetLandTradeRouteRangeBonus@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetLandTradeRouteRangeBonus
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+320]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+320], eax

; 1804 : 			m_iTradeReligionModifier += trait->GetTradeReligionModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetTradeReligionModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetTradeReligionModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+324]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], eax

; 1805 : 			m_iTradeBuildingModifier += trait->GetTradeBuildingModifier();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetTradeBuildingModifier@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetTradeBuildingModifier
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+328]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], eax

; 1806 : 
; 1807 : 			if(trait->IsFightWellDamaged())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsFightWellDamaged@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsFightWellDamaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@InitPlayer

; 1808 : 			{
; 1809 : 				m_bFightWellDamaged = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+332], 1

; 1810 : 				// JON: Changing the way this works. Above line can/should probably be removed at some point
; 1811 : 				int iWoundedUnitDamageMod = /*-50*/ GC.getTRAIT_WOUNDED_DAMAGE_MOD();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7460
	mov	DWORD PTR _iWoundedUnitDamageMod$222589[ebp], edx

; 1812 : 				m_pPlayer->ChangeWoundedUnitDamageMod(iWoundedUnitDamageMod);

	mov	eax, DWORD PTR _iWoundedUnitDamageMod$222589[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?ChangeWoundedUnitDamageMod@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeWoundedUnitDamageMod
$LN57@InitPlayer:

; 1813 : 			}
; 1814 : 			if(trait->IsMoveFriendlyWoodsAsRoad())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsMoveFriendlyWoodsAsRoad@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsMoveFriendlyWoodsAsRoad
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN56@InitPlayer

; 1815 : 			{
; 1816 : 				m_bMoveFriendlyWoodsAsRoad = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+333], 1
$LN56@InitPlayer:

; 1817 : 			}
; 1818 : 			if(trait->IsFasterAlongRiver())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsFasterAlongRiver@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsFasterAlongRiver
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@InitPlayer

; 1819 : 			{
; 1820 : 				m_bFasterAlongRiver = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+334], 1
$LN55@InitPlayer:

; 1821 : 			}
; 1822 : 			if(trait->IsFasterInHills())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsFasterInHills@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsFasterInHills
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN54@InitPlayer

; 1823 : 			{
; 1824 : 				m_bFasterInHills = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+335], 1
$LN54@InitPlayer:

; 1825 : 			}
; 1826 : 			if(trait->IsEmbarkedAllWater())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsEmbarkedAllWater@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsEmbarkedAllWater
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN53@InitPlayer

; 1827 : 			{
; 1828 : 				m_bEmbarkedAllWater = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+336], 1
$LN53@InitPlayer:

; 1829 : 			}
; 1830 : 			if(trait->IsEmbarkedToLandFlatCost())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsEmbarkedToLandFlatCost@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsEmbarkedToLandFlatCost
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN52@InitPlayer

; 1831 : 			{
; 1832 : 				m_bEmbarkedToLandFlatCost = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+337], 1
$LN52@InitPlayer:

; 1833 : 			}
; 1834 : 			if(trait->IsNoHillsImprovementMaintenance())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsNoHillsImprovementMaintenance@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsNoHillsImprovementMaintenance
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN51@InitPlayer

; 1835 : 			{
; 1836 : 				m_bNoHillsImprovementMaintenance = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+338], 1
$LN51@InitPlayer:

; 1837 : 			}
; 1838 : 			if(trait->IsTechBoostFromCapitalScienceBuildings())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsTechBoostFromCapitalScienceBuildings@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsTechBoostFromCapitalScienceBuildings
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN50@InitPlayer

; 1839 : 			{
; 1840 : 				m_bTechBoostFromCapitalScienceBuildings = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+339], 1
$LN50@InitPlayer:

; 1841 : 			}
; 1842 : 			if(trait->IsStaysAliveZeroCities())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsStaysAliveZeroCities@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsStaysAliveZeroCities
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN49@InitPlayer

; 1843 : 			{
; 1844 : 				m_bStaysAliveZeroCities = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+340], 1
$LN49@InitPlayer:

; 1845 : 			}
; 1846 : 			if(trait->IsFaithFromUnimprovedForest())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsFaithFromUnimprovedForest@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsFaithFromUnimprovedForest
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN48@InitPlayer

; 1847 : 			{
; 1848 : 				m_bFaithFromUnimprovedForest = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+341], 1
$LN48@InitPlayer:

; 1849 : 			}
; 1850 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 1851 : 			if(trait->IsSeaTradeRoutesArePlunderImmune())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsSeaTradeRoutesArePlunderImmune@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsSeaTradeRoutesArePlunderImmune
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN47@InitPlayer

; 1852 : 			{
; 1853 : 				m_bSeaTradeRoutesArePlunderImmune = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+342], 1
$LN47@InitPlayer:

; 1854 : 			}
; 1855 : #endif
; 1856 : 			// NQMP GJS - New France UA begin
; 1857 : 			if(trait->IsEarnsGreatPersonOnSlotOrGuild())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsEarnsGreatPersonOnSlotOrGuild@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsEarnsGreatPersonOnSlotOrGuild
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN46@InitPlayer

; 1858 : 			{
; 1859 : 				m_bEarnsGreatPersonOnSlotOrGuild = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+343], 1
$LN46@InitPlayer:

; 1860 : 			}
; 1861 : 			// NQMP GJS - New France UA end
; 1862 : 			if(trait->IsBonusReligiousBelief())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsBonusReligiousBelief@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsBonusReligiousBelief
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN45@InitPlayer

; 1863 : 			{
; 1864 : 				m_bBonusReligiousBelief = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+347], 1
$LN45@InitPlayer:

; 1865 : 			}
; 1866 : 			if(trait->IsAbleToAnnexCityStates())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsAbleToAnnexCityStates@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsAbleToAnnexCityStates
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN44@InitPlayer

; 1867 : 			{
; 1868 : 				m_bAbleToAnnexCityStates = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+348], 1
$LN44@InitPlayer:

; 1869 : 			}
; 1870 : 			if(trait->IsCrossesMountainsAfterGreatGeneral())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsCrossesMountainsAfterGreatGeneral@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsCrossesMountainsAfterGreatGeneral
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN43@InitPlayer

; 1871 : 			{
; 1872 : 				m_bCrossesMountainsAfterGreatGeneral = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+349], 1
$LN43@InitPlayer:

; 1873 : 			}
; 1874 : 			if(trait->IsMayaCalendarBonuses())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsMayaCalendarBonuses
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN42@InitPlayer

; 1875 : 			{
; 1876 : 				m_bMayaCalendarBonuses = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+350], 1
$LN42@InitPlayer:

; 1877 : 			}
; 1878 : 			if (trait->IsNoAnnexing())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsNoAnnexing@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsNoAnnexing
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN41@InitPlayer

; 1879 : 			{
; 1880 : 				m_bNoAnnexing = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+351], 1
$LN41@InitPlayer:

; 1881 : 			}
; 1882 : 			if (trait->IsTechFromCityConquer())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsTechFromCityConquer@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsTechFromCityConquer
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN40@InitPlayer

; 1883 : 			{
; 1884 : 				m_bTechFromCityConquer = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+352], 1
$LN40@InitPlayer:

; 1885 : 			}
; 1886 : 			if (trait->IsUniqueLuxuryRequiresNewArea())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsUniqueLuxuryRequiresNewArea@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsUniqueLuxuryRequiresNewArea
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN39@InitPlayer

; 1887 : 			{
; 1888 : 				m_bUniqueLuxuryRequiresNewArea = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+353], 1
$LN39@InitPlayer:

; 1889 : 			}
; 1890 : 			if (trait->IsRiverTradeRoad())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsRiverTradeRoad@CvTraitEntry@@QBE_NXZ	; CvTraitEntry::IsRiverTradeRoad
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN38@InitPlayer

; 1891 : 			{
; 1892 : 				m_bRiverTradeRoad = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+354], 1
$LN38@InitPlayer:

; 1893 : 			}
; 1894 : 			if (trait->IsAngerFreeIntrusionOfCityStates())

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?IsAngerFreeIntrusionOfCityStates@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsAngerFreeIntrusionOfCityStates
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN37@InitPlayer

; 1895 : 			{
; 1896 : 				m_bAngerFreeIntrusionOfCityStates = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+355], 1
$LN37@InitPlayer:

; 1897 : 			}
; 1898 : 
; 1899 : 			for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$222610[ebp], 0
	jmp	SHORT $LN36@InitPlayer
$LN35@InitPlayer:
	mov	eax, DWORD PTR _iYield$222610[ebp]
	add	eax, 1
	mov	DWORD PTR _iYield$222610[ebp], eax
$LN36@InitPlayer:
	cmp	DWORD PTR _iYield$222610[ebp], 6
	jge	$LN34@InitPlayer

; 1900 : 			{
; 1901 : 				if(trait->GetExtraYieldThreshold(iYield) > m_iExtraYieldThreshold[iYield])

	mov	ecx, DWORD PTR _iYield$222610[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetExtraYieldThreshold
	mov	edx, DWORD PTR _iYield$222610[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+edx*4+384]
	jle	SHORT $LN33@InitPlayer

; 1902 : 				{
; 1903 : 					m_iExtraYieldThreshold[iYield] = trait->GetExtraYieldThreshold(iYield);

	mov	edx, DWORD PTR _iYield$222610[ebp]
	push	edx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetExtraYieldThreshold@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetExtraYieldThreshold
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+384], eax
$LN33@InitPlayer:

; 1904 : 				}
; 1905 : 				m_iFreeCityYield[iYield] = trait->GetYieldChange(iYield);

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetYieldChange@CvTraitEntry@@QBEHH@Z	; CvTraitEntry::GetYieldChange
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+408], eax

; 1906 : 				m_iYieldChangeStrategicResources[iYield] = trait->GetYieldChangeStrategicResources(iYield);

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetYieldChangeStrategicResources@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeStrategicResources
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+432], eax

; 1907 : 				m_iYieldChangeLuxuryResources[iYield] = trait->GetYieldChangeLuxuryResources(iYield); // NQMP GJS - New Netherlands UA

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetYieldChangeLuxuryResources@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeLuxuryResources
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+456], eax

; 1908 : 				m_iYieldChangeNaturalWonder[iYield] = trait->GetYieldChangeNaturalWonder(iYield);

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetYieldChangeNaturalWonder@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeNaturalWonder
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+480], eax

; 1909 : 				m_iYieldChangePerTradePartner[iYield] = trait->GetYieldChangePerTradePartner(iYield);

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetYieldChangePerTradePartner@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangePerTradePartner
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+504], eax

; 1910 : 				m_iYieldChangeIncomingTradeRoute[iYield] = trait->GetYieldChangeIncomingTradeRoute(iYield);

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetYieldChangeIncomingTradeRoute@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetYieldChangeIncomingTradeRoute
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+528], eax

; 1911 : 				m_iYieldRateModifier[iYield] = trait->GetYieldModifier(iYield);

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetYieldModifier@CvTraitEntry@@QBEHH@Z	; CvTraitEntry::GetYieldModifier
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+552], eax

; 1912 : 
; 1913 : #ifdef AUI_WARNING_FIXES
; 1914 : 				for (uint iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
; 1915 : #else
; 1916 : 				for(int iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)

	mov	DWORD PTR _iFeatureLoop$222615[ebp], 0
	jmp	SHORT $LN32@InitPlayer
$LN31@InitPlayer:
	mov	eax, DWORD PTR _iFeatureLoop$222615[ebp]
	add	eax, 1
	mov	DWORD PTR _iFeatureLoop$222615[ebp], eax
$LN32@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	DWORD PTR _iFeatureLoop$222615[ebp], eax
	jge	$LN30@InitPlayer

; 1917 : #endif
; 1918 : 				{
; 1919 : 					int iChange = trait->GetUnimprovedFeatureYieldChanges((FeatureTypes)iFeatureLoop, (YieldTypes)iYield);

	mov	ecx, DWORD PTR _iYield$222610[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFeatureLoop$222615[ebp]
	push	edx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetUnimprovedFeatureYieldChanges@CvTraitEntry@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetUnimprovedFeatureYieldChanges
	mov	DWORD PTR _iChange$222619[ebp], eax

; 1920 : 					if(iChange > 0)

	cmp	DWORD PTR _iChange$222619[ebp], 0
	jle	$LN29@InitPlayer

; 1921 : 					{
; 1922 : 						Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiUnimprovedFeatureYieldChange[iFeatureLoop];

	mov	eax, DWORD PTR _iFeatureLoop$222615[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+848]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _yields$222624[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _yields$222624[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _yields$222624[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _yields$222624[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _yields$222624[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR _yields$222624[ebp+20], ecx

; 1923 : 						yields[iYield] = (m_ppaaiUnimprovedFeatureYieldChange[iFeatureLoop][iYield] + iChange);

	mov	edx, DWORD PTR _iFeatureLoop$222615[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+848]
	mov	DWORD PTR $T232619[ebp], edx
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	edx, DWORD PTR $T232619[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	add	eax, DWORD PTR _iChange$222619[ebp]
	mov	ecx, DWORD PTR _iYield$222610[ebp]
	mov	DWORD PTR _yields$222624[ebp+ecx*4], eax

; 1924 : 						m_ppaaiUnimprovedFeatureYieldChange[iFeatureLoop] = yields;

	mov	edx, DWORD PTR _iFeatureLoop$222615[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+848]
	mov	DWORD PTR $T232636[ebp], edx
	mov	DWORD PTR _i$232632[ebp], 0
	jmp	SHORT $LN220@InitPlayer
$LN219@InitPlayer:
	mov	ecx, DWORD PTR _i$232632[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$232632[ebp], ecx
$LN220@InitPlayer:
	cmp	DWORD PTR _i$232632[ebp], 6
	jae	SHORT $LN29@InitPlayer
	mov	edx, DWORD PTR _i$232632[ebp]
	mov	eax, DWORD PTR $T232636[ebp]
	mov	ecx, DWORD PTR _i$232632[ebp]
	mov	ecx, DWORD PTR _yields$222624[ebp+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN219@InitPlayer
$LN29@InitPlayer:

; 1925 : 					}
; 1926 : 				}

	jmp	$LN31@InitPlayer
$LN30@InitPlayer:

; 1927 : 
; 1928 : #ifdef AUI_WARNING_FIXES
; 1929 : 				for (uint iImprovementLoop = 0; iImprovementLoop < GC.getNumImprovementInfos(); iImprovementLoop++)
; 1930 : #else
; 1931 : 				for(int iImprovementLoop = 0; iImprovementLoop < GC.getNumImprovementInfos(); iImprovementLoop++)

	mov	DWORD PTR _iImprovementLoop$222625[ebp], 0
	jmp	SHORT $LN28@InitPlayer
$LN27@InitPlayer:
	mov	edx, DWORD PTR _iImprovementLoop$222625[ebp]
	add	edx, 1
	mov	DWORD PTR _iImprovementLoop$222625[ebp], edx
$LN28@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iImprovementLoop$222625[ebp], eax
	jge	$LN26@InitPlayer

; 1932 : #endif
; 1933 : 				{
; 1934 : 					int iChange = trait->GetImprovementYieldChanges((ImprovementTypes)iImprovementLoop, (YieldTypes)iYield);

	mov	eax, DWORD PTR _iYield$222610[ebp]
	push	eax
	mov	ecx, DWORD PTR _iImprovementLoop$222625[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetImprovementYieldChanges@CvTraitEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetImprovementYieldChanges
	mov	DWORD PTR _iChange$222629[ebp], eax

; 1935 : 					if(iChange > 0)

	cmp	DWORD PTR _iChange$222629[ebp], 0
	jle	$LN25@InitPlayer

; 1936 : 					{
; 1937 : 						Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiImprovementYieldChange[iImprovementLoop];

	mov	edx, DWORD PTR _iImprovementLoop$222625[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+816]
	add	ecx, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _yields$222634[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _yields$222634[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _yields$222634[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _yields$222634[ebp+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _yields$222634[ebp+16], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _yields$222634[ebp+20], eax

; 1938 : 						yields[iYield] = (m_ppaaiImprovementYieldChange[iImprovementLoop][iYield] + iChange);

	mov	ecx, DWORD PTR _iImprovementLoop$222625[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+816]
	mov	DWORD PTR $T232643[ebp], ecx
	mov	eax, DWORD PTR _iYield$222610[ebp]
	mov	ecx, DWORD PTR $T232643[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, DWORD PTR _iChange$222629[ebp]
	mov	eax, DWORD PTR _iYield$222610[ebp]
	mov	DWORD PTR _yields$222634[ebp+eax*4], edx

; 1939 : 						m_ppaaiImprovementYieldChange[iImprovementLoop] = yields;

	mov	ecx, DWORD PTR _iImprovementLoop$222625[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+816]
	mov	DWORD PTR $T232660[ebp], ecx
	mov	DWORD PTR _i$232656[ebp], 0
	jmp	SHORT $LN235@InitPlayer
$LN234@InitPlayer:
	mov	eax, DWORD PTR _i$232656[ebp]
	add	eax, 1
	mov	DWORD PTR _i$232656[ebp], eax
$LN235@InitPlayer:
	cmp	DWORD PTR _i$232656[ebp], 6
	jae	SHORT $LN25@InitPlayer
	mov	ecx, DWORD PTR _i$232656[ebp]
	mov	edx, DWORD PTR $T232660[ebp]
	mov	eax, DWORD PTR _i$232656[ebp]
	mov	eax, DWORD PTR _yields$222634[ebp+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN234@InitPlayer
$LN25@InitPlayer:

; 1940 : 					}
; 1941 : 				}

	jmp	$LN27@InitPlayer
$LN26@InitPlayer:

; 1942 : 
; 1943 : #ifdef AUI_WARNING_FIXES
; 1944 : 				for (uint iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)
; 1945 : #else
; 1946 : 				for(int iSpecialistLoop = 0; iSpecialistLoop < GC.getNumSpecialistInfos(); iSpecialistLoop++)

	mov	DWORD PTR _iSpecialistLoop$222635[ebp], 0
	jmp	SHORT $LN24@InitPlayer
$LN23@InitPlayer:
	mov	ecx, DWORD PTR _iSpecialistLoop$222635[ebp]
	add	ecx, 1
	mov	DWORD PTR _iSpecialistLoop$222635[ebp], ecx
$LN24@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	DWORD PTR _iSpecialistLoop$222635[ebp], eax
	jge	$LN22@InitPlayer

; 1947 : #endif
; 1948 : 				{
; 1949 : 					int iChange = trait->GetSpecialistYieldChanges((SpecialistTypes)iSpecialistLoop, (YieldTypes)iYield);

	mov	edx, DWORD PTR _iYield$222610[ebp]
	push	edx
	mov	eax, DWORD PTR _iSpecialistLoop$222635[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetSpecialistYieldChanges@CvTraitEntry@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvTraitEntry::GetSpecialistYieldChanges
	mov	DWORD PTR _iChange$222639[ebp], eax

; 1950 : 					if(iChange > 0)

	cmp	DWORD PTR _iChange$222639[ebp], 0
	jle	$LN21@InitPlayer

; 1951 : 					{
; 1952 : 						Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiSpecialistYieldChange[iSpecialistLoop];

	mov	ecx, DWORD PTR _iSpecialistLoop$222635[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+832]
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _yields$222644[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _yields$222644[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _yields$222644[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _yields$222644[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _yields$222644[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _yields$222644[ebp+20], edx

; 1953 : 						yields[iYield] = (m_ppaaiSpecialistYieldChange[iSpecialistLoop][iYield] + iChange);

	mov	eax, DWORD PTR _iSpecialistLoop$222635[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+832]
	mov	DWORD PTR $T232667[ebp], eax
	mov	edx, DWORD PTR _iYield$222610[ebp]
	mov	eax, DWORD PTR $T232667[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, DWORD PTR _iChange$222639[ebp]
	mov	edx, DWORD PTR _iYield$222610[ebp]
	mov	DWORD PTR _yields$222644[ebp+edx*4], ecx

; 1954 : 						m_ppaaiSpecialistYieldChange[iSpecialistLoop] = yields;

	mov	eax, DWORD PTR _iSpecialistLoop$222635[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+832]
	mov	DWORD PTR $T232684[ebp], eax
	mov	DWORD PTR _i$232680[ebp], 0
	jmp	SHORT $LN250@InitPlayer
$LN249@InitPlayer:
	mov	edx, DWORD PTR _i$232680[ebp]
	add	edx, 1
	mov	DWORD PTR _i$232680[ebp], edx
$LN250@InitPlayer:
	cmp	DWORD PTR _i$232680[ebp], 6
	jae	SHORT $LN21@InitPlayer
	mov	eax, DWORD PTR _i$232680[ebp]
	mov	ecx, DWORD PTR $T232684[ebp]
	mov	edx, DWORD PTR _i$232680[ebp]
	mov	edx, DWORD PTR _yields$222644[ebp+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN249@InitPlayer
$LN21@InitPlayer:

; 1955 : 					}
; 1956 : 				}

	jmp	$LN23@InitPlayer
$LN22@InitPlayer:

; 1957 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 1958 : 				for(int iSpecialistLoop = 0; iSpecialistLoop < 2; iSpecialistLoop++)
; 1959 : 
; 1960 : 				{
; 1961 : 					int iChange = trait->GetAnySpecificSpecialistYieldChanges((SpecialistTypes)iSpecialistLoop, (YieldTypes)iYield);
; 1962 : 					if(iChange > 0)
; 1963 : 					{
; 1964 : 						Firaxis::Array<int, NUM_YIELD_TYPES> yields = m_ppaaiAnySpecificSpecialistYieldChange[iSpecialistLoop];
; 1965 : 						yields[iYield] = (m_ppaaiAnySpecificSpecialistYieldChange[iSpecialistLoop][iYield] + iChange);
; 1966 : 						m_ppaaiAnySpecificSpecialistYieldChange[iSpecialistLoop] = yields;
; 1967 : 					}
; 1968 : 				}
; 1969 : #endif
; 1970 : 			}

	jmp	$LN35@InitPlayer
$LN34@InitPlayer:

; 1971 : 			CvAssert(GC.getNumTerrainInfos() <= NUM_TERRAIN_TYPES);
; 1972 : #ifdef AUI_WARNING_FIXES
; 1973 : 			for (uint iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)
; 1974 : #else
; 1975 : 			for(int iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)

	mov	DWORD PTR _iTerrain$222645[ebp], 0
	jmp	SHORT $LN20@InitPlayer
$LN19@InitPlayer:
	mov	eax, DWORD PTR _iTerrain$222645[ebp]
	add	eax, 1
	mov	DWORD PTR _iTerrain$222645[ebp], eax
$LN20@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	DWORD PTR _iTerrain$222645[ebp], eax
	jge	SHORT $LN18@InitPlayer

; 1976 : #endif
; 1977 : 			{
; 1978 : 				m_iStrategicResourceQuantityModifier[iTerrain] = trait->GetStrategicResourceQuantityModifier(iTerrain);

	mov	ecx, DWORD PTR _iTerrain$222645[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetStrategicResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetStrategicResourceQuantityModifier
	mov	edx, DWORD PTR _iTerrain$222645[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+576], eax

; 1979 : 			}

	jmp	SHORT $LN19@InitPlayer
$LN18@InitPlayer:

; 1980 : 
; 1981 : #ifdef AUI_WARNING_FIXES
; 1982 : 			for (uint iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)
; 1983 : #else
; 1984 : 			for(int iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)

	mov	DWORD PTR _iResource$222649[ebp], 0
	jmp	SHORT $LN17@InitPlayer
$LN16@InitPlayer:
	mov	edx, DWORD PTR _iResource$222649[ebp]
	add	edx, 1
	mov	DWORD PTR _iResource$222649[ebp], edx
$LN17@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResource$222649[ebp], eax
	jge	SHORT $LN15@InitPlayer

; 1985 : #endif
; 1986 : 			{
; 1987 : 				m_aiResourceQuantityModifier[iResource] = trait->GetResourceQuantityModifier(iResource);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+616]
	mov	edx, DWORD PTR _iResource$222649[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T232688[ebp], eax
	mov	ecx, DWORD PTR _iResource$222649[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetResourceQuantityModifier@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetResourceQuantityModifier
	mov	edx, DWORD PTR $T232688[ebp]
	mov	DWORD PTR [edx], eax

; 1988 : 			}

	jmp	SHORT $LN16@InitPlayer
$LN15@InitPlayer:

; 1989 : 
; 1990 : #ifdef AUI_WARNING_FIXES
; 1991 : 			for (uint iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)
; 1992 : #else
; 1993 : 			for (int iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)

	mov	DWORD PTR _iUnitClass$222653[ebp], 0
	jmp	SHORT $LN14@InitPlayer
$LN13@InitPlayer:
	mov	eax, DWORD PTR _iUnitClass$222653[ebp]
	add	eax, 1
	mov	DWORD PTR _iUnitClass$222653[ebp], eax
$LN14@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iUnitClass$222653[ebp], eax
	jge	$LN12@InitPlayer

; 1994 : #endif
; 1995 : 			{
; 1996 : 				m_abNoTrain[iUnitClass] = trait->NoTrain((UnitClassTypes)iUnitClass);

	mov	ecx, DWORD PTR _iUnitClass$222653[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?NoTrain@CvTraitEntry@@QAE_NW4UnitClassTypes@@@Z ; CvTraitEntry::NoTrain
	mov	BYTE PTR $T232796[ebp], al
	mov	edx, DWORD PTR _iUnitClass$222653[ebp]
	push	edx
	lea	eax, DWORD PTR $T232235[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T232795[ebp], eax
	movzx	ecx, BYTE PTR $T232796[ebp]
	test	ecx, ecx
	je	SHORT $LN289@InitPlayer
	mov	edx, DWORD PTR $T232772[ebp]
	mov	DWORD PTR tv1168[ebp], edx
	mov	eax, DWORD PTR $T232795[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv1168[ebp], ecx
	mov	edx, DWORD PTR $T232795[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	mov	ecx, DWORD PTR tv1168[ebp]
	or	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv1168[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN290@InitPlayer
$LN289@InitPlayer:
	mov	eax, DWORD PTR $T232779[ebp]
	mov	DWORD PTR tv1218[ebp], eax
	mov	ecx, DWORD PTR $T232795[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv1218[ebp], edx
	mov	eax, DWORD PTR $T232795[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR tv1218[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1218[ebp]
	mov	DWORD PTR [ecx], edx
$LN290@InitPlayer:

; 1997 : 			}

	jmp	$LN13@InitPlayer
$LN12@InitPlayer:

; 1998 : 
; 1999 : 			//EAP: No Build
; 2000 : 			for (int iImprovement = 0; iImprovement < GC.getNumImprovementInfos(); iImprovement++)

	mov	DWORD PTR _iImprovement$222659[ebp], 0
	jmp	SHORT $LN11@InitPlayer
$LN10@InitPlayer:
	mov	edx, DWORD PTR _iImprovement$222659[ebp]
	add	edx, 1
	mov	DWORD PTR _iImprovement$222659[ebp], edx
$LN11@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iImprovement$222659[ebp], eax
	jge	$LN9@InitPlayer

; 2001 : 			{
; 2002 : 				m_abNoBuild[iImprovement] = trait->NoBuild((ImprovementTypes)iImprovement);

	mov	eax, DWORD PTR _iImprovement$222659[ebp]
	push	eax
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?NoBuild@CvTraitEntry@@QAE_NW4ImprovementTypes@@@Z ; CvTraitEntry::NoBuild
	mov	BYTE PTR $T232904[ebp], al
	mov	ecx, DWORD PTR _iImprovement$222659[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232236[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T232903[ebp], eax
	movzx	eax, BYTE PTR $T232904[ebp]
	test	eax, eax
	je	SHORT $LN334@InitPlayer
	mov	ecx, DWORD PTR $T232880[ebp]
	mov	DWORD PTR tv1268[ebp], ecx
	mov	edx, DWORD PTR $T232903[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv1268[ebp], eax
	mov	ecx, DWORD PTR $T232903[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv1268[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv1268[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN335@InitPlayer
$LN334@InitPlayer:
	mov	edx, DWORD PTR $T232887[ebp]
	mov	DWORD PTR tv1318[ebp], edx
	mov	eax, DWORD PTR $T232903[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv1318[ebp], ecx
	mov	edx, DWORD PTR $T232903[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv1318[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv1318[ebp]
	mov	DWORD PTR [edx], eax
$LN335@InitPlayer:

; 2003 : 			}

	jmp	$LN10@InitPlayer
$LN9@InitPlayer:

; 2004 : 
; 2005 : 			FreeTraitUnit traitUnit;
; 2006 : #ifdef AUI_WARNING_FIXES
; 2007 : 			traitUnit.m_iFreeUnit = (UnitClassTypes)trait->GetFreeUnitClassType();
; 2008 : #else
; 2009 : 			traitUnit.m_iFreeUnit = (UnitTypes)trait->GetFreeUnitClassType();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetFreeUnitClassType@CvTraitEntry@@QBEHXZ ; CvTraitEntry::GetFreeUnitClassType
	mov	DWORD PTR _traitUnit$222665[ebp], eax

; 2010 : #endif
; 2011 : 			if(traitUnit.m_iFreeUnit != NO_UNITCLASS)

	cmp	DWORD PTR _traitUnit$222665[ebp], -1
	je	SHORT $LN8@InitPlayer

; 2012 : 			{
; 2013 : 				traitUnit.m_ePrereqTech = trait->GetFreeUnitPrereqTech();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeUnitPrereqTech
	mov	DWORD PTR _traitUnit$222665[ebp+4], eax

; 2014 : 				m_aFreeTraitUnits.push_back(traitUnit);

	lea	eax, DWORD PTR _traitUnit$222665[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 668				; 0000029cH
	call	?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back
$LN8@InitPlayer:

; 2015 : 			}
; 2016 : 
; 2017 : 			m_eCombatBonusImprovement = trait->GetCombatBonusImprovement();

	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetCombatBonusImprovement@CvTraitEntry@@QBE?AW4ImprovementTypes@@XZ ; CvTraitEntry::GetCombatBonusImprovement
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+368], eax

; 2018 : 
; 2019 : #ifdef AUI_WARNING_FIXES
; 2020 : 			for (uint jJ = 0; jJ < GC.getNumUnitCombatClassInfos(); jJ++)
; 2021 : #else
; 2022 : 			int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	mov	DWORD PTR _iNumUnitCombatClassInfos$222668[ebp], eax

; 2023 : 			for(int jJ= 0; jJ < iNumUnitCombatClassInfos; jJ++)

	mov	DWORD PTR _jJ$222669[ebp], 0
	jmp	SHORT $LN7@InitPlayer
$LN6@InitPlayer:
	mov	edx, DWORD PTR _jJ$222669[ebp]
	add	edx, 1
	mov	DWORD PTR _jJ$222669[ebp], edx
$LN7@InitPlayer:
	mov	eax, DWORD PTR _jJ$222669[ebp]
	cmp	eax, DWORD PTR _iNumUnitCombatClassInfos$222668[ebp]
	jge	SHORT $LN5@InitPlayer

; 2024 : #endif
; 2025 : 			{
; 2026 : 				m_paiMovesChangeUnitCombat[jJ] += trait->GetMovesChangeUnitCombat(jJ);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+784]
	mov	eax, DWORD PTR _jJ$222669[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv837[ebp], ecx
	mov	edx, DWORD PTR _jJ$222669[ebp]
	push	edx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetMovesChangeUnitCombat@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetMovesChangeUnitCombat
	mov	ecx, DWORD PTR tv837[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv837[ebp]
	mov	DWORD PTR [edx], eax

; 2027 : 				m_paiMaintenanceModifierUnitCombat[jJ] += trait->GetMaintenanceModifierUnitCombat(jJ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	edx, DWORD PTR _jJ$222669[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv846[ebp], eax
	mov	ecx, DWORD PTR _jJ$222669[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetMaintenanceModifierUnitCombat@CvTraitEntry@@QBEHH@Z ; CvTraitEntry::GetMaintenanceModifierUnitCombat
	mov	edx, DWORD PTR tv846[ebp]
	add	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv846[ebp]
	mov	DWORD PTR [ecx], eax

; 2028 : 			}

	jmp	$LN6@InitPlayer
$LN5@InitPlayer:

; 2029 : 
; 2030 : #ifdef AUI_WARNING_FIXES
; 2031 : 			for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2032 : #else
; 2033 : 			for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$222673[ebp], 0
	jmp	SHORT $LN4@InitPlayer
$LN3@InitPlayer:
	mov	edx, DWORD PTR _iResourceLoop$222673[ebp]
	add	edx, 1
	mov	DWORD PTR _iResourceLoop$222673[ebp], edx
$LN4@InitPlayer:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222673[ebp], eax
	jge	SHORT $LN58@InitPlayer

; 2034 : #endif
; 2035 : 			{
; 2036 : 				FreeResourceXCities temp = trait->GetFreeResourceXCities((ResourceTypes)iResourceLoop);

	mov	eax, DWORD PTR _iResourceLoop$222673[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$222677[ebp]
	push	ecx
	mov	ecx, DWORD PTR _trait$222586[ebp]
	call	?GetFreeResourceXCities@CvTraitEntry@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ; CvTraitEntry::GetFreeResourceXCities

; 2037 : 				if(temp.m_iResourceQuantity > 0)

	cmp	DWORD PTR _temp$222677[ebp+4], 0
	jle	SHORT $LN1@InitPlayer

; 2038 : 				{
; 2039 : 					m_aFreeResourceXCities[iResourceLoop] = temp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	mov	ecx, DWORD PTR _iResourceLoop$222673[ebp]
	mov	edx, DWORD PTR _temp$222677[ebp]
	mov	DWORD PTR [eax+ecx*8], edx
	mov	edx, DWORD PTR _temp$222677[ebp+4]
	mov	DWORD PTR [eax+ecx*8+4], edx
$LN1@InitPlayer:

; 2040 : 				}

	jmp	SHORT $LN3@InitPlayer
$LN58@InitPlayer:

; 2041 : 			}

	jmp	$LN60@InitPlayer
$LN66@InitPlayer:

; 2042 : 		}
; 2043 : 	}
; 2044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitPlayerTraits@CvPlayerTraits@@QAEXXZ ENDP		; CvPlayerTraits::InitPlayerTraits
_TEXT	ENDS
PUBLIC	?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::erase
PUBLIC	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase
PUBLIC	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
_this$ = -448						; size = 4
$T233766 = -444						; size = 4
$T233640 = -408						; size = 4
$T233624 = -404						; size = 4
$T233752 = -400						; size = 4
$T233751 = -396						; size = 4
$T233750 = -392						; size = 4
$T233749 = -388						; size = 4
$T233748 = -384						; size = 4
$T233608 = -380						; size = 4
$T233582 = -376						; size = 4
$T233566 = -372						; size = 4
$T233594 = -368						; size = 4
$T233593 = -364						; size = 4
$T233592 = -360						; size = 4
$T233591 = -356						; size = 4
$T233590 = -352						; size = 4
$T233550 = -348						; size = 4
$T233424 = -312						; size = 4
$T233408 = -308						; size = 4
$T233536 = -304						; size = 4
$T233535 = -300						; size = 4
$T233534 = -296						; size = 4
$T233533 = -292						; size = 4
$T233532 = -288						; size = 4
$T233392 = -284						; size = 4
$T233366 = -280						; size = 4
$T233350 = -276						; size = 4
$T233378 = -272						; size = 4
$T233377 = -268						; size = 4
$T233376 = -264						; size = 4
$T233375 = -260						; size = 4
$T233374 = -256						; size = 4
$T233334 = -252						; size = 4
$T233238 = -220						; size = 4
$T233222 = -216						; size = 4
$T233320 = -212						; size = 4
$T233319 = -208						; size = 4
$T233318 = -204						; size = 4
$T233317 = -200						; size = 4
$T233316 = -196						; size = 4
$T233206 = -192						; size = 4
$T233180 = -188						; size = 4
$T233164 = -184						; size = 4
$T233192 = -180						; size = 4
$T233191 = -176						; size = 4
$T233190 = -172						; size = 4
$T233189 = -168						; size = 4
$T233188 = -164						; size = 4
$T233016 = -32						; size = 4
$T232990 = -28						; size = 4
$T232974 = -24						; size = 4
$T233002 = -20						; size = 4
$T233001 = -16						; size = 4
$T233000 = -12						; size = 4
$T232999 = -8						; size = 4
$T232998 = -4						; size = 4
?Uninit@CvPlayerTraits@@QAEXXZ PROC			; CvPlayerTraits::Uninit, COMDAT
; _this$ = ecx

; 2048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 448				; 000001c0H
	mov	DWORD PTR _this$[ebp], ecx

; 2049 : 	m_aiResourceQuantityModifier.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 612				; 00000264H
	mov	DWORD PTR $T233016[ebp], eax
	mov	ecx, DWORD PTR $T233016[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T232974[ebp], edx
	mov	eax, DWORD PTR $T232974[ebp]
	mov	DWORD PTR $T232999[ebp], eax
	mov	ecx, DWORD PTR $T232999[ebp]
	mov	DWORD PTR $T232998[ebp], ecx
	mov	edx, DWORD PTR $T233016[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232990[ebp], eax
	mov	ecx, DWORD PTR $T232990[ebp]
	mov	DWORD PTR $T233001[ebp], ecx
	mov	edx, DWORD PTR $T233001[ebp]
	mov	DWORD PTR $T233000[ebp], edx
	mov	eax, DWORD PTR $T232998[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233000[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233002[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233016[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 2050 : 	m_abNoTrain.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 2051 : 	//EAP: No build
; 2052 : 	m_abNoBuild.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 2053 : 
; 2054 : 	m_paiMovesChangeUnitCombat.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 780				; 0000030cH
	mov	DWORD PTR $T233206[ebp], eax
	mov	ecx, DWORD PTR $T233206[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233164[ebp], edx
	mov	eax, DWORD PTR $T233164[ebp]
	mov	DWORD PTR $T233189[ebp], eax
	mov	ecx, DWORD PTR $T233189[ebp]
	mov	DWORD PTR $T233188[ebp], ecx
	mov	edx, DWORD PTR $T233206[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233180[ebp], eax
	mov	ecx, DWORD PTR $T233180[ebp]
	mov	DWORD PTR $T233191[ebp], ecx
	mov	edx, DWORD PTR $T233191[ebp]
	mov	DWORD PTR $T233190[ebp], edx
	mov	eax, DWORD PTR $T233188[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233190[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233192[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233206[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 2055 : 	m_paiMaintenanceModifierUnitCombat.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 796				; 0000031cH
	mov	DWORD PTR $T233334[ebp], eax
	mov	ecx, DWORD PTR $T233334[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233222[ebp], edx
	mov	eax, DWORD PTR $T233222[ebp]
	mov	DWORD PTR $T233317[ebp], eax
	mov	ecx, DWORD PTR $T233317[ebp]
	mov	DWORD PTR $T233316[ebp], ecx
	mov	edx, DWORD PTR $T233334[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233238[ebp], eax
	mov	ecx, DWORD PTR $T233238[ebp]
	mov	DWORD PTR $T233319[ebp], ecx
	mov	edx, DWORD PTR $T233319[ebp]
	mov	DWORD PTR $T233318[ebp], edx
	mov	eax, DWORD PTR $T233316[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233318[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233320[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233334[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 2056 : 	m_ppaaiImprovementYieldChange.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	mov	DWORD PTR $T233392[ebp], eax
	mov	ecx, DWORD PTR $T233392[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233350[ebp], edx
	mov	eax, DWORD PTR $T233350[ebp]
	mov	DWORD PTR $T233375[ebp], eax
	mov	ecx, DWORD PTR $T233375[ebp]
	mov	DWORD PTR $T233374[ebp], ecx
	mov	edx, DWORD PTR $T233392[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233366[ebp], eax
	mov	ecx, DWORD PTR $T233366[ebp]
	mov	DWORD PTR $T233377[ebp], ecx
	mov	edx, DWORD PTR $T233377[ebp]
	mov	DWORD PTR $T233376[ebp], edx
	mov	eax, DWORD PTR $T233374[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233376[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233378[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233392[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase

; 2057 : 	m_ppaaiSpecialistYieldChange.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 828				; 0000033cH
	mov	DWORD PTR $T233550[ebp], eax
	mov	ecx, DWORD PTR $T233550[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233408[ebp], edx
	mov	eax, DWORD PTR $T233408[ebp]
	mov	DWORD PTR $T233533[ebp], eax
	mov	ecx, DWORD PTR $T233533[ebp]
	mov	DWORD PTR $T233532[ebp], ecx
	mov	edx, DWORD PTR $T233550[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233424[ebp], eax
	mov	ecx, DWORD PTR $T233424[ebp]
	mov	DWORD PTR $T233535[ebp], ecx
	mov	edx, DWORD PTR $T233535[ebp]
	mov	DWORD PTR $T233534[ebp], edx
	mov	eax, DWORD PTR $T233532[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233534[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233536[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233550[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase

; 2058 : 
; 2059 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 2060 : 	m_ppaaiAnySpecificSpecialistYieldChange.clear();
; 2061 : #endif
; 2062 : 
; 2063 : 	m_ppaaiUnimprovedFeatureYieldChange.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 844				; 0000034cH
	mov	DWORD PTR $T233608[ebp], eax
	mov	ecx, DWORD PTR $T233608[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233566[ebp], edx
	mov	eax, DWORD PTR $T233566[ebp]
	mov	DWORD PTR $T233591[ebp], eax
	mov	ecx, DWORD PTR $T233591[ebp]
	mov	DWORD PTR $T233590[ebp], ecx
	mov	edx, DWORD PTR $T233608[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233582[ebp], eax
	mov	ecx, DWORD PTR $T233582[ebp]
	mov	DWORD PTR $T233593[ebp], ecx
	mov	edx, DWORD PTR $T233593[ebp]
	mov	DWORD PTR $T233592[ebp], edx
	mov	eax, DWORD PTR $T233590[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233592[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233594[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233608[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase

; 2064 : 	m_aFreeResourceXCities.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 860				; 0000035cH
	mov	DWORD PTR $T233766[ebp], eax
	mov	ecx, DWORD PTR $T233766[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233624[ebp], edx
	mov	eax, DWORD PTR $T233624[ebp]
	mov	DWORD PTR $T233749[ebp], eax
	mov	ecx, DWORD PTR $T233749[ebp]
	mov	DWORD PTR $T233748[ebp], ecx
	mov	edx, DWORD PTR $T233766[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233640[ebp], eax
	mov	ecx, DWORD PTR $T233640[ebp]
	mov	DWORD PTR $T233751[ebp], ecx
	mov	edx, DWORD PTR $T233751[ebp]
	mov	DWORD PTR $T233750[ebp], edx
	mov	eax, DWORD PTR $T233748[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233750[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233752[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233766[ebp]
	call	?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::erase

; 2065 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvPlayerTraits@@QAEXXZ ENDP			; CvPlayerTraits::Uninit
_TEXT	ENDS
PUBLIC	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
PUBLIC	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?Reset@CvPlayerTraits@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$5
__ehfuncinfo$?Reset@CvPlayerTraits@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Reset@CvPlayerTraits@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?Reset@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
tv914 = -1196						; size = 4
tv328 = -1192						; size = 4
tv789 = -1188						; size = 4
tv308 = -1184						; size = 4
tv1037 = -1180						; size = 4
_this$ = -1176						; size = 4
$T234908 = -1020					; size = 4
$T234812 = -988						; size = 4
$T234796 = -984						; size = 4
$T234894 = -980						; size = 4
$T234893 = -976						; size = 4
$T234892 = -972						; size = 4
$T234891 = -968						; size = 4
$T234890 = -964						; size = 4
$T234780 = -960						; size = 4
$T234684 = -928						; size = 4
$T234668 = -924						; size = 4
$T234766 = -920						; size = 4
$T234765 = -916						; size = 4
$T234764 = -912						; size = 4
$T234763 = -908						; size = 4
$T234762 = -904						; size = 4
$T234652 = -900						; size = 4
_i$234647 = -896					; size = 4
$T234633 = -892						; size = 4
$T234617 = -888						; size = 4
$T234610 = -884						; size = 4
$T234408 = -660						; size = 4
$T234392 = -656						; size = 4
$T234385 = -652						; size = 4
$T234180 = -428						; size = 4
$T234176 = -424						; size = 4
$T234150 = -420						; size = 4
$T234134 = -416						; size = 4
$T234162 = -412						; size = 4
$T234161 = -408						; size = 4
$T234160 = -404						; size = 4
$T234159 = -400						; size = 4
$T234158 = -396						; size = 4
$T234118 = -392						; size = 4
_i$234114 = -388					; size = 4
$T234107 = -384						; size = 4
_i$234103 = -380					; size = 4
$T234096 = -376						; size = 4
_i$234092 = -372					; size = 4
$T234082 = -368						; size = 4
$T234081 = -364						; size = 24
$T234076 = -340						; size = 4
$T234050 = -336						; size = 4
$T234034 = -332						; size = 4
$T234062 = -328						; size = 4
$T234061 = -324						; size = 4
$T234060 = -320						; size = 4
$T234059 = -316						; size = 4
$T234058 = -312						; size = 4
$T234018 = -308						; size = 4
$T234017 = -304						; size = 24
$T234012 = -280						; size = 4
$T233986 = -276						; size = 4
$T233970 = -272						; size = 4
$T233998 = -268						; size = 4
$T233997 = -264						; size = 4
$T233996 = -260						; size = 4
$T233995 = -256						; size = 4
$T233994 = -252						; size = 4
$T233954 = -248						; size = 4
$T233952 = -244						; size = 24
$T233948 = -220						; size = 4
$T233922 = -216						; size = 4
$T233906 = -212						; size = 4
$T233934 = -208						; size = 4
$T233933 = -204						; size = 4
$T233932 = -200						; size = 4
$T233931 = -196						; size = 4
$T233930 = -192						; size = 4
$T233890 = -188						; size = 4
$T233864 = -184						; size = 4
$T233848 = -180						; size = 4
$T233876 = -176						; size = 4
$T233875 = -172						; size = 4
$T233874 = -168						; size = 4
$T233873 = -164						; size = 4
$T233872 = -160						; size = 4
$T233819 = -156						; size = 4
$T233798 = -152						; size = 4
$T233797 = -148						; size = 4
$T233771 = -128						; size = 8
$T233770 = -120						; size = 8
$T233769 = -112						; size = 20
_temp$222741 = -92					; size = 8
_iI$222733 = -84					; size = 4
_iImprovement$222727 = -80				; size = 4
_iUnitClass$222722 = -76				; size = 4
_iResource$222718 = -72					; size = 4
_iTerrain$222714 = -68					; size = 4
_iFeature$222710 = -64					; size = 4
_iSpecialist$222706 = -60				; size = 4
_iImprovement$222702 = -56				; size = 4
_iYield$222698 = -52					; size = 4
_j$222694 = -48						; size = 4
_iResourceLoop$ = -44					; size = 4
_yield$ = -40						; size = 24
_iNumUnitCombatClassInfos$ = -16			; size = 4
__$EHRec$ = -12						; size = 12
?Reset@CvPlayerTraits@@QAEXXZ PROC			; CvPlayerTraits::Reset, COMDAT
; _this$ = ecx

; 2069 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Reset@CvPlayerTraits@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1184				; 000004a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2070 : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::Uninit

; 2071 : 
; 2072 : 
; 2073 : 	m_vLeaderHasTrait = std::vector<bool>( GC.getNumTraitInfos(), false );

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	push	eax
	lea	ecx, DWORD PTR $T233769[ebp]
	call	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
	mov	DWORD PTR tv1037[ebp], eax
	mov	eax, DWORD PTR tv1037[ebp]
	mov	DWORD PTR $T233798[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T233797[ebp], ecx
	mov	edx, DWORD PTR $T233797[ebp]
	mov	eax, DWORD PTR $T233798[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T233798[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR $T233797[ebp]
	add	ecx, 4
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T233769[ebp], 0
	lea	eax, DWORD PTR $T233769[ebp+4]
	mov	DWORD PTR $T233819[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T233819[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 2074 : 	m_vPotentiallyActiveLeaderTraits.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T233890[ebp], ecx
	mov	edx, DWORD PTR $T233890[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T233848[ebp], eax
	mov	ecx, DWORD PTR $T233848[ebp]
	mov	DWORD PTR $T233873[ebp], ecx
	mov	edx, DWORD PTR $T233873[ebp]
	mov	DWORD PTR $T233872[ebp], edx
	mov	eax, DWORD PTR $T233890[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T233864[ebp], ecx
	mov	edx, DWORD PTR $T233864[ebp]
	mov	DWORD PTR $T233875[ebp], edx
	mov	eax, DWORD PTR $T233875[ebp]
	mov	DWORD PTR $T233874[ebp], eax
	mov	ecx, DWORD PTR $T233872[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233874[ebp]
	push	edx
	lea	eax, DWORD PTR $T233876[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233890[ebp]
	call	?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase

; 2075 : 
; 2076 : 	m_iGreatPeopleRateModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 2077 : 	m_iGreatScientistRateModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0

; 2078 : 	m_iGreatGeneralRateModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 2079 : 	m_iGreatGeneralExtraBonus = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2080 : 	m_iGreatPersonGiftInfluence = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 0

; 2081 : 	m_iLevelExperienceModifier= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 2082 : 	m_iMaxGlobalBuildingProductionModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 2083 : 	m_iMaxTeamBuildingProductionModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], 0

; 2084 : 	m_iMaxPlayerBuildingProductionModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 2085 : 	m_iCityUnhappinessModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 0

; 2086 : 	m_iPopulationUnhappinessModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 0

; 2087 : 	m_iCityStateBonusModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0

; 2088 : 	m_iCityStateFriendshipModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 2089 : 	m_iCityStateCombatModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0

; 2090 : 	m_iLandBarbarianConversionPercent = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 2091 : 	m_iLandBarbarianConversionExtraUnits = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], 0

; 2092 : 	m_iSeaBarbarianConversionPercent = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 0

; 2093 : 	m_iCapitalBuildingModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0

; 2094 : 	m_iPlotBuyCostModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 0

; 2095 : 	m_iPlotCultureCostModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], 0

; 2096 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 2097 : 	m_iSciencePerGreatPersonBorn = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 0

; 2098 : #endif
; 2099 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 2100 : 	m_iNumTurnsBeforeMinorAlliesRefuseBribes = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 2101 : #endif
; 2102 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 2103 : 	m_iGoldenAgeTileBonusFaith = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 0

; 2104 : #endif
; 2105 : 	m_iCultureFromKills = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+136], 0

; 2106 : 	m_iFaithFromKills = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0

; 2107 : 	m_iCityCultureBonus = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0

; 2108 : 	m_iCapitalThemingBonusModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0

; 2109 : 	m_iPolicyCostModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+152], 0

; 2110 : 	m_iCityConnectionTradeRouteChange = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 2111 : 	m_iWonderProductionModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+160], 0

; 2112 : 	m_iPlunderModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+164], 0

; 2113 : 	m_iImprovementMaintenanceModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0

; 2114 : 	m_iGoldenAgeDurationModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+172], 0

; 2115 : 	m_iGoldenAgeMoveChange = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], 0

; 2116 : 	m_iGoldenAgeCombatModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+180], 0

; 2117 : 	m_iGoldenAgeTourismModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+184], 0

; 2118 : 	m_iGoldenAgeGreatArtistRateModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+188], 0

; 2119 : 	m_iGoldenAgeGreatMusicianRateModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+192], 0

; 2120 : 	m_iGoldenAgeGreatWriterRateModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+196], 0

; 2121 : 	m_iExtraEmbarkMoves = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+200], 0

; 2122 : 	m_iNaturalWonderFirstFinderGold = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+204], 0

; 2123 : 	m_iNaturalWonderSubsequentFinderGold = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+208], 0

; 2124 : 
; 2125 : 	//EAP: Natural wonder faith for the finder
; 2126 : 	m_iNaturalWonderFirstFinderFaith = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+216], 0

; 2127 : 	m_iNaturalWonderSubsequentFinderFaith = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+220], 0

; 2128 : 
; 2129 : 	m_iNaturalWonderYieldModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+212], 0

; 2130 : 	m_iNaturalWonderHappinessModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+224], 0

; 2131 : 	m_iNearbyImprovementCombatBonus = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+228], 0

; 2132 : 	m_iNearbyImprovementBonusRange = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+232], 0

; 2133 : 	m_iCultureBuildingYieldChange = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 0

; 2134 : 	m_iCombatBonusVsHigherTech = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+240], 0

; 2135 : 	m_iCombatBonusVsLargerCiv = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+244], 0

; 2136 : 	m_iLandUnitMaintenanceModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+248], 0

; 2137 : 	m_iNavalUnitMaintenanceModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+252], 0

; 2138 : 	m_iRazeSpeedModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+256], 0

; 2139 : 	m_iDOFGreatPersonModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], 0

; 2140 : 	m_iLuxuryHappinessRetention = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0

; 2141 : 	m_iExtraHappinessPerLuxury = 0; // NQMP GJS - New Netherlands UA

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0

; 2142 : 	m_iExtraSpies = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0

; 2143 : 	m_iHappinessPerReligion = 0; // NQMP GJS - New Ottoman UA

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 0

; 2144 : 	m_iUnresearchedTechBonusFromKills = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], 0

; 2145 : 	m_iExtraFoundedCityTerritoryClaimRange = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 0

; 2146 : 	m_iFreeSocialPoliciesPerEra = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0

; 2147 : 	m_iNumTradeRoutesModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0

; 2148 : 	m_iTradeRouteResourceModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 0

; 2149 : 	m_iUniqueLuxuryCities = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 0

; 2150 : 	m_iUniqueLuxuryQuantity = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+304], 0

; 2151 : 	m_iWorkerSpeedModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+312], 0

; 2152 : 	m_iAfraidMinorPerTurnInfluence = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+316], 0

; 2153 : 	m_iLandTradeRouteRangeBonus = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+320], 0

; 2154 : 	m_iTradeReligionModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], 0

; 2155 : 	m_iTradeBuildingModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 0

; 2156 : 
; 2157 : 	m_bFightWellDamaged = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+332], 0

; 2158 : 	m_bMoveFriendlyWoodsAsRoad = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+333], 0

; 2159 : 	m_bFasterAlongRiver = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+334], 0

; 2160 : 	m_bFasterInHills = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+335], 0

; 2161 : 	m_bEmbarkedAllWater = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+336], 0

; 2162 : 	m_bEmbarkedToLandFlatCost = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+337], 0

; 2163 : 	m_bNoHillsImprovementMaintenance = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+338], 0

; 2164 : 	m_bTechBoostFromCapitalScienceBuildings = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+339], 0

; 2165 : 	m_bStaysAliveZeroCities = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+340], 0

; 2166 : 	m_bFaithFromUnimprovedForest = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+341], 0

; 2167 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 2168 : 	m_bSeaTradeRoutesArePlunderImmune = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+342], 0

; 2169 : #endif
; 2170 : 	
; 2171 : 	// NQMP GJS - New France UA begin
; 2172 : 	m_bEarnsGreatPersonOnSlotOrGuild = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+343], 0

; 2173 : 	m_bHasBuiltWritersGuild = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+344], 0

; 2174 : 	m_bHasBuiltArtistsGuild = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+345], 0

; 2175 : 	m_bHasBuiltMusiciansGuild = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+346], 0

; 2176 : 	// NQMP GJS - New France UA end
; 2177 : 	
; 2178 : 	m_bBonusReligiousBelief = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+347], 0

; 2179 : 	m_bAbleToAnnexCityStates = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+348], 0

; 2180 : 	m_bCrossesMountainsAfterGreatGeneral = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+349], 0

; 2181 : 	m_bMayaCalendarBonuses = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+350], 0

; 2182 : 	m_bNoAnnexing = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+351], 0

; 2183 : 	m_bTechFromCityConquer = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+352], 0

; 2184 : 	m_bUniqueLuxuryRequiresNewArea = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+353], 0

; 2185 : 	m_bRiverTradeRoad = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+354], 0

; 2186 : 	m_bAngerFreeIntrusionOfCityStates = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+355], 0

; 2187 : 
; 2188 : 	m_eCampGuardType = NO_UNIT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+356], -1

; 2189 : 	m_eCombatBonusImprovement = NO_IMPROVEMENT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+368], -1

; 2190 : 
; 2191 : 	m_ppaaiImprovementYieldChange.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 812				; 0000032cH
	mov	DWORD PTR $T233948[ebp], edx
	mov	eax, DWORD PTR $T233948[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233906[ebp], ecx
	mov	edx, DWORD PTR $T233906[ebp]
	mov	DWORD PTR $T233931[ebp], edx
	mov	eax, DWORD PTR $T233931[ebp]
	mov	DWORD PTR $T233930[ebp], eax
	mov	ecx, DWORD PTR $T233948[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233922[ebp], edx
	mov	eax, DWORD PTR $T233922[ebp]
	mov	DWORD PTR $T233933[ebp], eax
	mov	ecx, DWORD PTR $T233933[ebp]
	mov	DWORD PTR $T233932[ebp], ecx
	mov	edx, DWORD PTR $T233930[ebp]
	push	edx
	mov	eax, DWORD PTR $T233932[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233934[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233948[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase

; 2192 : 	m_ppaaiImprovementYieldChange.resize(GC.getNumImprovementInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	DWORD PTR $T233954[ebp], eax
	sub	esp, 24					; 00000018H
	mov	edx, esp
	mov	eax, DWORD PTR $T233952[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T233952[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T233952[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T233952[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR $T233952[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T233952[ebp+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR $T233954[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	call	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize

; 2193 : 	m_ppaaiSpecialistYieldChange.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 828				; 0000033cH
	mov	DWORD PTR $T234012[ebp], eax
	mov	ecx, DWORD PTR $T234012[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233970[ebp], edx
	mov	eax, DWORD PTR $T233970[ebp]
	mov	DWORD PTR $T233995[ebp], eax
	mov	ecx, DWORD PTR $T233995[ebp]
	mov	DWORD PTR $T233994[ebp], ecx
	mov	edx, DWORD PTR $T234012[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233986[ebp], eax
	mov	ecx, DWORD PTR $T233986[ebp]
	mov	DWORD PTR $T233997[ebp], ecx
	mov	edx, DWORD PTR $T233997[ebp]
	mov	DWORD PTR $T233996[ebp], edx
	mov	eax, DWORD PTR $T233994[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233996[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233998[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234012[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase

; 2194 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 2195 : 	m_ppaaiAnySpecificSpecialistYieldChange.clear();
; 2196 : #endif
; 2197 : 	m_ppaaiSpecialistYieldChange.resize(GC.getNumSpecialistInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	mov	DWORD PTR $T234018[ebp], eax
	sub	esp, 24					; 00000018H
	mov	eax, esp
	mov	ecx, DWORD PTR $T234017[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T234017[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T234017[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T234017[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR $T234017[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T234017[ebp+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T234018[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 828				; 0000033cH
	call	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize

; 2198 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 2199 : 	m_ppaaiAnySpecificSpecialistYieldChange.resize(GC.getNumSpecialistInfos());
; 2200 : #endif
; 2201 : 
; 2202 : 	m_ppaaiUnimprovedFeatureYieldChange.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	mov	DWORD PTR $T234076[ebp], ecx
	mov	edx, DWORD PTR $T234076[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234034[ebp], eax
	mov	ecx, DWORD PTR $T234034[ebp]
	mov	DWORD PTR $T234059[ebp], ecx
	mov	edx, DWORD PTR $T234059[ebp]
	mov	DWORD PTR $T234058[ebp], edx
	mov	eax, DWORD PTR $T234076[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234050[ebp], ecx
	mov	edx, DWORD PTR $T234050[ebp]
	mov	DWORD PTR $T234061[ebp], edx
	mov	eax, DWORD PTR $T234061[ebp]
	mov	DWORD PTR $T234060[ebp], eax
	mov	ecx, DWORD PTR $T234058[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234060[ebp]
	push	edx
	lea	eax, DWORD PTR $T234062[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234076[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase

; 2203 : 	m_ppaaiUnimprovedFeatureYieldChange.resize(GC.getNumFeatureInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	mov	DWORD PTR $T234082[ebp], eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	edx, DWORD PTR $T234081[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T234081[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T234081[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR $T234081[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR $T234081[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T234081[ebp+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR $T234082[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	call	?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize

; 2204 : 
; 2205 : 	Firaxis::Array< int, NUM_YIELD_TYPES > yield;
; 2206 : 	for(unsigned int j = 0; j < NUM_YIELD_TYPES; ++j)

	mov	DWORD PTR _j$222694[ebp], 0
	jmp	SHORT $LN33@Reset
$LN32@Reset:
	mov	edx, DWORD PTR _j$222694[ebp]
	add	edx, 1
	mov	DWORD PTR _j$222694[ebp], edx
$LN33@Reset:
	cmp	DWORD PTR _j$222694[ebp], 6
	jae	SHORT $LN31@Reset

; 2207 : 	{
; 2208 : 		yield[j] = 0;

	mov	eax, DWORD PTR _j$222694[ebp]
	mov	DWORD PTR _yield$[ebp+eax*4], 0

; 2209 : 	}

	jmp	SHORT $LN32@Reset
$LN31@Reset:

; 2210 : 
; 2211 : 	for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$222698[ebp], 0
	jmp	SHORT $LN30@Reset
$LN29@Reset:
	mov	ecx, DWORD PTR _iYield$222698[ebp]
	add	ecx, 1
	mov	DWORD PTR _iYield$222698[ebp], ecx
$LN30@Reset:
	cmp	DWORD PTR _iYield$222698[ebp], 6
	jge	$LN28@Reset

; 2212 : 	{
; 2213 : 		m_iExtraYieldThreshold[iYield] = 0;

	mov	edx, DWORD PTR _iYield$222698[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+384], 0

; 2214 : 		m_iFreeCityYield[iYield] = 0;

	mov	ecx, DWORD PTR _iYield$222698[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+408], 0

; 2215 : 		m_iYieldChangeStrategicResources[iYield] = 0;

	mov	eax, DWORD PTR _iYield$222698[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+432], 0

; 2216 : 		m_iYieldChangeLuxuryResources[iYield] = 0; // NQMP GJS - New Netherlands UA

	mov	edx, DWORD PTR _iYield$222698[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+456], 0

; 2217 : 		m_iYieldChangeNaturalWonder[iYield] = 0;

	mov	ecx, DWORD PTR _iYield$222698[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+480], 0

; 2218 : 		m_iYieldChangePerTradePartner[iYield] = 0;

	mov	eax, DWORD PTR _iYield$222698[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+504], 0

; 2219 : 		m_iYieldChangeIncomingTradeRoute[iYield] = 0;

	mov	edx, DWORD PTR _iYield$222698[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+528], 0

; 2220 : 		m_iYieldRateModifier[iYield] = 0;

	mov	ecx, DWORD PTR _iYield$222698[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+552], 0

; 2221 : 
; 2222 : #ifdef AUI_WARNING_FIXES
; 2223 : 		for (uint iImprovement = 0; iImprovement < GC.getNumImprovementInfos(); iImprovement++)
; 2224 : 		{
; 2225 : 			m_ppaaiImprovementYieldChange[iImprovement] = yield;
; 2226 : 		}
; 2227 : 		for (uint iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)
; 2228 : 		{
; 2229 : 			m_ppaaiSpecialistYieldChange[iSpecialist] = yield;
; 2230 : 		}
; 2231 : 		for (uint iFeature = 0; iFeature < GC.getNumFeatureInfos(); iFeature++)
; 2232 : #else
; 2233 : 		for(int iImprovement = 0; iImprovement < GC.getNumImprovementInfos(); iImprovement++)

	mov	DWORD PTR _iImprovement$222702[ebp], 0
	jmp	SHORT $LN27@Reset
$LN26@Reset:
	mov	eax, DWORD PTR _iImprovement$222702[ebp]
	add	eax, 1
	mov	DWORD PTR _iImprovement$222702[ebp], eax
$LN27@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iImprovement$222702[ebp], eax
	jge	SHORT $LN25@Reset

; 2234 : 		{
; 2235 : 			m_ppaaiImprovementYieldChange[iImprovement] = yield;

	mov	ecx, DWORD PTR _iImprovement$222702[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+816]
	mov	DWORD PTR $T234096[ebp], ecx
	mov	DWORD PTR _i$234092[ebp], 0
	jmp	SHORT $LN133@Reset
$LN132@Reset:
	mov	eax, DWORD PTR _i$234092[ebp]
	add	eax, 1
	mov	DWORD PTR _i$234092[ebp], eax
$LN133@Reset:
	cmp	DWORD PTR _i$234092[ebp], 6
	jae	SHORT $LN134@Reset
	mov	ecx, DWORD PTR _i$234092[ebp]
	mov	edx, DWORD PTR $T234096[ebp]
	mov	eax, DWORD PTR _i$234092[ebp]
	mov	eax, DWORD PTR _yield$[ebp+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN132@Reset
$LN134@Reset:

; 2236 : 		}

	jmp	SHORT $LN26@Reset
$LN25@Reset:

; 2237 : 		for(int iSpecialist = 0; iSpecialist < GC.getNumSpecialistInfos(); iSpecialist++)

	mov	DWORD PTR _iSpecialist$222706[ebp], 0
	jmp	SHORT $LN24@Reset
$LN23@Reset:
	mov	ecx, DWORD PTR _iSpecialist$222706[ebp]
	add	ecx, 1
	mov	DWORD PTR _iSpecialist$222706[ebp], ecx
$LN24@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumSpecialistInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumSpecialistInfos
	cmp	DWORD PTR _iSpecialist$222706[ebp], eax
	jge	SHORT $LN22@Reset

; 2238 : 		{
; 2239 : 			m_ppaaiSpecialistYieldChange[iSpecialist] = yield;

	mov	edx, DWORD PTR _iSpecialist$222706[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+832]
	mov	DWORD PTR $T234107[ebp], edx
	mov	DWORD PTR _i$234103[ebp], 0
	jmp	SHORT $LN140@Reset
$LN139@Reset:
	mov	ecx, DWORD PTR _i$234103[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$234103[ebp], ecx
$LN140@Reset:
	cmp	DWORD PTR _i$234103[ebp], 6
	jae	SHORT $LN141@Reset
	mov	edx, DWORD PTR _i$234103[ebp]
	mov	eax, DWORD PTR $T234107[ebp]
	mov	ecx, DWORD PTR _i$234103[ebp]
	mov	ecx, DWORD PTR _yield$[ebp+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN139@Reset
$LN141@Reset:

; 2240 : 		}

	jmp	SHORT $LN23@Reset
$LN22@Reset:

; 2241 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 2242 : 		for(int iSpecialist = 0; iSpecialist < 2; iSpecialist++)
; 2243 : 		{
; 2244 : 			m_ppaaiAnySpecificSpecialistYieldChange[iSpecialist] = yield;
; 2245 : 		}
; 2246 : #endif
; 2247 : 		for(int iFeature = 0; iFeature < GC.getNumFeatureInfos(); iFeature++)

	mov	DWORD PTR _iFeature$222710[ebp], 0
	jmp	SHORT $LN21@Reset
$LN20@Reset:
	mov	edx, DWORD PTR _iFeature$222710[ebp]
	add	edx, 1
	mov	DWORD PTR _iFeature$222710[ebp], edx
$LN21@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	DWORD PTR _iFeature$222710[ebp], eax
	jge	SHORT $LN19@Reset

; 2248 : #endif
; 2249 : 		{
; 2250 : 			m_ppaaiUnimprovedFeatureYieldChange[iFeature] = yield;

	mov	eax, DWORD PTR _iFeature$222710[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+848]
	mov	DWORD PTR $T234118[ebp], eax
	mov	DWORD PTR _i$234114[ebp], 0
	jmp	SHORT $LN147@Reset
$LN146@Reset:
	mov	edx, DWORD PTR _i$234114[ebp]
	add	edx, 1
	mov	DWORD PTR _i$234114[ebp], edx
$LN147@Reset:
	cmp	DWORD PTR _i$234114[ebp], 6
	jae	SHORT $LN148@Reset
	mov	eax, DWORD PTR _i$234114[ebp]
	mov	ecx, DWORD PTR $T234118[ebp]
	mov	edx, DWORD PTR _i$234114[ebp]
	mov	edx, DWORD PTR _yield$[ebp+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	jmp	SHORT $LN146@Reset
$LN148@Reset:

; 2251 : 		}

	jmp	SHORT $LN20@Reset
$LN19@Reset:

; 2252 : 	}

	jmp	$LN29@Reset
$LN28@Reset:

; 2253 : 
; 2254 : #ifdef AUI_WARNING_FIXES
; 2255 : 	for (uint iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)
; 2256 : #else
; 2257 : 	for(int iTerrain = 0; iTerrain < GC.getNumTerrainInfos(); iTerrain++)

	mov	DWORD PTR _iTerrain$222714[ebp], 0
	jmp	SHORT $LN18@Reset
$LN17@Reset:
	mov	eax, DWORD PTR _iTerrain$222714[ebp]
	add	eax, 1
	mov	DWORD PTR _iTerrain$222714[ebp], eax
$LN18@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	cmp	DWORD PTR _iTerrain$222714[ebp], eax
	jge	SHORT $LN16@Reset

; 2258 : #endif
; 2259 : 	{
; 2260 : 		m_iStrategicResourceQuantityModifier[iTerrain] = 0;

	mov	ecx, DWORD PTR _iTerrain$222714[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+576], 0

; 2261 : 	}

	jmp	SHORT $LN17@Reset
$LN16@Reset:

; 2262 : 
; 2263 : 	m_aiResourceQuantityModifier.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 612				; 00000264H
	mov	DWORD PTR $T234176[ebp], eax
	mov	ecx, DWORD PTR $T234176[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T234134[ebp], edx
	mov	eax, DWORD PTR $T234134[ebp]
	mov	DWORD PTR $T234159[ebp], eax
	mov	ecx, DWORD PTR $T234159[ebp]
	mov	DWORD PTR $T234158[ebp], ecx
	mov	edx, DWORD PTR $T234176[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T234150[ebp], eax
	mov	ecx, DWORD PTR $T234150[ebp]
	mov	DWORD PTR $T234161[ebp], ecx
	mov	edx, DWORD PTR $T234161[ebp]
	mov	DWORD PTR $T234160[ebp], edx
	mov	eax, DWORD PTR $T234158[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234160[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234162[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234176[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 2264 : 	m_aiResourceQuantityModifier.resize(GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR $T234180[ebp], eax
	push	0
	mov	eax, DWORD PTR $T234180[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize

; 2265 : 
; 2266 : #ifdef AUI_WARNING_FIXES
; 2267 : 	for (uint iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)
; 2268 : #else
; 2269 : 	for(int iResource = 0; iResource < GC.getNumResourceInfos(); iResource++)

	mov	DWORD PTR _iResource$222718[ebp], 0
	jmp	SHORT $LN15@Reset
$LN14@Reset:
	mov	ecx, DWORD PTR _iResource$222718[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResource$222718[ebp], ecx
$LN15@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResource$222718[ebp], eax
	jge	SHORT $LN13@Reset

; 2270 : #endif
; 2271 : 	{
; 2272 : 		m_aiResourceQuantityModifier[iResource] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+616]
	mov	ecx, DWORD PTR _iResource$222718[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 2273 : 	}

	jmp	SHORT $LN14@Reset
$LN13@Reset:

; 2274 : 
; 2275 : 	m_abNoTrain.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 2276 : 	m_abNoTrain.resize(GC.getNumUnitClassInfos());

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 2277 : #ifdef AUI_WARNING_FIXES
; 2278 : 	for (uint iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)
; 2279 : #else
; 2280 : 	for (int iUnitClass = 0; iUnitClass < GC.getNumUnitClassInfos(); iUnitClass++)

	mov	DWORD PTR _iUnitClass$222722[ebp], 0
	jmp	SHORT $LN12@Reset
$LN11@Reset:
	mov	edx, DWORD PTR _iUnitClass$222722[ebp]
	add	edx, 1
	mov	DWORD PTR _iUnitClass$222722[ebp], edx
$LN12@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iUnitClass$222722[ebp], eax
	jge	$LN10@Reset

; 2281 : #endif
; 2282 : 	{
; 2283 : 		m_abNoTrain[iUnitClass] = false;

	mov	eax, DWORD PTR _iUnitClass$222722[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233770[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T234408[ebp], eax
	xor	edx, edx
	je	SHORT $LN241@Reset
	mov	eax, DWORD PTR $T234385[ebp]
	mov	DWORD PTR tv308[ebp], eax
	mov	ecx, DWORD PTR $T234408[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv308[ebp], edx
	mov	eax, DWORD PTR $T234408[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv308[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv308[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN242@Reset
$LN241@Reset:
	mov	edx, DWORD PTR $T234392[ebp]
	mov	DWORD PTR tv789[ebp], edx
	mov	eax, DWORD PTR $T234408[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv789[ebp], ecx
	mov	edx, DWORD PTR $T234408[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv789[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv789[ebp]
	mov	DWORD PTR [edx], eax
$LN242@Reset:

; 2284 : 	}

	jmp	$LN11@Reset
$LN10@Reset:

; 2285 : 
; 2286 : 	// EAP: No build
; 2287 : 	m_abNoBuild.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 2288 : 	m_abNoBuild.resize(GC.getNumImprovementInfos());

	push	0
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ; std::vector<bool,std::allocator<bool> >::resize

; 2289 : 	for (int iImprovement = 0; iImprovement < GC.getNumUnitClassInfos(); iImprovement++)

	mov	DWORD PTR _iImprovement$222727[ebp], 0
	jmp	SHORT $LN9@Reset
$LN8@Reset:
	mov	eax, DWORD PTR _iImprovement$222727[ebp]
	add	eax, 1
	mov	DWORD PTR _iImprovement$222727[ebp], eax
$LN9@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iImprovement$222727[ebp], eax
	jge	$LN7@Reset

; 2290 : 	{
; 2291 : 		m_abNoBuild[iImprovement] = false;

	mov	ecx, DWORD PTR _iImprovement$222727[ebp]
	push	ecx
	lea	edx, DWORD PTR $T233771[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T234633[ebp], eax
	xor	eax, eax
	je	SHORT $LN325@Reset
	mov	ecx, DWORD PTR $T234610[ebp]
	mov	DWORD PTR tv328[ebp], ecx
	mov	edx, DWORD PTR $T234633[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv328[ebp], eax
	mov	ecx, DWORD PTR $T234633[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv328[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv328[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN326@Reset
$LN325@Reset:
	mov	edx, DWORD PTR $T234617[ebp]
	mov	DWORD PTR tv914[ebp], edx
	mov	eax, DWORD PTR $T234633[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv914[ebp], ecx
	mov	edx, DWORD PTR $T234633[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv914[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv914[ebp]
	mov	DWORD PTR [edx], eax
$LN326@Reset:

; 2292 : 	}

	jmp	$LN8@Reset
$LN7@Reset:

; 2293 : 
; 2294 : 	m_aFreeTraitUnits.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 668				; 0000029cH
	mov	DWORD PTR $T234652[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN342@Reset
	mov	DWORD PTR _i$234647[ebp], 0
	jmp	SHORT $LN340@Reset
$LN339@Reset:
	mov	edx, DWORD PTR _i$234647[ebp]
	add	edx, 1
	mov	DWORD PTR _i$234647[ebp], edx
$LN340@Reset:
	mov	eax, DWORD PTR $T234652[ebp]
	mov	ecx, DWORD PTR _i$234647[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN342@Reset
	jmp	SHORT $LN339@Reset
$LN342@Reset:
	mov	edx, DWORD PTR $T234652[ebp]
	mov	DWORD PTR [edx+4], 0

; 2295 : 
; 2296 : #ifdef AUI_WARNING_FIXES
; 2297 : 	uint iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();
; 2298 : 	CvAssertMsg((0 < iNumUnitCombatClassInfos), "GC.getNumUnitCombatClassInfos() is not greater than zero but an array is being allocated in CvPlayerTraits::Reset");
; 2299 : 	m_paiMovesChangeUnitCombat.clear();
; 2300 : 	m_paiMaintenanceModifierUnitCombat.clear();
; 2301 : 	m_paiMovesChangeUnitCombat.resize(iNumUnitCombatClassInfos);
; 2302 : 	m_paiMaintenanceModifierUnitCombat.resize(iNumUnitCombatClassInfos);
; 2303 : 	for (uint iI = 0; iI < iNumUnitCombatClassInfos; iI++)
; 2304 : #else
; 2305 : 	int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	mov	DWORD PTR _iNumUnitCombatClassInfos$[ebp], eax

; 2306 : 	CvAssertMsg((0 < iNumUnitCombatClassInfos),  "GC.getNumUnitCombatClassInfos() is not greater than zero but an array is being allocated in CvPlayerTraits::Reset");
; 2307 : 	m_paiMovesChangeUnitCombat.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 780				; 0000030cH
	mov	DWORD PTR $T234780[ebp], eax
	mov	ecx, DWORD PTR $T234780[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T234668[ebp], edx
	mov	eax, DWORD PTR $T234668[ebp]
	mov	DWORD PTR $T234763[ebp], eax
	mov	ecx, DWORD PTR $T234763[ebp]
	mov	DWORD PTR $T234762[ebp], ecx
	mov	edx, DWORD PTR $T234780[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T234684[ebp], eax
	mov	ecx, DWORD PTR $T234684[ebp]
	mov	DWORD PTR $T234765[ebp], ecx
	mov	edx, DWORD PTR $T234765[ebp]
	mov	DWORD PTR $T234764[ebp], edx
	mov	eax, DWORD PTR $T234762[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234764[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234766[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234780[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 2308 : 	m_paiMaintenanceModifierUnitCombat.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 796				; 0000031cH
	mov	DWORD PTR $T234908[ebp], eax
	mov	ecx, DWORD PTR $T234908[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T234796[ebp], edx
	mov	eax, DWORD PTR $T234796[ebp]
	mov	DWORD PTR $T234891[ebp], eax
	mov	ecx, DWORD PTR $T234891[ebp]
	mov	DWORD PTR $T234890[ebp], ecx
	mov	edx, DWORD PTR $T234908[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T234812[ebp], eax
	mov	ecx, DWORD PTR $T234812[ebp]
	mov	DWORD PTR $T234893[ebp], ecx
	mov	edx, DWORD PTR $T234893[ebp]
	mov	DWORD PTR $T234892[ebp], edx
	mov	eax, DWORD PTR $T234890[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234892[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234894[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234908[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 2309 : 	m_paiMovesChangeUnitCombat.resize(iNumUnitCombatClassInfos);

	push	0
	mov	eax, DWORD PTR _iNumUnitCombatClassInfos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize

; 2310 : 	m_paiMaintenanceModifierUnitCombat.resize(iNumUnitCombatClassInfos);

	push	0
	mov	ecx, DWORD PTR _iNumUnitCombatClassInfos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize

; 2311 : 	for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	mov	DWORD PTR _iI$222733[ebp], 0
	jmp	SHORT $LN6@Reset
$LN5@Reset:
	mov	edx, DWORD PTR _iI$222733[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$222733[ebp], edx
$LN6@Reset:
	mov	eax, DWORD PTR _iI$222733[ebp]
	cmp	eax, DWORD PTR _iNumUnitCombatClassInfos$[ebp]
	jge	SHORT $LN4@Reset

; 2312 : #endif
; 2313 : 	{
; 2314 : 		m_paiMovesChangeUnitCombat[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+784]
	mov	eax, DWORD PTR _iI$222733[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2315 : 		m_paiMaintenanceModifierUnitCombat[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+800]
	mov	eax, DWORD PTR _iI$222733[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 2316 : 	}

	jmp	SHORT $LN5@Reset
$LN4@Reset:

; 2317 : 
; 2318 : #ifdef AUI_WARNING_FIXES
; 2319 : 	for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2320 : #else
; 2321 : 	int iResourceLoop;
; 2322 : 	for(iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	ecx, DWORD PTR _iResourceLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$[ebp], ecx
$LN3@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$[ebp], eax
	jge	SHORT $LN34@Reset

; 2323 : #endif
; 2324 : 	{
; 2325 : 		FreeResourceXCities temp;

	mov	DWORD PTR _temp$222741[ebp], 0
	mov	DWORD PTR _temp$222741[ebp+4], 0

; 2326 : 		m_aFreeResourceXCities.push_back(temp);

	lea	edx, DWORD PTR _temp$222741[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 860				; 0000035cH
	call	?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back
	jmp	SHORT $LN2@Reset
$LN34@Reset:

; 2327 : 	}
; 2328 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$0:
	lea	ecx, DWORD PTR $T233769[ebp]
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T233769[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$?Reset@CvPlayerTraits@@QAEXXZ$5:
	mov	ecx, DWORD PTR $T233819[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$?Reset@CvPlayerTraits@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Reset@CvPlayerTraits@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Reset@CvPlayerTraits@@QAEXXZ ENDP			; CvPlayerTraits::Reset
; Function compile flags: /Odtp
;	COMDAT ?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z
_TEXT	SEGMENT
tv128 = -24						; size = 4
_this$ = -20						; size = 4
$T235233 = -16						; size = 4
$T235232 = -12						; size = 4
$T235223 = -8						; size = 4
$T235222 = -4						; size = 4
_eTrait$ = 8						; size = 4
?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z PROC	; CvPlayerTraits::HasTrait, COMDAT
; _this$ = ecx

; 2332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2333 : 	CvAssert(m_pPlayer);
; 2334 : 
; 2335 : 	if(m_pPlayer != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN2@HasTrait

; 2336 : 	{
; 2337 : 		CvAssertMsg((m_pPlayer->getLeaderType() >= 0), "getLeaderType() is less than zero");
; 2338 : 		CvAssertMsg((eTrait >= 0), "eTrait is less than zero");
; 2339 : 		return m_pPlayer->getLeaderInfo().hasTrait(eTrait) && !m_pTraits->GetEntry(eTrait)->IsObsoleteByTech(m_pPlayer->getTeam()) && m_pTraits->GetEntry(eTrait)->IsEnabledByTech(m_pPlayer->getTeam());

	mov	ecx, DWORD PTR _eTrait$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	ecx, eax
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@HasTrait
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235222[ebp], edx
	mov	eax, DWORD PTR $T235222[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235223[ebp], eax
	mov	edx, DWORD PTR $T235223[ebp]
	push	edx
	mov	eax, DWORD PTR _eTrait$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z ; CvTraitXMLEntries::GetEntry
	mov	ecx, eax
	call	?IsObsoleteByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ; CvTraitEntry::IsObsoleteByTech
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN5@HasTrait
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235232[ebp], ecx
	mov	edx, DWORD PTR $T235232[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235233[ebp], eax
	mov	ecx, DWORD PTR $T235233[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTrait$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetEntry@CvTraitXMLEntries@@QAEPAVCvTraitEntry@@H@Z ; CvTraitXMLEntries::GetEntry
	mov	ecx, eax
	call	?IsEnabledByTech@CvTraitEntry@@QAE_NW4TeamTypes@@@Z ; CvTraitEntry::IsEnabledByTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@HasTrait
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN6@HasTrait
$LN5@HasTrait:
	mov	DWORD PTR tv128[ebp], 0
$LN6@HasTrait:
	mov	al, BYTE PTR tv128[ebp]
	jmp	SHORT $LN3@HasTrait

; 2340 : 	}
; 2341 : 	else

	jmp	SHORT $LN3@HasTrait
$LN2@HasTrait:

; 2342 : 	{
; 2343 : 		return false;

	xor	al, al
$LN3@HasTrait:

; 2344 : 	}
; 2345 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ENDP	; CvPlayerTraits::HasTrait
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z ; CvPlayerTraits::WillGetUniqueLuxury
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvResourceInfo::GetRequiredCivilization
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?GetOriginalCapitalX@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetOriginalCapitalX
EXTRN	?GetOriginalCapitalY@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetOriginalCapitalY
EXTRN	?GetNumCitiesFounded@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumCitiesFounded
; Function compile flags: /Odtp
;	COMDAT ?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z
_TEXT	SEGMENT
tv195 = -144						; size = 4
tv207 = -140						; size = 4
_this$ = -136						; size = 4
$T235431 = -132						; size = 4
$T235419 = -128						; size = 4
$T235401 = -124						; size = 4
$T235400 = -120						; size = 4
$T235403 = -116						; size = 4
$T235364 = -112						; size = 4
$T235355 = -108						; size = 4
$T235346 = -104						; size = 4
$T235341 = -100						; size = 4
$T235337 = -96						; size = 4
$T235336 = -92						; size = 4
$T235297 = -88						; size = 4
$T235284 = -84						; size = 4
$T235280 = -80						; size = 4
$T235273 = -76						; size = 4
$T235269 = -69						; size = 1
$T235258 = -68						; size = 4
$T235254 = -61						; size = 1
_iMapY$235306 = -60					; size = 4
_iMapX$235305 = -56					; size = 4
$T235247 = -52						; size = 4
$T235243 = -48						; size = 4
$T235239 = -44						; size = 4
$T235238 = -40						; size = 4
$T235237 = -36						; size = 4
$T235236 = -32						; size = 4
_eResource$222777 = -28					; size = 4
_pkResource$222779 = -24				; size = 4
_iResourceLoop$222773 = -20				; size = 4
_pOriginalCapitalPlot$222756 = -16			; size = 4
_iArea$222754 = -12					; size = 4
_iNumUniquesFound$222772 = -8				; size = 4
_iNumUniqueResourcesGiven$222771 = -4			; size = 4
_pArea$ = 8						; size = 4
?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z PROC ; CvPlayerTraits::WillGetUniqueLuxury, COMDAT
; _this$ = ecx

; 2349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2350 : 	// Still have more of these cities to award?
; 2351 : 	if (m_iUniqueLuxuryCities > m_iUniqueLuxuryCitiesPlaced)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+300]
	cmp	edx, DWORD PTR [ecx+308]
	jle	$LN11@WillGetUni

; 2352 : 	{
; 2353 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area BEGIN
; 2354 : 		if (m_pPlayer->GetNumCitiesFounded() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumCitiesFounded@CvPlayer@@QBEHXZ	; CvPlayer::GetNumCitiesFounded
	test	eax, eax
	jne	SHORT $LN10@WillGetUni

; 2355 : 		{
; 2356 : 			return false;

	xor	al, al
	jmp	$LN12@WillGetUni
$LN10@WillGetUni:

; 2357 : 		}
; 2358 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area END
; 2359 : 
; 2360 : 		int iArea = pArea->GetID();

	mov	ecx, DWORD PTR _pArea$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235243[ebp], edx
	mov	eax, DWORD PTR $T235243[ebp]
	mov	DWORD PTR _iArea$222754[ebp], eax

; 2361 : 
; 2362 : 		// If we have to be in a new area, check to see if this area is okay
; 2363 : 		if (m_bUniqueLuxuryRequiresNewArea)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+353]
	test	edx, edx
	je	$LN9@WillGetUni

; 2364 : 		{
; 2365 : 			/* NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area
; 2366 : 			// Can't be the capital itself
; 2367 : 			if (m_pPlayer->GetNumCitiesFounded() == 0)
; 2368 : 			{
; 2369 : 				return false;
; 2370 : 			}
; 2371 : 			*/
; 2372 : 
; 2373 : 			CvPlot *pOriginalCapitalPlot = GC.getMap().plot(m_pPlayer->GetOriginalCapitalX(), m_pPlayer->GetOriginalCapitalY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235247[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetOriginalCapitalY@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalY
	mov	DWORD PTR $T235337[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetOriginalCapitalX@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalX
	mov	DWORD PTR $T235336[ebp], eax
	cmp	DWORD PTR $T235336[ebp], -2147483647	; 80000001H
	je	SHORT $LN18@WillGetUni
	cmp	DWORD PTR $T235337[ebp], -2147483647	; 80000001H
	jne	SHORT $LN19@WillGetUni
$LN18@WillGetUni:
	mov	DWORD PTR _pOriginalCapitalPlot$222756[ebp], 0
	jmp	$LN20@WillGetUni
$LN19@WillGetUni:
	mov	eax, DWORD PTR $T235247[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T235254[ebp], cl
	mov	edx, DWORD PTR $T235247[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T235258[ebp], eax
	movzx	ecx, BYTE PTR $T235254[ebp]
	test	ecx, ecx
	je	SHORT $LN31@WillGetUni
	cmp	DWORD PTR $T235336[ebp], 0
	jge	SHORT $LN30@WillGetUni
	mov	eax, DWORD PTR $T235336[ebp]
	cdq
	idiv	DWORD PTR $T235258[ebp]
	add	edx, DWORD PTR $T235258[ebp]
	mov	DWORD PTR _iMapX$235305[ebp], edx
	jmp	SHORT $LN32@WillGetUni
	jmp	SHORT $LN31@WillGetUni
$LN30@WillGetUni:
	mov	edx, DWORD PTR $T235336[ebp]
	cmp	edx, DWORD PTR $T235258[ebp]
	jl	SHORT $LN31@WillGetUni
	mov	eax, DWORD PTR $T235336[ebp]
	cdq
	idiv	DWORD PTR $T235258[ebp]
	mov	DWORD PTR _iMapX$235305[ebp], edx
	jmp	SHORT $LN32@WillGetUni
$LN31@WillGetUni:
	mov	eax, DWORD PTR $T235336[ebp]
	mov	DWORD PTR _iMapX$235305[ebp], eax
$LN32@WillGetUni:
	mov	ecx, DWORD PTR $T235247[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T235269[ebp], dl
	mov	eax, DWORD PTR $T235247[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T235273[ebp], ecx
	movzx	edx, BYTE PTR $T235269[ebp]
	push	edx
	mov	eax, DWORD PTR $T235273[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235337[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$235306[ebp], eax
	cmp	DWORD PTR _iMapX$235305[ebp], 0
	jl	SHORT $LN40@WillGetUni
	mov	edx, DWORD PTR $T235247[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T235280[ebp], eax
	mov	ecx, DWORD PTR _iMapX$235305[ebp]
	cmp	ecx, DWORD PTR $T235280[ebp]
	jge	SHORT $LN40@WillGetUni
	cmp	DWORD PTR _iMapY$235306[ebp], 0
	jl	SHORT $LN40@WillGetUni
	mov	edx, DWORD PTR $T235247[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T235284[ebp], eax
	mov	ecx, DWORD PTR _iMapY$235306[ebp]
	cmp	ecx, DWORD PTR $T235284[ebp]
	jge	SHORT $LN40@WillGetUni
	mov	DWORD PTR tv207[ebp], 1
	jmp	SHORT $LN38@WillGetUni
$LN40@WillGetUni:
	mov	DWORD PTR tv207[ebp], 0
$LN38@WillGetUni:
	cmp	DWORD PTR tv207[ebp], 0
	je	SHORT $LN22@WillGetUni
	mov	edx, DWORD PTR $T235247[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T235297[ebp], eax
	mov	ecx, DWORD PTR _iMapY$235306[ebp]
	imul	ecx, DWORD PTR $T235297[ebp]
	add	ecx, DWORD PTR _iMapX$235305[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T235247[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv195[ebp], ecx
	jmp	SHORT $LN23@WillGetUni
$LN22@WillGetUni:
	mov	DWORD PTR tv195[ebp], 0
$LN23@WillGetUni:
	mov	eax, DWORD PTR tv195[ebp]
	mov	DWORD PTR _pOriginalCapitalPlot$222756[ebp], eax
$LN20@WillGetUni:

; 2374 : 			if (pOriginalCapitalPlot)

	cmp	DWORD PTR _pOriginalCapitalPlot$222756[ebp], 0
	je	SHORT $LN8@WillGetUni

; 2375 : 			{
; 2376 : 				if (pOriginalCapitalPlot->getArea() == iArea)

	mov	ecx, DWORD PTR _pOriginalCapitalPlot$222756[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T235341[ebp], edx
	mov	eax, DWORD PTR $T235341[ebp]
	cmp	eax, DWORD PTR _iArea$222754[ebp]
	jne	SHORT $LN8@WillGetUni

; 2377 : 				{
; 2378 : 					return false;

	xor	al, al
	jmp	$LN12@WillGetUni
$LN8@WillGetUni:

; 2379 : 				}
; 2380 : 			}
; 2381 : 
; 2382 : 			// Already in the list?
; 2383 : 			if (std::find (m_aUniqueLuxuryAreas.begin(), m_aUniqueLuxuryAreas.end(), iArea) != m_aUniqueLuxuryAreas.end())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR $T235346[ebp], edx
	mov	eax, DWORD PTR $T235346[ebp]
	mov	DWORD PTR $T235239[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR $T235355[ebp], edx
	mov	eax, DWORD PTR $T235355[ebp]
	mov	DWORD PTR $T235236[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	mov	DWORD PTR $T235364[ebp], edx
	mov	eax, DWORD PTR $T235364[ebp]
	mov	DWORD PTR $T235237[ebp], eax
	mov	ecx, DWORD PTR $T235237[ebp]
	mov	DWORD PTR $T235419[ebp], ecx
	mov	edx, DWORD PTR $T235236[ebp]
	mov	DWORD PTR $T235401[ebp], edx
	mov	eax, DWORD PTR $T235419[ebp]
	mov	DWORD PTR $T235400[ebp], eax
	jmp	SHORT $LN74@WillGetUni
$LN68@WillGetUni:
	mov	ecx, DWORD PTR $T235400[ebp]
	add	ecx, 4
	mov	DWORD PTR $T235400[ebp], ecx
$LN74@WillGetUni:
	mov	edx, DWORD PTR $T235400[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T235401[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN67@WillGetUni
	mov	eax, DWORD PTR $T235400[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _iArea$222754[ebp]
	jne	SHORT $LN66@WillGetUni
	jmp	SHORT $LN67@WillGetUni
$LN66@WillGetUni:
	jmp	SHORT $LN68@WillGetUni
$LN67@WillGetUni:
	mov	edx, DWORD PTR $T235400[ebp]
	mov	DWORD PTR $T235403[ebp], edx
	mov	eax, DWORD PTR $T235403[ebp]
	mov	DWORD PTR $T235419[ebp], eax
	mov	ecx, DWORD PTR $T235419[ebp]
	mov	DWORD PTR $T235238[ebp], ecx
	mov	edx, DWORD PTR $T235238[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T235239[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@WillGetUni

; 2384 : 			{
; 2385 : 				return false;

	xor	al, al
	jmp	$LN12@WillGetUni
$LN9@WillGetUni:

; 2386 : 			}
; 2387 : 		}
; 2388 : 
; 2389 : 		int iNumUniqueResourcesGiven = m_aUniqueLuxuryAreas.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 724				; 000002d4H
	mov	DWORD PTR $T235431[ebp], eax
	mov	ecx, DWORD PTR $T235431[ebp]
	mov	edx, DWORD PTR $T235431[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR _iNumUniqueResourcesGiven$222771[ebp], eax

; 2390 : 
; 2391 : 		// Loop through all resources and see if we can find one more
; 2392 : 		int iNumUniquesFound = 0;

	mov	DWORD PTR _iNumUniquesFound$222772[ebp], 0

; 2393 : #ifdef AUI_WARNING_FIXES
; 2394 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2395 : #else
; 2396 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$222773[ebp], 0
	jmp	SHORT $LN5@WillGetUni
$LN4@WillGetUni:
	mov	ecx, DWORD PTR _iResourceLoop$222773[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$222773[ebp], ecx
$LN5@WillGetUni:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222773[ebp], eax
	jge	SHORT $LN11@WillGetUni

; 2397 : #endif
; 2398 : 		{
; 2399 : 			ResourceTypes eResource = (ResourceTypes) iResourceLoop;

	mov	edx, DWORD PTR _iResourceLoop$222773[ebp]
	mov	DWORD PTR _eResource$222777[ebp], edx

; 2400 : 			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$222777[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResource$222779[ebp], eax

; 2401 : 			if (pkResource != NULL && pkResource->GetRequiredCivilization() == m_pPlayer->getCivilizationType())

	cmp	DWORD PTR _pkResource$222779[ebp], 0
	je	SHORT $LN2@WillGetUni
	mov	ecx, DWORD PTR _pkResource$222779[ebp]
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	esi, eax
	jne	SHORT $LN2@WillGetUni

; 2402 : 			{
; 2403 : 				iNumUniquesFound++;

	mov	edx, DWORD PTR _iNumUniquesFound$222772[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumUniquesFound$222772[ebp], edx

; 2404 : 				if (iNumUniquesFound > iNumUniqueResourcesGiven)

	mov	eax, DWORD PTR _iNumUniquesFound$222772[ebp]
	cmp	eax, DWORD PTR _iNumUniqueResourcesGiven$222771[ebp]
	jle	SHORT $LN2@WillGetUni

; 2405 : 				{
; 2406 : 					return true;

	mov	al, 1
	jmp	SHORT $LN12@WillGetUni
$LN2@WillGetUni:

; 2407 : 				}
; 2408 : 			}
; 2409 : 		}

	jmp	SHORT $LN4@WillGetUni
$LN11@WillGetUni:

; 2410 : 	}
; 2411 : 
; 2412 : 	return false;

	xor	al, al
$LN12@WillGetUni:

; 2413 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z ENDP ; CvPlayerTraits::WillGetUniqueLuxury
_TEXT	ENDS
PUBLIC	?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z ; CvPlayerTraits::GetMovesChangeUnitCombat
; Function compile flags: /Odtp
;	COMDAT ?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_unitCombatID$ = 8					; size = 4
?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z PROC	; CvPlayerTraits::GetMovesChangeUnitCombat, COMDAT
; _this$ = ecx

; 2417 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2418 : 	CvAssertMsg(unitCombatID < GC.getNumUnitCombatClassInfos(),  "Invalid unitCombatID parameter in call to CvPlayerTraits::GetMovesChangeUnitCombat()");
; 2419 : 
; 2420 : 	if(unitCombatID == NO_UNITCLASS)

	cmp	DWORD PTR _unitCombatID$[ebp], -1
	jne	SHORT $LN4@GetMovesCh

; 2421 : 	{
; 2422 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetMovesCh

; 2423 : 	}
; 2424 : 
; 2425 : 	return m_paiMovesChangeUnitCombat[unitCombatID];

$LN4@GetMovesCh:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+784]
	mov	edx, DWORD PTR _unitCombatID$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN2@GetMovesCh:

; 2426 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetMovesChangeUnitCombat@CvPlayerTraits@@QBEHH@Z ENDP	; CvPlayerTraits::GetMovesChangeUnitCombat
_TEXT	ENDS
PUBLIC	?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
; Function compile flags: /Odtp
;	COMDAT ?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_unitCombatID$ = 8					; size = 4
?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z PROC ; CvPlayerTraits::GetMaintenanceModifierUnitCombat, COMDAT
; _this$ = ecx

; 2430 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2431 : 	CvAssertMsg(unitCombatID < GC.getNumUnitCombatClassInfos(),  "Invalid unitCombatID parameter in call to CvPlayerTraits::GetMaintenanceModifierUnitCombat()");
; 2432 : 
; 2433 : 	if(unitCombatID == NO_UNITCLASS)

	cmp	DWORD PTR _unitCombatID$[ebp], -1
	jne	SHORT $LN4@GetMainten

; 2434 : 	{
; 2435 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetMainten

; 2436 : 	}
; 2437 : 
; 2438 : 	return m_paiMaintenanceModifierUnitCombat[unitCombatID];

$LN4@GetMainten:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	edx, DWORD PTR _unitCombatID$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
$LN2@GetMainten:

; 2439 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetMaintenanceModifierUnitCombat@CvPlayerTraits@@QBEHH@Z ENDP ; CvPlayerTraits::GetMaintenanceModifierUnitCombat
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetImprovementYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235447 = -4						; size = 4
_eImprovement$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z PROC ; CvPlayerTraits::GetImprovementYieldChange, COMDAT
; _this$ = ecx

; 2443 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2444 : 	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(),  "Invalid eImprovement parameter in call to CvPlayerTraits::GetImprovementYieldChange()");
; 2445 : 	CvAssertMsg(eYield < NUM_YIELD_TYPES,  "Invalid eYield parameter in call to CvPlayerTraits::GetImprovementYieldChange()");
; 2446 : 
; 2447 : 	if(eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	jne	SHORT $LN1@GetImprove@2

; 2448 : 	{
; 2449 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetImprove@2
$LN1@GetImprove@2:

; 2450 : 	}
; 2451 : 
; 2452 : 	return m_ppaaiImprovementYieldChange[(int)eImprovement][(int)eYield];

	mov	eax, DWORD PTR _eImprovement$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+816]
	mov	DWORD PTR $T235447[ebp], eax
	mov	edx, DWORD PTR _eYield$[ebp]
	mov	eax, DWORD PTR $T235447[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
$LN2@GetImprove@2:

; 2453 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetImprovementYieldChange
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetSpecialistYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235456 = -4						; size = 4
_eSpecialist$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z PROC ; CvPlayerTraits::GetSpecialistYieldChange, COMDAT
; _this$ = ecx

; 2457 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2458 : 	CvAssertMsg(eSpecialist < GC.getNumSpecialistInfos(),  "Invalid eSpecialist parameter in call to CvPlayerTraits::GetSpecialistYieldChange()");
; 2459 : 	CvAssertMsg(eYield < NUM_YIELD_TYPES,  "Invalid eYield parameter in call to CvPlayerTraits::GetSpecialistYieldChange()");
; 2460 : 
; 2461 : 	if(eSpecialist == NO_SPECIALIST)

	cmp	DWORD PTR _eSpecialist$[ebp], -1
	jne	SHORT $LN1@GetSpecial@2

; 2462 : 	{
; 2463 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetSpecial@2
$LN1@GetSpecial@2:

; 2464 : 	}
; 2465 : 
; 2466 : 	return m_ppaaiSpecialistYieldChange[(int)eSpecialist][(int)eYield];

	mov	eax, DWORD PTR _eSpecialist$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+832]
	mov	DWORD PTR $T235456[ebp], eax
	mov	edx, DWORD PTR _eYield$[ebp]
	mov	eax, DWORD PTR $T235456[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
$LN2@GetSpecial@2:

; 2467 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetSpecialistYieldChange@CvPlayerTraits@@QBEHW4SpecialistTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetSpecialistYieldChange
_TEXT	ENDS
PUBLIC	?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235465 = -4						; size = 4
_eFeature$ = 8						; size = 4
_eYield$ = 12						; size = 4
?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z PROC ; CvPlayerTraits::GetUnimprovedFeatureYieldChange, COMDAT
; _this$ = ecx

; 2485 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2486 : 	CvAssertMsg(eFeature < GC.getNumFeatureInfos(),  "Invalid eImprovement parameter in call to CvPlayerTraits::GetUnimprovedFeatureYieldChange()");
; 2487 : 	CvAssertMsg(eYield < NUM_YIELD_TYPES,  "Invalid eYield parameter in call to CvPlayerTraits::GetUnimprovedFeatureYieldChange()");
; 2488 : 
; 2489 : 	if(eFeature == NO_FEATURE)

	cmp	DWORD PTR _eFeature$[ebp], -1
	jne	SHORT $LN1@GetUnimpro@2

; 2490 : 	{
; 2491 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetUnimpro@2
$LN1@GetUnimpro@2:

; 2492 : 	}
; 2493 : 
; 2494 : 	return m_ppaaiUnimprovedFeatureYieldChange[(int)eFeature][(int)eYield];

	mov	eax, DWORD PTR _eFeature$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+848]
	mov	DWORD PTR $T235465[ebp], eax
	mov	edx, DWORD PTR _eYield$[ebp]
	mov	eax, DWORD PTR $T235465[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
$LN2@GetUnimpro@2:

; 2495 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
_TEXT	ENDS
PUBLIC	?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z ; CvPlayerTraits::HasFreePromotionUnitCombat
; Function compile flags: /Odtp
;	COMDAT ?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_eTrait$222825 = -12					; size = 4
_pkTraitInfo$222827 = -8				; size = 4
_iI$222821 = -4						; size = 4
_promotionID$ = 8					; size = 4
_unitCombatID$ = 12					; size = 4
?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z PROC ; CvPlayerTraits::HasFreePromotionUnitCombat, COMDAT
; _this$ = ecx

; 2499 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2500 : 	CvAssertMsg((promotionID >= 0), "promotionID is less than zero");
; 2501 : #ifdef AUI_WARNING_FIXES
; 2502 : 	for (uint iI = 0; iI < GC.getNumTraitInfos(); iI++)
; 2503 : #else
; 2504 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	DWORD PTR _iI$222821[ebp], 0
	jmp	SHORT $LN6@HasFreePro
$LN5@HasFreePro:
	mov	eax, DWORD PTR _iI$222821[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222821[ebp], eax
$LN6@HasFreePro:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	DWORD PTR _iI$222821[ebp], eax
	jge	SHORT $LN4@HasFreePro

; 2505 : #endif
; 2506 : 	{
; 2507 : 		const TraitTypes eTrait = static_cast<TraitTypes>(iI);

	mov	ecx, DWORD PTR _iI$222821[ebp]
	mov	DWORD PTR _eTrait$222825[ebp], ecx

; 2508 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(eTrait);

	mov	edx, DWORD PTR _eTrait$222825[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$222827[ebp], eax

; 2509 : 		if(pkTraitInfo)

	cmp	DWORD PTR _pkTraitInfo$222827[ebp], 0
	je	SHORT $LN3@HasFreePro

; 2510 : 		{
; 2511 : 			if(HasTrait(eTrait))

	mov	eax, DWORD PTR _eTrait$222825[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@HasFreePro

; 2512 : 			{
; 2513 : 				if(pkTraitInfo->IsFreePromotionUnitCombat(promotionID, unitCombatID))

	mov	edx, DWORD PTR _unitCombatID$[ebp]
	push	edx
	mov	eax, DWORD PTR _promotionID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkTraitInfo$222827[ebp]
	call	?IsFreePromotionUnitCombat@CvTraitEntry@@QBE_NHH@Z ; CvTraitEntry::IsFreePromotionUnitCombat
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@HasFreePro

; 2514 : 				{
; 2515 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@HasFreePro
$LN3@HasFreePro:

; 2516 : 				}
; 2517 : 			}
; 2518 : 		}
; 2519 : 	}

	jmp	SHORT $LN5@HasFreePro
$LN4@HasFreePro:

; 2520 : 
; 2521 : 	return false;

	xor	al, al
$LN7@HasFreePro:

; 2522 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HasFreePromotionUnitCombat@CvPlayerTraits@@QBE_NHH@Z ENDP ; CvPlayerTraits::HasFreePromotionUnitCombat
_TEXT	ENDS
PUBLIC	?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T235484 = -20						; size = 4
$T235480 = -16						; size = 4
$T235476 = -12						; size = 4
_pkTraitInfo$222838 = -8				; size = 4
_iI$222834 = -4						; size = 4
?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ PROC ; CvPlayerTraits::GetFreeBuilding, COMDAT
; _this$ = ecx

; 2526 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2527 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	DWORD PTR _iI$222834[ebp], 0
	jmp	SHORT $LN5@GetFreeBui
$LN4@GetFreeBui:
	mov	eax, DWORD PTR _iI$222834[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222834[ebp], eax
$LN5@GetFreeBui:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T235476[ebp], ecx
	mov	edx, DWORD PTR $T235476[ebp]
	mov	eax, DWORD PTR $T235476[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$222834[ebp], ecx
	jae	SHORT $LN3@GetFreeBui

; 2528 : 	{
; 2529 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222834[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235480[ebp], edx
	mov	eax, DWORD PTR $T235480[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$222838[ebp], eax

; 2530 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]))

	cmp	DWORD PTR _pkTraitInfo$222838[ebp], 0
	je	SHORT $LN2@GetFreeBui
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222834[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235484[ebp], edx
	mov	eax, DWORD PTR $T235484[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetFreeBui

; 2531 : 		{
; 2532 : 			if(pkTraitInfo->GetFreeBuilding()!=NO_BUILDING)

	mov	ecx, DWORD PTR _pkTraitInfo$222838[ebp]
	call	?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuilding
	cmp	eax, -1
	je	SHORT $LN2@GetFreeBui

; 2533 : 			{
; 2534 : 				return pkTraitInfo->GetFreeBuilding();

	mov	ecx, DWORD PTR _pkTraitInfo$222838[ebp]
	call	?GetFreeBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuilding
	jmp	SHORT $LN6@GetFreeBui
$LN2@GetFreeBui:

; 2535 : 			}
; 2536 : 		}
; 2537 : 	}

	jmp	$LN4@GetFreeBui
$LN3@GetFreeBui:

; 2538 : 
; 2539 : 
; 2540 : 	return NO_BUILDING;

	or	eax, -1
$LN6@GetFreeBui:

; 2541 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPlayerTraits::GetFreeBuilding
_TEXT	ENDS
PUBLIC	?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeCapitalBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T235498 = -20						; size = 4
$T235494 = -16						; size = 4
$T235490 = -12						; size = 4
_pkTraitInfo$222848 = -8				; size = 4
_iI$222844 = -4						; size = 4
?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ PROC ; CvPlayerTraits::GetFreeCapitalBuilding, COMDAT
; _this$ = ecx

; 2544 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2545 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	DWORD PTR _iI$222844[ebp], 0
	jmp	SHORT $LN5@GetFreeCap
$LN4@GetFreeCap:
	mov	eax, DWORD PTR _iI$222844[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222844[ebp], eax
$LN5@GetFreeCap:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T235490[ebp], ecx
	mov	edx, DWORD PTR $T235490[ebp]
	mov	eax, DWORD PTR $T235490[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$222844[ebp], ecx
	jae	SHORT $LN3@GetFreeCap

; 2546 : 	{
; 2547 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222844[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235494[ebp], edx
	mov	eax, DWORD PTR $T235494[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$222848[ebp], eax

; 2548 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]))

	cmp	DWORD PTR _pkTraitInfo$222848[ebp], 0
	je	SHORT $LN2@GetFreeCap
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222844[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235498[ebp], edx
	mov	eax, DWORD PTR $T235498[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetFreeCap

; 2549 : 		{
; 2550 : 			if(pkTraitInfo->GetFreeCapitalBuilding()!=NO_BUILDING)

	mov	ecx, DWORD PTR _pkTraitInfo$222848[ebp]
	call	?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeCapitalBuilding
	cmp	eax, -1
	je	SHORT $LN2@GetFreeCap

; 2551 : 			{
; 2552 : 				return pkTraitInfo->GetFreeCapitalBuilding();

	mov	ecx, DWORD PTR _pkTraitInfo$222848[ebp]
	call	?GetFreeCapitalBuilding@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeCapitalBuilding
	jmp	SHORT $LN6@GetFreeCap
$LN2@GetFreeCap:

; 2553 : 			}
; 2554 : 		}
; 2555 : 	}

	jmp	$LN4@GetFreeCap
$LN3@GetFreeCap:

; 2556 : 
; 2557 : 	return NO_BUILDING;

	or	eax, -1
$LN6@GetFreeCap:

; 2558 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeCapitalBuilding@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPlayerTraits::GetFreeCapitalBuilding
_TEXT	ENDS
PUBLIC	?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ; CvPlayerTraits::GetFreeBuildingOnConquest
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T235512 = -20						; size = 4
$T235508 = -16						; size = 4
$T235504 = -12						; size = 4
_pkTraitInfo$222858 = -8				; size = 4
_iI$222854 = -4						; size = 4
?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ PROC ; CvPlayerTraits::GetFreeBuildingOnConquest, COMDAT
; _this$ = ecx

; 2563 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2564 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	DWORD PTR _iI$222854[ebp], 0
	jmp	SHORT $LN5@GetFreeBui@2
$LN4@GetFreeBui@2:
	mov	eax, DWORD PTR _iI$222854[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222854[ebp], eax
$LN5@GetFreeBui@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T235504[ebp], ecx
	mov	edx, DWORD PTR $T235504[ebp]
	mov	eax, DWORD PTR $T235504[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$222854[ebp], ecx
	jae	SHORT $LN3@GetFreeBui@2

; 2565 : 	{
; 2566 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222854[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235508[ebp], edx
	mov	eax, DWORD PTR $T235508[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$222858[ebp], eax

; 2567 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]))

	cmp	DWORD PTR _pkTraitInfo$222858[ebp], 0
	je	SHORT $LN2@GetFreeBui@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222854[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235512[ebp], edx
	mov	eax, DWORD PTR $T235512[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetFreeBui@2

; 2568 : 		{
; 2569 : 			if(pkTraitInfo->GetFreeBuildingOnConquest()!=NO_BUILDING)

	mov	ecx, DWORD PTR _pkTraitInfo$222858[ebp]
	call	?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuildingOnConquest
	cmp	eax, -1
	je	SHORT $LN2@GetFreeBui@2

; 2570 : 			{
; 2571 : 				return pkTraitInfo->GetFreeBuildingOnConquest();

	mov	ecx, DWORD PTR _pkTraitInfo$222858[ebp]
	call	?GetFreeBuildingOnConquest@CvTraitEntry@@QBE?AW4BuildingTypes@@XZ ; CvTraitEntry::GetFreeBuildingOnConquest
	jmp	SHORT $LN6@GetFreeBui@2
$LN2@GetFreeBui@2:

; 2572 : 			}
; 2573 : 		}
; 2574 : 	}

	jmp	$LN4@GetFreeBui@2
$LN3@GetFreeBui@2:

; 2575 : 
; 2576 : 	return NO_BUILDING;

	or	eax, -1
$LN6@GetFreeBui@2:

; 2577 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuildingOnConquest@CvPlayerTraits@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPlayerTraits::GetFreeBuildingOnConquest
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z ; CvPlayerTraits::AddUniqueLuxuries
EXTRN	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlot::setResourceType
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Odtp
;	COMDAT ?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
tv229 = -212						; size = 4
tv241 = -208						; size = 4
_this$ = -204						; size = 4
$T235887 = -200						; size = 4
$T235733 = -128						; size = 4
$T235711 = -124						; size = 4
$T235710 = -120						; size = 4
$T235713 = -116						; size = 4
$T235658 = -112						; size = 4
$T235642 = -108						; size = 4
$T235626 = -104						; size = 4
$T235616 = -100						; size = 4
$T235612 = -96						; size = 4
$T235611 = -92						; size = 4
$T235572 = -88						; size = 4
$T235559 = -84						; size = 4
$T235555 = -80						; size = 4
$T235548 = -76						; size = 4
$T235544 = -69						; size = 1
$T235533 = -68						; size = 4
$T235529 = -61						; size = 1
_iMapY$235610 = -60					; size = 4
_iMapX$235609 = -56					; size = 4
$T235522 = -52						; size = 4
$T235518 = -48						; size = 4
$T235517 = -44						; size = 4
$T235516 = -40						; size = 4
$T235515 = -36						; size = 4
_eResource$222892 = -32					; size = 4
_pkResource$222894 = -28				; size = 4
_iResourceLoop$222888 = -24				; size = 4
_pOriginalCapitalPlot$222870 = -20			; size = 4
_iArea$222868 = -16					; size = 4
_iNumUniquesFound$222887 = -12				; size = 4
_iNumUniqueResourcesGiven$222885 = -8			; size = 4
_eResourceToGive$222886 = -4				; size = 4
_pCity$ = 8						; size = 4
?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z PROC ; CvPlayerTraits::AddUniqueLuxuries, COMDAT
; _this$ = ecx

; 2581 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2582 : 	// Still have more of these cities to award?
; 2583 : 	if (m_iUniqueLuxuryCities > m_iUniqueLuxuryCitiesPlaced)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+300]
	cmp	edx, DWORD PTR [ecx+308]
	jle	$LN14@AddUniqueL

; 2584 : 	{
; 2585 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area BEGIN
; 2586 : 		if (m_pPlayer->GetNumCitiesFounded() == 1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumCitiesFounded@CvPlayer@@QBEHXZ	; CvPlayer::GetNumCitiesFounded
	cmp	eax, 1
	jne	SHORT $LN12@AddUniqueL

; 2587 : 		{
; 2588 : 			return;

	jmp	$LN14@AddUniqueL
$LN12@AddUniqueL:

; 2589 : 		}
; 2590 : 		// NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area END
; 2591 : 
; 2592 : 		// NQMP GJS - Spice Islanders must be coastal BEGIN
; 2593 : 		if (!pCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@AddUniqueL

; 2594 : 		{
; 2595 : 			return;

	jmp	$LN14@AddUniqueL
$LN11@AddUniqueL:

; 2596 : 		}
; 2597 : 		// NQMP GJS - Spice Islanders must be coastal END
; 2598 : 
; 2599 : 		int iArea = pCity->getArea();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	DWORD PTR _iArea$222868[ebp], eax

; 2600 : 
; 2601 : 		// If we have to be in a new area, check to see if this area is okay
; 2602 : 		if (m_bUniqueLuxuryRequiresNewArea)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+353]
	test	eax, eax
	je	$LN10@AddUniqueL

; 2603 : 		{
; 2604 : 			/* NQMP GJS - Spice Islanders changed it so this ability will NEVER trigger in the capital, even if it's not requiring a new area
; 2605 : 			// Can't be the capital itself of the area where the capital was founded
; 2606 : 			if (m_pPlayer->GetNumCitiesFounded() == 1)
; 2607 : 			{
; 2608 : 				return;
; 2609 : 			}
; 2610 : 			*/
; 2611 : 
; 2612 : 			CvPlot *pOriginalCapitalPlot = GC.getMap().plot(m_pPlayer->GetOriginalCapitalX(), m_pPlayer->GetOriginalCapitalY());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235522[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetOriginalCapitalY@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalY
	mov	DWORD PTR $T235612[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetOriginalCapitalX@CvPlayer@@QBEHXZ	; CvPlayer::GetOriginalCapitalX
	mov	DWORD PTR $T235611[ebp], eax
	cmp	DWORD PTR $T235611[ebp], -2147483647	; 80000001H
	je	SHORT $LN18@AddUniqueL
	cmp	DWORD PTR $T235612[ebp], -2147483647	; 80000001H
	jne	SHORT $LN19@AddUniqueL
$LN18@AddUniqueL:
	mov	DWORD PTR _pOriginalCapitalPlot$222870[ebp], 0
	jmp	$LN20@AddUniqueL
$LN19@AddUniqueL:
	mov	ecx, DWORD PTR $T235522[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T235529[ebp], dl
	mov	eax, DWORD PTR $T235522[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T235533[ebp], ecx
	movzx	edx, BYTE PTR $T235529[ebp]
	test	edx, edx
	je	SHORT $LN31@AddUniqueL
	cmp	DWORD PTR $T235611[ebp], 0
	jge	SHORT $LN30@AddUniqueL
	mov	eax, DWORD PTR $T235611[ebp]
	cdq
	idiv	DWORD PTR $T235533[ebp]
	add	edx, DWORD PTR $T235533[ebp]
	mov	DWORD PTR _iMapX$235609[ebp], edx
	jmp	SHORT $LN32@AddUniqueL
	jmp	SHORT $LN31@AddUniqueL
$LN30@AddUniqueL:
	mov	eax, DWORD PTR $T235611[ebp]
	cmp	eax, DWORD PTR $T235533[ebp]
	jl	SHORT $LN31@AddUniqueL
	mov	eax, DWORD PTR $T235611[ebp]
	cdq
	idiv	DWORD PTR $T235533[ebp]
	mov	DWORD PTR _iMapX$235609[ebp], edx
	jmp	SHORT $LN32@AddUniqueL
$LN31@AddUniqueL:
	mov	ecx, DWORD PTR $T235611[ebp]
	mov	DWORD PTR _iMapX$235609[ebp], ecx
$LN32@AddUniqueL:
	mov	edx, DWORD PTR $T235522[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T235544[ebp], al
	mov	ecx, DWORD PTR $T235522[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T235548[ebp], edx
	movzx	eax, BYTE PTR $T235544[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235548[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235612[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$235610[ebp], eax
	cmp	DWORD PTR _iMapX$235609[ebp], 0
	jl	SHORT $LN40@AddUniqueL
	mov	eax, DWORD PTR $T235522[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T235555[ebp], ecx
	mov	edx, DWORD PTR _iMapX$235609[ebp]
	cmp	edx, DWORD PTR $T235555[ebp]
	jge	SHORT $LN40@AddUniqueL
	cmp	DWORD PTR _iMapY$235610[ebp], 0
	jl	SHORT $LN40@AddUniqueL
	mov	eax, DWORD PTR $T235522[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T235559[ebp], ecx
	mov	edx, DWORD PTR _iMapY$235610[ebp]
	cmp	edx, DWORD PTR $T235559[ebp]
	jge	SHORT $LN40@AddUniqueL
	mov	DWORD PTR tv241[ebp], 1
	jmp	SHORT $LN38@AddUniqueL
$LN40@AddUniqueL:
	mov	DWORD PTR tv241[ebp], 0
$LN38@AddUniqueL:
	cmp	DWORD PTR tv241[ebp], 0
	je	SHORT $LN22@AddUniqueL
	mov	eax, DWORD PTR $T235522[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T235572[ebp], ecx
	mov	edx, DWORD PTR _iMapY$235610[ebp]
	imul	edx, DWORD PTR $T235572[ebp]
	add	edx, DWORD PTR _iMapX$235609[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T235522[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv229[ebp], edx
	jmp	SHORT $LN23@AddUniqueL
$LN22@AddUniqueL:
	mov	DWORD PTR tv229[ebp], 0
$LN23@AddUniqueL:
	mov	ecx, DWORD PTR tv229[ebp]
	mov	DWORD PTR _pOriginalCapitalPlot$222870[ebp], ecx
$LN20@AddUniqueL:

; 2613 : 			if (pOriginalCapitalPlot)

	cmp	DWORD PTR _pOriginalCapitalPlot$222870[ebp], 0
	je	SHORT $LN9@AddUniqueL

; 2614 : 			{
; 2615 : 				if (pOriginalCapitalPlot->getArea() == iArea)

	mov	edx, DWORD PTR _pOriginalCapitalPlot$222870[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T235616[ebp], eax
	mov	ecx, DWORD PTR $T235616[ebp]
	cmp	ecx, DWORD PTR _iArea$222868[ebp]
	jne	SHORT $LN9@AddUniqueL

; 2616 : 				{
; 2617 : 					return;

	jmp	$LN14@AddUniqueL
$LN9@AddUniqueL:

; 2618 : 				}
; 2619 : 			}
; 2620 : 
; 2621 : 			// Already in the list?
; 2622 : 			if (std::find (m_aUniqueLuxuryAreas.begin(), m_aUniqueLuxuryAreas.end(), iArea) != m_aUniqueLuxuryAreas.end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR $T235626[ebp], eax
	mov	ecx, DWORD PTR $T235626[ebp]
	mov	DWORD PTR $T235518[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+732]
	mov	DWORD PTR $T235642[ebp], eax
	mov	ecx, DWORD PTR $T235642[ebp]
	mov	DWORD PTR $T235515[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+728]
	mov	DWORD PTR $T235658[ebp], eax
	mov	ecx, DWORD PTR $T235658[ebp]
	mov	DWORD PTR $T235516[ebp], ecx
	mov	edx, DWORD PTR $T235516[ebp]
	mov	DWORD PTR $T235733[ebp], edx
	mov	eax, DWORD PTR $T235515[ebp]
	mov	DWORD PTR $T235711[ebp], eax
	mov	ecx, DWORD PTR $T235733[ebp]
	mov	DWORD PTR $T235710[ebp], ecx
	jmp	SHORT $LN82@AddUniqueL
$LN74@AddUniqueL:
	mov	edx, DWORD PTR $T235710[ebp]
	add	edx, 4
	mov	DWORD PTR $T235710[ebp], edx
$LN82@AddUniqueL:
	mov	eax, DWORD PTR $T235710[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T235711[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN73@AddUniqueL
	mov	ecx, DWORD PTR $T235710[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _iArea$222868[ebp]
	jne	SHORT $LN72@AddUniqueL
	jmp	SHORT $LN73@AddUniqueL
$LN72@AddUniqueL:
	jmp	SHORT $LN74@AddUniqueL
$LN73@AddUniqueL:
	mov	eax, DWORD PTR $T235710[ebp]
	mov	DWORD PTR $T235713[ebp], eax
	mov	ecx, DWORD PTR $T235713[ebp]
	mov	DWORD PTR $T235733[ebp], ecx
	mov	edx, DWORD PTR $T235733[ebp]
	mov	DWORD PTR $T235517[ebp], edx
	mov	eax, DWORD PTR $T235517[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T235518[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN10@AddUniqueL

; 2623 : 			{
; 2624 : 				return;

	jmp	$LN14@AddUniqueL
$LN10@AddUniqueL:

; 2625 : 			}
; 2626 : 		}
; 2627 : 
; 2628 : 		m_aUniqueLuxuryAreas.push_back(iArea);  		// Store area

	lea	ecx, DWORD PTR _iArea$222868[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 2629 : 		int iNumUniqueResourcesGiven = m_aUniqueLuxuryAreas.size();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 724				; 000002d4H
	mov	DWORD PTR $T235887[ebp], edx
	mov	eax, DWORD PTR $T235887[ebp]
	mov	ecx, DWORD PTR $T235887[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR _iNumUniqueResourcesGiven$222885[ebp], edx

; 2630 : 		m_iUniqueLuxuryCitiesPlaced++;   // One less to give out

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+308], ecx

; 2631 : 
; 2632 : 		// Loop through all resources and see if we can find this many unique ones
; 2633 : 		ResourceTypes eResourceToGive = NO_RESOURCE;

	mov	DWORD PTR _eResourceToGive$222886[ebp], -1

; 2634 : 		int iNumUniquesFound = 0;

	mov	DWORD PTR _iNumUniquesFound$222887[ebp], 0

; 2635 : #ifdef AUI_WARNING_FIXES
; 2636 : 		for (uint iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)
; 2637 : #else
; 2638 : 		for(int iResourceLoop = 0; iResourceLoop < GC.getNumResourceInfos(); iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$222888[ebp], 0
	jmp	SHORT $LN6@AddUniqueL
$LN5@AddUniqueL:
	mov	eax, DWORD PTR _iResourceLoop$222888[ebp]
	add	eax, 1
	mov	DWORD PTR _iResourceLoop$222888[ebp], eax
$LN6@AddUniqueL:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _iResourceLoop$222888[ebp], eax
	jge	SHORT $LN4@AddUniqueL

; 2639 : #endif
; 2640 : 		{
; 2641 : 			ResourceTypes eResource = (ResourceTypes) iResourceLoop;

	mov	ecx, DWORD PTR _iResourceLoop$222888[ebp]
	mov	DWORD PTR _eResource$222892[ebp], ecx

; 2642 : 			CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	mov	edx, DWORD PTR _eResource$222892[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResource$222894[ebp], eax

; 2643 : 			if (pkResource != NULL && pkResource->GetRequiredCivilization() == m_pPlayer->getCivilizationType())

	cmp	DWORD PTR _pkResource$222894[ebp], 0
	je	SHORT $LN3@AddUniqueL
	mov	ecx, DWORD PTR _pkResource$222894[ebp]
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	esi, eax
	jne	SHORT $LN3@AddUniqueL

; 2644 : 			{
; 2645 : 				iNumUniquesFound++;

	mov	ecx, DWORD PTR _iNumUniquesFound$222887[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumUniquesFound$222887[ebp], ecx

; 2646 : 				if (iNumUniquesFound == iNumUniqueResourcesGiven)

	mov	edx, DWORD PTR _iNumUniquesFound$222887[ebp]
	cmp	edx, DWORD PTR _iNumUniqueResourcesGiven$222885[ebp]
	jne	SHORT $LN3@AddUniqueL

; 2647 : 				{
; 2648 : 					eResourceToGive = eResource;

	mov	eax, DWORD PTR _eResource$222892[ebp]
	mov	DWORD PTR _eResourceToGive$222886[ebp], eax

; 2649 : 					break;

	jmp	SHORT $LN4@AddUniqueL
$LN3@AddUniqueL:

; 2650 : 				}
; 2651 : 			}
; 2652 : 		}

	jmp	SHORT $LN5@AddUniqueL
$LN4@AddUniqueL:

; 2653 : 
; 2654 : 		if (eResourceToGive != NO_RESOURCE)

	cmp	DWORD PTR _eResourceToGive$222886[ebp], -1
	je	SHORT $LN14@AddUniqueL

; 2655 : 		{
; 2656 : 			pCity->plot()->setResourceType(NO_RESOURCE, 0, true);

	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType

; 2657 : 			pCity->plot()->setResourceType(eResourceToGive, m_iUniqueLuxuryQuantity, true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+304]
	push	edx
	mov	eax, DWORD PTR _eResourceToGive$222886[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
$LN14@AddUniqueL:

; 2658 : 		}
; 2659 : 	}
; 2660 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddUniqueLuxuries@CvPlayerTraits@@QAEXPAVCvCity@@@Z ENDP ; CvPlayerTraits::AddUniqueLuxuries
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z ; CvPlayerTraits::ConvertBarbarianCamp
PUBLIC	?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlayerTraits::ConvertBarbarianNavalUnit
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z ; CvPlayerTraits::CheckForBarbarianConversion
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z$0
__ehfuncinfo$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
tv167 = -149						; size = 1
tv166 = -148						; size = 4
_this$ = -144						; size = 4
$T236107 = -140						; size = 4
$T236103 = -136						; size = 4
$T236090 = -132						; size = 4
$T235907 = -48						; size = 4
$T235903 = -44						; size = 4
$T235899 = -40						; size = 4
$T235890 = -36						; size = 4
_pNavalUnit$222912 = -32				; size = 8
_bRtnValue$ = -21					; size = 1
_iI$ = -20						; size = 4
_pAdjacentPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z PROC ; CvPlayerTraits::CheckForBarbarianConversion, COMDAT
; _this$ = ecx

; 2664 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2665 : 	// Loop through all adjacent plots
; 2666 : 	CvPlot* pAdjacentPlot;
; 2667 : 	int iI;
; 2668 : 	bool bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[ebp], 0

; 2669 : 
; 2670 : 	if(pPlot->isWater() && GetSeaBarbarianConversionPercent() > 0)

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN10@CheckForBa
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T235899[ebp], edx
	cmp	DWORD PTR $T235899[ebp], 0
	jle	$LN10@CheckForBa

; 2671 : 	{
; 2672 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN9@CheckForBa
$LN8@CheckForBa:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN9@CheckForBa:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN7@CheckForBa

; 2673 : 		{
; 2674 : 			pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235903[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T235907[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T235903[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235907[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 2675 : 
; 2676 : 			if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	$LN6@CheckForBa

; 2677 : 			{
; 2678 : 				if(pAdjacentPlot->isWater())

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN6@CheckForBa

; 2679 : 				{
; 2680 : 					UnitHandle pNavalUnit = pAdjacentPlot->getBestDefender(BARBARIAN_PLAYER);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	63					; 0000003fH
	lea	eax, DWORD PTR _pNavalUnit$222912[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2681 : 					if(pNavalUnit)

	xor	ecx, ecx
	cmp	DWORD PTR _pNavalUnit$222912[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@CheckForBa

; 2682 : 					{
; 2683 : 						if(ConvertBarbarianNavalUnit(pNavalUnit))

	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T235890[ebp], esp
	mov	DWORD PTR $T236090[ebp], eax
	mov	ecx, DWORD PTR $T236090[ebp]
	mov	edx, DWORD PTR _pNavalUnit$222912[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T236090[ebp]
	mov	cl, BYTE PTR _pNavalUnit$222912[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T236090[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN98@CheckForBa
	mov	eax, DWORD PTR $T236090[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN98@CheckForBa:
	mov	ecx, DWORD PTR $T236090[ebp]
	mov	DWORD PTR tv166[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlayerTraits::ConvertBarbarianNavalUnit
	mov	BYTE PTR tv167[ebp], al
	movzx	edx, BYTE PTR tv167[ebp]
	test	edx, edx
	je	SHORT $LN4@CheckForBa

; 2684 : 						{
; 2685 : 							bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
$LN4@CheckForBa:

; 2686 : 						}
; 2687 : 					}
; 2688 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pNavalUnit$222912[ebp], 0
	je	SHORT $LN6@CheckForBa
	mov	ecx, DWORD PTR _pNavalUnit$222912[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@CheckForBa:

; 2689 : 			}
; 2690 : 		}

	jmp	$LN8@CheckForBa
$LN7@CheckForBa:

; 2691 : 	}
; 2692 : 
; 2693 : 	else if(GetLandBarbarianConversionPercent() > 0 && pPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT() &&

	jmp	SHORT $LN2@CheckForBa
$LN10@CheckForBa:

; 2694 : 	        m_eCampGuardType != NO_UNIT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T236103[ebp], ecx
	cmp	DWORD PTR $T236103[ebp], 0
	jle	SHORT $LN2@CheckForBa
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T236107[ebp], edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR $T236107[ebp]
	jne	SHORT $LN2@CheckForBa
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+356], -1
	je	SHORT $LN2@CheckForBa

; 2695 : 	{
; 2696 : 		bRtnValue = ConvertBarbarianCamp(pPlot);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z ; CvPlayerTraits::ConvertBarbarianCamp
	mov	BYTE PTR _bRtnValue$[ebp], al
$LN2@CheckForBa:

; 2697 : 	}
; 2698 : 
; 2699 : 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[ebp]

; 2700 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pNavalUnit$222912[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckForBarbarianConversion@CvPlayerTraits@@QAE_NPAVCvPlot@@@Z ENDP ; CvPlayerTraits::CheckForBarbarianConversion
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T236320 = -80						; size = 4
$T236275 = -76						; size = 4
$T236262 = -72						; size = 4
$T236258 = -68						; size = 4
$T236244 = -64						; size = 4
$T236240 = -57						; size = 1
$T236229 = -56						; size = 4
$T236225 = -49						; size = 1
_iMapY$236308 = -48					; size = 4
_iMapX$236306 = -44					; size = 4
$T236218 = -40						; size = 4
$T236194 = -36						; size = 4
$T236157 = -32						; size = 4
$T236145 = -28						; size = 4
$T236141 = -21						; size = 1
$T236130 = -20						; size = 4
$T236126 = -13						; size = 1
_iMapY$236193 = -12					; size = 4
_iMapX$236192 = -8					; size = 4
$T236119 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236119[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T236194[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T236119[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T236126[ebp], dl
	mov	eax, DWORD PTR $T236119[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T236130[ebp], ecx
	movzx	edx, BYTE PTR $T236126[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T236130[ebp]
	add	edx, DWORD PTR $T236130[ebp]
	mov	DWORD PTR _iMapX$236192[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T236130[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T236130[ebp]
	mov	DWORD PTR _iMapX$236192[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$236192[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T236119[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T236141[ebp], al
	mov	ecx, DWORD PTR $T236119[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T236145[ebp], edx
	movzx	eax, BYTE PTR $T236141[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T236145[ebp]
	add	edx, DWORD PTR $T236145[ebp]
	mov	DWORD PTR _iMapY$236193[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T236145[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T236145[ebp]
	mov	DWORD PTR _iMapY$236193[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$236193[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$236193[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$236192[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T236119[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T236119[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T236157[ebp], eax
	mov	ecx, DWORD PTR _iMapY$236193[ebp]
	imul	ecx, DWORD PTR $T236157[ebp]
	add	ecx, DWORD PTR _iMapX$236192[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T236119[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T236194[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T236194[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236218[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T236320[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T236218[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T236225[ebp], dl
	mov	eax, DWORD PTR $T236218[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T236229[ebp], ecx
	movzx	edx, BYTE PTR $T236225[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T236229[ebp]
	add	edx, DWORD PTR $T236229[ebp]
	mov	DWORD PTR _iMapX$236306[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T236229[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T236229[ebp]
	mov	DWORD PTR _iMapX$236306[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$236306[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T236218[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T236240[ebp], al
	mov	ecx, DWORD PTR $T236218[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T236244[ebp], edx
	movzx	eax, BYTE PTR $T236240[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T236244[ebp]
	add	edx, DWORD PTR $T236244[ebp]
	mov	DWORD PTR _iMapY$236308[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T236244[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T236244[ebp]
	mov	DWORD PTR _iMapY$236308[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$236308[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$236306[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T236218[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T236258[ebp], ecx
	mov	edx, DWORD PTR _iMapX$236306[ebp]
	cmp	edx, DWORD PTR $T236258[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$236308[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T236218[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T236262[ebp], ecx
	mov	edx, DWORD PTR _iMapY$236308[ebp]
	cmp	edx, DWORD PTR $T236262[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T236218[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T236275[ebp], ecx
	mov	edx, DWORD PTR _iMapY$236308[ebp]
	imul	edx, DWORD PTR $T236275[ebp]
	add	edx, DWORD PTR _iMapX$236306[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T236218[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T236320[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T236320[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z ; CvPlayerTraits::GetCapitalBuildingDiscount
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
;	COMDAT ?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pCapital$222925 = -4					; size = 4
_eBuilding$ = 8						; size = 4
?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z PROC ; CvPlayerTraits::GetCapitalBuildingDiscount, COMDAT
; _this$ = ecx

; 2704 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2705 : 	if(m_iCapitalBuildingModifier > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 0
	jle	SHORT $LN3@GetCapital

; 2706 : 	{
; 2707 : 		// Find this player's capital
; 2708 : 		CvCity* pCapital = m_pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapital$222925[ebp], eax

; 2709 : 		if(pCapital)

	cmp	DWORD PTR _pCapital$222925[ebp], 0
	je	SHORT $LN3@GetCapital

; 2710 : 		{
; 2711 : 			if(pCapital->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	edx, DWORD PTR _eBuilding$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCapital$222925[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN3@GetCapital

; 2712 : 			{
; 2713 : 				return m_iCapitalBuildingModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	jmp	SHORT $LN4@GetCapital
$LN3@GetCapital:

; 2714 : 			}
; 2715 : 		}
; 2716 : 	}
; 2717 : 	return 0;

	xor	eax, eax
$LN4@GetCapital:

; 2718 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCapitalBuildingDiscount@CvPlayerTraits@@QAEHW4BuildingTypes@@@Z ENDP ; CvPlayerTraits::GetCapitalBuildingDiscount
_TEXT	ENDS
PUBLIC	?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetFreeBuildingPrereqTech
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T236336 = -20						; size = 4
$T236332 = -16						; size = 4
$T236328 = -12						; size = 4
_pkTraitInfo$222935 = -8				; size = 4
_iI$222931 = -4						; size = 4
?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ PROC ; CvPlayerTraits::GetFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 2723 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2724 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	DWORD PTR _iI$222931[ebp], 0
	jmp	SHORT $LN4@GetFreeBui@3
$LN3@GetFreeBui@3:
	mov	eax, DWORD PTR _iI$222931[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222931[ebp], eax
$LN4@GetFreeBui@3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T236328[ebp], ecx
	mov	edx, DWORD PTR $T236328[ebp]
	mov	eax, DWORD PTR $T236328[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$222931[ebp], ecx
	jae	SHORT $LN2@GetFreeBui@3

; 2725 : 	{
; 2726 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222931[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T236332[ebp], edx
	mov	eax, DWORD PTR $T236332[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$222935[ebp], eax

; 2727 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]) && pkTraitInfo->GetFreeBuildingPrereqTech())

	cmp	DWORD PTR _pkTraitInfo$222935[ebp], 0
	je	SHORT $LN1@GetFreeBui@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222931[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T236336[ebp], edx
	mov	eax, DWORD PTR $T236336[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetFreeBui@3
	mov	ecx, DWORD PTR _pkTraitInfo$222935[ebp]
	call	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeBuildingPrereqTech
	test	eax, eax
	je	SHORT $LN1@GetFreeBui@3

; 2728 : 			return pkTraitInfo->GetFreeBuildingPrereqTech();

	mov	ecx, DWORD PTR _pkTraitInfo$222935[ebp]
	call	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeBuildingPrereqTech
	jmp	SHORT $LN5@GetFreeBui@3
$LN1@GetFreeBui@3:

; 2729 : 	}

	jmp	$LN3@GetFreeBui@3
$LN2@GetFreeBui@3:

; 2730 : 
; 2731 : 	return NO_TECH;

	or	eax, -1
$LN5@GetFreeBui@3:

; 2732 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ENDP ; CvPlayerTraits::GetFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T236350 = -20						; size = 4
$T236346 = -16						; size = 4
$T236342 = -12						; size = 4
_pkTraitInfo$222944 = -8				; size = 4
_iI$222940 = -4						; size = 4
?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ PROC ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech, COMDAT
; _this$ = ecx

; 2735 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2736 : 	for(size_t iI = 0; iI < m_vPotentiallyActiveLeaderTraits.size(); iI++)

	mov	DWORD PTR _iI$222940[ebp], 0
	jmp	SHORT $LN4@GetCapital@2
$LN3@GetCapital@2:
	mov	eax, DWORD PTR _iI$222940[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222940[ebp], eax
$LN4@GetCapital@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T236342[ebp], ecx
	mov	edx, DWORD PTR $T236342[ebp]
	mov	eax, DWORD PTR $T236342[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$222940[ebp], ecx
	jae	SHORT $LN2@GetCapital@2

; 2737 : 	{
; 2738 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(m_vPotentiallyActiveLeaderTraits[iI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222940[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T236346[ebp], edx
	mov	eax, DWORD PTR $T236346[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$222944[ebp], eax

; 2739 : 		if(pkTraitInfo && HasTrait(m_vPotentiallyActiveLeaderTraits[iI]) && pkTraitInfo->GetCapitalFreeBuildingPrereqTech())

	cmp	DWORD PTR _pkTraitInfo$222944[ebp], 0
	je	SHORT $LN1@GetCapital@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _iI$222940[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T236350[ebp], edx
	mov	eax, DWORD PTR $T236350[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetCapital@2
	mov	ecx, DWORD PTR _pkTraitInfo$222944[ebp]
	call	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
	test	eax, eax
	je	SHORT $LN1@GetCapital@2

; 2740 : 			return pkTraitInfo->GetCapitalFreeBuildingPrereqTech();

	mov	ecx, DWORD PTR _pkTraitInfo$222944[ebp]
	call	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
	jmp	SHORT $LN5@GetCapital@2
$LN1@GetCapital@2:

; 2741 : 	}

	jmp	$LN3@GetCapital@2
$LN2@GetCapital@2:

; 2742 : 
; 2743 : 	return NO_TECH;

	or	eax, -1
$LN5@GetCapital@2:

; 2744 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalFreeBuildingPrereqTech@CvPlayerTraits@@QBE?AW4TechTypes@@XZ ENDP ; CvPlayerTraits::GetCapitalFreeBuildingPrereqTech
_TEXT	ENDS
PUBLIC	?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z ; CvPlayerTraits::GetFirstFreeUnit
; Function compile flags: /Odtp
;	COMDAT ?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T236356 = -4						; size = 4
_eTech$ = 8						; size = 4
?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z PROC ; CvPlayerTraits::GetFirstFreeUnit, COMDAT
; _this$ = ecx

; 2749 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2750 : 	m_uiFreeUnitIndex = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+360], 0

; 2751 : 	m_eFreeUnitPrereqTech = eTech;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eTech$[ebp]
	mov	DWORD PTR [ecx+364], edx
$LN3@GetFirstFr:

; 2752 : 
; 2753 : 	while(m_uiFreeUnitIndex < m_aFreeTraitUnits.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T236356[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+360]
	cmp	eax, DWORD PTR $T236356[ebp]
	jae	SHORT $LN2@GetFirstFr

; 2754 : 	{
; 2755 : 		if(eTech == m_aFreeTraitUnits[m_uiFreeUnitIndex].m_ePrereqTech)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	eax, DWORD PTR _eTech$[ebp]
	cmp	eax, DWORD PTR [ecx+edx*8+4]
	jne	SHORT $LN1@GetFirstFr

; 2756 : 		{
; 2757 : 			return m_aFreeTraitUnits[m_uiFreeUnitIndex].m_iFreeUnit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	eax, DWORD PTR [ecx+edx*8]
	jmp	SHORT $LN4@GetFirstFr
$LN1@GetFirstFr:

; 2758 : 		}
; 2759 : 
; 2760 : 		m_uiFreeUnitIndex++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+360]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 2761 : 	}

	jmp	SHORT $LN3@GetFirstFr
$LN2@GetFirstFr:

; 2762 : 
; 2763 : 	return NO_UNITCLASS;

	or	eax, -1
$LN4@GetFirstFr:

; 2764 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFirstFreeUnit@CvPlayerTraits@@QAEHW4TechTypes@@@Z ENDP ; CvPlayerTraits::GetFirstFreeUnit
_TEXT	ENDS
PUBLIC	?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ		; CvPlayerTraits::GetNextFreeUnit
; Function compile flags: /Odtp
;	COMDAT ?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T236368 = -4						; size = 4
?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ PROC		; CvPlayerTraits::GetNextFreeUnit, COMDAT
; _this$ = ecx

; 2768 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2769 : 	m_uiFreeUnitIndex++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], ecx
$LN3@GetNextFre:

; 2770 : 
; 2771 : 	while(m_uiFreeUnitIndex < m_aFreeTraitUnits.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T236368[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+360]
	cmp	eax, DWORD PTR $T236368[ebp]
	jae	SHORT $LN2@GetNextFre

; 2772 : 	{
; 2773 : 		if(m_eFreeUnitPrereqTech == m_aFreeTraitUnits[m_uiFreeUnitIndex].m_ePrereqTech)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+364]
	cmp	eax, DWORD PTR [ecx+edx*8+4]
	jne	SHORT $LN1@GetNextFre

; 2774 : 		{
; 2775 : 			return m_aFreeTraitUnits[m_uiFreeUnitIndex].m_iFreeUnit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+668]
	mov	eax, DWORD PTR [ecx+edx*8]
	jmp	SHORT $LN4@GetNextFre
$LN1@GetNextFre:

; 2776 : 		}
; 2777 : 
; 2778 : 		m_uiFreeUnitIndex++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+360]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 2779 : 	}

	jmp	SHORT $LN3@GetNextFre
$LN2@GetNextFre:

; 2780 : 
; 2781 : 	return NO_UNITCLASS;

	or	eax, -1
$LN4@GetNextFre:

; 2782 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextFreeUnit@CvPlayerTraits@@QAEHXZ ENDP		; CvPlayerTraits::GetNextFreeUnit
_TEXT	ENDS
PUBLIC	?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ; CvPlayerTraits::GetFreeResourceXCities
; Function compile flags: /Odtp
;	COMDAT ?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_eResource$ = 12					; size = 4
?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z PROC ; CvPlayerTraits::GetFreeResourceXCities, COMDAT
; _this$ = ecx

; 2786 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2787 : 	return m_aFreeResourceXCities[(int)eResource];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+864]
	mov	edx, DWORD PTR _eResource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2788 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetFreeResourceXCities@CvPlayerTraits@@QBE?AUFreeResourceXCities@@W4ResourceTypes@@@Z ENDP ; CvPlayerTraits::GetFreeResourceXCities
_TEXT	ENDS
PUBLIC	?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsAbleToCrossMountains
; Function compile flags: /Odtp
;	COMDAT ?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsAbleToCrossMountains, COMDAT
; _this$ = ecx

; 2792 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2793 : 	return (m_bCrossesMountainsAfterGreatGeneral /*&& m_pPlayer->getGreatGeneralsCreated() > 0*/); // NQMP GJS - new Carthage UA no longer needs Great General

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+349]

; 2794 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAbleToCrossMountains@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsAbleToCrossMountains
_TEXT	ENDS
PUBLIC	?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z ; CvPlayerTraits::NoTrain
; Function compile flags: /Odtp
;	COMDAT ?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T236478 = -60						; size = 4
$T236468 = -56						; size = 4
$T236384 = -8						; size = 8
_eUnitClassType$ = 8					; size = 4
?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z PROC	; CvPlayerTraits::NoTrain, COMDAT
; _this$ = ecx

; 2797 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 2798 : 	if (eUnitClassType != NO_UNITCLASS)

	cmp	DWORD PTR _eUnitClassType$[ebp], -1
	je	SHORT $LN2@NoTrain@2

; 2799 : 	{
; 2800 : 		return m_abNoTrain[eUnitClassType];

	mov	eax, DWORD PTR _eUnitClassType$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236384[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T236478[ebp], eax
	mov	edx, DWORD PTR $T236478[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T236468[ebp], eax
	mov	ecx, DWORD PTR $T236478[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	eax, cl
	mov	edx, DWORD PTR $T236468[ebp]
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN3@NoTrain@2

; 2801 : 	}
; 2802 : 	else

	jmp	SHORT $LN3@NoTrain@2
$LN2@NoTrain@2:

; 2803 : 	{
; 2804 : 		return false;

	xor	al, al
$LN3@NoTrain@2:

; 2805 : 	}
; 2806 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NoTrain@CvPlayerTraits@@QAE_NW4UnitClassTypes@@@Z ENDP	; CvPlayerTraits::NoTrain
_TEXT	ENDS
PUBLIC	?NoBuild@CvPlayerTraits@@QAE_NW4ImprovementTypes@@@Z ; CvPlayerTraits::NoBuild
; Function compile flags: /Odtp
;	COMDAT ?NoBuild@CvPlayerTraits@@QAE_NW4ImprovementTypes@@@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T236575 = -60						; size = 4
$T236565 = -56						; size = 4
$T236481 = -8						; size = 8
_eImprovementType$ = 8					; size = 4
?NoBuild@CvPlayerTraits@@QAE_NW4ImprovementTypes@@@Z PROC ; CvPlayerTraits::NoBuild, COMDAT
; _this$ = ecx

; 2812 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 2813 : 	if (eImprovementType != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovementType$[ebp], -1
	je	SHORT $LN2@NoBuild@2

; 2814 : 	{
; 2815 : 		return m_abNoBuild[eImprovementType];

	mov	eax, DWORD PTR _eImprovementType$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236481[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T236575[ebp], eax
	mov	edx, DWORD PTR $T236575[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T236565[ebp], eax
	mov	ecx, DWORD PTR $T236575[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	eax, cl
	mov	edx, DWORD PTR $T236565[ebp]
	and	eax, DWORD PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN3@NoBuild@2

; 2816 : 	}
; 2817 : 	else

	jmp	SHORT $LN3@NoBuild@2
$LN2@NoBuild@2:

; 2818 : 	{
; 2819 : 		return false;

	xor	al, al
$LN3@NoBuild@2:

; 2820 : 	}
; 2821 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NoBuild@CvPlayerTraits@@QAE_NW4ImprovementTypes@@@Z ENDP ; CvPlayerTraits::NoBuild
_TEXT	ENDS
PUBLIC	?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ	; CvPlayerTraits::IsUsingMayaCalendar
; Function compile flags: /Odtp
;	COMDAT ?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_eTrait$222998 = -16					; size = 4
_pkTraitInfo$223000 = -12				; size = 4
_iI$222994 = -8						; size = 4
_iNumTraits$ = -4					; size = 4
?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ PROC	; CvPlayerTraits::IsUsingMayaCalendar, COMDAT
; _this$ = ecx

; 2834 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2835 : 	int iNumTraits = GC.getNumTraitInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	mov	DWORD PTR _iNumTraits$[ebp], eax

; 2836 : 	for(int iI = 0; iI < iNumTraits; iI++)

	mov	DWORD PTR _iI$222994[ebp], 0
	jmp	SHORT $LN7@IsUsingMay
$LN6@IsUsingMay:
	mov	eax, DWORD PTR _iI$222994[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222994[ebp], eax
$LN7@IsUsingMay:
	mov	ecx, DWORD PTR _iI$222994[ebp]
	cmp	ecx, DWORD PTR _iNumTraits$[ebp]
	jge	SHORT $LN5@IsUsingMay

; 2837 : 	{
; 2838 : 		const TraitTypes eTrait = static_cast<TraitTypes>(iI);

	mov	edx, DWORD PTR _iI$222994[ebp]
	mov	DWORD PTR _eTrait$222998[ebp], edx

; 2839 : 		CvTraitEntry* pkTraitInfo = GC.getTraitInfo(eTrait);

	mov	eax, DWORD PTR _eTrait$222998[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	DWORD PTR _pkTraitInfo$223000[ebp], eax

; 2840 : 		if(pkTraitInfo)

	cmp	DWORD PTR _pkTraitInfo$223000[ebp], 0
	je	SHORT $LN4@IsUsingMay

; 2841 : 		{
; 2842 : 			if(pkTraitInfo->IsMayaCalendarBonuses())

	mov	ecx, DWORD PTR _pkTraitInfo$223000[ebp]
	call	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsMayaCalendarBonuses
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsUsingMay

; 2843 : 			{
; 2844 : 				if(HasTrait(eTrait))

	mov	edx, DWORD PTR _eTrait$222998[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasTrait@CvPlayerTraits@@QBE_NW4TraitTypes@@@Z ; CvPlayerTraits::HasTrait
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@IsUsingMay

; 2845 : 				{
; 2846 : 					return true;

	mov	al, 1
	jmp	SHORT $LN8@IsUsingMay

; 2847 : 				}
; 2848 : 				else

	jmp	SHORT $LN4@IsUsingMay
$LN2@IsUsingMay:

; 2849 : 				{
; 2850 : 					return false;

	xor	al, al
	jmp	SHORT $LN8@IsUsingMay
$LN4@IsUsingMay:

; 2851 : 				}
; 2852 : 			}
; 2853 : 		}
; 2854 : 	}

	jmp	SHORT $LN6@IsUsingMay
$LN5@IsUsingMay:

; 2855 : 	return false;

	xor	al, al
$LN8@IsUsingMay:

; 2856 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ ENDP	; CvPlayerTraits::IsUsingMayaCalendar
_TEXT	ENDS
PUBLIC	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::ComputeMayaDate
PUBLIC	?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ	; CvPlayerTraits::IsEndOfMayaLongCount
; Function compile flags: /Odtp
;	COMDAT ?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bRtnValue$ = -1					; size = 1
?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ PROC	; CvPlayerTraits::IsEndOfMayaLongCount, COMDAT
; _this$ = ecx

; 2860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2861 : 	bool bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[ebp], 0

; 2862 : 
; 2863 : 	if (!IsUsingMayaCalendar())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingMayaCalendar@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsUsingMayaCalendar
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@IsEndOfMay

; 2864 : 	{
; 2865 : 		return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[ebp]
	jmp	SHORT $LN3@IsEndOfMay
$LN2@IsEndOfMay:

; 2866 : 	}
; 2867 : 
; 2868 : 	ComputeMayaDate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::ComputeMayaDate

; 2869 : 
; 2870 : 	if(m_iBaktunPreviousTurn + 1 == m_iBaktun)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+740]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+744]
	jne	SHORT $LN1@IsEndOfMay

; 2871 : 	{
; 2872 : 		bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
$LN1@IsEndOfMay:

; 2873 : 	}
; 2874 : 
; 2875 : 	m_iBaktunPreviousTurn = m_iBaktun;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+744]
	mov	DWORD PTR [ecx+740], eax

; 2876 : 
; 2877 : 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[ebp]
$LN3@IsEndOfMay:

; 2878 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEndOfMayaLongCount@CvPlayerTraits@@QAE_NXZ ENDP	; CvPlayerTraits::IsEndOfMayaLongCount
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0P@DJOANNIK@?$CFd?4?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ ; CvPlayerTraits::GetMayaCalendarString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT ??_C@_0P@DJOANNIK@?$CFd?4?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0P@DJOANNIK@?$CFd?4?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d.'
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ$0
__ehfuncinfo$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T236585 = -48						; size = 4
_szRtnValue$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ PROC ; CvPlayerTraits::GetMayaCalendarString, COMDAT
; _this$ = ecx

; 2882 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T236585[ebp], 0

; 2883 : 	CvString szRtnValue;

	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2884 : 	ComputeMayaDate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::ComputeMayaDate

; 2885 : 	szRtnValue.Format("%d.%d.%d.%d.%d", m_iBaktun, m_iKatun, m_iTun, m_iWinal, m_iKin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+756]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+752]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+744]
	push	eax
	push	OFFSET ??_C@_0P@DJOANNIK@?$CFd?4?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 2886 : 	return szRtnValue;

	lea	edx, DWORD PTR _szRtnValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T236585[ebp]
	or	eax, 1
	mov	DWORD PTR $T236585[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2887 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ$0:
	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ$1:
	mov	eax, DWORD PTR $T236585[ebp]
	and	eax, 1
	je	$LN5@GetMayaCal
	and	DWORD PTR $T236585[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetMayaCal:
	ret	0
__ehhandler$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMayaCalendarString@CvPlayerTraits@@QAE?AVCvString@@XZ ENDP ; CvPlayerTraits::GetMayaCalendarString
PUBLIC	??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z ; GetLocalizedText<int,int,int,int,int>
PUBLIC	??_C@_0CC@PGBGMNAE@TXT_KEY_MAYA_CALENDAR_LONG_STRIN@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ ; CvPlayerTraits::GetMayaCalendarLongString
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
;	COMDAT ??_C@_0CC@PGBGMNAE@TXT_KEY_MAYA_CALENDAR_LONG_STRIN@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CC@PGBGMNAE@TXT_KEY_MAYA_CALENDAR_LONG_STRIN@ DB 'TXT_KEY_MAYA_CAL'
	DB	'ENDAR_LONG_STRING', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$1
__ehfuncinfo$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
tv158 = -88						; size = 4
_this$ = -84						; size = 4
$T236621 = -80						; size = 4
$T236612 = -76						; size = 4
$T236608 = -72						; size = 28
_szRtnValue$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ PROC ; CvPlayerTraits::GetMayaCalendarLongString, COMDAT
; _this$ = ecx

; 2891 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T236612[ebp], 0

; 2892 : 	CvString szRtnValue;

	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2893 : 	ComputeMayaDate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeMayaDate@CvPlayerTraits@@QAEXXZ	; CvPlayerTraits::ComputeMayaDate

; 2894 : 	szRtnValue = GetLocalizedText("TXT_KEY_MAYA_CALENDAR_LONG_STRING", m_iBaktun, m_iKatun, m_iTun, m_iWinal, m_iKin);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 760				; 000002f8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 756				; 000002f4H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 752				; 000002f0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 748				; 000002ecH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	push	ecx
	push	OFFSET ??_C@_0CC@PGBGMNAE@TXT_KEY_MAYA_CALENDAR_LONG_STRIN@
	lea	edx, DWORD PTR $T236608[ebp]
	push	edx
	call	??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z ; GetLocalizedText<int,int,int,int,int>
	add	esp, 28					; 0000001cH
	mov	DWORD PTR tv158[ebp], eax
	mov	eax, DWORD PTR tv158[ebp]
	mov	DWORD PTR $T236621[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T236621[ebp]
	push	ecx
	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236608[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2895 : 	return szRtnValue;

	lea	edx, DWORD PTR _szRtnValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T236612[ebp]
	or	eax, 1
	mov	DWORD PTR $T236612[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2896 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$0:
	lea	ecx, DWORD PTR _szRtnValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$1:
	lea	ecx, DWORD PTR $T236608[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ$2:
	mov	eax, DWORD PTR $T236612[ebp]
	and	eax, 1
	je	$LN6@GetMayaCal@2
	and	DWORD PTR $T236612[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetMayaCal@2:
	ret	0
__ehhandler$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMayaCalendarLongString@CvPlayerTraits@@QAE?AVCvString@@XZ ENDP ; CvPlayerTraits::GetMayaCalendarLongString
PUBLIC	?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z ; CvPlayerTraits::SetUnitBaktun
PUBLIC	??_C@_0BD@MGIKNJB@UNIT_GREAT_ADMIRAL?$AA@	; `string'
PUBLIC	??_C@_0O@JKJEBPP@UNIT_MUSICIAN?$AA@		; `string'
PUBLIC	??_C@_0M@CNLPFHOK@UNIT_WRITER?$AA@		; `string'
PUBLIC	??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ ; `string'
PUBLIC	??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@	; `string'
PUBLIC	??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ ; `string'
PUBLIC	??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@		; `string'
PUBLIC	??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@	; `string'
PUBLIC	??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@		; `string'
PUBLIC	??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ ; `string'
PUBLIC	??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@		; `string'
PUBLIC	??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@		; `string'
PUBLIC	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
PUBLIC	??_C@_0N@FMDKANIN@UNIT_PROPHET?$AA@		; `string'
PUBLIC	?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ		; CvPlayerTraits::ChooseMayaBoost
EXTRN	?ChangeNumMayaBoosts@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumMayaBoosts
EXTRN	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z:PROC ; CvCityCitizens::DoSpawnGreatPerson
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?GetGreatPersonSpawnCity@CvPlayer@@QAEPAVCvCity@@W4UnitTypes@@@Z:PROC ; CvPlayer::GetGreatPersonSpawnCity
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getEstimateEndTurn@CvGame@@QBEHXZ:PROC		; CvGame::getEstimateEndTurn
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ:PROC ; CvDiplomacyAI::GetWonderCompetitiveness
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ:PROC ; CvGameReligions::GetNumReligionsStillToFound
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligionCreatedByPlayer
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
;	COMDAT ??_C@_0BD@MGIKNJB@UNIT_GREAT_ADMIRAL?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BD@MGIKNJB@UNIT_GREAT_ADMIRAL?$AA@ DB 'UNIT_GREAT_ADMIRAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JKJEBPP@UNIT_MUSICIAN?$AA@
CONST	SEGMENT
??_C@_0O@JKJEBPP@UNIT_MUSICIAN?$AA@ DB 'UNIT_MUSICIAN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CNLPFHOK@UNIT_WRITER?$AA@
CONST	SEGMENT
??_C@_0M@CNLPFHOK@UNIT_WRITER?$AA@ DB 'UNIT_WRITER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
CONST	SEGMENT
??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ DB 'AIGRANDSTRATEGY_CONQ'
	DB	'UEST', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@
CONST	SEGMENT
??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@ DB 'UNIT_GREAT_GENERAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
CONST	SEGMENT
??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ DB 'AIGRANDSTRATEG'
	DB	'Y_UNITED_NATIONS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@
CONST	SEGMENT
??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@ DB 'UNIT_MERCHANT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
CONST	SEGMENT
??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@ DB 'AIGRANDSTRATEGY_CULTU'
	DB	'RE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@
CONST	SEGMENT
??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@ DB 'UNIT_ARTIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
CONST	SEGMENT
??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ DB 'AIGRANDSTRATEGY_SPAC'
	DB	'ESHIP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@
CONST	SEGMENT
??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@ DB 'UNIT_SCIENTIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@
CONST	SEGMENT
??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@ DB 'UNIT_ENGINEER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMDKANIN@UNIT_PROPHET?$AA@
CONST	SEGMENT
??_C@_0N@FMDKANIN@UNIT_PROPHET?$AA@ DB 'UNIT_PROPHET', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
CONST	ENDS
;	COMDAT ?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T236671 = -48						; size = 4
$T236667 = -44						; size = 4
$T236663 = -40						; size = 4
$T236654 = -36						; size = 4
$T236645 = -32						; size = 4
_pCity$223117 = -28					; size = 4
_pMyReligion$223048 = -24				; size = 4
_eReligion$223046 = -20					; size = 4
_pReligions$223045 = -16				; size = 4
_ePossibleGreatPerson$ = -12				; size = 4
_eDesiredGreatPerson$ = -8				; size = 4
_eVictoryStrategy$ = -4					; size = 4
?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ PROC		; CvPlayerTraits::ChooseMayaBoost, COMDAT
; _this$ = ecx

; 2900 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2901 : 	UnitTypes eDesiredGreatPerson = NO_UNIT;

	mov	DWORD PTR _eDesiredGreatPerson$[ebp], -1

; 2902 : 	UnitTypes ePossibleGreatPerson;
; 2903 : 
; 2904 : 	// Go for a prophet?
; 2905 : 	ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_PROPHET", true);

	push	1
	push	OFFSET ??_C@_0N@FMDKANIN@UNIT_PROPHET?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 2906 : 	if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN40@ChooseMaya

; 2907 : 	{
; 2908 : 		CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236645[ebp], ecx
	mov	ecx, DWORD PTR $T236645[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	DWORD PTR _pReligions$223045[ebp], eax

; 2909 : 		ReligionTypes eReligion = pReligions->GetReligionCreatedByPlayer(m_pPlayer->GetID());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T236654[ebp], ecx
	mov	edx, DWORD PTR $T236654[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligions$223045[ebp]
	call	?GetReligionCreatedByPlayer@CvGameReligions@@QBE?AW4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligionCreatedByPlayer
	mov	DWORD PTR _eReligion$223046[ebp], eax

; 2910 : 
; 2911 : 		// Have a religion that isn't enhanced yet?
; 2912 : 		if(eReligion != NO_RELIGION)

	cmp	DWORD PTR _eReligion$223046[ebp], -1
	je	SHORT $LN39@ChooseMaya

; 2913 : 		{
; 2914 : 			const CvReligion* pMyReligion = pReligions->GetReligion(eReligion, m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T236663[ebp], edx
	mov	eax, DWORD PTR $T236663[ebp]
	push	eax
	mov	ecx, DWORD PTR _eReligion$223046[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pReligions$223045[ebp]
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pMyReligion$223048[ebp], eax

; 2915 : 			if(!pMyReligion->m_bEnhanced)

	mov	edx, DWORD PTR _pMyReligion$223048[ebp]
	movzx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN38@ChooseMaya

; 2916 : 			{
; 2917 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], ecx
$LN38@ChooseMaya:

; 2918 : 			}
; 2919 : 		}
; 2920 : 
; 2921 : 		// Don't have a religion and they can still be founded?
; 2922 : 		else

	jmp	SHORT $LN40@ChooseMaya
$LN39@ChooseMaya:

; 2923 : 		{
; 2924 : 			if(pReligions->GetNumReligionsStillToFound() > 0)

	mov	ecx, DWORD PTR _pReligions$223045[ebp]
	call	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ ; CvGameReligions::GetNumReligionsStillToFound
	test	eax, eax
	jle	SHORT $LN40@ChooseMaya

; 2925 : 			{
; 2926 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], edx
$LN40@ChooseMaya:

; 2927 : 			}
; 2928 : 		}
; 2929 : 	}
; 2930 : 
; 2931 : 	// Highly wonder competitive and still early in game?
; 2932 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$[ebp], -1
	jne	SHORT $LN35@ChooseMaya

; 2933 : 	{
; 2934 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ENGINEER");

	push	0
	push	OFFSET ??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 2935 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN35@ChooseMaya

; 2936 : 		{
; 2937 : 			if(m_pPlayer->GetDiplomacyAI()->GetWonderCompetitiveness() >= 8 && GC.getGame().getGameTurn() <= (GC.getGame().getEstimateEndTurn() / 2))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetWonderCompetitiveness@CvDiplomacyAI@@QBEHXZ ; CvDiplomacyAI::GetWonderCompetitiveness
	cmp	eax, 8
	jl	SHORT $LN35@ChooseMaya
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236667[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236671[ebp], eax
	mov	ecx, DWORD PTR $T236667[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR $T236671[ebp]
	call	?getEstimateEndTurn@CvGame@@QBEHXZ	; CvGame::getEstimateEndTurn
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	esi, eax
	jg	SHORT $LN35@ChooseMaya

; 2938 : 			{
; 2939 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], ecx
$LN35@ChooseMaya:

; 2940 : 			}
; 2941 : 		}
; 2942 : 	}
; 2943 : 
; 2944 : 	// Does our grand strategy match one that is available?
; 2945 : 	AIGrandStrategyTypes eVictoryStrategy = m_pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	mov	DWORD PTR _eVictoryStrategy$[ebp], eax

; 2946 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$[ebp], -1
	jne	SHORT $LN32@ChooseMaya

; 2947 : 	{
; 2948 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_SCIENTIST");

	push	0
	push	OFFSET ??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 2949 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN32@ChooseMaya

; 2950 : 		{
; 2951 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))

	push	0
	push	OFFSET ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$[ebp], eax
	jne	SHORT $LN32@ChooseMaya

; 2952 : 			{
; 2953 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], ecx
$LN32@ChooseMaya:

; 2954 : 			}
; 2955 : 		}
; 2956 : 	}
; 2957 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$[ebp], -1
	jne	SHORT $LN29@ChooseMaya

; 2958 : 	{
; 2959 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ARTIST");

	push	0
	push	OFFSET ??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 2960 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN29@ChooseMaya

; 2961 : 		{
; 2962 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$[ebp], eax
	jne	SHORT $LN29@ChooseMaya

; 2963 : 			{
; 2964 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], eax
$LN29@ChooseMaya:

; 2965 : 			}
; 2966 : 		}
; 2967 : 	}
; 2968 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$[ebp], -1
	jne	SHORT $LN26@ChooseMaya

; 2969 : 	{
; 2970 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MERCHANT");

	push	0
	push	OFFSET ??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 2971 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN26@ChooseMaya

; 2972 : 		{
; 2973 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))

	push	0
	push	OFFSET ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$[ebp], eax
	jne	SHORT $LN26@ChooseMaya

; 2974 : 			{
; 2975 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], edx
$LN26@ChooseMaya:

; 2976 : 			}
; 2977 : 		}
; 2978 : 	}
; 2979 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$[ebp], -1
	jne	SHORT $LN23@ChooseMaya

; 2980 : 	{
; 2981 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_GENERAL");

	push	0
	push	OFFSET ??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 2982 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN23@ChooseMaya

; 2983 : 		{
; 2984 : 			if(eVictoryStrategy == (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eVictoryStrategy$[ebp], eax
	jne	SHORT $LN23@ChooseMaya

; 2985 : 			{
; 2986 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], ecx
$LN23@ChooseMaya:

; 2987 : 			}
; 2988 : 		}
; 2989 : 	}
; 2990 : 
; 2991 : 	// No obvious strategic choice, just go for first one available in a reasonable order
; 2992 : 	if(eDesiredGreatPerson == NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$[ebp], -1
	jne	$LN20@ChooseMaya

; 2993 : 	{
; 2994 : 		ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_PROPHET", true);

	push	1
	push	OFFSET ??_C@_0N@FMDKANIN@UNIT_PROPHET?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 2995 : 		if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN19@ChooseMaya

; 2996 : 		{
; 2997 : 			eDesiredGreatPerson = ePossibleGreatPerson;

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], eax

; 2998 : 		}
; 2999 : 		else

	jmp	$LN20@ChooseMaya
$LN19@ChooseMaya:

; 3000 : 		{
; 3001 : 			ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ENGINEER");

	push	0
	push	OFFSET ??_C@_0O@FDAJPIMP@UNIT_ENGINEER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3002 : 			if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN17@ChooseMaya

; 3003 : 			{
; 3004 : 				eDesiredGreatPerson = ePossibleGreatPerson;

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], edx

; 3005 : 			}
; 3006 : 			else

	jmp	$LN20@ChooseMaya
$LN17@ChooseMaya:

; 3007 : 			{
; 3008 : 				ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_WRITER");

	push	0
	push	OFFSET ??_C@_0M@CNLPFHOK@UNIT_WRITER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3009 : 				if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN15@ChooseMaya

; 3010 : 				{
; 3011 : 					eDesiredGreatPerson = ePossibleGreatPerson;

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], ecx

; 3012 : 				}
; 3013 : 				else

	jmp	$LN20@ChooseMaya
$LN15@ChooseMaya:

; 3014 : 				{
; 3015 : 					ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MERCHANT");

	push	0
	push	OFFSET ??_C@_0O@HLOLPMBO@UNIT_MERCHANT?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3016 : 					if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN13@ChooseMaya

; 3017 : 					{
; 3018 : 						eDesiredGreatPerson = ePossibleGreatPerson;

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], eax

; 3019 : 					}
; 3020 : 					else

	jmp	$LN20@ChooseMaya
$LN13@ChooseMaya:

; 3021 : 					{
; 3022 : 						ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_SCIENTIST");

	push	0
	push	OFFSET ??_C@_0P@MKBOELIK@UNIT_SCIENTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3023 : 						if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN11@ChooseMaya

; 3024 : 						{
; 3025 : 							eDesiredGreatPerson = ePossibleGreatPerson;

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], edx

; 3026 : 						}
; 3027 : 						else

	jmp	$LN20@ChooseMaya
$LN11@ChooseMaya:

; 3028 : 						{
; 3029 : 							ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_ARTIST");

	push	0
	push	OFFSET ??_C@_0M@FNEDFKCL@UNIT_ARTIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3030 : 							if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN9@ChooseMaya

; 3031 : 							{
; 3032 : 								eDesiredGreatPerson = ePossibleGreatPerson;

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], ecx

; 3033 : 							}
; 3034 : 							else

	jmp	$LN20@ChooseMaya
$LN9@ChooseMaya:

; 3035 : 							{
; 3036 : 								ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_MUSICIAN");

	push	0
	push	OFFSET ??_C@_0O@JKJEBPP@UNIT_MUSICIAN?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3037 : 								if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN7@ChooseMaya

; 3038 : 								{
; 3039 : 									eDesiredGreatPerson = ePossibleGreatPerson;

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], eax

; 3040 : 								}
; 3041 : 								else

	jmp	SHORT $LN20@ChooseMaya
$LN7@ChooseMaya:

; 3042 : 								{
; 3043 : 									ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_GENERAL");

	push	0
	push	OFFSET ??_C@_0BD@CPBEDAAN@UNIT_GREAT_GENERAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3044 : 									if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN5@ChooseMaya

; 3045 : 									{
; 3046 : 										eDesiredGreatPerson = ePossibleGreatPerson;

	mov	edx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], edx

; 3047 : 									}
; 3048 : 									else

	jmp	SHORT $LN20@ChooseMaya
$LN5@ChooseMaya:

; 3049 : 									{
; 3050 : 										ePossibleGreatPerson = (UnitTypes)GC.getInfoTypeForString("UNIT_GREAT_ADMIRAL");

	push	0
	push	OFFSET ??_C@_0BD@MGIKNJB@UNIT_GREAT_ADMIRAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePossibleGreatPerson$[ebp], eax

; 3051 : 										if(GetUnitBaktun(ePossibleGreatPerson) == 0)

	mov	eax, DWORD PTR _ePossibleGreatPerson$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ; CvPlayerTraits::GetUnitBaktun
	test	eax, eax
	jne	SHORT $LN20@ChooseMaya

; 3052 : 										{
; 3053 : 											eDesiredGreatPerson = ePossibleGreatPerson;

	mov	ecx, DWORD PTR _ePossibleGreatPerson$[ebp]
	mov	DWORD PTR _eDesiredGreatPerson$[ebp], ecx
$LN20@ChooseMaya:

; 3054 : 										}
; 3055 : 									}
; 3056 : 								}
; 3057 : 							}
; 3058 : 						}
; 3059 : 					}
; 3060 : 				}
; 3061 : 			}
; 3062 : 		}
; 3063 : 	}
; 3064 : 
; 3065 : 	// Actually get the great person
; 3066 : 	if(eDesiredGreatPerson != NO_UNIT)

	cmp	DWORD PTR _eDesiredGreatPerson$[ebp], -1
	je	SHORT $LN41@ChooseMaya

; 3067 : 	{
; 3068 : 		CvCity* pCity = m_pPlayer->GetGreatPersonSpawnCity(eDesiredGreatPerson);

	mov	edx, DWORD PTR _eDesiredGreatPerson$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetGreatPersonSpawnCity@CvPlayer@@QAEPAVCvCity@@W4UnitTypes@@@Z ; CvPlayer::GetGreatPersonSpawnCity
	mov	DWORD PTR _pCity$223117[ebp], eax

; 3069 : 		if(pCity)

	cmp	DWORD PTR _pCity$223117[ebp], 0
	je	SHORT $LN1@ChooseMaya

; 3070 : 		{
; 3071 : 			pCity->GetCityCitizens()->DoSpawnGreatPerson(eDesiredGreatPerson, true, false);

	push	0
	push	1
	mov	ecx, DWORD PTR _eDesiredGreatPerson$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$223117[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoSpawnGreatPerson@CvCityCitizens@@QAEXW4UnitTypes@@_N1@Z ; CvCityCitizens::DoSpawnGreatPerson

; 3072 : 			SetUnitBaktun(eDesiredGreatPerson);

	mov	edx, DWORD PTR _eDesiredGreatPerson$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z ; CvPlayerTraits::SetUnitBaktun
$LN1@ChooseMaya:

; 3073 : 		}
; 3074 : 		m_pPlayer->ChangeNumMayaBoosts(-1);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?ChangeNumMayaBoosts@CvPlayer@@QAEXH@Z	; CvPlayer::ChangeNumMayaBoosts
$LN41@ChooseMaya:

; 3075 : 	}
; 3076 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ChooseMayaBoost@CvPlayerTraits@@QAEXXZ ENDP		; CvPlayerTraits::ChooseMayaBoost
_TEXT	ENDS
EXTRN	?getGameTurnYear@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurnYear
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
;	COMDAT ?ComputeMayaDate@CvPlayerTraits@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T236677 = -20						; size = 4
_fDays$223127 = -16					; size = 4
_fCalendarStart$ = -12					; size = 4
_fYear$ = -8						; size = 4
_iYear$ = -4						; size = 4
?ComputeMayaDate@CvPlayerTraits@@QAEXXZ PROC		; CvPlayerTraits::ComputeMayaDate, COMDAT
; _this$ = ecx

; 3080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3081 : 	float fCalendarStart = CALENDAR_START;

	movss	xmm0, DWORD PTR _CALENDAR_START
	movss	DWORD PTR _fCalendarStart$[ebp], xmm0

; 3082 : 	int iYear = GC.getGame().getGameTurnYear();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236677[ebp], eax
	mov	ecx, DWORD PTR $T236677[ebp]
	call	?getGameTurnYear@CvGame@@QAEHXZ		; CvGame::getGameTurnYear
	mov	DWORD PTR _iYear$[ebp], eax

; 3083 : 	float fYear = (float)iYear;

	cvtsi2ss xmm0, DWORD PTR _iYear$[ebp]
	movss	DWORD PTR _fYear$[ebp], xmm0

; 3084 : 
; 3085 : 	if(fYear >= fCalendarStart)

	movss	xmm0, DWORD PTR _fYear$[ebp]
	comiss	xmm0, DWORD PTR _fCalendarStart$[ebp]
	jb	$LN1@ComputeMay

; 3086 : 	{
; 3087 : 		// Days since calendar start
; 3088 : 		float fDays = (fYear - fCalendarStart) * DAYS_IN_YEAR;

	movss	xmm0, DWORD PTR _fYear$[ebp]
	subss	xmm0, DWORD PTR _fCalendarStart$[ebp]
	mulss	xmm0, DWORD PTR _DAYS_IN_YEAR
	movss	DWORD PTR _fDays$223127[ebp], xmm0

; 3089 : 		m_iBaktun = (int)(fDays / DAYS_IN_BAKTUN);

	movss	xmm0, DWORD PTR _fDays$223127[ebp]
	divss	xmm0, DWORD PTR _DAYS_IN_BAKTUN
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+744], ecx

; 3090 : 		fDays = fDays - ((float)m_iBaktun * DAYS_IN_BAKTUN);

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+744]
	mulss	xmm0, DWORD PTR _DAYS_IN_BAKTUN
	movss	xmm1, DWORD PTR _fDays$223127[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _fDays$223127[ebp], xmm1

; 3091 : 		m_iKatun = (int)(fDays / DAYS_IN_KATUN);

	movss	xmm0, DWORD PTR _fDays$223127[ebp]
	divss	xmm0, DWORD PTR _DAYS_IN_KATUN
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+748], ecx

; 3092 : 		fDays = fDays - ((float)m_iKatun * DAYS_IN_KATUN);

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+748]
	mulss	xmm0, DWORD PTR _DAYS_IN_KATUN
	movss	xmm1, DWORD PTR _fDays$223127[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _fDays$223127[ebp], xmm1

; 3093 : 		m_iTun = (int)(fDays / DAYS_IN_TUN);

	movss	xmm0, DWORD PTR _fDays$223127[ebp]
	divss	xmm0, DWORD PTR _DAYS_IN_TUN
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+752], ecx

; 3094 : 		fDays = fDays - ((float)m_iTun * DAYS_IN_TUN);

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+752]
	mulss	xmm0, DWORD PTR _DAYS_IN_TUN
	movss	xmm1, DWORD PTR _fDays$223127[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _fDays$223127[ebp], xmm1

; 3095 : 		m_iWinal = (int)(fDays / DAYS_IN_WINAL);

	movss	xmm0, DWORD PTR _fDays$223127[ebp]
	divss	xmm0, DWORD PTR _DAYS_IN_WINAL
	cvttss2si ecx, xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+756], ecx

; 3096 : 		fDays = fDays - ((float)m_iWinal * DAYS_IN_WINAL);

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax+756]
	mulss	xmm0, DWORD PTR _DAYS_IN_WINAL
	movss	xmm1, DWORD PTR _fDays$223127[ebp]
	subss	xmm1, xmm0
	movss	DWORD PTR _fDays$223127[ebp], xmm1

; 3097 : 		m_iKin = (int)fDays;

	cvttss2si ecx, DWORD PTR _fDays$223127[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+760], ecx
$LN1@ComputeMay:

; 3098 : 	}
; 3099 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ComputeMayaDate@CvPlayerTraits@@QAEXXZ ENDP		; CvPlayerTraits::ComputeMayaDate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T236709 = -28						; size = 4
__Tmp$236704 = -24					; size = 4
$T236691 = -20						; size = 4
$T236683 = -16						; size = 4
$T236682 = -12						; size = 4
$T236681 = -8						; size = 4
_it$ = -4						; size = 4
_eUnit$ = 8						; size = 4
?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z PROC	; CvPlayerTraits::GetUnitBaktun, COMDAT
; _this$ = ecx

; 3103 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 3104 : 	std::vector<MayaBonusChoice>::const_iterator it;

	mov	DWORD PTR _it$[ebp], 0

; 3105 : 
; 3106 : 	// Loop through all units available to tactical AI this turn
; 3107 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3108 : 	for (it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); ++it)
; 3109 : #else
; 3110 : 	for(it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); it++)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+768]
	mov	DWORD PTR $T236691[ebp], ecx
	mov	edx, DWORD PTR $T236691[ebp]
	mov	DWORD PTR $T236681[ebp], edx
	mov	eax, DWORD PTR $T236681[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN4@GetUnitBak
$LN3@GetUnitBak:
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR __Tmp$236704[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	add	edx, 8
	mov	DWORD PTR _it$[ebp], edx
	mov	eax, DWORD PTR __Tmp$236704[ebp]
	mov	DWORD PTR $T236682[ebp], eax
$LN4@GetUnitBak:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+772]
	mov	DWORD PTR $T236709[ebp], edx
	mov	eax, DWORD PTR $T236709[ebp]
	mov	DWORD PTR $T236683[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T236683[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetUnitBak

; 3111 : #endif
; 3112 : 	{
; 3113 : 		if(it->m_eUnitType == eUnit)

	mov	edx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eUnit$[ebp]
	jne	SHORT $LN1@GetUnitBak

; 3114 : 		{
; 3115 : 			return it->m_iBaktunJustFinished;

	mov	ecx, DWORD PTR _it$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	jmp	SHORT $LN5@GetUnitBak
$LN1@GetUnitBak:

; 3116 : 		}
; 3117 : 	}

	jmp	SHORT $LN3@GetUnitBak
$LN2@GetUnitBak:

; 3118 : 
; 3119 : 	return 0;

	xor	eax, eax
$LN5@GetUnitBak:

; 3120 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitBaktun@CvPlayerTraits@@QBEHW4UnitTypes@@@Z ENDP	; CvPlayerTraits::GetUnitBaktun
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back
; Function compile flags: /Odtp
;	COMDAT ?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
_choice$ = -8						; size = 8
_eUnit$ = 8						; size = 4
?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z PROC	; CvPlayerTraits::SetUnitBaktun, COMDAT
; _this$ = ecx

; 3124 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 3125 : 	MayaBonusChoice choice;

	mov	DWORD PTR _choice$[ebp], -1
	mov	DWORD PTR _choice$[ebp+4], 0

; 3126 : 	choice.m_eUnitType = eUnit;

	mov	eax, DWORD PTR _eUnit$[ebp]
	mov	DWORD PTR _choice$[ebp], eax

; 3127 : 	choice.m_iBaktunJustFinished = m_iBaktun;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+744]
	mov	DWORD PTR _choice$[ebp+4], edx

; 3128 : 	m_aMayaBonusChoices.push_back(choice);

	lea	eax, DWORD PTR _choice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 764				; 000002fcH
	call	?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back

; 3129 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetUnitBaktun@CvPlayerTraits@@QAEXW4UnitTypes@@@Z ENDP	; CvPlayerTraits::SetUnitBaktun
_TEXT	ENDS
PUBLIC	??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@	; `string'
PUBLIC	?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ ; CvPlayerTraits::IsFreeMayaGreatPersonChoice
EXTRN	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetSpecialUnitType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
;	COMDAT ??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@ DB 'SPECIALUNIT_PEOPLE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
CONST	ENDS
;	COMDAT ?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T236864 = -32						; size = 4
_pUnitEntry$223280 = -28				; size = 4
_eUnit$223277 = -24					; size = 4
_pkUnitClassInfo$223275 = -20				; size = 4
_eUnitClass$223273 = -16				; size = 4
_iI$223269 = -12					; size = 4
_eSpecialUnitGreatPerson$ = -8				; size = 4
_iNumGreatPeopleTypes$ = -4				; size = 4
?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ PROC ; CvPlayerTraits::IsFreeMayaGreatPersonChoice, COMDAT
; _this$ = ecx

; 3133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3134 : 	// True if have already selected each GP type once
; 3135 : 	int iNumGreatPeopleTypes = 0;

	mov	DWORD PTR _iNumGreatPeopleTypes$[ebp], 0

; 3136 : 	SpecialUnitTypes eSpecialUnitGreatPerson = (SpecialUnitTypes) GC.getInfoTypeForString("SPECIALUNIT_PEOPLE");

	push	0
	push	OFFSET ??_C@_0BD@NNACGNOP@SPECIALUNIT_PEOPLE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eSpecialUnitGreatPerson$[ebp], eax

; 3137 : 
; 3138 : 	// Loop through adding the available units
; 3139 : #ifdef AUI_WARNING_FIXES
; 3140 : 	for (uint iI = 0; iI < GC.getNumUnitClassInfos(); iI++)
; 3141 : #else
; 3142 : 	for(int iI = 0; iI < GC.getNumUnitClassInfos(); iI++)

	mov	DWORD PTR _iI$223269[ebp], 0
	jmp	SHORT $LN7@IsFreeMaya
$LN6@IsFreeMaya:
	mov	eax, DWORD PTR _iI$223269[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$223269[ebp], eax
$LN7@IsFreeMaya:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iI$223269[ebp], eax
	jge	SHORT $LN5@IsFreeMaya

; 3143 : #endif
; 3144 : 	{
; 3145 : 		const UnitClassTypes eUnitClass = static_cast<UnitClassTypes>(iI);

	mov	ecx, DWORD PTR _iI$223269[ebp]
	mov	DWORD PTR _eUnitClass$223273[ebp], ecx

; 3146 : 		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	edx, DWORD PTR _eUnitClass$223273[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$223275[ebp], eax

; 3147 : 		if(pkUnitClassInfo)

	cmp	DWORD PTR _pkUnitClassInfo$223275[ebp], 0
	je	SHORT $LN4@IsFreeMaya

; 3148 : 		{
; 3149 : 			const UnitTypes eUnit = (UnitTypes)m_pPlayer->getCivilizationInfo().getCivilizationUnits(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$223273[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	DWORD PTR _eUnit$223277[ebp], eax

; 3150 : 			if (eUnit != NO_UNIT)

	cmp	DWORD PTR _eUnit$223277[ebp], -1
	je	SHORT $LN4@IsFreeMaya

; 3151 : 			{
; 3152 : 				CvUnitEntry* pUnitEntry = GC.getUnitInfo(eUnit);

	mov	edx, DWORD PTR _eUnit$223277[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pUnitEntry$223280[ebp], eax

; 3153 : 				if (pUnitEntry)

	cmp	DWORD PTR _pUnitEntry$223280[ebp], 0
	je	SHORT $LN4@IsFreeMaya

; 3154 : 				{
; 3155 : 					if (pUnitEntry->GetSpecialUnitType() == eSpecialUnitGreatPerson)

	mov	ecx, DWORD PTR _pUnitEntry$223280[ebp]
	call	?GetSpecialUnitType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetSpecialUnitType
	cmp	eax, DWORD PTR _eSpecialUnitGreatPerson$[ebp]
	jne	SHORT $LN4@IsFreeMaya

; 3156 : 					{
; 3157 : 						iNumGreatPeopleTypes++;

	mov	eax, DWORD PTR _iNumGreatPeopleTypes$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumGreatPeopleTypes$[ebp], eax
$LN4@IsFreeMaya:

; 3158 : 					}
; 3159 : 				}
; 3160 : 			}	
; 3161 : 		}
; 3162 : 	}

	jmp	$LN6@IsFreeMaya
$LN5@IsFreeMaya:

; 3163 : 
; 3164 : 	return ((int)m_aMayaBonusChoices.size() >= iNumGreatPeopleTypes);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 764				; 000002fcH
	mov	DWORD PTR $T236864[ebp], ecx
	mov	edx, DWORD PTR $T236864[ebp]
	mov	eax, DWORD PTR $T236864[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	xor	eax, eax
	cmp	ecx, DWORD PTR _iNumGreatPeopleTypes$[ebp]
	setge	al

; 3165 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFreeMayaGreatPersonChoice@CvPlayerTraits@@QBE_NXZ ENDP ; CvPlayerTraits::IsFreeMayaGreatPersonChoice
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
PUBLIC	??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator>><Firaxis::Array<int,6> >
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
PUBLIC	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
PUBLIC	?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z	; CvPlayerTraits::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv789 = -1080						; size = 4
tv782 = -1076						; size = 4
tv740 = -1072						; size = 4
tv733 = -1068						; size = 4
_this$ = -1064						; size = 4
$T238664 = -1060					; size = 4
$T238546 = -1004					; size = 4
$T238530 = -1000					; size = 4
$T238650 = -996						; size = 4
$T238649 = -992						; size = 4
$T238648 = -988						; size = 4
$T238647 = -984						; size = 4
$T238646 = -980						; size = 4
$T238357 = -888						; size = 4
$T238239 = -832						; size = 4
$T238223 = -828						; size = 4
$T238343 = -824						; size = 4
$T238342 = -820						; size = 4
$T238341 = -816						; size = 4
$T238340 = -812						; size = 4
$T238339 = -808						; size = 4
$T238024 = -704						; size = 4
$T238017 = -700						; size = 4
$T238000 = -692						; size = 4
_i$237994 = -688					; size = 4
$T237978 = -681						; size = 1
$T237977 = -680						; size = 4
$T237975 = -608						; size = 8
$T237974 = -600						; size = 8
$T237973 = -592						; size = 8
$T237733 = -505						; size = 1
$T237732 = -504						; size = 4
$T237730 = -432						; size = 8
$T237729 = -424						; size = 8
$T237728 = -416						; size = 8
$T237411 = -308						; size = 4
$T237385 = -304						; size = 4
$T237369 = -300						; size = 4
$T237397 = -296						; size = 4
$T237396 = -292						; size = 4
$T237395 = -288						; size = 4
$T237394 = -284						; size = 4
$T237393 = -280						; size = 4
$T237004 = -256						; size = 4
__Tmp$237012 = -252					; size = 8
$T237010 = -244						; size = 8
$T237009 = -236						; size = 8
$T236991 = -225						; size = 1
$T236943 = -224						; size = 4
__Tmp$236951 = -220					; size = 8
$T236949 = -212						; size = 8
$T236948 = -204						; size = 8
$T236930 = -196						; size = 4
$T236904 = -192						; size = 4
$T236888 = -188						; size = 4
$T236916 = -184						; size = 4
$T236915 = -180						; size = 4
$T236914 = -176						; size = 4
$T236913 = -172						; size = 4
$T236912 = -168						; size = 4
$T236869 = -164						; size = 4
$T236868 = -160						; size = 8
$T236867 = -152						; size = 8
_iAreaID$223448 = -144					; size = 4
_iI$223444 = -140					; size = 4
_iI$223439 = -136					; size = 4
_iNumUnitCombatClassInfos$223438 = -132			; size = 4
_iI$223433 = -128					; size = 4
_iI$223428 = -124					; size = 4
_trait$223424 = -120					; size = 8
_iI$223420 = -112					; size = 4
_bValue$223419 = -105					; size = 1
_i$223415 = -104					; size = 4
_bValue$223414 = -97					; size = 1
_i$223410 = -96						; size = 4
_iYield$223391 = -92					; size = 4
_kYieldChangeIncomingTradeRouteWrapper$223389 = -88	; size = 8
_kYieldChangePerTradePartnerWrapper$223387 = -80	; size = 8
_iI$223327 = -72					; size = 4
_iI$223290 = -68					; size = 4
_choice$ = -64						; size = 8
_kYieldChangeLuxuryResourcesWrapper$ = -56		; size = 8
_kExtraYieldThreshold$ = -48				; size = 8
_kYieldChangeResourcesWrapper$ = -40			; size = 8
_uiVersion$ = -32					; size = 4
_kYieldRateModifierWrapper$ = -28			; size = 8
_kFreeCityYield$ = -20					; size = 8
_iNumEntries$ = -12					; size = 4
_kYieldChangeNaturalWonderWrapper$ = -8			; size = 8
_kStream$ = 8						; size = 4
?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTraits::Read, COMDAT
; _this$ = ecx

; 3171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1080				; 00000438H
	mov	DWORD PTR _this$[ebp], ecx

; 3172 : 	int iNumEntries;
; 3173 : 
; 3174 : 	// Version number to maintain backwards compatibility
; 3175 : 	uint uiVersion;
; 3176 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3177 : 
; 3178 : 	// precompute the traits our leader has
; 3179 : 	m_vPotentiallyActiveLeaderTraits.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T236930[ebp], ecx
	mov	edx, DWORD PTR $T236930[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T236888[ebp], eax
	mov	ecx, DWORD PTR $T236888[ebp]
	mov	DWORD PTR $T236913[ebp], ecx
	mov	edx, DWORD PTR $T236913[ebp]
	mov	DWORD PTR $T236912[ebp], edx
	mov	eax, DWORD PTR $T236930[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236904[ebp], ecx
	mov	edx, DWORD PTR $T236904[ebp]
	mov	DWORD PTR $T236915[ebp], edx
	mov	eax, DWORD PTR $T236915[ebp]
	mov	DWORD PTR $T236914[ebp], eax
	mov	ecx, DWORD PTR $T236912[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236914[ebp]
	push	edx
	lea	eax, DWORD PTR $T236916[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236930[ebp]
	call	?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase

; 3180 : 	for(int iI = 0; iI < GC.getNumTraitInfos(); iI++)

	mov	DWORD PTR _iI$223290[ebp], 0
	jmp	SHORT $LN73@Read
$LN72@Read:
	mov	ecx, DWORD PTR _iI$223290[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223290[ebp], ecx
$LN73@Read:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	cmp	DWORD PTR _iI$223290[ebp], eax
	jge	$LN71@Read

; 3181 : 	{
; 3182 : 		m_vLeaderHasTrait[iI] = false;

	lea	edx, DWORD PTR $T236948[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
	mov	DWORD PTR $T236943[ebp], eax
	mov	eax, DWORD PTR $T236943[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$236951[ebp], ecx
	mov	DWORD PTR __Tmp$236951[ebp+4], edx
	mov	eax, DWORD PTR _iI$223290[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$236951[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$236951[ebp]
	mov	edx, DWORD PTR __Tmp$236951[ebp+4]
	mov	DWORD PTR $T236949[ebp], ecx
	mov	DWORD PTR $T236949[ebp+4], edx
	lea	eax, DWORD PTR $T236949[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236867[ebp]
	call	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
	xor	ecx, ecx
	je	SHORT $LN108@Read
	mov	edx, DWORD PTR $T236867[ebp]
	mov	DWORD PTR tv733[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR $T236867[ebp+4]
	shl	eax, cl
	mov	ecx, DWORD PTR tv733[ebp]
	or	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv733[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN102@Read
$LN108@Read:
	mov	eax, DWORD PTR $T236867[ebp]
	mov	DWORD PTR tv740[ebp], eax
	mov	edx, 1
	mov	ecx, DWORD PTR $T236867[ebp+4]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR tv740[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv740[ebp]
	mov	DWORD PTR [ecx], edx
$LN102@Read:

; 3183 : 		if (m_pPlayer && m_pPlayer->isMajorCiv() && m_pPlayer->isAlive() && m_pPlayer->getLeaderInfo().hasTrait( (TraitTypes)iI ))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN70@Read
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?isMajorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMajorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	$LN70@Read
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T236991[ebp], cl
	movzx	edx, BYTE PTR $T236991[ebp]
	test	edx, edx
	je	$LN70@Read
	mov	eax, DWORD PTR _iI$223290[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	ecx, eax
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	movzx	edx, al
	test	edx, edx
	je	$LN70@Read

; 3184 : 		{
; 3185 : 			m_vLeaderHasTrait[iI] = true;

	lea	eax, DWORD PTR $T237009[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
	mov	DWORD PTR $T237004[ebp], eax
	mov	ecx, DWORD PTR $T237004[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237012[ebp], edx
	mov	DWORD PTR __Tmp$237012[ebp+4], eax
	mov	ecx, DWORD PTR _iI$223290[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$237012[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$237012[ebp]
	mov	eax, DWORD PTR __Tmp$237012[ebp+4]
	mov	DWORD PTR $T237010[ebp], edx
	mov	DWORD PTR $T237010[ebp+4], eax
	lea	ecx, DWORD PTR $T237010[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T236868[ebp]
	call	??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN132@Read
	mov	eax, DWORD PTR $T236868[ebp]
	mov	DWORD PTR tv782[ebp], eax
	mov	edx, 1
	mov	ecx, DWORD PTR $T236868[ebp+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv782[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv782[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN126@Read
$LN132@Read:
	mov	edx, DWORD PTR $T236868[ebp]
	mov	DWORD PTR tv789[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR $T236868[ebp+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv789[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv789[ebp]
	mov	DWORD PTR [edx], eax
$LN126@Read:

; 3186 : 			m_vPotentiallyActiveLeaderTraits.push_back( (TraitTypes)iI );

	mov	eax, DWORD PTR _iI$223290[ebp]
	mov	DWORD PTR $T236869[ebp], eax
	lea	ecx, DWORD PTR $T236869[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
$LN70@Read:

; 3187 : 		}
; 3188 : 	}

	jmp	$LN72@Read
$LN71@Read:

; 3189 : 
; 3190 : 	kStream >> m_iGreatPeopleRateModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3191 : 	kStream >> m_iGreatScientistRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3192 : 	kStream >> m_iGreatGeneralRateModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3193 : 	kStream >> m_iGreatGeneralExtraBonus;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3194 : 
; 3195 : 	kStream >> m_iGreatPersonGiftInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3196 : 
; 3197 : 	kStream >> m_iLevelExperienceModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3198 : 	kStream >> m_iMaxGlobalBuildingProductionModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3199 : 	kStream >> m_iMaxTeamBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3200 : 	kStream >> m_iMaxPlayerBuildingProductionModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3201 : 	kStream >> m_iCityUnhappinessModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3202 : 	kStream >> m_iPopulationUnhappinessModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3203 : 	kStream >> m_iCityStateBonusModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3204 : 	kStream >> m_iCityStateFriendshipModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3205 : 	kStream >> m_iCityStateCombatModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3206 : 	kStream >> m_iLandBarbarianConversionPercent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3207 : 	kStream >> m_iLandBarbarianConversionExtraUnits;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 104				; 00000068H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3208 : 	kStream >> m_iSeaBarbarianConversionPercent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3209 : 	kStream >> m_iCapitalBuildingModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3210 : 	kStream >> m_iPlotBuyCostModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3211 : 	kStream >> m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3212 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 3213 : 	kStream >> m_iSciencePerGreatPersonBorn;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3214 : #endif
; 3215 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 3216 : 	kStream >> m_iNumTurnsBeforeMinorAlliesRefuseBribes;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 128				; 00000080H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3217 : #endif
; 3218 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 3219 : 	kStream >> m_iGoldenAgeTileBonusFaith;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 132				; 00000084H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3220 : #endif
; 3221 : 	kStream >> m_iCultureFromKills;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3222 : 	if (uiVersion >= 19)

	cmp	DWORD PTR _uiVersion$[ebp], 19		; 00000013H
	jb	SHORT $LN69@Read

; 3223 : 	{
; 3224 : 		kStream >> m_iFaithFromKills;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 140				; 0000008cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3225 : 	}
; 3226 : 	else

	jmp	SHORT $LN68@Read
$LN69@Read:

; 3227 : 	{
; 3228 : 		m_iFaithFromKills = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], 0
$LN68@Read:

; 3229 : 	}
; 3230 : 	kStream >> m_iCityCultureBonus;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3231 : 
; 3232 : 	if (uiVersion >= 17)

	cmp	DWORD PTR _uiVersion$[ebp], 17		; 00000011H
	jb	SHORT $LN67@Read

; 3233 : 	{
; 3234 : 		kStream >> m_iCapitalThemingBonusModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3235 : 	}
; 3236 : 	else

	jmp	SHORT $LN66@Read
$LN67@Read:

; 3237 : 	{
; 3238 : 		m_iCapitalThemingBonusModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0
$LN66@Read:

; 3239 : 	}
; 3240 : 
; 3241 : 	kStream >> m_iPolicyCostModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3242 : 	kStream >> m_iCityConnectionTradeRouteChange;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 156				; 0000009cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3243 : 	kStream >> m_iWonderProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 160				; 000000a0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3244 : 	kStream >> m_iPlunderModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3245 : 
; 3246 : 	kStream >> m_iImprovementMaintenanceModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 168				; 000000a8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3247 : 
; 3248 : 	kStream >> m_iGoldenAgeDurationModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 172				; 000000acH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3249 : 	kStream >> m_iGoldenAgeMoveChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3250 : 	kStream >> m_iGoldenAgeCombatModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 180				; 000000b4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3251 : 
; 3252 : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	SHORT $LN65@Read

; 3253 : 	{
; 3254 : 		kStream >> m_iGoldenAgeTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 184				; 000000b8H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3255 : 		kStream >> m_iGoldenAgeGreatArtistRateModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 188				; 000000bcH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3256 : 		kStream >> m_iGoldenAgeGreatMusicianRateModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3257 : 		kStream >> m_iGoldenAgeGreatWriterRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 196				; 000000c4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3258 : 	}
; 3259 : 	else

	jmp	SHORT $LN64@Read
$LN65@Read:

; 3260 : 	{
; 3261 : 		m_iGoldenAgeTourismModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+184], 0

; 3262 : 		m_iGoldenAgeGreatArtistRateModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+188], 0

; 3263 : 		m_iGoldenAgeGreatMusicianRateModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+192], 0

; 3264 : 		m_iGoldenAgeGreatWriterRateModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+196], 0
$LN64@Read:

; 3265 : 	}
; 3266 : 
; 3267 : 	kStream >> m_iExtraEmbarkMoves;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3268 : 
; 3269 : 	kStream >> m_iNaturalWonderFirstFinderGold;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 204				; 000000ccH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3270 : 
; 3271 : 	kStream >> m_iNaturalWonderSubsequentFinderGold;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3272 : 
; 3273 : 
; 3274 : 	//EAP: Natural wonder faith for the finder:
; 3275 : 
; 3276 : 	kStream >> m_iNaturalWonderFirstFinderFaith;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 216				; 000000d8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3277 : 
; 3278 : 	kStream >> m_iNaturalWonderSubsequentFinderFaith;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 220				; 000000dcH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3279 : 
; 3280 : 	//
; 3281 : 
; 3282 : 	kStream >> m_iNaturalWonderYieldModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3283 : 	kStream >> m_iNaturalWonderHappinessModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 224				; 000000e0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3284 : 
; 3285 : 	kStream >> m_iNearbyImprovementCombatBonus;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 228				; 000000e4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3286 : 	kStream >> m_iNearbyImprovementBonusRange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3287 : 
; 3288 : 	kStream >> m_iCultureBuildingYieldChange;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 236				; 000000ecH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3289 : 
; 3290 : 	kStream >> m_iCombatBonusVsHigherTech;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 240				; 000000f0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3291 : 
; 3292 : 	kStream >> m_iCombatBonusVsLargerCiv;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 244				; 000000f4H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3293 : 
; 3294 : 	kStream >> m_iLandUnitMaintenanceModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3295 : 
; 3296 : 	kStream >> m_iNavalUnitMaintenanceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 252				; 000000fcH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3297 : 
; 3298 : 	kStream >> m_iRazeSpeedModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3299 : 
; 3300 : 	kStream >> m_iDOFGreatPersonModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 260				; 00000104H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3301 : 
; 3302 : 	kStream >> m_iLuxuryHappinessRetention;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 264				; 00000108H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3303 : 
; 3304 : 	kStream >> m_iExtraHappinessPerLuxury; // NQMP GJS - New Netherlands UA

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 268				; 0000010cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3305 : 
; 3306 : 	kStream >> m_iExtraSpies;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 272				; 00000110H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3307 : 
; 3308 : 	kStream >> m_iHappinessPerReligion; // NQMP GJS - New Ottoman UA

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 276				; 00000114H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3309 : 
; 3310 : 	kStream >> m_iUnresearchedTechBonusFromKills;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 280				; 00000118H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3311 : 
; 3312 : 	if (uiVersion >= 4)

	cmp	DWORD PTR _uiVersion$[ebp], 4
	jb	SHORT $LN63@Read

; 3313 : 	{
; 3314 : 		kStream >> m_iExtraFoundedCityTerritoryClaimRange;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 284				; 0000011cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3315 : 	}
; 3316 : 	else

	jmp	SHORT $LN62@Read
$LN63@Read:

; 3317 : 	{
; 3318 : 		m_iExtraFoundedCityTerritoryClaimRange = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+284], 0
$LN62@Read:

; 3319 : 	}
; 3320 : 
; 3321 : 	if (uiVersion >= 5)

	cmp	DWORD PTR _uiVersion$[ebp], 5
	jb	SHORT $LN61@Read

; 3322 : 	{
; 3323 : 		kStream >> m_iFreeSocialPoliciesPerEra;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3324 : 	}
; 3325 : 	else

	jmp	SHORT $LN60@Read
$LN61@Read:

; 3326 : 	{
; 3327 : 		m_iFreeSocialPoliciesPerEra = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0
$LN60@Read:

; 3328 : 	}
; 3329 : 
; 3330 : 	if (uiVersion >= 6)

	cmp	DWORD PTR _uiVersion$[ebp], 6
	jb	SHORT $LN59@Read

; 3331 : 	{
; 3332 : 		kStream >> m_iNumTradeRoutesModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 292				; 00000124H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3333 : 	}
; 3334 : 	else

	jmp	SHORT $LN58@Read
$LN59@Read:

; 3335 : 	{
; 3336 : 		m_iNumTradeRoutesModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], 0
$LN58@Read:

; 3337 : 	}
; 3338 : 
; 3339 : 	if (uiVersion >= 8)

	cmp	DWORD PTR _uiVersion$[ebp], 8
	jb	SHORT $LN57@Read

; 3340 : 	{
; 3341 : 		kStream >> m_iTradeRouteResourceModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3342 : 	}
; 3343 : 	else

	jmp	SHORT $LN56@Read
$LN57@Read:

; 3344 : 	{
; 3345 : 		m_iTradeRouteResourceModifier = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+296], 0
$LN56@Read:

; 3346 : 	}
; 3347 : 
; 3348 : 	if (uiVersion >= 9)

	cmp	DWORD PTR _uiVersion$[ebp], 9
	jb	SHORT $LN55@Read

; 3349 : 	{
; 3350 : 		kStream >> m_iUniqueLuxuryCities;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 300				; 0000012cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3351 : 		kStream >> m_iUniqueLuxuryQuantity;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 304				; 00000130H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3352 : 	}
; 3353 : 	else

	jmp	SHORT $LN54@Read
$LN55@Read:

; 3354 : 	{
; 3355 : 		m_iUniqueLuxuryCities = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+300], 0

; 3356 : 		m_iUniqueLuxuryQuantity = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], 0
$LN54@Read:

; 3357 : 	}
; 3358 : 
; 3359 : 	if (uiVersion >= 11)

	cmp	DWORD PTR _uiVersion$[ebp], 11		; 0000000bH
	jb	SHORT $LN53@Read

; 3360 : 	{
; 3361 : 		kStream >> m_iUniqueLuxuryCitiesPlaced;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 308				; 00000134H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3362 : 	}
; 3363 : 	else

	jmp	SHORT $LN52@Read
$LN53@Read:

; 3364 : 	{
; 3365 : 		m_iUniqueLuxuryCitiesPlaced = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+308], 0
$LN52@Read:

; 3366 : 	}
; 3367 : 
; 3368 : 	if (uiVersion >= 13)

	cmp	DWORD PTR _uiVersion$[ebp], 13		; 0000000dH
	jb	SHORT $LN51@Read

; 3369 : 	{
; 3370 : 		kStream >> m_iWorkerSpeedModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3371 : 	}
; 3372 : 	else

	jmp	SHORT $LN50@Read
$LN51@Read:

; 3373 : 	{
; 3374 : 		m_iWorkerSpeedModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], 0
$LN50@Read:

; 3375 : 	}
; 3376 : 
; 3377 : 	if (uiVersion >= 14)

	cmp	DWORD PTR _uiVersion$[ebp], 14		; 0000000eH
	jb	SHORT $LN49@Read

; 3378 : 	{
; 3379 : 		kStream >> m_iAfraidMinorPerTurnInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3380 : 	}
; 3381 : 	else

	jmp	SHORT $LN48@Read
$LN49@Read:

; 3382 : 	{
; 3383 : 		m_iAfraidMinorPerTurnInfluence = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], 0
$LN48@Read:

; 3384 : 	}
; 3385 : 	
; 3386 : 	if (uiVersion >= 15)

	cmp	DWORD PTR _uiVersion$[ebp], 15		; 0000000fH
	jb	SHORT $LN47@Read

; 3387 : 	{
; 3388 : 		kStream >> m_iLandTradeRouteRangeBonus;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 320				; 00000140H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3389 : 		kStream >> m_iTradeReligionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 324				; 00000144H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3390 : 	}
; 3391 : 	else

	jmp	SHORT $LN46@Read
$LN47@Read:

; 3392 : 	{
; 3393 : 		m_iLandTradeRouteRangeBonus = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], 0

; 3394 : 		m_iTradeReligionModifier = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], 0
$LN46@Read:

; 3395 : 	}
; 3396 : 
; 3397 : 	if (uiVersion >= 16)

	cmp	DWORD PTR _uiVersion$[ebp], 16		; 00000010H
	jb	SHORT $LN45@Read

; 3398 : 	{
; 3399 : 		kStream >> m_iTradeBuildingModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 328				; 00000148H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3400 : 	}
; 3401 : 	else

	jmp	SHORT $LN44@Read
$LN45@Read:

; 3402 : 	{
; 3403 : 		m_iTradeBuildingModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], 0
$LN44@Read:

; 3404 : 	}
; 3405 : 
; 3406 : 	kStream >> m_bFightWellDamaged;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 332				; 0000014cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3407 : 	kStream >> m_bMoveFriendlyWoodsAsRoad;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 333				; 0000014dH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3408 : 	kStream >> m_bFasterAlongRiver;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 334				; 0000014eH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3409 : 
; 3410 : 	kStream >> m_bFasterInHills;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 335				; 0000014fH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3411 : 
; 3412 : 	kStream >> m_bEmbarkedAllWater;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 336				; 00000150H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3413 : 
; 3414 : 	kStream >> m_bEmbarkedToLandFlatCost;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 337				; 00000151H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3415 : 
; 3416 : 	kStream >> m_bNoHillsImprovementMaintenance;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 338				; 00000152H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3417 : 
; 3418 : 	kStream >> m_bTechBoostFromCapitalScienceBuildings;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 339				; 00000153H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3419 : 	kStream >> m_bStaysAliveZeroCities;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3420 : 
; 3421 : 	kStream >> m_bFaithFromUnimprovedForest;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 341				; 00000155H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3422 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 3423 : 	kStream >> m_bSeaTradeRoutesArePlunderImmune;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 342				; 00000156H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3424 : #endif
; 3425 : 
; 3426 : 	// NQMP GJS - New France UA begin
; 3427 : 	kStream >> m_bEarnsGreatPersonOnSlotOrGuild;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 343				; 00000157H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3428 : 	kStream >> m_bHasBuiltWritersGuild;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 344				; 00000158H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3429 : 	kStream >> m_bHasBuiltArtistsGuild;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 345				; 00000159H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3430 : 	kStream >> m_bHasBuiltMusiciansGuild;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 346				; 0000015aH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3431 : 	// NQMP GJS - New France UA end
; 3432 : 
; 3433 : 
; 3434 : 	kStream >> m_bBonusReligiousBelief;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3435 : 
; 3436 : 	kStream >> m_bAbleToAnnexCityStates;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3437 : 
; 3438 : 	kStream >> m_bCrossesMountainsAfterGreatGeneral;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 349				; 0000015dH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3439 : 
; 3440 : 	kStream >> m_bMayaCalendarBonuses;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 350				; 0000015eH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3441 : 	kStream >> m_iBaktunPreviousTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 740				; 000002e4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3442 : 
; 3443 : 	kStream >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3444 : 	m_aMayaBonusChoices.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 764				; 000002fcH
	mov	DWORD PTR $T237411[ebp], edx
	mov	eax, DWORD PTR $T237411[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237369[ebp], ecx
	mov	edx, DWORD PTR $T237369[ebp]
	mov	DWORD PTR $T237394[ebp], edx
	mov	eax, DWORD PTR $T237394[ebp]
	mov	DWORD PTR $T237393[ebp], eax
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237385[ebp], edx
	mov	eax, DWORD PTR $T237385[ebp]
	mov	DWORD PTR $T237396[ebp], eax
	mov	ecx, DWORD PTR $T237396[ebp]
	mov	DWORD PTR $T237395[ebp], ecx
	mov	edx, DWORD PTR $T237393[ebp]
	push	edx
	mov	eax, DWORD PTR $T237395[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237397[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237411[ebp]
	call	?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase

; 3445 : 	MayaBonusChoice choice;

	mov	DWORD PTR _choice$[ebp], -1
	mov	DWORD PTR _choice$[ebp+4], 0

; 3446 : 	for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$223327[ebp], 0
	jmp	SHORT $LN43@Read
$LN42@Read:
	mov	edx, DWORD PTR _iI$223327[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223327[ebp], edx
$LN43@Read:
	mov	eax, DWORD PTR _iI$223327[ebp]
	cmp	eax, DWORD PTR _iNumEntries$[ebp]
	jge	SHORT $LN41@Read

; 3447 : 	{
; 3448 : 		kStream >> choice.m_eUnitType;

	lea	ecx, DWORD PTR _choice$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8

; 3449 : 		kStream >> choice.m_iBaktunJustFinished;

	lea	eax, DWORD PTR _choice$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3450 : 		m_aMayaBonusChoices.push_back(choice);

	lea	ecx, DWORD PTR _choice$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 764				; 000002fcH
	call	?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back

; 3451 : 	}

	jmp	SHORT $LN42@Read
$LN41@Read:

; 3452 : 
; 3453 : 	kStream >> m_bNoAnnexing;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 351				; 0000015fH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3454 : 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[ebp], 3
	jb	SHORT $LN40@Read

; 3455 : 	{
; 3456 : 		kStream >> m_bTechFromCityConquer;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3457 : 	}
; 3458 : 	else

	jmp	SHORT $LN39@Read
$LN40@Read:

; 3459 : 	{
; 3460 : 		m_bTechFromCityConquer = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+352], 0
$LN39@Read:

; 3461 : 	}
; 3462 : 
; 3463 : 	if (uiVersion >= 9)

	cmp	DWORD PTR _uiVersion$[ebp], 9
	jb	SHORT $LN38@Read

; 3464 : 	{
; 3465 : 		kStream >> m_bUniqueLuxuryRequiresNewArea;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 353				; 00000161H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3466 : 	}
; 3467 : 	else

	jmp	SHORT $LN37@Read
$LN38@Read:

; 3468 : 	{
; 3469 : 		m_bUniqueLuxuryRequiresNewArea = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+353], 0
$LN37@Read:

; 3470 : 	}
; 3471 : 
; 3472 : 	if (uiVersion >= 12)

	cmp	DWORD PTR _uiVersion$[ebp], 12		; 0000000cH
	jb	SHORT $LN36@Read

; 3473 : 	{
; 3474 : 		kStream >> m_bRiverTradeRoad;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 354				; 00000162H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3475 : 	}
; 3476 : 	else

	jmp	SHORT $LN35@Read
$LN36@Read:

; 3477 : 	{
; 3478 : 		m_bRiverTradeRoad = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+354], 0
$LN35@Read:

; 3479 : 	}
; 3480 : 
; 3481 : 	if (uiVersion >= 18)

	cmp	DWORD PTR _uiVersion$[ebp], 18		; 00000012H
	jb	SHORT $LN34@Read

; 3482 : 	{
; 3483 : 		kStream >> m_bAngerFreeIntrusionOfCityStates;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 355				; 00000163H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3484 : 	}
; 3485 : 	else

	jmp	SHORT $LN33@Read
$LN34@Read:

; 3486 : 	{
; 3487 : 		m_bAngerFreeIntrusionOfCityStates = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+355], 0
$LN33@Read:

; 3488 : 	}
; 3489 : 
; 3490 : 	kStream >> m_eCampGuardType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 356				; 00000164H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8

; 3491 : 
; 3492 : 	kStream >> m_eCombatBonusImprovement;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 368				; 00000170H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z ; operator>>
	add	esp, 8

; 3493 : 
; 3494 : 	ArrayWrapper<int> kExtraYieldThreshold(NUM_YIELD_TYPES, m_iExtraYieldThreshold);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 384				; 00000180H
	mov	DWORD PTR _kExtraYieldThreshold$[ebp], eax
	mov	DWORD PTR _kExtraYieldThreshold$[ebp+4], 6

; 3495 : 	kStream >> kExtraYieldThreshold;

	lea	ecx, DWORD PTR _kExtraYieldThreshold$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3496 : 
; 3497 : 	ArrayWrapper<int> kFreeCityYield(NUM_YIELD_TYPES, m_iFreeCityYield);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 408				; 00000198H
	mov	DWORD PTR _kFreeCityYield$[ebp], eax
	mov	DWORD PTR _kFreeCityYield$[ebp+4], 6

; 3498 : 	kStream >> kFreeCityYield;

	lea	ecx, DWORD PTR _kFreeCityYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3499 : 
; 3500 : 	ArrayWrapper<int> kYieldChangeResourcesWrapper(NUM_YIELD_TYPES, m_iYieldChangeStrategicResources);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 432				; 000001b0H
	mov	DWORD PTR _kYieldChangeResourcesWrapper$[ebp], eax
	mov	DWORD PTR _kYieldChangeResourcesWrapper$[ebp+4], 6

; 3501 : 	kStream >> kYieldChangeResourcesWrapper;

	lea	ecx, DWORD PTR _kYieldChangeResourcesWrapper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3502 : 
; 3503 : 	ArrayWrapper<int> kYieldChangeLuxuryResourcesWrapper(NUM_YIELD_TYPES, m_iYieldChangeLuxuryResources); // NQMP GJS - New Netherlands UA

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 456				; 000001c8H
	mov	DWORD PTR _kYieldChangeLuxuryResourcesWrapper$[ebp], eax
	mov	DWORD PTR _kYieldChangeLuxuryResourcesWrapper$[ebp+4], 6

; 3504 : 	kStream >> kYieldChangeLuxuryResourcesWrapper; // NQMP GJS - New Netherlands UA

	lea	ecx, DWORD PTR _kYieldChangeLuxuryResourcesWrapper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3505 : 
; 3506 : 	ArrayWrapper<int> kYieldRateModifierWrapper(NUM_YIELD_TYPES, m_iYieldRateModifier);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 552				; 00000228H
	mov	DWORD PTR _kYieldRateModifierWrapper$[ebp], eax
	mov	DWORD PTR _kYieldRateModifierWrapper$[ebp+4], 6

; 3507 : 	kStream >> kYieldRateModifierWrapper;

	lea	ecx, DWORD PTR _kYieldRateModifierWrapper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3508 : 
; 3509 : 	ArrayWrapper<int> kYieldChangeNaturalWonderWrapper(NUM_YIELD_TYPES, m_iYieldChangeNaturalWonder);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 480				; 000001e0H
	mov	DWORD PTR _kYieldChangeNaturalWonderWrapper$[ebp], eax
	mov	DWORD PTR _kYieldChangeNaturalWonderWrapper$[ebp+4], 6

; 3510 : 	kStream >> kYieldChangeNaturalWonderWrapper;

	lea	ecx, DWORD PTR _kYieldChangeNaturalWonderWrapper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3511 : 
; 3512 : 	if (uiVersion >= 7)

	cmp	DWORD PTR _uiVersion$[ebp], 7
	jb	SHORT $LN32@Read

; 3513 : 	{
; 3514 : 		ArrayWrapper<int> kYieldChangePerTradePartnerWrapper(NUM_YIELD_TYPES, m_iYieldChangePerTradePartner);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 504				; 000001f8H
	mov	DWORD PTR _kYieldChangePerTradePartnerWrapper$223387[ebp], eax
	mov	DWORD PTR _kYieldChangePerTradePartnerWrapper$223387[ebp+4], 6

; 3515 : 		kStream >> kYieldChangePerTradePartnerWrapper;

	lea	ecx, DWORD PTR _kYieldChangePerTradePartnerWrapper$223387[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3516 : 
; 3517 : 		ArrayWrapper<int> kYieldChangeIncomingTradeRouteWrapper(NUM_YIELD_TYPES, m_iYieldChangeIncomingTradeRoute);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 528				; 00000210H
	mov	DWORD PTR _kYieldChangeIncomingTradeRouteWrapper$223389[ebp], eax
	mov	DWORD PTR _kYieldChangeIncomingTradeRouteWrapper$223389[ebp+4], 6

; 3518 : 		kStream >> kYieldChangeIncomingTradeRouteWrapper;

	lea	ecx, DWORD PTR _kYieldChangeIncomingTradeRouteWrapper$223389[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 3519 : 	}
; 3520 : 	else

	jmp	SHORT $LN31@Read
$LN32@Read:

; 3521 : 	{
; 3522 : 		for(int iYield = 0; iYield < NUM_YIELD_TYPES; iYield++)

	mov	DWORD PTR _iYield$223391[ebp], 0
	jmp	SHORT $LN30@Read
$LN29@Read:
	mov	eax, DWORD PTR _iYield$223391[ebp]
	add	eax, 1
	mov	DWORD PTR _iYield$223391[ebp], eax
$LN30@Read:
	cmp	DWORD PTR _iYield$223391[ebp], 6
	jge	SHORT $LN31@Read

; 3523 : 		{
; 3524 : 			m_iYieldChangePerTradePartner[iYield] = 0;

	mov	ecx, DWORD PTR _iYield$223391[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+504], 0

; 3525 : 			m_iYieldChangeIncomingTradeRoute[iYield] = 0;

	mov	eax, DWORD PTR _iYield$223391[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+528], 0

; 3526 : 		}

	jmp	SHORT $LN29@Read
$LN31@Read:

; 3527 : 	}
; 3528 : 
; 3529 : 	CvAssert(GC.getNumTerrainInfos() == NUM_TERRAIN_TYPES);	// If this is not true, m_iStrategicResourceQuantityModifier must be resized dynamically
; 3530 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, &m_iStrategicResourceQuantityModifier[0], GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 576				; 00000240H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 3531 : 
; 3532 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_aiResourceQuantityModifier);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 8

; 3533 : 
; 3534 : 	kStream >> iNumEntries;

	lea	eax, DWORD PTR _iNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3535 : 	m_abNoTrain.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 3536 : 	for (int i = 0; i < iNumEntries; i++)

	mov	DWORD PTR _i$223410[ebp], 0
	jmp	SHORT $LN27@Read
$LN26@Read:
	mov	ecx, DWORD PTR _i$223410[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$223410[ebp], ecx
$LN27@Read:
	mov	edx, DWORD PTR _i$223410[ebp]
	cmp	edx, DWORD PTR _iNumEntries$[ebp]
	jge	SHORT $LN25@Read

; 3537 : 	{
; 3538 : 		bool bValue;
; 3539 : 		kStream >> bValue;

	lea	eax, DWORD PTR _bValue$223414[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3540 : 		m_abNoTrain.push_back(bValue);

	mov	cl, BYTE PTR _bValue$223414[ebp]
	mov	BYTE PTR $T237733[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 628				; 00000274H
	mov	DWORD PTR $T237732[ebp], edx
	lea	eax, DWORD PTR $T237729[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237732[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237728[ebp], ecx
	mov	DWORD PTR $T237728[ebp+4], edx
	movzx	eax, BYTE PTR $T237733[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237728[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T237728[ebp]
	push	edx
	lea	eax, DWORD PTR $T237730[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237732[ebp]
	call	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert

; 3541 : 	}

	jmp	$LN26@Read
$LN25@Read:

; 3542 : 	
; 3543 : 	//EAP: No build
; 3544 : 	kStream >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3545 : 	m_abNoBuild.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 3546 : 	for (int i = 0; i < iNumEntries; i++)

	mov	DWORD PTR _i$223415[ebp], 0
	jmp	SHORT $LN24@Read
$LN23@Read:
	mov	edx, DWORD PTR _i$223415[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223415[ebp], edx
$LN24@Read:
	mov	eax, DWORD PTR _i$223415[ebp]
	cmp	eax, DWORD PTR _iNumEntries$[ebp]
	jge	SHORT $LN22@Read

; 3547 : 	{
; 3548 : 		bool bValue;
; 3549 : 		kStream >> bValue;

	lea	ecx, DWORD PTR _bValue$223419[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 3550 : 		m_abNoBuild.push_back(bValue);

	mov	dl, BYTE PTR _bValue$223419[ebp]
	mov	BYTE PTR $T237978[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 648				; 00000288H
	mov	DWORD PTR $T237977[ebp], eax
	lea	ecx, DWORD PTR $T237974[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237977[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T237973[ebp], edx
	mov	DWORD PTR $T237973[ebp+4], eax
	movzx	ecx, BYTE PTR $T237978[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237973[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T237973[ebp]
	push	eax
	lea	ecx, DWORD PTR $T237975[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T237977[ebp]
	call	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert

; 3551 : 	}

	jmp	$LN23@Read
$LN22@Read:

; 3552 : 
; 3553 : 	kStream >> iNumEntries;

	lea	edx, DWORD PTR _iNumEntries$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3554 : 	m_aFreeTraitUnits.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 668				; 0000029cH
	mov	DWORD PTR $T238000[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN570@Read
	mov	DWORD PTR _i$237994[ebp], 0
	jmp	SHORT $LN568@Read
$LN567@Read:
	mov	edx, DWORD PTR _i$237994[ebp]
	add	edx, 1
	mov	DWORD PTR _i$237994[ebp], edx
$LN568@Read:
	mov	eax, DWORD PTR $T238000[ebp]
	mov	ecx, DWORD PTR _i$237994[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN570@Read
	jmp	SHORT $LN567@Read
$LN570@Read:
	mov	edx, DWORD PTR $T238000[ebp]
	mov	DWORD PTR [edx+4], 0

; 3555 : 	for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$223420[ebp], 0
	jmp	SHORT $LN21@Read
$LN20@Read:
	mov	eax, DWORD PTR _iI$223420[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$223420[ebp], eax
$LN21@Read:
	mov	ecx, DWORD PTR _iI$223420[ebp]
	cmp	ecx, DWORD PTR _iNumEntries$[ebp]
	jge	SHORT $LN19@Read

; 3556 : 	{
; 3557 : 		FreeTraitUnit trait;
; 3558 : 		kStream >> trait.m_iFreeUnit;

	lea	edx, DWORD PTR _trait$223424[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8

; 3559 : 		kStream >> trait.m_ePrereqTech;

	lea	ecx, DWORD PTR _trait$223424[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z ; operator>>
	add	esp, 8

; 3560 : 		m_aFreeTraitUnits.push_back(trait);

	lea	eax, DWORD PTR _trait$223424[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 668				; 0000029cH
	call	?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back

; 3561 : 	}

	jmp	SHORT $LN20@Read
$LN19@Read:

; 3562 : 
; 3563 : 	kStream >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3564 : 	for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$223428[ebp], 0
	jmp	SHORT $LN18@Read
$LN17@Read:
	mov	edx, DWORD PTR _iI$223428[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223428[ebp], edx
$LN18@Read:
	mov	eax, DWORD PTR _iI$223428[ebp]
	cmp	eax, DWORD PTR _iNumEntries$[ebp]
	jge	SHORT $LN16@Read

; 3565 : 	{
; 3566 : 		kStream >> m_paiMovesChangeUnitCombat[iI];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+784]
	mov	eax, DWORD PTR _iI$223428[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T238017[ebp], ecx
	mov	edx, DWORD PTR $T238017[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3567 : 	}

	jmp	SHORT $LN17@Read
$LN16@Read:

; 3568 : 	if (uiVersion >= 10)

	cmp	DWORD PTR _uiVersion$[ebp], 10		; 0000000aH
	jb	SHORT $LN15@Read

; 3569 : 	{
; 3570 : 		for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$223433[ebp], 0
	jmp	SHORT $LN14@Read
$LN13@Read:
	mov	eax, DWORD PTR _iI$223433[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$223433[ebp], eax
$LN14@Read:
	mov	ecx, DWORD PTR _iI$223433[ebp]
	cmp	ecx, DWORD PTR _iNumEntries$[ebp]
	jge	SHORT $LN12@Read

; 3571 : 		{
; 3572 : 			kStream >> m_paiMaintenanceModifierUnitCombat[iI];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+800]
	mov	ecx, DWORD PTR _iI$223433[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T238024[ebp], edx
	mov	eax, DWORD PTR $T238024[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3573 : 		}

	jmp	SHORT $LN13@Read
$LN12@Read:

; 3574 : 	}
; 3575 : 	else

	jmp	SHORT $LN11@Read
$LN15@Read:

; 3576 : 	{
; 3577 : 		int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	mov	DWORD PTR _iNumUnitCombatClassInfos$223438[ebp], eax

; 3578 : 		m_paiMaintenanceModifierUnitCombat.resize(iNumUnitCombatClassInfos);

	push	0
	mov	ecx, DWORD PTR _iNumUnitCombatClassInfos$223438[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 796				; 0000031cH
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize

; 3579 : 		for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	mov	DWORD PTR _iI$223439[ebp], 0
	jmp	SHORT $LN10@Read
$LN9@Read:
	mov	edx, DWORD PTR _iI$223439[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223439[ebp], edx
$LN10@Read:
	mov	eax, DWORD PTR _iI$223439[ebp]
	cmp	eax, DWORD PTR _iNumUnitCombatClassInfos$223438[ebp]
	jge	SHORT $LN11@Read

; 3580 : 		{
; 3581 : 			m_paiMaintenanceModifierUnitCombat[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+800]
	mov	eax, DWORD PTR _iI$223439[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 3582 : 		}

	jmp	SHORT $LN9@Read
$LN11@Read:

; 3583 : 	}
; 3584 : 
; 3585 : 	kStream >> m_ppaaiImprovementYieldChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 812				; 0000032cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator>><Firaxis::Array<int,6> >
	add	esp, 8

; 3586 : 	kStream >> m_ppaaiSpecialistYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 828				; 0000033cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator>><Firaxis::Array<int,6> >
	add	esp, 8

; 3587 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 3588 : 	kStream >> m_ppaaiAnySpecificSpecialistYieldChange;
; 3589 : #endif
; 3590 : 	kStream >> m_ppaaiUnimprovedFeatureYieldChange;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 844				; 0000034cH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator>><Firaxis::Array<int,6> >
	add	esp, 8

; 3591 : 
; 3592 : 	if (uiVersion >= 11)

	cmp	DWORD PTR _uiVersion$[ebp], 11		; 0000000bH
	jb	$LN7@Read

; 3593 : 	{
; 3594 : 		kStream >> iNumEntries;

	lea	ecx, DWORD PTR _iNumEntries$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3595 : 		m_aUniqueLuxuryAreas.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 724				; 000002d4H
	mov	DWORD PTR $T238357[ebp], edx
	mov	eax, DWORD PTR $T238357[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238223[ebp], ecx
	mov	edx, DWORD PTR $T238223[ebp]
	mov	DWORD PTR $T238340[ebp], edx
	mov	eax, DWORD PTR $T238340[ebp]
	mov	DWORD PTR $T238339[ebp], eax
	mov	ecx, DWORD PTR $T238357[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238239[ebp], edx
	mov	eax, DWORD PTR $T238239[ebp]
	mov	DWORD PTR $T238342[ebp], eax
	mov	ecx, DWORD PTR $T238342[ebp]
	mov	DWORD PTR $T238341[ebp], ecx
	mov	edx, DWORD PTR $T238339[ebp]
	push	edx
	mov	eax, DWORD PTR $T238341[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238343[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238357[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 3596 : 		for (int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$223444[ebp], 0
	jmp	SHORT $LN6@Read
$LN5@Read:
	mov	edx, DWORD PTR _iI$223444[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223444[ebp], edx
$LN6@Read:
	mov	eax, DWORD PTR _iI$223444[ebp]
	cmp	eax, DWORD PTR _iNumEntries$[ebp]
	jge	SHORT $LN4@Read

; 3597 : 		{
; 3598 : 			int iAreaID;
; 3599 : 			kStream >> iAreaID;

	lea	ecx, DWORD PTR _iAreaID$223448[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 3600 : 			m_aUniqueLuxuryAreas.push_back(iAreaID);

	lea	edx, DWORD PTR _iAreaID$223448[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 724				; 000002d4H
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3601 : 		}

	jmp	SHORT $LN5@Read
$LN4@Read:

; 3602 : 	}
; 3603 : 	else if (uiVersion >= 9)

	jmp	$LN74@Read
$LN7@Read:
	cmp	DWORD PTR _uiVersion$[ebp], 9
	jb	SHORT $LN2@Read

; 3604 : 	{
; 3605 : 		kStream >> m_aUniqueLuxuryAreas;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 724				; 000002d4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
	add	esp, 8

; 3606 : 	}
; 3607 : 	else

	jmp	$LN74@Read
$LN2@Read:

; 3608 : 	{
; 3609 : 		m_aUniqueLuxuryAreas.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 724				; 000002d4H
	mov	DWORD PTR $T238664[ebp], edx
	mov	eax, DWORD PTR $T238664[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238530[ebp], ecx
	mov	edx, DWORD PTR $T238530[ebp]
	mov	DWORD PTR $T238647[ebp], edx
	mov	eax, DWORD PTR $T238647[ebp]
	mov	DWORD PTR $T238646[ebp], eax
	mov	ecx, DWORD PTR $T238664[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238546[ebp], edx
	mov	eax, DWORD PTR $T238546[ebp]
	mov	DWORD PTR $T238649[ebp], eax
	mov	ecx, DWORD PTR $T238649[ebp]
	mov	DWORD PTR $T238648[ebp], ecx
	mov	edx, DWORD PTR $T238646[ebp]
	push	edx
	mov	eax, DWORD PTR $T238648[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238650[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238664[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN74@Read:

; 3610 : 	}
; 3611 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvPlayerTraits@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTraits::Read
_TEXT	ENDS
PUBLIC	??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator<<<Firaxis::Array<int,6> >
PUBLIC	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
PUBLIC	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
PUBLIC	?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z	; CvPlayerTraits::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -328						; size = 4
$T239363 = -324						; size = 4
$T239356 = -320						; size = 4
$T239349 = -316						; size = 4
$T239345 = -312						; size = 4
$T239338 = -308						; size = 4
$T239322 = -304						; size = 4
$T239315 = -300						; size = 4
$T239311 = -296						; size = 4
$T239292 = -292						; size = 4
$T239304 = -285						; size = 1
$T239207 = -240						; size = 4
$T239200 = -236						; size = 4
$T239196 = -232						; size = 4
$T239177 = -228						; size = 4
$T239189 = -221						; size = 1
$T239092 = -176						; size = 4
$T239085 = -172						; size = 4
$T239042 = -168						; size = 4
$T239008 = -164						; size = 4
__Tmp$238998 = -160					; size = 4
$T238983 = -156						; size = 4
$T238970 = -152						; size = 4
$T238684 = -148						; size = 4
$T238683 = -144						; size = 4
$T238682 = -140						; size = 8
$T238681 = -132						; size = 4
$T238680 = -128						; size = 8
$T238679 = -120						; size = 4
$T238678 = -116						; size = 8
$T238677 = -108						; size = 8
$T238676 = -100						; size = 8
$T238675 = -92						; size = 8
$T238674 = -84						; size = 8
$T238673 = -76						; size = 8
$T238672 = -68						; size = 8
$T238671 = -60						; size = 8
$T238670 = -52						; size = 4
$T238669 = -48						; size = 4
$T238668 = -44						; size = 4
$T238667 = -40						; size = 4
_iI$223614 = -36					; size = 4
_iI$223608 = -32					; size = 4
_iI$223604 = -28					; size = 4
_ui$223591 = -24					; size = 4
_ui$223585 = -20					; size = 4
_ui$223571 = -16					; size = 4
_uiVersion$ = -12					; size = 4
_iNumUnitCombatClassInfos$ = -8				; size = 4
_it$ = -4						; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTraits::Write, COMDAT
; _this$ = ecx

; 3615 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	mov	DWORD PTR _this$[ebp], ecx

; 3616 : 	// Current version number
; 3617 : 	uint uiVersion = 19;

	mov	DWORD PTR _uiVersion$[ebp], 19		; 00000013H

; 3618 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3619 : 
; 3620 : 	kStream << m_iGreatPeopleRateModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3621 : 	kStream << m_iGreatScientistRateModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3622 : 	kStream << m_iGreatGeneralRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3623 : 	kStream << m_iGreatGeneralExtraBonus;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3624 : 	kStream << m_iGreatPersonGiftInfluence;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3625 : 	kStream << m_iLevelExperienceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3626 : 	kStream << m_iMaxGlobalBuildingProductionModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3627 : 	kStream << m_iMaxTeamBuildingProductionModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3628 : 	kStream << m_iMaxPlayerBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3629 : 	kStream << m_iCityUnhappinessModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3630 : 	kStream << m_iPopulationUnhappinessModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3631 : 	kStream << m_iCityStateBonusModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3632 : 	kStream << m_iCityStateFriendshipModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3633 : 	kStream << m_iCityStateCombatModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3634 : 	kStream << m_iLandBarbarianConversionPercent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3635 : 	kStream << m_iLandBarbarianConversionExtraUnits;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3636 : 	kStream << m_iSeaBarbarianConversionPercent;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 108				; 0000006cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3637 : 	kStream << m_iCapitalBuildingModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3638 : 	kStream << m_iPlotBuyCostModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3639 : 	kStream << m_iPlotCultureCostModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3640 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN
; 3641 : 	kStream << m_iSciencePerGreatPersonBorn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3642 : #endif
; 3643 : #ifdef NQ_NUM_TURNS_BEFORE_MINOR_ALLIES_REFUSE_BRIBES_FROM_TRAIT
; 3644 : 	kStream << m_iNumTurnsBeforeMinorAlliesRefuseBribes;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3645 : #endif
; 3646 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 3647 : 	kStream << m_iGoldenAgeTileBonusFaith;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 132				; 00000084H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3648 : #endif
; 3649 : 	kStream << m_iCultureFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3650 : 	kStream << m_iFaithFromKills;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3651 : 	kStream << m_iCityCultureBonus;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 144				; 00000090H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3652 : 	kStream << m_iCapitalThemingBonusModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3653 : 	kStream << m_iPolicyCostModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3654 : 	kStream << m_iCityConnectionTradeRouteChange;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 156				; 0000009cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3655 : 	kStream << m_iWonderProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 160				; 000000a0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3656 : 	kStream << m_iPlunderModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 164				; 000000a4H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3657 : 	kStream << m_iImprovementMaintenanceModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 168				; 000000a8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3658 : 	kStream << m_iGoldenAgeDurationModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 172				; 000000acH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3659 : 	kStream << m_iGoldenAgeMoveChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3660 : 	kStream << m_iGoldenAgeCombatModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 180				; 000000b4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3661 : 	kStream << m_iGoldenAgeTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 184				; 000000b8H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3662 : 	kStream << m_iGoldenAgeGreatArtistRateModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 188				; 000000bcH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3663 : 	kStream << m_iGoldenAgeGreatMusicianRateModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 192				; 000000c0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3664 : 	kStream << m_iGoldenAgeGreatWriterRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 196				; 000000c4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3665 : 	kStream << m_iExtraEmbarkMoves;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3666 : 	kStream << m_iNaturalWonderFirstFinderGold;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 204				; 000000ccH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3667 : 	kStream << m_iNaturalWonderSubsequentFinderGold;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 208				; 000000d0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3668 : 	
; 3669 : 	//EAP: Natural wonder faith for the finder
; 3670 : 	
; 3671 : 	kStream << m_iNaturalWonderFirstFinderFaith;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 216				; 000000d8H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3672 : 	kStream << m_iNaturalWonderSubsequentFinderFaith;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 220				; 000000dcH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3673 : 	
; 3674 : 
; 3675 : 	//
; 3676 : 	kStream << m_iNaturalWonderYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3677 : 	kStream << m_iNaturalWonderHappinessModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 224				; 000000e0H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3678 : 	kStream << m_iNearbyImprovementCombatBonus;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 228				; 000000e4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3679 : 	kStream << m_iNearbyImprovementBonusRange;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3680 : 	kStream << m_iCultureBuildingYieldChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3681 : 	kStream << m_iCombatBonusVsHigherTech;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 240				; 000000f0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3682 : 	kStream << m_iCombatBonusVsLargerCiv;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 244				; 000000f4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3683 : 	kStream << m_iLandUnitMaintenanceModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3684 : 	kStream << m_iNavalUnitMaintenanceModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 252				; 000000fcH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3685 : 	kStream << m_iRazeSpeedModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 256				; 00000100H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3686 : 	kStream << m_iDOFGreatPersonModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3687 : 	kStream << m_iLuxuryHappinessRetention;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 264				; 00000108H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3688 : 	kStream << m_iExtraHappinessPerLuxury; // NQMP GJS - New Netherlands UA

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 268				; 0000010cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3689 : 	kStream << m_iExtraSpies;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3690 : 	kStream << m_iHappinessPerReligion; // NQMP GJS - New Ottoman UA

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 276				; 00000114H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3691 : 	kStream << m_iUnresearchedTechBonusFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 280				; 00000118H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3692 : 	kStream << m_iExtraFoundedCityTerritoryClaimRange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 284				; 0000011cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3693 : 	kStream << m_iFreeSocialPoliciesPerEra;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 288				; 00000120H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3694 : 	kStream << m_iNumTradeRoutesModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 292				; 00000124H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3695 : 	kStream << m_iTradeRouteResourceModifier;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3696 : 	kStream << m_iUniqueLuxuryCities;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3697 : 	kStream << m_iUniqueLuxuryQuantity;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 304				; 00000130H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3698 : 	kStream << m_iUniqueLuxuryCitiesPlaced;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3699 : 	kStream << m_iWorkerSpeedModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 312				; 00000138H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3700 : 	kStream << m_iAfraidMinorPerTurnInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3701 : 	kStream << m_iLandTradeRouteRangeBonus;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 320				; 00000140H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3702 : 	kStream << m_iTradeReligionModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 324				; 00000144H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3703 : 	kStream << m_iTradeBuildingModifier;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 328				; 00000148H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3704 : 
; 3705 : 	kStream << m_bFightWellDamaged;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3706 : 	kStream << m_bMoveFriendlyWoodsAsRoad;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 333				; 0000014dH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3707 : 	kStream << m_bFasterAlongRiver;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 334				; 0000014eH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3708 : 	kStream << m_bFasterInHills;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 335				; 0000014fH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3709 : 	kStream << m_bEmbarkedAllWater;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 336				; 00000150H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3710 : 	kStream << m_bEmbarkedToLandFlatCost;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 337				; 00000151H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3711 : 	kStream << m_bNoHillsImprovementMaintenance;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 338				; 00000152H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3712 : 	kStream << m_bTechBoostFromCapitalScienceBuildings;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 339				; 00000153H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3713 : 	kStream << m_bStaysAliveZeroCities;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3714 : 	kStream << m_bFaithFromUnimprovedForest;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 341				; 00000155H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3715 : #ifdef NQ_UNIT_IMMUNE_TO_PLUNDER_FROM_TRAIT
; 3716 : 	kStream << m_bSeaTradeRoutesArePlunderImmune;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 342				; 00000156H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3717 : #endif
; 3718 : 
; 3719 : 	// NQMP GJS - New France UA begin
; 3720 : 	kStream << m_bEarnsGreatPersonOnSlotOrGuild;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 343				; 00000157H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3721 : 	kStream << m_bHasBuiltWritersGuild;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 344				; 00000158H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3722 : 	kStream << m_bHasBuiltArtistsGuild;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 345				; 00000159H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3723 : 	kStream << m_bHasBuiltMusiciansGuild;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 346				; 0000015aH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3724 : 	// NQMP GJS - New France UA end
; 3725 : 
; 3726 : 	kStream << m_bBonusReligiousBelief;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 347				; 0000015bH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3727 : 	kStream << m_bAbleToAnnexCityStates;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 348				; 0000015cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3728 : 	kStream << m_bCrossesMountainsAfterGreatGeneral;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 349				; 0000015dH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3729 : 	kStream << m_bMayaCalendarBonuses;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 350				; 0000015eH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3730 : 
; 3731 : 	kStream << m_iBaktunPreviousTurn;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 740				; 000002e4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3732 : 
; 3733 : 	std::vector<MayaBonusChoice>::const_iterator it;

	mov	DWORD PTR _it$[ebp], 0

; 3734 : 	kStream << m_aMayaBonusChoices.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 764				; 000002fcH
	mov	DWORD PTR $T238970[ebp], eax
	mov	ecx, DWORD PTR $T238970[ebp]
	mov	edx, DWORD PTR $T238970[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T238667[ebp], eax
	lea	ecx, DWORD PTR $T238667[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3735 : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 3736 : 	for (it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); ++it)
; 3737 : #else
; 3738 : 	for(it = m_aMayaBonusChoices.begin(); it != m_aMayaBonusChoices.end(); it++)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+768]
	mov	DWORD PTR $T238983[ebp], eax
	mov	ecx, DWORD PTR $T238983[ebp]
	mov	DWORD PTR $T238668[ebp], ecx
	mov	edx, DWORD PTR $T238668[ebp]
	mov	DWORD PTR _it$[ebp], edx
	jmp	SHORT $LN21@Write
$LN20@Write:
	mov	eax, DWORD PTR _it$[ebp]
	mov	DWORD PTR __Tmp$238998[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 8
	mov	DWORD PTR _it$[ebp], ecx
	mov	edx, DWORD PTR __Tmp$238998[ebp]
	mov	DWORD PTR $T238669[ebp], edx
$LN21@Write:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+772]
	mov	DWORD PTR $T239008[ebp], ecx
	mov	edx, DWORD PTR $T239008[ebp]
	mov	DWORD PTR $T238670[ebp], edx
	mov	eax, DWORD PTR _it$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T238670[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN19@Write

; 3739 : #endif
; 3740 : 	{
; 3741 : 		kStream << it->m_eUnitType;

	mov	ecx, DWORD PTR _it$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<
	add	esp, 8

; 3742 : 		kStream << it->m_iBaktunJustFinished;

	mov	eax, DWORD PTR _it$[ebp]
	add	eax, 4
	mov	DWORD PTR $T239042[ebp], eax
	mov	ecx, DWORD PTR $T239042[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3743 : 	}

	jmp	SHORT $LN20@Write
$LN19@Write:

; 3744 : 
; 3745 : 	kStream << m_bNoAnnexing;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 351				; 0000015fH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3746 : 	kStream << m_bTechFromCityConquer;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3747 : 	kStream << m_bUniqueLuxuryRequiresNewArea;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 353				; 00000161H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3748 : 	kStream << m_bRiverTradeRoad;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 354				; 00000162H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3749 : 	kStream << m_bAngerFreeIntrusionOfCityStates;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 355				; 00000163H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3750 : 
; 3751 : 	kStream << m_eCampGuardType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 356				; 00000164H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<
	add	esp, 8

; 3752 : 	kStream << m_eCombatBonusImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 368				; 00000170H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z ; operator<<
	add	esp, 8

; 3753 : 
; 3754 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iExtraYieldThreshold);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 384				; 00000180H
	mov	DWORD PTR $T238671[ebp], edx
	mov	DWORD PTR $T238671[ebp+4], 6
	lea	eax, DWORD PTR $T238671[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3755 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iFreeCityYield);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 408				; 00000198H
	mov	DWORD PTR $T238672[ebp], edx
	mov	DWORD PTR $T238672[ebp+4], 6
	lea	eax, DWORD PTR $T238672[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3756 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeStrategicResources);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 432				; 000001b0H
	mov	DWORD PTR $T238673[ebp], edx
	mov	DWORD PTR $T238673[ebp+4], 6
	lea	eax, DWORD PTR $T238673[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3757 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeLuxuryResources); // NQMP GJS - New Netherlands UA

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 456				; 000001c8H
	mov	DWORD PTR $T238674[ebp], edx
	mov	DWORD PTR $T238674[ebp+4], 6
	lea	eax, DWORD PTR $T238674[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3758 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldRateModifier);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 552				; 00000228H
	mov	DWORD PTR $T238675[ebp], edx
	mov	DWORD PTR $T238675[ebp+4], 6
	lea	eax, DWORD PTR $T238675[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3759 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeNaturalWonder);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 480				; 000001e0H
	mov	DWORD PTR $T238676[ebp], edx
	mov	DWORD PTR $T238676[ebp+4], 6
	lea	eax, DWORD PTR $T238676[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3760 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangePerTradePartner);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 504				; 000001f8H
	mov	DWORD PTR $T238677[ebp], edx
	mov	DWORD PTR $T238677[ebp+4], 6
	lea	eax, DWORD PTR $T238677[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3761 : 	kStream << ArrayWrapper<int>(NUM_YIELD_TYPES, m_iYieldChangeIncomingTradeRoute);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 528				; 00000210H
	mov	DWORD PTR $T238678[ebp], edx
	mov	DWORD PTR $T238678[ebp+4], 6
	lea	eax, DWORD PTR $T238678[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 3762 : 	
; 3763 : 	CvInfosSerializationHelper::WriteHashedDataArray<TerrainTypes>(kStream, &m_iStrategicResourceQuantityModifier[0], GC.getNumTerrainInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTerrainInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTerrainInfos
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 576				; 00000240H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
	add	esp, 12					; 0000000cH

; 3764 : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_aiResourceQuantityModifier);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
	add	esp, 8

; 3765 : 
; 3766 : 	kStream << m_abNoTrain.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+628]
	mov	DWORD PTR $T239085[ebp], ecx
	mov	edx, DWORD PTR $T239085[ebp]
	mov	DWORD PTR $T238679[ebp], edx
	lea	eax, DWORD PTR $T238679[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3767 : 	for (uint ui = 0; ui < m_abNoTrain.size(); ui++)

	mov	DWORD PTR _ui$223571[ebp], 0
	jmp	SHORT $LN18@Write
$LN17@Write:
	mov	ecx, DWORD PTR _ui$223571[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$223571[ebp], ecx
$LN18@Write:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+628]
	mov	DWORD PTR $T239092[ebp], eax
	mov	ecx, DWORD PTR _ui$223571[ebp]
	cmp	ecx, DWORD PTR $T239092[ebp]
	jae	SHORT $LN16@Write

; 3768 : 	{
; 3769 : 		kStream << m_abNoTrain[ui];

	mov	edx, DWORD PTR _ui$223571[ebp]
	push	edx
	lea	eax, DWORD PTR $T238680[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 628				; 00000274H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T239196[ebp], eax
	mov	ecx, DWORD PTR $T239196[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239177[ebp], edx
	mov	eax, DWORD PTR $T239196[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]
	shl	edx, cl
	mov	eax, DWORD PTR $T239177[ebp]
	and	edx, DWORD PTR [eax]
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR $T239189[ebp], dl
	lea	ecx, DWORD PTR $T239189[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3770 : 	}

	jmp	$LN17@Write
$LN16@Write:

; 3771 : 	
; 3772 : 	// EAP: No build
; 3773 : 	kStream << m_abNoBuild.size();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+648]
	mov	DWORD PTR $T239200[ebp], eax
	mov	ecx, DWORD PTR $T239200[ebp]
	mov	DWORD PTR $T238681[ebp], ecx
	lea	edx, DWORD PTR $T238681[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3774 : 	for (uint ui = 0; ui < m_abNoBuild.size(); ui++)

	mov	DWORD PTR _ui$223585[ebp], 0
	jmp	SHORT $LN15@Write
$LN14@Write:
	mov	eax, DWORD PTR _ui$223585[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$223585[ebp], eax
$LN15@Write:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+648]
	mov	DWORD PTR $T239207[ebp], edx
	mov	eax, DWORD PTR _ui$223585[ebp]
	cmp	eax, DWORD PTR $T239207[ebp]
	jae	SHORT $LN13@Write

; 3775 : 	{
; 3776 : 		kStream << m_abNoBuild[ui];

	mov	ecx, DWORD PTR _ui$223585[ebp]
	push	ecx
	lea	edx, DWORD PTR $T238682[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 648				; 00000288H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T239311[ebp], eax
	mov	eax, DWORD PTR $T239311[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T239292[ebp], ecx
	mov	edx, DWORD PTR $T239311[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	mov	ecx, DWORD PTR $T239292[ebp]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR $T239304[ebp], al
	lea	edx, DWORD PTR $T239304[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 3777 : 	}

	jmp	$LN14@Write
$LN13@Write:

; 3778 : 
; 3779 : 	kStream << m_aFreeTraitUnits.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	mov	DWORD PTR $T239315[ebp], ecx
	mov	edx, DWORD PTR $T239315[ebp]
	mov	DWORD PTR $T238683[ebp], edx
	lea	eax, DWORD PTR $T238683[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3780 : 	for(uint ui = 0; ui < m_aFreeTraitUnits.size(); ui++)

	mov	DWORD PTR _ui$223591[ebp], 0
	jmp	SHORT $LN12@Write
$LN11@Write:
	mov	ecx, DWORD PTR _ui$223591[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$223591[ebp], ecx
$LN12@Write:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+672]
	mov	DWORD PTR $T239322[ebp], eax
	mov	ecx, DWORD PTR _ui$223591[ebp]
	cmp	ecx, DWORD PTR $T239322[ebp]
	jae	SHORT $LN10@Write

; 3781 : 	{
; 3782 : 		kStream << m_aFreeTraitUnits[ui].m_iFreeUnit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+668]
	mov	ecx, DWORD PTR _ui$223591[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<
	add	esp, 8

; 3783 : 		kStream << m_aFreeTraitUnits[ui].m_ePrereqTech;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+668]
	mov	eax, DWORD PTR _ui$223591[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z ; operator<<
	add	esp, 8

; 3784 : 	}

	jmp	SHORT $LN11@Write
$LN10@Write:

; 3785 : 
; 3786 : 	int iNumUnitCombatClassInfos = GC.getNumUnitCombatClassInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitCombatClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumUnitCombatClassInfos
	mov	DWORD PTR _iNumUnitCombatClassInfos$[ebp], eax

; 3787 : 	kStream << 	iNumUnitCombatClassInfos;

	lea	eax, DWORD PTR _iNumUnitCombatClassInfos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3788 : 	for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	mov	DWORD PTR _iI$223604[ebp], 0
	jmp	SHORT $LN9@Write
$LN8@Write:
	mov	ecx, DWORD PTR _iI$223604[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223604[ebp], ecx
$LN9@Write:
	mov	edx, DWORD PTR _iI$223604[ebp]
	cmp	edx, DWORD PTR _iNumUnitCombatClassInfos$[ebp]
	jge	SHORT $LN7@Write

; 3789 : 	{
; 3790 : 		kStream << m_paiMovesChangeUnitCombat[iI];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+784]
	mov	edx, DWORD PTR _iI$223604[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T239338[ebp], eax
	mov	ecx, DWORD PTR $T239338[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3791 : 	}

	jmp	SHORT $LN8@Write
$LN7@Write:

; 3792 : 	for(int iI = 0; iI < iNumUnitCombatClassInfos; iI++)

	mov	DWORD PTR _iI$223608[ebp], 0
	jmp	SHORT $LN6@Write
$LN5@Write:
	mov	edx, DWORD PTR _iI$223608[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223608[ebp], edx
$LN6@Write:
	mov	eax, DWORD PTR _iI$223608[ebp]
	cmp	eax, DWORD PTR _iNumUnitCombatClassInfos$[ebp]
	jge	SHORT $LN4@Write

; 3793 : 	{
; 3794 : 		kStream << m_paiMaintenanceModifierUnitCombat[iI];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+800]
	mov	eax, DWORD PTR _iI$223608[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T239345[ebp], ecx
	mov	edx, DWORD PTR $T239345[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3795 : 	}

	jmp	SHORT $LN5@Write
$LN4@Write:

; 3796 : 
; 3797 : 	kStream << m_ppaaiImprovementYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 812				; 0000032cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator<<<Firaxis::Array<int,6> >
	add	esp, 8

; 3798 : 	kStream << m_ppaaiSpecialistYieldChange;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 828				; 0000033cH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator<<<Firaxis::Array<int,6> >
	add	esp, 8

; 3799 : #ifdef LEK_TRAIT_SPECIALIST_YIELD_MAX_ONE
; 3800 : 	kStream << m_ppaaiAnySpecificSpecialistYieldChange;
; 3801 : #endif
; 3802 : 	kStream << m_ppaaiUnimprovedFeatureYieldChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; operator<<<Firaxis::Array<int,6> >
	add	esp, 8

; 3803 : 
; 3804 : 	kStream << (int)m_aUniqueLuxuryAreas.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 724				; 000002d4H
	mov	DWORD PTR $T239349[ebp], eax
	mov	ecx, DWORD PTR $T239349[ebp]
	mov	edx, DWORD PTR $T239349[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T238684[ebp], eax
	lea	ecx, DWORD PTR $T238684[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3805 : 	for (unsigned int iI = 0; iI < m_aUniqueLuxuryAreas.size(); iI++)

	mov	DWORD PTR _iI$223614[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	edx, DWORD PTR _iI$223614[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$223614[ebp], edx
$LN3@Write:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 724				; 000002d4H
	mov	DWORD PTR $T239356[ebp], eax
	mov	ecx, DWORD PTR $T239356[ebp]
	mov	edx, DWORD PTR $T239356[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iI$223614[ebp], eax
	jae	SHORT $LN22@Write

; 3806 : 	{
; 3807 : 		kStream << m_aUniqueLuxuryAreas[iI];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+728]
	mov	eax, DWORD PTR _iI$223614[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T239363[ebp], ecx
	mov	edx, DWORD PTR $T239363[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 3808 : 	}

	jmp	SHORT $LN2@Write
$LN22@Write:

; 3809 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvPlayerTraits@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTraits::Write
_TEXT	ENDS
PUBLIC	??_C@_0DA@DHGPFLLL@TXT_KEY_NOTIFICATION_SUMMARY_BAR@ ; `string'
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
PUBLIC	??_C@_0CI@HCNODJNF@TXT_KEY_NOTIFICATION_BARB_CAMP_C@ ; `string'
PUBLIC	??_C@_0CH@JBDFDIBM@Converted?5barbarian?5camp?0?5X?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0BK@LCAPFJNB@Barbarian?5Camp?5Conversion?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z:PROC ; CvPlot::SetBarbarianCampNotConverting
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z:PROC ; CvHomelandAI::LogHomelandMessage
EXTRN	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ:PROC ; CvPlayer::GetHomelandAI
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ:PROC	; CvUnit::jumpToNearestValidPlot
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlot::SetPlayerThatClearedBarbCampHere
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ:PROC ; CvPlot::IsBarbarianCampNotConverting
;	COMDAT ??_C@_0DA@DHGPFLLL@TXT_KEY_NOTIFICATION_SUMMARY_BAR@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DA@DHGPFLLL@TXT_KEY_NOTIFICATION_SUMMARY_BAR@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_BARB_CAMP_CONVERTS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HCNODJNF@TXT_KEY_NOTIFICATION_BARB_CAMP_C@
CONST	SEGMENT
??_C@_0CI@HCNODJNF@TXT_KEY_NOTIFICATION_BARB_CAMP_C@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_BARB_CAMP_CONVERTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JBDFDIBM@Converted?5barbarian?5camp?0?5X?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0CH@JBDFDIBM@Converted?5barbarian?5camp?0?5X?3?5?$CFd?0@ DB 'Conver'
	DB	'ted barbarian camp, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LCAPFJNB@Barbarian?5Camp?5Conversion?$AA@
CONST	SEGMENT
??_C@_0BK@LCAPFJNB@Barbarian?5Camp?5Conversion?$AA@ DB 'Barbarian Camp Co'
	DB	'nversion', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$3
__ehfuncinfo$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
tv264 = -196						; size = 4
_this$ = -192						; size = 4
$T239508 = -188						; size = 4
$T239504 = -184						; size = 4
$T239500 = -180						; size = 4
$T239496 = -176						; size = 4
$T239492 = -172						; size = 4
$T239488 = -168						; size = 4
$T239477 = -164						; size = 4
$T239463 = -160						; size = 4
$T239459 = -156						; size = 4
$T239443 = -152						; size = 4
$T239439 = -148						; size = 4
$T239429 = -144						; size = 4
$T239425 = -140						; size = 4
$T239409 = -136						; size = 4
$T239405 = -132						; size = 4
$T239401 = -128						; size = 4
$T239389 = -124						; size = 4
$T239369 = -119						; size = 1
$T239368 = -118						; size = 1
$T239367 = -117						; size = 1
_logMsg$223637 = -116					; size = 28
_iI$223630 = -88					; size = 4
_iNumGold$223627 = -84					; size = 4
_strBuffer$223639 = -80					; size = 28
_strSummary$223642 = -52				; size = 28
__$ArrayPad$ = -24					; size = 4
_pGiftUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z PROC ; CvPlayerTraits::ConvertBarbarianCamp, COMDAT
; _this$ = ecx

; 3815 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3816 : 	UnitHandle pGiftUnit;

	mov	DWORD PTR _pGiftUnit$[ebp], 0
	mov	BYTE PTR _pGiftUnit$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3817 : 
; 3818 : 	// Has this camp already decided not to convert?
; 3819 : 	if(pPlot->IsBarbarianCampNotConverting())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ ; CvPlot::IsBarbarianCampNotConverting
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@ConvertBar

; 3820 : 	{
; 3821 : 		return false;

	mov	BYTE PTR $T239367[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN22@ConvertBar
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN22@ConvertBar:
	mov	al, BYTE PTR $T239367[ebp]
	jmp	$LN13@ConvertBar
$LN12@ConvertBar:

; 3822 : 	}
; 3823 : 
; 3824 : 	// Roll die to see if it converts
; 3825 : 	if(GC.getGame().getJonRandNum(100, "Barbarian Camp Conversion") < m_iLandBarbarianConversionPercent)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239389[ebp], ecx
	push	OFFSET ??_C@_0BK@LCAPFJNB@Barbarian?5Camp?5Conversion?$AA@
	push	100					; 00000064H
	mov	ecx, DWORD PTR $T239389[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+100]
	jge	$LN11@ConvertBar

; 3826 : 	{
; 3827 : 		pPlot->setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 3828 : 
; 3829 : 		int iNumGold = /*25*/ GC.getGOLD_FROM_BARBARIAN_CONVERSION();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7068
	mov	DWORD PTR _iNumGold$223627[ebp], eax

; 3830 : 		m_pPlayer->GetTreasury()->ChangeGold(iNumGold);

	mov	ecx, DWORD PTR _iNumGold$223627[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3831 : 
; 3832 : 		// Set who last cleared the camp here
; 3833 : 		pPlot->SetPlayerThatClearedBarbCampHere(m_pPlayer->GetID());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T239401[ebp], edx
	mov	eax, DWORD PTR $T239401[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatClearedBarbCampHere

; 3834 : 
; 3835 : 		// Convert the barbarian into our unit
; 3836 : 		FAssertMsg(m_eCampGuardType < GC.getNumUnitInfos(), "Illegal camp guard unit type");
; 3837 : 		pGiftUnit = m_pPlayer->initUnit(m_eCampGuardType, pPlot->getX(), pPlot->getY(), NO_UNITAI, NO_DIRECTION, true /*bNoMove*/);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T239405[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239409[ebp], ecx
	push	0
	push	0
	push	1
	push	1
	push	-1
	push	-1
	mov	edx, DWORD PTR $T239405[ebp]
	push	edx
	mov	eax, DWORD PTR $T239409[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	DWORD PTR $T239425[ebp], eax
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN39@ConvertBar
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN39@ConvertBar:
	mov	ecx, DWORD PTR $T239425[ebp]
	mov	DWORD PTR _pGiftUnit$[ebp], ecx
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN40@ConvertBar
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN40@ConvertBar:

; 3838 : 		if (!pGiftUnit->jumpToNearestValidPlot())

	mov	edx, DWORD PTR _pGiftUnit$[ebp]
	mov	DWORD PTR $T239429[ebp], edx
	mov	ecx, DWORD PTR $T239429[ebp]
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN50@ConvertBar

; 3839 : 			pGiftUnit->kill(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 3840 : 		else

	jmp	SHORT $LN9@ConvertBar

; 3841 : 			pGiftUnit->finishMoves();

$LN50@ConvertBar:
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN9@ConvertBar:

; 3842 : 
; 3843 : 		// Convert any extra units
; 3844 : 		for(int iI = 0; iI < m_iLandBarbarianConversionExtraUnits; iI++)

	mov	DWORD PTR _iI$223630[ebp], 0
	jmp	SHORT $LN8@ConvertBar
$LN7@ConvertBar:
	mov	ecx, DWORD PTR _iI$223630[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223630[ebp], ecx
$LN8@ConvertBar:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iI$223630[ebp]
	cmp	eax, DWORD PTR [edx+104]
	jge	$LN6@ConvertBar

; 3845 : 		{
; 3846 : 			pGiftUnit = m_pPlayer->initUnit(m_eCampGuardType, pPlot->getX(), pPlot->getY(), NO_UNITAI, NO_DIRECTION, true /*bNoMove*/);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T239439[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239443[ebp], ecx
	push	0
	push	0
	push	1
	push	1
	push	-1
	push	-1
	mov	edx, DWORD PTR $T239439[ebp]
	push	edx
	mov	eax, DWORD PTR $T239443[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	DWORD PTR $T239459[ebp], eax
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN57@ConvertBar
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@ConvertBar:
	mov	ecx, DWORD PTR $T239459[ebp]
	mov	DWORD PTR _pGiftUnit$[ebp], ecx
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN58@ConvertBar
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN58@ConvertBar:

; 3847 : 			if (!pGiftUnit->jumpToNearestValidPlot())

	mov	edx, DWORD PTR _pGiftUnit$[ebp]
	mov	DWORD PTR $T239463[ebp], edx
	mov	ecx, DWORD PTR $T239463[ebp]
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN68@ConvertBar

; 3848 : 				pGiftUnit->kill(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 3849 : 			else

	jmp	SHORT $LN4@ConvertBar

; 3850 : 				pGiftUnit->finishMoves();

$LN68@ConvertBar:
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN4@ConvertBar:

; 3851 : 		}

	jmp	$LN7@ConvertBar
$LN6@ConvertBar:

; 3852 : 
; 3853 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ConvertBar
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ConvertBar

; 3854 : 		{
; 3855 : 			CvString logMsg;

	lea	ecx, DWORD PTR _logMsg$223637[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3856 : 			logMsg.Format("Converted barbarian camp, X: %d, Y: %d", pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239477[ebp], ecx
	mov	edx, DWORD PTR $T239477[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CH@JBDFDIBM@Converted?5barbarian?5camp?0?5X?3?5?$CFd?0@
	lea	edx, DWORD PTR _logMsg$223637[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3857 : 			m_pPlayer->GetHomelandAI()->LogHomelandMessage(logMsg);

	lea	eax, DWORD PTR _logMsg$223637[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3858 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _logMsg$223637[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ConvertBar:

; 3859 : 
; 3860 : 		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BARB_CAMP_CONVERTS");

	push	OFFSET ??_C@_0CI@HCNODJNF@TXT_KEY_NOTIFICATION_BARB_CAMP_C@
	lea	edx, DWORD PTR _strBuffer$223639[ebp]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3861 : 		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_BARB_CAMP_CONVERTS");

	push	OFFSET ??_C@_0DA@DHGPFLLL@TXT_KEY_NOTIFICATION_SUMMARY_BAR@
	lea	eax, DWORD PTR _strSummary$223642[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3862 : 		m_pPlayer->GetNotifications()->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pPlot->getX(), pPlot->getY(), -1);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T239488[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239492[ebp], ecx
	lea	ecx, DWORD PTR _strSummary$223642[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239496[ebp], eax
	lea	ecx, DWORD PTR _strBuffer$223639[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239500[ebp], eax
	push	-1
	push	-1
	mov	edx, DWORD PTR $T239488[ebp]
	push	edx
	mov	eax, DWORD PTR $T239492[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239496[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239500[ebp]
	push	edx
	push	-1097390650				; be9725c6H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3863 : 		//Increase Stat
; 3864 : 		if(m_pPlayer->isHuman() &&!GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ConvertBar
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239504[ebp], eax
	mov	ecx, DWORD PTR $T239504[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ConvertBar

; 3865 : 		{
; 3866 : 			gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_BARBSCONVERTED, 10, ACHIEVEMENT_SPECIAL_BARBARIANWARLORD);

	mov	edx, DWORD PTR $T239508[ebp]
	mov	DWORD PTR tv264[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv264[ebp], eax
	push	110					; 0000006eH
	push	10					; 0000000aH
	push	128					; 00000080H
	mov	ecx, DWORD PTR tv264[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv264[ebp]
	mov	eax, DWORD PTR [edx+848]
	call	eax
$LN2@ConvertBar:

; 3867 : 		}
; 3868 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strSummary$223642[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBuffer$223639[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3869 : 
; 3870 : 	// Decided not to
; 3871 : 	else

	jmp	SHORT $LN1@ConvertBar
$LN11@ConvertBar:

; 3872 : 	{
; 3873 : 		pPlot->SetBarbarianCampNotConverting(true);

	push	1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z ; CvPlot::SetBarbarianCampNotConverting

; 3874 : 		return false;

	mov	BYTE PTR $T239368[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN99@ConvertBar
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN99@ConvertBar:
	mov	al, BYTE PTR $T239368[ebp]
	jmp	SHORT $LN13@ConvertBar
$LN1@ConvertBar:

; 3875 : 	}
; 3876 : 
; 3877 : 	return true;

	mov	BYTE PTR $T239369[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN104@ConvertBar
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN104@ConvertBar:
	mov	al, BYTE PTR $T239369[ebp]
$LN13@ConvertBar:

; 3878 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _pGiftUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR _logMsg$223637[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strBuffer$223639[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z$3:
	lea	ecx, DWORD PTR _strSummary$223642[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConvertBarbarianCamp@CvPlayerTraits@@AAE_NPAVCvPlot@@@Z ENDP ; CvPlayerTraits::ConvertBarbarianCamp
PUBLIC	__$ArrayPad$
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
$T239547 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T239547[ebp], 0

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 491  : 
; 492  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 494  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 495  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 496  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T239547[ebp]
	or	eax, 1
	mov	DWORD PTR $T239547[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2:
	mov	eax, DWORD PTR $T239547[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz
	and	DWORD PTR $T239547[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??_C@_0DG@DAOILMDG@TXT_KEY_NOTIFICATION_SUMMARY_BAR@ ; `string'
PUBLIC	??_C@_0CO@DCHLJAOF@TXT_KEY_NOTIFICATION_BARB_NAVAL_@ ; `string'
PUBLIC	??_C@_0CN@NMHBHDNM@Converted?5barbarian?5naval?5unit?0?5@ ; `string'
PUBLIC	??_C@_0BA@KLPDPLHD@LEADER_SULEIMAN?$AA@		; `string'
PUBLIC	??_C@_0CA@NOMNOJAC@Barbarian?5Naval?5Unit?5Conversion?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SetNotConverting@CvUnit@@QAEX_N@Z:PROC		; CvUnit::SetNotConverting
EXTRN	__imp___stricmp:PROC
EXTRN	?setupGraphical@CvUnit@@QAEXXZ:PROC		; CvUnit::setupGraphical
EXTRN	?convert@CvUnit@@QAEXPAV1@_N@Z:PROC		; CvUnit::convert
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?IsNotConverting@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsNotConverting
;	COMDAT ??_C@_0DG@DAOILMDG@TXT_KEY_NOTIFICATION_SUMMARY_BAR@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0DG@DAOILMDG@TXT_KEY_NOTIFICATION_SUMMARY_BAR@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_BARB_NAVAL_UNIT_CONVERTS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DCHLJAOF@TXT_KEY_NOTIFICATION_BARB_NAVAL_@
CONST	SEGMENT
??_C@_0CO@DCHLJAOF@TXT_KEY_NOTIFICATION_BARB_NAVAL_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_BARB_NAVAL_UNIT_CONVERTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NMHBHDNM@Converted?5barbarian?5naval?5unit?0?5@
CONST	SEGMENT
??_C@_0CN@NMHBHDNM@Converted?5barbarian?5naval?5unit?0?5@ DB 'Converted b'
	DB	'arbarian naval unit, X: %d, Y: %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KLPDPLHD@LEADER_SULEIMAN?$AA@
CONST	SEGMENT
??_C@_0BA@KLPDPLHD@LEADER_SULEIMAN?$AA@ DB 'LEADER_SULEIMAN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NOMNOJAC@Barbarian?5Naval?5Unit?5Conversion?$AA@
CONST	SEGMENT
??_C@_0CA@NOMNOJAC@Barbarian?5Naval?5Unit?5Conversion?$AA@ DB 'Barbarian '
	DB	'Naval Unit Conversion', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtraitclasses.cpp
xdata$x	ENDS
;	COMDAT ?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
tv205 = -224						; size = 4
_this$ = -220						; size = 4
$T239757 = -216						; size = 4
$T239753 = -212						; size = 4
$T239749 = -208						; size = 4
$T239740 = -204						; size = 4
$T239736 = -200						; size = 4
$T239727 = -196						; size = 4
$T239719 = -192						; size = 4
$T239710 = -188						; size = 4
$T239706 = -184						; size = 4
$T239697 = -180						; size = 4
$T239689 = -176						; size = 4
$T239685 = -172						; size = 4
$T239684 = -168						; size = 4
$T239680 = -164						; size = 4
$T239676 = -160						; size = 4
$T239663 = -156						; size = 4
$T239659 = -152						; size = 4
$T239643 = -148						; size = 4
$T239639 = -144						; size = 4
$T239630 = -140						; size = 4
$T239626 = -136						; size = 4
$T239617 = -132						; size = 4
$T239613 = -128						; size = 4
$T239606 = -124						; size = 4
$T239584 = -120						; size = 4
$T239572 = -115						; size = 1
$T239571 = -114						; size = 1
$T239570 = -113						; size = 1
_logMsg$223662 = -112					; size = 28
_iNumGold$223658 = -84					; size = 4
_strBuffer$223664 = -80					; size = 28
_strSummary$223667 = -52				; size = 28
__$ArrayPad$ = -24					; size = 4
_pGiftUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvPlayerTraits::ConvertBarbarianNavalUnit, COMDAT
; _this$ = ecx

; 3882 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 212				; 000000d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3883 : 	UnitHandle pGiftUnit;

	mov	DWORD PTR _pGiftUnit$[ebp], 0
	mov	BYTE PTR _pGiftUnit$[ebp+4], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3884 : 
; 3885 : 	// Has this unit already decided not to convert?
; 3886 : 	if(pUnit->IsNotConverting())

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239584[ebp], eax
	mov	ecx, DWORD PTR $T239584[ebp]
	call	?IsNotConverting@CvUnit@@QBE_NXZ	; CvUnit::IsNotConverting
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@ConvertBar@2

; 3887 : 	{
; 3888 : 		return false;

	mov	BYTE PTR $T239570[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN18@ConvertBar@2
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@ConvertBar@2:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN23@ConvertBar@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@ConvertBar@2:
	mov	al, BYTE PTR $T239570[ebp]
	jmp	$LN6@ConvertBar@2
$LN5@ConvertBar@2:

; 3889 : 	}
; 3890 : 
; 3891 : 	// Roll die to see if it converts
; 3892 : 	if(GC.getGame().getJonRandNum(100, "Barbarian Naval Unit Conversion") < m_iSeaBarbarianConversionPercent)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239606[ebp], edx
	push	OFFSET ??_C@_0CA@NOMNOJAC@Barbarian?5Naval?5Unit?5Conversion?$AA@
	push	100					; 00000064H
	mov	ecx, DWORD PTR $T239606[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+108]
	jge	$LN121@ConvertBar@2

; 3893 : 	{
; 3894 : 		int iNumGold = /*25*/ GC.getGOLD_FROM_BARBARIAN_CONVERSION();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7068
	mov	DWORD PTR _iNumGold$223658[ebp], edx

; 3895 : 		m_pPlayer->GetTreasury()->ChangeGold(iNumGold);

	mov	eax, DWORD PTR _iNumGold$223658[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 3896 : 
; 3897 : 		// Convert the barbarian into our unit
; 3898 : #ifdef AUI_UNIT_FIX_GIFTED_UNITS_ARE_GIFTED_NOT_CLONED
; 3899 : 		pGiftUnit = m_pPlayer->initUnit(pUnit->getUnitType(), pUnit->getX(), pUnit->getY(), pUnit->AI_getUnitAIType(), NO_DIRECTION, true /*bNoMove*/, false, DEFAULT_UNIT_MAP_LAYER, 0, true);
; 3900 : #else
; 3901 : 		pGiftUnit = m_pPlayer->initUnit(pUnit->getUnitType(), pUnit->getX(), pUnit->getY(), pUnit->AI_getUnitAIType(), NO_DIRECTION, true /*bNoMove*/, false);

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239613[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239617[ebp], eax
	mov	ecx, DWORD PTR $T239617[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T239626[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239630[ebp], eax
	mov	ecx, DWORD PTR $T239630[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T239639[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239643[ebp], eax
	push	0
	push	0
	push	0
	push	1
	push	-1
	mov	ecx, DWORD PTR $T239613[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	push	eax
	mov	ecx, DWORD PTR $T239626[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239639[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239643[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	DWORD PTR $T239659[ebp], eax
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN48@ConvertBar@2
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@ConvertBar@2:
	mov	ecx, DWORD PTR $T239659[ebp]
	mov	DWORD PTR _pGiftUnit$[ebp], ecx
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN49@ConvertBar@2
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN49@ConvertBar@2:

; 3902 : #endif
; 3903 : 		CvAssertMsg(pGiftUnit, "GiftUnit is not assigned a valid value");
; 3904 : 		pGiftUnit->convert(pUnit.pointer(), false);

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239663[ebp], edx
	push	0
	mov	eax, DWORD PTR $T239663[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?convert@CvUnit@@QAEXPAV1@_N@Z		; CvUnit::convert

; 3905 : 		pGiftUnit->setupGraphical();

	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?setupGraphical@CvUnit@@QAEXXZ		; CvUnit::setupGraphical

; 3906 : 		pGiftUnit->finishMoves(); // No move first turn

	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3907 : 
; 3908 : 		// Validate that the achievement is reached by a live human and active player at the same time
; 3909 : 		if(m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer() && m_pPlayer->getLeaderInfo().GetType() && _stricmp(m_pPlayer->getLeaderInfo().GetType(), "LEADER_SULEIMAN") == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	$LN3@ConvertBar@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239676[ebp], eax
	mov	ecx, DWORD PTR $T239676[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN3@ConvertBar@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	DWORD PTR $T239680[ebp], eax
	mov	ecx, DWORD PTR $T239680[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	je	SHORT $LN3@ConvertBar@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo
	mov	DWORD PTR $T239684[ebp], eax
	mov	ecx, DWORD PTR $T239684[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239685[ebp], eax
	push	OFFSET ??_C@_0BA@KLPDPLHD@LEADER_SULEIMAN?$AA@
	mov	ecx, DWORD PTR $T239685[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@ConvertBar@2

; 3910 : 		{
; 3911 : 			gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_BARBSNAVALCONVERTED, 10, ACHIEVEMENT_SPECIAL_BARBARYPIRATE);

	mov	edx, DWORD PTR $T239689[ebp]
	mov	DWORD PTR tv205[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv205[ebp], eax
	push	111					; 0000006fH
	push	10					; 0000000aH
	push	130					; 00000082H
	mov	ecx, DWORD PTR tv205[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv205[ebp]
	mov	eax, DWORD PTR [edx+848]
	call	eax
$LN3@ConvertBar@2:

; 3912 : 		}
; 3913 : 
; 3914 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@ConvertBar@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN2@ConvertBar@2

; 3915 : 		{
; 3916 : 			CvString logMsg;

	lea	ecx, DWORD PTR _logMsg$223662[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3917 : 			logMsg.Format("Converted barbarian naval unit, X: %d, Y: %d", pUnit->getX(), pUnit->getY());

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239697[ebp], eax
	mov	ecx, DWORD PTR $T239697[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T239706[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239710[ebp], eax
	mov	ecx, DWORD PTR $T239710[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T239719[ebp], edx
	mov	eax, DWORD PTR $T239706[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239719[ebp]
	push	ecx
	push	OFFSET ??_C@_0CN@NMHBHDNM@Converted?5barbarian?5naval?5unit?0?5@
	lea	edx, DWORD PTR _logMsg$223662[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3918 : 			m_pPlayer->GetHomelandAI()->LogHomelandMessage(logMsg);

	lea	eax, DWORD PTR _logMsg$223662[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 3919 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _logMsg$223662[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@ConvertBar@2:

; 3920 : 
; 3921 : 		CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_BARB_NAVAL_UNIT_CONVERTS");

	push	OFFSET ??_C@_0CO@DCHLJAOF@TXT_KEY_NOTIFICATION_BARB_NAVAL_@
	lea	edx, DWORD PTR _strBuffer$223664[ebp]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3922 : 		CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_BARB_NAVAL_UNIT_CONVERTS");

	push	OFFSET ??_C@_0DG@DAOILMDG@TXT_KEY_NOTIFICATION_SUMMARY_BAR@
	lea	eax, DWORD PTR _strSummary$223667[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3923 : 		m_pPlayer->GetNotifications()->Add(NOTIFICATION_GENERIC, strBuffer, strSummary, pUnit->getX(), pUnit->getY(), -1);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239727[ebp], ecx
	mov	edx, DWORD PTR $T239727[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T239736[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T239740[ebp], ecx
	mov	edx, DWORD PTR $T239740[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T239749[ebp], eax
	lea	ecx, DWORD PTR _strSummary$223667[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239753[ebp], eax
	lea	ecx, DWORD PTR _strBuffer$223664[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239757[ebp], eax
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T239736[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239749[ebp]
	push	edx
	mov	eax, DWORD PTR $T239753[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239757[ebp]
	push	ecx
	push	-1097390650				; be9725c6H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	ecx, eax
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3924 : 		return true;

	mov	BYTE PTR $T239571[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strSummary$223667[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strBuffer$223664[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN112@ConvertBar@2
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN112@ConvertBar@2:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN117@ConvertBar@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN117@ConvertBar@2:
	mov	al, BYTE PTR $T239571[ebp]
	jmp	SHORT $LN6@ConvertBar@2

; 3925 : 	}
; 3926 : 
; 3927 : 	// Decided not to
; 3928 : 	else

	jmp	SHORT $LN1@ConvertBar@2

; 3929 : 	{
; 3930 : 		pUnit->SetNotConverting(true);

$LN121@ConvertBar@2:
	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?SetNotConverting@CvUnit@@QAEX_N@Z	; CvUnit::SetNotConverting

; 3931 : 		return false;

	mov	BYTE PTR $T239572[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN124@ConvertBar@2
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN124@ConvertBar@2:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN129@ConvertBar@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN129@ConvertBar@2:
	mov	al, BYTE PTR $T239572[ebp]
	jmp	SHORT $LN6@ConvertBar@2
$LN1@ConvertBar@2:

; 3932 : 	}
; 3933 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pGiftUnit$[ebp], 0
	je	SHORT $LN134@ConvertBar@2
	mov	ecx, DWORD PTR _pGiftUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN134@ConvertBar@2:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN6@ConvertBar@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@ConvertBar@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _pGiftUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR _logMsg$223662[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _strBuffer$223664[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z$4:
	lea	ecx, DWORD PTR _strSummary$223667[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ConvertBarbarianNavalUnit@CvPlayerTraits@@AAE_NV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvPlayerTraits::ConvertBarbarianNavalUnit
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
PUBLIC	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$1
__ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
_TEXT	SEGMENT
tv159 = -240						; size = 4
tv184 = -236						; size = 4
tv134 = -232						; size = 4
_this$ = -228						; size = 4
$T239891 = -52						; size = 4
$T239876 = -46						; size = 1
$T239863 = -45						; size = 1
$T239859 = -44						; size = 4
$T239852 = -36						; size = 4
$T239842 = -25						; size = 1
$T239838 = -24						; size = 4
$T239832 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Val$ = 12						; size = 1
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1918 : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T239842[ebp]
	mov	DWORD PTR $T239838[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	movzx	eax, BYTE PTR __Val$[ebp]
	neg	eax
	sbb	eax, eax
	mov	DWORD PTR $T239832[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T239891[ebp], ecx
	lea	edx, DWORD PTR $T239876[ebp]
	mov	DWORD PTR $T239852[ebp], edx
	lea	eax, DWORD PTR $T239863[ebp]
	mov	DWORD PTR $T239859[ebp], eax
	mov	ecx, DWORD PTR $T239891[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	mov	edx, DWORD PTR $T239891[ebp]
	mov	DWORD PTR tv159[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR $T239832[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	add	ecx, 31					; 0000001fH
	shr	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR $T239891[ebp]
	call	?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1919 : 		_Trim(_Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 1920 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$2:
	mov	ecx, DWORD PTR $T239891[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@I_N@Z ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z
_TEXT	SEGMENT
_this$ = -428						; size = 4
__Tmp$240405 = -236					; size = 8
$T240383 = -228						; size = 4
$T240361 = -224						; size = 4
$T240386 = -220						; size = 4
$T240295 = -192						; size = 4
$T240165 = -96						; size = 4
$T240107 = -68						; size = 4
$T240103 = -64						; size = 8
$T240102 = -56						; size = 8
$T240101 = -48						; size = 8
$T240100 = -40						; size = 8
$T240099 = -32						; size = 8
$T240098 = -24						; size = 8
$T240097 = -16						; size = 8
$T240096 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z PROC ; std::vector<bool,std::allocator<bool> >::resize, COMDAT
; _this$ = ecx

; 2039 : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	mov	DWORD PTR _this$[ebp], ecx

; 2040 : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240107[ebp], ecx
	mov	edx, DWORD PTR $T240107[ebp]
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize

; 2041 : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T240097[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240096[ebp], ecx
	mov	DWORD PTR $T240096[ebp+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240165[ebp], ecx
	movzx	edx, BYTE PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	sub	eax, DWORD PTR $T240165[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240096[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T240096[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
	jmp	$LN4@resize
$LN3@resize:

; 2042 : 		else if (_Newsize < size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240295[ebp], ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	cmp	edx, DWORD PTR $T240295[ebp]
	jae	$LN4@resize

; 2043 : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR $T240099[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240098[ebp], ecx
	mov	DWORD PTR $T240098[ebp+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240361[ebp], ecx
	mov	edx, DWORD PTR $T240361[ebp]
	mov	DWORD PTR $T240386[ebp], edx
	mov	eax, DWORD PTR $T240386[ebp]
	mov	DWORD PTR $T240383[ebp], eax
	mov	ecx, DWORD PTR $T240383[ebp]
	mov	DWORD PTR $T240101[ebp], ecx
	mov	DWORD PTR $T240101[ebp+4], 0
	mov	edx, DWORD PTR $T240101[ebp]
	mov	eax, DWORD PTR $T240101[ebp+4]
	mov	DWORD PTR __Tmp$240405[ebp], edx
	mov	DWORD PTR __Tmp$240405[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$240405[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$240405[ebp]
	mov	eax, DWORD PTR __Tmp$240405[ebp+4]
	mov	DWORD PTR $T240102[ebp], edx
	mov	DWORD PTR $T240102[ebp+4], eax
	mov	ecx, DWORD PTR $T240102[ebp]
	mov	edx, DWORD PTR $T240102[ebp+4]
	mov	DWORD PTR $T240100[ebp], ecx
	mov	DWORD PTR $T240100[ebp+4], edx
	mov	eax, DWORD PTR $T240098[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T240098[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240100[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T240100[ebp]
	push	eax
	lea	ecx, DWORD PTR $T240103[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
$LN4@resize:

; 2044 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T240694 = -44						; size = 4
$T240693 = -40						; size = 4
__Tmp$240687 = -36					; size = 8
$T240662 = -28						; size = 4
$T240640 = -24						; size = 4
$T240677 = -20						; size = 4
$T240628 = -16						; size = 8
$T240627 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2090 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2091 : 		return (*(begin() + _Off));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240640[ebp], ecx
	mov	edx, DWORD PTR $T240640[ebp]
	mov	DWORD PTR $T240677[ebp], edx
	mov	eax, DWORD PTR $T240677[ebp]
	mov	DWORD PTR $T240662[ebp], eax
	mov	ecx, DWORD PTR $T240662[ebp]
	mov	DWORD PTR $T240627[ebp], ecx
	mov	DWORD PTR $T240627[ebp+4], 0
	mov	edx, DWORD PTR $T240627[ebp]
	mov	eax, DWORD PTR $T240627[ebp+4]
	mov	DWORD PTR __Tmp$240687[ebp], edx
	mov	DWORD PTR __Tmp$240687[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$240687[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$240687[ebp]
	mov	eax, DWORD PTR __Tmp$240687[ebp+4]
	mov	DWORD PTR $T240628[ebp], edx
	mov	DWORD PTR $T240628[ebp+4], eax
	mov	ecx, DWORD PTR $T240628[ebp+4]
	mov	DWORD PTR $T240694[ebp], ecx
	mov	edx, DWORD PTR $T240628[ebp]
	mov	DWORD PTR $T240693[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T240693[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T240694[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2092 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv224 = -308						; size = 4
_this$ = -304						; size = 4
$T240983 = -300						; size = 4
$T240982 = -296						; size = 4
$T240981 = -292						; size = 4
$T240927 = -176						; size = 4
$T240923 = -172						; size = 4
$T240922 = -168						; size = 4
$T240918 = -164						; size = 4
$T240917 = -160						; size = 4
$T240906 = -156						; size = 4
$T240905 = -152						; size = 4
__Cat$240913 = -146					; size = 1
$T240911 = -145						; size = 1
$T240886 = -144						; size = 4
$T240885 = -140						; size = 4
$T240833 = -84						; size = 4
$T240826 = -80						; size = 4
$T240815 = -76						; size = 4
$T240814 = -72						; size = 4
__Cat$240822 = -68					; size = 1
$T240820 = -67						; size = 1
$T240770 = -40						; size = 4
$T240741 = -36						; size = 4
$T240725 = -32						; size = 4
$T240753 = -28						; size = 4
$T240752 = -24						; size = 4
$T240751 = -20						; size = 4
$T240750 = -16						; size = 4
$T240749 = -12						; size = 4
__Ptr$223718 = -8					; size = 4
__Ptr$223715 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240725[ebp], edx
	mov	eax, DWORD PTR $T240725[ebp]
	mov	DWORD PTR $T240750[ebp], eax
	mov	ecx, DWORD PTR $T240750[ebp]
	mov	DWORD PTR $T240749[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240741[ebp], eax
	mov	ecx, DWORD PTR $T240741[ebp]
	mov	DWORD PTR $T240752[ebp], ecx
	mov	edx, DWORD PTR $T240752[ebp]
	mov	DWORD PTR $T240751[ebp], edx
	mov	eax, DWORD PTR $T240749[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240751[ebp]
	push	ecx
	lea	edx, DWORD PTR $T240753[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator
$LN8@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T240770[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR $T240770[ebp], edx
	ja	SHORT $LN6@operator

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$223715[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240826[ebp], ecx
	mov	edx, DWORD PTR $T240826[ebp]
	mov	DWORD PTR $T240815[ebp], edx
	mov	eax, DWORD PTR __Ptr$223715[ebp]
	mov	DWORD PTR $T240814[ebp], eax
	mov	cl, BYTE PTR __Cat$240822[ebp]
	mov	BYTE PTR $T240820[ebp], cl

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	$LN9@operator
$LN6@operator:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T240833[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN55@operator
	mov	DWORD PTR tv224[ebp], 0
	jmp	SHORT $LN53@operator
$LN55@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv224[ebp], eax
$LN53@operator:
	mov	ecx, DWORD PTR $T240833[ebp]
	cmp	ecx, DWORD PTR tv224[ebp]
	ja	$LN4@operator

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR __Ptr$223718[ebp], ecx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Ptr$223718[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240886[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240885[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240886[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240885[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$223718[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator
$LN4@operator:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN2@operator

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240918[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240917[ebp], eax
	mov	ecx, DWORD PTR $T240918[ebp]
	mov	DWORD PTR $T240906[ebp], ecx
	mov	edx, DWORD PTR $T240917[ebp]
	mov	DWORD PTR $T240905[ebp], edx
	mov	al, BYTE PTR __Cat$240913[ebp]
	mov	BYTE PTR $T240911[ebp], al

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T240923[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240922[ebp], edx
	mov	eax, DWORD PTR $T240922[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T240927[ebp], eax
	mov	ecx, DWORD PTR $T240927[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@operator

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240983[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240982[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240981[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240983[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240982[ebp]
	push	edx
	mov	eax, DWORD PTR $T240981[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@operator:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv137 = -192						; size = 4
tv163 = -188						; size = 4
tv189 = -184						; size = 4
_this$ = -180						; size = 4
$T241052 = -46						; size = 1
$T241034 = -45						; size = 1
$T241023 = -44						; size = 4
$T241044 = -40						; size = 4
$T241016 = -36						; size = 4
$T241006 = -28						; size = 4
$T240992 = -21						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T241052[ebp]
	mov	DWORD PTR $T241006[ebp], eax
	lea	ecx, DWORD PTR $T241034[ebp]
	mov	DWORD PTR $T241016[ebp], ecx
	push	ecx
	mov	edx, esp
	mov	DWORD PTR $T241044[ebp], esp
	mov	DWORD PTR $T241023[ebp], edx
	lea	eax, DWORD PTR $T240992[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
; Function compile flags: /Odtp
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
tv93 = -48						; size = 4
_this$ = -44						; size = 4
$T241514 = -40						; size = 4
$T241493 = -36						; size = 4
$T241482 = -32						; size = 4
$T241473 = -28						; size = 4
$T241433 = -16						; size = 4
$T241431 = -12						; size = 4
$T241430 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
	mov	DWORD PTR $T241473[ebp], eax
	mov	ecx, DWORD PTR $T241473[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241482[ebp], eax
	mov	ecx, DWORD PTR $T241482[ebp]
	mov	DWORD PTR $T241431[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T241431[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241493[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T241493[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN4@find
$LN3@find:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241514[ebp], ecx
	mov	edx, DWORD PTR $T241514[ebp]
	mov	DWORD PTR $T241433[ebp], edx
	lea	eax, DWORD PTR $T241433[ebp]
	mov	DWORD PTR tv93[ebp], eax
$LN4@find:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T241430[ebp], ecx
	mov	edx, DWORD PTR $T241430[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$1
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T241571 = -52						; size = 4
$T241570 = -48						; size = 4
__Tmp$241568 = -44					; size = 4
$T241564 = -40						; size = 4
$T241563 = -36						; size = 4
__Tmp$241561 = -32					; size = 4
__Tmp$223846 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN16@swap
	jmp	$LN5@swap

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())

$LN16@swap:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN31@swap

; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	mov	DWORD PTR $T241564[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T241563[ebp], ecx
	mov	edx, DWORD PTR $T241563[ebp]
	cmp	edx, DWORD PTR $T241564[ebp]
	je	SHORT $LN26@swap
	mov	eax, DWORD PTR $T241563[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$241561[ebp], ecx
	mov	edx, DWORD PTR $T241563[ebp]
	mov	eax, DWORD PTR $T241564[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T241564[ebp]
	mov	eax, DWORD PTR __Tmp$241561[ebp]
	mov	DWORD PTR [edx], eax
$LN26@swap:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T241571[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T241570[ebp], edx
	mov	eax, DWORD PTR $T241570[ebp]
	cmp	eax, DWORD PTR $T241571[ebp]
	je	SHORT $LN29@swap
	mov	ecx, DWORD PTR $T241570[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$241568[ebp], edx
	mov	eax, DWORD PTR $T241570[ebp]
	mov	ecx, DWORD PTR $T241571[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T241571[ebp]
	mov	ecx, DWORD PTR __Tmp$241568[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@swap:

; 1048 : 			}
; 1049 : 		else

	jmp	SHORT $LN5@swap

; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);

$LN31@swap:

; 1052 : 
; 1053 : 			_Myt _Tmp = *this;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$223846[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1054 : 
; 1055 : 			*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=

; 1056 : 			_Right = _Tmp;

	lea	ecx, DWORD PTR __Tmp$223846[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=

; 1057 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Tmp$223846[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN5@swap:

; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$0:
	lea	ecx, DWORD PTR __Tmp$223846[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$1:
	lea	ecx, DWORD PTR __Tmp$223846[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T242754 = -30						; size = 1
$T242741 = -29						; size = 1
$T242737 = -28						; size = 4
$T242730 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T242754[ebp]
	mov	DWORD PTR $T242730[ebp], eax
	lea	ecx, DWORD PTR $T242741[ebp]
	mov	DWORD PTR $T242737[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >
PUBLIC	?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::insert
PUBLIC	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T242939 = -32						; size = 4
$T242929 = -28						; size = 4
$T242919 = -24						; size = 4
__Cat$242928 = -19					; size = 1
$T242925 = -18						; size = 1
$T242924 = -17						; size = 1
$T242896 = -16						; size = 4
$T242892 = -12						; size = 4
$T242891 = -8						; size = 4
$T242890 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR $T242896[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T242896[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T242929[ebp], eax
	mov	ecx, DWORD PTR $T242929[ebp]
	mov	DWORD PTR $T242919[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T242924[ebp], dl
	mov	al, BYTE PTR __Cat$242928[ebp]
	mov	BYTE PTR $T242925[ebp], al
	movzx	ecx, BYTE PTR $T242924[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T242925[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T242919[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 3
	add	eax, DWORD PTR $T242929[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T242939[ebp], eax
	mov	ecx, DWORD PTR $T242939[ebp]
	mov	DWORD PTR $T242891[ebp], ecx
	mov	edx, DWORD PTR $T242891[ebp]
	mov	DWORD PTR $T242890[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242890[ebp]
	push	ecx
	lea	edx, DWORD PTR $T242892[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAEXABUFreeResourceXCities@@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >
PUBLIC	?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T243092 = -30						; size = 1
$T243079 = -29						; size = 1
$T243075 = -28						; size = 4
$T243068 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::vector<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T243092[ebp]
	mov	DWORD PTR $T243068[ebp], eax
	lea	ecx, DWORD PTR $T243079[ebp]
	mov	DWORD PTR $T243075[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::vector<enum TraitTypes,std::allocator<enum TraitTypes> >
PUBLIC	?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::insert
PUBLIC	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T243191 = -32						; size = 4
$T243181 = -28						; size = 4
$T243171 = -24						; size = 4
__Cat$243179 = -19					; size = 1
$T243177 = -18						; size = 1
$T243176 = -17						; size = 1
$T243148 = -16						; size = 4
$T243144 = -12						; size = 4
$T243143 = -8						; size = 4
$T243142 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T243148[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@2
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@2:
	mov	ecx, DWORD PTR $T243148[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243181[ebp], eax
	mov	ecx, DWORD PTR $T243181[ebp]
	mov	DWORD PTR $T243171[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243176[ebp], dl
	mov	al, BYTE PTR __Cat$243179[ebp]
	mov	BYTE PTR $T243177[ebp], al
	movzx	ecx, BYTE PTR $T243176[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T243177[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T243171[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T243181[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243191[ebp], eax
	mov	ecx, DWORD PTR $T243191[ebp]
	mov	DWORD PTR $T243143[ebp], ecx
	mov	edx, DWORD PTR $T243143[ebp]
	mov	DWORD PTR $T243142[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243142[ebp]
	push	ecx
	lea	edx, DWORD PTR $T243144[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::insert
$LN3@push_back@2:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAEXABW4TraitTypes@@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ	; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T243269 = -20						; size = 4
_pRet$243265 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::FStaticVector<FreeTraitUnit,5,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 5

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243269[ebp], edx
	cmp	DWORD PTR $T243269[ebp], 5
	jbe	SHORT $LN7@FStaticVec@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T243269[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$243265[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T243269[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@2
$LN7@FStaticVec@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$243265[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 5
$LN8@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$243265[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ ; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>
__ehhandler$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::FStaticVector<FreeTraitUnit,5,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T243300 = -24						; size = 4
$T243299 = -20						; size = 4
_i$243294 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243300[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T243299[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@3
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@3
	mov	DWORD PTR _i$243294[ebp], 0
	jmp	SHORT $LN10@FStaticVec@3
$LN9@FStaticVec@3:
	mov	eax, DWORD PTR _i$243294[ebp]
	add	eax, 1
	mov	DWORD PTR _i$243294[ebp], eax
$LN10@FStaticVec@3:
	mov	ecx, DWORD PTR _i$243294[ebp]
	cmp	ecx, DWORD PTR $T243300[ebp]
	jae	SHORT $LN5@FStaticVec@3
	jmp	SHORT $LN9@FStaticVec@3
$LN5@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T243299[ebp], edx
	je	SHORT $LN1@FStaticVec@3
	mov	eax, DWORD PTR $T243299[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@3:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ ; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>
__ehhandler$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::~FStaticVector<FreeTraitUnit,5,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T243312 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+52], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243312[ebp], ecx
	cmp	DWORD PTR $T243312[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T243312[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T243312[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@QAEIABUFreeTraitUnit@@@Z ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T243385 = -30						; size = 1
$T243372 = -29						; size = 1
$T243368 = -28						; size = 4
$T243361 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T243385[ebp]
	mov	DWORD PTR $T243361[ebp], eax
	lea	ecx, DWORD PTR $T243372[ebp]
	mov	DWORD PTR $T243368[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >
PUBLIC	?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::insert
PUBLIC	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T243570 = -32						; size = 4
$T243560 = -28						; size = 4
$T243550 = -24						; size = 4
__Cat$243559 = -19					; size = 1
$T243556 = -18						; size = 1
$T243555 = -17						; size = 1
$T243527 = -16						; size = 4
$T243523 = -12						; size = 4
$T243522 = -8						; size = 4
$T243521 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR $T243527[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@4
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@4
$LN9@push_back@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@4:
	mov	ecx, DWORD PTR $T243527[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243560[ebp], eax
	mov	ecx, DWORD PTR $T243560[ebp]
	mov	DWORD PTR $T243550[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243555[ebp], dl
	mov	al, BYTE PTR __Cat$243559[ebp]
	mov	BYTE PTR $T243556[ebp], al
	movzx	ecx, BYTE PTR $T243555[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T243556[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T243550[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 3
	add	eax, DWORD PTR $T243560[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@4
$LN2@push_back@4:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243570[ebp], eax
	mov	ecx, DWORD PTR $T243570[ebp]
	mov	DWORD PTR $T243522[ebp], ecx
	mov	edx, DWORD PTR $T243522[ebp]
	mov	DWORD PTR $T243521[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243521[ebp]
	push	ecx
	lea	edx, DWORD PTR $T243523[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::insert
$LN3@push_back@4:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAEXABUMayaBonusChoice@@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >::~_Vector_val<FreeResourceXCities,std::allocator<FreeResourceXCities> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >::~_Vector_val<CvTraitEntry *,std::allocator<CvTraitEntry *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >::~_Vector_val<MayaBonusChoice,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
__Tmp$243766 = -48					; size = 4
$T243744 = -44						; size = 4
$T243728 = -40						; size = 4
$T243706 = -36						; size = 4
$T243693 = -32						; size = 4
$T243692 = -28						; size = 4
$T243691 = -24						; size = 4
$T243690 = -20						; size = 4
$T243689 = -16						; size = 4
$T243688 = -12						; size = 4
$T243687 = -8						; size = 4
$T243686 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN16@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243706[ebp], ecx
	mov	edx, DWORD PTR $T243706[ebp]
	mov	DWORD PTR $T243687[ebp], edx
	mov	eax, DWORD PTR $T243687[ebp]
	mov	DWORD PTR $T243686[ebp], eax
	lea	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR $T243686[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN4@resize@2

; 720  : 		else if (_Newsize < size())

$LN16@resize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243728[ebp], edx
	mov	eax, DWORD PTR $T243728[ebp]
	mov	DWORD PTR $T243689[ebp], eax
	mov	ecx, DWORD PTR $T243689[ebp]
	mov	DWORD PTR $T243688[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243744[ebp], eax
	mov	ecx, DWORD PTR $T243744[ebp]
	mov	DWORD PTR $T243691[ebp], ecx
	mov	edx, DWORD PTR $T243691[ebp]
	mov	DWORD PTR __Tmp$243766[ebp], edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Tmp$243766[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$243766[ebp], edx
	mov	eax, DWORD PTR __Tmp$243766[ebp]
	mov	DWORD PTR $T243692[ebp], eax
	mov	ecx, DWORD PTR $T243692[ebp]
	mov	DWORD PTR $T243690[ebp], ecx
	mov	edx, DWORD PTR $T243688[ebp]
	push	edx
	mov	eax, DWORD PTR $T243690[ebp]
	push	eax
	lea	ecx, DWORD PTR $T243693[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN4@resize@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
__Tmp$243941 = -48					; size = 4
$T243919 = -44						; size = 4
$T243903 = -40						; size = 4
$T243881 = -36						; size = 4
$T243868 = -32						; size = 4
$T243867 = -28						; size = 4
$T243866 = -24						; size = 4
$T243865 = -20						; size = 4
$T243864 = -16						; size = 4
$T243863 = -12						; size = 4
$T243862 = -8						; size = 4
$T243861 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 24
?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN16@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243881[ebp], eax
	mov	ecx, DWORD PTR $T243881[ebp]
	mov	DWORD PTR $T243862[ebp], ecx
	mov	edx, DWORD PTR $T243862[ebp]
	mov	DWORD PTR $T243861[ebp], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR $T243861[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n
	jmp	SHORT $LN4@resize@3

; 720  : 		else if (_Newsize < size())

$LN16@resize@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@3

; 721  : 			erase(begin() + _Newsize, end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243903[ebp], eax
	mov	ecx, DWORD PTR $T243903[ebp]
	mov	DWORD PTR $T243864[ebp], ecx
	mov	edx, DWORD PTR $T243864[ebp]
	mov	DWORD PTR $T243863[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243919[ebp], ecx
	mov	edx, DWORD PTR $T243919[ebp]
	mov	DWORD PTR $T243866[ebp], edx
	mov	eax, DWORD PTR $T243866[ebp]
	mov	DWORD PTR __Tmp$243941[ebp], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Tmp$243941[ebp]
	mov	DWORD PTR __Tmp$243941[ebp], ecx
	mov	edx, DWORD PTR __Tmp$243941[ebp]
	mov	DWORD PTR $T243867[ebp], edx
	mov	eax, DWORD PTR $T243867[ebp]
	mov	DWORD PTR $T243865[ebp], eax
	mov	ecx, DWORD PTR $T243863[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243865[ebp]
	push	edx
	lea	eax, DWORD PTR $T243868[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase
$LN4@resize@3:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?resize@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXIV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::resize
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T244159 = -47						; size = 1
$T244134 = -46						; size = 1
$T244116 = -45						; size = 1
$T244105 = -44						; size = 4
$T244148 = -40						; size = 4
$T244098 = -36						; size = 4
$T244091 = -28						; size = 4
$T244084 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T244159[ebp]
	mov	DWORD PTR $T244084[ebp], eax
	lea	ecx, DWORD PTR $T244134[ebp]
	mov	DWORD PTR $T244091[ebp], ecx
	lea	edx, DWORD PTR $T244116[ebp]
	mov	DWORD PTR $T244098[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T244148[ebp], esp
	mov	DWORD PTR $T244105[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T244236 = -32						; size = 4
$T244223 = -28						; size = 4
$T244211 = -24						; size = 4
$T244201 = -20						; size = 4
$T244200 = -16						; size = 4
$T244199 = -12						; size = 4
$T244198 = -8						; size = 4
$T244197 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@2

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244211[ebp], edx
	mov	eax, DWORD PTR $T244211[ebp]
	mov	DWORD PTR $T244198[ebp], eax
	mov	ecx, DWORD PTR $T244198[ebp]
	mov	DWORD PTR $T244197[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244223[ebp], eax
	mov	ecx, DWORD PTR $T244223[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T244236[ebp], edx
	mov	eax, DWORD PTR $T244236[ebp]
	mov	DWORD PTR $T244200[ebp], eax
	mov	ecx, DWORD PTR $T244200[ebp]
	mov	DWORD PTR $T244199[ebp], ecx
	mov	edx, DWORD PTR $T244197[ebp]
	push	edx
	mov	eax, DWORD PTR $T244199[ebp]
	push	eax
	lea	ecx, DWORD PTR $T244201[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
$LN1@operator@2:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T244663 = -148						; size = 4
$T244643 = -144						; size = 4
$T244628 = -140						; size = 4
$T244611 = -136						; size = 4
$T244598 = -132						; size = 4
$T244584 = -128						; size = 4
$T244540 = -45						; size = 1
$T244539 = -44						; size = 4
$T244538 = -37						; size = 1
$T244537 = -36						; size = 4
$T244536 = -29						; size = 1
$T244535 = -28						; size = 4
$T244534 = -24						; size = 4
$T244533 = -17						; size = 1
__Where$224304 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN9@insert

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert
$LN33@insert:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert
$LN9@insert:

; 641  : 
; 642  : 		if (this->_Multi)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN8@insert

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T244533[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T244534[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	DWORD PTR $T244584[ebp], eax
	mov	edx, DWORD PTR $T244584[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T244533[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 644  : 		else

	jmp	$LN11@insert
$LN8@insert:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$224304[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert
	jmp	$LN79@insert
$LN6@insert:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244598[ebp], ecx
	mov	edx, DWORD PTR $T244598[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244611[ebp], eax
	mov	ecx, DWORD PTR $T244611[ebp]
	mov	DWORD PTR $T244535[ebp], ecx
	mov	edx, DWORD PTR __Where$224304[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T244535[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T244536[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T244537[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	DWORD PTR $T244628[ebp], eax
	mov	edx, DWORD PTR $T244628[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T244536[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 651  : 			else

	jmp	SHORT $LN79@insert
$LN4@insert:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$224304[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert:
	mov	ecx, DWORD PTR __Where$224304[ebp]
	mov	DWORD PTR $T244643[ebp], ecx
	mov	edx, DWORD PTR $T244643[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T244538[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T244539[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	DWORD PTR $T244663[ebp], eax
	mov	edx, DWORD PTR $T244663[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T244538[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert

; 657  : 			else

	jmp	SHORT $LN11@insert
$LN2@insert:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T244540[ebp], 0
	mov	ecx, DWORD PTR __Where$224304[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T244540[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T244784 = -40						; size = 4
$T244771 = -36						; size = 4
$T244750 = -32						; size = 4
$T244737 = -28						; size = 4
$T244732 = -24						; size = 4
$T244711 = -20						; size = 4
$T244699 = -16						; size = 4
$T244690 = -12						; size = 4
$T244686 = -8						; size = 4
$T244677 = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T244677[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T244686[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T244677[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	edx, DWORD PTR $T244686[ebp]
	mov	DWORD PTR [edx], eax

; 1064 : 		_Mysize = _Right.size();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244690[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T244690[ebp]
	mov	DWORD PTR [edx+8], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T244699[ebp], edx
	mov	eax, DWORD PTR $T244699[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN2@Copy

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T244711[ebp], ecx
	mov	edx, DWORD PTR $T244711[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244732[ebp], eax
$LN31@Copy:
	mov	ecx, DWORD PTR $T244732[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN27@Copy
	mov	ecx, DWORD PTR $T244732[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T244732[ebp], edx
	jmp	SHORT $LN31@Copy
$LN27@Copy:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244737[ebp], ecx
	mov	edx, DWORD PTR $T244737[ebp]
	mov	eax, DWORD PTR $T244732[ebp]
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T244750[ebp], edx
	mov	eax, DWORD PTR $T244750[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T244771[ebp], ecx
$LN49@Copy:
	mov	edx, DWORD PTR $T244771[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN53@Copy
	mov	edx, DWORD PTR $T244771[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244771[ebp], eax
	jmp	SHORT $LN49@Copy
$LN53@Copy:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T244771[ebp]
	mov	DWORD PTR [edx+8], eax

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244784[ebp], edx
	mov	eax, DWORD PTR $T244784[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN3@Copy:

; 1072 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T244814 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244814[ebp], eax
	mov	ecx, DWORD PTR $T244814[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound, COMDAT
; _this$ = ecx

; 1349 : 		{	// find leftmost node greater than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1350 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1351 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1352 : 
; 1353 : 		while (!_Isnil(_Pnode))

$LN11@Ubound:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN3@Ubound

; 1354 : 			if (_DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	mov	ecx, DWORD PTR __Keyval$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN23@Ubound

; 1355 : 				{	// _Pnode greater than _Keyval, remember it
; 1356 : 				_Wherenode = _Pnode;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1357 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1358 : 				}
; 1359 : 			else

	jmp	SHORT $LN1@Ubound

; 1360 : 				_Pnode = _Right(_Pnode);	// descend right subtree

$LN23@Ubound:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Ubound:
	jmp	SHORT $LN11@Ubound
$LN3@Ubound:

; 1361 : 
; 1362 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1363 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T245104 = -88						; size = 4
$T245070 = -84						; size = 4
$T244903 = -32						; size = 4
$T244890 = -28						; size = 4
$T244878 = -24						; size = 4
$T244868 = -20						; size = 4
$T244867 = -16						; size = 4
$T244866 = -12						; size = 4
$T244865 = -8						; size = 4
$T244864 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244878[ebp], ecx
	mov	edx, DWORD PTR $T244878[ebp]
	mov	DWORD PTR $T244865[ebp], edx
	mov	eax, DWORD PTR $T244865[ebp]
	mov	DWORD PTR $T244864[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244890[ebp], edx
	mov	eax, DWORD PTR $T244890[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T244903[ebp], ecx
	mov	edx, DWORD PTR $T244903[ebp]
	mov	DWORD PTR $T244867[ebp], edx
	mov	eax, DWORD PTR $T244867[ebp]
	mov	DWORD PTR $T244866[ebp], eax
	mov	ecx, DWORD PTR $T244864[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244866[ebp]
	push	edx
	lea	eax, DWORD PTR $T244868[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245070[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245104[ebp], ecx
	mov	edx, DWORD PTR $T245104[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$245164 = -24					; size = 4
$T245142 = -20						; size = 4
$T245123 = -16						; size = 4
$T245110 = -12						; size = 4
$T245107 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	test	edx, edx
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245123[ebp], ecx
	mov	edx, DWORD PTR $T245123[ebp]
	mov	DWORD PTR $T245107[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T245107[ebp]
	sar	eax, 3
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245142[ebp], edx
	mov	eax, DWORD PTR $T245142[ebp]
	mov	DWORD PTR $T245110[ebp], eax
	mov	ecx, DWORD PTR $T245110[ebp]
	mov	DWORD PTR __Tmp$245164[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$245164[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$245164[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245164[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@ABUFreeResourceXCities@@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T245306 = -64						; size = 4
$T245288 = -60						; size = 4
$T245287 = -56						; size = 4
$T245271 = -52						; size = 4
__Cat$245296 = -46					; size = 1
$T245293 = -45						; size = 1
$T245245 = -44						; size = 4
$T245244 = -40						; size = 4
$T245243 = -36						; size = 4
$T245226 = -30						; size = 1
$T245225 = -29						; size = 1
$T245224 = -28						; size = 4
$T245223 = -24						; size = 4
__Cat$245234 = -16					; size = 1
$T245231 = -15						; size = 1
$T245230 = -14						; size = 1
$T245229 = -13						; size = 1
__Ptr$224383 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245245[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245244[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T245243[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245229[ebp], cl
	mov	dl, BYTE PTR __Cat$245234[ebp]
	mov	BYTE PTR $T245230[ebp], dl
	mov	al, BYTE PTR $T245229[ebp]
	mov	BYTE PTR $T245226[ebp], al
	mov	cl, BYTE PTR $T245231[ebp]
	mov	BYTE PTR $T245225[ebp], cl
	mov	edx, DWORD PTR $T245245[ebp]
	mov	DWORD PTR $T245224[ebp], edx
	mov	eax, DWORD PTR $T245243[ebp]
	mov	DWORD PTR $T245223[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T245224[ebp]
	add	ecx, 8
	mov	DWORD PTR $T245224[ebp], ecx
	mov	edx, DWORD PTR $T245223[ebp]
	add	edx, 8
	mov	DWORD PTR $T245223[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T245223[ebp]
	cmp	eax, DWORD PTR $T245244[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T245223[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T245224[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	edx, DWORD PTR $T245224[ebp]
	mov	DWORD PTR __Ptr$224383[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245306[ebp], ecx
	mov	edx, DWORD PTR $T245306[ebp]
	mov	DWORD PTR $T245288[ebp], edx
	mov	eax, DWORD PTR __Ptr$224383[ebp]
	mov	DWORD PTR $T245287[ebp], eax
	mov	cl, BYTE PTR __Cat$245296[ebp]
	mov	BYTE PTR $T245293[ebp], cl
	mov	edx, DWORD PTR $T245287[ebp]
	mov	DWORD PTR $T245271[ebp], edx
	jmp	SHORT $LN39@erase
$LN38@erase:
	mov	eax, DWORD PTR $T245271[ebp]
	add	eax, 8
	mov	DWORD PTR $T245271[ebp], eax
$LN39@erase:
	mov	ecx, DWORD PTR $T245271[ebp]
	cmp	ecx, DWORD PTR $T245288[ebp]
	je	SHORT $LN31@erase
	jmp	SHORT $LN38@erase
$LN31@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$224383[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@QAE?AV?$_Vector_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@V?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@0@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ; std::_Allocate<FreeResourceXCities>
PUBLIC	?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$245324 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$245324[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$245324[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$245324[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ; std::_Allocate<FreeResourceXCities>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T245417 = -32						; size = 4
$T245416 = -28						; size = 4
$T245412 = -24						; size = 4
$T245411 = -20						; size = 4
$T245393 = -16						; size = 4
$T245392 = -12						; size = 4
$T245376 = -8						; size = 4
__Cat$245401 = -2					; size = 1
$T245398 = -1						; size = 1
?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245412[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245411[ebp], ecx
	mov	edx, DWORD PTR $T245412[ebp]
	mov	DWORD PTR $T245393[ebp], edx
	mov	eax, DWORD PTR $T245411[ebp]
	mov	DWORD PTR $T245392[ebp], eax
	mov	cl, BYTE PTR __Cat$245401[ebp]
	mov	BYTE PTR $T245398[ebp], cl
	mov	edx, DWORD PTR $T245392[ebp]
	mov	DWORD PTR $T245376[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T245376[ebp]
	add	eax, 8
	mov	DWORD PTR $T245376[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T245376[ebp]
	cmp	ecx, DWORD PTR $T245393[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	mov	DWORD PTR $T245417[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245416[ebp], eax
	mov	ecx, DWORD PTR $T245416[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTraitEntry * *,CvTraitEntry * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T245510 = -52						; size = 4
$T245499 = -48						; size = 4
$T245498 = -44						; size = 4
__Cat$245507 = -40					; size = 1
$T245504 = -39						; size = 1
__Ptr$224428 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTraitEntry * *,CvTraitEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$224428[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245510[ebp], edx
	mov	eax, DWORD PTR $T245510[ebp]
	mov	DWORD PTR $T245499[ebp], eax
	mov	ecx, DWORD PTR __Ptr$224428[ebp]
	mov	DWORD PTR $T245498[ebp], ecx
	mov	dl, BYTE PTR __Cat$245507[ebp]
	mov	BYTE PTR $T245504[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$224428[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@2@0@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z ; std::_Allocate<CvTraitEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$245528 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$245528[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$245528[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$245528[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z ; std::_Allocate<CvTraitEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T245591 = -28						; size = 4
$T245590 = -24						; size = 4
$T245586 = -20						; size = 4
$T245585 = -16						; size = 4
$T245574 = -12						; size = 4
$T245573 = -8						; size = 4
__Cat$245582 = -2					; size = 1
$T245579 = -1						; size = 1
?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245586[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245585[ebp], ecx
	mov	edx, DWORD PTR $T245586[ebp]
	mov	DWORD PTR $T245574[ebp], edx
	mov	eax, DWORD PTR $T245585[ebp]
	mov	DWORD PTR $T245573[ebp], eax
	mov	cl, BYTE PTR __Cat$245582[ebp]
	mov	BYTE PTR $T245579[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T245591[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245590[ebp], eax
	mov	ecx, DWORD PTR $T245590[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$245646 = -24					; size = 4
$T245629 = -20						; size = 4
$T245610 = -16						; size = 4
$T245597 = -12						; size = 4
$T245594 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245610[ebp], ecx
	mov	edx, DWORD PTR $T245610[ebp]
	mov	DWORD PTR $T245594[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T245594[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245629[ebp], edx
	mov	eax, DWORD PTR $T245629[ebp]
	mov	DWORD PTR $T245597[ebp], eax
	mov	ecx, DWORD PTR $T245597[ebp]
	mov	DWORD PTR __Tmp$245646[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$245646[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$245646[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245646[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@ABW4TraitTypes@@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T245793 = -64						; size = 4
$T245775 = -60						; size = 4
$T245774 = -56						; size = 4
$T245758 = -52						; size = 4
__Cat$245779 = -46					; size = 1
$T245777 = -45						; size = 1
$T245732 = -44						; size = 4
$T245731 = -40						; size = 4
$T245730 = -36						; size = 4
$T245713 = -30						; size = 1
$T245712 = -29						; size = 1
$T245711 = -28						; size = 4
$T245710 = -24						; size = 4
__Cat$245720 = -16					; size = 1
$T245718 = -15						; size = 1
$T245717 = -14						; size = 1
$T245716 = -13						; size = 1
__Ptr$224479 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245732[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245731[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T245730[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245716[ebp], cl
	mov	dl, BYTE PTR __Cat$245720[ebp]
	mov	BYTE PTR $T245717[ebp], dl
	mov	al, BYTE PTR $T245716[ebp]
	mov	BYTE PTR $T245713[ebp], al
	mov	cl, BYTE PTR $T245718[ebp]
	mov	BYTE PTR $T245712[ebp], cl
	mov	edx, DWORD PTR $T245732[ebp]
	mov	DWORD PTR $T245711[ebp], edx
	mov	eax, DWORD PTR $T245730[ebp]
	mov	DWORD PTR $T245710[ebp], eax
	jmp	SHORT $LN28@erase@3
$LN27@erase@3:
	mov	ecx, DWORD PTR $T245711[ebp]
	add	ecx, 4
	mov	DWORD PTR $T245711[ebp], ecx
	mov	edx, DWORD PTR $T245710[ebp]
	add	edx, 4
	mov	DWORD PTR $T245710[ebp], edx
$LN28@erase@3:
	mov	eax, DWORD PTR $T245710[ebp]
	cmp	eax, DWORD PTR $T245731[ebp]
	je	SHORT $LN20@erase@3
	mov	ecx, DWORD PTR $T245711[ebp]
	mov	edx, DWORD PTR $T245710[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN27@erase@3
$LN20@erase@3:
	mov	ecx, DWORD PTR $T245711[ebp]
	mov	DWORD PTR __Ptr$224479[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245793[ebp], eax
	mov	ecx, DWORD PTR $T245793[ebp]
	mov	DWORD PTR $T245775[ebp], ecx
	mov	edx, DWORD PTR __Ptr$224479[ebp]
	mov	DWORD PTR $T245774[ebp], edx
	mov	al, BYTE PTR __Cat$245779[ebp]
	mov	BYTE PTR $T245777[ebp], al
	mov	ecx, DWORD PTR $T245774[ebp]
	mov	DWORD PTR $T245758[ebp], ecx
	jmp	SHORT $LN39@erase@3
$LN38@erase@3:
	mov	edx, DWORD PTR $T245758[ebp]
	add	edx, 4
	mov	DWORD PTR $T245758[ebp], edx
$LN39@erase@3:
	mov	eax, DWORD PTR $T245758[ebp]
	cmp	eax, DWORD PTR $T245775[ebp]
	je	SHORT $LN31@erase@3
	jmp	SHORT $LN38@erase@3
$LN31@erase@3:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$224479[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@V?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@0@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::erase
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T245830 = -36						; size = 4
$T245829 = -32						; size = 4
_i$245822 = -28						; size = 4
$T245805 = -24						; size = 4
_pRet$245802 = -20					; size = 4
$T245796 = -16						; size = 4
_i$224515 = -12						; size = 4
_uiNewSize$224507 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$224507[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$224507[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$224507[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245805[ebp], ecx
	cmp	DWORD PTR $T245805[ebp], 5
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T245805[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$245802[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T245805[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$245802[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 5
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$245802[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$224515[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$224515[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224515[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$224515[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$224515[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T245796[ebp], ecx
	cmp	DWORD PTR $T245796[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$224515[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T245796[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T245796[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245830[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245829[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	xor	edx, edx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$245822[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	eax, DWORD PTR _i$245822[ebp]
	add	eax, 1
	mov	DWORD PTR _i$245822[ebp], eax
$LN26@GrowSize:
	mov	ecx, DWORD PTR _i$245822[ebp]
	cmp	ecx, DWORD PTR $T245830[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T245829[ebp], edx
	je	SHORT $LN22@GrowSize
	mov	eax, DWORD PTR $T245829[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+52], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UFreeTraitUnit@@$04$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<FreeTraitUnit,5,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ PROC	; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UFreeTraitUnit@@$00@@QAE@XZ ENDP	; BaseVector<FreeTraitUnit,1>::~BaseVector<FreeTraitUnit,1>
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$245893 = -24					; size = 4
$T245871 = -20						; size = 4
$T245852 = -16						; size = 4
$T245839 = -12						; size = 4
$T245836 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	test	edx, edx
	jne	SHORT $LN3@insert@4
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245852[ebp], ecx
	mov	edx, DWORD PTR $T245852[ebp]
	mov	DWORD PTR $T245836[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T245836[ebp]
	sar	eax, 3
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@4:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245871[ebp], edx
	mov	eax, DWORD PTR $T245871[ebp]
	mov	DWORD PTR $T245839[ebp], eax
	mov	ecx, DWORD PTR $T245839[ebp]
	mov	DWORD PTR __Tmp$245893[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$245893[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$245893[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245893[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@ABUMayaBonusChoice@@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T246035 = -64						; size = 4
$T246017 = -60						; size = 4
$T246016 = -56						; size = 4
$T246000 = -52						; size = 4
__Cat$246023 = -46					; size = 1
$T246020 = -45						; size = 1
$T245974 = -44						; size = 4
$T245973 = -40						; size = 4
$T245972 = -36						; size = 4
$T245955 = -30						; size = 1
$T245954 = -29						; size = 1
$T245953 = -28						; size = 4
$T245952 = -24						; size = 4
__Cat$245962 = -16					; size = 1
$T245959 = -15						; size = 1
$T245958 = -14						; size = 1
$T245957 = -13						; size = 1
__Ptr$224566 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245974[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245973[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T245972[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245957[ebp], cl
	mov	dl, BYTE PTR __Cat$245962[ebp]
	mov	BYTE PTR $T245958[ebp], dl
	mov	al, BYTE PTR $T245957[ebp]
	mov	BYTE PTR $T245955[ebp], al
	mov	cl, BYTE PTR $T245959[ebp]
	mov	BYTE PTR $T245954[ebp], cl
	mov	edx, DWORD PTR $T245974[ebp]
	mov	DWORD PTR $T245953[ebp], edx
	mov	eax, DWORD PTR $T245972[ebp]
	mov	DWORD PTR $T245952[ebp], eax
	jmp	SHORT $LN28@erase@4
$LN27@erase@4:
	mov	ecx, DWORD PTR $T245953[ebp]
	add	ecx, 8
	mov	DWORD PTR $T245953[ebp], ecx
	mov	edx, DWORD PTR $T245952[ebp]
	add	edx, 8
	mov	DWORD PTR $T245952[ebp], edx
$LN28@erase@4:
	mov	eax, DWORD PTR $T245952[ebp]
	cmp	eax, DWORD PTR $T245973[ebp]
	je	SHORT $LN20@erase@4
	mov	ecx, DWORD PTR $T245952[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T245953[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN27@erase@4
$LN20@erase@4:
	mov	edx, DWORD PTR $T245953[ebp]
	mov	DWORD PTR __Ptr$224566[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246035[ebp], ecx
	mov	edx, DWORD PTR $T246035[ebp]
	mov	DWORD PTR $T246017[ebp], edx
	mov	eax, DWORD PTR __Ptr$224566[ebp]
	mov	DWORD PTR $T246016[ebp], eax
	mov	cl, BYTE PTR __Cat$246023[ebp]
	mov	BYTE PTR $T246020[ebp], cl
	mov	edx, DWORD PTR $T246016[ebp]
	mov	DWORD PTR $T246000[ebp], edx
	jmp	SHORT $LN39@erase@4
$LN38@erase@4:
	mov	eax, DWORD PTR $T246000[ebp]
	add	eax, 8
	mov	DWORD PTR $T246000[ebp], eax
$LN39@erase@4:
	mov	ecx, DWORD PTR $T246000[ebp]
	cmp	ecx, DWORD PTR $T246017[ebp]
	je	SHORT $LN31@erase@4
	jmp	SHORT $LN38@erase@4
$LN31@erase@4:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$224566[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@QAE?AV?$_Vector_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@V?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@0@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ; std::_Allocate<MayaBonusChoice>
PUBLIC	?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$246052 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$246052[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$246052[ebp], 0
	jbe	SHORT $LN11@Buy@3
	mov	eax, DWORD PTR __Count$246052[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@3
$LN11@Buy@3:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@3:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ; std::_Allocate<MayaBonusChoice>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T246146 = -32						; size = 4
$T246145 = -28						; size = 4
$T246141 = -24						; size = 4
$T246140 = -20						; size = 4
$T246122 = -16						; size = 4
$T246121 = -12						; size = 4
$T246105 = -8						; size = 4
__Cat$246128 = -2					; size = 1
$T246125 = -1						; size = 1
?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246140[ebp], ecx
	mov	edx, DWORD PTR $T246141[ebp]
	mov	DWORD PTR $T246122[ebp], edx
	mov	eax, DWORD PTR $T246140[ebp]
	mov	DWORD PTR $T246121[ebp], eax
	mov	cl, BYTE PTR __Cat$246128[ebp]
	mov	BYTE PTR $T246125[ebp], cl
	mov	edx, DWORD PTR $T246121[ebp]
	mov	DWORD PTR $T246105[ebp], edx
	jmp	SHORT $LN12@Tidy@3
$LN11@Tidy@3:
	mov	eax, DWORD PTR $T246105[ebp]
	add	eax, 8
	mov	DWORD PTR $T246105[ebp], eax
$LN12@Tidy@3:
	mov	ecx, DWORD PTR $T246105[ebp]
	cmp	ecx, DWORD PTR $T246122[ebp]
	je	SHORT $LN4@Tidy@3
	jmp	SHORT $LN11@Tidy@3
$LN4@Tidy@3:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	mov	DWORD PTR $T246146[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246145[ebp], eax
	mov	ecx, DWORD PTR $T246145[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Tidy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246183 = -16						; size = 4
$T246162 = -12						; size = 4
$T246155 = -8						; size = 4
__Pnode$224615 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN6@Inc
	jmp	$LN7@Inc
$LN6@Inc:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T246155[ebp], ecx
	mov	edx, DWORD PTR $T246155[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN27@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T246162[ebp], eax
	mov	ecx, DWORD PTR $T246162[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246183[ebp], edx
$LN23@Inc:
	mov	eax, DWORD PTR $T246183[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN19@Inc
	mov	eax, DWORD PTR $T246183[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246183[ebp], ecx
	jmp	SHORT $LN23@Inc
$LN19@Inc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T246183[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224615[ebp], eax
	mov	ecx, DWORD PTR __Pnode$224615[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN1@Inc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$224615[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$224615[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$224615[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z$0
__unwindtable$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z$4
__ehfuncinfo$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
_TEXT	SEGMENT
tv168 = -184						; size = 4
_this$ = -180						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n, COMDAT
; _this$ = ecx

; 545  : 		{	// construct from _Count * _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buy(_Count))

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Construct_

; 547  : 			{	// nonzero, fill it
; 548  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 549  : 			_Mylast = _Ufill(_Myfirst, _Count, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
	mov	DWORD PTR tv168[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv168[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN5@Construct_
__catch$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z$0:

; 550  : 			_CATCH_ALL
; 551  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 552  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 553  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN4@Construct_
	ret	0
$LN5@Construct_:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN4@Construct_:

; 554  : 			}
; 555  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Construct_n@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T246598 = -72						; size = 4
$T246593 = -68						; size = 4
__Tmp$246580 = -48					; size = 4
$T246508 = -44						; size = 4
$T246495 = -40						; size = 4
$T246425 = -28						; size = 4
$T246402 = -24						; size = 4
$T246389 = -20						; size = 4
$T246383 = -16						; size = 4
$T246382 = -12						; size = 4
$T246381 = -8						; size = 4
$T246380 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246389[ebp], ecx
	mov	edx, DWORD PTR $T246389[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246402[ebp], eax
	mov	ecx, DWORD PTR $T246402[ebp]
	mov	DWORD PTR $T246380[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T246380[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246425[ebp], eax
	mov	ecx, DWORD PTR $T246425[ebp]
	mov	DWORD PTR $T246381[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T246381[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@5

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246495[ebp], eax
	mov	ecx, DWORD PTR $T246495[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246508[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T246508[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@5

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@5

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN72@erase@5:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@5

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$246580[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$246580[ebp]
	mov	DWORD PTR $T246382[ebp], ecx
	mov	edx, DWORD PTR $T246382[ebp]
	push	edx
	lea	eax, DWORD PTR $T246383[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	jmp	SHORT $LN72@erase@5
$LN1@erase@5:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T246598[ebp], ecx
	mov	edx, DWORD PTR $T246598[ebp]
	mov	DWORD PTR $T246593[ebp], edx
	mov	eax, DWORD PTR $T246593[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@5:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
tv141 = -40						; size = 4
tv153 = -36						; size = 4
_this$ = -32						; size = 4
__Pnode$224696 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	$LN3@Copy@2

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR __Pnode$224696[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN2@Copy@2

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$224696[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@2:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$224696[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR tv153[ebp], eax
	mov	eax, DWORD PTR __Pnode$224696[ebp]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR [eax], ecx

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	edx, DWORD PTR __Pnode$224696[ebp]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR __Pnode$224696[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN6@Copy@2
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	ecx, DWORD PTR __Newroot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@2
	ret	0
$LN6@Copy@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@2:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@2:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T247195 = -188						; size = 4
$T247107 = -172						; size = 4
$T247022 = -160						; size = 4
$T247006 = -156						; size = 4
$T246987 = -152						; size = 4
$T246983 = -148						; size = 4
$T246898 = -136						; size = 4
$T246797 = -120						; size = 4
$T246775 = -116						; size = 4
$T246768 = -112						; size = 4
$T246764 = -108						; size = 4
$T246725 = -104						; size = 4
$T246716 = -100						; size = 4
$T246696 = -96						; size = 4
__Count$246679 = -92					; size = 4
$T246662 = -88						; size = 28
$T246661 = -60						; size = 40
__Pnode$224713 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$246679[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$246679[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$246679[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T246662[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T246662[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246661[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T246661[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T246661[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T246662[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246696[ebp], edx
	mov	eax, DWORD PTR $T246696[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246716[ebp], eax
	mov	ecx, DWORD PTR $T246716[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246725[ebp], ecx
	mov	edx, DWORD PTR $T246725[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$224713[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+20]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T246764[ebp], edx
	mov	eax, DWORD PTR $T246764[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246768[ebp], ecx
	mov	edx, DWORD PTR __Pnode$224713[ebp]
	mov	eax, DWORD PTR $T246768[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$224713[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T246775[ebp], eax
	mov	ecx, DWORD PTR $T246775[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$224713[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224713[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T246797[ebp], ecx
	mov	edx, DWORD PTR $T246797[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224713[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$224713[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$224713[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$224713[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224713[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T246898[ebp], ecx
	mov	edx, DWORD PTR $T246898[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T246983[ebp], edx
	mov	eax, DWORD PTR $T246983[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246987[ebp], ecx
	mov	edx, DWORD PTR $T246987[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$224713[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$224713[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T247006[ebp], ecx
	mov	edx, DWORD PTR $T247006[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224713[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247022[ebp], edx
	mov	eax, DWORD PTR $T247022[ebp]
	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$224713[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$224713[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$224713[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+20], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$224713[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T247107[ebp], edx
	mov	eax, DWORD PTR $T247107[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$224713[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T247195[ebp], eax
	mov	ecx, DWORD PTR $T247195[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T246662[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN3@Lbound

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound
$LN3@Lbound:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T247379 = -80						; size = 4
__Vptr$247385 = -76					; size = 4
$T247350 = -72						; size = 4
__Vptr$247356 = -68					; size = 4
$T247321 = -64						; size = 4
__Vptr$247327 = -60					; size = 4
$T247284 = -36						; size = 4
$T247283 = -32						; size = 4
$T247282 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T247282[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$247327[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247327[ebp]
	mov	DWORD PTR $T247321[ebp], ecx
	cmp	DWORD PTR $T247321[ebp], 0
	je	SHORT $LN23@Buynode
	mov	edx, DWORD PTR $T247321[ebp]
	mov	eax, DWORD PTR $T247282[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T247321[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode
$LN23@Buynode:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T247283[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$247356[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247356[ebp]
	mov	DWORD PTR $T247350[ebp], ecx
	cmp	DWORD PTR $T247350[ebp], 0
	je	SHORT $LN33@Buynode
	mov	edx, DWORD PTR $T247350[ebp]
	mov	eax, DWORD PTR $T247283[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T247350[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode
$LN33@Buynode:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T247284[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$247385[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247385[ebp]
	mov	DWORD PTR $T247379[ebp], ecx
	cmp	DWORD PTR $T247379[ebp], 0
	je	SHORT $LN43@Buynode
	mov	edx, DWORD PTR $T247379[ebp]
	mov	eax, DWORD PTR $T247284[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T247379[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode
$LN43@Buynode:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode:
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+21], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
PUBLIC	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
PUBLIC	??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$2
__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$0
__unwindtable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv304 = -428						; size = 4
tv290 = -424						; size = 4
tv282 = -420						; size = 4
_this$ = -416						; size = 4
$T248110 = -412						; size = 4
$T248102 = -408						; size = 4
$T248101 = -404						; size = 4
$T248078 = -398						; size = 1
$T248077 = -397						; size = 1
$T248076 = -396						; size = 4
$T248075 = -392						; size = 4
$T248063 = -385						; size = 1
$T248062 = -384						; size = 4
$T248061 = -380						; size = 4
$T248060 = -376						; size = 4
__Cat$248094 = -372					; size = 1
$T248091 = -371						; size = 1
$T248090 = -370						; size = 1
__Cat$248085 = -368					; size = 1
$T248082 = -367						; size = 1
$T248081 = -366						; size = 1
$T248080 = -365						; size = 1
$T248035 = -364						; size = 4
$T248016 = -360						; size = 4
$T247999 = -353						; size = 1
$T247998 = -352						; size = 4
$T247988 = -348						; size = 4
$T247987 = -344						; size = 4
__Cat$248032 = -338					; size = 1
$T248029 = -337						; size = 1
$T248028 = -336						; size = 1
__Cat$248023 = -335					; size = 1
$T248020 = -334						; size = 1
$T248019 = -333						; size = 1
$T247963 = -332						; size = 4
$T247955 = -328						; size = 4
$T247947 = -324						; size = 4
$T247929 = -320						; size = 4
$T247928 = -316						; size = 4
$T247912 = -312						; size = 4
__Cat$247935 = -306					; size = 1
$T247932 = -305						; size = 1
$T247886 = -304						; size = 4
$T247885 = -300						; size = 4
$T247875 = -296						; size = 4
__Cat$247882 = -291					; size = 1
$T247879 = -290						; size = 1
$T247878 = -289						; size = 1
$T247859 = -288						; size = 4
$T247840 = -284						; size = 4
$T247823 = -277						; size = 1
$T247822 = -276						; size = 4
$T247812 = -272						; size = 4
$T247811 = -268						; size = 4
__Cat$247842 = -262					; size = 1
$T247849 = -261						; size = 1
$T247848 = -260						; size = 1
__Cat$247855 = -259					; size = 1
$T247853 = -258						; size = 1
$T247852 = -257						; size = 1
$T247787 = -256						; size = 4
$T247786 = -252						; size = 4
$T247782 = -248						; size = 4
$T247781 = -244						; size = 4
$T247763 = -240						; size = 4
$T247762 = -236						; size = 4
$T247746 = -232						; size = 4
__Cat$247770 = -226					; size = 1
$T247768 = -225						; size = 1
$T247697 = -224						; size = 4
$T247696 = -220						; size = 4
$T247680 = -216						; size = 4
__Cat$247704 = -210					; size = 1
$T247702 = -209						; size = 1
$T247637 = -208						; size = 4
$T247636 = -204						; size = 4
$T247620 = -200						; size = 4
__Cat$247644 = -194					; size = 1
$T247642 = -193						; size = 1
$T247594 = -192						; size = 4
$T247582 = -188						; size = 4
$T247572 = -181						; size = 1
$T247571 = -180						; size = 4
__Cat$247590 = -175					; size = 1
$T247587 = -174						; size = 1
$T247586 = -173						; size = 1
$T247559 = -172						; size = 4
$T247547 = -168						; size = 4
$T247537 = -161						; size = 1
$T247536 = -160						; size = 4
__Cat$247555 = -155					; size = 1
$T247552 = -154						; size = 1
$T247551 = -153						; size = 1
$T247524 = -152						; size = 4
$T247514 = -148						; size = 4
__Cat$247523 = -143					; size = 1
$T247520 = -142						; size = 1
$T247519 = -141						; size = 1
__Count$247487 = -128					; size = 4
__Count$247461 = -56					; size = 4
__Tmp$224827 = -52					; size = 8
__Oldend$224828 = -44					; size = 4
__Tmp$224817 = -40					; size = 8
__Ncopied$224804 = -32					; size = 4
__Newvec$224802 = -28					; size = 4
__Whereoff$224803 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$247461[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$247461[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$247461[ebp]
	mov	DWORD PTR tv290[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	eax, DWORD PTR tv290[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$247487[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$247487[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$247487[ebp]
	mov	DWORD PTR tv304[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv304[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ; std::_Allocate<FreeResourceXCities>
	add	esp, 8
	mov	DWORD PTR __Newvec$224802[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR __Whereoff$224803[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224804[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$224803[ebp]
	mov	ecx, DWORD PTR __Newvec$224802[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T247524[ebp], edx
	mov	eax, DWORD PTR $T247524[ebp]
	mov	DWORD PTR $T247514[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T247519[ebp], cl
	mov	dl, BYTE PTR __Cat$247523[ebp]
	mov	BYTE PTR $T247520[ebp], dl
	movzx	eax, BYTE PTR $T247519[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T247520[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247514[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224804[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224804[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247559[ebp], edx
	mov	eax, DWORD PTR __Newvec$224802[ebp]
	mov	DWORD PTR $T247547[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T247551[ebp], cl
	mov	dl, BYTE PTR __Cat$247555[ebp]
	mov	BYTE PTR $T247552[ebp], dl
	mov	al, BYTE PTR $T247551[ebp]
	mov	BYTE PTR $T247537[ebp], al
	mov	ecx, DWORD PTR $T247547[ebp]
	mov	DWORD PTR $T247536[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T247536[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247559[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224804[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224804[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T247594[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224803[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$224802[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T247582[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247586[ebp], al
	mov	cl, BYTE PTR __Cat$247590[ebp]
	mov	BYTE PTR $T247587[ebp], cl
	mov	dl, BYTE PTR $T247586[ebp]
	mov	BYTE PTR $T247572[ebp], dl
	mov	eax, DWORD PTR $T247582[ebp]
	mov	DWORD PTR $T247571[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247571[ebp]
	push	edx
	mov	eax, DWORD PTR $T247594[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224804[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$224803[ebp]
	mov	eax, DWORD PTR __Newvec$224802[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T247637[ebp], ecx
	mov	edx, DWORD PTR __Newvec$224802[ebp]
	mov	DWORD PTR $T247636[ebp], edx
	mov	al, BYTE PTR __Cat$247644[ebp]
	mov	BYTE PTR $T247642[ebp], al
	mov	ecx, DWORD PTR $T247636[ebp]
	mov	DWORD PTR $T247620[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T247620[ebp]
	add	edx, 8
	mov	DWORD PTR $T247620[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T247620[ebp]
	cmp	eax, DWORD PTR $T247637[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224804[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$224803[ebp]
	mov	edx, DWORD PTR __Newvec$224802[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T247697[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224803[ebp]
	mov	ecx, DWORD PTR __Newvec$224802[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T247696[ebp], edx
	mov	al, BYTE PTR __Cat$247704[ebp]
	mov	BYTE PTR $T247702[ebp], al
	mov	ecx, DWORD PTR $T247696[ebp]
	mov	DWORD PTR $T247680[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T247680[ebp]
	add	edx, 8
	mov	DWORD PTR $T247680[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T247680[ebp]
	cmp	eax, DWORD PTR $T247697[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224802[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T247782[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T247781[ebp], eax
	mov	ecx, DWORD PTR $T247782[ebp]
	mov	DWORD PTR $T247763[ebp], ecx
	mov	edx, DWORD PTR $T247781[ebp]
	mov	DWORD PTR $T247762[ebp], edx
	mov	al, BYTE PTR __Cat$247770[ebp]
	mov	BYTE PTR $T247768[ebp], al
	mov	ecx, DWORD PTR $T247762[ebp]
	mov	DWORD PTR $T247746[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T247746[ebp]
	add	edx, 8
	mov	DWORD PTR $T247746[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T247746[ebp]
	cmp	eax, DWORD PTR $T247763[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T247787[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247786[ebp], edx
	mov	eax, DWORD PTR $T247786[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$224802[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$224802[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224802[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$224817[ebp], edx
	mov	DWORD PTR __Tmp$224817[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T247859[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T247840[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247852[ebp], al
	mov	cl, BYTE PTR __Cat$247855[ebp]
	mov	BYTE PTR $T247853[ebp], cl
	mov	dl, BYTE PTR $T247852[ebp]
	mov	BYTE PTR $T247823[ebp], dl
	mov	eax, DWORD PTR $T247840[ebp]
	mov	DWORD PTR $T247822[ebp], eax
	mov	ecx, DWORD PTR $T247822[ebp]
	mov	DWORD PTR $T247812[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T247811[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247848[ebp], al
	mov	cl, BYTE PTR __Cat$247842[ebp]
	mov	BYTE PTR $T247849[ebp], cl
	movzx	edx, BYTE PTR $T247848[ebp]
	push	edx
	movzx	eax, BYTE PTR $T247849[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247812[ebp]
	push	edx
	mov	eax, DWORD PTR $T247859[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247811[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T247886[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T247885[ebp], eax
	mov	ecx, DWORD PTR $T247885[ebp]
	mov	DWORD PTR $T247875[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T247878[ebp], dl
	mov	al, BYTE PTR __Cat$247882[ebp]
	mov	BYTE PTR $T247879[ebp], al
	movzx	ecx, BYTE PTR $T247878[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T247879[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224817[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247886[ebp]
	push	edx
	mov	eax, DWORD PTR $T247875[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T247947[ebp], ecx
	mov	edx, DWORD PTR $T247947[ebp]
	mov	DWORD PTR $T247929[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T247928[ebp], edx
	mov	al, BYTE PTR __Cat$247935[ebp]
	mov	BYTE PTR $T247932[ebp], al
	mov	ecx, DWORD PTR $T247928[ebp]
	mov	DWORD PTR $T247912[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T247912[ebp]
	add	edx, 8
	mov	DWORD PTR $T247912[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T247912[ebp]
	cmp	eax, DWORD PTR $T247929[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T247963[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T247955[ebp], eax
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	ecx, DWORD PTR $T247955[ebp]
	add	ecx, 8
	mov	DWORD PTR $T247955[ebp], ecx
$LN171@Insert_n:
	mov	edx, DWORD PTR $T247955[ebp]
	cmp	edx, DWORD PTR $T247963[ebp]
	je	SHORT $LN167@Insert_n
	mov	eax, DWORD PTR __Tmp$224817[ebp]
	mov	ecx, DWORD PTR __Tmp$224817[ebp+4]
	mov	edx, DWORD PTR $T247955[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$224827[ebp], ecx
	mov	DWORD PTR __Tmp$224827[ebp+4], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$224828[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T248035[ebp], eax
	mov	ecx, DWORD PTR $T248035[ebp]
	mov	DWORD PTR $T248016[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248019[ebp], dl
	mov	al, BYTE PTR __Cat$248023[ebp]
	mov	BYTE PTR $T248020[ebp], al
	mov	cl, BYTE PTR $T248019[ebp]
	mov	BYTE PTR $T247999[ebp], cl
	mov	edx, DWORD PTR $T248016[ebp]
	mov	DWORD PTR $T247998[ebp], edx
	mov	eax, DWORD PTR $T247998[ebp]
	mov	DWORD PTR $T247988[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$224828[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T247987[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T248028[ebp], al
	mov	cl, BYTE PTR __Cat$248032[ebp]
	mov	BYTE PTR $T248029[ebp], cl
	movzx	edx, BYTE PTR $T248028[ebp]
	push	edx
	movzx	eax, BYTE PTR $T248029[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247988[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$224828[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247987[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$224828[ebp]
	mov	DWORD PTR $T248102[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T248101[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248080[ebp], dl
	mov	al, BYTE PTR __Cat$248085[ebp]
	mov	BYTE PTR $T248081[ebp], al
	mov	cl, BYTE PTR $T248080[ebp]
	mov	BYTE PTR $T248078[ebp], cl
	mov	dl, BYTE PTR $T248082[ebp]
	mov	BYTE PTR $T248077[ebp], dl
	mov	eax, DWORD PTR $T248102[ebp]
	mov	DWORD PTR $T248076[ebp], eax
	mov	ecx, DWORD PTR $T248101[ebp]
	mov	DWORD PTR $T248075[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248090[ebp], dl
	mov	al, BYTE PTR __Cat$248094[ebp]
	mov	BYTE PTR $T248091[ebp], al
	mov	cl, BYTE PTR $T248090[ebp]
	mov	BYTE PTR $T248063[ebp], cl
	mov	edx, DWORD PTR $T248076[ebp]
	mov	DWORD PTR $T248062[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$224828[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T248061[ebp], ecx
	mov	edx, DWORD PTR $T248075[ebp]
	mov	DWORD PTR $T248060[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T248060[ebp]
	cmp	eax, DWORD PTR $T248061[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T248061[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T248061[ebp], ecx
	mov	edx, DWORD PTR $T248062[ebp]
	sub	edx, 8
	mov	DWORD PTR $T248062[ebp], edx
	mov	eax, DWORD PTR $T248061[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T248062[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T248110[ebp], ecx
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	edx, DWORD PTR $T248110[ebp]
	add	edx, 8
	mov	DWORD PTR $T248110[ebp], edx
$LN204@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	DWORD PTR $T248110[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR __Tmp$224827[ebp]
	mov	ecx, DWORD PTR __Tmp$224827[ebp+4]
	mov	edx, DWORD PTR $T248110[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@IAEXV?$_Vector_const_iterator@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@2@IABUFreeResourceXCities@@@Z ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Insert_n
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T248132 = -80						; size = 28
$T248131 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ PROC ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T248132[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T248131[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T248131[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T248132[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248131[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T248131[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T248131[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T248132[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T248132[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T248131[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UFreeResourceXCities@@V?$allocator@UFreeResourceXCities@@@std@@@std@@KAXXZ ENDP ; std::vector<FreeResourceXCities,std::allocator<FreeResourceXCities> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T248154 = -80						; size = 28
$T248153 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T248154[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T248153[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T248153[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T248154[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248153[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T248153[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T248153[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T248154[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T248154[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T248153[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvTraitEntry@@V?$allocator@PAVCvTraitEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTraitEntry *,std::allocator<CvTraitEntry *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
PUBLIC	??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
PUBLIC	??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ; std::_Allocate<enum TraitTypes>
PUBLIC	?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv302 = -420						; size = 4
tv288 = -416						; size = 4
tv280 = -412						; size = 4
_this$ = -408						; size = 4
$T248856 = -404						; size = 4
$T248848 = -400						; size = 4
$T248847 = -396						; size = 4
$T248824 = -390						; size = 1
$T248823 = -389						; size = 1
$T248822 = -388						; size = 4
$T248821 = -384						; size = 4
$T248809 = -377						; size = 1
$T248808 = -376						; size = 4
$T248807 = -372						; size = 4
$T248806 = -368						; size = 4
__Cat$248841 = -364					; size = 1
$T248839 = -363						; size = 1
$T248838 = -362						; size = 1
__Cat$248831 = -360					; size = 1
$T248829 = -359						; size = 1
$T248828 = -358						; size = 1
$T248827 = -357						; size = 1
$T248781 = -356						; size = 4
$T248762 = -352						; size = 4
$T248745 = -345						; size = 1
$T248744 = -344						; size = 4
$T248734 = -340						; size = 4
$T248733 = -336						; size = 4
__Cat$248778 = -330					; size = 1
$T248776 = -329						; size = 1
$T248775 = -328						; size = 1
__Cat$248770 = -327					; size = 1
$T248767 = -326						; size = 1
$T248766 = -325						; size = 1
$T248709 = -324						; size = 4
$T248701 = -320						; size = 4
$T248693 = -316						; size = 4
$T248675 = -312						; size = 4
$T248674 = -308						; size = 4
$T248658 = -304						; size = 4
__Cat$248682 = -298					; size = 1
$T248680 = -297						; size = 1
$T248632 = -296						; size = 4
$T248631 = -292						; size = 4
$T248621 = -288						; size = 4
__Cat$248629 = -283					; size = 1
$T248627 = -282						; size = 1
$T248626 = -281						; size = 1
$T248605 = -280						; size = 4
$T248586 = -276						; size = 4
$T248569 = -269						; size = 1
$T248568 = -268						; size = 4
$T248558 = -264						; size = 4
$T248557 = -260						; size = 4
__Cat$248602 = -254					; size = 1
$T248600 = -253						; size = 1
$T248599 = -252						; size = 1
__Cat$248594 = -251					; size = 1
$T248591 = -250						; size = 1
$T248590 = -249						; size = 1
$T248533 = -248						; size = 4
$T248532 = -244						; size = 4
$T248528 = -240						; size = 4
$T248527 = -236						; size = 4
$T248509 = -232						; size = 4
$T248508 = -228						; size = 4
$T248492 = -224						; size = 4
__Cat$248516 = -218					; size = 1
$T248514 = -217						; size = 1
$T248443 = -216						; size = 4
$T248442 = -212						; size = 4
$T248426 = -208						; size = 4
__Cat$248449 = -202					; size = 1
$T248447 = -201						; size = 1
$T248383 = -200						; size = 4
$T248382 = -196						; size = 4
$T248366 = -192						; size = 4
__Cat$248389 = -186					; size = 1
$T248387 = -185						; size = 1
$T248340 = -184						; size = 4
$T248328 = -180						; size = 4
$T248318 = -173						; size = 1
$T248317 = -172						; size = 4
__Cat$248335 = -167					; size = 1
$T248332 = -166						; size = 1
$T248331 = -165						; size = 1
$T248305 = -164						; size = 4
$T248293 = -160						; size = 4
$T248283 = -153						; size = 1
$T248282 = -152						; size = 4
__Cat$248300 = -147					; size = 1
$T248297 = -146						; size = 1
$T248296 = -145						; size = 1
$T248270 = -144						; size = 4
$T248260 = -140						; size = 4
__Cat$248268 = -135					; size = 1
$T248266 = -134						; size = 1
$T248265 = -133						; size = 1
__Count$248233 = -120					; size = 4
__Count$248207 = -48					; size = 4
__Tmp$224924 = -44					; size = 4
__Oldend$224925 = -40					; size = 4
__Tmp$224914 = -36					; size = 4
__Ncopied$224901 = -32					; size = 4
__Newvec$224899 = -28					; size = 4
__Whereoff$224900 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$248207[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$248207[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$248207[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$248233[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$248233[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$248233[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ; std::_Allocate<enum TraitTypes>
	add	esp, 8
	mov	DWORD PTR __Newvec$224899[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$224900[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224901[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$224900[ebp]
	mov	ecx, DWORD PTR __Newvec$224899[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T248270[ebp], edx
	mov	eax, DWORD PTR $T248270[ebp]
	mov	DWORD PTR $T248260[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248265[ebp], cl
	mov	dl, BYTE PTR __Cat$248268[ebp]
	mov	BYTE PTR $T248266[ebp], dl
	movzx	eax, BYTE PTR $T248265[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T248266[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248260[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224901[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224901[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T248305[ebp], edx
	mov	eax, DWORD PTR __Newvec$224899[ebp]
	mov	DWORD PTR $T248293[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248296[ebp], cl
	mov	dl, BYTE PTR __Cat$248300[ebp]
	mov	BYTE PTR $T248297[ebp], dl
	mov	al, BYTE PTR $T248296[ebp]
	mov	BYTE PTR $T248283[ebp], al
	mov	ecx, DWORD PTR $T248293[ebp]
	mov	DWORD PTR $T248282[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T248282[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248305[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224901[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224901[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T248340[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224900[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$224899[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T248328[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T248331[ebp], al
	mov	cl, BYTE PTR __Cat$248335[ebp]
	mov	BYTE PTR $T248332[ebp], cl
	mov	dl, BYTE PTR $T248331[ebp]
	mov	BYTE PTR $T248318[ebp], dl
	mov	eax, DWORD PTR $T248328[ebp]
	mov	DWORD PTR $T248317[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248317[ebp]
	push	edx
	mov	eax, DWORD PTR $T248340[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224901[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$224900[ebp]
	mov	eax, DWORD PTR __Newvec$224899[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T248383[ebp], ecx
	mov	edx, DWORD PTR __Newvec$224899[ebp]
	mov	DWORD PTR $T248382[ebp], edx
	mov	al, BYTE PTR __Cat$248389[ebp]
	mov	BYTE PTR $T248387[ebp], al
	mov	ecx, DWORD PTR $T248382[ebp]
	mov	DWORD PTR $T248366[ebp], ecx
	jmp	SHORT $LN91@Insert_n@2
$LN90@Insert_n@2:
	mov	edx, DWORD PTR $T248366[ebp]
	add	edx, 4
	mov	DWORD PTR $T248366[ebp], edx
$LN91@Insert_n@2:
	mov	eax, DWORD PTR $T248366[ebp]
	cmp	eax, DWORD PTR $T248383[ebp]
	je	SHORT $LN7@Insert_n@2
	jmp	SHORT $LN90@Insert_n@2
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224901[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$224900[ebp]
	mov	edx, DWORD PTR __Newvec$224899[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T248443[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224900[ebp]
	mov	ecx, DWORD PTR __Newvec$224899[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T248442[ebp], edx
	mov	al, BYTE PTR __Cat$248449[ebp]
	mov	BYTE PTR $T248447[ebp], al
	mov	ecx, DWORD PTR $T248442[ebp]
	mov	DWORD PTR $T248426[ebp], ecx
	jmp	SHORT $LN106@Insert_n@2
$LN105@Insert_n@2:
	mov	edx, DWORD PTR $T248426[ebp]
	add	edx, 4
	mov	DWORD PTR $T248426[ebp], edx
$LN106@Insert_n@2:
	mov	eax, DWORD PTR $T248426[ebp]
	cmp	eax, DWORD PTR $T248443[ebp]
	je	SHORT $LN6@Insert_n@2
	jmp	SHORT $LN105@Insert_n@2
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224899[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T248528[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T248527[ebp], eax
	mov	ecx, DWORD PTR $T248528[ebp]
	mov	DWORD PTR $T248509[ebp], ecx
	mov	edx, DWORD PTR $T248527[ebp]
	mov	DWORD PTR $T248508[ebp], edx
	mov	al, BYTE PTR __Cat$248516[ebp]
	mov	BYTE PTR $T248514[ebp], al
	mov	ecx, DWORD PTR $T248508[ebp]
	mov	DWORD PTR $T248492[ebp], ecx
	jmp	SHORT $LN125@Insert_n@2
$LN124@Insert_n@2:
	mov	edx, DWORD PTR $T248492[ebp]
	add	edx, 4
	mov	DWORD PTR $T248492[ebp], edx
$LN125@Insert_n@2:
	mov	eax, DWORD PTR $T248492[ebp]
	cmp	eax, DWORD PTR $T248509[ebp]
	je	SHORT $LN117@Insert_n@2
	jmp	SHORT $LN124@Insert_n@2
$LN117@Insert_n@2:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T248533[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T248532[ebp], edx
	mov	eax, DWORD PTR $T248532[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$224899[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$224899[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224899[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224914[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T248605[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T248586[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248590[ebp], dl
	mov	al, BYTE PTR __Cat$248594[ebp]
	mov	BYTE PTR $T248591[ebp], al
	mov	cl, BYTE PTR $T248590[ebp]
	mov	BYTE PTR $T248569[ebp], cl
	mov	edx, DWORD PTR $T248586[ebp]
	mov	DWORD PTR $T248568[ebp], edx
	mov	eax, DWORD PTR $T248568[ebp]
	mov	DWORD PTR $T248558[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T248557[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248599[ebp], dl
	mov	al, BYTE PTR __Cat$248602[ebp]
	mov	BYTE PTR $T248600[ebp], al
	movzx	ecx, BYTE PTR $T248599[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T248600[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248558[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248605[ebp]
	push	edx
	mov	eax, DWORD PTR $T248557[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T248632[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T248631[ebp], edx
	mov	eax, DWORD PTR $T248631[ebp]
	mov	DWORD PTR $T248621[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248626[ebp], cl
	mov	dl, BYTE PTR __Cat$248629[ebp]
	mov	BYTE PTR $T248627[ebp], dl
	movzx	eax, BYTE PTR $T248626[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T248627[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$224914[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248632[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248621[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T248693[ebp], eax
	mov	ecx, DWORD PTR $T248693[ebp]
	mov	DWORD PTR $T248675[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T248674[ebp], ecx
	mov	dl, BYTE PTR __Cat$248682[ebp]
	mov	BYTE PTR $T248680[ebp], dl
	mov	eax, DWORD PTR $T248674[ebp]
	mov	DWORD PTR $T248658[ebp], eax
	jmp	SHORT $LN160@Insert_n@2
$LN159@Insert_n@2:
	mov	ecx, DWORD PTR $T248658[ebp]
	add	ecx, 4
	mov	DWORD PTR $T248658[ebp], ecx
$LN160@Insert_n@2:
	mov	edx, DWORD PTR $T248658[ebp]
	cmp	edx, DWORD PTR $T248675[ebp]
	je	SHORT $LN152@Insert_n@2
	jmp	SHORT $LN159@Insert_n@2
$LN152@Insert_n@2:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T248709[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T248701[ebp], edx
	jmp	SHORT $LN171@Insert_n@2
$LN170@Insert_n@2:
	mov	eax, DWORD PTR $T248701[ebp]
	add	eax, 4
	mov	DWORD PTR $T248701[ebp], eax
$LN171@Insert_n@2:
	mov	ecx, DWORD PTR $T248701[ebp]
	cmp	ecx, DWORD PTR $T248709[ebp]
	je	SHORT $LN167@Insert_n@2
	mov	edx, DWORD PTR $T248701[ebp]
	mov	eax, DWORD PTR __Tmp$224914[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN170@Insert_n@2
$LN167@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224924[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$224925[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T248781[ebp], eax
	mov	ecx, DWORD PTR $T248781[ebp]
	mov	DWORD PTR $T248762[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248766[ebp], dl
	mov	al, BYTE PTR __Cat$248770[ebp]
	mov	BYTE PTR $T248767[ebp], al
	mov	cl, BYTE PTR $T248766[ebp]
	mov	BYTE PTR $T248745[ebp], cl
	mov	edx, DWORD PTR $T248762[ebp]
	mov	DWORD PTR $T248744[ebp], edx
	mov	eax, DWORD PTR $T248744[ebp]
	mov	DWORD PTR $T248734[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$224925[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T248733[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T248775[ebp], al
	mov	cl, BYTE PTR __Cat$248778[ebp]
	mov	BYTE PTR $T248776[ebp], cl
	movzx	edx, BYTE PTR $T248775[ebp]
	push	edx
	movzx	eax, BYTE PTR $T248776[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248734[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$224925[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248733[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$224925[ebp]
	mov	DWORD PTR $T248848[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T248847[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248827[ebp], dl
	mov	al, BYTE PTR __Cat$248831[ebp]
	mov	BYTE PTR $T248828[ebp], al
	mov	cl, BYTE PTR $T248827[ebp]
	mov	BYTE PTR $T248824[ebp], cl
	mov	dl, BYTE PTR $T248829[ebp]
	mov	BYTE PTR $T248823[ebp], dl
	mov	eax, DWORD PTR $T248848[ebp]
	mov	DWORD PTR $T248822[ebp], eax
	mov	ecx, DWORD PTR $T248847[ebp]
	mov	DWORD PTR $T248821[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248838[ebp], dl
	mov	al, BYTE PTR __Cat$248841[ebp]
	mov	BYTE PTR $T248839[ebp], al
	mov	cl, BYTE PTR $T248838[ebp]
	mov	BYTE PTR $T248809[ebp], cl
	mov	edx, DWORD PTR $T248822[ebp]
	mov	DWORD PTR $T248808[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$224925[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T248807[ebp], ecx
	mov	edx, DWORD PTR $T248821[ebp]
	mov	DWORD PTR $T248806[ebp], edx
$LN197@Insert_n@2:
	mov	eax, DWORD PTR $T248806[ebp]
	cmp	eax, DWORD PTR $T248807[ebp]
	je	SHORT $LN186@Insert_n@2
	mov	ecx, DWORD PTR $T248807[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T248807[ebp], ecx
	mov	edx, DWORD PTR $T248808[ebp]
	sub	edx, 4
	mov	DWORD PTR $T248808[ebp], edx
	mov	eax, DWORD PTR $T248808[ebp]
	mov	ecx, DWORD PTR $T248807[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN197@Insert_n@2
$LN186@Insert_n@2:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T248856[ebp], eax
	jmp	SHORT $LN204@Insert_n@2
$LN203@Insert_n@2:
	mov	ecx, DWORD PTR $T248856[ebp]
	add	ecx, 4
	mov	DWORD PTR $T248856[ebp], ecx
$LN204@Insert_n@2:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T248856[ebp], ecx
	je	SHORT $LN16@Insert_n@2
	mov	edx, DWORD PTR $T248856[ebp]
	mov	eax, DWORD PTR __Tmp$224924[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN203@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@2@IABW4TraitTypes@@@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Insert_n
PUBLIC	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
PUBLIC	??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$2
__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$0
__unwindtable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
_TEXT	SEGMENT
tv84 = -420						; size = 4
tv306 = -416						; size = 4
tv292 = -412						; size = 4
tv284 = -408						; size = 4
_this$ = -404						; size = 4
$T249562 = -400						; size = 4
$T249554 = -396						; size = 4
$T249553 = -392						; size = 4
$T249530 = -386						; size = 1
$T249529 = -385						; size = 1
$T249528 = -384						; size = 4
$T249527 = -380						; size = 4
$T249515 = -373						; size = 1
$T249514 = -372						; size = 4
$T249513 = -368						; size = 4
$T249512 = -364						; size = 4
__Cat$249547 = -360					; size = 1
$T249544 = -359						; size = 1
$T249543 = -358						; size = 1
__Cat$249536 = -356					; size = 1
$T249534 = -355						; size = 1
$T249533 = -354						; size = 1
$T249532 = -353						; size = 1
$T249487 = -352						; size = 4
$T249468 = -348						; size = 4
$T249451 = -341						; size = 1
$T249450 = -340						; size = 4
$T249440 = -336						; size = 4
$T249439 = -332						; size = 4
__Cat$249484 = -326					; size = 1
$T249481 = -325						; size = 1
$T249480 = -324						; size = 1
__Cat$249474 = -323					; size = 1
$T249472 = -322						; size = 1
$T249471 = -321						; size = 1
$T249412 = -320						; size = 4
$T249404 = -316						; size = 4
$T249396 = -312						; size = 4
$T249378 = -308						; size = 4
$T249377 = -304						; size = 4
$T249361 = -300						; size = 4
__Cat$249384 = -294					; size = 1
$T249381 = -293						; size = 1
$T249335 = -292						; size = 4
$T249334 = -288						; size = 4
$T249324 = -284						; size = 4
__Cat$249333 = -279					; size = 1
$T249330 = -278						; size = 1
$T249329 = -277						; size = 1
$T249308 = -276						; size = 4
$T249289 = -272						; size = 4
$T249272 = -265						; size = 1
$T249271 = -264						; size = 4
$T249261 = -260						; size = 4
$T249260 = -256						; size = 4
__Cat$249305 = -250					; size = 1
$T249302 = -249						; size = 1
$T249301 = -248						; size = 1
__Cat$249295 = -247					; size = 1
$T249293 = -246						; size = 1
$T249292 = -245						; size = 1
$T249233 = -244						; size = 4
$T249232 = -240						; size = 4
$T249228 = -236						; size = 4
$T249227 = -232						; size = 4
$T249209 = -228						; size = 4
$T249208 = -224						; size = 4
$T249192 = -220						; size = 4
__Cat$249215 = -214					; size = 1
$T249212 = -213						; size = 1
$T249143 = -212						; size = 4
$T249142 = -208						; size = 4
$T249126 = -204						; size = 4
__Cat$249149 = -198					; size = 1
$T249146 = -197						; size = 1
$T249083 = -196						; size = 4
$T249082 = -192						; size = 4
$T249066 = -188						; size = 4
__Cat$249089 = -182					; size = 1
$T249086 = -181						; size = 1
$T249040 = -180						; size = 4
$T249028 = -176						; size = 4
$T249018 = -169						; size = 1
$T249017 = -168						; size = 4
__Cat$249034 = -163					; size = 1
$T249032 = -162						; size = 1
$T249031 = -161						; size = 1
$T249005 = -160						; size = 4
$T248993 = -156						; size = 4
$T248983 = -149						; size = 1
$T248982 = -148						; size = 4
__Cat$248999 = -143					; size = 1
$T248997 = -142						; size = 1
$T248996 = -141						; size = 1
$T248970 = -140						; size = 4
$T248960 = -136						; size = 4
__Cat$248967 = -131					; size = 1
$T248964 = -130						; size = 1
$T248963 = -129						; size = 1
__Count$248934 = -128					; size = 4
__Count$248908 = -56					; size = 4
__Tmp$224981 = -52					; size = 8
__Oldend$224982 = -44					; size = 4
__Tmp$224971 = -40					; size = 8
__Ncopied$224958 = -32					; size = 4
__Newvec$224956 = -28					; size = 4
__Whereoff$224957 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 404				; 00000194H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@3
	mov	DWORD PTR tv284[ebp], 0
	jmp	SHORT $LN27@Insert_n@3
$LN29@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv284[ebp], eax
$LN27@Insert_n@3:
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$248908[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$248908[ebp], 0
	jbe	SHORT $LN35@Insert_n@3
	mov	edx, DWORD PTR __Count$248908[ebp]
	mov	DWORD PTR tv292[ebp], edx
	jmp	SHORT $LN37@Insert_n@3
$LN35@Insert_n@3:
	mov	DWORD PTR tv292[ebp], 1
$LN37@Insert_n@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	eax, DWORD PTR tv292[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen
	jmp	$LN16@Insert_n@3

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$248934[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$248934[ebp], 0
	jbe	SHORT $LN48@Insert_n@3
	mov	ecx, DWORD PTR __Count$248934[ebp]
	mov	DWORD PTR tv306[ebp], ecx
	jmp	SHORT $LN44@Insert_n@3
$LN48@Insert_n@3:
	mov	DWORD PTR tv306[ebp], 1
$LN44@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv306[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@3:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@3:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ; std::_Allocate<MayaBonusChoice>
	add	esp, 8
	mov	DWORD PTR __Newvec$224956[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR __Whereoff$224957[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$224958[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$224957[ebp]
	mov	ecx, DWORD PTR __Newvec$224956[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T248970[ebp], edx
	mov	eax, DWORD PTR $T248970[ebp]
	mov	DWORD PTR $T248960[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248963[ebp], cl
	mov	dl, BYTE PTR __Cat$248967[ebp]
	mov	BYTE PTR $T248964[ebp], dl
	movzx	eax, BYTE PTR $T248963[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T248964[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248960[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224958[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224958[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249005[ebp], edx
	mov	eax, DWORD PTR __Newvec$224956[ebp]
	mov	DWORD PTR $T248993[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248996[ebp], cl
	mov	dl, BYTE PTR __Cat$248999[ebp]
	mov	BYTE PTR $T248997[ebp], dl
	mov	al, BYTE PTR $T248996[ebp]
	mov	BYTE PTR $T248983[ebp], al
	mov	ecx, DWORD PTR $T248993[ebp]
	mov	DWORD PTR $T248982[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T248982[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249005[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$224958[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$224958[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T249040[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224957[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$224956[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T249028[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T249031[ebp], al
	mov	cl, BYTE PTR __Cat$249034[ebp]
	mov	BYTE PTR $T249032[ebp], cl
	mov	dl, BYTE PTR $T249031[ebp]
	mov	BYTE PTR $T249018[ebp], dl
	mov	eax, DWORD PTR $T249028[ebp]
	mov	DWORD PTR $T249017[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249017[ebp]
	push	edx
	mov	eax, DWORD PTR $T249040[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@3
__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224958[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$224957[ebp]
	mov	eax, DWORD PTR __Newvec$224956[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T249083[ebp], ecx
	mov	edx, DWORD PTR __Newvec$224956[ebp]
	mov	DWORD PTR $T249082[ebp], edx
	mov	al, BYTE PTR __Cat$249089[ebp]
	mov	BYTE PTR $T249086[ebp], al
	mov	ecx, DWORD PTR $T249082[ebp]
	mov	DWORD PTR $T249066[ebp], ecx
	jmp	SHORT $LN86@Insert_n@3
$LN85@Insert_n@3:
	mov	edx, DWORD PTR $T249066[ebp]
	add	edx, 8
	mov	DWORD PTR $T249066[ebp], edx
$LN86@Insert_n@3:
	mov	eax, DWORD PTR $T249066[ebp]
	cmp	eax, DWORD PTR $T249083[ebp]
	je	SHORT $LN7@Insert_n@3
	jmp	SHORT $LN85@Insert_n@3
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$224958[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$224957[ebp]
	mov	edx, DWORD PTR __Newvec$224956[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T249143[ebp], edx
	mov	eax, DWORD PTR __Whereoff$224957[ebp]
	mov	ecx, DWORD PTR __Newvec$224956[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T249142[ebp], edx
	mov	al, BYTE PTR __Cat$249149[ebp]
	mov	BYTE PTR $T249146[ebp], al
	mov	ecx, DWORD PTR $T249142[ebp]
	mov	DWORD PTR $T249126[ebp], ecx
	jmp	SHORT $LN101@Insert_n@3
$LN100@Insert_n@3:
	mov	edx, DWORD PTR $T249126[ebp]
	add	edx, 8
	mov	DWORD PTR $T249126[ebp], edx
$LN101@Insert_n@3:
	mov	eax, DWORD PTR $T249126[ebp]
	cmp	eax, DWORD PTR $T249143[ebp]
	je	SHORT $LN6@Insert_n@3
	jmp	SHORT $LN100@Insert_n@3
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$224956[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN110@Insert_n@3
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN110@Insert_n@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T249228[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T249227[ebp], eax
	mov	ecx, DWORD PTR $T249228[ebp]
	mov	DWORD PTR $T249209[ebp], ecx
	mov	edx, DWORD PTR $T249227[ebp]
	mov	DWORD PTR $T249208[ebp], edx
	mov	al, BYTE PTR __Cat$249215[ebp]
	mov	BYTE PTR $T249212[ebp], al
	mov	ecx, DWORD PTR $T249208[ebp]
	mov	DWORD PTR $T249192[ebp], ecx
	jmp	SHORT $LN120@Insert_n@3
$LN119@Insert_n@3:
	mov	edx, DWORD PTR $T249192[ebp]
	add	edx, 8
	mov	DWORD PTR $T249192[ebp], edx
$LN120@Insert_n@3:
	mov	eax, DWORD PTR $T249192[ebp]
	cmp	eax, DWORD PTR $T249209[ebp]
	je	SHORT $LN112@Insert_n@3
	jmp	SHORT $LN119@Insert_n@3
$LN112@Insert_n@3:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T249233[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249232[ebp], edx
	mov	eax, DWORD PTR $T249232[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$224956[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$224956[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$224956[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224971[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$224971[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T249308[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T249289[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249292[ebp], cl
	mov	dl, BYTE PTR __Cat$249295[ebp]
	mov	BYTE PTR $T249293[ebp], dl
	mov	al, BYTE PTR $T249292[ebp]
	mov	BYTE PTR $T249272[ebp], al
	mov	ecx, DWORD PTR $T249289[ebp]
	mov	DWORD PTR $T249271[ebp], ecx
	mov	edx, DWORD PTR $T249271[ebp]
	mov	DWORD PTR $T249261[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249260[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249301[ebp], cl
	mov	dl, BYTE PTR __Cat$249305[ebp]
	mov	BYTE PTR $T249302[ebp], dl
	movzx	eax, BYTE PTR $T249301[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T249302[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T249261[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249308[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249260[ebp]
	push	edx
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T249335[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T249334[ebp], ecx
	mov	edx, DWORD PTR $T249334[ebp]
	mov	DWORD PTR $T249324[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T249329[ebp], al
	mov	cl, BYTE PTR __Cat$249333[ebp]
	mov	BYTE PTR $T249330[ebp], cl
	movzx	edx, BYTE PTR $T249329[ebp]
	push	edx
	movzx	eax, BYTE PTR $T249330[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$224971[ebp]
	push	edx
	mov	eax, DWORD PTR $T249335[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249324[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T249396[ebp], edx
	mov	eax, DWORD PTR $T249396[ebp]
	mov	DWORD PTR $T249378[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T249377[ebp], eax
	mov	cl, BYTE PTR __Cat$249384[ebp]
	mov	BYTE PTR $T249381[ebp], cl
	mov	edx, DWORD PTR $T249377[ebp]
	mov	DWORD PTR $T249361[ebp], edx
	jmp	SHORT $LN157@Insert_n@3
$LN156@Insert_n@3:
	mov	eax, DWORD PTR $T249361[ebp]
	add	eax, 8
	mov	DWORD PTR $T249361[ebp], eax
$LN157@Insert_n@3:
	mov	ecx, DWORD PTR $T249361[ebp]
	cmp	ecx, DWORD PTR $T249378[ebp]
	je	SHORT $LN149@Insert_n@3
	jmp	SHORT $LN156@Insert_n@3
$LN149@Insert_n@3:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T249412[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249404[ebp], ecx
	jmp	SHORT $LN168@Insert_n@3
$LN167@Insert_n@3:
	mov	edx, DWORD PTR $T249404[ebp]
	add	edx, 8
	mov	DWORD PTR $T249404[ebp], edx
$LN168@Insert_n@3:
	mov	eax, DWORD PTR $T249404[ebp]
	cmp	eax, DWORD PTR $T249412[ebp]
	je	SHORT $LN164@Insert_n@3
	mov	ecx, DWORD PTR __Tmp$224971[ebp]
	mov	edx, DWORD PTR __Tmp$224971[ebp+4]
	mov	eax, DWORD PTR $T249404[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN167@Insert_n@3
$LN164@Insert_n@3:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224981[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$224981[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$224982[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T249487[ebp], edx
	mov	eax, DWORD PTR $T249487[ebp]
	mov	DWORD PTR $T249468[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249471[ebp], cl
	mov	dl, BYTE PTR __Cat$249474[ebp]
	mov	BYTE PTR $T249472[ebp], dl
	mov	al, BYTE PTR $T249471[ebp]
	mov	BYTE PTR $T249451[ebp], al
	mov	ecx, DWORD PTR $T249468[ebp]
	mov	DWORD PTR $T249450[ebp], ecx
	mov	edx, DWORD PTR $T249450[ebp]
	mov	DWORD PTR $T249440[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$224982[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T249439[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T249480[ebp], dl
	mov	al, BYTE PTR __Cat$249484[ebp]
	mov	BYTE PTR $T249481[ebp], al
	movzx	ecx, BYTE PTR $T249480[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T249481[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249440[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$224982[ebp]
	push	edx
	mov	eax, DWORD PTR $T249439[ebp]
	push	eax
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$224982[ebp]
	mov	DWORD PTR $T249554[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249553[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249532[ebp], cl
	mov	dl, BYTE PTR __Cat$249536[ebp]
	mov	BYTE PTR $T249533[ebp], dl
	mov	al, BYTE PTR $T249532[ebp]
	mov	BYTE PTR $T249530[ebp], al
	mov	cl, BYTE PTR $T249534[ebp]
	mov	BYTE PTR $T249529[ebp], cl
	mov	edx, DWORD PTR $T249554[ebp]
	mov	DWORD PTR $T249528[ebp], edx
	mov	eax, DWORD PTR $T249553[ebp]
	mov	DWORD PTR $T249527[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249543[ebp], cl
	mov	dl, BYTE PTR __Cat$249547[ebp]
	mov	BYTE PTR $T249544[ebp], dl
	mov	al, BYTE PTR $T249543[ebp]
	mov	BYTE PTR $T249515[ebp], al
	mov	ecx, DWORD PTR $T249528[ebp]
	mov	DWORD PTR $T249514[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR __Oldend$224982[ebp]
	sub	eax, edx
	mov	DWORD PTR $T249513[ebp], eax
	mov	ecx, DWORD PTR $T249527[ebp]
	mov	DWORD PTR $T249512[ebp], ecx
$LN196@Insert_n@3:
	mov	edx, DWORD PTR $T249512[ebp]
	cmp	edx, DWORD PTR $T249513[ebp]
	je	SHORT $LN185@Insert_n@3
	mov	eax, DWORD PTR $T249513[ebp]
	sub	eax, 8
	mov	DWORD PTR $T249513[ebp], eax
	mov	ecx, DWORD PTR $T249514[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T249514[ebp], ecx
	mov	edx, DWORD PTR $T249513[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T249514[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN196@Insert_n@3
$LN185@Insert_n@3:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249562[ebp], eax
	jmp	SHORT $LN203@Insert_n@3
$LN202@Insert_n@3:
	mov	ecx, DWORD PTR $T249562[ebp]
	add	ecx, 8
	mov	DWORD PTR $T249562[ebp], ecx
$LN203@Insert_n@3:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	cmp	DWORD PTR $T249562[ebp], ecx
	je	SHORT $LN16@Insert_n@3
	mov	edx, DWORD PTR __Tmp$224981[ebp]
	mov	eax, DWORD PTR __Tmp$224981[ebp+4]
	mov	ecx, DWORD PTR $T249562[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN202@Insert_n@3
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-424]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@IAEXV?$_Vector_const_iterator@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@2@IABUMayaBonusChoice@@@Z ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T249584 = -80						; size = 28
$T249583 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ PROC ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T249584[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T249583[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T249583[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T249584[ebp]
	push	eax
	lea	ecx, DWORD PTR $T249583[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T249583[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T249583[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T249584[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T249584[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T249583[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UMayaBonusChoice@@V?$allocator@UMayaBonusChoice@@@std@@@std@@KAXXZ ENDP ; std::vector<MayaBonusChoice,std::allocator<MayaBonusChoice> >::_Xlen
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R0?AVout_of_range@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -216						; size = 4
tv165 = -212						; size = 4
_this$ = -208						; size = 4
$T250463 = -204						; size = 4
$T250457 = -200						; size = 4
$T249862 = -136						; size = 4
$T249861 = -132						; size = 4
__Tmp$249860 = -125					; size = 1
$T249837 = -124						; size = 4
$T249830 = -120						; size = 4
$T249760 = -116						; size = 4
$T249724 = -112						; size = 4
$T249719 = -108						; size = 4
$T249691 = -104						; size = 4
$T249615 = -100						; size = 4
$T249606 = -96						; size = 28
$T249605 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T249615[ebp], eax
	mov	ecx, DWORD PTR $T249615[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN55@erase@6

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T249606[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T249606[ebp]
	push	eax
	lea	ecx, DWORD PTR $T249605[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T249605[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T249605[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T249606[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@6:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN67@erase@6

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@6

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@6:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN71@erase@6

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@6

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@6:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@6:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@6

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN81@erase@6

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@6

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@6

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@6:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@6

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@6

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@6:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@6:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249691[ebp], ecx
	mov	edx, DWORD PTR $T249691[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@6

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN43@erase@6
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@6
$LN43@erase@6:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T249719[ebp], ecx
$LN107@erase@6:
	mov	edx, DWORD PTR $T249719[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN103@erase@6
	mov	edx, DWORD PTR $T249719[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249719[ebp], eax
	jmp	SHORT $LN107@erase@6
$LN103@erase@6:
	mov	ecx, DWORD PTR $T249719[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@6:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T249724[ebp], eax
	mov	ecx, DWORD PTR $T249724[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@6

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN45@erase@6
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@6
$LN45@erase@6:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T249760[ebp], eax
$LN127@erase@6:
	mov	ecx, DWORD PTR $T249760[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN123@erase@6
	mov	ecx, DWORD PTR $T249760[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T249760[ebp], edx
	jmp	SHORT $LN127@erase@6
$LN123@erase@6:
	mov	eax, DWORD PTR $T249760[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@6:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@6

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@6:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@6

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@6

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN151@erase@6

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@6:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@6

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@6

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@6:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T249830[ebp], ecx
	mov	edx, DWORD PTR $T249830[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@6

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249837[ebp], edx
	mov	eax, DWORD PTR $T249837[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@6

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@6:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T249862[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T249861[ebp], eax
	mov	ecx, DWORD PTR $T249861[ebp]
	cmp	ecx, DWORD PTR $T249862[ebp]
	je	SHORT $LN192@erase@6
	mov	edx, DWORD PTR $T249861[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$249860[ebp], al
	mov	ecx, DWORD PTR $T249861[ebp]
	mov	edx, DWORD PTR $T249862[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T249862[ebp]
	mov	dl, BYTE PTR __Tmp$249860[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@6:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	$LN588@erase@6

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@6
$LN194@erase@6:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@6
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	cmp	edx, 1
	jne	$LN586@erase@6

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@6

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN263@erase@6

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN267@erase@6

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@6

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@6
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@6

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@6

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN338@erase@6

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+20], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@6
$LN12@erase@6:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@6

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@6:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN454@erase@6

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN458@erase@6

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@6

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@6
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@6

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@6

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN529@erase@6

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+20], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@6
$LN8@erase@6:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@6

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@6:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN588@erase@6:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@6

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@6:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T250463[ebp], edx
	mov	eax, DWORD PTR $T250463[ebp]
	mov	DWORD PTR $T250457[ebp], eax
	mov	ecx, DWORD PTR $T250457[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@6:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T249606[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 134  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T250528 = -8						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T250528[ebp], eax
	mov	ecx, DWORD PTR $T250528[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$225105 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$225105[ebp], eax
	jmp	SHORT $LN6@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$225105[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase:
	mov	edx, DWORD PTR __Pnode$225105[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$225105[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$225105[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$225105[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T250621 = -12						; size = 4
$T250614 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T250614[ebp], eax
	mov	ecx, DWORD PTR $T250614[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250621[ebp], ecx
	mov	edx, DWORD PTR $T250621[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T250697 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T250697[ebp], eax
	mov	ecx, DWORD PTR $T250697[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T250707 = -28						; size = 4
$T250706 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T250707[ebp], eax
	cmp	DWORD PTR $T250707[ebp], 0
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR $T250707[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T250707[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T250707[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T250707[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR $T250707[ebp]
	mov	al, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [edx+20], al
	mov	ecx, DWORD PTR $T250707[ebp]
	mov	BYTE PTR [ecx+21], 0
	mov	edx, DWORD PTR $T250707[ebp]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T250706[ebp], eax
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv145 = -28						; size = 4
_this$ = -24						; size = 4
$T250769 = -19						; size = 1
$T250768 = -18						; size = 1
$T250760 = -17						; size = 1
$T250756 = -16						; size = 4
$T250749 = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T250768[ebp]
	mov	DWORD PTR $T250749[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T250769[ebp], dl
	lea	eax, DWORD PTR $T250760[ebp]
	mov	DWORD PTR $T250756[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], edx

; 53   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T250816 = -9						; size = 1
$T250812 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T250816[ebp]
	mov	DWORD PTR $T250812[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T250859 = -16						; size = 4
$T250838 = -12						; size = 4
$T250831 = -8						; size = 4
__Pnode$225216 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250831[ebp], edx
	mov	eax, DWORD PTR $T250831[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T250838[ebp], ecx
	mov	edx, DWORD PTR $T250838[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T250859[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T250859[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T250859[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T250859[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T250859[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$225216[ebp], ecx
	mov	edx, DWORD PTR __Pnode$225216[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225216[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$225216[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$225216[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$1
__ehfuncinfo$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
_TEXT	SEGMENT
$T250878 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
_arg4$ = 28						; size = 4
_arg5$ = 32						; size = 4
??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z PROC ; GetLocalizedText<int,int,int,int,int>, COMDAT

; 553  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T250878[ebp], 0

; 554  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 555  : 	text << arg1 << arg2 << arg3 << arg4 << arg5;

	mov	edx, DWORD PTR _arg5$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg4$[ebp]
	push	eax
	mov	ecx, DWORD PTR _arg3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8

; 556  : 
; 557  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 558  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 559  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 560  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 561  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T250878[ebp]
	or	eax, 1
	mov	DWORD PTR $T250878[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 562  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z$2:
	mov	eax, DWORD PTR $T250878[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@2
	and	DWORD PTR $T250878[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@HHHHH@@YA?AVCvString@@PBDABH1111@Z ENDP ; GetLocalizedText<int,int,int,int,int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@3

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_tValue$225294 = -24					; size = 4
_tValue$225289 = -20					; size = 4
_iType$225287 = -16					; size = 4
_bValid$225286 = -9					; size = 1
_iI$225282 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$225282[ebp], 0
	jmp	SHORT $LN7@ReadHashed
$LN6@ReadHashed:
	mov	ecx, DWORD PTR _iI$225282[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225282[ebp], ecx
$LN7@ReadHashed:
	mov	edx, DWORD PTR _iI$225282[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$225286[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$225287[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$225287[ebp], -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225289[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$225287[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _iType$225287[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	mov	eax, DWORD PTR _tValue$225289[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN3@ReadHashed:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	movzx	ecx, BYTE PTR _bValid$225286[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225294[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN2@ReadHashed:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed
$LN8@ReadHashed:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T251108 = -124						; size = 4
$T251013 = -72						; size = 4
_tDummy$225309 = -20					; size = 4
_iType$225303 = -16					; size = 4
_bValid$225302 = -9					; size = 1
_iI$225298 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_aiArray$ = 12						; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 390  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 391  : 	uint uiNumEntries;
; 392  : 
; 393  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 394  : 
; 395  : 	if(aiArray.size() < uiNumEntries)

	mov	ecx, DWORD PTR _aiArray$[ebp]
	mov	edx, DWORD PTR _aiArray$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	eax, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed@2

; 396  : 		aiArray.resize(uiNumEntries);

	mov	ecx, DWORD PTR _uiNumEntries$[ebp]
	mov	DWORD PTR $T251013[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T251013[ebp]
	push	edx
	mov	ecx, DWORD PTR _aiArray$[ebp]
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
$LN8@ReadHashed@2:

; 397  : 
; 398  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$225298[ebp], 0
	jmp	SHORT $LN7@ReadHashed@2
$LN6@ReadHashed@2:
	mov	eax, DWORD PTR _iI$225298[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225298[ebp], eax
$LN7@ReadHashed@2:
	mov	ecx, DWORD PTR _iI$225298[ebp]
	cmp	ecx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN9@ReadHashed@2

; 399  : 	{
; 400  : 		bool bValid;
; 401  : 		int iType = ReadHashed(kStream, &bValid);

	lea	edx, DWORD PTR _bValid$225302[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$225303[ebp], eax

; 402  : 		if(iType != -1)

	cmp	DWORD PTR _iType$225303[ebp], -1
	je	SHORT $LN4@ReadHashed@2

; 403  : 		{
; 404  : 			if (iType >= (int)aiArray.size())

	mov	ecx, DWORD PTR _aiArray$[ebp]
	mov	edx, DWORD PTR _aiArray$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _iType$225303[ebp], eax
	jl	SHORT $LN91@ReadHashed@2

; 405  : 				aiArray.resize(iType+1);

	push	0
	mov	ecx, DWORD PTR _iType$225303[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _aiArray$[ebp]
	call	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize

; 406  : 
; 407  : 			kStream >> aiArray[iType];

$LN91@ReadHashed@2:
	mov	edx, DWORD PTR _aiArray$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iType$225303[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T251108[ebp], edx
	mov	eax, DWORD PTR $T251108[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 408  : 		}
; 409  : 		else if(!bValid)

	jmp	SHORT $LN2@ReadHashed@2
$LN4@ReadHashed@2:
	movzx	ecx, BYTE PTR _bValid$225302[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@ReadHashed@2

; 410  : 		{
; 411  : 			TData tDummy;
; 412  : 			kStream >> tDummy;

	lea	edx, DWORD PTR _tDummy$225309[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN2@ReadHashed@2:

; 413  : 		}
; 414  : 	}

	jmp	$LN6@ReadHashed@2
$LN9@ReadHashed@2:

; 415  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@4:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@4

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@4
$LN1@operator@4:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$225322 = -8					; size = 4
_iI$225318 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$225318[ebp], 0
	jmp	SHORT $LN4@WriteHashe
$LN3@WriteHashe:
	mov	ecx, DWORD PTR _iI$225318[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225318[ebp], ecx
$LN4@WriteHashe:
	mov	edx, DWORD PTR _iI$225318[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$225318[ebp]
	mov	DWORD PTR _eType$225322[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$225322[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TerrainTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$225318[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe
$LN5@WriteHashe:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4TerrainTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TerrainTypes,int>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T251149 = -16						; size = 4
$T251133 = -12						; size = 4
_eType$225331 = -8					; size = 4
_iI$225327 = -4						; size = 4
_kStream$ = 8						; size = 4
_aArray$ = 12						; size = 4
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>, COMDAT

; 591  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 592  : 	kStream << aArray.size();

	mov	eax, DWORD PTR _aArray$[ebp]
	mov	ecx, DWORD PTR _aArray$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T251133[ebp], edx
	lea	eax, DWORD PTR $T251133[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 593  : 
; 594  : 	for(uint iI = 0; iI < aArray.size(); iI++)

	mov	DWORD PTR _iI$225327[ebp], 0
	jmp	SHORT $LN11@WriteHashe@2
$LN3@WriteHashe@2:
	mov	ecx, DWORD PTR _iI$225327[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225327[ebp], ecx
$LN11@WriteHashe@2:
	mov	edx, DWORD PTR _aArray$[ebp]
	mov	eax, DWORD PTR _aArray$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _iI$225327[ebp], ecx
	jae	SHORT $LN5@WriteHashe@2

; 595  : 	{
; 596  : 		const TType eType = static_cast<TType>(iI);

	mov	edx, DWORD PTR _iI$225327[ebp]
	mov	DWORD PTR _eType$225331[ebp], edx

; 597  : 		if(WriteHashed(kStream, eType))

	mov	eax, DWORD PTR _eType$225331[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@WriteHashe@2

; 598  : 		{
; 599  : 			kStream << aArray[iI];

	mov	eax, DWORD PTR _aArray$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iI$225327[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T251149[ebp], eax
	mov	ecx, DWORD PTR $T251149[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe@2:

; 600  : 		}
; 601  : 	}

	jmp	SHORT $LN3@WriteHashe@2
$LN5@WriteHashe@2:

; 602  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T251172 = -26						; size = 1
$T251171 = -25						; size = 1
$T251170 = -24						; size = 4
$T251169 = -20						; size = 4
__Off$251166 = -16					; size = 4
__Result$251167 = -12					; size = 4
__Cat$251158 = -4					; size = 1
$T251154 = -3						; size = 1
$T251153 = -2						; size = 1
$T251152 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvTraitEntry * *,CvTraitEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T251152[ebp], al
	mov	cl, BYTE PTR __Cat$251158[ebp]
	mov	BYTE PTR $T251153[ebp], cl
	mov	dl, BYTE PTR $T251152[ebp]
	mov	BYTE PTR $T251172[ebp], dl
	mov	al, BYTE PTR $T251154[ebp]
	mov	BYTE PTR $T251171[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T251170[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T251169[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T251169[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$251166[ebp], eax
	mov	ecx, DWORD PTR __Off$251166[ebp]
	mov	edx, DWORD PTR $T251170[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$251167[ebp], eax
	cmp	DWORD PTR __Off$251166[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$251166[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T251169[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$251166[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T251170[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$251167[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvTraitEntry@@PAPAV1@@stdext@@YAPAPAVCvTraitEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvTraitEntry * *,CvTraitEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z
_TEXT	SEGMENT
$T251179 = -16						; size = 4
$T251175 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z PROC ; std::_Allocate<FreeResourceXCities>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T251179[ebp], 0
	lea	eax, DWORD PTR $T251179[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251175[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T251175[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T251175[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UFreeResourceXCities@@@std@@YAPAUFreeResourceXCities@@IPAU1@@Z ENDP ; std::_Allocate<FreeResourceXCities>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T251193 = -16						; size = 4
$T251189 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvTraitEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T251193[ebp], 0
	lea	eax, DWORD PTR $T251193[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251189[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T251189[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T251189[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvTraitEntry@@@std@@YAPAPAVCvTraitEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvTraitEntry *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z
_TEXT	SEGMENT
$T251200 = -16						; size = 4
$T251196 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z PROC ; std::_Allocate<MayaBonusChoice>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T251200[ebp], 0
	lea	eax, DWORD PTR $T251200[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251196[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T251196[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T251196[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UMayaBonusChoice@@@std@@YAPAUMayaBonusChoice@@IPAU1@@Z ENDP ; std::_Allocate<MayaBonusChoice>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T251207 = -16						; size = 4
$T251203 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T251207[ebp], 0
	lea	eax, DWORD PTR $T251207[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251203[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T251203[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T251203[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T251237 = -28						; size = 4
__Vptr$251235 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$251235[ebp], eax
	mov	ecx, DWORD PTR __Vptr$251235[ebp]
	mov	DWORD PTR $T251237[ebp], ecx
	cmp	DWORD PTR $T251237[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T251237[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T251237[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUFreeResourceXCities@@IU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAXPAUFreeResourceXCities@@IABU1@AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<FreeResourceXCities *,unsigned int,FreeResourceXCities,std::allocator<FreeResourceXCities> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T251285 = -28						; size = 4
__Vptr$251283 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$251283[ebp], eax
	mov	ecx, DWORD PTR __Vptr$251283[ebp]
	mov	DWORD PTR $T251285[ebp], ecx
	cmp	DWORD PTR $T251285[ebp], 0
	je	SHORT $LN18@Uninit_fil@2
	mov	edx, DWORD PTR $T251285[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T251285[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@Uninit_fil@2
$LN18@Uninit_fil@2:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_fil@2:
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4TraitTypes@@IW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAXPAW4TraitTypes@@IABW41@AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum TraitTypes *,unsigned int,enum TraitTypes,std::allocator<enum TraitTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T251344 = -32						; size = 4
$T251343 = -28						; size = 4
__Vptr$251341 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@3
$LN5@Uninit_fil@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$251341[ebp], eax
	mov	ecx, DWORD PTR __Vptr$251341[ebp]
	mov	DWORD PTR $T251344[ebp], ecx
	cmp	DWORD PTR $T251344[ebp], 0
	je	SHORT $LN18@Uninit_fil@3
	mov	edx, DWORD PTR $T251344[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T251344[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T251344[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $LN19@Uninit_fil@3
$LN18@Uninit_fil@3:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@3:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T251343[ebp], eax
	jmp	SHORT $LN5@Uninit_fil@3
$LN4@Uninit_fil@3:
	jmp	SHORT $LN10@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@3
$LN2@Uninit_fil@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil@3:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@3

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@3
	ret	0
$LN10@Uninit_fil@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@3:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUMayaBonusChoice@@IU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAXPAUMayaBonusChoice@@IABU1@AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<MayaBonusChoice *,unsigned int,MayaBonusChoice,std::allocator<MayaBonusChoice> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z
_TEXT	SEGMENT
__Cat$251375 = -3					; size = 1
$T251371 = -2						; size = 1
$T251370 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T251370[ebp], al
	mov	cl, BYTE PTR __Cat$251375[ebp]
	mov	BYTE PTR $T251371[ebp], cl
	movzx	edx, BYTE PTR $T251370[ebp]
	push	edx
	movzx	eax, BYTE PTR $T251371[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@stdext@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z
_TEXT	SEGMENT
__Cat$251382 = -3					; size = 1
$T251379 = -2						; size = 1
$T251378 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T251378[ebp], al
	mov	cl, BYTE PTR __Cat$251382[ebp]
	mov	BYTE PTR $T251379[ebp], cl
	movzx	edx, BYTE PTR $T251378[ebp]
	push	edx
	movzx	eax, BYTE PTR $T251379[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@stdext@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z
_TEXT	SEGMENT
__Cat$251391 = -3					; size = 1
$T251387 = -2						; size = 1
$T251386 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T251386[ebp], al
	mov	cl, BYTE PTR __Cat$251391[ebp]
	mov	BYTE PTR $T251387[ebp], cl
	movzx	edx, BYTE PTR $T251386[ebp]
	push	edx
	movzx	eax, BYTE PTR $T251387[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@stdext@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T251419 = -28						; size = 4
__Vptr$251417 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$251417[ebp], ecx
	mov	edx, DWORD PTR __Vptr$251417[ebp]
	mov	DWORD PTR $T251419[ebp], edx
	cmp	DWORD PTR $T251419[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T251419[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T251419[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUFreeResourceXCities@@PAU1@V?$allocator@UFreeResourceXCities@@@std@@@std@@YAPAUFreeResourceXCities@@PAU1@00AAV?$allocator@UFreeResourceXCities@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<FreeResourceXCities *,FreeResourceXCities *,std::allocator<FreeResourceXCities> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T251467 = -28						; size = 4
__Vptr$251465 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$251465[ebp], ecx
	mov	edx, DWORD PTR __Vptr$251465[ebp]
	mov	DWORD PTR $T251467[ebp], edx
	cmp	DWORD PTR $T251467[ebp], 0
	je	SHORT $LN18@Uninit_cop@2
	mov	eax, DWORD PTR $T251467[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T251467[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@Uninit_cop@2
$LN18@Uninit_cop@2:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_cop@2:
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4TraitTypes@@PAW41@V?$allocator@W4TraitTypes@@@std@@@std@@YAPAW4TraitTypes@@PAW41@00AAV?$allocator@W4TraitTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum TraitTypes *,enum TraitTypes *,std::allocator<enum TraitTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T251526 = -32						; size = 4
$T251525 = -28						; size = 4
__Vptr$251523 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$251523[ebp], ecx
	mov	edx, DWORD PTR __Vptr$251523[ebp]
	mov	DWORD PTR $T251526[ebp], edx
	cmp	DWORD PTR $T251526[ebp], 0
	je	SHORT $LN18@Uninit_cop@3
	mov	eax, DWORD PTR $T251526[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T251526[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T251526[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_cop@3
$LN18@Uninit_cop@3:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop@3:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T251525[ebp], ecx
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUMayaBonusChoice@@PAU1@V?$allocator@UMayaBonusChoice@@@std@@@std@@YAPAUMayaBonusChoice@@PAU1@00AAV?$allocator@UMayaBonusChoice@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<MayaBonusChoice *,MayaBonusChoice *,std::allocator<MayaBonusChoice> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T251580 = -2092					; size = 4
$T251579 = -2088					; size = 4
$T251578 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T251578[ebp], eax
	mov	ecx, DWORD PTR $T251578[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T251579[ebp], eax
	mov	eax, DWORD PTR $T251579[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T251580[ebp], eax
	mov	ecx, DWORD PTR $T251580[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T251599 = -8						; size = 4
$T251595 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T251595[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T251595[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T251599[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T251599[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T251602 = -8						; size = 4
_i$172577 = -4						; size = 4
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T251602[ebp], eax
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR $T251602[ebp]
	mov	DWORD PTR [eax], ecx

; 126  : 	if(iDefault == 0)

	cmp	DWORD PTR _iDefault$[ebp], 0
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	mov	edx, DWORD PTR _count$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 129  : 	}
; 130  : 	else

	jmp	SHORT $LN6@Initialize
$LN5@Initialize:

; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	mov	DWORD PTR _i$172577[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	edx, DWORD PTR _i$172577[ebp]
	add	edx, 1
	mov	DWORD PTR _i$172577[ebp], edx
$LN3@Initialize:
	mov	eax, DWORD PTR _i$172577[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jae	SHORT $LN6@Initialize

; 133  : 			pArray[i] = iDefault;

	mov	ecx, DWORD PTR _pArray$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$172577[ebp]
	mov	ecx, DWORD PTR _iDefault$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN2@Initialize
$LN6@Initialize:

; 134  : 	}
; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T251635 = -30						; size = 1
$T251622 = -29						; size = 1
$T251618 = -28						; size = 4
$T251611 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T251635[ebp]
	mov	DWORD PTR $T251611[ebp], eax
	lea	ecx, DWORD PTR $T251622[ebp]
	mov	DWORD PTR $T251618[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::~vector<enum TraitTypes,std::allocator<enum TraitTypes> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::~_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >::~_Vector_val<enum TraitTypes,std::allocator<enum TraitTypes> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$251851 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$251851[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$251851[ebp], 0
	jbe	SHORT $LN11@Buy@4
	mov	eax, DWORD PTR __Count$251851[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@4
$LN11@Buy@4:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@4:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@4:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T251917 = -28						; size = 4
$T251916 = -24						; size = 4
$T251912 = -20						; size = 4
$T251911 = -16						; size = 4
$T251900 = -12						; size = 4
$T251899 = -8						; size = 4
__Cat$251907 = -2					; size = 1
$T251905 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T251912[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T251911[ebp], ecx
	mov	edx, DWORD PTR $T251912[ebp]
	mov	DWORD PTR $T251900[ebp], edx
	mov	eax, DWORD PTR $T251911[ebp]
	mov	DWORD PTR $T251899[ebp], eax
	mov	cl, BYTE PTR __Cat$251907[ebp]
	mov	BYTE PTR $T251905[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T251917[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T251916[ebp], eax
	mov	ecx, DWORD PTR $T251916[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$251934 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$251934[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$251934[ebp], 0
	jbe	SHORT $LN11@Buy@5
	mov	eax, DWORD PTR __Count$251934[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@5
$LN11@Buy@5:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@5:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@5:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ; std::_Allocate<enum TraitTypes>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T252028 = -32						; size = 4
$T252027 = -28						; size = 4
$T252023 = -24						; size = 4
$T252022 = -20						; size = 4
$T252004 = -16						; size = 4
$T252003 = -12						; size = 4
$T251987 = -8						; size = 4
__Cat$252010 = -2					; size = 1
$T252007 = -1						; size = 1
?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T252023[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T252022[ebp], ecx
	mov	edx, DWORD PTR $T252023[ebp]
	mov	DWORD PTR $T252004[ebp], edx
	mov	eax, DWORD PTR $T252022[ebp]
	mov	DWORD PTR $T252003[ebp], eax
	mov	cl, BYTE PTR __Cat$252010[ebp]
	mov	BYTE PTR $T252007[ebp], cl
	mov	edx, DWORD PTR $T252003[ebp]
	mov	DWORD PTR $T251987[ebp], edx
	jmp	SHORT $LN12@Tidy@5
$LN11@Tidy@5:
	mov	eax, DWORD PTR $T251987[ebp]
	add	eax, 4
	mov	DWORD PTR $T251987[ebp], eax
$LN12@Tidy@5:
	mov	ecx, DWORD PTR $T251987[ebp]
	cmp	ecx, DWORD PTR $T252004[ebp]
	je	SHORT $LN4@Tidy@5
	jmp	SHORT $LN11@Tidy@5
$LN4@Tidy@5:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T252028[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T252027[ebp], eax
	mov	ecx, DWORD PTR $T252027[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T252046 = -80						; size = 28
$T252045 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T252046[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T252045[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T252045[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T252046[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252045[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T252045[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T252045[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T252046[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T252046[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T252045[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T252068 = -80						; size = 28
$T252067 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T252068[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T252067[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T252067[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T252068[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252067[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T252067[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T252067[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T252068[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T252068[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T252067[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4TraitTypes@@V?$allocator@W4TraitTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum TraitTypes,std::allocator<enum TraitTypes> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T252093 = -16						; size = 4
$T252089 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T252093[ebp], 0
	lea	eax, DWORD PTR $T252093[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252089[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T252089[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T252089[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T252100 = -16						; size = 4
$T252096 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z PROC ; std::_Allocate<enum TraitTypes>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T252100[ebp], 0
	lea	eax, DWORD PTR $T252100[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252096[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T252096[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T252096[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4TraitTypes@@@std@@YAPAW4TraitTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum TraitTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2
__ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv147 = -152						; size = 4
tv172 = -148						; size = 4
tv93 = -144						; size = 4
_this$ = -140						; size = 4
$T252203 = -136						; size = 4
$T252147 = -42						; size = 1
$T252134 = -41						; size = 1
$T252130 = -40						; size = 4
$T252123 = -32						; size = 4
$T252116 = -21						; size = 1
$T252112 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1903 : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T252116[ebp]
	mov	DWORD PTR $T252112[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T252203[ebp], eax
	lea	ecx, DWORD PTR $T252147[ebp]
	mov	DWORD PTR $T252123[ebp], ecx
	lea	edx, DWORD PTR $T252134[ebp]
	mov	DWORD PTR $T252130[ebp], edx
	mov	eax, DWORD PTR $T252203[ebp]
	mov	DWORD PTR tv172[ebp], eax
	mov	ecx, DWORD PTR $T252203[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, DWORD PTR $T252203[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 0

; 1904 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T252203[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2
__ehfuncinfo$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T252269 = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1957 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1958 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1959 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T252269[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T252269[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T252269[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -356						; size = 4
$T252374 = -76						; size = 4
$T252352 = -72						; size = 4
$T252377 = -68						; size = 4
$T252285 = -40						; size = 8
$T252284 = -32						; size = 8
$T252283 = -24						; size = 8
$T252282 = -16						; size = 8
$T252281 = -8						; size = 8
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::vector<bool,std::allocator<bool> >::clear, COMDAT
; _this$ = ecx

; 2243 : 		{	// erase all elements

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	DWORD PTR _this$[ebp], ecx

; 2244 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T252282[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T252281[ebp], ecx
	mov	DWORD PTR $T252281[ebp+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T252352[ebp], ecx
	mov	edx, DWORD PTR $T252352[ebp]
	mov	DWORD PTR $T252377[ebp], edx
	mov	eax, DWORD PTR $T252377[ebp]
	mov	DWORD PTR $T252374[ebp], eax
	mov	ecx, DWORD PTR $T252374[ebp]
	mov	DWORD PTR $T252284[ebp], ecx
	mov	DWORD PTR $T252284[ebp+4], 0
	mov	edx, DWORD PTR $T252284[ebp]
	mov	eax, DWORD PTR $T252284[ebp+4]
	mov	DWORD PTR $T252283[ebp], edx
	mov	DWORD PTR $T252283[ebp+4], eax
	mov	ecx, DWORD PTR $T252281[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T252281[ebp]
	push	edx
	mov	eax, DWORD PTR $T252283[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T252283[ebp]
	push	ecx
	lea	edx, DWORD PTR $T252285[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase

; 2245 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::clear
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T252879 = -30						; size = 1
$T252866 = -29						; size = 1
$T252862 = -28						; size = 4
$T252855 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T252879[ebp]
	mov	DWORD PTR $T252855[ebp], eax
	lea	ecx, DWORD PTR $T252866[ebp]
	mov	DWORD PTR $T252862[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::~_Vector_val<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T253111 = -52						; size = 4
$T253100 = -48						; size = 4
$T253099 = -44						; size = 4
__Cat$253106 = -40					; size = 1
$T253104 = -39						; size = 1
__Ptr$210227 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$210227[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T253111[ebp], edx
	mov	eax, DWORD PTR $T253111[ebp]
	mov	DWORD PTR $T253100[ebp], eax
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR $T253099[ebp], ecx
	mov	dl, BYTE PTR __Cat$253106[ebp]
	mov	BYTE PTR $T253104[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@7:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T253146 = -12						; size = 4
$T253124 = -8						; size = 4
$T253114 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 1984 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1985 : 		return (iterator(_VEC_ITER_BASE(_Myvec.begin())));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253124[ebp], ecx
	mov	edx, DWORD PTR $T253124[ebp]
	mov	DWORD PTR $T253114[ebp], edx
	mov	eax, DWORD PTR $T253114[ebp]
	mov	DWORD PTR $T253146[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T253146[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1986 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T253202 = -24						; size = 4
$T253182 = -20						; size = 4
$T253160 = -16						; size = 4
$T253184 = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1995 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1996 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253160[ebp], ecx
	mov	edx, DWORD PTR $T253160[ebp]
	mov	DWORD PTR $T253184[ebp], edx
	mov	eax, DWORD PTR $T253184[ebp]
	mov	DWORD PTR $T253182[ebp], eax
	mov	ecx, DWORD PTR $T253182[ebp]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], 0

; 1997 : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN1@end

; 1998 : 			_Tmp += _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T253202[ebp], ecx
	mov	edx, DWORD PTR $T253202[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN1@end:

; 1999 : 		return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2000 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -372						; size = 4
__Tmp$253719 = -368					; size = 8
$T253698 = -360						; size = 4
$T253676 = -356						; size = 4
$T253701 = -352						; size = 4
$T253541 = -228						; size = 4
$T253519 = -224						; size = 4
$T253544 = -220						; size = 4
$T253507 = -216						; size = 8
$T253506 = -208						; size = 8
$T253505 = -200						; size = 8
__Cat$253500 = -164					; size = 1
$T253498 = -163						; size = 1
$T253497 = -162						; size = 1
$T253496 = -161						; size = 1
$T253352 = -136						; size = 4
$T253330 = -132						; size = 4
$T253355 = -128						; size = 4
$T253208 = -60						; size = 8
$T253207 = -52						; size = 8
$T253206 = -44						; size = 8
$T253205 = -36						; size = 8
__Off$ = -28						; size = 4
__Last$ = -24						; size = 8
__First$ = -16						; size = 8
__Next$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2221 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	mov	DWORD PTR _this$[ebp], ecx

; 2222 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2223 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2224 : 		size_type _Off = _First - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T253330[ebp], ecx
	mov	edx, DWORD PTR $T253330[ebp]
	mov	DWORD PTR $T253355[ebp], edx
	mov	eax, DWORD PTR $T253355[ebp]
	mov	DWORD PTR $T253352[ebp], eax
	mov	ecx, DWORD PTR $T253352[ebp]
	mov	DWORD PTR $T253205[ebp], ecx
	mov	DWORD PTR $T253205[ebp+4], 0
	mov	edx, DWORD PTR __First$[ebp]
	sub	edx, DWORD PTR $T253205[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __First$[ebp+4]
	sub	edx, DWORD PTR $T253205[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2225 : 
; 2226 :  #if _HAS_ITERATOR_DEBUGGING
; 2227 : 		if (_Last < _First || end() < _Last)
; 2228 : 			_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2229 : 		iterator _Next = std::copy(_Last, end(), _First);
; 2230 : 		size_type _Newsize = _Next - begin();
; 2231 : 		_Orphan_range(_Newsize, _Mysize);
; 2232 : 		_Trim(_Newsize);
; 2233 : 
; 2234 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 2235 : 		iterator _Next = std::copy(_Last, end(), _First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T253507[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T253507[ebp+4], ecx
	lea	edx, DWORD PTR $T253206[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T253506[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T253506[ebp+4], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T253505[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR $T253505[ebp+4], ecx
	xor	edx, edx
	mov	BYTE PTR $T253496[ebp], dl
	mov	al, BYTE PTR __Cat$253500[ebp]
	mov	BYTE PTR $T253497[ebp], al
	movzx	ecx, BYTE PTR $T253496[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T253497[ebp]
	push	edx
	movzx	eax, BYTE PTR $T253498[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253507[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T253507[ebp]
	push	edx
	mov	eax, DWORD PTR $T253506[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T253506[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253505[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T253505[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H

; 2236 : 		_Trim(_Next - begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T253519[ebp], eax
	mov	ecx, DWORD PTR $T253519[ebp]
	mov	DWORD PTR $T253544[ebp], ecx
	mov	edx, DWORD PTR $T253544[ebp]
	mov	DWORD PTR $T253541[ebp], edx
	mov	eax, DWORD PTR $T253541[ebp]
	mov	DWORD PTR $T253207[ebp], eax
	mov	DWORD PTR $T253207[ebp+4], 0
	mov	ecx, DWORD PTR __Next$[ebp]
	sub	ecx, DWORD PTR $T253207[ebp]
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Next$[ebp+4]
	sub	ecx, DWORD PTR $T253207[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2237 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2238 : 
; 2239 : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T253676[ebp], eax
	mov	ecx, DWORD PTR $T253676[ebp]
	mov	DWORD PTR $T253701[ebp], ecx
	mov	edx, DWORD PTR $T253701[ebp]
	mov	DWORD PTR $T253698[ebp], edx
	mov	eax, DWORD PTR $T253698[ebp]
	mov	DWORD PTR $T253208[ebp], eax
	mov	DWORD PTR $T253208[ebp+4], 0
	mov	ecx, DWORD PTR $T253208[ebp]
	mov	edx, DWORD PTR $T253208[ebp+4]
	mov	DWORD PTR __Tmp$253719[ebp], ecx
	mov	DWORD PTR __Tmp$253719[ebp+4], edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$253719[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$253719[ebp]
	mov	edx, DWORD PTR __Tmp$253719[ebp+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2240 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T253756 = -30						; size = 1
$T253743 = -29						; size = 1
$T253739 = -28						; size = 4
$T253732 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T253756[ebp]
	mov	DWORD PTR $T253732[ebp], eax
	lea	ecx, DWORD PTR $T253743[ebp]
	mov	DWORD PTR $T253739[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ; stdext::unchecked_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T253995 = -52						; size = 4
$T253977 = -48						; size = 4
$T253976 = -44						; size = 4
$T253960 = -40						; size = 4
__Cat$253989 = -36					; size = 1
$T253987 = -35						; size = 1
__Ptr$210588 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@8

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ; stdext::unchecked_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$210588[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T253995[ebp], edx
	mov	eax, DWORD PTR $T253995[ebp]
	mov	DWORD PTR $T253977[ebp], eax
	mov	ecx, DWORD PTR __Ptr$210588[ebp]
	mov	DWORD PTR $T253976[ebp], ecx
	mov	dl, BYTE PTR __Cat$253989[ebp]
	mov	BYTE PTR $T253987[ebp], dl
	mov	eax, DWORD PTR $T253976[ebp]
	mov	DWORD PTR $T253960[ebp], eax
	jmp	SHORT $LN44@erase@8
$LN43@erase@8:
	mov	ecx, DWORD PTR $T253960[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T253960[ebp], ecx
$LN44@erase@8:
	mov	edx, DWORD PTR $T253960[ebp]
	cmp	edx, DWORD PTR $T253977[ebp]
	je	SHORT $LN36@erase@8
	jmp	SHORT $LN43@erase@8
$LN36@erase@8:

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$210588[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@8:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ; std::_Allocate<Firaxis::Array<int,6> >
PUBLIC	?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$254012 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@6
	jmp	SHORT $LN3@Buy@6
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$254012[ebp], 178956970 ; 0aaaaaaaH
	cmp	DWORD PTR __Count$254012[ebp], 0
	jbe	SHORT $LN11@Buy@6
	mov	eax, DWORD PTR __Count$254012[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@6
$LN11@Buy@6:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@6:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@6

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@6:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ; std::_Allocate<Firaxis::Array<int,6> >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@6:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@6:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T254106 = -32						; size = 4
$T254105 = -28						; size = 4
$T254101 = -24						; size = 4
$T254100 = -20						; size = 4
$T254082 = -16						; size = 4
$T254081 = -12						; size = 4
$T254065 = -8						; size = 4
__Cat$254088 = -2					; size = 1
$T254085 = -1						; size = 1
?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254101[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T254100[ebp], ecx
	mov	edx, DWORD PTR $T254101[ebp]
	mov	DWORD PTR $T254082[ebp], edx
	mov	eax, DWORD PTR $T254100[ebp]
	mov	DWORD PTR $T254081[ebp], eax
	mov	cl, BYTE PTR __Cat$254088[ebp]
	mov	BYTE PTR $T254085[ebp], cl
	mov	edx, DWORD PTR $T254081[ebp]
	mov	DWORD PTR $T254065[ebp], edx
	jmp	SHORT $LN12@Tidy@6
$LN11@Tidy@6:
	mov	eax, DWORD PTR $T254065[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254065[ebp], eax
$LN12@Tidy@6:
	mov	ecx, DWORD PTR $T254065[ebp]
	cmp	ecx, DWORD PTR $T254082[ebp]
	je	SHORT $LN4@Tidy@6
	jmp	SHORT $LN11@Tidy@6
$LN4@Tidy@6:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR $T254106[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T254105[ebp], eax
	mov	ecx, DWORD PTR $T254105[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T254221 = -44						; size = 4
$T254198 = -40						; size = 4
$T254176 = -36						; size = 4
$T254200 = -32						; size = 4
$T254149 = -28						; size = 4
$T254127 = -24						; size = 4
$T254151 = -20						; size = 4
$T254115 = -16						; size = 8
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2011 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2012 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T254127[ebp], ecx
	mov	edx, DWORD PTR $T254127[ebp]
	mov	DWORD PTR $T254151[ebp], edx
	mov	eax, DWORD PTR $T254151[ebp]
	mov	DWORD PTR $T254149[ebp], eax
	mov	ecx, DWORD PTR $T254149[ebp]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], 0

; 2013 : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN1@Make_iter

; 2014 : 			_Tmp += _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T254176[ebp], ecx
	mov	edx, DWORD PTR $T254176[ebp]
	mov	DWORD PTR $T254200[ebp], edx
	mov	eax, DWORD PTR $T254200[ebp]
	mov	DWORD PTR $T254198[ebp], eax
	mov	ecx, DWORD PTR $T254198[ebp]
	mov	DWORD PTR $T254115[ebp], ecx
	mov	DWORD PTR $T254115[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T254115[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T254115[ebp+4]
	mov	DWORD PTR $T254221[ebp], edx
	mov	eax, DWORD PTR $T254221[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN1@Make_iter:

; 2015 : 		return (_Tmp);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv142 = -188						; size = 4
tv149 = -184						; size = 4
tv158 = -180						; size = 4
_this$ = -176						; size = 4
__Tmp$254318 = -120					; size = 4
$T254301 = -116						; size = 4
$T254285 = -112						; size = 4
$T254275 = -108						; size = 4
__Count$254260 = -36					; size = 4
__Maxsize$254250 = -32					; size = 4
$T254229 = -28						; size = 4
$T254228 = -24						; size = 4
$T254227 = -20						; size = 4
$T254226 = -16						; size = 4
$T254225 = -12						; size = 4
$T254224 = -8						; size = 4
__Words$ = -4						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 2360 : 		{	// trim base vector to exact length in bits

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	DWORD PTR _this$[ebp], ecx

; 2361 : 		if (max_size() < _Size)

	mov	DWORD PTR __Count$254260[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$254260[ebp], 0
	jbe	SHORT $LN14@Trim
	mov	eax, DWORD PTR __Count$254260[ebp]
	mov	DWORD PTR tv158[ebp], eax
	jmp	SHORT $LN10@Trim
$LN14@Trim:
	mov	DWORD PTR tv158[ebp], 1
$LN10@Trim:
	mov	ecx, DWORD PTR tv158[ebp]
	mov	DWORD PTR __Maxsize$254250[ebp], ecx
	cmp	DWORD PTR __Maxsize$254250[ebp], 134217727 ; 07ffffffH
	jae	SHORT $LN8@Trim
	mov	edx, DWORD PTR __Maxsize$254250[ebp]
	shl	edx, 5
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN6@Trim
$LN8@Trim:
	mov	DWORD PTR tv149[ebp], -1
$LN6@Trim:
	mov	eax, DWORD PTR tv149[ebp]
	cmp	eax, DWORD PTR __Size$[ebp]
	jae	SHORT $LN22@Trim

; 2362 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen

; 2363 : 		size_type _Words = _Nw(_Size);

$LN22@Trim:
	mov	ecx, DWORD PTR __Size$[ebp]
	add	ecx, 31					; 0000001fH
	shr	ecx, 5
	mov	DWORD PTR __Words$[ebp], ecx

; 2364 : 
; 2365 : 		if (_Words < _Myvec.size())

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T254275[ebp], edx
	mov	eax, DWORD PTR $T254275[ebp]
	mov	ecx, DWORD PTR $T254275[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR __Words$[ebp], edx
	jae	SHORT $LN2@Trim

; 2366 : 			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T254285[ebp], ecx
	mov	edx, DWORD PTR $T254285[ebp]
	mov	DWORD PTR $T254225[ebp], edx
	mov	eax, DWORD PTR $T254225[ebp]
	mov	DWORD PTR $T254224[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254301[ebp], edx
	mov	eax, DWORD PTR $T254301[ebp]
	mov	DWORD PTR $T254227[ebp], eax
	mov	ecx, DWORD PTR $T254227[ebp]
	mov	DWORD PTR __Tmp$254318[ebp], ecx
	mov	edx, DWORD PTR __Words$[ebp]
	mov	eax, DWORD PTR __Tmp$254318[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$254318[ebp], ecx
	mov	edx, DWORD PTR __Tmp$254318[ebp]
	mov	DWORD PTR $T254228[ebp], edx
	mov	eax, DWORD PTR $T254228[ebp]
	mov	DWORD PTR $T254226[ebp], eax
	mov	ecx, DWORD PTR $T254224[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254226[ebp]
	push	edx
	lea	eax, DWORD PTR $T254229[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN2@Trim:

; 2367 : 		_Mysize = _Size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Size$[ebp]
	mov	DWORD PTR [ecx], edx

; 2368 : 		_Size %= _VBITS;

	mov	eax, DWORD PTR __Size$[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	DWORD PTR __Size$[ebp], edx

; 2369 : 		if (0 < _Size)

	cmp	DWORD PTR __Size$[ebp], 0
	jbe	SHORT $LN4@Trim

; 2370 : 			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Words$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR tv142[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR __Size$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR tv142[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Trim:

; 2371 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$254433 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@7
	jmp	SHORT $LN3@Buy@7
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$254433[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$254433[ebp], 0
	jbe	SHORT $LN11@Buy@7
	mov	eax, DWORD PTR __Count$254433[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@7
$LN11@Buy@7:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@7:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@7

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@7:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@7:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@7:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T254499 = -28						; size = 4
$T254498 = -24						; size = 4
$T254494 = -20						; size = 4
$T254493 = -16						; size = 4
$T254482 = -12						; size = 4
$T254481 = -8						; size = 4
__Cat$254489 = -2					; size = 1
$T254487 = -1						; size = 1
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254494[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T254493[ebp], ecx
	mov	edx, DWORD PTR $T254494[ebp]
	mov	DWORD PTR $T254482[ebp], edx
	mov	eax, DWORD PTR $T254493[ebp]
	mov	DWORD PTR $T254481[ebp], eax
	mov	cl, BYTE PTR __Cat$254489[ebp]
	mov	BYTE PTR $T254487[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T254499[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T254498[ebp], eax
	mov	ecx, DWORD PTR $T254498[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254503 = -80						; size = 28
$T254502 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254503[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T254502[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T254502[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T254503[ebp]
	push	eax
	lea	ecx, DWORD PTR $T254502[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T254502[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254502[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T254503[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254503[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254502[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2
__ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T254525 = -80						; size = 28
$T254524 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 2374 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2375 : 		_THROW(length_error, "vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254525[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T254524[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T254524[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T254525[ebp]
	push	eax
	lea	ecx, DWORD PTR $T254524[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T254524[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254524[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T254525[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@7:

; 2376 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0:
	lea	ecx, DWORD PTR $T254525[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2:
	lea	ecx, DWORD PTR $T254524[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T254636 = -52						; size = 4
$T254625 = -48						; size = 4
$T254624 = -44						; size = 4
__Cat$254632 = -40					; size = 1
$T254630 = -39						; size = 1
__Ptr$211089 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@9

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$211089[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254636[ebp], edx
	mov	eax, DWORD PTR $T254636[ebp]
	mov	DWORD PTR $T254625[ebp], eax
	mov	ecx, DWORD PTR __Ptr$211089[ebp]
	mov	DWORD PTR $T254624[ebp], ecx
	mov	dl, BYTE PTR __Cat$254632[ebp]
	mov	BYTE PTR $T254630[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$211089[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@9:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T254640 = -80						; size = 28
$T254639 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T254640[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T254639[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T254639[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T254640[ebp]
	push	eax
	lea	ecx, DWORD PTR $T254639[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T254639[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T254639[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T254640[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@8:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T254640[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T254639[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1603 : 		if (_Off == 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jne	SHORT $LN3@operator@5

; 1604 : 			return (*this); // early out

	mov	eax, DWORD PTR _this$[ebp]
	jmp	$LN6@operator@5
$LN3@operator@5:

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	cmp	DWORD PTR __Off$[ebp], 0
	jge	SHORT $LN2@operator@5
	xor	eax, eax
	sub	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jae	SHORT $LN2@operator@5

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	or	eax, -1
	sub	eax, DWORD PTR [edx+4]
	shr	eax, 5
	lea	ecx, DWORD PTR [eax*4+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1618 : 			this->_Myoff %= _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1619 : 			}
; 1620 : 		else

	jmp	SHORT $LN1@operator@5
$LN2@operator@5:

; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN1@operator@5:

; 1625 : 			}
; 1626 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@operator@5:

; 1627 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator>><int>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >
; Function compile flags: /Odtp
;	COMDAT ??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z PROC ; operator>><Firaxis::Array<int,6> >, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ENDP ; operator>><Firaxis::Array<int,6> >
_TEXT	ENDS
PUBLIC	??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z ; operator<<<int,6>
; Function compile flags: /Odtp
;	COMDAT ??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z
_TEXT	SEGMENT
$T254743 = -68						; size = 8
$T254742 = -60						; size = 4
$T254741 = -56						; size = 4
$T254723 = -52						; size = 4
__ChkFirst$254736 = -48					; size = 4
__ChkLast$254737 = -44					; size = 4
$T254700 = -40						; size = 4
$T254691 = -36						; size = 4
$T254679 = -32						; size = 4
$T254682 = -28						; size = 4
$T254670 = -24						; size = 8
$T254669 = -16						; size = 4
$T254668 = -12						; size = 4
$T254667 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z PROC ; operator<<<Firaxis::Array<int,6> >, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T254667[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T254667[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR $T254682[ebp], eax
	mov	edx, DWORD PTR $T254667[ebp]
	mov	DWORD PTR $T254679[ebp], edx
	lea	eax, DWORD PTR $T254682[ebp]
	push	eax
	mov	ecx, DWORD PTR $T254679[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T254691[ebp], edx
	mov	eax, DWORD PTR $T254691[ebp]
	mov	DWORD PTR $T254668[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254700[ebp], edx
	mov	eax, DWORD PTR $T254700[ebp]
	mov	DWORD PTR $T254669[ebp], eax
	mov	ecx, DWORD PTR $T254667[ebp]
	mov	DWORD PTR $T254743[ebp], ecx
	mov	edx, DWORD PTR $T254667[ebp+4]
	mov	DWORD PTR $T254743[ebp+4], edx
	mov	eax, DWORD PTR $T254668[ebp]
	mov	DWORD PTR $T254742[ebp], eax
	mov	ecx, DWORD PTR $T254669[ebp]
	mov	DWORD PTR $T254741[ebp], ecx
	mov	edx, DWORD PTR $T254741[ebp]
	mov	DWORD PTR __ChkFirst$254736[ebp], edx
	mov	eax, DWORD PTR $T254742[ebp]
	mov	DWORD PTR __ChkLast$254737[ebp], eax
	jmp	SHORT $LN24@operator@6
$LN18@operator@6:
	mov	ecx, DWORD PTR __ChkFirst$254736[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __ChkFirst$254736[ebp], ecx
$LN24@operator@6:
	mov	edx, DWORD PTR __ChkFirst$254736[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$254737[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@6
	mov	eax, DWORD PTR __ChkFirst$254736[ebp]
	mov	DWORD PTR $T254723[ebp], eax
	mov	ecx, DWORD PTR $T254723[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254743[ebp]
	push	edx
	call	??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z ; operator<<<int,6>
	add	esp, 8
	jmp	SHORT $LN18@operator@6
$LN17@operator@6:
	mov	eax, DWORD PTR $T254743[ebp]
	mov	DWORD PTR $T254670[ebp], eax
	mov	ecx, DWORD PTR $T254743[ebp+4]
	mov	DWORD PTR $T254670[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6V?$Array@H$05@Firaxis@@@@YAAAVFDataStream@@AAV0@ABV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ENDP ; operator<<<Firaxis::Array<int,6> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T254766 = -26						; size = 1
$T254765 = -25						; size = 1
$T254764 = -24						; size = 4
$T254763 = -20						; size = 4
__Off$254759 = -16					; size = 4
__Result$254760 = -12					; size = 4
__Cat$254751 = -4					; size = 1
$T254748 = -3						; size = 1
$T254747 = -2						; size = 1
$T254746 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T254746[ebp], al
	mov	cl, BYTE PTR __Cat$254751[ebp]
	mov	BYTE PTR $T254747[ebp], cl
	mov	dl, BYTE PTR $T254746[ebp]
	mov	BYTE PTR $T254766[ebp], dl
	mov	al, BYTE PTR $T254748[ebp]
	mov	BYTE PTR $T254765[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T254764[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T254763[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T254763[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$254759[ebp], eax
	mov	ecx, DWORD PTR __Off$254759[ebp]
	mov	edx, DWORD PTR $T254764[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$254760[ebp], eax
	cmp	DWORD PTR __Off$254759[ebp], 0
	jle	SHORT $LN8@unchecked_@2
	mov	ecx, DWORD PTR __Off$254759[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T254763[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$254759[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T254764[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	mov	eax, DWORD PTR __Result$254760[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z
_TEXT	SEGMENT
$T254802 = -22						; size = 1
$T254801 = -21						; size = 1
$T254800 = -20						; size = 4
$T254799 = -16						; size = 4
_i$254794 = -12						; size = 4
__Cat$254774 = -4					; size = 1
$T254771 = -3						; size = 1
$T254770 = -2						; size = 1
$T254769 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z PROC ; stdext::unchecked_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T254769[ebp], al
	mov	cl, BYTE PTR __Cat$254774[ebp]
	mov	BYTE PTR $T254770[ebp], cl
	mov	dl, BYTE PTR $T254769[ebp]
	mov	BYTE PTR $T254802[ebp], dl
	mov	al, BYTE PTR $T254771[ebp]
	mov	BYTE PTR $T254801[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T254800[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T254799[ebp], edx
	jmp	SHORT $LN9@unchecked_@3
$LN8@unchecked_@3:
	mov	eax, DWORD PTR $T254800[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254800[ebp], eax
	mov	ecx, DWORD PTR $T254799[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T254799[ebp], ecx
$LN9@unchecked_@3:
	mov	edx, DWORD PTR $T254799[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN10@unchecked_@3
	mov	DWORD PTR _i$254794[ebp], 0
	jmp	SHORT $LN14@unchecked_@3
$LN13@unchecked_@3:
	mov	eax, DWORD PTR _i$254794[ebp]
	add	eax, 1
	mov	DWORD PTR _i$254794[ebp], eax
$LN14@unchecked_@3:
	cmp	DWORD PTR _i$254794[ebp], 6
	jae	SHORT $LN15@unchecked_@3
	mov	ecx, DWORD PTR _i$254794[ebp]
	mov	edx, DWORD PTR $T254800[ebp]
	mov	eax, DWORD PTR _i$254794[ebp]
	mov	esi, DWORD PTR $T254799[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN13@unchecked_@3
$LN15@unchecked_@3:
	jmp	SHORT $LN8@unchecked_@3
$LN10@unchecked_@3:
	mov	eax, DWORD PTR $T254800[ebp]

; 3607 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ENDP ; stdext::unchecked_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z
_TEXT	SEGMENT
$T254809 = -16						; size = 4
$T254805 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z PROC ; std::_Allocate<Firaxis::Array<int,6> >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T254809[ebp], 0
	lea	eax, DWORD PTR $T254809[ebp]
	push	eax
	lea	ecx, DWORD PTR $T254805[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T254805[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T254805[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ENDP ; std::_Allocate<Firaxis::Array<int,6> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T254832 = -26						; size = 1
$T254831 = -25						; size = 1
$T254830 = -24						; size = 4
$T254829 = -20						; size = 4
__Off$254825 = -16					; size = 4
__Result$254826 = -12					; size = 4
__Cat$254817 = -4					; size = 1
$T254814 = -3						; size = 1
$T254813 = -2						; size = 1
$T254812 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T254812[ebp], al
	mov	cl, BYTE PTR __Cat$254817[ebp]
	mov	BYTE PTR $T254813[ebp], cl
	mov	dl, BYTE PTR $T254812[ebp]
	mov	BYTE PTR $T254832[ebp], dl
	mov	al, BYTE PTR $T254814[ebp]
	mov	BYTE PTR $T254831[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T254830[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T254829[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T254829[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$254825[ebp], eax
	mov	ecx, DWORD PTR __Off$254825[ebp]
	mov	edx, DWORD PTR $T254830[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$254826[ebp], eax
	cmp	DWORD PTR __Off$254825[ebp], 0
	jle	SHORT $LN8@unchecked_@4
	mov	ecx, DWORD PTR __Off$254825[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T254829[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$254825[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T254830[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@4:
	mov	eax, DWORD PTR __Result$254826[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T254839 = -16						; size = 4
$T254835 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T254839[ebp], 0
	lea	eax, DWORD PTR $T254839[ebp]
	push	eax
	lea	ecx, DWORD PTR $T254835[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T254835[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T254835[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T254846 = -8						; size = 4
$T254845 = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >, COMDAT
; _this$ = ecx

; 1465 : 		{	// construct with base

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T254846[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T254845[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T254845[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T254846[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1466 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
_TEXT	ENDS
;	COMDAT ??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T254880 = -40						; size = 4
$T254864 = -36						; size = 4
$T254988 = -32						; size = 4
$T254987 = -28						; size = 4
$T254986 = -24						; size = 4
$T254985 = -20						; size = 4
$T254984 = -16						; size = 4
_v$213750 = -12						; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T254864[ebp], ecx
	mov	edx, DWORD PTR $T254864[ebp]
	mov	DWORD PTR $T254985[ebp], edx
	mov	eax, DWORD PTR $T254985[ebp]
	mov	DWORD PTR $T254984[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254880[ebp], edx
	mov	eax, DWORD PTR $T254880[ebp]
	mov	DWORD PTR $T254987[ebp], eax
	mov	ecx, DWORD PTR $T254987[ebp]
	mov	DWORD PTR $T254986[ebp], ecx
	mov	edx, DWORD PTR $T254984[ebp]
	push	edx
	mov	eax, DWORD PTR $T254986[ebp]
	push	eax
	lea	ecx, DWORD PTR $T254988[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$213750[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$213750[ebp]
	push	eax
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT
$LN4@SerializeT:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back
PUBLIC	??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z ; operator>><int,6>
; Function compile flags: /Odtp
;	COMDAT ??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z
_TEXT	SEGMENT
$T255195 = -60						; size = 4
$T255179 = -56						; size = 4
$T255348 = -52						; size = 4
$T255347 = -48						; size = 4
$T255346 = -44						; size = 4
$T255345 = -40						; size = 4
$T255344 = -36						; size = 4
_v$213927 = -32						; size = 24
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255179[ebp], ecx
	mov	edx, DWORD PTR $T255179[ebp]
	mov	DWORD PTR $T255345[ebp], edx
	mov	eax, DWORD PTR $T255345[ebp]
	mov	DWORD PTR $T255344[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T255195[ebp], edx
	mov	eax, DWORD PTR $T255195[ebp]
	mov	DWORD PTR $T255347[ebp], eax
	mov	ecx, DWORD PTR $T255347[ebp]
	mov	DWORD PTR $T255346[ebp], ecx
	mov	edx, DWORD PTR $T255344[ebp]
	push	edx
	mov	eax, DWORD PTR $T255346[ebp]
	push	eax
	lea	ecx, DWORD PTR $T255348[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@0@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@2
$LN2@SerializeT@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@2:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@2

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$213927[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z ; operator>><int,6>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$213927[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT@2
$LN4@SerializeT@2:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@V?$Array@H$05@Firaxis@@V?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<Firaxis::Array<int,6>,std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > > >
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv202 = -44						; size = 4
$T255564 = -32						; size = 4
$T255563 = -28						; size = 4
$T255547 = -24						; size = 4
$T255546 = -20						; size = 4
$T255484 = -16						; size = 8
$T255483 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN2@Copy_opt:
	cmp	DWORD PTR __Dest$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN11@Copy_opt
	mov	eax, DWORD PTR __Dest$[ebp+4]
	add	eax, 1
	mov	DWORD PTR __Dest$[ebp+4], eax
	jmp	SHORT $LN6@Copy_opt
$LN11@Copy_opt:
	mov	DWORD PTR __Dest$[ebp+4], 0
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
$LN6@Copy_opt:
	cmp	DWORD PTR __First$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN19@Copy_opt
	mov	edx, DWORD PTR __First$[ebp+4]
	add	edx, 1
	mov	DWORD PTR __First$[ebp+4], edx
	jmp	SHORT $LN3@Copy_opt
$LN19@Copy_opt:
	mov	DWORD PTR __First$[ebp+4], 0
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN26@Copy_opt
	mov	edx, DWORD PTR __First$[ebp+4]
	cmp	edx, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN26@Copy_opt
	mov	DWORD PTR tv202[ebp], 1
	jmp	SHORT $LN22@Copy_opt
$LN26@Copy_opt:
	mov	DWORD PTR tv202[ebp], 0
$LN22@Copy_opt:
	movzx	eax, BYTE PTR tv202[ebp]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T255547[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T255546[ebp], eax
	mov	ecx, DWORD PTR $T255546[ebp]
	mov	DWORD PTR $T255484[ebp], ecx
	mov	edx, DWORD PTR $T255547[ebp]
	mov	DWORD PTR $T255484[ebp+4], edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR $T255564[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T255563[ebp], ecx
	mov	edx, DWORD PTR $T255563[ebp]
	mov	DWORD PTR $T255483[ebp], edx
	mov	eax, DWORD PTR $T255564[ebp]
	mov	DWORD PTR $T255483[ebp+4], eax
	lea	ecx, DWORD PTR $T255484[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T255483[ebp]
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
	jmp	$LN2@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T255705 = -64						; size = 4
$T255695 = -60						; size = 4
$T255683 = -56						; size = 4
$T255673 = -49						; size = 1
$T255672 = -48						; size = 4
__Cat$255691 = -19					; size = 1
$T255689 = -18						; size = 1
$T255688 = -17						; size = 1
$T255624 = -16						; size = 4
$T255620 = -12						; size = 4
$T255619 = -8						; size = 4
$T255618 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T255624[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@5
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@5
$LN9@push_back@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@5:
	mov	ecx, DWORD PTR $T255624[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T255695[ebp], eax
	mov	ecx, DWORD PTR $T255695[ebp]
	mov	DWORD PTR $T255683[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T255688[ebp], dl
	mov	al, BYTE PTR __Cat$255691[ebp]
	mov	BYTE PTR $T255689[ebp], al
	mov	cl, BYTE PTR $T255688[ebp]
	mov	BYTE PTR $T255673[ebp], cl
	mov	edx, DWORD PTR $T255683[ebp]
	mov	DWORD PTR $T255672[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T255672[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T255695[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@5
$LN2@push_back@5:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T255705[ebp], edx
	mov	eax, DWORD PTR $T255705[ebp]
	mov	DWORD PTR $T255619[ebp], eax
	mov	ecx, DWORD PTR $T255619[ebp]
	mov	DWORD PTR $T255618[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T255618[ebp]
	push	eax
	lea	ecx, DWORD PTR $T255620[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back@5:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert
PUBLIC	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T255822 = -32						; size = 4
$T255812 = -28						; size = 4
$T255802 = -24						; size = 4
__Cat$255810 = -19					; size = 1
$T255808 = -18						; size = 1
$T255807 = -17						; size = 1
$T255779 = -16						; size = 4
$T255775 = -12						; size = 4
$T255774 = -8						; size = 4
$T255773 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR $T255779[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back@6
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@6
$LN9@push_back@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@6:
	mov	edx, DWORD PTR $T255779[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255812[ebp], ecx
	mov	edx, DWORD PTR $T255812[ebp]
	mov	DWORD PTR $T255802[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T255807[ebp], al
	mov	cl, BYTE PTR __Cat$255810[ebp]
	mov	BYTE PTR $T255808[ebp], cl
	movzx	edx, BYTE PTR $T255807[ebp]
	push	edx
	movzx	eax, BYTE PTR $T255808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T255802[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR $T255812[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@6
$LN2@push_back@6:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T255822[ebp], ecx
	mov	edx, DWORD PTR $T255822[ebp]
	mov	DWORD PTR $T255774[ebp], edx
	mov	eax, DWORD PTR $T255774[ebp]
	mov	DWORD PTR $T255773[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255773[ebp]
	push	edx
	lea	eax, DWORD PTR $T255775[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert
$LN3@push_back@6:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAEXABV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv130 = -28						; size = 4
tv91 = -24						; size = 4
_this$ = -20						; size = 4
$T255916 = -16						; size = 4
$T255909 = -12						; size = 4
$T255904 = -5						; size = 1
$T255894 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1470 : 		{	// assign _Vb_reference _Right to bit

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1471 : 		return (*this = bool(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T255894[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	mov	ecx, DWORD PTR $T255894[ebp]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR $T255904[ebp], al
	movzx	edx, BYTE PTR $T255904[ebp]
	test	edx, edx
	je	SHORT $LN10@operator@7
	mov	eax, DWORD PTR $T255909[ebp]
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv91[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv91[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN11@operator@7
$LN10@operator@7:
	mov	edx, DWORD PTR $T255916[ebp]
	mov	DWORD PTR tv130[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv130[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv130[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR [edx], eax
$LN11@operator@7:
	mov	eax, DWORD PTR _this$[ebp]

; 1472 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$255986 = -24					; size = 4
$T255969 = -20						; size = 4
$T255950 = -16						; size = 4
$T255937 = -12						; size = 4
$T255934 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@5
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T255950[ebp], ecx
	mov	edx, DWORD PTR $T255950[ebp]
	mov	DWORD PTR $T255934[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T255934[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@5:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T255969[ebp], edx
	mov	eax, DWORD PTR $T255969[ebp]
	mov	DWORD PTR $T255937[ebp], eax
	mov	ecx, DWORD PTR $T255937[ebp]
	mov	DWORD PTR __Tmp$255986[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$255986[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$255986[ebp], ecx
	mov	edx, DWORD PTR __Tmp$255986[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z
_TEXT	SEGMENT
_this$ = -224						; size = 4
__Tmp$256243 = -220					; size = 8
$T256221 = -212						; size = 4
$T256199 = -208						; size = 4
$T256223 = -204						; size = 4
$T256029 = -32						; size = 4
$T256007 = -28						; size = 4
$T256044 = -24						; size = 4
$T255995 = -20						; size = 8
$T255994 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 1
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z PROC ; std::vector<bool,std::allocator<bool> >::insert, COMDAT
; _this$ = ecx

; 2150 : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	DWORD PTR _this$[ebp], ecx

; 2151 : 		size_type _Off = _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256007[ebp], ecx
	mov	edx, DWORD PTR $T256007[ebp]
	mov	DWORD PTR $T256044[ebp], edx
	mov	eax, DWORD PTR $T256044[ebp]
	mov	DWORD PTR $T256029[ebp], eax
	mov	ecx, DWORD PTR $T256029[ebp]
	mov	DWORD PTR $T255994[ebp], ecx
	mov	DWORD PTR $T255994[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T255994[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T255994[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2152 : 		_Insert_n(_Where, (size_type)1, _Val);

	movzx	eax, BYTE PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n

; 2153 : 		return (begin() + _Off);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256199[ebp], ecx
	mov	edx, DWORD PTR $T256199[ebp]
	mov	DWORD PTR $T256223[ebp], edx
	mov	eax, DWORD PTR $T256223[ebp]
	mov	DWORD PTR $T256221[ebp], eax
	mov	ecx, DWORD PTR $T256221[ebp]
	mov	DWORD PTR $T255995[ebp], ecx
	mov	DWORD PTR $T255995[ebp+4], 0
	mov	edx, DWORD PTR $T255995[ebp]
	mov	eax, DWORD PTR $T255995[ebp+4]
	mov	DWORD PTR __Tmp$256243[ebp], edx
	mov	DWORD PTR __Tmp$256243[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$256243[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$256243[ebp]
	mov	eax, DWORD PTR __Tmp$256243[ebp+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$256306 = -24					; size = 4
$T256284 = -20						; size = 4
$T256265 = -16						; size = 4
$T256252 = -12						; size = 4
$T256249 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@6
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@6
$LN3@insert@6:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256265[ebp], eax
	mov	ecx, DWORD PTR $T256265[ebp]
	mov	DWORD PTR $T256249[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T256249[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@6:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256284[ebp], eax
	mov	ecx, DWORD PTR $T256284[ebp]
	mov	DWORD PTR $T256252[ebp], ecx
	mov	edx, DWORD PTR $T256252[ebp]
	mov	DWORD PTR __Tmp$256306[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Tmp$256306[ebp]
	mov	DWORD PTR __Tmp$256306[ebp], eax
	mov	ecx, DWORD PTR __Tmp$256306[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@V?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@ABV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T256860 = -412						; size = 4
$T256808 = -368						; size = 4
$T256796 = -364						; size = 4
$T256786 = -357						; size = 1
$T256785 = -356						; size = 4
__Cat$256804 = -327					; size = 1
$T256801 = -326						; size = 1
$T256800 = -325						; size = 1
$T256757 = -324						; size = 4
$T256749 = -320						; size = 4
$T256741 = -316						; size = 4
$T256730 = -312						; size = 4
$T256729 = -308						; size = 4
__Cat$256737 = -302					; size = 1
$T256735 = -301						; size = 1
$T256658 = -276						; size = 4
$T256639 = -272						; size = 4
$T256622 = -265						; size = 1
$T256621 = -264						; size = 4
$T256611 = -260						; size = 4
$T256610 = -256						; size = 4
__Cat$256655 = -250					; size = 1
$T256653 = -249						; size = 1
$T256652 = -248						; size = 1
__Cat$256647 = -247					; size = 1
$T256644 = -246						; size = 1
$T256643 = -245						; size = 1
$T256586 = -244						; size = 4
$T256585 = -240						; size = 4
$T256581 = -236						; size = 4
$T256580 = -232						; size = 4
$T256569 = -228						; size = 4
$T256568 = -224						; size = 4
__Cat$256575 = -218					; size = 1
$T256573 = -217						; size = 1
$T256533 = -216						; size = 4
$T256532 = -212						; size = 4
__Cat$256539 = -206					; size = 1
$T256537 = -205						; size = 1
$T256503 = -204						; size = 4
$T256502 = -200						; size = 4
__Cat$256509 = -194					; size = 1
$T256507 = -193						; size = 1
$T256483 = -192						; size = 4
$T256471 = -188						; size = 4
$T256461 = -181						; size = 1
$T256460 = -180						; size = 4
__Cat$256479 = -175					; size = 1
$T256476 = -174						; size = 1
$T256475 = -173						; size = 1
$T256448 = -172						; size = 4
$T256436 = -168						; size = 4
$T256426 = -161						; size = 1
$T256425 = -160						; size = 4
__Cat$256443 = -155					; size = 1
$T256440 = -154						; size = 1
$T256439 = -153						; size = 1
$T256413 = -152						; size = 4
$T256401 = -148						; size = 4
$T256391 = -141						; size = 1
$T256390 = -140						; size = 4
__Cat$256408 = -135					; size = 1
$T256406 = -134						; size = 1
$T256405 = -133						; size = 1
__Count$256367 = -120					; size = 4
__Count$256341 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@4
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@4
$LN29@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@4:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@4
	jmp	$LN16@Insert_n@4
$LN14@Insert_n@4:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$256341[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$256341[ebp], 0
	jbe	SHORT $LN35@Insert_n@4
	mov	edx, DWORD PTR __Count$256341[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@4
$LN35@Insert_n@4:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n@4

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$256367[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$256367[ebp], 0
	jbe	SHORT $LN48@Insert_n@4
	mov	ecx, DWORD PTR __Count$256367[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@4
$LN48@Insert_n@4:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@4:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@4:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@4:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T256413[ebp], edx
	mov	eax, DWORD PTR $T256413[ebp]
	mov	DWORD PTR $T256401[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256405[ebp], cl
	mov	dl, BYTE PTR __Cat$256408[ebp]
	mov	BYTE PTR $T256406[ebp], dl
	mov	al, BYTE PTR $T256405[ebp]
	mov	BYTE PTR $T256391[ebp], al
	mov	ecx, DWORD PTR $T256401[ebp]
	mov	DWORD PTR $T256390[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256390[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256448[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T256436[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T256439[ebp], al
	mov	cl, BYTE PTR __Cat$256443[ebp]
	mov	BYTE PTR $T256440[ebp], cl
	mov	dl, BYTE PTR $T256439[ebp]
	mov	BYTE PTR $T256426[ebp], dl
	mov	eax, DWORD PTR $T256436[ebp]
	mov	DWORD PTR $T256425[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256425[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256448[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T256483[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T256471[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256475[ebp], dl
	mov	al, BYTE PTR __Cat$256479[ebp]
	mov	BYTE PTR $T256476[ebp], al
	mov	cl, BYTE PTR $T256475[ebp]
	mov	BYTE PTR $T256461[ebp], cl
	mov	edx, DWORD PTR $T256471[ebp]
	mov	DWORD PTR $T256460[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256460[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256483[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@4
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n@4

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T256503[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T256502[ebp], ecx
	mov	dl, BYTE PTR __Cat$256509[ebp]
	mov	BYTE PTR $T256507[ebp], dl
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T256533[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T256532[ebp], ecx
	mov	dl, BYTE PTR __Cat$256539[ebp]
	mov	BYTE PTR $T256537[ebp], dl
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@4
	ret	0
$LN19@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256581[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T256580[ebp], edx
	mov	eax, DWORD PTR $T256581[ebp]
	mov	DWORD PTR $T256569[ebp], eax
	mov	ecx, DWORD PTR $T256580[ebp]
	mov	DWORD PTR $T256568[ebp], ecx
	mov	dl, BYTE PTR __Cat$256575[ebp]
	mov	BYTE PTR $T256573[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T256586[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256585[ebp], ecx
	mov	edx, DWORD PTR $T256585[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@4
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256658[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T256639[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256643[ebp], cl
	mov	dl, BYTE PTR __Cat$256647[ebp]
	mov	BYTE PTR $T256644[ebp], dl
	mov	al, BYTE PTR $T256643[ebp]
	mov	BYTE PTR $T256622[ebp], al
	mov	ecx, DWORD PTR $T256639[ebp]
	mov	DWORD PTR $T256621[ebp], ecx
	mov	edx, DWORD PTR $T256621[ebp]
	mov	DWORD PTR $T256611[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256610[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256652[ebp], cl
	mov	dl, BYTE PTR __Cat$256655[ebp]
	mov	BYTE PTR $T256653[ebp], dl
	movzx	eax, BYTE PTR $T256652[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T256653[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T256611[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256658[ebp]
	push	ecx
	mov	edx, DWORD PTR $T256610[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@4
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T256741[ebp], eax
	mov	ecx, DWORD PTR $T256741[ebp]
	mov	DWORD PTR $T256730[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T256729[ebp], ecx
	mov	dl, BYTE PTR __Cat$256737[ebp]
	mov	BYTE PTR $T256735[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T256757[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256749[ebp], edx
	jmp	SHORT $LN151@Insert_n@4
$LN150@Insert_n@4:
	mov	eax, DWORD PTR $T256749[ebp]
	add	eax, 4
	mov	DWORD PTR $T256749[ebp], eax
$LN151@Insert_n@4:
	mov	ecx, DWORD PTR $T256749[ebp]
	cmp	ecx, DWORD PTR $T256757[ebp]
	je	SHORT $LN147@Insert_n@4
	mov	edx, DWORD PTR $T256749[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@4
$LN147@Insert_n@4:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T256808[ebp], eax
	mov	ecx, DWORD PTR $T256808[ebp]
	mov	DWORD PTR $T256796[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T256800[ebp], dl
	mov	al, BYTE PTR __Cat$256804[ebp]
	mov	BYTE PTR $T256801[ebp], al
	mov	cl, BYTE PTR $T256800[ebp]
	mov	BYTE PTR $T256786[ebp], cl
	mov	edx, DWORD PTR $T256796[ebp]
	mov	DWORD PTR $T256785[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256785[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256860[ebp], ecx
	jmp	SHORT $LN186@Insert_n@4
$LN185@Insert_n@4:
	mov	edx, DWORD PTR $T256860[ebp]
	add	edx, 4
	mov	DWORD PTR $T256860[ebp], edx
$LN186@Insert_n@4:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T256860[ebp], edx
	je	SHORT $LN16@Insert_n@4
	mov	eax, DWORD PTR $T256860[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@4
$LN16@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T256931 = -40						; size = 4
$T256921 = -33						; size = 1
$T256920 = -32						; size = 4
__Cat$256927 = -3					; size = 1
$T256925 = -2						; size = 1
$T256924 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T256931[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T256924[ebp], cl
	mov	dl, BYTE PTR __Cat$256927[ebp]
	mov	BYTE PTR $T256925[ebp], dl
	mov	al, BYTE PTR $T256924[ebp]
	mov	BYTE PTR $T256921[ebp], al
	mov	ecx, DWORD PTR $T256931[ebp]
	mov	DWORD PTR $T256920[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256920[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
; Function compile flags: /Odtp
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z
_TEXT	SEGMENT
_this$ = -212						; size = 4
$T257253 = -208						; size = 8
$T257252 = -200						; size = 8
__Tmp$257165 = -172					; size = 8
$T257143 = -164						; size = 4
$T257121 = -160						; size = 4
$T257145 = -156						; size = 4
__Tmp$257109 = -152					; size = 8
$T257085 = -144						; size = 4
$T257063 = -140						; size = 4
$T257087 = -136						; size = 4
$T256937 = -36						; size = 8
$T256936 = -28						; size = 8
$T256935 = -20						; size = 8
$T256934 = -12						; size = 8
__Off$ = -4						; size = 4
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 1
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2290 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	DWORD PTR _this$[ebp], ecx

; 2291 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
	mov	DWORD PTR __Off$[ebp], eax

; 2292 : 		std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257063[ebp], ecx
	mov	edx, DWORD PTR $T257063[ebp]
	mov	DWORD PTR $T257087[ebp], edx
	mov	eax, DWORD PTR $T257087[ebp]
	mov	DWORD PTR $T257085[ebp], eax
	mov	ecx, DWORD PTR $T257085[ebp]
	mov	DWORD PTR $T256934[ebp], ecx
	mov	DWORD PTR $T256934[ebp+4], 0
	mov	edx, DWORD PTR $T256934[ebp]
	mov	eax, DWORD PTR $T256934[ebp+4]
	mov	DWORD PTR __Tmp$257109[ebp], edx
	mov	DWORD PTR __Tmp$257109[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$257109[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$257109[ebp]
	mov	eax, DWORD PTR __Tmp$257109[ebp+4]
	mov	DWORD PTR $T256935[ebp], edx
	mov	DWORD PTR $T256935[ebp+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257121[ebp], edx
	mov	eax, DWORD PTR $T257121[ebp]
	mov	DWORD PTR $T257145[ebp], eax
	mov	ecx, DWORD PTR $T257145[ebp]
	mov	DWORD PTR $T257143[ebp], ecx
	mov	edx, DWORD PTR $T257143[ebp]
	mov	DWORD PTR $T256936[ebp], edx
	mov	DWORD PTR $T256936[ebp+4], 0
	mov	eax, DWORD PTR $T256936[ebp]
	mov	ecx, DWORD PTR $T256936[ebp+4]
	mov	DWORD PTR __Tmp$257165[ebp], eax
	mov	DWORD PTR __Tmp$257165[ebp+4], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$257165[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR __Tmp$257165[ebp]
	mov	ecx, DWORD PTR __Tmp$257165[ebp+4]
	mov	DWORD PTR $T256937[ebp], eax
	mov	DWORD PTR $T256937[ebp+4], ecx
	mov	edx, DWORD PTR $T256935[ebp]
	mov	DWORD PTR $T257253[ebp], edx
	mov	eax, DWORD PTR $T256935[ebp+4]
	mov	DWORD PTR $T257253[ebp+4], eax
	mov	ecx, DWORD PTR $T256937[ebp]
	mov	DWORD PTR $T257252[ebp], ecx
	mov	edx, DWORD PTR $T256937[ebp+4]
	mov	DWORD PTR $T257252[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257253[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T257253[ebp]
	push	edx
	mov	eax, DWORD PTR $T257252[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T257252[ebp]
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H

; 2293 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
PUBLIC	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
PUBLIC	??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\farray.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$2
__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$0
__unwindtable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
tv84 = -468						; size = 4
tv304 = -464						; size = 4
tv290 = -460						; size = 4
tv282 = -456						; size = 4
_this$ = -452						; size = 4
$T257964 = -448						; size = 4
_i$257973 = -444					; size = 4
$T257881 = -400						; size = 4
$T257862 = -396						; size = 4
$T257845 = -389						; size = 1
$T257844 = -388						; size = 4
$T257834 = -384						; size = 4
$T257833 = -380						; size = 4
__Cat$257879 = -374					; size = 1
$T257877 = -373						; size = 1
$T257876 = -372						; size = 1
__Cat$257870 = -371					; size = 1
$T257868 = -370						; size = 1
$T257867 = -369						; size = 1
$T257809 = -368						; size = 4
$T257795 = -364						; size = 4
_i$257804 = -360					; size = 4
$T257774 = -356						; size = 4
$T257756 = -352						; size = 4
$T257755 = -348						; size = 4
$T257739 = -344						; size = 4
__Cat$257761 = -338					; size = 1
$T257759 = -337						; size = 1
$T257713 = -336						; size = 4
$T257712 = -332						; size = 4
$T257702 = -328						; size = 4
__Cat$257709 = -323					; size = 1
$T257707 = -322						; size = 1
$T257706 = -321						; size = 1
$T257686 = -320						; size = 4
$T257667 = -316						; size = 4
$T257650 = -309						; size = 1
$T257649 = -308						; size = 4
$T257639 = -304						; size = 4
$T257638 = -300						; size = 4
__Cat$257684 = -294					; size = 1
$T257682 = -293						; size = 1
$T257681 = -292						; size = 1
__Cat$257675 = -291					; size = 1
$T257673 = -290						; size = 1
$T257672 = -289						; size = 1
$T257614 = -288						; size = 4
$T257613 = -284						; size = 4
$T257609 = -280						; size = 4
$T257608 = -276						; size = 4
$T257590 = -272						; size = 4
$T257589 = -268						; size = 4
$T257573 = -264						; size = 4
__Cat$257595 = -258					; size = 1
$T257593 = -257						; size = 1
$T257524 = -256						; size = 4
$T257523 = -252						; size = 4
$T257507 = -248						; size = 4
__Cat$257529 = -242					; size = 1
$T257527 = -241						; size = 1
$T257464 = -240						; size = 4
$T257463 = -236						; size = 4
$T257447 = -232						; size = 4
__Cat$257469 = -226					; size = 1
$T257467 = -225						; size = 1
$T257421 = -224						; size = 4
$T257409 = -220						; size = 4
$T257399 = -213						; size = 1
$T257398 = -212						; size = 4
__Cat$257416 = -207					; size = 1
$T257414 = -206						; size = 1
$T257413 = -205						; size = 1
$T257386 = -204						; size = 4
$T257374 = -200						; size = 4
$T257364 = -193						; size = 1
$T257363 = -192						; size = 4
__Cat$257381 = -187					; size = 1
$T257379 = -186						; size = 1
$T257378 = -185						; size = 1
$T257351 = -184						; size = 4
$T257341 = -180						; size = 4
__Cat$257347 = -175					; size = 1
$T257345 = -174						; size = 1
$T257344 = -173						; size = 1
__Count$257310 = -160					; size = 4
__Count$257284 = -88					; size = 4
__Tmp$214918 = -84					; size = 24
__Oldend$214919 = -60					; size = 4
__Tmp$214908 = -56					; size = 24
__Ncopied$214895 = -32					; size = 4
__Newvec$214893 = -28					; size = 4
__Whereoff$214894 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z PROC ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 452				; 000001c4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@5
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n@5
$LN29@Insert_n@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n@5:
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@5
	jmp	$LN16@Insert_n@5
$LN14@Insert_n@5:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$257284[ebp], 178956970 ; 0aaaaaaaH
	cmp	DWORD PTR __Count$257284[ebp], 0
	jbe	SHORT $LN35@Insert_n@5
	mov	eax, DWORD PTR __Count$257284[ebp]
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $LN37@Insert_n@5
$LN35@Insert_n@5:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	edx, DWORD PTR tv290[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@KAXXZ ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Xlen
	jmp	$LN16@Insert_n@5

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$257310[ebp], 178956970 ; 0aaaaaaaH
	cmp	DWORD PTR __Count$257310[ebp], 0
	jbe	SHORT $LN48@Insert_n@5
	mov	edx, DWORD PTR __Count$257310[ebp]
	mov	DWORD PTR tv304[ebp], edx
	jmp	SHORT $LN44@Insert_n@5
$LN48@Insert_n@5:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n@5:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv304[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@5:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN54@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@5:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$Array@H$05@Firaxis@@@std@@YAPAV?$Array@H$05@Firaxis@@IPAV12@@Z ; std::_Allocate<Firaxis::Array<int,6> >
	add	esp, 8
	mov	DWORD PTR __Newvec$214893[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR __Whereoff$214894[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214895[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$214894[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Newvec$214893[ebp]
	mov	DWORD PTR $T257351[ebp], edx
	mov	eax, DWORD PTR $T257351[ebp]
	mov	DWORD PTR $T257341[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257344[ebp], cl
	mov	dl, BYTE PTR __Cat$257347[ebp]
	mov	BYTE PTR $T257345[ebp], dl
	movzx	eax, BYTE PTR $T257344[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T257345[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257341[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$214895[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$214895[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T257386[ebp], edx
	mov	eax, DWORD PTR __Newvec$214893[ebp]
	mov	DWORD PTR $T257374[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257378[ebp], cl
	mov	dl, BYTE PTR __Cat$257381[ebp]
	mov	BYTE PTR $T257379[ebp], dl
	mov	al, BYTE PTR $T257378[ebp]
	mov	BYTE PTR $T257364[ebp], al
	mov	ecx, DWORD PTR $T257374[ebp]
	mov	DWORD PTR $T257363[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T257363[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257386[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$214895[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$214895[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257421[ebp], edx
	mov	eax, DWORD PTR __Whereoff$214894[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Newvec$214893[ebp]
	mov	DWORD PTR $T257409[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257413[ebp], cl
	mov	dl, BYTE PTR __Cat$257416[ebp]
	mov	BYTE PTR $T257414[ebp], dl
	mov	al, BYTE PTR $T257413[ebp]
	mov	BYTE PTR $T257399[ebp], al
	mov	ecx, DWORD PTR $T257409[ebp]
	mov	DWORD PTR $T257398[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T257398[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257421[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@5
__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214895[ebp], 1
	jle	SHORT $LN7@Insert_n@5

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$214894[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Newvec$214893[ebp]
	mov	DWORD PTR $T257464[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214893[ebp]
	mov	DWORD PTR $T257463[ebp], ecx
	mov	dl, BYTE PTR __Cat$257469[ebp]
	mov	BYTE PTR $T257467[ebp], dl
	mov	eax, DWORD PTR $T257463[ebp]
	mov	DWORD PTR $T257447[ebp], eax
	jmp	SHORT $LN91@Insert_n@5
$LN90@Insert_n@5:
	mov	ecx, DWORD PTR $T257447[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T257447[ebp], ecx
$LN91@Insert_n@5:
	mov	edx, DWORD PTR $T257447[ebp]
	cmp	edx, DWORD PTR $T257464[ebp]
	je	SHORT $LN7@Insert_n@5
	jmp	SHORT $LN90@Insert_n@5
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214895[ebp], 0
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR __Whereoff$214894[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$214893[ebp]
	add	ecx, eax
	mov	DWORD PTR $T257524[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214894[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Newvec$214893[ebp]
	mov	DWORD PTR $T257523[ebp], edx
	mov	al, BYTE PTR __Cat$257529[ebp]
	mov	BYTE PTR $T257527[ebp], al
	mov	ecx, DWORD PTR $T257523[ebp]
	mov	DWORD PTR $T257507[ebp], ecx
	jmp	SHORT $LN106@Insert_n@5
$LN105@Insert_n@5:
	mov	edx, DWORD PTR $T257507[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T257507[ebp], edx
$LN106@Insert_n@5:
	mov	eax, DWORD PTR $T257507[ebp]
	cmp	eax, DWORD PTR $T257524[ebp]
	je	SHORT $LN6@Insert_n@5
	jmp	SHORT $LN105@Insert_n@5
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$214893[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n@5
	ret	0
$LN19@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257609[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257608[ebp], eax
	mov	ecx, DWORD PTR $T257609[ebp]
	mov	DWORD PTR $T257590[ebp], ecx
	mov	edx, DWORD PTR $T257608[ebp]
	mov	DWORD PTR $T257589[ebp], edx
	mov	al, BYTE PTR __Cat$257595[ebp]
	mov	BYTE PTR $T257593[ebp], al
	mov	ecx, DWORD PTR $T257589[ebp]
	mov	DWORD PTR $T257573[ebp], ecx
	jmp	SHORT $LN125@Insert_n@5
$LN124@Insert_n@5:
	mov	edx, DWORD PTR $T257573[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T257573[ebp], edx
$LN125@Insert_n@5:
	mov	eax, DWORD PTR $T257573[ebp]
	cmp	eax, DWORD PTR $T257590[ebp]
	je	SHORT $LN117@Insert_n@5
	jmp	SHORT $LN124@Insert_n@5
$LN117@Insert_n@5:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR $T257614[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257613[ebp], eax
	mov	ecx, DWORD PTR $T257613[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Newvec$214893[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$214893[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$214893[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@5
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$214908[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$214908[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$214908[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$214908[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$214908[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$214908[ebp+20], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T257686[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257667[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257672[ebp], dl
	mov	al, BYTE PTR __Cat$257675[ebp]
	mov	BYTE PTR $T257673[ebp], al
	mov	cl, BYTE PTR $T257672[ebp]
	mov	BYTE PTR $T257650[ebp], cl
	mov	edx, DWORD PTR $T257667[ebp]
	mov	DWORD PTR $T257649[ebp], edx
	mov	eax, DWORD PTR $T257649[ebp]
	mov	DWORD PTR $T257639[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257638[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257681[ebp], dl
	mov	al, BYTE PTR __Cat$257684[ebp]
	mov	BYTE PTR $T257682[ebp], al
	movzx	ecx, BYTE PTR $T257681[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T257682[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257639[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257686[ebp]
	push	edx
	mov	eax, DWORD PTR $T257638[ebp]
	push	eax
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T257713[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257712[ebp], ecx
	mov	edx, DWORD PTR $T257712[ebp]
	mov	DWORD PTR $T257702[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T257706[ebp], al
	mov	cl, BYTE PTR __Cat$257709[ebp]
	mov	BYTE PTR $T257707[ebp], cl
	movzx	edx, BYTE PTR $T257706[ebp]
	push	edx
	movzx	eax, BYTE PTR $T257707[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$214908[ebp]
	push	edx
	mov	eax, DWORD PTR $T257713[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257702[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@5
__catch$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257774[ebp], edx
	mov	ecx, DWORD PTR $T257774[ebp]
	mov	DWORD PTR $T257756[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257755[ebp], edx
	mov	al, BYTE PTR __Cat$257761[ebp]
	mov	BYTE PTR $T257759[ebp], al
	mov	ecx, DWORD PTR $T257755[ebp]
	mov	DWORD PTR $T257739[ebp], ecx
	jmp	SHORT $LN160@Insert_n@5
$LN159@Insert_n@5:
	mov	edx, DWORD PTR $T257739[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T257739[ebp], edx
$LN160@Insert_n@5:
	mov	eax, DWORD PTR $T257739[ebp]
	cmp	eax, DWORD PTR $T257756[ebp]
	je	SHORT $LN152@Insert_n@5
	jmp	SHORT $LN159@Insert_n@5
$LN152@Insert_n@5:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$3
	ret	0
$LN21@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T257809[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257795[ebp], ecx
	jmp	SHORT $LN171@Insert_n@5
$LN170@Insert_n@5:
	mov	edx, DWORD PTR $T257795[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T257795[ebp], edx
$LN171@Insert_n@5:
	mov	eax, DWORD PTR $T257795[ebp]
	cmp	eax, DWORD PTR $T257809[ebp]
	je	SHORT $LN167@Insert_n@5
	mov	DWORD PTR _i$257804[ebp], 0
	jmp	SHORT $LN176@Insert_n@5
$LN175@Insert_n@5:
	mov	ecx, DWORD PTR _i$257804[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$257804[ebp], ecx
$LN176@Insert_n@5:
	cmp	DWORD PTR _i$257804[ebp], 6
	jae	SHORT $LN177@Insert_n@5
	mov	edx, DWORD PTR _i$257804[ebp]
	mov	eax, DWORD PTR $T257795[ebp]
	mov	ecx, DWORD PTR _i$257804[ebp]
	mov	ecx, DWORD PTR __Tmp$214908[ebp+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN175@Insert_n@5
$LN177@Insert_n@5:
	jmp	SHORT $LN170@Insert_n@5
$LN167@Insert_n@5:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$214918[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$214918[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$214918[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$214918[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$214918[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$214918[ebp+20], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$214919[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257881[ebp], edx
	mov	eax, DWORD PTR $T257881[ebp]
	mov	DWORD PTR $T257862[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T257867[ebp], cl
	mov	dl, BYTE PTR __Cat$257870[ebp]
	mov	BYTE PTR $T257868[ebp], dl
	mov	al, BYTE PTR $T257867[ebp]
	mov	BYTE PTR $T257845[ebp], al
	mov	ecx, DWORD PTR $T257862[ebp]
	mov	DWORD PTR $T257844[ebp], ecx
	mov	edx, DWORD PTR $T257844[ebp]
	mov	DWORD PTR $T257834[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR __Oldend$214919[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T257833[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T257876[ebp], dl
	mov	al, BYTE PTR __Cat$257879[ebp]
	mov	BYTE PTR $T257877[ebp], al
	movzx	ecx, BYTE PTR $T257876[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T257877[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T257834[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214919[ebp]
	push	edx
	mov	eax, DWORD PTR $T257833[ebp]
	push	eax
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$214919[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR __Oldend$214919[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T257964[ebp], eax
	jmp	SHORT $LN214@Insert_n@5
$LN213@Insert_n@5:
	mov	ecx, DWORD PTR $T257964[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T257964[ebp], ecx
$LN214@Insert_n@5:
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T257964[ebp], edx
	je	SHORT $LN16@Insert_n@5
	mov	DWORD PTR _i$257973[ebp], 0
	jmp	SHORT $LN219@Insert_n@5
$LN218@Insert_n@5:
	mov	eax, DWORD PTR _i$257973[ebp]
	add	eax, 1
	mov	DWORD PTR _i$257973[ebp], eax
$LN219@Insert_n@5:
	cmp	DWORD PTR _i$257973[ebp], 6
	jae	SHORT $LN220@Insert_n@5
	mov	ecx, DWORD PTR _i$257973[ebp]
	mov	edx, DWORD PTR $T257964[ebp]
	mov	eax, DWORD PTR _i$257973[ebp]
	mov	eax, DWORD PTR __Tmp$214918[ebp+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN218@Insert_n@5
$LN220@Insert_n@5:
	jmp	SHORT $LN213@Insert_n@5
$LN16@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-472]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@IAEXV?$_Vector_const_iterator@V?$Array@H$05@Firaxis@@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@2@IABV?$Array@H$05@Firaxis@@@Z ENDP ; std::vector<Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >::_Insert_n
PUBLIC	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
PUBLIC	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
; Function compile flags: /Odtp
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z
_TEXT	SEGMENT
tv191 = -348						; size = 4
tv200 = -344						; size = 4
_this$ = -340						; size = 4
__Tmp$258347 = -268					; size = 8
$T258325 = -260						; size = 4
$T258303 = -256						; size = 4
$T258327 = -252						; size = 4
$T258183 = -200						; size = 4
$T258094 = -148						; size = 4
$T258082 = -76						; size = 4
__Count$258075 = -72					; size = 4
__Maxsize$258078 = -68					; size = 4
$T258029 = -64						; size = 4
$T258007 = -60						; size = 4
$T258032 = -56						; size = 4
$T257995 = -52						; size = 8
$T257994 = -44						; size = 8
$T257993 = -36						; size = 8
$T257992 = -28						; size = 8
$T257991 = -20						; size = 8
__Oldend$214955 = -12					; size = 8
__Off$ = -4						; size = 4
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2296 : 		{	// make room to insert _Count elements at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	DWORD PTR _this$[ebp], ecx

; 2297 : 		size_type _Off = _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T258007[ebp], ecx
	mov	edx, DWORD PTR $T258007[ebp]
	mov	DWORD PTR $T258032[ebp], edx
	mov	eax, DWORD PTR $T258032[ebp]
	mov	DWORD PTR $T258029[ebp], eax
	mov	ecx, DWORD PTR $T258029[ebp]
	mov	DWORD PTR $T257991[ebp], ecx
	mov	DWORD PTR $T257991[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T257991[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T257991[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2298 : 
; 2299 :  #if _HAS_ITERATOR_DEBUGGING
; 2300 : 		if (end() < _Where)
; 2301 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2302 : 		bool _Realloc = capacity() - size() < _Count;
; 2303 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2304 : 
; 2305 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN6@Insert_x
	jmp	$LN5@Insert_x
$LN6@Insert_x:

; 2306 : 			;
; 2307 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$258075[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$258075[ebp], 0
	jbe	SHORT $LN33@Insert_x
	mov	eax, DWORD PTR __Count$258075[ebp]
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN29@Insert_x
$LN33@Insert_x:
	mov	DWORD PTR tv200[ebp], 1
$LN29@Insert_x:
	mov	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR __Maxsize$258078[ebp], ecx
	cmp	DWORD PTR __Maxsize$258078[ebp], 134217727 ; 07ffffffH
	jae	SHORT $LN27@Insert_x
	mov	edx, DWORD PTR __Maxsize$258078[ebp]
	shl	edx, 5
	mov	DWORD PTR tv191[ebp], edx
	jmp	SHORT $LN25@Insert_x
$LN27@Insert_x:
	mov	DWORD PTR tv191[ebp], -1
$LN25@Insert_x:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T258082[ebp], ecx
	mov	edx, DWORD PTR tv191[ebp]
	sub	edx, DWORD PTR $T258082[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Insert_x

; 2308 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen

; 2309 : 		else

	jmp	$LN5@Insert_x
$LN4@Insert_x:

; 2310 : 			{	// worth doing
; 2311 : 			_Myvec.resize(_Nw(size() + _Count), 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T258094[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR $T258094[ebp]
	lea	ecx, DWORD PTR [eax+edx+31]
	shr	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 2312 : 			if (size() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T258183[ebp], eax
	cmp	DWORD PTR $T258183[ebp], 0
	jne	SHORT $LN2@Insert_x

; 2313 : 				_Mysize += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 2314 : 			else

	jmp	$LN5@Insert_x
$LN2@Insert_x:

; 2315 : 				{	// make room and copy down suffix
; 2316 : 				iterator _Oldend = end();

	lea	ecx, DWORD PTR __Oldend$214955[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end

; 2317 : 				_Mysize += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 2318 : 				std::copy_backward(begin() + _Off, _Oldend, end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T258303[ebp], eax
	mov	ecx, DWORD PTR $T258303[ebp]
	mov	DWORD PTR $T258327[ebp], ecx
	mov	edx, DWORD PTR $T258327[ebp]
	mov	DWORD PTR $T258325[ebp], edx
	mov	eax, DWORD PTR $T258325[ebp]
	mov	DWORD PTR $T257993[ebp], eax
	mov	DWORD PTR $T257993[ebp+4], 0
	mov	ecx, DWORD PTR $T257993[ebp]
	mov	edx, DWORD PTR $T257993[ebp+4]
	mov	DWORD PTR __Tmp$258347[ebp], ecx
	mov	DWORD PTR __Tmp$258347[ebp+4], edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$258347[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$258347[ebp]
	mov	edx, DWORD PTR __Tmp$258347[ebp+4]
	mov	DWORD PTR $T257994[ebp], ecx
	mov	DWORD PTR $T257994[ebp+4], edx
	lea	eax, DWORD PTR $T257992[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Oldend$214955[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Oldend$214955[ebp]
	push	ecx
	mov	edx, DWORD PTR $T257994[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T257994[ebp]
	push	eax
	lea	ecx, DWORD PTR $T257995[ebp]
	push	ecx
	call	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
	add	esp, 28					; 0000001cH
$LN5@Insert_x:

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, DWORD PTR __Off$[ebp]

; 2327 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
__Tmp$258552 = -48					; size = 4
$T258535 = -44						; size = 4
$T258519 = -40						; size = 4
$T258497 = -36						; size = 4
$T258484 = -32						; size = 4
$T258483 = -28						; size = 4
$T258482 = -24						; size = 4
$T258481 = -20						; size = 4
$T258480 = -16						; size = 4
$T258479 = -12						; size = 4
$T258478 = -8						; size = 4
$T258477 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN16@resize@4

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T258497[ebp], ecx
	mov	edx, DWORD PTR $T258497[ebp]
	mov	DWORD PTR $T258478[ebp], edx
	mov	eax, DWORD PTR $T258478[ebp]
	mov	DWORD PTR $T258477[ebp], eax
	lea	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR $T258477[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
	jmp	SHORT $LN4@resize@4

; 720  : 		else if (_Newsize < size())

$LN16@resize@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@4

; 721  : 			erase(begin() + _Newsize, end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T258519[ebp], edx
	mov	eax, DWORD PTR $T258519[ebp]
	mov	DWORD PTR $T258480[ebp], eax
	mov	ecx, DWORD PTR $T258480[ebp]
	mov	DWORD PTR $T258479[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T258535[ebp], eax
	mov	ecx, DWORD PTR $T258535[ebp]
	mov	DWORD PTR $T258482[ebp], ecx
	mov	edx, DWORD PTR $T258482[ebp]
	mov	DWORD PTR __Tmp$258552[ebp], edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Tmp$258552[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$258552[ebp], edx
	mov	eax, DWORD PTR __Tmp$258552[ebp]
	mov	DWORD PTR $T258483[ebp], eax
	mov	ecx, DWORD PTR $T258483[ebp]
	mov	DWORD PTR $T258481[ebp], ecx
	mov	edx, DWORD PTR $T258479[ebp]
	push	edx
	mov	eax, DWORD PTR $T258481[ebp]
	push	eax
	lea	ecx, DWORD PTR $T258484[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN4@resize@4:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0
__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T259203 = -412						; size = 4
$T259151 = -368						; size = 4
$T259139 = -364						; size = 4
$T259129 = -357						; size = 1
$T259128 = -356						; size = 4
__Cat$259146 = -327					; size = 1
$T259143 = -326						; size = 1
$T259142 = -325						; size = 1
$T259100 = -324						; size = 4
$T259092 = -320						; size = 4
$T259084 = -316						; size = 4
$T259073 = -312						; size = 4
$T259072 = -308						; size = 4
__Cat$259080 = -302					; size = 1
$T259078 = -301						; size = 1
$T259001 = -276						; size = 4
$T258982 = -272						; size = 4
$T258965 = -265						; size = 1
$T258964 = -264						; size = 4
$T258954 = -260						; size = 4
$T258953 = -256						; size = 4
__Cat$258999 = -250					; size = 1
$T258997 = -249						; size = 1
$T258996 = -248						; size = 1
__Cat$258990 = -247					; size = 1
$T258988 = -246						; size = 1
$T258987 = -245						; size = 1
$T258929 = -244						; size = 4
$T258928 = -240						; size = 4
$T258924 = -236						; size = 4
$T258923 = -232						; size = 4
$T258912 = -228						; size = 4
$T258911 = -224						; size = 4
__Cat$258919 = -218					; size = 1
$T258917 = -217						; size = 1
$T258876 = -216						; size = 4
$T258875 = -212						; size = 4
__Cat$258883 = -206					; size = 1
$T258881 = -205						; size = 1
$T258846 = -204						; size = 4
$T258845 = -200						; size = 4
__Cat$258853 = -194					; size = 1
$T258851 = -193						; size = 1
$T258826 = -192						; size = 4
$T258814 = -188						; size = 4
$T258804 = -181						; size = 1
$T258803 = -180						; size = 4
__Cat$258822 = -175					; size = 1
$T258820 = -174						; size = 1
$T258819 = -173						; size = 1
$T258791 = -172						; size = 4
$T258779 = -168						; size = 4
$T258769 = -161						; size = 1
$T258768 = -160						; size = 4
__Cat$258787 = -155					; size = 1
$T258785 = -154						; size = 1
$T258784 = -153						; size = 1
$T258756 = -152						; size = 4
$T258744 = -148						; size = 4
$T258734 = -141						; size = 1
$T258733 = -140						; size = 4
__Cat$258751 = -135					; size = 1
$T258749 = -134						; size = 1
$T258748 = -133						; size = 1
__Count$258707 = -120					; size = 4
__Count$258681 = -48					; size = 4
__Tmp$215030 = -44					; size = 4
__Oldend$215031 = -40					; size = 4
__Tmp$215020 = -36					; size = 4
__Ncopied$215007 = -32					; size = 4
__Newvec$215005 = -28					; size = 4
__Whereoff$215006 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@6
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@6
$LN29@Insert_n@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@6:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@6
	jmp	$LN16@Insert_n@6
$LN14@Insert_n@6:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$258681[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$258681[ebp], 0
	jbe	SHORT $LN35@Insert_n@6
	mov	edx, DWORD PTR __Count$258681[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@6
$LN35@Insert_n@6:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
	jmp	$LN16@Insert_n@6

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$258707[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$258707[ebp], 0
	jbe	SHORT $LN48@Insert_n@6
	mov	ecx, DWORD PTR __Count$258707[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@6
$LN48@Insert_n@6:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@6:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@6:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@6:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8
	mov	DWORD PTR __Newvec$215005[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$215006[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$215007[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$215006[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T258756[ebp], edx
	mov	eax, DWORD PTR $T258756[ebp]
	mov	DWORD PTR $T258744[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258748[ebp], cl
	mov	dl, BYTE PTR __Cat$258751[ebp]
	mov	BYTE PTR $T258749[ebp], dl
	mov	al, BYTE PTR $T258748[ebp]
	mov	BYTE PTR $T258734[ebp], al
	mov	ecx, DWORD PTR $T258744[ebp]
	mov	DWORD PTR $T258733[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258733[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$215007[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$215007[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T258791[ebp], ecx
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR $T258779[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T258784[ebp], al
	mov	cl, BYTE PTR __Cat$258787[ebp]
	mov	BYTE PTR $T258785[ebp], cl
	mov	dl, BYTE PTR $T258784[ebp]
	mov	BYTE PTR $T258769[ebp], dl
	mov	eax, DWORD PTR $T258779[ebp]
	mov	DWORD PTR $T258768[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258768[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258791[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$215007[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$215007[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T258826[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$215006[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T258814[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T258819[ebp], dl
	mov	al, BYTE PTR __Cat$258822[ebp]
	mov	BYTE PTR $T258820[ebp], al
	mov	cl, BYTE PTR $T258819[ebp]
	mov	BYTE PTR $T258804[ebp], cl
	mov	edx, DWORD PTR $T258814[ebp]
	mov	DWORD PTR $T258803[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T258803[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258826[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@6
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$215007[ebp], 1
	jle	SHORT $LN7@Insert_n@6

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$215006[ebp]
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T258846[ebp], eax
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR $T258845[ebp], ecx
	mov	dl, BYTE PTR __Cat$258853[ebp]
	mov	BYTE PTR $T258851[ebp], dl
$LN7@Insert_n@6:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$215007[ebp], 0
	jle	SHORT $LN6@Insert_n@6

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$215006[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T258876[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$215006[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T258875[ebp], ecx
	mov	dl, BYTE PTR __Cat$258883[ebp]
	mov	BYTE PTR $T258881[ebp], dl
$LN6@Insert_n@6:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$215005[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@6
	ret	0
$LN19@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T258924[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T258923[ebp], edx
	mov	eax, DWORD PTR $T258924[ebp]
	mov	DWORD PTR $T258912[ebp], eax
	mov	ecx, DWORD PTR $T258923[ebp]
	mov	DWORD PTR $T258911[ebp], ecx
	mov	dl, BYTE PTR __Cat$258919[ebp]
	mov	BYTE PTR $T258917[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T258929[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T258928[ebp], ecx
	mov	edx, DWORD PTR $T258928[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@6
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$215020[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T259001[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T258982[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258987[ebp], cl
	mov	dl, BYTE PTR __Cat$258990[ebp]
	mov	BYTE PTR $T258988[ebp], dl
	mov	al, BYTE PTR $T258987[ebp]
	mov	BYTE PTR $T258965[ebp], al
	mov	ecx, DWORD PTR $T258982[ebp]
	mov	DWORD PTR $T258964[ebp], ecx
	mov	edx, DWORD PTR $T258964[ebp]
	mov	DWORD PTR $T258954[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T258953[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T258996[ebp], cl
	mov	dl, BYTE PTR __Cat$258999[ebp]
	mov	BYTE PTR $T258997[ebp], dl
	movzx	eax, BYTE PTR $T258996[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T258997[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T258954[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259001[ebp]
	push	ecx
	mov	edx, DWORD PTR $T258953[ebp]
	push	edx
	call	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$215020[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@6
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T259084[ebp], eax
	mov	ecx, DWORD PTR $T259084[ebp]
	mov	DWORD PTR $T259073[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T259072[ebp], ecx
	mov	dl, BYTE PTR __Cat$259080[ebp]
	mov	BYTE PTR $T259078[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3
	ret	0
$LN21@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T259100[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T259092[ebp], edx
	jmp	SHORT $LN151@Insert_n@6
$LN150@Insert_n@6:
	mov	eax, DWORD PTR $T259092[ebp]
	add	eax, 4
	mov	DWORD PTR $T259092[ebp], eax
$LN151@Insert_n@6:
	mov	ecx, DWORD PTR $T259092[ebp]
	cmp	ecx, DWORD PTR $T259100[ebp]
	je	SHORT $LN147@Insert_n@6
	mov	edx, DWORD PTR $T259092[ebp]
	mov	eax, DWORD PTR __Tmp$215020[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@6
$LN147@Insert_n@6:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@6
$LN3@Insert_n@6:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$215030[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$215031[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T259151[ebp], eax
	mov	ecx, DWORD PTR $T259151[ebp]
	mov	DWORD PTR $T259139[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T259142[ebp], dl
	mov	al, BYTE PTR __Cat$259146[ebp]
	mov	BYTE PTR $T259143[ebp], al
	mov	cl, BYTE PTR $T259142[ebp]
	mov	BYTE PTR $T259129[ebp], cl
	mov	edx, DWORD PTR $T259139[ebp]
	mov	DWORD PTR $T259128[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259128[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$215031[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$215031[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$215031[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$215031[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T259203[ebp], ecx
	jmp	SHORT $LN186@Insert_n@6
$LN185@Insert_n@6:
	mov	edx, DWORD PTR $T259203[ebp]
	add	edx, 4
	mov	DWORD PTR $T259203[ebp], edx
$LN186@Insert_n@6:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T259203[ebp], edx
	je	SHORT $LN16@Insert_n@6
	mov	eax, DWORD PTR $T259203[ebp]
	mov	ecx, DWORD PTR __Tmp$215030[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@6
$LN16@Insert_n@6:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T259274 = -40						; size = 4
$T259264 = -33						; size = 1
$T259263 = -32						; size = 4
__Cat$259269 = -3					; size = 1
$T259267 = -2						; size = 1
$T259266 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T259274[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T259266[ebp], cl
	mov	dl, BYTE PTR __Cat$259269[ebp]
	mov	BYTE PTR $T259267[ebp], dl
	mov	al, BYTE PTR $T259266[ebp]
	mov	BYTE PTR $T259264[ebp], al
	mov	ecx, DWORD PTR $T259274[ebp]
	mov	DWORD PTR $T259263[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T259263[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
_i$215101 = -4						; size = 4
_kStream$ = 8						; size = 4
_kArray$ = 12						; size = 4
??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z PROC ; operator>><int,6>, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 561  : 	for( unsigned int i = 0; i < kArray.size(); ++i )

	mov	DWORD PTR _i$215101[ebp], 0
	jmp	SHORT $LN6@operator@8
$LN2@operator@8:
	mov	eax, DWORD PTR _i$215101[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215101[ebp], eax
$LN6@operator@8:
	cmp	DWORD PTR _i$215101[ebp], 6
	jae	SHORT $LN1@operator@8

; 562  : 	{
; 563  : 		kStream >> kArray[i];

	mov	ecx, DWORD PTR _i$215101[ebp]
	mov	edx, DWORD PTR _kArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 564  : 	}

	jmp	SHORT $LN2@operator@8
$LN1@operator@8:

; 565  : 	return kStream;

	mov	eax, DWORD PTR _kStream$[ebp]

; 566  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H$05@@YAAAVFDataStream@@AAV0@AAV?$Array@H$05@Firaxis@@@Z ENDP ; operator>><int,6>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z
_TEXT	SEGMENT
_i$215401 = -4						; size = 4
_kStream$ = 8						; size = 4
_kArray$ = 12						; size = 4
??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z PROC ; operator<<<int,6>, COMDAT

; 570  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 571  : 	for( unsigned int i = 0; i < kArray.size(); ++i )

	mov	DWORD PTR _i$215401[ebp], 0
	jmp	SHORT $LN6@operator@9
$LN2@operator@9:
	mov	eax, DWORD PTR _i$215401[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215401[ebp], eax
$LN6@operator@9:
	cmp	DWORD PTR _i$215401[ebp], 6
	jae	SHORT $LN1@operator@9

; 572  : 	{
; 573  : 		kStream << kArray[i];

	mov	ecx, DWORD PTR _i$215401[ebp]
	mov	edx, DWORD PTR _kArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 574  : 	}

	jmp	SHORT $LN2@operator@9
$LN1@operator@9:

; 575  : 	return kStream;

	mov	eax, DWORD PTR _kStream$[ebp]

; 576  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H$05@@YAAAVFDataStream@@AAV0@ABV?$Array@H$05@Firaxis@@@Z ENDP ; operator<<<int,6>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T259341 = -38						; size = 1
$T259340 = -37						; size = 1
$T259339 = -36						; size = 4
$T259338 = -32						; size = 4
$T259325 = -25						; size = 1
$T259324 = -24						; size = 4
$T259323 = -20						; size = 4
__Off$259334 = -16					; size = 4
__Result$259335 = -12					; size = 4
__Cat$259330 = -8					; size = 1
$T259328 = -7						; size = 1
$T259327 = -6						; size = 1
__Cat$259305 = -4					; size = 1
$T259301 = -3						; size = 1
$T259300 = -2						; size = 1
$T259299 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T259299[ebp], al
	mov	cl, BYTE PTR __Cat$259305[ebp]
	mov	BYTE PTR $T259300[ebp], cl
	mov	dl, BYTE PTR $T259299[ebp]
	mov	BYTE PTR $T259341[ebp], dl
	mov	al, BYTE PTR $T259301[ebp]
	mov	BYTE PTR $T259340[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T259339[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259338[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T259327[ebp], al
	mov	cl, BYTE PTR __Cat$259330[ebp]
	mov	BYTE PTR $T259328[ebp], cl
	mov	dl, BYTE PTR $T259327[ebp]
	mov	BYTE PTR $T259325[ebp], dl
	mov	eax, DWORD PTR $T259339[ebp]
	mov	DWORD PTR $T259324[ebp], eax
	mov	ecx, DWORD PTR $T259338[ebp]
	mov	DWORD PTR $T259323[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T259323[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$259334[ebp], edx
	mov	eax, DWORD PTR __Off$259334[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T259324[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$259335[ebp], ecx
	cmp	DWORD PTR __Off$259334[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$259334[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T259323[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$259334[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$259335[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$259335[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z
_TEXT	SEGMENT
$T259404 = -38						; size = 1
$T259403 = -37						; size = 1
$T259402 = -36						; size = 4
$T259401 = -32						; size = 4
$T259383 = -25						; size = 1
$T259382 = -24						; size = 4
$T259381 = -20						; size = 4
$T259380 = -16						; size = 4
_i$259394 = -12						; size = 4
__Cat$259389 = -8					; size = 1
$T259387 = -7						; size = 1
$T259386 = -6						; size = 1
__Cat$259349 = -4					; size = 1
$T259346 = -3						; size = 1
$T259345 = -2						; size = 1
$T259344 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T259344[ebp], al
	mov	cl, BYTE PTR __Cat$259349[ebp]
	mov	BYTE PTR $T259345[ebp], cl
	mov	dl, BYTE PTR $T259344[ebp]
	mov	BYTE PTR $T259404[ebp], dl
	mov	al, BYTE PTR $T259346[ebp]
	mov	BYTE PTR $T259403[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T259402[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259401[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T259386[ebp], al
	mov	cl, BYTE PTR __Cat$259389[ebp]
	mov	BYTE PTR $T259387[ebp], cl
	mov	dl, BYTE PTR $T259386[ebp]
	mov	BYTE PTR $T259383[ebp], dl
	mov	eax, DWORD PTR $T259402[ebp]
	mov	DWORD PTR $T259382[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T259381[ebp], ecx
	mov	edx, DWORD PTR $T259401[ebp]
	mov	DWORD PTR $T259380[ebp], edx
$LN12@Unchecked_@2:
	mov	eax, DWORD PTR $T259380[ebp]
	cmp	eax, DWORD PTR $T259381[ebp]
	je	SHORT $LN7@Unchecked_@2
	mov	ecx, DWORD PTR $T259381[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR $T259381[ebp], ecx
	mov	edx, DWORD PTR $T259382[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR $T259382[ebp], edx
	mov	DWORD PTR _i$259394[ebp], 0
	jmp	SHORT $LN17@Unchecked_@2
$LN16@Unchecked_@2:
	mov	eax, DWORD PTR _i$259394[ebp]
	add	eax, 1
	mov	DWORD PTR _i$259394[ebp], eax
$LN17@Unchecked_@2:
	cmp	DWORD PTR _i$259394[ebp], 6
	jae	SHORT $LN18@Unchecked_@2
	mov	ecx, DWORD PTR _i$259394[ebp]
	mov	edx, DWORD PTR $T259382[ebp]
	mov	eax, DWORD PTR _i$259394[ebp]
	mov	esi, DWORD PTR $T259381[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN16@Unchecked_@2
$LN18@Unchecked_@2:
	jmp	SHORT $LN12@Unchecked_@2
$LN7@Unchecked_@2:
	mov	eax, DWORD PTR $T259382[ebp]

; 3697 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAV?$Array@H$05@Firaxis@@PAV12@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
__Cat$259412 = -4					; size = 1
$T259409 = -3						; size = 1
$T259408 = -2						; size = 1
$T259407 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2740 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2741 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2742 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T259407[ebp], al
	mov	cl, BYTE PTR __Cat$259412[ebp]
	mov	BYTE PTR $T259408[ebp], cl
	movzx	edx, BYTE PTR $T259407[ebp]
	push	edx
	movzx	eax, BYTE PTR $T259408[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T259409[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2743 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T259596 = -38						; size = 1
$T259595 = -37						; size = 1
$T259594 = -36						; size = 4
$T259593 = -32						; size = 4
$T259580 = -25						; size = 1
$T259579 = -24						; size = 4
$T259578 = -20						; size = 4
__Off$259589 = -16					; size = 4
__Result$259590 = -12					; size = 4
__Cat$259586 = -8					; size = 1
$T259584 = -7						; size = 1
$T259583 = -6						; size = 1
__Cat$259559 = -4					; size = 1
$T259556 = -3						; size = 1
$T259555 = -2						; size = 1
$T259554 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T259554[ebp], al
	mov	cl, BYTE PTR __Cat$259559[ebp]
	mov	BYTE PTR $T259555[ebp], cl
	mov	dl, BYTE PTR $T259554[ebp]
	mov	BYTE PTR $T259596[ebp], dl
	mov	al, BYTE PTR $T259556[ebp]
	mov	BYTE PTR $T259595[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T259594[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259593[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T259583[ebp], al
	mov	cl, BYTE PTR __Cat$259586[ebp]
	mov	BYTE PTR $T259584[ebp], cl
	mov	dl, BYTE PTR $T259583[ebp]
	mov	BYTE PTR $T259580[ebp], dl
	mov	eax, DWORD PTR $T259594[ebp]
	mov	DWORD PTR $T259579[ebp], eax
	mov	ecx, DWORD PTR $T259593[ebp]
	mov	DWORD PTR $T259578[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T259578[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$259589[ebp], edx
	mov	eax, DWORD PTR __Off$259589[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T259579[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$259590[ebp], ecx
	cmp	DWORD PTR __Off$259589[ebp], 0
	jle	SHORT $LN7@Unchecked_@3
	mov	edx, DWORD PTR __Off$259589[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T259578[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$259589[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$259590[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@3:
	mov	eax, DWORD PTR __Result$259590[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T259624 = -28						; size = 4
__Vptr$259622 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@4
$LN5@Uninit_fil@4:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@4:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$259622[ebp], eax
	mov	ecx, DWORD PTR __Vptr$259622[ebp]
	mov	DWORD PTR $T259624[ebp], ecx
	cmp	DWORD PTR $T259624[ebp], 0
	je	SHORT $LN18@Uninit_fil@4
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T259624[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T259624[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil@4
$LN18@Uninit_fil@4:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil@4:
	jmp	SHORT $LN5@Uninit_fil@4
$LN4@Uninit_fil@4:
	jmp	SHORT $LN10@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@4
$LN2@Uninit_fil@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil@4:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@4

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@4
	ret	0
$LN10@Uninit_fil@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@4:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$Array@H$05@Firaxis@@IV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAXPAV?$Array@H$05@Firaxis@@IABV12@AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Firaxis::Array<int,6> *,unsigned int,Firaxis::Array<int,6>,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
tv190 = -32						; size = 4
tv179 = -28						; size = 4
tv171 = -24						; size = 4
$T259726 = -17						; size = 1
$T259690 = -16						; size = 4
$T259689 = -12						; size = 4
$T259648 = -8						; size = 8
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	cmp	DWORD PTR __First$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN11@Fill
	mov	eax, DWORD PTR __First$[ebp+4]
	add	eax, 1
	mov	DWORD PTR __First$[ebp+4], eax
	jmp	SHORT $LN3@Fill
$LN11@Fill:
	mov	DWORD PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN18@Fill
	mov	eax, DWORD PTR __First$[ebp+4]
	cmp	eax, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN18@Fill
	mov	DWORD PTR tv171[ebp], 1
	jmp	SHORT $LN14@Fill
$LN18@Fill:
	mov	DWORD PTR tv171[ebp], 0
$LN14@Fill:
	movzx	ecx, BYTE PTR tv171[ebp]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T259690[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259689[ebp], ecx
	mov	edx, DWORD PTR $T259689[ebp]
	mov	DWORD PTR $T259648[ebp], edx
	mov	eax, DWORD PTR $T259690[ebp]
	mov	DWORD PTR $T259648[ebp+4], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T259726[ebp], dl
	movzx	eax, BYTE PTR $T259726[ebp]
	test	eax, eax
	je	SHORT $LN34@Fill
	mov	ecx, DWORD PTR $T259648[ebp]
	mov	DWORD PTR tv179[ebp], ecx
	mov	edx, 1
	mov	ecx, DWORD PTR $T259648[ebp+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv179[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv179[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN28@Fill
$LN34@Fill:
	mov	edx, DWORD PTR $T259648[ebp]
	mov	DWORD PTR tv190[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR $T259648[ebp+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv190[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv190[ebp]
	mov	DWORD PTR [edx], eax
$LN28@Fill:
	jmp	$LN2@Fill
$LN4@Fill:

; 3160 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv150 = -44						; size = 4
$T259810 = -32						; size = 4
$T259809 = -28						; size = 4
$T259772 = -24						; size = 4
$T259771 = -20						; size = 4
$T259730 = -16						; size = 8
$T259729 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
$LN2@Copy_backw:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN9@Copy_backw
	mov	ecx, DWORD PTR __First$[ebp+4]
	cmp	ecx, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN9@Copy_backw
	mov	DWORD PTR tv150[ebp], 1
	jmp	SHORT $LN5@Copy_backw
$LN9@Copy_backw:
	mov	DWORD PTR tv150[ebp], 0
$LN5@Copy_backw:
	movzx	edx, BYTE PTR tv150[ebp]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	cmp	DWORD PTR __Last$[ebp+4], 0
	je	SHORT $LN16@Copy_backw
	mov	ecx, DWORD PTR __Last$[ebp+4]
	sub	ecx, 1
	mov	DWORD PTR __Last$[ebp+4], ecx
	jmp	SHORT $LN11@Copy_backw
$LN16@Copy_backw:
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Last$[ebp], edx
	mov	DWORD PTR __Last$[ebp+4], 31		; 0000001fH
$LN11@Copy_backw:
	mov	eax, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR $T259772[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T259771[ebp], ecx
	mov	edx, DWORD PTR $T259771[ebp]
	mov	DWORD PTR $T259730[ebp], edx
	mov	eax, DWORD PTR $T259772[ebp]
	mov	DWORD PTR $T259730[ebp+4], eax
	cmp	DWORD PTR __Dest$[ebp+4], 0
	je	SHORT $LN30@Copy_backw
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	sub	ecx, 1
	mov	DWORD PTR __Dest$[ebp+4], ecx
	jmp	SHORT $LN25@Copy_backw
$LN30@Copy_backw:
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], 31		; 0000001fH
$LN25@Copy_backw:
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR $T259810[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T259809[ebp], ecx
	mov	edx, DWORD PTR $T259809[ebp]
	mov	DWORD PTR $T259729[ebp], edx
	mov	eax, DWORD PTR $T259810[ebp]
	mov	DWORD PTR $T259729[ebp+4], eax
	lea	ecx, DWORD PTR $T259730[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T259729[ebp]
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
	jmp	$LN2@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T259891 = -22						; size = 1
$T259890 = -21						; size = 1
$T259889 = -20						; size = 4
$T259880 = -13						; size = 1
$T259879 = -12						; size = 4
$T259878 = -8						; size = 4
$T259883 = -4						; size = 1
$T259865 = -2						; size = 1
$T259864 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T259864[ebp], al
	mov	cl, BYTE PTR $T259864[ebp]
	mov	BYTE PTR $T259891[ebp], cl
	mov	dl, BYTE PTR $T259865[ebp]
	mov	BYTE PTR $T259890[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259889[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T259883[ebp], cl
	mov	dl, BYTE PTR $T259883[ebp]
	mov	BYTE PTR $T259880[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T259879[ebp], eax
	mov	ecx, DWORD PTR $T259889[ebp]
	mov	DWORD PTR $T259878[ebp], ecx
	jmp	SHORT $LN9@unchecked_@5
$LN8@unchecked_@5:
	mov	edx, DWORD PTR $T259879[ebp]
	sub	edx, 1
	mov	DWORD PTR $T259879[ebp], edx
	mov	eax, DWORD PTR $T259878[ebp]
	add	eax, 4
	mov	DWORD PTR $T259878[ebp], eax
$LN9@unchecked_@5:
	cmp	DWORD PTR $T259879[ebp], 0
	jbe	SHORT $LN1@unchecked_@5
	mov	ecx, DWORD PTR $T259878[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@5
$LN1@unchecked_@5:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
$T259921 = -22						; size = 1
$T259920 = -21						; size = 1
$T259919 = -20						; size = 4
$T259910 = -13						; size = 1
$T259909 = -12						; size = 4
$T259908 = -8						; size = 4
$T259913 = -4						; size = 1
$T259895 = -2						; size = 1
$T259894 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T259894[ebp], al
	mov	cl, BYTE PTR $T259894[ebp]
	mov	BYTE PTR $T259921[ebp], cl
	mov	dl, BYTE PTR $T259895[ebp]
	mov	BYTE PTR $T259920[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259919[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T259913[ebp], cl
	mov	dl, BYTE PTR $T259913[ebp]
	mov	BYTE PTR $T259910[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T259909[ebp], eax
	mov	ecx, DWORD PTR $T259919[ebp]
	mov	DWORD PTR $T259908[ebp], ecx
	jmp	SHORT $LN9@unchecked_@6
$LN8@unchecked_@6:
	mov	edx, DWORD PTR $T259909[ebp]
	sub	edx, 1
	mov	DWORD PTR $T259909[ebp], edx
	mov	eax, DWORD PTR $T259908[ebp]
	add	eax, 4
	mov	DWORD PTR $T259908[ebp], eax
$LN9@unchecked_@6:
	cmp	DWORD PTR $T259909[ebp], 0
	jbe	SHORT $LN1@unchecked_@6
	mov	ecx, DWORD PTR $T259908[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@6
$LN1@unchecked_@6:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T259938 = -21						; size = 1
$T259937 = -20						; size = 4
$T259936 = -16						; size = 4
__Result$259933 = -12					; size = 4
__Count$259932 = -8					; size = 4
__Cat$259928 = -3					; size = 1
$T259925 = -2						; size = 1
$T259924 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T259924[ebp], al
	mov	cl, BYTE PTR __Cat$259928[ebp]
	mov	BYTE PTR $T259925[ebp], cl
	mov	dl, BYTE PTR $T259924[ebp]
	mov	BYTE PTR $T259938[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T259937[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259936[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T259936[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$259932[ebp], edx
	mov	eax, DWORD PTR __Count$259932[ebp]
	mov	ecx, DWORD PTR $T259937[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$259933[ebp], edx
	cmp	DWORD PTR __Count$259932[ebp], 0
	jbe	SHORT $LN6@unchecked_@7
	mov	eax, DWORD PTR __Count$259932[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T259936[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$259932[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T259937[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@7:
	mov	eax, DWORD PTR __Result$259933[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z
_TEXT	SEGMENT
__Cat$259945 = -3					; size = 1
$T259942 = -2						; size = 1
$T259941 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T259941[ebp], al
	mov	cl, BYTE PTR __Cat$259945[ebp]
	mov	BYTE PTR $T259942[ebp], cl
	movzx	edx, BYTE PTR $T259941[ebp]
	push	edx
	movzx	eax, BYTE PTR $T259942[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@stdext@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
$T259963 = -21						; size = 1
$T259962 = -20						; size = 4
$T259961 = -16						; size = 4
__Result$259958 = -12					; size = 4
__Count$259957 = -8					; size = 4
__Cat$259953 = -3					; size = 1
$T259950 = -2						; size = 1
$T259949 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T259949[ebp], al
	mov	cl, BYTE PTR __Cat$259953[ebp]
	mov	BYTE PTR $T259950[ebp], cl
	mov	dl, BYTE PTR $T259949[ebp]
	mov	BYTE PTR $T259963[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T259962[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T259961[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T259961[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$259957[ebp], edx
	mov	eax, DWORD PTR __Count$259957[ebp]
	mov	ecx, DWORD PTR $T259962[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$259958[ebp], edx
	cmp	DWORD PTR __Count$259957[ebp], 0
	jbe	SHORT $LN6@unchecked_@8
	mov	eax, DWORD PTR __Count$259957[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T259961[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$259957[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T259962[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@8:
	mov	eax, DWORD PTR __Result$259958[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@4

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@4:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T259993 = -28						; size = 4
__Vptr$259991 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@5
$LN5@Uninit_cop@5:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@5:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@5

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$259991[ebp], ecx
	mov	edx, DWORD PTR __Vptr$259991[ebp]
	mov	DWORD PTR $T259993[ebp], edx
	cmp	DWORD PTR $T259993[ebp], 0
	je	SHORT $LN18@Uninit_cop@5
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T259993[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR $T259993[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop@5
$LN18@Uninit_cop@5:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop@5:
	jmp	SHORT $LN5@Uninit_cop@5
$LN4@Uninit_cop@5:
	jmp	SHORT $LN10@Uninit_cop@5
__catch$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@5
$LN2@Uninit_cop@5:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@5:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@5

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@5
$LN1@Uninit_cop@5:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@5:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAV?$Array@H$05@Firaxis@@PAV12@V?$allocator@V?$Array@H$05@Firaxis@@@std@@@std@@YAPAV?$Array@H$05@Firaxis@@PAV12@00AAV?$allocator@V?$Array@H$05@Firaxis@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Firaxis::Array<int,6> *,Firaxis::Array<int,6> *,std::allocator<Firaxis::Array<int,6> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@6

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@6:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
END
