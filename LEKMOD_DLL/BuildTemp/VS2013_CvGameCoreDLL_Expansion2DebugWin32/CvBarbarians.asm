; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvBarbarians.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
PUBLIC	?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
_BSS	SEGMENT
?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA DD 01H DUP (?) ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA DD 01H DUP (?) ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
_BSS	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?IsPlotValidForBarbCamp@CvBarbarians@@CA_NPAVCvPlot@@@Z ; CvBarbarians::IsPlotValidForBarbCamp
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbarbarians.cpp
;	COMDAT ?IsPlotValidForBarbCamp@CvBarbarians@@CA_NPAVCvPlot@@@Z
_TEXT	SEGMENT
tv130 = -156						; size = 4
tv170 = -152						; size = 4
$T218218 = -148						; size = 4
$T218205 = -144						; size = 4
$T218201 = -140						; size = 4
$T218187 = -136						; size = 4
$T218183 = -129						; size = 1
$T218172 = -128						; size = 4
$T218168 = -121						; size = 1
_iMapY$218262 = -120					; size = 4
_iMapX$218261 = -116					; size = 4
_iLoopPlotX$217396 = -36				; size = 4
_iLoopPlotY$217397 = -32				; size = 4
_pLoopPlot$217399 = -28					; size = 4
_iDX$217389 = -24					; size = 4
_iDY$ = -20						; size = 4
_kMap$ = -16						; size = 4
_iPlotY$ = -12						; size = 4
_iRange$ = -8						; size = 4
_iPlotX$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?IsPlotValidForBarbCamp@CvBarbarians@@CA_NPAVCvPlot@@@Z PROC ; CvBarbarians::IsPlotValidForBarbCamp, COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH

; 27   : 	int iRange = 4;

	mov	DWORD PTR _iRange$[ebp], 4

; 28   : 	int iDY;
; 29   : 
; 30   : #ifdef AUI_HEXSPACE_DX_LOOPS
; 31   : 	int iMaxDX, iDX;
; 32   : 	CvPlot* pLoopPlot;
; 33   : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 34   : 	{
; 35   : 		iMaxDX = iRange - MAX(0, iDY);
; 36   : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 37   : 		{
; 38   : 			// No need for range check because loops are set up properly
; 39   : 			pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 40   : #else
; 41   : 	int iPlotX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iPlotX$[ebp], ecx

; 42   : 	int iPlotY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 43   : 
; 44   : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], ecx

; 45   : 	for (int iDX = -(iRange); iDX <= iRange; iDX++)

	mov	edx, DWORD PTR _iRange$[ebp]
	neg	edx
	mov	DWORD PTR _iDX$217389[ebp], edx
	jmp	SHORT $LN9@IsPlotVali
$LN8@IsPlotVali:
	mov	eax, DWORD PTR _iDX$217389[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$217389[ebp], eax
$LN9@IsPlotVali:
	mov	ecx, DWORD PTR _iDX$217389[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jg	$LN7@IsPlotVali

; 46   : 	{
; 47   : 		for (iDY = -(iRange); iDY <= iRange; iDY++)

	mov	edx, DWORD PTR _iRange$[ebp]
	neg	edx
	mov	DWORD PTR _iDY$[ebp], edx
	jmp	SHORT $LN6@IsPlotVali
$LN5@IsPlotVali:
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, 1
	mov	DWORD PTR _iDY$[ebp], eax
$LN6@IsPlotVali:
	mov	ecx, DWORD PTR _iDY$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jg	$LN4@IsPlotVali

; 48   : 		{
; 49   : 			int iLoopPlotX = iPlotX + iDX;

	mov	edx, DWORD PTR _iPlotX$[ebp]
	add	edx, DWORD PTR _iDX$217389[ebp]
	mov	DWORD PTR _iLoopPlotX$217396[ebp], edx

; 50   : 			int iLoopPlotY = iPlotY + iDY;

	mov	eax, DWORD PTR _iPlotY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iLoopPlotY$217397[ebp], eax

; 51   : 
; 52   : 			// Cut off corners
; 53   : 			if (plotDistance(iPlotX, iPlotY, iLoopPlotX, iLoopPlotY) > iRange)

	mov	ecx, DWORD PTR _iLoopPlotY$217397[ebp]
	push	ecx
	mov	edx, DWORD PTR _iLoopPlotX$217396[ebp]
	push	edx
	mov	eax, DWORD PTR _iPlotY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotX$[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN3@IsPlotVali

; 54   : 				continue;

	jmp	SHORT $LN5@IsPlotVali
$LN3@IsPlotVali:

; 55   : 
; 56   : 			// If the counter is below -1 that means a camp was cleared recently
; 57   : 			CvPlot* pLoopPlot = kMap.plot(iLoopPlotX, iLoopPlotY);

	cmp	DWORD PTR _iLoopPlotX$217396[ebp], -2147483647 ; 80000001H
	je	SHORT $LN70@IsPlotVali
	cmp	DWORD PTR _iLoopPlotY$217397[ebp], -2147483647 ; 80000001H
	jne	SHORT $LN71@IsPlotVali
$LN70@IsPlotVali:
	mov	DWORD PTR _pLoopPlot$217399[ebp], 0
	jmp	$LN72@IsPlotVali
$LN71@IsPlotVali:
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T218168[ebp], al
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T218172[ebp], edx
	movzx	eax, BYTE PTR $T218168[ebp]
	test	eax, eax
	je	SHORT $LN83@IsPlotVali
	cmp	DWORD PTR _iLoopPlotX$217396[ebp], 0
	jge	SHORT $LN82@IsPlotVali
	mov	eax, DWORD PTR _iLoopPlotX$217396[ebp]
	cdq
	idiv	DWORD PTR $T218172[ebp]
	add	edx, DWORD PTR $T218172[ebp]
	mov	DWORD PTR _iMapX$218261[ebp], edx
	jmp	SHORT $LN84@IsPlotVali
	jmp	SHORT $LN83@IsPlotVali
$LN82@IsPlotVali:
	mov	ecx, DWORD PTR _iLoopPlotX$217396[ebp]
	cmp	ecx, DWORD PTR $T218172[ebp]
	jl	SHORT $LN83@IsPlotVali
	mov	eax, DWORD PTR _iLoopPlotX$217396[ebp]
	cdq
	idiv	DWORD PTR $T218172[ebp]
	mov	DWORD PTR _iMapX$218261[ebp], edx
	jmp	SHORT $LN84@IsPlotVali
$LN83@IsPlotVali:
	mov	edx, DWORD PTR _iLoopPlotX$217396[ebp]
	mov	DWORD PTR _iMapX$218261[ebp], edx
$LN84@IsPlotVali:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T218183[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T218187[ebp], eax
	movzx	ecx, BYTE PTR $T218183[ebp]
	test	ecx, ecx
	je	SHORT $LN93@IsPlotVali
	cmp	DWORD PTR _iLoopPlotY$217397[ebp], 0
	jge	SHORT $LN92@IsPlotVali
	mov	eax, DWORD PTR _iLoopPlotY$217397[ebp]
	cdq
	idiv	DWORD PTR $T218187[ebp]
	add	edx, DWORD PTR $T218187[ebp]
	mov	DWORD PTR _iMapY$218262[ebp], edx
	jmp	SHORT $LN94@IsPlotVali
	jmp	SHORT $LN93@IsPlotVali
$LN92@IsPlotVali:
	mov	edx, DWORD PTR _iLoopPlotY$217397[ebp]
	cmp	edx, DWORD PTR $T218187[ebp]
	jl	SHORT $LN93@IsPlotVali
	mov	eax, DWORD PTR _iLoopPlotY$217397[ebp]
	cdq
	idiv	DWORD PTR $T218187[ebp]
	mov	DWORD PTR _iMapY$218262[ebp], edx
	jmp	SHORT $LN94@IsPlotVali
$LN93@IsPlotVali:
	mov	eax, DWORD PTR _iLoopPlotY$217397[ebp]
	mov	DWORD PTR _iMapY$218262[ebp], eax
$LN94@IsPlotVali:
	cmp	DWORD PTR _iMapX$218261[ebp], 0
	jl	SHORT $LN98@IsPlotVali
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T218201[ebp], edx
	mov	eax, DWORD PTR _iMapX$218261[ebp]
	cmp	eax, DWORD PTR $T218201[ebp]
	jge	SHORT $LN98@IsPlotVali
	cmp	DWORD PTR _iMapY$218262[ebp], 0
	jl	SHORT $LN98@IsPlotVali
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T218205[ebp], edx
	mov	eax, DWORD PTR _iMapY$218262[ebp]
	cmp	eax, DWORD PTR $T218205[ebp]
	jge	SHORT $LN98@IsPlotVali
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN96@IsPlotVali
$LN98@IsPlotVali:
	mov	DWORD PTR tv170[ebp], 0
$LN96@IsPlotVali:
	cmp	DWORD PTR tv170[ebp], 0
	je	SHORT $LN74@IsPlotVali
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T218218[ebp], edx
	mov	eax, DWORD PTR _iMapY$218262[ebp]
	imul	eax, DWORD PTR $T218218[ebp]
	add	eax, DWORD PTR _iMapX$218261[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN75@IsPlotVali
$LN74@IsPlotVali:
	mov	DWORD PTR tv130[ebp], 0
$LN75@IsPlotVali:
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR _pLoopPlot$217399[ebp], edx
$LN72@IsPlotVali:

; 58   : #endif
; 59   : 			if (pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$217399[ebp], 0
	je	SHORT $LN2@IsPlotVali

; 60   : 			{
; 61   : 				if (m_aiPlotBarbCampSpawnCounter[pLoopPlot->GetPlotIndex()] < -1)

	mov	ecx, DWORD PTR _pLoopPlot$217399[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	movsx	edx, WORD PTR [ecx+eax*2]
	cmp	edx, -1
	jge	SHORT $LN2@IsPlotVali

; 62   : 					return false;

	xor	al, al
	jmp	SHORT $LN10@IsPlotVali
$LN2@IsPlotVali:

; 63   : 			}
; 64   : 		}

	jmp	$LN5@IsPlotVali
$LN4@IsPlotVali:

; 65   : 	}

	jmp	$LN8@IsPlotVali
$LN7@IsPlotVali:

; 66   : 
; 67   : 	return true;

	mov	al, 1
$LN10@IsPlotVali:

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlotValidForBarbCamp@CvBarbarians@@CA_NPAVCvPlot@@@Z ENDP ; CvBarbarians::IsPlotValidForBarbCamp
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T218345 = -80						; size = 4
$T218319 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T218319[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T218319[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T218319[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T218345[ebp], edx
	mov	eax, DWORD PTR $T218345[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T218369 = -16						; size = 4
$T218361 = -12						; size = 4
$T218357 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T218357[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218361[ebp], ecx
	movzx	edx, BYTE PTR $T218357[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T218361[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T218361[ebp]
	mov	DWORD PTR $T218369[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T218361[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T218361[ebp]
	mov	DWORD PTR $T218369[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T218369[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T218369[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T218390 = -16						; size = 4
$T218382 = -12						; size = 4
$T218378 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T218378[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T218382[ebp], ecx
	movzx	edx, BYTE PTR $T218378[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T218382[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T218382[ebp]
	mov	DWORD PTR $T218390[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T218382[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T218382[ebp]
	mov	DWORD PTR $T218390[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T218390[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T218390[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z ; CvBarbarians::DoBarbCampCleared
EXTRN	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z:PROC ; CvPlot::AddArchaeologicalRecord
EXTRN	?getARTIFACT_BARBARIAN_CAMP@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ:PROC ; CvTypes::getARTIFACT_BARBARIAN_CAMP
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbarbarians.cpp
;	COMDAT ?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z PROC ; CvBarbarians::DoBarbCampCleared, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   : 	m_aiPlotBarbCampSpawnCounter[pPlot->GetPlotIndex()] = -16;

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	WORD PTR [edx+eax*2], cx

; 75   : 
; 76   : 	pPlot->AddArchaeologicalRecord(CvTypes::getARTIFACT_BARBARIAN_CAMP(), ePlayer, NO_PLAYER);

	push	-1
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	call	?getARTIFACT_BARBARIAN_CAMP@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ ; CvTypes::getARTIFACT_BARBARIAN_CAMP
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z ; CvPlot::AddArchaeologicalRecord

; 77   : }

	pop	ebp
	ret	0
?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z ENDP ; CvBarbarians::DoBarbCampCleared
_TEXT	ENDS
PUBLIC	?CanBarbariansSpawn@CvBarbarians@@CA_NXZ	; CvBarbarians::CanBarbariansSpawn
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
; Function compile flags: /Odtp
;	COMDAT ?CanBarbariansSpawn@CvBarbarians@@CA_NXZ
_TEXT	SEGMENT
_kGame$ = -4						; size = 4
?CanBarbariansSpawn@CvBarbarians@@CA_NXZ PROC		; CvBarbarians::CanBarbariansSpawn, COMDAT

; 82   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 83   : 	CvGame& kGame = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], eax

; 84   : 	if (kGame.getElapsedGameTurns() < 10)

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN1@CanBarbari

; 85   : 	{
; 86   : 		return false;

	xor	al, al
	jmp	SHORT $LN2@CanBarbari
$LN1@CanBarbari:

; 87   : 	}
; 88   : 
; 89   : 	return true;

	mov	al, 1
$LN2@CanBarbari:

; 90   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CanBarbariansSpawn@CvBarbarians@@CA_NXZ ENDP		; CvBarbarians::CanBarbariansSpawn
_TEXT	ENDS
PUBLIC	?ShouldSpawnBarbFromCamp@CvBarbarians@@SA_NPAVCvPlot@@@Z ; CvBarbarians::ShouldSpawnBarbFromCamp
; Function compile flags: /Odtp
;	COMDAT ?ShouldSpawnBarbFromCamp@CvBarbarians@@SA_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?ShouldSpawnBarbFromCamp@CvBarbarians@@SA_NPAVCvPlot@@@Z PROC ; CvBarbarians::ShouldSpawnBarbFromCamp, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp

; 96   : 	if (m_aiPlotBarbCampSpawnCounter[pPlot->GetPlotIndex()] == 0)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	jne	SHORT $LN1@ShouldSpaw

; 97   : 	{
; 98   : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@ShouldSpaw
$LN1@ShouldSpaw:

; 99   : 	}
; 100  : 
; 101  : 	return false;

	xor	al, al
$LN2@ShouldSpaw:

; 102  : }

	pop	ebp
	ret	0
?ShouldSpawnBarbFromCamp@CvBarbarians@@SA_NPAVCvPlot@@@Z ENDP ; CvBarbarians::ShouldSpawnBarbFromCamp
_TEXT	ENDS
PUBLIC	??_C@_0BF@MMFMJOPK@Barb?5Spawn?5Rand?5call?$AA@	; `string'
PUBLIC	?DoCampActivationNotice@CvBarbarians@@CAXPAVCvPlot@@@Z ; CvBarbarians::DoCampActivationNotice
EXTRN	?getBarbPercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getBarbPercent
EXTRN	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z:PROC ; CvGlobals::getGameSpeedInfo
EXTRN	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ:PROC ; CvGame::getGameSpeedType
EXTRN	?getBarbSpawnMod@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getBarbSpawnMod
EXTRN	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z:PROC ; CvGlobals::getHandicapInfo
EXTRN	?getHandicapType@CvGame@@QBE?AW4HandicapTypes@@XZ:PROC ; CvGame::getHandicapType
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
;	COMDAT ??_C@_0BF@MMFMJOPK@Barb?5Spawn?5Rand?5call?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BF@MMFMJOPK@Barb?5Spawn?5Rand?5call?$AA@ DB 'Barb Spawn Rand call', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbarbarians.cpp
CONST	ENDS
;	COMDAT ?DoCampActivationNotice@CvBarbarians@@CAXPAVCvPlot@@@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv64 = -32						; size = 4
$T218411 = -28						; size = 4
$T218402 = -24						; size = 4
_pHandicapInfo$ = -20					; size = 4
_iNumTurnsToSpawn$ = -16				; size = 4
_pGameSpeedInfo$ = -12					; size = 4
_kGame$ = -8						; size = 4
_iNumUnitsSpawned$ = -4					; size = 4
_pPlot$ = 8						; size = 4
?DoCampActivationNotice@CvBarbarians@@CAXPAVCvPlot@@@Z PROC ; CvBarbarians::DoCampActivationNotice, COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 108  : 	CvGame& kGame = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], eax

; 109  : 	// Default to between 8 and 12 turns per spawn
; 110  : 	int iNumTurnsToSpawn = 8 + kGame.getJonRandNum(5, "Barb Spawn Rand call");

	push	OFFSET ??_C@_0BF@MMFMJOPK@Barb?5Spawn?5Rand?5call?$AA@
	push	5
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, 8
	mov	DWORD PTR _iNumTurnsToSpawn$[ebp], eax

; 111  : 
; 112  : 	// Raging
; 113  : 	if (kGame.isOption(GAMEOPTION_RAGING_BARBARIANS))

	push	2
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@DoCampActi

; 114  : 		iNumTurnsToSpawn /= 2;

	mov	eax, DWORD PTR _iNumTurnsToSpawn$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iNumTurnsToSpawn$[ebp], eax
$LN3@DoCampActi:

; 115  : 
; 116  : 	// Num Units Spawned
; 117  : 	int iNumUnitsSpawned = m_aiPlotBarbCampNumUnitsSpawned[pPlot->GetPlotIndex()];

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	edx, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	movsx	eax, WORD PTR [edx+eax*2]
	mov	DWORD PTR _iNumUnitsSpawned$[ebp], eax

; 118  : 
; 119  : 	// Reduce turns between spawn if we've pumped out more guys (meaning we're further into the game)
; 120  : 	iNumTurnsToSpawn -= min(3, iNumUnitsSpawned);	// -1 turns if we've spawned one Unit, -3 turns if we've spawned three

	mov	DWORD PTR $T218402[ebp], 3
	mov	ecx, DWORD PTR _iNumUnitsSpawned$[ebp]
	cmp	ecx, DWORD PTR $T218402[ebp]
	jge	SHORT $LN10@DoCampActi
	lea	edx, DWORD PTR _iNumUnitsSpawned$[ebp]
	mov	DWORD PTR tv64[ebp], edx
	jmp	SHORT $LN11@DoCampActi
$LN10@DoCampActi:
	lea	eax, DWORD PTR $T218402[ebp]
	mov	DWORD PTR tv64[ebp], eax
$LN11@DoCampActi:
	mov	ecx, DWORD PTR tv64[ebp]
	mov	DWORD PTR $T218411[ebp], ecx
	mov	edx, DWORD PTR $T218411[ebp]
	mov	eax, DWORD PTR _iNumTurnsToSpawn$[ebp]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _iNumTurnsToSpawn$[ebp], eax

; 121  : 
; 122  : 	// Increment # of barbs spawned from this camp
; 123  : 	m_aiPlotBarbCampNumUnitsSpawned[pPlot->GetPlotIndex()]++;	// This starts at -1 so when a camp is first created it will bump up to 0, which is correct

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR tv90[ebp], edx
	mov	eax, DWORD PTR tv90[ebp]
	mov	cx, WORD PTR [eax]
	add	cx, 1
	mov	edx, DWORD PTR tv90[ebp]
	mov	WORD PTR [edx], cx

; 124  : 
; 125  : 	//// If it's too early to spawn then add in a small amount to delay things a bit - between 3 and 6 extra turns
; 126  : 	//if (CanBarbariansSpawn())
; 127  : 	//{
; 128  : 	//	iNumTurnsToSpawn += 3;
; 129  : 	//	iNumTurnsToSpawn += auto_ptr<ICvGame1> pGame = GameCore::GetGame();\n.getJonRandNum(4, "Early game Barb Spawn Rand call");
; 130  : 	//}
; 131  : 
; 132  : 	// Difficulty level can add time between spawns (e.g. Settler is +8 turns)
; 133  : 	CvHandicapInfo* pHandicapInfo = GC.getHandicapInfo(kGame.getHandicapType());

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getHandicapType@CvGame@@QBE?AW4HandicapTypes@@XZ ; CvGame::getHandicapType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo
	mov	DWORD PTR _pHandicapInfo$[ebp], eax

; 134  : 	if (pHandicapInfo)

	cmp	DWORD PTR _pHandicapInfo$[ebp], 0
	je	SHORT $LN2@DoCampActi

; 135  : 		iNumTurnsToSpawn += pHandicapInfo->getBarbSpawnMod();

	mov	ecx, DWORD PTR _pHandicapInfo$[ebp]
	call	?getBarbSpawnMod@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getBarbSpawnMod
	add	eax, DWORD PTR _iNumTurnsToSpawn$[ebp]
	mov	DWORD PTR _iNumTurnsToSpawn$[ebp], eax
$LN2@DoCampActi:

; 136  : 
; 137  : 	// Game Speed can increase or decrease amount of time between spawns (ranges from 67 on Quick to 400 on Marathon)
; 138  : 	CvGameSpeedInfo* pGameSpeedInfo = GC.getGameSpeedInfo(kGame.getGameSpeedType());

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getGameSpeedType@CvGame@@QBE?AW4GameSpeedTypes@@XZ ; CvGame::getGameSpeedType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo
	mov	DWORD PTR _pGameSpeedInfo$[ebp], eax

; 139  : 	if (pGameSpeedInfo)

	cmp	DWORD PTR _pGameSpeedInfo$[ebp], 0
	je	SHORT $LN1@DoCampActi

; 140  : 	{
; 141  : 		iNumTurnsToSpawn *= pGameSpeedInfo->getBarbPercent();

	mov	ecx, DWORD PTR _pGameSpeedInfo$[ebp]
	call	?getBarbPercent@CvGameSpeedInfo@@QBEHXZ	; CvGameSpeedInfo::getBarbPercent
	imul	eax, DWORD PTR _iNumTurnsToSpawn$[ebp]
	mov	DWORD PTR _iNumTurnsToSpawn$[ebp], eax

; 142  : 		iNumTurnsToSpawn /= 100;

	mov	eax, DWORD PTR _iNumTurnsToSpawn$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iNumTurnsToSpawn$[ebp], eax
$LN1@DoCampActi:

; 143  : 	}
; 144  : 
; 145  : 	m_aiPlotBarbCampSpawnCounter[pPlot->GetPlotIndex()] = iNumTurnsToSpawn;

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	edx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	cx, WORD PTR _iNumTurnsToSpawn$[ebp]
	mov	WORD PTR [edx+eax*2], cx

; 146  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoCampActivationNotice@CvBarbarians@@CAXPAVCvPlot@@@Z ENDP ; CvBarbarians::DoCampActivationNotice
_TEXT	ENDS
PUBLIC	?DoCampAttacked@CvBarbarians@@SAXPAVCvPlot@@@Z	; CvBarbarians::DoCampAttacked
; Function compile flags: /Odtp
;	COMDAT ?DoCampAttacked@CvBarbarians@@SAXPAVCvPlot@@@Z
_TEXT	SEGMENT
_iNewValue$ = -8					; size = 4
_iCounter$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?DoCampAttacked@CvBarbarians@@SAXPAVCvPlot@@@Z PROC	; CvBarbarians::DoCampAttacked, COMDAT

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 152  : 	int iCounter = m_aiPlotBarbCampSpawnCounter[pPlot->GetPlotIndex()];

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	movsx	edx, WORD PTR [ecx+eax*2]
	mov	DWORD PTR _iCounter$[ebp], edx

; 153  : 
; 154  : 	// Halve the amount of time to spawn
; 155  : 	int iNewValue = iCounter / 2;

	mov	eax, DWORD PTR _iCounter$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iNewValue$[ebp], eax

; 156  : 
; 157  : 	m_aiPlotBarbCampSpawnCounter[pPlot->GetPlotIndex()] = iNewValue;

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	dx, WORD PTR _iNewValue$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 158  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoCampAttacked@CvBarbarians@@SAXPAVCvPlot@@@Z ENDP	; CvBarbarians::DoCampAttacked
_TEXT	ENDS
PUBLIC	?BeginTurn@CvBarbarians@@SAXXZ			; CvBarbarians::BeginTurn
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?GetBarbarianCampImprovementType@CvGame@@QAE?AW4ImprovementTypes@@XZ:PROC ; CvGame::GetBarbarianCampImprovementType
; Function compile flags: /Odtp
;	COMDAT ?BeginTurn@CvBarbarians@@SAXXZ
_TEXT	SEGMENT
tv142 = -32						; size = 4
$T218434 = -28						; size = 4
_pPlot$217448 = -24					; size = 4
_iPlotLoop$217443 = -20					; size = 4
_kMap$ = -16						; size = 4
_iWorldNumPlots$ = -12					; size = 4
_eCamp$ = -8						; size = 4
_kGame$ = -4						; size = 4
?BeginTurn@CvBarbarians@@SAXXZ PROC			; CvBarbarians::BeginTurn, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 164  : 	CvGame &kGame = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], eax

; 165  : 	const ImprovementTypes eCamp = kGame.GetBarbarianCampImprovementType();

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?GetBarbarianCampImprovementType@CvGame@@QAE?AW4ImprovementTypes@@XZ ; CvGame::GetBarbarianCampImprovementType
	mov	DWORD PTR _eCamp$[ebp], eax

; 166  : 
; 167  : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], ecx

; 168  : 	int iWorldNumPlots = kMap.numPlots();

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iWorldNumPlots$[ebp], eax

; 169  : 	for (int iPlotLoop = 0; iPlotLoop < iWorldNumPlots; iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$217443[ebp], 0
	jmp	SHORT $LN8@BeginTurn
$LN7@BeginTurn:
	mov	ecx, DWORD PTR _iPlotLoop$217443[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlotLoop$217443[ebp], ecx
$LN8@BeginTurn:
	mov	edx, DWORD PTR _iPlotLoop$217443[ebp]
	cmp	edx, DWORD PTR _iWorldNumPlots$[ebp]
	jge	$LN9@BeginTurn

; 170  : 	{
; 171  : 		if (m_aiPlotBarbCampSpawnCounter[iPlotLoop] > 0)

	mov	eax, DWORD PTR _iPlotLoop$217443[ebp]
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	movsx	edx, WORD PTR [ecx+eax*2]
	test	edx, edx
	jle	$LN5@BeginTurn

; 172  : 		{
; 173  : 			// No Camp here any more
; 174  : 			CvPlot* pPlot = kMap.plotByIndex(iPlotLoop);

	cmp	DWORD PTR _iPlotLoop$217443[ebp], 0
	jl	SHORT $LN19@BeginTurn
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T218434[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$217443[ebp]
	cmp	edx, DWORD PTR $T218434[ebp]
	jge	SHORT $LN19@BeginTurn
	mov	eax, DWORD PTR _iPlotLoop$217443[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN17@BeginTurn
$LN19@BeginTurn:
	mov	DWORD PTR tv142[ebp], 0
$LN17@BeginTurn:
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR _pPlot$217448[ebp], edx

; 175  : 
; 176  : 			if (pPlot->getImprovementType() != eCamp)

	mov	ecx, DWORD PTR _pPlot$217448[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eCamp$[ebp]
	je	SHORT $LN4@BeginTurn

; 177  : 			{
; 178  : 				m_aiPlotBarbCampSpawnCounter[iPlotLoop] = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _iPlotLoop$217443[ebp]
	mov	edx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	WORD PTR [edx+ecx*2], ax

; 179  : 				m_aiPlotBarbCampNumUnitsSpawned[iPlotLoop] = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _iPlotLoop$217443[ebp]
	mov	edx, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	mov	WORD PTR [edx+ecx*2], ax

; 180  : 			}
; 181  : 			else

	jmp	SHORT $LN3@BeginTurn
$LN4@BeginTurn:

; 182  : 			{
; 183  : 				m_aiPlotBarbCampSpawnCounter[iPlotLoop]--;

	mov	eax, DWORD PTR _iPlotLoop$217443[ebp]
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	dx, WORD PTR [ecx+eax*2]
	sub	dx, 1
	mov	eax, DWORD PTR _iPlotLoop$217443[ebp]
	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	WORD PTR [ecx+eax*2], dx
$LN3@BeginTurn:

; 184  : 			}

	jmp	SHORT $LN2@BeginTurn
$LN5@BeginTurn:

; 185  : 		}
; 186  : 
; 187  : 		// Counter is negative, meaning a camp was cleared here recently and isn't allowed to respawn in the area for a while
; 188  : 		else if (m_aiPlotBarbCampSpawnCounter[iPlotLoop] < -1)

	mov	edx, DWORD PTR _iPlotLoop$217443[ebp]
	mov	eax, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	movsx	ecx, WORD PTR [eax+edx*2]
	cmp	ecx, -1
	jge	SHORT $LN2@BeginTurn

; 189  : 		{
; 190  : 			m_aiPlotBarbCampSpawnCounter[iPlotLoop]++;

	mov	edx, DWORD PTR _iPlotLoop$217443[ebp]
	mov	eax, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	cx, WORD PTR [eax+edx*2]
	add	cx, 1
	mov	edx, DWORD PTR _iPlotLoop$217443[ebp]
	mov	eax, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	WORD PTR [eax+edx*2], cx
$LN2@BeginTurn:

; 191  : 		}

	jmp	$LN7@BeginTurn
$LN9@BeginTurn:

; 192  : 	}
; 193  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginTurn@CvBarbarians@@SAXXZ ENDP			; CvBarbarians::BeginTurn
_TEXT	ENDS
PUBLIC	?MapInit@CvBarbarians@@SAXH@Z			; CvBarbarians::MapInit
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ?MapInit@CvBarbarians@@SAXH@Z
_TEXT	SEGMENT
$T218453 = -20						; size = 4
$T218448 = -16						; size = 4
$T218444 = -12						; size = 4
$T218443 = -8						; size = 4
_iI$ = -4						; size = 4
_iWorldNumPlots$ = 8					; size = 4
?MapInit@CvBarbarians@@SAXH@Z PROC			; CvBarbarians::MapInit, COMDAT

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 198  : 	if (m_aiPlotBarbCampSpawnCounter != NULL)

	cmp	DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	je	SHORT $LN8@MapInit

; 199  : 	{
; 200  : 		SAFE_DELETE_ARRAY(m_aiPlotBarbCampSpawnCounter);

	mov	eax, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	DWORD PTR $T218448[ebp], eax
	mov	ecx, DWORD PTR $T218448[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
$LN8@MapInit:

; 201  : 	}
; 202  : 	if (m_aiPlotBarbCampNumUnitsSpawned != NULL)

	cmp	DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	je	SHORT $LN7@MapInit

; 203  : 	{
; 204  : 		SAFE_DELETE_ARRAY(m_aiPlotBarbCampNumUnitsSpawned);

	mov	edx, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	mov	DWORD PTR $T218453[ebp], edx
	mov	eax, DWORD PTR $T218453[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
$LN7@MapInit:

; 205  : 	}
; 206  : 	
; 207  : 	int iI;
; 208  : 
; 209  : 	if (iWorldNumPlots > 0)

	cmp	DWORD PTR _iWorldNumPlots$[ebp], 0
	jle	$LN9@MapInit

; 210  : 	{
; 211  : 		if (m_aiPlotBarbCampSpawnCounter == NULL)

	cmp	DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	jne	SHORT $LN5@MapInit

; 212  : 		{
; 213  : #ifdef AUI_WARNING_FIXES
; 214  : 			m_aiPlotBarbCampSpawnCounter = FNEW(int[iWorldNumPlots], c_eCiv5GameplayDLL, 0);
; 215  : #else
; 216  : 			m_aiPlotBarbCampSpawnCounter = FNEW(short[iWorldNumPlots], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iWorldNumPlots$[ebp]
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T218443[ebp], eax
	mov	eax, DWORD PTR $T218443[ebp]
	mov	DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA, eax ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
$LN5@MapInit:

; 217  : #endif
; 218  : 		}
; 219  : 		if (m_aiPlotBarbCampNumUnitsSpawned == NULL)

	cmp	DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	jne	SHORT $LN4@MapInit

; 220  : 		{
; 221  : #ifdef AUI_WARNING_FIXES
; 222  : 			m_aiPlotBarbCampNumUnitsSpawned = FNEW(int[iWorldNumPlots], c_eCiv5GameplayDLL, 0);
; 223  : #else
; 224  : 			m_aiPlotBarbCampNumUnitsSpawned = FNEW(short[iWorldNumPlots], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iWorldNumPlots$[ebp]
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T218444[ebp], eax
	mov	eax, DWORD PTR $T218444[ebp]
	mov	DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA, eax ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
$LN4@MapInit:

; 225  : #endif
; 226  : 		}
; 227  : 
; 228  : 		// Default values
; 229  : 		for (iI = 0; iI < iWorldNumPlots; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@MapInit
$LN2@MapInit:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN3@MapInit:
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iWorldNumPlots$[ebp]
	jge	SHORT $LN9@MapInit

; 230  : 		{
; 231  : 			m_aiPlotBarbCampSpawnCounter[iI] = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	WORD PTR [edx+ecx*2], ax

; 232  : 			m_aiPlotBarbCampNumUnitsSpawned[iI] = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	mov	WORD PTR [edx+ecx*2], ax

; 233  : 		}

	jmp	SHORT $LN2@MapInit
$LN9@MapInit:

; 234  : 	}
; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MapInit@CvBarbarians@@SAXH@Z ENDP			; CvBarbarians::MapInit
_TEXT	ENDS
PUBLIC	?Uninit@CvBarbarians@@SAXXZ			; CvBarbarians::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvBarbarians@@SAXXZ
_TEXT	SEGMENT
$T218465 = -8						; size = 4
$T218460 = -4						; size = 4
?Uninit@CvBarbarians@@SAXXZ PROC			; CvBarbarians::Uninit, COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 241  : 	if (m_aiPlotBarbCampSpawnCounter != NULL)

	cmp	DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	je	SHORT $LN2@Uninit

; 242  : 	{
; 243  : 		SAFE_DELETE_ARRAY(m_aiPlotBarbCampSpawnCounter);

	mov	eax, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	DWORD PTR $T218460[ebp], eax
	mov	ecx, DWORD PTR $T218460[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
$LN2@Uninit:

; 244  : 	}
; 245  : 
; 246  : 	if (m_aiPlotBarbCampNumUnitsSpawned != NULL)

	cmp	DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	je	SHORT $LN3@Uninit

; 247  : 	{
; 248  : 		SAFE_DELETE_ARRAY(m_aiPlotBarbCampNumUnitsSpawned);

	mov	edx, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	mov	DWORD PTR $T218465[ebp], edx
	mov	eax, DWORD PTR $T218465[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA, 0 ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
$LN3@Uninit:

; 249  : 	}
; 250  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvBarbarians@@SAXXZ ENDP			; CvBarbarians::Uninit
_TEXT	ENDS
PUBLIC	??$?5F@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@F@@@Z ; operator>><short>
PUBLIC	?Read@CvBarbarians@@SAXAAVFDataStream@@I@Z	; CvBarbarians::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvBarbarians@@SAXAAVFDataStream@@I@Z
_TEXT	SEGMENT
$T218488 = -36						; size = 4
$T218484 = -32						; size = 4
$T218477 = -28						; size = 4
$T218470 = -24						; size = 8
$T218469 = -16						; size = 8
_iWorldNumPlots$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
_uiParentVersion$ = 12					; size = 4
?Read@CvBarbarians@@SAXAAVFDataStream@@I@Z PROC		; CvBarbarians::Read, COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 260  : 	// Version number to maintain backwards compatibility
; 261  : 	uint uiVersion = 0;

	mov	DWORD PTR _uiVersion$[ebp], 0

; 262  : 
; 263  : 	kStream >> uiVersion;	

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 264  : 
; 265  : 	int iWorldNumPlots = GC.getMap().numPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218477[ebp], ecx
	mov	edx, DWORD PTR $T218477[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iWorldNumPlots$[ebp], eax

; 266  : 	MapInit(iWorldNumPlots);	// Map will have been initialized/unserialized by now so this is ok.

	mov	ecx, DWORD PTR _iWorldNumPlots$[ebp]
	push	ecx
	call	?MapInit@CvBarbarians@@SAXH@Z		; CvBarbarians::MapInit
	add	esp, 4

; 267  : 
; 268  : #ifdef AUI_WARNING_FIXES
; 269  : 	ArrayWrapper<int> kWrapper1(iWorldNumPlots, m_aiPlotBarbCampSpawnCounter);
; 270  : 	kStream >> kWrapper1;
; 271  : 	ArrayWrapper<int> kWrapper2(iWorldNumPlots, m_aiPlotBarbCampNumUnitsSpawned);
; 272  : 	kStream >> kWrapper2;
; 273  : #else
; 274  : 	kStream >> ArrayWrapper<short>(iWorldNumPlots, m_aiPlotBarbCampSpawnCounter);

	mov	edx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	DWORD PTR $T218484[ebp], edx
	mov	eax, DWORD PTR $T218484[ebp]
	mov	DWORD PTR $T218469[ebp], eax
	mov	ecx, DWORD PTR _iWorldNumPlots$[ebp]
	mov	DWORD PTR $T218469[ebp+4], ecx
	lea	edx, DWORD PTR $T218469[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5F@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@F@@@Z ; operator>><short>
	add	esp, 8

; 275  : 	kStream >> ArrayWrapper<short>(iWorldNumPlots, m_aiPlotBarbCampNumUnitsSpawned);

	mov	ecx, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	mov	DWORD PTR $T218488[ebp], ecx
	mov	edx, DWORD PTR $T218488[ebp]
	mov	DWORD PTR $T218470[ebp], edx
	mov	eax, DWORD PTR _iWorldNumPlots$[ebp]
	mov	DWORD PTR $T218470[ebp+4], eax
	lea	ecx, DWORD PTR $T218470[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5F@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@F@@@Z ; operator>><short>
	add	esp, 8

; 276  : #endif
; 277  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Read@CvBarbarians@@SAXAAVFDataStream@@I@Z ENDP		; CvBarbarians::Read
_TEXT	ENDS
PUBLIC	??$?6F@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@F@@@Z ; operator<<<short>
PUBLIC	?Write@CvBarbarians@@SAXAAVFDataStream@@@Z	; CvBarbarians::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvBarbarians@@SAXAAVFDataStream@@@Z
_TEXT	SEGMENT
$T218510 = -36						; size = 4
$T218506 = -32						; size = 4
$T218499 = -28						; size = 4
$T218492 = -24						; size = 8
$T218491 = -16						; size = 8
_iWorldNumPlots$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvBarbarians@@SAXAAVFDataStream@@@Z PROC		; CvBarbarians::Write, COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 283  : 	// Current version number
; 284  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 285  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 286  : 
; 287  : 	int iWorldNumPlots = GC.getMap().numPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218499[ebp], ecx
	mov	edx, DWORD PTR $T218499[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iWorldNumPlots$[ebp], eax

; 288  : #ifdef AUI_WARNING_FIXES
; 289  : 	ArrayWrapper<int> kWrapper1(iWorldNumPlots, m_aiPlotBarbCampSpawnCounter);
; 290  : 	kStream << kWrapper1;
; 291  : 	ArrayWrapper<int> kWrapper2(iWorldNumPlots, m_aiPlotBarbCampNumUnitsSpawned);
; 292  : 	kStream << kWrapper2;
; 293  : #else
; 294  : 	kStream << ArrayWrapper<short>(iWorldNumPlots, m_aiPlotBarbCampSpawnCounter);

	mov	ecx, DWORD PTR ?m_aiPlotBarbCampSpawnCounter@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampSpawnCounter
	mov	DWORD PTR $T218506[ebp], ecx
	mov	edx, DWORD PTR $T218506[ebp]
	mov	DWORD PTR $T218491[ebp], edx
	mov	eax, DWORD PTR _iWorldNumPlots$[ebp]
	mov	DWORD PTR $T218491[ebp+4], eax
	lea	ecx, DWORD PTR $T218491[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6F@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@F@@@Z ; operator<<<short>
	add	esp, 8

; 295  : 	kStream << ArrayWrapper<short>(iWorldNumPlots, m_aiPlotBarbCampNumUnitsSpawned);

	mov	eax, DWORD PTR ?m_aiPlotBarbCampNumUnitsSpawned@CvBarbarians@@0PAFA ; CvBarbarians::m_aiPlotBarbCampNumUnitsSpawned
	mov	DWORD PTR $T218510[ebp], eax
	mov	ecx, DWORD PTR $T218510[ebp]
	mov	DWORD PTR $T218492[ebp], ecx
	mov	edx, DWORD PTR _iWorldNumPlots$[ebp]
	mov	DWORD PTR $T218492[ebp+4], edx
	lea	eax, DWORD PTR $T218492[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6F@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@F@@@Z ; operator<<<short>
	add	esp, 8

; 296  : #endif
; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Write@CvBarbarians@@SAXAAVFDataStream@@@Z ENDP		; CvBarbarians::Write
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_0CN@CCKJBOAA@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@ ; `string'
PUBLIC	?GetRandomBarbarianUnitType@CvBarbarians@@CA?AW4UnitTypes@@PAVCvArea@@W4UnitAITypes@@@Z ; CvBarbarians::GetRandomBarbarianUnitType
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
PUBLIC	??_C@_0BM@GAGFPHLN@Barb?5Camp?5Plot?9Finding?5Roll?$AA@ ; `string'
PUBLIC	??_C@_0CN@JIEENMD@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@ ; `string'
PUBLIC	??_C@_0DB@DHGMHKAF@Random?5roll?5to?5see?5if?5Barb?5Camp?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DoCamps@CvBarbarians@@SAXXZ			; CvBarbarians::DoCamps
EXTRN	?updateDeferredFog@CvMap@@QAEXXZ:PROC		; CvMap::updateDeferredFog
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z:PROC ; CvPlot::setRevealedImprovementType
EXTRN	?IsAlwaysSeeBarbCamps@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::IsAlwaysSeeBarbCamps
EXTRN	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z:PROC ; CvPlayer::initUnit
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?isNoImprovement@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNoImprovement
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z:PROC ; CvArea::getNumImprovements
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getLandPlots@CvMap@@QAEHXZ:PROC		; CvMap::getLandPlots
EXTRN	?getFogTilesPerBarbarianCamp@CvWorldInfo@@QBEHXZ:PROC ; CvWorldInfo::getFogTilesPerBarbarianCamp
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?isVisibleToCivTeam@CvPlot@@QBE_NXZ:PROC	; CvPlot::isVisibleToCivTeam
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CN@CCKJBOAA@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CN@CCKJBOAA@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@ DB 'Barb Camp'
	DB	' Plot-Finding Roll - Coastal Bias 2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GAGFPHLN@Barb?5Camp?5Plot?9Finding?5Roll?$AA@
CONST	SEGMENT
??_C@_0BM@GAGFPHLN@Barb?5Camp?5Plot?9Finding?5Roll?$AA@ DB 'Barb Camp Plo'
	DB	't-Finding Roll', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JIEENMD@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@
CONST	SEGMENT
??_C@_0CN@JIEENMD@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@ DB 'Barb Camp '
	DB	'Plot-Finding Roll - Coastal Bias 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DHGMHKAF@Random?5roll?5to?5see?5if?5Barb?5Camp?5@
CONST	SEGMENT
??_C@_0DB@DHGMHKAF@Random?5roll?5to?5see?5if?5Barb?5Camp?5@ DB 'Random ro'
	DB	'll to see if Barb Camp spawns this turn', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoCamps@CvBarbarians@@SAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoCamps@CvBarbarians@@SAXXZ$0
__ehfuncinfo$?DoCamps@CvBarbarians@@SAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoCamps@CvBarbarians@@SAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbarbarians.cpp
xdata$x	ENDS
;	COMDAT ?DoCamps@CvBarbarians@@SAXXZ
_TEXT	SEGMENT
tv444 = -396						; size = 4
tv171 = -392						; size = 4
tv134 = -388						; size = 4
$T218847 = -384						; size = 4
$T218839 = -380						; size = 4
$T218835 = -376						; size = 4
_uiOffset$218830 = -372					; size = 4
$T218821 = -368						; size = 4
$T218809 = -364						; size = 4
$T218805 = -360						; size = 4
$T218801 = -356						; size = 4
$T218797 = -352						; size = 4
$T218793 = -348						; size = 4
$T218789 = -344						; size = 4
$T218788 = -340						; size = 4
$T218715 = -268						; size = 4
$T218711 = -264						; size = 4
$T218707 = -260						; size = 4
$T218703 = -256						; size = 4
$T218618 = -204						; size = 4
$T218614 = -200						; size = 4
_f$218610 = -194					; size = 1
_f$218601 = -193					; size = 1
$T218592 = -192						; size = 4
$T218573 = -188						; size = 4
$T218556 = -184						; size = 4
$T218549 = -180						; size = 4
$T218545 = -176						; size = 4
$T218541 = -172						; size = 4
$T218531 = -168						; size = 4
_ePlayer$217623 = -164					; size = 4
_eTeam$217624 = -160					; size = 4
_iCount$217572 = -156					; size = 4
_iDY$217584 = -152					; size = 4
_iDX$217583 = -148					; size = 4
_iPlotIndex$217573 = -144				; size = 4
_bWantsCoastal$217577 = -137				; size = 1
_eBestUnit$217575 = -136				; size = 4
_strBuffer$217587 = -132				; size = 28
__$ArrayPad$ = -104					; size = 4
_iPlayerLoop$217588 = -100				; size = 4
_iPlotDistance$217582 = -96				; size = 4
_iMaxDistanceToLook$217581 = -92			; size = 4
_iPlayerCapitalMinDistance$217579 = -88			; size = 4
_iBarbCampMinDistance$217580 = -84			; size = 4
_iNumPlots$217574 = -80					; size = 4
_pNearbyCampPlot$217585 = -76				; size = 4
_iNumLandPlots$217576 = -72				; size = 4
_bSomethingTooClose$217586 = -65			; size = 1
_iI$217554 = -64					; size = 4
_kMap$217553 = -60					; size = 4
_iMaxCampsThisArea$217565 = -56				; size = 4
_iCampTargetNum$217563 = -52				; size = 4
_iNumValidCampPlots$217561 = -48			; size = 4
_iNumCampsToAdd$217564 = -44				; size = 4
_iFogTilesPerBarbarianCamp$217562 = -40			; size = 4
_eCamp$ = -36						; size = 4
_bAlwaysRevealedBarbCamp$ = -29				; size = 1
_kGame$ = -28						; size = 4
_iNumNotVisiblePlots$ = -24				; size = 4
_pLoopPlot$ = -20					; size = 4
_iNumCampsInExistence$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?DoCamps@CvBarbarians@@SAXXZ PROC			; CvBarbarians::DoCamps, COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoCamps@CvBarbarians@@SAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 302  : 	CvGame& kGame = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], eax

; 303  : 
; 304  : 	if(kGame.isOption(GAMEOPTION_NO_BARBARIANS))

	push	1
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN52@DoCamps

; 305  : 	{
; 306  : 		return;

	jmp	$LN53@DoCamps
$LN52@DoCamps:

; 307  : 	}
; 308  : 
; 309  : 	int iNumNotVisiblePlots = 0;

	mov	DWORD PTR _iNumNotVisiblePlots$[ebp], 0

; 310  : 	int iNumCampsInExistence = 0;

	mov	DWORD PTR _iNumCampsInExistence$[ebp], 0

; 311  : 	CvPlot* pLoopPlot;
; 312  : 
; 313  : 	ImprovementTypes eCamp = (ImprovementTypes)GC.getBARBARIAN_CAMP_IMPROVEMENT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR _eCamp$[ebp], edx

; 314  : 
; 315  : 	bool bAlwaysRevealedBarbCamp = false;

	mov	BYTE PTR _bAlwaysRevealedBarbCamp$[ebp], 0

; 316  : 
; 317  : 	// Is there an appropriate Improvement to place as a Barb Camp?
; 318  : 	if(eCamp != NO_IMPROVEMENT)

	cmp	DWORD PTR _eCamp$[ebp], -1
	je	$LN51@DoCamps

; 319  : 	{
; 320  : 		CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$217553[ebp], eax

; 321  : 		// Figure out how many Nonvisible tiles we have to base # of camps to spawn on
; 322  : #ifdef AUI_WARNING_FIXES
; 323  : 		for (uint iI = 0; iI < kMap.numPlots(); iI++)
; 324  : #else
; 325  : 		for(int iI = 0; iI < kMap.numPlots(); iI++)

	mov	DWORD PTR _iI$217554[ebp], 0
	jmp	SHORT $LN50@DoCamps
$LN49@DoCamps:
	mov	ecx, DWORD PTR _iI$217554[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$217554[ebp], ecx
$LN50@DoCamps:
	mov	edx, DWORD PTR _kMap$217553[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T218531[ebp], eax
	mov	ecx, DWORD PTR _iI$217554[ebp]
	cmp	ecx, DWORD PTR $T218531[ebp]
	jge	SHORT $LN48@DoCamps

; 326  : #endif
; 327  : 		{
; 328  : 			pLoopPlot = kMap.plotByIndexUnchecked(iI);

	mov	edx, DWORD PTR _iI$217554[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$217553[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], edx

; 329  : 
; 330  : 			// See how many camps we already have
; 331  : 			if(pLoopPlot->getImprovementType() == eCamp)

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eCamp$[ebp]
	jne	SHORT $LN70@DoCamps

; 332  : 			{
; 333  : 				iNumCampsInExistence++;

	mov	ecx, DWORD PTR _iNumCampsInExistence$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumCampsInExistence$[ebp], ecx

; 334  : 			}
; 335  : 
; 336  : 			if(!pLoopPlot->isWater())

$LN70@DoCamps:
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN46@DoCamps

; 337  : 			{
; 338  : 				if(!pLoopPlot->isVisibleToCivTeam())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isVisibleToCivTeam@CvPlot@@QBE_NXZ	; CvPlot::isVisibleToCivTeam
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN46@DoCamps

; 339  : 				{
; 340  : 					iNumNotVisiblePlots++;

	mov	ecx, DWORD PTR _iNumNotVisiblePlots$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumNotVisiblePlots$[ebp], ecx
$LN46@DoCamps:

; 341  : 				}
; 342  : 			}
; 343  : 		}

	jmp	SHORT $LN49@DoCamps
$LN48@DoCamps:

; 344  : 
; 345  : 		int iNumValidCampPlots;
; 346  : 
; 347  : 		iNumValidCampPlots = iNumNotVisiblePlots;

	mov	edx, DWORD PTR _iNumNotVisiblePlots$[ebp]
	mov	DWORD PTR _iNumValidCampPlots$217561[ebp], edx

; 348  : 
; 349  : 		int iFogTilesPerBarbarianCamp = kMap.getWorldInfo().getFogTilesPerBarbarianCamp();

	mov	ecx, DWORD PTR _kMap$217553[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getFogTilesPerBarbarianCamp@CvWorldInfo@@QBEHXZ ; CvWorldInfo::getFogTilesPerBarbarianCamp
	mov	DWORD PTR _iFogTilesPerBarbarianCamp$217562[ebp], eax

; 350  : 		int iCampTargetNum = (iFogTilesPerBarbarianCamp != 0)? iNumValidCampPlots / iFogTilesPerBarbarianCamp : 0;//getHandicapInfo().getFogTilesPerBarbarianCamp();

	cmp	DWORD PTR _iFogTilesPerBarbarianCamp$217562[ebp], 0
	je	SHORT $LN55@DoCamps
	mov	eax, DWORD PTR _iNumValidCampPlots$217561[ebp]
	cdq
	idiv	DWORD PTR _iFogTilesPerBarbarianCamp$217562[ebp]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN56@DoCamps
$LN55@DoCamps:
	mov	DWORD PTR tv134[ebp], 0
$LN56@DoCamps:
	mov	eax, DWORD PTR tv134[ebp]
	mov	DWORD PTR _iCampTargetNum$217563[ebp], eax

; 351  : 		int iNumCampsToAdd = iCampTargetNum - iNumCampsInExistence;

	mov	ecx, DWORD PTR _iCampTargetNum$217563[ebp]
	sub	ecx, DWORD PTR _iNumCampsInExistence$[ebp]
	mov	DWORD PTR _iNumCampsToAdd$217564[ebp], ecx

; 352  : 
; 353  : 		int iMaxCampsThisArea;
; 354  : 
; 355  : 		if(iNumCampsToAdd > 0 && GC.getBARBARIAN_CAMP_ODDS_OF_NEW_CAMP_SPAWNING() > 0) // slewis - added the barbarian chance for the FoR scenario

	cmp	DWORD PTR _iNumCampsToAdd$217564[ebp], 0
	jle	$LN51@DoCamps
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7036
	mov	DWORD PTR $T218541[ebp], edx
	cmp	DWORD PTR $T218541[ebp], 0
	jle	$LN51@DoCamps

; 356  : 		{
; 357  : 			// First turn of the game add 1/3 of the Target number of Camps
; 358  : 			if(kGame.getElapsedGameTurns() == 0)

	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	test	eax, eax
	jne	SHORT $LN43@DoCamps

; 359  : 			{
; 360  : 				iNumCampsToAdd *= /*33*/ GC.getBARBARIAN_CAMP_FIRST_TURN_PERCENT_OF_TARGET_TO_ADD();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7032
	mov	DWORD PTR $T218545[ebp], eax
	mov	ecx, DWORD PTR _iNumCampsToAdd$217564[ebp]
	imul	ecx, DWORD PTR $T218545[ebp]
	mov	DWORD PTR _iNumCampsToAdd$217564[ebp], ecx

; 361  : 				iNumCampsToAdd /= 100;

	mov	eax, DWORD PTR _iNumCampsToAdd$217564[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iNumCampsToAdd$217564[ebp], eax

; 362  : 			}
; 363  : 			// Every other turn of the game there's a 1 in 2 chance of adding a new camp if we're still below the target
; 364  : 			else

	jmp	SHORT $LN42@DoCamps
$LN43@DoCamps:

; 365  : 			{
; 366  : 				if(kGame.getJonRandNum(/*2*/ GC.getBARBARIAN_CAMP_ODDS_OF_NEW_CAMP_SPAWNING(), "Random roll to see if Barb Camp spawns this turn") > 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7036
	mov	DWORD PTR $T218549[ebp], edx
	push	OFFSET ??_C@_0DB@DHGMHKAF@Random?5roll?5to?5see?5if?5Barb?5Camp?5@
	mov	eax, DWORD PTR $T218549[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	test	eax, eax
	jle	SHORT $LN41@DoCamps

; 367  : 				{
; 368  : 					iNumCampsToAdd = 1;

	mov	DWORD PTR _iNumCampsToAdd$217564[ebp], 1

; 369  : 				}
; 370  : 				else

	jmp	SHORT $LN42@DoCamps
$LN41@DoCamps:

; 371  : 				{
; 372  : 					iNumCampsToAdd = 0;

	mov	DWORD PTR _iNumCampsToAdd$217564[ebp], 0
$LN42@DoCamps:

; 373  : 				}
; 374  : 			}
; 375  : 
; 376  : 			// Don't want to get stuck in an infinite or almost so loop
; 377  : 			int iCount = 0;

	mov	DWORD PTR _iCount$217572[ebp], 0

; 378  : 			int iPlotIndex = -1;

	mov	DWORD PTR _iPlotIndex$217573[ebp], -1

; 379  : 			int iNumPlots = kMap.numPlots();

	mov	ecx, DWORD PTR _kMap$217553[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iNumPlots$217574[ebp], edx

; 380  : 
; 381  : 			UnitTypes eBestUnit;
; 382  : 
; 383  : 			int iNumLandPlots = kMap.getLandPlots();

	mov	ecx, DWORD PTR _kMap$217553[ebp]
	call	?getLandPlots@CvMap@@QAEHXZ		; CvMap::getLandPlots
	mov	DWORD PTR _iNumLandPlots$217576[ebp], eax

; 384  : 
; 385  : 			// Do a random roll to bias in favor of Coastal land Tiles so that the Barbs will spawn Boats :) - required 1/6 of the time
; 386  : 			bool bWantsCoastal = kGame.getJonRandNum(/*6*/ GC.getBARBARIAN_CAMP_COASTAL_SPAWN_ROLL(), "Barb Camp Plot-Finding Roll - Coastal Bias 1") == 0 ? true : false;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7048
	mov	DWORD PTR $T218556[ebp], eax
	push	OFFSET ??_C@_0CN@JIEENMD@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@
	mov	ecx, DWORD PTR $T218556[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	test	eax, eax
	sete	dl
	mov	BYTE PTR _bWantsCoastal$217577[ebp], dl

; 387  : 
; 388  : 			int iPlayerCapitalMinDistance = /*4*/ GC.getBARBARIAN_CAMP_MINIMUM_DISTANCE_CAPITAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7040
	mov	DWORD PTR _iPlayerCapitalMinDistance$217579[ebp], eax

; 389  : 			int iBarbCampMinDistance = /*7*/ GC.getBARBARIAN_CAMP_MINIMUM_DISTANCE_ANOTHER_CAMP();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7044
	mov	DWORD PTR _iBarbCampMinDistance$217580[ebp], ecx

; 390  : 			int iMaxDistanceToLook = iPlayerCapitalMinDistance > iBarbCampMinDistance ? iPlayerCapitalMinDistance : iBarbCampMinDistance;

	mov	edx, DWORD PTR _iPlayerCapitalMinDistance$217579[ebp]
	cmp	edx, DWORD PTR _iBarbCampMinDistance$217580[ebp]
	jle	SHORT $LN57@DoCamps
	mov	eax, DWORD PTR _iPlayerCapitalMinDistance$217579[ebp]
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN58@DoCamps
$LN57@DoCamps:
	mov	ecx, DWORD PTR _iBarbCampMinDistance$217580[ebp]
	mov	DWORD PTR tv171[ebp], ecx
$LN58@DoCamps:
	mov	edx, DWORD PTR tv171[ebp]
	mov	DWORD PTR _iMaxDistanceToLook$217581[ebp], edx

; 391  : 			int iPlotDistance;
; 392  : 
; 393  : 			int iDX, iDY;
; 394  : 			CvPlot* pNearbyCampPlot;
; 395  : 			bool bSomethingTooClose;
; 396  : 
; 397  : 			CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$217587[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN39@DoCamps:

; 398  : 
; 399  : 			int iPlayerLoop;
; 400  : 
; 401  : 			// Find Plots to put the Camps
; 402  : 			do
; 403  : 			{
; 404  : 				iCount++;

	mov	eax, DWORD PTR _iCount$217572[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$217572[ebp], eax

; 405  : 
; 406  : 				iPlotIndex = kGame.getJonRandNum(iNumPlots, "Barb Camp Plot-Finding Roll");

	push	OFFSET ??_C@_0BM@GAGFPHLN@Barb?5Camp?5Plot?9Finding?5Roll?$AA@
	mov	ecx, DWORD PTR _iNumPlots$217574[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _iPlotIndex$217573[ebp], eax

; 407  : 
; 408  : 				pLoopPlot = kMap.plotByIndex(iPlotIndex);

	cmp	DWORD PTR _iPlotIndex$217573[ebp], 0
	jl	SHORT $LN91@DoCamps
	mov	edx, DWORD PTR _kMap$217553[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T218573[ebp], eax
	mov	ecx, DWORD PTR _iPlotIndex$217573[ebp]
	cmp	ecx, DWORD PTR $T218573[ebp]
	jge	SHORT $LN91@DoCamps
	mov	edx, DWORD PTR _iPlotIndex$217573[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$217553[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv444[ebp], edx
	jmp	SHORT $LN89@DoCamps
$LN91@DoCamps:
	mov	DWORD PTR tv444[ebp], 0
$LN89@DoCamps:
	mov	ecx, DWORD PTR tv444[ebp]
	mov	DWORD PTR _pLoopPlot$[ebp], ecx

; 409  : 
; 410  : 				// Plot must be valid (not Water, nonvisible)
; 411  : 				if(!pLoopPlot->isWater())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN38@DoCamps

; 412  : 				{
; 413  : 					if(!pLoopPlot->isImpassable() && !pLoopPlot->isMountain())

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN38@DoCamps
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN38@DoCamps

; 414  : 					{
; 415  : 						if(!pLoopPlot->isOwned() && !pLoopPlot->isVisibleToCivTeam())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	jne	$LN38@DoCamps
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isVisibleToCivTeam@CvPlot@@QBE_NXZ	; CvPlot::isVisibleToCivTeam
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN38@DoCamps

; 416  : 						{
; 417  : 							// JON: NO RESOURCES FOR NOW, MAY REPLACE WITH SOMETHING COOLER
; 418  : 							if(pLoopPlot->getResourceType() == NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	jne	$LN38@DoCamps

; 419  : 							{
; 420  : 								// No camps on 1-tile islands
; 421  : 								if(kMap.getArea(pLoopPlot->getArea())->getNumTiles() > 1)

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T218592[ebp], eax
	mov	ecx, DWORD PTR $T218592[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kMap$217553[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, 1
	jle	$LN38@DoCamps

; 422  : 								{
; 423  : 									if(pLoopPlot->isCoastalLand() || !bWantsCoastal)

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN30@DoCamps
	movzx	eax, BYTE PTR _bWantsCoastal$217577[ebp]
	test	eax, eax
	jne	$LN38@DoCamps
$LN30@DoCamps:

; 424  : 									{
; 425  : 										// Max Camps for this area
; 426  : 										iMaxCampsThisArea = iCampTargetNum * pLoopPlot->area()->getNumTiles() / iNumLandPlots;

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	imul	eax, DWORD PTR _iCampTargetNum$217563[ebp]
	cdq
	idiv	DWORD PTR _iNumLandPlots$217576[ebp]
	mov	DWORD PTR _iMaxCampsThisArea$217565[ebp], eax

; 427  : 										// Add 1 just in case the above algorithm rounded something off
; 428  : 										iMaxCampsThisArea++;

	mov	ecx, DWORD PTR _iMaxCampsThisArea$217565[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMaxCampsThisArea$217565[ebp], ecx

; 429  : 
; 430  : 										// Already enough Camps in this Area?
; 431  : 										if(pLoopPlot->area()->getNumImprovements(eCamp) <= iMaxCampsThisArea)

	mov	edx, DWORD PTR _eCamp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z ; CvArea::getNumImprovements
	cmp	eax, DWORD PTR _iMaxCampsThisArea$217565[ebp]
	jg	$LN38@DoCamps

; 432  : 										{
; 433  : 											// Don't look at Tiles that already have a Camp
; 434  : 											if(pLoopPlot->getImprovementType() == NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	$LN38@DoCamps

; 435  : 											{
; 436  : 												// Don't look at Tiles that can't have an improvement
; 437  : 												if(pLoopPlot->getFeatureType() == NO_FEATURE || !GC.getFeatureInfo(pLoopPlot->getFeatureType())->isNoImprovement())

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$218601[ebp], cl
	movsx	edx, BYTE PTR _f$218601[ebp]
	cmp	edx, -1
	je	SHORT $LN26@DoCamps
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$218610[ebp], cl
	movsx	edx, BYTE PTR _f$218610[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isNoImprovement@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoImprovement
	movzx	eax, al
	test	eax, eax
	jne	$LN38@DoCamps
$LN26@DoCamps:

; 438  : 												{
; 439  : 													bSomethingTooClose = false;

	mov	BYTE PTR _bSomethingTooClose$217586[ebp], 0

; 440  : 
; 441  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 442  : 													int iMaxDX;
; 443  : 													for (iDY = -(iMaxDistanceToLook); iDY <= iMaxDistanceToLook; iDY++)
; 444  : 													{
; 445  : 														iMaxDX = iMaxDistanceToLook - MAX(0, iDY);
; 446  : 														for (iDX = -(iMaxDistanceToLook) - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 447  : #else
; 448  : 													// Look at nearby Plots to make sure another camp isn't too close
; 449  : 													for(iDX = -(iMaxDistanceToLook); iDX <= iMaxDistanceToLook; iDX++)

	mov	ecx, DWORD PTR _iMaxDistanceToLook$217581[ebp]
	neg	ecx
	mov	DWORD PTR _iDX$217583[ebp], ecx
	jmp	SHORT $LN25@DoCamps
$LN24@DoCamps:
	mov	edx, DWORD PTR _iDX$217583[ebp]
	add	edx, 1
	mov	DWORD PTR _iDX$217583[ebp], edx
$LN25@DoCamps:
	mov	eax, DWORD PTR _iDX$217583[ebp]
	cmp	eax, DWORD PTR _iMaxDistanceToLook$217581[ebp]
	jg	$LN23@DoCamps

; 450  : 													{
; 451  : 														for(iDY = -(iMaxDistanceToLook); iDY <= iMaxDistanceToLook; iDY++)

	mov	ecx, DWORD PTR _iMaxDistanceToLook$217581[ebp]
	neg	ecx
	mov	DWORD PTR _iDY$217584[ebp], ecx
	jmp	SHORT $LN22@DoCamps
$LN21@DoCamps:
	mov	edx, DWORD PTR _iDY$217584[ebp]
	add	edx, 1
	mov	DWORD PTR _iDY$217584[ebp], edx
$LN22@DoCamps:
	mov	eax, DWORD PTR _iDY$217584[ebp]
	cmp	eax, DWORD PTR _iMaxDistanceToLook$217581[ebp]
	jg	$LN20@DoCamps

; 452  : #endif
; 453  : 														{
; 454  : 															pNearbyCampPlot = plotXY(pLoopPlot->getX(), pLoopPlot->getY(), iDX, iDY);

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T218614[ebp], edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T218618[ebp], ecx
	mov	edx, DWORD PTR _iDY$217584[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$217583[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218614[ebp]
	push	ecx
	mov	edx, DWORD PTR $T218618[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pNearbyCampPlot$217585[ebp], eax

; 455  : 
; 456  : 															if(pNearbyCampPlot != NULL)

	cmp	DWORD PTR _pNearbyCampPlot$217585[ebp], 0
	je	$LN19@DoCamps

; 457  : 															{
; 458  : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 459  : 																iPlotDistance = hexDistance(iDX, iDY);
; 460  : #else
; 461  : 																iPlotDistance = plotDistance(pNearbyCampPlot->getX(), pNearbyCampPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T218703[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T218707[ebp], eax
	mov	ecx, DWORD PTR _pNearbyCampPlot$217585[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T218711[ebp], edx
	mov	eax, DWORD PTR _pNearbyCampPlot$217585[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T218715[ebp], ecx
	mov	edx, DWORD PTR $T218703[ebp]
	push	edx
	mov	eax, DWORD PTR $T218707[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218711[ebp]
	push	ecx
	mov	edx, DWORD PTR $T218715[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$217582[ebp], eax

; 462  : #endif
; 463  : 
; 464  : 																// Can't be too close to a player
; 465  : 																if(iPlotDistance <= iPlayerCapitalMinDistance)

	mov	eax, DWORD PTR _iPlotDistance$217582[ebp]
	cmp	eax, DWORD PTR _iPlayerCapitalMinDistance$217579[ebp]
	jg	SHORT $LN18@DoCamps

; 466  : 																{
; 467  : 																	if(pNearbyCampPlot->isCity())

	mov	ecx, DWORD PTR _pNearbyCampPlot$217585[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@DoCamps

; 468  : 																	{
; 469  : 																		if(pNearbyCampPlot->getPlotCity()->isCapital())

	mov	ecx, DWORD PTR _pNearbyCampPlot$217585[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@DoCamps

; 470  : 																		{
; 471  : 																			// Only care about Majors' capitals
; 472  : 																			if(pNearbyCampPlot->getPlotCity()->getOwner() < MAX_MAJOR_CIVS)

	mov	ecx, DWORD PTR _pNearbyCampPlot$217585[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR $T218788[ebp], eax
	mov	eax, DWORD PTR $T218788[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T218789[ebp], ecx
	cmp	DWORD PTR $T218789[ebp], 22		; 00000016H
	jge	SHORT $LN18@DoCamps

; 473  : 																			{
; 474  : 																				bSomethingTooClose = true;

	mov	BYTE PTR _bSomethingTooClose$217586[ebp], 1

; 475  : 																				break;

	jmp	SHORT $LN20@DoCamps
$LN18@DoCamps:

; 476  : 																			}
; 477  : 																		}
; 478  : 																	}
; 479  : 																}
; 480  : 
; 481  : 																// Can't be too close to another Camp
; 482  : 																if(iPlotDistance <= iBarbCampMinDistance)

	mov	edx, DWORD PTR _iPlotDistance$217582[ebp]
	cmp	edx, DWORD PTR _iBarbCampMinDistance$217580[ebp]
	jg	SHORT $LN19@DoCamps

; 483  : 																{
; 484  : 																	if(pNearbyCampPlot->getImprovementType() == eCamp)

	mov	ecx, DWORD PTR _pNearbyCampPlot$217585[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eCamp$[ebp]
	jne	SHORT $LN19@DoCamps

; 485  : 																	{
; 486  : 																		bSomethingTooClose = true;

	mov	BYTE PTR _bSomethingTooClose$217586[ebp], 1

; 487  : 																		break;

	jmp	SHORT $LN20@DoCamps
$LN19@DoCamps:

; 488  : 																	}
; 489  : 																}
; 490  : 															}
; 491  : 														}

	jmp	$LN21@DoCamps
$LN20@DoCamps:

; 492  : 														if(bSomethingTooClose)

	movzx	eax, BYTE PTR _bSomethingTooClose$217586[ebp]
	test	eax, eax
	je	SHORT $LN12@DoCamps

; 493  : 														{
; 494  : 															break;

	jmp	SHORT $LN23@DoCamps
$LN12@DoCamps:

; 495  : 														}
; 496  : 													}

	jmp	$LN24@DoCamps
$LN23@DoCamps:

; 497  : 
; 498  : 													// Found a camp too close, check another Plot
; 499  : 													if(bSomethingTooClose)

	movzx	ecx, BYTE PTR _bSomethingTooClose$217586[ebp]
	test	ecx, ecx
	je	SHORT $LN11@DoCamps

; 500  : 														continue;

	jmp	$LN38@DoCamps
$LN11@DoCamps:

; 501  : 
; 502  : 													// Last check
; 503  : 													if(!CvBarbarians::IsPlotValidForBarbCamp(pLoopPlot))

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	call	?IsPlotValidForBarbCamp@CvBarbarians@@CA_NPAVCvPlot@@@Z ; CvBarbarians::IsPlotValidForBarbCamp
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@DoCamps

; 504  : 														continue;

	jmp	$LN38@DoCamps
$LN10@DoCamps:

; 505  : 
; 506  : 													pLoopPlot->setImprovementType(eCamp);

	push	-1
	mov	ecx, DWORD PTR _eCamp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 507  : 													DoCampActivationNotice(pLoopPlot);

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	call	?DoCampActivationNotice@CvBarbarians@@CAXPAVCvPlot@@@Z ; CvBarbarians::DoCampActivationNotice
	add	esp, 4

; 508  : 
; 509  : 													eBestUnit = GetRandomBarbarianUnitType(kMap.getArea(pLoopPlot->getArea()), UNITAI_DEFENSE);

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T218793[ebp], ecx
	push	6
	mov	edx, DWORD PTR $T218793[ebp]
	push	edx
	mov	ecx, DWORD PTR _kMap$217553[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	push	eax
	call	?GetRandomBarbarianUnitType@CvBarbarians@@CA?AW4UnitTypes@@PAVCvArea@@W4UnitAITypes@@@Z ; CvBarbarians::GetRandomBarbarianUnitType
	add	esp, 8
	mov	DWORD PTR _eBestUnit$217575[ebp], eax

; 510  : 
; 511  : 													if(eBestUnit != NO_UNIT)

	cmp	DWORD PTR _eBestUnit$217575[ebp], -1
	je	SHORT $LN9@DoCamps

; 512  : 													{
; 513  : #ifdef AUI_WARNING_FIXES
; 514  : 														CvUnitEntry* pUnitInfo = GC.getUnitInfo(eBestUnit);
; 515  : 														if (pUnitInfo)
; 516  : 															GET_PLAYER(BARBARIAN_PLAYER).initUnit(eBestUnit, pLoopPlot->getX(), pLoopPlot->getY(), (UnitAITypes)pUnitInfo->GetDefaultUnitAIType());
; 517  : #else
; 518  : 														GET_PLAYER(BARBARIAN_PLAYER).initUnit(eBestUnit, pLoopPlot->getX(), pLoopPlot->getY(), (UnitAITypes) GC.getUnitInfo(eBestUnit)->GetDefaultUnitAIType());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T218797[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T218801[ebp], eax
	mov	ecx, 63					; 0000003fH
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218805[ebp], ecx
	push	0
	push	0
	push	1
	push	0
	push	-1
	mov	edx, DWORD PTR _eBestUnit$217575[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	ecx, eax
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	push	eax
	mov	eax, DWORD PTR $T218797[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218801[ebp]
	push	ecx
	mov	edx, DWORD PTR _eBestUnit$217575[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218805[ebp]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
$LN9@DoCamps:

; 519  : #endif
; 520  : 													}
; 521  : 
; 522  : 													// If we should update Camp visibility (for Policy), do so
; 523  : 													PlayerTypes ePlayer;
; 524  : 													TeamTypes eTeam;
; 525  : 													for(iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$217588[ebp], 0
	jmp	SHORT $LN8@DoCamps
$LN7@DoCamps:
	mov	eax, DWORD PTR _iPlayerLoop$217588[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$217588[ebp], eax
$LN8@DoCamps:
	cmp	DWORD PTR _iPlayerLoop$217588[ebp], 22	; 00000016H
	jge	$LN6@DoCamps

; 526  : 													{
; 527  : 														ePlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$217588[ebp]
	mov	DWORD PTR _ePlayer$217623[ebp], ecx

; 528  : 														eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$217623[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218809[ebp], edx
	mov	eax, DWORD PTR $T218809[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$217624[ebp], eax

; 529  : 
; 530  : 														if(GET_PLAYER(ePlayer).IsAlwaysSeeBarbCamps())

	mov	edx, DWORD PTR _ePlayer$217623[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218821[ebp], edx
	mov	ecx, DWORD PTR $T218821[ebp]
	call	?IsAlwaysSeeBarbCamps@CvPlayer@@QBE_NXZ	; CvPlayer::IsAlwaysSeeBarbCamps
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@DoCamps

; 531  : 														{
; 532  : 															if(pLoopPlot->isRevealed(eTeam))

	mov	ecx, DWORD PTR _eTeam$217624[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$218830[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$218830[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eTeam$217624[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$218830[ebp]
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@DoCamps

; 533  : 															{
; 534  : 																pLoopPlot->setRevealedImprovementType(eTeam, eCamp);

	mov	edx, DWORD PTR _eCamp$[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$217624[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType

; 535  : 																if(GC.getGame().getActivePlayer() == ePlayer)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T218835[ebp], ecx
	mov	ecx, DWORD PTR $T218835[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR _ePlayer$217623[ebp]
	jne	SHORT $LN5@DoCamps

; 536  : 																	bAlwaysRevealedBarbCamp = true;

	mov	BYTE PTR _bAlwaysRevealedBarbCamp$[ebp], 1
$LN5@DoCamps:

; 537  : 															}
; 538  : 														}
; 539  : 													}

	jmp	$LN7@DoCamps
$LN6@DoCamps:

; 540  : 
; 541  : 													// Add another Unit adjacent to the Camp to stir up some trouble (JON: Disabled for now 09/12/09)
; 542  : 													//doSpawnBarbarianUnit(pLoopPlot);
; 543  : 
; 544  : 													iNumCampsToAdd--;

	mov	edx, DWORD PTR _iNumCampsToAdd$217564[ebp]
	sub	edx, 1
	mov	DWORD PTR _iNumCampsToAdd$217564[ebp], edx

; 545  : 
; 546  : 													// Seed the next Camp for Coast or not
; 547  : 													bWantsCoastal = kGame.getJonRandNum(/*5*/ GC.getBARBARIAN_CAMP_COASTAL_SPAWN_ROLL(), "Barb Camp Plot-Finding Roll - Coastal Bias 2") == 0 ? true : false;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7048
	mov	DWORD PTR $T218839[ebp], eax
	push	OFFSET ??_C@_0CN@CCKJBOAA@Barb?5Camp?5Plot?9Finding?5Roll?5?9?5Co@
	mov	ecx, DWORD PTR $T218839[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	test	eax, eax
	sete	dl
	mov	BYTE PTR _bWantsCoastal$217577[ebp], dl
$LN38@DoCamps:

; 548  : 												}
; 549  : 											}
; 550  : 										}
; 551  : 									}
; 552  : 								}
; 553  : 							}
; 554  : 						}
; 555  : 					}
; 556  : 				}
; 557  : 			}
; 558  : 			while(iNumCampsToAdd > 0 && iCount < iNumLandPlots);

	cmp	DWORD PTR _iNumCampsToAdd$217564[ebp], 0
	jle	SHORT $LN37@DoCamps
	mov	eax, DWORD PTR _iCount$217572[ebp]
	cmp	eax, DWORD PTR _iNumLandPlots$217576[ebp]
	jl	$LN39@DoCamps
$LN37@DoCamps:

; 559  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$217587[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN51@DoCamps:

; 560  : 	}
; 561  : 
; 562  : 	if(bAlwaysRevealedBarbCamp)

	movzx	ecx, BYTE PTR _bAlwaysRevealedBarbCamp$[ebp]
	test	ecx, ecx
	je	SHORT $LN53@DoCamps

; 563  : 		GC.getMap().updateDeferredFog();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218847[ebp], edx
	mov	ecx, DWORD PTR $T218847[ebp]
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog
$LN53@DoCamps:

; 564  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoCamps@CvBarbarians@@SAXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$217587[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoCamps@CvBarbarians@@SAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-388]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoCamps@CvBarbarians@@SAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoCamps@CvBarbarians@@SAXXZ ENDP			; CvBarbarians::DoCamps
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T218980 = -56						; size = 4
$T218935 = -52						; size = 4
$T218922 = -48						; size = 4
$T218918 = -44						; size = 4
$T218904 = -40						; size = 4
$T218900 = -33						; size = 1
$T218889 = -32						; size = 4
$T218885 = -25						; size = 1
_iMapY$218944 = -24					; size = 4
_iMapX$218943 = -20					; size = 4
$T218878 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218878[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T218980[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T218878[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T218885[ebp], dl
	mov	eax, DWORD PTR $T218878[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218889[ebp], ecx
	movzx	edx, BYTE PTR $T218885[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T218889[ebp]
	add	edx, DWORD PTR $T218889[ebp]
	mov	DWORD PTR _iMapX$218943[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T218889[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T218889[ebp]
	mov	DWORD PTR _iMapX$218943[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$218943[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T218878[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T218900[ebp], al
	mov	ecx, DWORD PTR $T218878[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T218904[ebp], edx
	movzx	eax, BYTE PTR $T218900[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T218904[ebp]
	add	edx, DWORD PTR $T218904[ebp]
	mov	DWORD PTR _iMapY$218944[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T218904[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T218904[ebp]
	mov	DWORD PTR _iMapY$218944[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$218944[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$218943[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T218878[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218918[ebp], ecx
	mov	edx, DWORD PTR _iMapX$218943[ebp]
	cmp	edx, DWORD PTR $T218918[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$218944[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T218878[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T218922[ebp], ecx
	mov	edx, DWORD PTR _iMapY$218944[ebp]
	cmp	edx, DWORD PTR $T218922[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T218878[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218935[ebp], ecx
	mov	edx, DWORD PTR _iMapY$218944[ebp]
	imul	edx, DWORD PTR $T218935[ebp]
	add	edx, DWORD PTR _iMapX$218943[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T218878[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T218980[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T218980[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	??_C@_0BE@HLDCOIFJ@Barb?5Unit?5Selection?$AA@	; `string'
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetPrereqAndTechs
EXTRN	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z:PROC ; CvPlayer::canTrain
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ:PROC	; CvPromotionEntry::IsOnlyDefensive
EXTRN	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetFreePromotions
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
EXTRN	?GetRange@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetRange
EXTRN	?GetCombat@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetCombat
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
;	COMDAT ??_C@_0BE@HLDCOIFJ@Barb?5Unit?5Selection?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
CONST	SEGMENT
??_C@_0BE@HLDCOIFJ@Barb?5Unit?5Selection?$AA@ DB 'Barb Unit Selection', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbarbarians.cpp
CONST	ENDS
;	COMDAT ?GetRandomBarbarianUnitType@CvBarbarians@@CA?AW4UnitTypes@@PAVCvArea@@W4UnitAITypes@@@Z
_TEXT	SEGMENT
$T219000 = -80						; size = 4
$T218996 = -76						; size = 4
$T218992 = -72						; size = 4
_eTech$217685 = -68					; size = 4
_i$217681 = -64						; size = 4
_bFound$217679 = -58					; size = 1
_bRequires$217680 = -57					; size = 1
_ePromotion$217665 = -56				; size = 4
_pkPromotionInfo$217667 = -52				; size = 4
_iLoop$217661 = -48					; size = 4
_kUnit$217658 = -44					; size = 4
_pkUnitInfo$217656 = -40				; size = 4
_pkUnitClassInfo$217650 = -36				; size = 4
_eLoopUnit$217653 = -32					; size = 4
_bValid$217649 = -25					; size = 1
_iUnitClassLoop$217645 = -24				; size = 4
_eBestUnit$ = -20					; size = 4
_kBarbarianPlayer$ = -16				; size = 4
_iBestValue$ = -12					; size = 4
_kGame$ = -8						; size = 4
_iValue$ = -4						; size = 4
_pArea$ = 8						; size = 4
_eUnitAI$ = 12						; size = 4
?GetRandomBarbarianUnitType@CvBarbarians@@CA?AW4UnitTypes@@PAVCvArea@@W4UnitAITypes@@@Z PROC ; CvBarbarians::GetRandomBarbarianUnitType, COMDAT

; 568  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 569  : 	UnitTypes eBestUnit = NO_UNIT;

	mov	DWORD PTR _eBestUnit$[ebp], -1

; 570  : 	int iBestValue = 0;

	mov	DWORD PTR _iBestValue$[ebp], 0

; 571  : 	int iValue = 0;

	mov	DWORD PTR _iValue$[ebp], 0

; 572  : 
; 573  : 	CvPlayerAI& kBarbarianPlayer = GET_PLAYER(BARBARIAN_PLAYER);

	mov	eax, 63					; 0000003fH
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kBarbarianPlayer$[ebp], eax

; 574  : 
; 575  : 	CvGame &kGame = GC.getGame();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], ecx

; 576  : 
; 577  : #ifdef AUI_WARNING_FIXES
; 578  : 	for (uint iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)
; 579  : #else
; 580  : 	for(int iUnitClassLoop = 0; iUnitClassLoop < GC.getNumUnitClassInfos(); iUnitClassLoop++)

	mov	DWORD PTR _iUnitClassLoop$217645[ebp], 0
	jmp	SHORT $LN30@GetRandomB
$LN29@GetRandomB:
	mov	edx, DWORD PTR _iUnitClassLoop$217645[ebp]
	add	edx, 1
	mov	DWORD PTR _iUnitClassLoop$217645[ebp], edx
$LN30@GetRandomB:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	DWORD PTR _iUnitClassLoop$217645[ebp], eax
	jge	$LN28@GetRandomB

; 581  : #endif
; 582  : 	{
; 583  : 		bool bValid = false;

	mov	BYTE PTR _bValid$217649[ebp], 0

; 584  : 		CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo((UnitClassTypes)iUnitClassLoop);

	mov	eax, DWORD PTR _iUnitClassLoop$217645[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$217650[ebp], eax

; 585  : 		if(pkUnitClassInfo == NULL)

	cmp	DWORD PTR _pkUnitClassInfo$217650[ebp], 0
	jne	SHORT $LN27@GetRandomB

; 586  : 			continue;

	jmp	SHORT $LN29@GetRandomB
$LN27@GetRandomB:

; 587  : 
; 588  : 		const UnitTypes eLoopUnit = ((UnitTypes)(kBarbarianPlayer.getCivilizationInfo().getCivilizationUnits(iUnitClassLoop)));

	mov	ecx, DWORD PTR _iUnitClassLoop$217645[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kBarbarianPlayer$[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	DWORD PTR _eLoopUnit$217653[ebp], eax

; 589  : 		if(eLoopUnit != NO_UNIT)

	cmp	DWORD PTR _eLoopUnit$217653[ebp], -1
	je	$LN26@GetRandomB

; 590  : 		{
; 591  : 			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eLoopUnit);

	mov	edx, DWORD PTR _eLoopUnit$217653[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$217656[ebp], eax

; 592  : 			if(pkUnitInfo == NULL)

	cmp	DWORD PTR _pkUnitInfo$217656[ebp], 0
	jne	SHORT $LN25@GetRandomB

; 593  : 			{
; 594  : 				continue;

	jmp	SHORT $LN29@GetRandomB
$LN25@GetRandomB:

; 595  : 			}
; 596  : 
; 597  : 			CvUnitEntry& kUnit = *pkUnitInfo;

	mov	eax, DWORD PTR _pkUnitInfo$217656[ebp]
	mov	DWORD PTR _kUnit$217658[ebp], eax

; 598  : 
; 599  : 			bValid = (kUnit.GetCombat() > 0);

	mov	ecx, DWORD PTR _kUnit$217658[ebp]
	call	?GetCombat@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetCombat
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR _bValid$217649[ebp], cl

; 600  : 			if(bValid)

	movzx	edx, BYTE PTR _bValid$217649[ebp]
	test	edx, edx
	je	SHORT $LN24@GetRandomB

; 601  : 			{
; 602  : 				// Unit has combat strength, make sure it isn't only defensive (and with no ranged combat ability)
; 603  : 				if(kUnit.GetRange() == 0)

	mov	ecx, DWORD PTR _kUnit$217658[ebp]
	call	?GetRange@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetRange
	test	eax, eax
	jne	SHORT $LN24@GetRandomB

; 604  : 				{
; 605  : #ifdef AUI_WARNING_FIXES
; 606  : 					for (uint iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)
; 607  : #else
; 608  : 					for(int iLoop = 0; iLoop < GC.getNumPromotionInfos(); iLoop++)

	mov	DWORD PTR _iLoop$217661[ebp], 0
	jmp	SHORT $LN22@GetRandomB
$LN21@GetRandomB:
	mov	eax, DWORD PTR _iLoop$217661[ebp]
	add	eax, 1
	mov	DWORD PTR _iLoop$217661[ebp], eax
$LN22@GetRandomB:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	DWORD PTR _iLoop$217661[ebp], eax
	jge	SHORT $LN24@GetRandomB

; 609  : #endif
; 610  : 					{
; 611  : 						const PromotionTypes ePromotion = static_cast<PromotionTypes>(iLoop);

	mov	ecx, DWORD PTR _iLoop$217661[ebp]
	mov	DWORD PTR _ePromotion$217665[ebp], ecx

; 612  : 						CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);

	mov	edx, DWORD PTR _ePromotion$217665[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	DWORD PTR _pkPromotionInfo$217667[ebp], eax

; 613  : 						if(pkPromotionInfo)

	cmp	DWORD PTR _pkPromotionInfo$217667[ebp], 0
	je	SHORT $LN19@GetRandomB

; 614  : 						{
; 615  : 							if(kUnit.GetFreePromotions(iLoop))

	mov	eax, DWORD PTR _iLoop$217661[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUnit$217658[ebp]
	call	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z ; CvUnitEntry::GetFreePromotions
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@GetRandomB

; 616  : 							{
; 617  : 								if(pkPromotionInfo->IsOnlyDefensive())

	mov	ecx, DWORD PTR _pkPromotionInfo$217667[ebp]
	call	?IsOnlyDefensive@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsOnlyDefensive
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN19@GetRandomB

; 618  : 								{
; 619  : 									bValid = false;

	mov	BYTE PTR _bValid$217649[ebp], 0

; 620  : 									break;

	jmp	SHORT $LN24@GetRandomB
$LN19@GetRandomB:

; 621  : 								}
; 622  : 							}
; 623  : 						}
; 624  : 					}

	jmp	SHORT $LN21@GetRandomB
$LN24@GetRandomB:

; 625  : 				}
; 626  : 			}
; 627  : 
; 628  : 			if(bValid)

	movzx	eax, BYTE PTR _bValid$217649[ebp]
	test	eax, eax
	je	SHORT $LN16@GetRandomB

; 629  : 			{
; 630  : 				if(pArea->isWater() && kUnit.GetDomainType() != DOMAIN_SEA)

	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@GetRandomB
	mov	ecx, DWORD PTR _kUnit$217658[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	test	eax, eax
	je	SHORT $LN15@GetRandomB

; 631  : 				{
; 632  : 					bValid = false;

	mov	BYTE PTR _bValid$217649[ebp], 0
	jmp	SHORT $LN16@GetRandomB
$LN15@GetRandomB:

; 633  : 				}
; 634  : 				else if(!pArea->isWater() && kUnit.GetDomainType() != DOMAIN_LAND)

	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN16@GetRandomB
	mov	ecx, DWORD PTR _kUnit$217658[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	cmp	eax, 2
	je	SHORT $LN16@GetRandomB

; 635  : 				{
; 636  : 					bValid = false;

	mov	BYTE PTR _bValid$217649[ebp], 0
$LN16@GetRandomB:

; 637  : 				}
; 638  : 			}
; 639  : 
; 640  : 			if(bValid)

	movzx	eax, BYTE PTR _bValid$217649[ebp]
	test	eax, eax
	je	SHORT $LN12@GetRandomB

; 641  : 			{
; 642  : 				if(!GET_PLAYER(BARBARIAN_PLAYER).canTrain(eLoopUnit))

	mov	ecx, 63					; 0000003fH
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218992[ebp], ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _eLoopUnit$217653[ebp]
	push	edx
	mov	ecx, DWORD PTR $T218992[ebp]
	call	?canTrain@CvPlayer@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvPlayer::canTrain
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@GetRandomB

; 643  : 				{
; 644  : 					bValid = false;

	mov	BYTE PTR _bValid$217649[ebp], 0
$LN12@GetRandomB:

; 645  : 				}
; 646  : 			}
; 647  : 
; 648  : 			if(bValid)

	movzx	ecx, BYTE PTR _bValid$217649[ebp]
	test	ecx, ecx
	je	$LN10@GetRandomB

; 649  : 			{
; 650  : 				bool bFound = false;

	mov	BYTE PTR _bFound$217679[ebp], 0

; 651  : 				bool bRequires = false;

	mov	BYTE PTR _bRequires$217680[ebp], 0

; 652  : 				for(int i = 0; i < GC.getNUM_UNIT_AND_TECH_PREREQS(); ++i)

	mov	DWORD PTR _i$217681[ebp], 0
	jmp	SHORT $LN9@GetRandomB
$LN8@GetRandomB:
	mov	edx, DWORD PTR _i$217681[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217681[ebp], edx
$LN9@GetRandomB:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6276
	mov	DWORD PTR $T218996[ebp], eax
	mov	ecx, DWORD PTR _i$217681[ebp]
	cmp	ecx, DWORD PTR $T218996[ebp]
	jge	SHORT $LN7@GetRandomB

; 653  : 				{
; 654  : 					TechTypes eTech = (TechTypes) kUnit.GetPrereqAndTechs(i);

	mov	edx, DWORD PTR _i$217681[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUnit$217658[ebp]
	call	?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetPrereqAndTechs
	mov	DWORD PTR _eTech$217685[ebp], eax

; 655  : 
; 656  : 					if(NO_TECH != eTech)

	cmp	DWORD PTR _eTech$217685[ebp], -1
	je	SHORT $LN6@GetRandomB

; 657  : 					{
; 658  : 						bRequires = true;

	mov	BYTE PTR _bRequires$217680[ebp], 1

; 659  : 
; 660  : 						if(GET_TEAM(BARBARIAN_TEAM).GetTeamTechs()->HasTech(eTech))

	mov	eax, 63					; 0000003fH
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T219000[ebp], eax
	mov	ecx, DWORD PTR _eTech$217685[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219000[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@GetRandomB

; 661  : 						{
; 662  : 							bFound = true;

	mov	BYTE PTR _bFound$217679[ebp], 1

; 663  : 							break;

	jmp	SHORT $LN7@GetRandomB
$LN6@GetRandomB:

; 664  : 						}
; 665  : 					}
; 666  : 				}

	jmp	SHORT $LN8@GetRandomB
$LN7@GetRandomB:

; 667  : 
; 668  : 				if(bRequires && !bFound)

	movzx	eax, BYTE PTR _bRequires$217680[ebp]
	test	eax, eax
	je	SHORT $LN10@GetRandomB
	movzx	ecx, BYTE PTR _bFound$217679[ebp]
	test	ecx, ecx
	jne	SHORT $LN10@GetRandomB

; 669  : 				{
; 670  : 					bValid = false;

	mov	BYTE PTR _bValid$217649[ebp], 0
$LN10@GetRandomB:

; 671  : 				}
; 672  : 			}
; 673  : 
; 674  : 			if(bValid)

	movzx	edx, BYTE PTR _bValid$217649[ebp]
	test	edx, edx
	je	SHORT $LN26@GetRandomB

; 675  : 			{
; 676  : 				iValue = (1 + kGame.getJonRandNum(1000, "Barb Unit Selection"));

	push	OFFSET ??_C@_0BE@HLDCOIFJ@Barb?5Unit?5Selection?$AA@
	push	1000					; 000003e8H
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, 1
	mov	DWORD PTR _iValue$[ebp], eax

; 677  : 
; 678  : 				if(kUnit.GetUnitAIType(eUnitAI))

	mov	eax, DWORD PTR _eUnitAI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUnit$217658[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetRandomB

; 679  : 				{
; 680  : 					iValue += 200;

	mov	edx, DWORD PTR _iValue$[ebp]
	add	edx, 200				; 000000c8H
	mov	DWORD PTR _iValue$[ebp], edx
$LN2@GetRandomB:

; 681  : 				}
; 682  : 
; 683  : 				if(iValue > iBestValue)

	mov	eax, DWORD PTR _iValue$[ebp]
	cmp	eax, DWORD PTR _iBestValue$[ebp]
	jle	SHORT $LN26@GetRandomB

; 684  : 				{
; 685  : 					eBestUnit = eLoopUnit;

	mov	ecx, DWORD PTR _eLoopUnit$217653[ebp]
	mov	DWORD PTR _eBestUnit$[ebp], ecx

; 686  : 					iBestValue = iValue;

	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], edx
$LN26@GetRandomB:

; 687  : 				}
; 688  : 			}
; 689  : 		}
; 690  : 	}

	jmp	$LN29@GetRandomB
$LN28@GetRandomB:

; 691  : 
; 692  : 	return eBestUnit;

	mov	eax, DWORD PTR _eBestUnit$[ebp]

; 693  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRandomBarbarianUnitType@CvBarbarians@@CA?AW4UnitTypes@@PAVCvArea@@W4UnitAITypes@@@Z ENDP ; CvBarbarians::GetRandomBarbarianUnitType
_TEXT	ENDS
PUBLIC	?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z ; CvBarbarians::DoSpawnBarbarianUnit
PUBLIC	?DoUnits@CvBarbarians@@SAXXZ			; CvBarbarians::DoUnits
; Function compile flags: /Odtp
;	COMDAT ?DoUnits@CvBarbarians@@SAXXZ
_TEXT	SEGMENT
$T219015 = -24						; size = 4
_pLoopPlot$217707 = -20					; size = 4
_iPlotLoop$217703 = -16					; size = 4
_kMap$ = -12						; size = 4
_eCamp$ = -8						; size = 4
_kGame$ = -4						; size = 4
?DoUnits@CvBarbarians@@SAXXZ PROC			; CvBarbarians::DoUnits, COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 698  : 	CvGame& kGame = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], eax

; 699  : 
; 700  : 	if(kGame.isOption(GAMEOPTION_NO_BARBARIANS))

	push	1
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@DoUnits

; 701  : 	{
; 702  : 		return;

	jmp	$LN8@DoUnits
$LN7@DoUnits:

; 703  : 	}
; 704  : 
; 705  : 	if(!CanBarbariansSpawn())

	call	?CanBarbariansSpawn@CvBarbarians@@CA_NXZ ; CvBarbarians::CanBarbariansSpawn
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@DoUnits

; 706  : 	{
; 707  : 		return;

	jmp	$LN8@DoUnits
$LN6@DoUnits:

; 708  : 	}
; 709  : 
; 710  : 	ImprovementTypes eCamp = (ImprovementTypes)GC.getBARBARIAN_CAMP_IMPROVEMENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR _eCamp$[ebp], eax

; 711  : 
; 712  : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], ecx

; 713  : #ifdef AUI_WARNING_FIXES
; 714  : 	for (uint iPlotLoop = 0; iPlotLoop < kMap.numPlots(); iPlotLoop++)
; 715  : #else
; 716  : 	for(int iPlotLoop = 0; iPlotLoop < kMap.numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$217703[ebp], 0
	jmp	SHORT $LN5@DoUnits
$LN4@DoUnits:
	mov	edx, DWORD PTR _iPlotLoop$217703[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotLoop$217703[ebp], edx
$LN5@DoUnits:
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T219015[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$217703[ebp]
	cmp	edx, DWORD PTR $T219015[ebp]
	jge	SHORT $LN8@DoUnits

; 717  : #endif
; 718  : 	{
; 719  : 		CvPlot* pLoopPlot = kMap.plotByIndexUnchecked(iPlotLoop);

	mov	eax, DWORD PTR _iPlotLoop$217703[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pLoopPlot$217707[ebp], eax

; 720  : 
; 721  : 		// Found a Camp to spawn near
; 722  : 		if(pLoopPlot->getImprovementType() == eCamp)

	mov	ecx, DWORD PTR _pLoopPlot$217707[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eCamp$[ebp]
	jne	SHORT $LN2@DoUnits

; 723  : 		{
; 724  : 			if(ShouldSpawnBarbFromCamp(pLoopPlot))

	mov	edx, DWORD PTR _pLoopPlot$217707[ebp]
	push	edx
	call	?ShouldSpawnBarbFromCamp@CvBarbarians@@SA_NPAVCvPlot@@@Z ; CvBarbarians::ShouldSpawnBarbFromCamp
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@DoUnits

; 725  : 			{
; 726  : 				DoSpawnBarbarianUnit(pLoopPlot, false, false);

	push	0
	push	0
	mov	ecx, DWORD PTR _pLoopPlot$217707[ebp]
	push	ecx
	call	?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z ; CvBarbarians::DoSpawnBarbarianUnit
	add	esp, 12					; 0000000cH

; 727  : 				DoCampActivationNotice(pLoopPlot);

	mov	edx, DWORD PTR _pLoopPlot$217707[ebp]
	push	edx
	call	?DoCampActivationNotice@CvBarbarians@@CAXPAVCvPlot@@@Z ; CvBarbarians::DoCampActivationNotice
	add	esp, 4
$LN2@DoUnits:

; 728  : 			}
; 729  : 		}

	jmp	SHORT $LN4@DoUnits
$LN8@DoUnits:

; 730  : 	}
; 731  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoUnits@CvBarbarians@@SAXXZ ENDP			; CvBarbarians::DoUnits
_TEXT	ENDS
PUBLIC	??_C@_0BO@FJEJKMEO@Barb?5Unit?5Location?5Spawn?5Roll?$AA@ ; `string'
PUBLIC	?push_back@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAEIABW4DirectionTypes@@@Z ; FStaticVector<enum DirectionTypes,6,1,297,0>::push_back
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
PUBLIC	?Destroy@?$BaseVector@W4DirectionTypes@@$00@@IAEXPAW4DirectionTypes@@I@Z ; BaseVector<enum DirectionTypes,1>::Destroy
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
EXTRN	?isBarbarian@CvUnit@@QBE_NXZ:PROC		; CvUnit::isBarbarian
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?GetNumCombatUnits@CvPlot@@QAEHXZ:PROC		; CvPlot::GetNumCombatUnits
;	COMDAT ??_C@_0BO@FJEJKMEO@Barb?5Unit?5Location?5Spawn?5Roll?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
??_C@_0BO@FJEJKMEO@Barb?5Unit?5Location?5Spawn?5Roll?$AA@ DB 'Barb Unit L'
	DB	'ocation Spawn Roll', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbarbarians.cpp
CONST	ENDS
;	COMDAT ?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z
_TEXT	SEGMENT
$T219454 = -336						; size = 4
$T219450 = -332						; size = 4
$T219446 = -328						; size = 4
$T219442 = -324						; size = 4
$T219438 = -320						; size = 4
$T219264 = -236						; size = 4
$T219260 = -232						; size = 4
$T219253 = -228						; size = 4
$T219249 = -224						; size = 4
$T219084 = -140						; size = 4
$T219080 = -136						; size = 4
$T219076 = -132						; size = 4
$T219072 = -128						; size = 4
$T219057 = -104						; size = 4
$T219053 = -100						; size = 4
$T219046 = -96						; size = 4
$T219042 = -92						; size = 4
$T219038 = -88						; size = 4
$T219034 = -84						; size = 4
$T219030 = -80						; size = 4
_pUnit$217768 = -76					; size = 4
_eUnit$217764 = -72					; size = 4
_iIndex$217759 = -68					; size = 4
_eUnitAI$217763 = -64					; size = 4
_pSpawnPlot$217762 = -60				; size = 4
_iDirectionLoop$217746 = -56				; size = 4
_bCanSpawnBoats$217745 = -49				; size = 1
_pLoopPlot$217744 = -48					; size = 4
_unit$217740 = -44					; size = 4
_pUnit$217727 = -40					; size = 4
_eUnit$217725 = -36					; size = 4
_iRange$ = -32						; size = 4
_iX$ = -28						; size = 4
_iNearbyUnitLoop$ = -24					; size = 4
_eDirection$ = -20					; size = 4
_iNumNearbyUnits$ = -16					; size = 4
_kGame$ = -12						; size = 4
_iY$ = -8						; size = 4
_pNearbyPlot$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_bIgnoreMaxBarbarians$ = 12				; size = 1
_bFinishMoves$ = 16					; size = 1
?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z PROC ; CvBarbarians::DoSpawnBarbarianUnit, COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H

; 737  : 	int iNumNearbyUnits;
; 738  : #ifdef AUI_WARNING_FIXES
; 739  : 	uint iNearbyUnitLoop;
; 740  : #else
; 741  : 	int iNearbyUnitLoop;
; 742  : #endif
; 743  : 	int iRange = GC.getMAX_BARBARIANS_FROM_CAMP_NEARBY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7064
	mov	DWORD PTR _iRange$[ebp], eax

; 744  : 	int iX;
; 745  : 	int iY;
; 746  : 	CvPlot* pNearbyPlot;
; 747  : 	DirectionTypes eDirection;
; 748  : 
; 749  : 	CvGame& kGame = GC.getGame();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$[ebp], ecx

; 750  : 
; 751  : 	if (pPlot == 0)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN32@DoSpawnBar

; 752  : 		return;

	jmp	$LN33@DoSpawnBar
$LN32@DoSpawnBar:

; 753  : 
; 754  : 	// is this camp empty - first priority is to fill it
; 755  : 	if (pPlot && pPlot->GetNumCombatUnits() == 0)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	$LN31@DoSpawnBar
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetNumCombatUnits@CvPlot@@QAEHXZ	; CvPlot::GetNumCombatUnits
	test	eax, eax
	jne	$LN31@DoSpawnBar

; 756  : 	{
; 757  : 		UnitTypes eUnit;
; 758  : 		eUnit = GetRandomBarbarianUnitType(GC.getMap().getArea(pPlot->getArea()), UNITAI_FAST_ATTACK);

	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T219030[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219034[ebp], ecx
	push	5
	mov	edx, DWORD PTR $T219030[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219034[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	push	eax
	call	?GetRandomBarbarianUnitType@CvBarbarians@@CA?AW4UnitTypes@@PAVCvArea@@W4UnitAITypes@@@Z ; CvBarbarians::GetRandomBarbarianUnitType
	add	esp, 8
	mov	DWORD PTR _eUnit$217725[ebp], eax

; 759  : 
; 760  : 		if (eUnit != NO_UNIT)

	cmp	DWORD PTR _eUnit$217725[ebp], -1
	je	SHORT $LN31@DoSpawnBar

; 761  : 		{
; 762  : 			CvUnit* pUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pPlot->getX(), pPlot->getY(), UNITAI_FAST_ATTACK);

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T219038[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T219042[ebp], eax
	mov	ecx, 63					; 0000003fH
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219046[ebp], ecx
	push	0
	push	0
	push	1
	push	0
	push	-1
	push	5
	mov	edx, DWORD PTR $T219038[ebp]
	push	edx
	mov	eax, DWORD PTR $T219042[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUnit$217725[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219046[ebp]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	DWORD PTR _pUnit$217727[ebp], eax

; 763  : 			pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$217727[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 764  : 			return;

	jmp	$LN33@DoSpawnBar
$LN31@DoSpawnBar:

; 765  : 		}
; 766  : 	}
; 767  : 
; 768  : 	m_aeValidBarbSpawnDirections.clear();

	mov	edx, DWORD PTR ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A+4
	push	edx
	mov	eax, DWORD PTR ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A
	push	eax
	mov	ecx, OFFSET ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A ; CvBarbarians::m_aeValidBarbSpawnDirections
	call	?Destroy@?$BaseVector@W4DirectionTypes@@$00@@IAEXPAW4DirectionTypes@@I@Z ; BaseVector<enum DirectionTypes,1>::Destroy
	mov	DWORD PTR ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A+4, 0

; 769  : 
; 770  : 	// Look at nearby Plots to see if there are already too many Barbs nearby
; 771  : 	iNumNearbyUnits = 0;

	mov	DWORD PTR _iNumNearbyUnits$[ebp], 0

; 772  : 
; 773  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 774  : 	int iMaxDX;
; 775  : 	for (iY = -iRange; iY <= iRange; iY++)
; 776  : 	{
; 777  : 		iMaxDX = iRange - MAX(0, iY);
; 778  : 		for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 779  : 		{
; 780  : 			// No need for range check because loops are set up properly
; 781  : 			pNearbyPlot = plotXY(pPlot->getX(), pPlot->getY(), iX, iY);
; 782  : #else
; 783  : 	for(iX = -iRange; iX <= iRange; iX++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iX$[ebp], ecx
	jmp	SHORT $LN29@DoSpawnBar
$LN28@DoSpawnBar:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, 1
	mov	DWORD PTR _iX$[ebp], edx
$LN29@DoSpawnBar:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	$LN27@DoSpawnBar

; 784  : 	{
; 785  : 		for(iY = -iRange; iY <= iRange; iY++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iY$[ebp], ecx
	jmp	SHORT $LN26@DoSpawnBar
$LN25@DoSpawnBar:
	mov	edx, DWORD PTR _iY$[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$[ebp], edx
$LN26@DoSpawnBar:
	mov	eax, DWORD PTR _iY$[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	$LN24@DoSpawnBar

; 786  : 		{
; 787  : 			// Cut off the corners of the area we're looking at that we don't want
; 788  : 			pNearbyPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iX, iY, iRange);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T219053[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T219057[ebp], ecx
	mov	edx, DWORD PTR _iRange$[ebp]
	push	edx
	mov	eax, DWORD PTR _iY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iX$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219053[ebp]
	push	edx
	mov	eax, DWORD PTR $T219057[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pNearbyPlot$[ebp], eax

; 789  : #endif
; 790  : 
; 791  : 			if(pNearbyPlot != NULL)

	cmp	DWORD PTR _pNearbyPlot$[ebp], 0
	je	SHORT $LN23@DoSpawnBar

; 792  : 			{
; 793  : 				if(pNearbyPlot->getNumUnits() > 0)

	mov	ecx, DWORD PTR _pNearbyPlot$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	SHORT $LN23@DoSpawnBar

; 794  : 				{
; 795  : 					for(iNearbyUnitLoop = 0; iNearbyUnitLoop < pNearbyPlot->getNumUnits(); iNearbyUnitLoop++)

	mov	DWORD PTR _iNearbyUnitLoop$[ebp], 0
	jmp	SHORT $LN21@DoSpawnBar
$LN20@DoSpawnBar:
	mov	ecx, DWORD PTR _iNearbyUnitLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNearbyUnitLoop$[ebp], ecx
$LN21@DoSpawnBar:
	mov	ecx, DWORD PTR _pNearbyPlot$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iNearbyUnitLoop$[ebp], eax
	jge	SHORT $LN23@DoSpawnBar

; 796  : 					{
; 797  : 						const CvUnit* const unit = pNearbyPlot->getUnitByIndex(iNearbyUnitLoop);

	mov	edx, DWORD PTR _iNearbyUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pNearbyPlot$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _unit$217740[ebp], eax

; 798  : #ifdef AUI_WARNING_FIXES
; 799  : 						if (unit && unit->isBarbarian())
; 800  : #else
; 801  : 						if(unit && pNearbyPlot->getUnitByIndex(iNearbyUnitLoop)->isBarbarian())

	cmp	DWORD PTR _unit$217740[ebp], 0
	je	SHORT $LN18@DoSpawnBar
	mov	eax, DWORD PTR _iNearbyUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNearbyPlot$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	ecx, eax
	call	?isBarbarian@CvUnit@@QBE_NXZ		; CvUnit::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@DoSpawnBar

; 802  : #endif
; 803  : 						{
; 804  : 							iNumNearbyUnits++;

	mov	edx, DWORD PTR _iNumNearbyUnits$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumNearbyUnits$[ebp], edx
$LN18@DoSpawnBar:

; 805  : 						}
; 806  : 					}

	jmp	SHORT $LN20@DoSpawnBar
$LN23@DoSpawnBar:

; 807  : 				}
; 808  : 			}
; 809  : 		}

	jmp	$LN25@DoSpawnBar
$LN24@DoSpawnBar:

; 810  : 	}

	jmp	$LN28@DoSpawnBar
$LN27@DoSpawnBar:

; 811  : 
; 812  : 	if(iNumNearbyUnits <= /*2*/ GC.getMAX_BARBARIANS_FROM_CAMP_NEARBY() || bIgnoreMaxBarbarians)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7060
	mov	DWORD PTR $T219072[ebp], eax
	mov	ecx, DWORD PTR _iNumNearbyUnits$[ebp]
	cmp	ecx, DWORD PTR $T219072[ebp]
	jle	SHORT $LN16@DoSpawnBar
	movzx	edx, BYTE PTR _bIgnoreMaxBarbarians$[ebp]
	test	edx, edx
	je	$LN33@DoSpawnBar
$LN16@DoSpawnBar:

; 813  : 	{
; 814  : 		CvPlot* pLoopPlot;
; 815  : 
; 816  : 		// Barbs only get boats after some period of time has passed
; 817  : 		bool bCanSpawnBoats = kGame.getElapsedGameTurns() > /*30*/ GC.getBARBARIAN_NAVAL_UNIT_START_TURN_SPAWN();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7056
	mov	DWORD PTR $T219076[ebp], eax
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T219076[ebp]
	setg	cl
	mov	BYTE PTR _bCanSpawnBoats$217745[ebp], cl

; 818  : 
; 819  : 		// Look to see if adjacent Tiles are valid locations to spawn a Unit
; 820  : 		for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; iDirectionLoop++)

	mov	DWORD PTR _iDirectionLoop$217746[ebp], 0
	jmp	SHORT $LN15@DoSpawnBar
$LN14@DoSpawnBar:
	mov	edx, DWORD PTR _iDirectionLoop$217746[ebp]
	add	edx, 1
	mov	DWORD PTR _iDirectionLoop$217746[ebp], edx
$LN15@DoSpawnBar:
	cmp	DWORD PTR _iDirectionLoop$217746[ebp], 6
	jge	$LN13@DoSpawnBar

; 821  : 		{
; 822  : 			eDirection = (DirectionTypes) iDirectionLoop;

	mov	eax, DWORD PTR _iDirectionLoop$217746[ebp]
	mov	DWORD PTR _eDirection$[ebp], eax

; 823  : 			pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), eDirection);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T219080[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T219084[ebp], ecx
	mov	edx, DWORD PTR _eDirection$[ebp]
	push	edx
	mov	eax, DWORD PTR $T219080[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219084[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$217744[ebp], eax

; 824  : 
; 825  : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$217744[ebp], 0
	je	$LN12@DoSpawnBar

; 826  : 			{
; 827  : 				if(pLoopPlot->getNumUnits() == 0)

	mov	ecx, DWORD PTR _pLoopPlot$217744[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jne	SHORT $LN12@DoSpawnBar

; 828  : 				{
; 829  : 					if(!pLoopPlot->isImpassable() && !pLoopPlot->isMountain())

	mov	edx, DWORD PTR _pLoopPlot$217744[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@DoSpawnBar
	mov	edx, DWORD PTR _pLoopPlot$217744[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@DoSpawnBar

; 830  : 					{
; 831  : 						if(!pLoopPlot->isCity())

	mov	ecx, DWORD PTR _pLoopPlot$217744[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@DoSpawnBar

; 832  : 						{
; 833  : 							if(!pLoopPlot->isLake())

	mov	ecx, DWORD PTR _pLoopPlot$217744[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@DoSpawnBar

; 834  : 							{
; 835  : 								// Water Tiles are only valid when the Barbs have the proper Tech
; 836  : 								if(!pLoopPlot->isWater() || bCanSpawnBoats)

	mov	ecx, DWORD PTR _pLoopPlot$217744[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@DoSpawnBar
	movzx	edx, BYTE PTR _bCanSpawnBoats$217745[ebp]
	test	edx, edx
	je	SHORT $LN12@DoSpawnBar
$LN6@DoSpawnBar:

; 837  : 								{
; 838  : 									m_aeValidBarbSpawnDirections.push_back(eDirection);

	lea	eax, DWORD PTR _eDirection$[ebp]
	push	eax
	mov	ecx, OFFSET ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A ; CvBarbarians::m_aeValidBarbSpawnDirections
	call	?push_back@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAEIABW4DirectionTypes@@@Z ; FStaticVector<enum DirectionTypes,6,1,297,0>::push_back
$LN12@DoSpawnBar:

; 839  : 								}
; 840  : 							}
; 841  : 						}
; 842  : 					}
; 843  : 				}
; 844  : 			}
; 845  : 		}

	jmp	$LN14@DoSpawnBar
$LN13@DoSpawnBar:

; 846  : 
; 847  : 		// Any valid locations?
; 848  : 		if(m_aeValidBarbSpawnDirections.size() > 0)

	mov	ecx, DWORD PTR ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A+4
	mov	DWORD PTR $T219249[ebp], ecx
	cmp	DWORD PTR $T219249[ebp], 0
	jbe	$LN33@DoSpawnBar

; 849  : 		{
; 850  : 			int iIndex = kGame.getJonRandNum(m_aeValidBarbSpawnDirections.size(), "Barb Unit Location Spawn Roll");

	mov	edx, DWORD PTR ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A+4
	mov	DWORD PTR $T219253[ebp], edx
	push	OFFSET ??_C@_0BO@FJEJKMEO@Barb?5Unit?5Location?5Spawn?5Roll?$AA@
	mov	eax, DWORD PTR $T219253[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGame$[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _iIndex$217759[ebp], eax

; 851  : 			eDirection = (DirectionTypes) m_aeValidBarbSpawnDirections[iIndex];

	mov	ecx, DWORD PTR _iIndex$217759[ebp]
	mov	edx, DWORD PTR ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _eDirection$[ebp], eax

; 852  : 			CvPlot* pSpawnPlot = plotDirection(pPlot->getX(), pPlot->getY(), eDirection);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T219260[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T219264[ebp], ecx
	mov	edx, DWORD PTR _eDirection$[ebp]
	push	edx
	mov	eax, DWORD PTR $T219260[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219264[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSpawnPlot$217762[ebp], eax

; 853  : 			UnitAITypes eUnitAI;
; 854  : 			UnitTypes eUnit;
; 855  : 
; 856  : 			// Naval Barbs
; 857  : 			if(pSpawnPlot->isWater())

	mov	edx, DWORD PTR _pSpawnPlot$217762[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@DoSpawnBar

; 858  : 			{
; 859  : 				eUnitAI = UNITAI_ATTACK_SEA;

	mov	DWORD PTR _eUnitAI$217763[ebp], 18	; 00000012H

; 860  : 			}
; 861  : 			// Land Barbs
; 862  : 			else

	jmp	SHORT $LN3@DoSpawnBar
$LN4@DoSpawnBar:

; 863  : 			{
; 864  : 				eUnitAI = UNITAI_FAST_ATTACK;

	mov	DWORD PTR _eUnitAI$217763[ebp], 5
$LN3@DoSpawnBar:

; 865  : 			}
; 866  : 
; 867  : 			eUnit = GetRandomBarbarianUnitType(GC.getMap().getArea(pSpawnPlot->getArea()), eUnitAI);

	mov	eax, DWORD PTR _pSpawnPlot$217762[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T219438[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219442[ebp], edx
	mov	eax, DWORD PTR _eUnitAI$217763[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219438[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219442[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	push	eax
	call	?GetRandomBarbarianUnitType@CvBarbarians@@CA?AW4UnitTypes@@PAVCvArea@@W4UnitAITypes@@@Z ; CvBarbarians::GetRandomBarbarianUnitType
	add	esp, 8
	mov	DWORD PTR _eUnit$217764[ebp], eax

; 868  : 
; 869  : 			if(eUnit != NO_UNIT)

	cmp	DWORD PTR _eUnit$217764[ebp], -1
	je	SHORT $LN33@DoSpawnBar

; 870  : 			{
; 871  : 				CvUnit* pUnit = GET_PLAYER(BARBARIAN_PLAYER).initUnit(eUnit, pSpawnPlot->getX(), pSpawnPlot->getY(), eUnitAI);

	mov	edx, DWORD PTR _pSpawnPlot$217762[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T219446[ebp], eax
	mov	ecx, DWORD PTR _pSpawnPlot$217762[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T219450[ebp], edx
	mov	eax, 63					; 0000003fH
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219454[ebp], eax
	push	0
	push	0
	push	1
	push	0
	push	-1
	mov	ecx, DWORD PTR _eUnitAI$217763[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219446[ebp]
	push	edx
	mov	eax, DWORD PTR $T219450[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUnit$217764[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219454[ebp]
	call	?initUnit@CvPlayer@@QAEPAVCvUnit@@W4UnitTypes@@HHW4UnitAITypes@@W4DirectionTypes@@_N3HH@Z ; CvPlayer::initUnit
	mov	DWORD PTR _pUnit$217768[ebp], eax

; 872  : 				if (bFinishMoves)

	movzx	edx, BYTE PTR _bFinishMoves$[ebp]
	test	edx, edx
	je	SHORT $LN33@DoSpawnBar

; 873  : 				{
; 874  : 					pUnit->finishMoves();

	mov	ecx, DWORD PTR _pUnit$217768[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN33@DoSpawnBar:

; 875  : 				}
; 876  : 			}
; 877  : 		}
; 878  : 	}
; 879  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoSpawnBarbarianUnit@CvBarbarians@@SAXPAVCvPlot@@_N1@Z ENDP ; CvBarbarians::DoSpawnBarbarianUnit
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T219661 = -80						; size = 4
$T219616 = -76						; size = 4
$T219603 = -72						; size = 4
$T219599 = -68						; size = 4
$T219585 = -64						; size = 4
$T219581 = -57						; size = 1
$T219570 = -56						; size = 4
$T219566 = -49						; size = 1
_iMapY$219660 = -48					; size = 4
_iMapX$219659 = -44					; size = 4
$T219559 = -40						; size = 4
$T219535 = -36						; size = 4
$T219498 = -32						; size = 4
$T219486 = -28						; size = 4
$T219482 = -21						; size = 1
$T219471 = -20						; size = 4
$T219467 = -13						; size = 1
_iMapY$219534 = -12					; size = 4
_iMapX$219533 = -8					; size = 4
$T219460 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219460[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T219535[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T219460[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T219467[ebp], dl
	mov	eax, DWORD PTR $T219460[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219471[ebp], ecx
	movzx	edx, BYTE PTR $T219467[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219471[ebp]
	add	edx, DWORD PTR $T219471[ebp]
	mov	DWORD PTR _iMapX$219533[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T219471[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219471[ebp]
	mov	DWORD PTR _iMapX$219533[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$219533[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T219460[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T219482[ebp], al
	mov	ecx, DWORD PTR $T219460[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T219486[ebp], edx
	movzx	eax, BYTE PTR $T219482[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219486[ebp]
	add	edx, DWORD PTR $T219486[ebp]
	mov	DWORD PTR _iMapY$219534[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T219486[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219486[ebp]
	mov	DWORD PTR _iMapY$219534[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$219534[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$219534[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$219533[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219460[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T219460[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T219498[ebp], eax
	mov	ecx, DWORD PTR _iMapY$219534[ebp]
	imul	ecx, DWORD PTR $T219498[ebp]
	add	ecx, DWORD PTR _iMapX$219533[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T219460[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T219535[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T219535[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219559[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T219661[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T219559[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T219566[ebp], dl
	mov	eax, DWORD PTR $T219559[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219570[ebp], ecx
	movzx	edx, BYTE PTR $T219566[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219570[ebp]
	add	edx, DWORD PTR $T219570[ebp]
	mov	DWORD PTR _iMapX$219659[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T219570[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219570[ebp]
	mov	DWORD PTR _iMapX$219659[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$219659[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T219559[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T219581[ebp], al
	mov	ecx, DWORD PTR $T219559[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T219585[ebp], edx
	movzx	eax, BYTE PTR $T219581[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219585[ebp]
	add	edx, DWORD PTR $T219585[ebp]
	mov	DWORD PTR _iMapY$219660[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T219585[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219585[ebp]
	mov	DWORD PTR _iMapY$219660[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$219660[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$219659[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T219559[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219599[ebp], ecx
	mov	edx, DWORD PTR _iMapX$219659[ebp]
	cmp	edx, DWORD PTR $T219599[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$219660[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T219559[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T219603[ebp], ecx
	mov	edx, DWORD PTR _iMapY$219660[ebp]
	cmp	edx, DWORD PTR $T219603[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T219559[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219616[ebp], ecx
	mov	edx, DWORD PTR _iMapY$219660[ebp]
	imul	edx, DWORD PTR $T219616[ebp]
	add	edx, DWORD PTR _iMapX$219659[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T219559[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T219661[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T219661[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216958 = -20					; size = 4
_iAbsDX$216957 = -16					; size = 4
_iAbsDY$216955 = -12					; size = 4
_iAbsDX$216954 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216954[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216955[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216954[ebp]
	add	edx, DWORD PTR _iAbsDY$216955[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216957[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216958[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216957[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216958[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216957[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216958[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum DirectionTypes,6,1,297,0>::GrowSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAEIABW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T219797 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAEIABW4DirectionTypes@@@Z PROC ; FStaticVector<enum DirectionTypes,6,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+36], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<enum DirectionTypes,6,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T219797[ebp], ecx
	cmp	DWORD PTR $T219797[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T219797[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T219797[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAEIABW4DirectionTypes@@@Z ENDP ; FStaticVector<enum DirectionTypes,6,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T219875 = -36						; size = 4
$T219874 = -32						; size = 4
_i$219867 = -28						; size = 4
$T219850 = -24						; size = 4
_pRet$219847 = -20					; size = 4
$T219841 = -16						; size = 4
_i$217803 = -12						; size = 4
_uiNewSize$217795 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<enum DirectionTypes,6,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$217795[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$217795[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$217795[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T219850[ebp], ecx
	cmp	DWORD PTR $T219850[ebp], 6
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T219850[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$219847[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T219850[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$219847[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 6
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$219847[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$217803[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$217803[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217803[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$217803[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$217803[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T219841[ebp], ecx
	cmp	DWORD PTR $T219841[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T219841[ebp]
	mov	edx, DWORD PTR _i$217803[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T219841[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219875[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219874[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$219867[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	edx, DWORD PTR _i$219867[ebp]
	add	edx, 1
	mov	DWORD PTR _i$219867[ebp], edx
$LN26@GrowSize:
	mov	eax, DWORD PTR _i$219867[ebp]
	cmp	eax, DWORD PTR $T219875[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T219874[ebp], ecx
	je	SHORT $LN22@GrowSize
	mov	edx, DWORD PTR $T219874[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+36], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<enum DirectionTypes,6,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@W4DirectionTypes@@$00@@IAEXPAW4DirectionTypes@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$217832 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@W4DirectionTypes@@$00@@IAEXPAW4DirectionTypes@@I@Z PROC ; BaseVector<enum DirectionTypes,1>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	xor	eax, eax
	je	SHORT $LN5@Destroy

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$217832[ebp], 0
	jmp	SHORT $LN3@Destroy
$LN2@Destroy:
	mov	ecx, DWORD PTR _i$217832[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$217832[ebp], ecx
$LN3@Destroy:
	mov	edx, DWORD PTR _i$217832[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy

; 223  : 				pVal[i].~T();
; 224  : 			}

	jmp	SHORT $LN2@Destroy
$LN5@Destroy:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@W4DirectionTypes@@$00@@IAEXPAW4DirectionTypes@@I@Z ENDP ; BaseVector<enum DirectionTypes,1>::Destroy
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAAF@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5F@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@F@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5F@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@F@@@Z PROC ; operator>><short>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5F@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@F@@@Z ENDP ; operator>><short>
_TEXT	ENDS
EXTRN	?Write@FDataStream@@IAEXABF@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??$?6F@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@F@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6F@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@F@@@Z PROC ; operator<<<short>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6F@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@F@@@Z ENDP ; operator<<<short>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T219914 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219914[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T219914[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T219920 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219920[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T219920[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T219932 = -8						; size = 4
$T219928 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219928[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T219928[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T219932[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T219932[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum DirectionTypes,6,1,297,0>::FStaticVector<enum DirectionTypes,6,1,297,0>
EXTRN	_atexit:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbarbarians.cpp
;	COMDAT ??__E?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ
text$yc	SEGMENT
??__E?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ PROC ; `dynamic initializer for 'CvBarbarians::m_aeValidBarbSpawnDirections'', COMDAT

; 22   : FStaticVector<DirectionTypes, 6, true, c_eCiv5GameplayDLL, 0> CvBarbarians::m_aeValidBarbSpawnDirections;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A ; CvBarbarians::m_aeValidBarbSpawnDirections
	call	??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum DirectionTypes,6,1,297,0>::FStaticVector<enum DirectionTypes,6,1,297,0>
	push	OFFSET ??__F?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ ; `dynamic atexit destructor for 'CvBarbarians::m_aeValidBarbSpawnDirections''
	call	_atexit
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CvBarbarians::m_aeValidBarbSpawnDirections''
text$yc	ENDS
PUBLIC	??1?$BaseVector@W4DirectionTypes@@$00@@QAE@XZ	; BaseVector<enum DirectionTypes,1>::~BaseVector<enum DirectionTypes,1>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T219960 = -20						; size = 4
_pRet$219956 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum DirectionTypes,6,1,297,0>::FStaticVector<enum DirectionTypes,6,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 6

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219960[ebp], edx
	cmp	DWORD PTR $T219960[ebp], 6
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T219960[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$219956[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T219960[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$219956[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 6
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$219956[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@W4DirectionTypes@@$00@@QAE@XZ ; BaseVector<enum DirectionTypes,1>::~BaseVector<enum DirectionTypes,1>
__ehhandler$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum DirectionTypes,6,1,297,0>::FStaticVector<enum DirectionTypes,6,1,297,0>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@W4DirectionTypes@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@W4DirectionTypes@@$00@@QAE@XZ PROC	; BaseVector<enum DirectionTypes,1>::~BaseVector<enum DirectionTypes,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@W4DirectionTypes@@$00@@QAE@XZ ENDP	; BaseVector<enum DirectionTypes,1>::~BaseVector<enum DirectionTypes,1>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum DirectionTypes,6,1,297,0>::~FStaticVector<enum DirectionTypes,6,1,297,0>
; Function compile flags: /Odtp
;	COMDAT ??__F?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ
text$yd	SEGMENT
??__F?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CvBarbarians::m_aeValidBarbSpawnDirections'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET ?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A ; CvBarbarians::m_aeValidBarbSpawnDirections
	call	??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<enum DirectionTypes,6,1,297,0>::~FStaticVector<enum DirectionTypes,6,1,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CvBarbarians::m_aeValidBarbSpawnDirections''
text$yd	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T220022 = -24						; size = 4
$T220021 = -20						; size = 4
_i$220016 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<enum DirectionTypes,6,1,297,0>::~FStaticVector<enum DirectionTypes,6,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220022[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T220021[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$220016[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$220016[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220016[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$220016[ebp]
	cmp	ecx, DWORD PTR $T220022[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T220021[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T220021[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@W4DirectionTypes@@$00@@QAE@XZ ; BaseVector<enum DirectionTypes,1>::~BaseVector<enum DirectionTypes,1>
__ehhandler$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<enum DirectionTypes,6,1,297,0>::~FStaticVector<enum DirectionTypes,6,1,297,0>
PUBLIC	?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A ; CvBarbarians::m_aeValidBarbSpawnDirections
_BSS	SEGMENT
?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A DB 028H DUP (?) ; CvBarbarians::m_aeValidBarbSpawnDirections
_BSS	ENDS
CRT$XCU	SEGMENT
?m_aeValidBarbSpawnDirections$initializer$@CvBarbarians@@0P6AXXZA DD FLAT:??__E?m_aeValidBarbSpawnDirections@CvBarbarians@@0V?$FStaticVector@W4DirectionTypes@@$05$00$0BCJ@$0A@@@A@@YAXXZ ; CvBarbarians::m_aeValidBarbSpawnDirections$initializer$
CRT$XCU	ENDS
END
