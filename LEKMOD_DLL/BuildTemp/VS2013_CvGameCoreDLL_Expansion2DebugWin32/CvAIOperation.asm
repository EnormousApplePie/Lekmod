; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvAIOperation.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
PUBLIC	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::~_Vector_val<OperationSlot,std::allocator<OperationSlot> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?Reset@CvAIOperation@@UAEXXZ			; CvAIOperation::Reset
PUBLIC	?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	??_7CvAIOperation@@6B@				; CvAIOperation::`vftable'
PUBLIC	??0CvAIOperation@@QAE@XZ			; CvAIOperation::CvAIOperation
PUBLIC	?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperation::Init
PUBLIC	?Uninit@CvAIOperation@@UAEXXZ			; CvAIOperation::Uninit
PUBLIC	?GetOperationType@CvAIOperation@@UBEHXZ		; CvAIOperation::GetOperationType
PUBLIC	?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ ; CvAIOperation::CanTacticalAIInterruptOperation
PUBLIC	?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ	; CvAIOperation::NeedToCheckPathToTarget
PUBLIC	?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ	; CvAIOperation::GetMaximumRecruitTurns
PUBLIC	?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperation::GetFormation
PUBLIC	?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ ; CvAIOperation::GetMoveType
PUBLIC	?IsAllNavalOperation@CvAIOperation@@UBE_NXZ	; CvAIOperation::IsAllNavalOperation
PUBLIC	?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ ; CvAIOperation::IsMixedLandNavalOperation
PUBLIC	?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z ; CvAIOperation::GetGatherTolerance
PUBLIC	?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ ; CvAIOperation::GetOperationStartCity
PUBLIC	?CheckOnTarget@CvAIOperation@@UAE_NXZ		; CvAIOperation::CheckOnTarget
PUBLIC	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
PUBLIC	?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z	; CvAIOperation::ArmyMoved
PUBLIC	?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ ; CvAIOperation::PercentFromMusterPointToTarget
PUBLIC	?ShouldAbort@CvAIOperation@@UAE_NXZ		; CvAIOperation::ShouldAbort
PUBLIC	?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ; CvAIOperation::SetToAbort
PUBLIC	?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ; CvAIOperation::Kill
PUBLIC	?DoTurn@CvAIOperation@@UAEXXZ			; CvAIOperation::DoTurn
PUBLIC	?DoDelayedDeath@CvAIOperation@@UAE_NXZ		; CvAIOperation::DoDelayedDeath
PUBLIC	?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ ; CvAIOperation::BuildListOfUnitsWeStillNeedToBuild
PUBLIC	?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z ; CvAIOperation::PeekAtNextUnitToBuild
PUBLIC	?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ; CvAIOperation::CommitToBuildNextUnit
PUBLIC	?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z ; CvAIOperation::UncommitToBuild
PUBLIC	?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z ; CvAIOperation::FinishedBuilding
PUBLIC	?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z ; CvAIOperation::GrabUnitsFromTheReserves
PUBLIC	?UnitWasRemoved@CvAIOperation@@UAEXHH@Z		; CvAIOperation::UnitWasRemoved
PUBLIC	?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z ; CvAIOperation::ComputeCenterOfMassForTurn
PUBLIC	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z	; CvAIOperation::Read
PUBLIC	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z	; CvAIOperation::Write
PUBLIC	?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ ; CvAIOperation::GetOperationName
PUBLIC	?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ; CvAIOperation::SelectInitialMusterPoint
PUBLIC	?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ; CvAIOperation::FindBestFitReserveUnit
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_ECvAIOperation@@UAEPAXI@Z:PROC		; CvAIOperation::`vector deleting destructor'
;	COMDAT ??_7CvAIOperation@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	SEGMENT
??_7CvAIOperation@@6B@ DD FLAT:??_ECvAIOperation@@UAEPAXI@Z ; CvAIOperation::`vftable'
	DD	FLAT:?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvAIOperation@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0CvAIOperation@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvAIOperation@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$1
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$9
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$2
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ??0CvAIOperation@@QAE@XZ
_TEXT	SEGMENT
tv249 = -340						; size = 4
tv278 = -336						; size = 4
tv194 = -332						; size = 4
tv223 = -328						; size = 4
tv143 = -324						; size = 4
tv168 = -320						; size = 4
_this$ = -316						; size = 4
$T229809 = -312						; size = 4
$T229768 = -222						; size = 1
$T229755 = -221						; size = 1
$T229751 = -220						; size = 4
$T229744 = -212						; size = 4
$T229737 = -204						; size = 4
$T229698 = -126						; size = 1
$T229685 = -125						; size = 1
$T229681 = -124						; size = 4
$T229674 = -116						; size = 4
$T229667 = -108						; size = 4
$T229627 = -30						; size = 1
$T229614 = -29						; size = 1
$T229610 = -28						; size = 4
$T229603 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvAIOperation@@QAE@XZ PROC				; CvAIOperation::CvAIOperation, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvAIOperation@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperation@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T229667[ebp], ecx
	lea	edx, DWORD PTR $T229627[ebp]
	mov	DWORD PTR $T229603[ebp], edx
	lea	eax, DWORD PTR $T229614[ebp]
	mov	DWORD PTR $T229610[ebp], eax
	mov	ecx, DWORD PTR $T229667[ebp]
	mov	DWORD PTR tv168[ebp], ecx
	mov	edx, DWORD PTR $T229667[ebp]
	mov	DWORD PTR tv143[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR $T229667[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T229737[ebp], eax
	lea	ecx, DWORD PTR $T229698[ebp]
	mov	DWORD PTR $T229674[ebp], ecx
	lea	edx, DWORD PTR $T229685[ebp]
	mov	DWORD PTR $T229681[ebp], edx
	mov	eax, DWORD PTR $T229737[ebp]
	mov	DWORD PTR tv223[ebp], eax
	mov	ecx, DWORD PTR $T229737[ebp]
	mov	DWORD PTR tv194[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	0
	mov	ecx, DWORD PTR $T229737[ebp]
	call	?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR $T229809[ebp], edx
	lea	eax, DWORD PTR $T229768[ebp]
	mov	DWORD PTR $T229744[ebp], eax
	lea	ecx, DWORD PTR $T229755[ebp]
	mov	DWORD PTR $T229751[ebp], ecx
	mov	edx, DWORD PTR $T229809[ebp]
	mov	DWORD PTR tv278[ebp], edx
	mov	eax, DWORD PTR $T229809[ebp]
	mov	DWORD PTR tv249[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	0
	mov	ecx, DWORD PTR $T229809[ebp]
	call	?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], -1

; 37   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvAIOperation@@UAEXXZ		; CvAIOperation::Reset

; 38   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvAIOperation@@QAE@XZ$3:
	mov	ecx, DWORD PTR $T229667[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$??0CvAIOperation@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvAIOperation@@QAE@XZ$6:
	mov	ecx, DWORD PTR $T229737[ebp]
	jmp	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvAIOperation@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__unwindfunclet$??0CvAIOperation@@QAE@XZ$9:
	mov	ecx, DWORD PTR $T229809[ebp]
	jmp	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvAIOperation@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__ehhandler$??0CvAIOperation@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvAIOperation@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvAIOperation@@QAE@XZ ENDP				; CvAIOperation::CvAIOperation
PUBLIC	??1CvAIOperation@@UAE@XZ			; CvAIOperation::~CvAIOperation
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperation@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperation@@UAEPAXI@Z PROC			; CvAIOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperation@@UAEPAXI@Z ENDP			; CvAIOperation::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1CvAIOperation@@UAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1CvAIOperation@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvAIOperation@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ??1CvAIOperation@@UAE@XZ
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T230055 = -116						; size = 4
$T229999 = -84						; size = 4
$T229913 = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1CvAIOperation@@UAE@XZ PROC				; CvAIOperation::~CvAIOperation, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvAIOperation@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperation@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 43   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvAIOperation@@UAEXXZ		; CvAIOperation::Uninit

; 44   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T229913[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T229913[ebp]
	call	?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T229999[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T229999[ebp]
	call	?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T230055[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T230055[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvAIOperation@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvAIOperation@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__unwindfunclet$??1CvAIOperation@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__unwindfunclet$??1CvAIOperation@@UAE@XZ$3:
	mov	ecx, DWORD PTR $T229913[ebp]
	jmp	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvAIOperation@@UAE@XZ$5:
	mov	ecx, DWORD PTR $T229999[ebp]
	jmp	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvAIOperation@@UAE@XZ$7:
	mov	ecx, DWORD PTR $T230055[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1CvAIOperation@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvAIOperation@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvAIOperation@@UAE@XZ ENDP				; CvAIOperation::~CvAIOperation
PUBLIC	?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetStartCityPlot
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
; Function compile flags: /Odtp
;	COMDAT ?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperation::Init, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 	Uninit();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 50   : 	m_iID = iID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 51   : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 52   : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [edx+76], eax

; 53   : 	m_iDefaultArea = iDefaultArea;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iDefaultArea$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 54   : #ifndef AUI_WARNING_FIXES
; 55   : 	m_bShouldReplaceLossesWithReinforcements = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+80], 0

; 56   : #endif
; 57   : 
; 58   : 	SetStartCityPlot(pMuster->plot());

	mov	ecx, DWORD PTR _pMuster$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetStartCityPlot

; 59   : 
; 60   : 	// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 61   : 	BuildListOfUnitsWeStillNeedToBuild();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 62   : 	GrabUnitsFromTheReserves(NULL, NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperation::Init
_TEXT	ENDS
PUBLIC	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?DeleteArmyAI@CvAIOperation@@QAE_NH@Z		; CvAIOperation::DeleteArmyAI
EXTRN	?deleteArmyAI@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::deleteArmyAI
EXTRN	?Kill@CvArmyAI@@QAEXXZ:PROC			; CvArmyAI::Kill
EXTRN	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z:PROC	; CvPlayer::getArmyAI
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -296						; size = 4
$T230634 = -292						; size = 4
$T230467 = -224						; size = 4
$T230451 = -220						; size = 4
$T230620 = -216						; size = 4
$T230619 = -212						; size = 4
$T230618 = -208						; size = 4
$T230617 = -204						; size = 4
$T230616 = -200						; size = 4
$T230435 = -196						; size = 4
$T230268 = -128						; size = 4
$T230252 = -124						; size = 4
$T230422 = -120						; size = 4
$T230420 = -116						; size = 4
$T230419 = -112						; size = 4
$T230418 = -108						; size = 4
$T230417 = -104						; size = 4
$T230236 = -100						; size = 4
$T230114 = -48						; size = 4
$T230098 = -44						; size = 4
$T230222 = -40						; size = 4
$T230221 = -36						; size = 4
$T230220 = -32						; size = 4
$T230219 = -28						; size = 4
$T230218 = -24						; size = 4
$T230076 = -20						; size = 4
$T230072 = -16						; size = 4
_thisArmy$222807 = -12					; size = 4
_uiI$222803 = -8					; size = 4
_thisPlayer$222802 = -4					; size = 4
?Uninit@CvAIOperation@@UAEXXZ PROC			; CvAIOperation::Uninit, COMDAT
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 	if(m_eOwner != NO_PLAYER)  // hopefully if this has been init'ed this should not happen

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+72], -1
	je	$LN5@Uninit

; 69   : 	{
; 70   : 		CvPlayer& thisPlayer = GET_PLAYER(m_eOwner);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$222802[ebp], edx

; 71   : 
; 72   : 		// remove the armies (which should, in turn, free up their units for other tasks)
; 73   : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$222803[ebp], 0
	jmp	SHORT $LN4@Uninit
$LN3@Uninit:
	mov	eax, DWORD PTR _uiI$222803[ebp]
	add	eax, 1
	mov	DWORD PTR _uiI$222803[ebp], eax
$LN4@Uninit:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T230072[ebp], ecx
	mov	edx, DWORD PTR $T230072[ebp]
	mov	eax, DWORD PTR $T230072[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _uiI$222803[ebp], ecx
	jae	SHORT $LN5@Uninit

; 74   : 		{
; 75   : 			CvArmyAI* thisArmy = thisPlayer.getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _uiI$222803[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T230076[ebp], edx
	mov	eax, DWORD PTR $T230076[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _thisPlayer$222802[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _thisArmy$222807[ebp], eax

; 76   : 			if(thisArmy)

	cmp	DWORD PTR _thisArmy$222807[ebp], 0
	je	SHORT $LN1@Uninit

; 77   : 			{
; 78   : 				thisArmy->Kill();

	mov	ecx, DWORD PTR _thisArmy$222807[ebp]
	call	?Kill@CvArmyAI@@QAEXXZ			; CvArmyAI::Kill

; 79   : 				thisPlayer.deleteArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _uiI$222803[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _thisPlayer$222802[ebp]
	call	?deleteArmyAI@CvPlayer@@QAEXH@Z		; CvPlayer::deleteArmyAI

; 80   : 				DeleteArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$222803[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArmyAI@CvAIOperation@@QAE_NH@Z	; CvAIOperation::DeleteArmyAI
$LN1@Uninit:

; 81   : 			}
; 82   : 		}

	jmp	$LN3@Uninit
$LN5@Uninit:

; 83   : 	}
; 84   : 
; 85   : 	// clear out the lists
; 86   : 	m_viArmyIDs.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T230236[ebp], ecx
	mov	edx, DWORD PTR $T230236[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230098[ebp], eax
	mov	ecx, DWORD PTR $T230098[ebp]
	mov	DWORD PTR $T230219[ebp], ecx
	mov	edx, DWORD PTR $T230219[ebp]
	mov	DWORD PTR $T230218[ebp], edx
	mov	eax, DWORD PTR $T230236[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230114[ebp], ecx
	mov	edx, DWORD PTR $T230114[ebp]
	mov	DWORD PTR $T230221[ebp], edx
	mov	eax, DWORD PTR $T230221[ebp]
	mov	DWORD PTR $T230220[ebp], eax
	mov	ecx, DWORD PTR $T230218[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230220[ebp]
	push	edx
	lea	eax, DWORD PTR $T230222[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230236[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 87   : 	m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T230435[ebp], ecx
	mov	edx, DWORD PTR $T230435[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230252[ebp], eax
	mov	ecx, DWORD PTR $T230252[ebp]
	mov	DWORD PTR $T230418[ebp], ecx
	mov	edx, DWORD PTR $T230418[ebp]
	mov	DWORD PTR $T230417[ebp], edx
	mov	eax, DWORD PTR $T230435[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230268[ebp], ecx
	mov	edx, DWORD PTR $T230268[ebp]
	mov	DWORD PTR $T230420[ebp], edx
	mov	eax, DWORD PTR $T230420[ebp]
	mov	DWORD PTR $T230419[ebp], eax
	mov	ecx, DWORD PTR $T230417[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230419[ebp]
	push	edx
	lea	eax, DWORD PTR $T230422[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230435[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 88   : 	m_viListOfUnitsCitiesHaveCommittedToBuild.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T230634[ebp], ecx
	mov	edx, DWORD PTR $T230634[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230451[ebp], eax
	mov	ecx, DWORD PTR $T230451[ebp]
	mov	DWORD PTR $T230617[ebp], ecx
	mov	edx, DWORD PTR $T230617[ebp]
	mov	DWORD PTR $T230616[ebp], edx
	mov	eax, DWORD PTR $T230634[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230467[ebp], ecx
	mov	edx, DWORD PTR $T230467[ebp]
	mov	DWORD PTR $T230619[ebp], edx
	mov	eax, DWORD PTR $T230619[ebp]
	mov	DWORD PTR $T230618[ebp], eax
	mov	ecx, DWORD PTR $T230616[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230618[ebp]
	push	edx
	lea	eax, DWORD PTR $T230620[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230634[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 89   : 
; 90   : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvAIOperation@@UAEXXZ ENDP			; CvAIOperation::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Reset@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T230786 = -84						; size = 4
$T230668 = -28						; size = 4
$T230652 = -24						; size = 4
$T230772 = -20						; size = 4
$T230771 = -16						; size = 4
$T230770 = -12						; size = 4
$T230769 = -8						; size = 4
$T230768 = -4						; size = 4
?Reset@CvAIOperation@@UAEXXZ PROC			; CvAIOperation::Reset, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	m_iID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 97   : 	m_eOwner = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], -1

; 98   : 	m_eEnemy = NO_PLAYER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], -1

; 99   : 	m_iDefaultArea = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], -1

; 100  : 	m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 101  : 	m_eAbortReason = NO_ABORT_REASON;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], -1

; 102  : 	m_iTargetX = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0

; 103  : 	m_iTargetY = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0

; 104  : 	m_iMusterX = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0

; 105  : 	m_iMusterY = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 106  : 	m_iStartCityX = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], -1

; 107  : 	m_iStartCityY = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], -1

; 108  : 	m_eMoveType = INVALID_AI_OPERATION_MOVE_TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], -1

; 109  : #ifdef AUI_WARNING_FIXES
; 110  : 	m_bShouldReplaceLossesWithReinforcements = false;
; 111  : #endif
; 112  : 	m_iLastTurnMoved = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], -1

; 113  : 	m_viArmyIDs.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T230786[ebp], edx
	mov	eax, DWORD PTR $T230786[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T230652[ebp], ecx
	mov	edx, DWORD PTR $T230652[ebp]
	mov	DWORD PTR $T230769[ebp], edx
	mov	eax, DWORD PTR $T230769[ebp]
	mov	DWORD PTR $T230768[ebp], eax
	mov	ecx, DWORD PTR $T230786[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T230668[ebp], edx
	mov	eax, DWORD PTR $T230668[ebp]
	mov	DWORD PTR $T230771[ebp], eax
	mov	ecx, DWORD PTR $T230771[ebp]
	mov	DWORD PTR $T230770[ebp], ecx
	mov	edx, DWORD PTR $T230768[ebp]
	push	edx
	mov	eax, DWORD PTR $T230770[ebp]
	push	eax
	lea	ecx, DWORD PTR $T230772[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T230786[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvAIOperation@@UAEXXZ ENDP			; CvAIOperation::Reset
_TEXT	ENDS
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T230792 = -4						; size = 4
?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ PROC	; CvAIOperation::GetMaximumRecruitTurns, COMDAT
; _this$ = ecx

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 	return GC.getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7852
	mov	DWORD PTR $T230792[ebp], eax
	mov	eax, DWORD PTR $T230792[ebp]

; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ ENDP	; CvAIOperation::GetMaximumRecruitTurns
_TEXT	ENDS
PUBLIC	?GetID@CvAIOperation@@QBEHXZ			; CvAIOperation::GetID
; Function compile flags: /Odtp
;	COMDAT ?GetID@CvAIOperation@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@CvAIOperation@@QBEHXZ PROC			; CvAIOperation::GetID, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	return m_iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@CvAIOperation@@QBEHXZ ENDP			; CvAIOperation::GetID
_TEXT	ENDS
PUBLIC	?SetID@CvAIOperation@@QAEXH@Z			; CvAIOperation::SetID
; Function compile flags: /Odtp
;	COMDAT ?SetID@CvAIOperation@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?SetID@CvAIOperation@@QAEXH@Z PROC			; CvAIOperation::SetID, COMDAT
; _this$ = ecx

; 130  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 	m_iID = iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetID@CvAIOperation@@QAEXH@Z ENDP			; CvAIOperation::SetID
_TEXT	ENDS
PUBLIC	?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z	; CvAIOperation::SetOwner
; Function compile flags: /Odtp
;	COMDAT ?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z PROC	; CvAIOperation::SetOwner, COMDAT
; _this$ = ecx

; 136  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 	m_eOwner = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 138  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z ENDP	; CvAIOperation::SetOwner
_TEXT	ENDS
PUBLIC	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ	; CvAIOperation::GetEnemy
; Function compile flags: /Odtp
;	COMDAT ?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ PROC	; CvAIOperation::GetEnemy, COMDAT
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	return m_eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+76]

; 144  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ENDP	; CvAIOperation::GetEnemy
_TEXT	ENDS
PUBLIC	?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z	; CvAIOperation::SetEnemy
; Function compile flags: /Odtp
;	COMDAT ?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eEnemy$ = 8						; size = 4
?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z PROC	; CvAIOperation::SetEnemy, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 150  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z ENDP	; CvAIOperation::SetEnemy
_TEXT	ENDS
PUBLIC	?GetDefaultArea@CvAIOperation@@QBEHXZ		; CvAIOperation::GetDefaultArea
; Function compile flags: /Odtp
;	COMDAT ?GetDefaultArea@CvAIOperation@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDefaultArea@CvAIOperation@@QBEHXZ PROC		; CvAIOperation::GetDefaultArea, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	return m_iDefaultArea;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDefaultArea@CvAIOperation@@QBEHXZ ENDP		; CvAIOperation::GetDefaultArea
_TEXT	ENDS
PUBLIC	?SetDefaultArea@CvAIOperation@@QAEXH@Z		; CvAIOperation::SetDefaultArea
; Function compile flags: /Odtp
;	COMDAT ?SetDefaultArea@CvAIOperation@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iDefaultArea$ = 8					; size = 4
?SetDefaultArea@CvAIOperation@@QAEXH@Z PROC		; CvAIOperation::SetDefaultArea, COMDAT
; _this$ = ecx

; 160  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 	m_iDefaultArea = iDefaultArea;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iDefaultArea$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDefaultArea@CvAIOperation@@QAEXH@Z ENDP		; CvAIOperation::SetDefaultArea
_TEXT	ENDS
PUBLIC	?GetFirstArmyID@CvAIOperation@@QAEHXZ		; CvAIOperation::GetFirstArmyID
; Function compile flags: /Odtp
;	COMDAT ?GetFirstArmyID@CvAIOperation@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T230817 = -4						; size = 4
?GetFirstArmyID@CvAIOperation@@QAEHXZ PROC		; CvAIOperation::GetFirstArmyID, COMDAT
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 	if(!m_viArmyIDs.empty())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T230817[ebp], eax
	mov	ecx, DWORD PTR $T230817[ebp]
	mov	edx, DWORD PTR $T230817[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@GetFirstAr

; 168  : 	{
; 169  : 		return m_viArmyIDs[0];

	xor	edx, edx
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx+ecx]
	jmp	SHORT $LN3@GetFirstAr

; 170  : 	}
; 171  : 	else

	jmp	SHORT $LN3@GetFirstAr
$LN2@GetFirstAr:

; 172  : 	{
; 173  : 		return -1;

	or	eax, -1
$LN3@GetFirstAr:

; 174  : 	}
; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstArmyID@CvAIOperation@@QAEHXZ ENDP		; CvAIOperation::GetFirstArmyID
_TEXT	ENDS
PUBLIC	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ	; CvAIOperation::GetTargetPlot
; Function compile flags: /Odtp
;	COMDAT ?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
tv134 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T230929 = -52						; size = 4
$T230928 = -48						; size = 4
$T230883 = -44						; size = 4
$T230870 = -40						; size = 4
$T230866 = -36						; size = 4
$T230852 = -32						; size = 4
$T230848 = -25						; size = 1
$T230837 = -24						; size = 4
$T230833 = -17						; size = 1
_iMapY$230927 = -16					; size = 4
_iMapX$230926 = -12					; size = 4
$T230826 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ PROC	; CvAIOperation::GetTargetPlot, COMDAT
; _this$ = ecx

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	CvPlot* rtnValue = NULL;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 181  : 	rtnValue =  GC.getMap().plot(m_iTargetX, m_iTargetY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230826[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T230929[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR $T230928[ebp], ecx
	cmp	DWORD PTR $T230928[ebp], -2147483647	; 80000001H
	je	SHORT $LN5@GetTargetP
	cmp	DWORD PTR $T230929[ebp], -2147483647	; 80000001H
	jne	SHORT $LN6@GetTargetP
$LN5@GetTargetP:
	mov	DWORD PTR _rtnValue$[ebp], 0
	jmp	$LN7@GetTargetP
$LN6@GetTargetP:
	mov	edx, DWORD PTR $T230826[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T230833[ebp], al
	mov	ecx, DWORD PTR $T230826[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T230837[ebp], edx
	movzx	eax, BYTE PTR $T230833[ebp]
	test	eax, eax
	je	SHORT $LN18@GetTargetP
	cmp	DWORD PTR $T230928[ebp], 0
	jge	SHORT $LN17@GetTargetP
	mov	eax, DWORD PTR $T230928[ebp]
	cdq
	idiv	DWORD PTR $T230837[ebp]
	add	edx, DWORD PTR $T230837[ebp]
	mov	DWORD PTR _iMapX$230926[ebp], edx
	jmp	SHORT $LN19@GetTargetP
	jmp	SHORT $LN18@GetTargetP
$LN17@GetTargetP:
	mov	ecx, DWORD PTR $T230928[ebp]
	cmp	ecx, DWORD PTR $T230837[ebp]
	jl	SHORT $LN18@GetTargetP
	mov	eax, DWORD PTR $T230928[ebp]
	cdq
	idiv	DWORD PTR $T230837[ebp]
	mov	DWORD PTR _iMapX$230926[ebp], edx
	jmp	SHORT $LN19@GetTargetP
$LN18@GetTargetP:
	mov	edx, DWORD PTR $T230928[ebp]
	mov	DWORD PTR _iMapX$230926[ebp], edx
$LN19@GetTargetP:
	mov	eax, DWORD PTR $T230826[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T230848[ebp], cl
	mov	edx, DWORD PTR $T230826[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T230852[ebp], eax
	movzx	ecx, BYTE PTR $T230848[ebp]
	test	ecx, ecx
	je	SHORT $LN28@GetTargetP
	cmp	DWORD PTR $T230929[ebp], 0
	jge	SHORT $LN27@GetTargetP
	mov	eax, DWORD PTR $T230929[ebp]
	cdq
	idiv	DWORD PTR $T230852[ebp]
	add	edx, DWORD PTR $T230852[ebp]
	mov	DWORD PTR _iMapY$230927[ebp], edx
	jmp	SHORT $LN29@GetTargetP
	jmp	SHORT $LN28@GetTargetP
$LN27@GetTargetP:
	mov	edx, DWORD PTR $T230929[ebp]
	cmp	edx, DWORD PTR $T230852[ebp]
	jl	SHORT $LN28@GetTargetP
	mov	eax, DWORD PTR $T230929[ebp]
	cdq
	idiv	DWORD PTR $T230852[ebp]
	mov	DWORD PTR _iMapY$230927[ebp], edx
	jmp	SHORT $LN29@GetTargetP
$LN28@GetTargetP:
	mov	eax, DWORD PTR $T230929[ebp]
	mov	DWORD PTR _iMapY$230927[ebp], eax
$LN29@GetTargetP:
	cmp	DWORD PTR _iMapX$230926[ebp], 0
	jl	SHORT $LN33@GetTargetP
	mov	ecx, DWORD PTR $T230826[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T230866[ebp], edx
	mov	eax, DWORD PTR _iMapX$230926[ebp]
	cmp	eax, DWORD PTR $T230866[ebp]
	jge	SHORT $LN33@GetTargetP
	cmp	DWORD PTR _iMapY$230927[ebp], 0
	jl	SHORT $LN33@GetTargetP
	mov	ecx, DWORD PTR $T230826[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T230870[ebp], edx
	mov	eax, DWORD PTR _iMapY$230927[ebp]
	cmp	eax, DWORD PTR $T230870[ebp]
	jge	SHORT $LN33@GetTargetP
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $LN31@GetTargetP
$LN33@GetTargetP:
	mov	DWORD PTR tv149[ebp], 0
$LN31@GetTargetP:
	cmp	DWORD PTR tv149[ebp], 0
	je	SHORT $LN9@GetTargetP
	mov	ecx, DWORD PTR $T230826[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T230883[ebp], edx
	mov	eax, DWORD PTR _iMapY$230927[ebp]
	imul	eax, DWORD PTR $T230883[ebp]
	add	eax, DWORD PTR _iMapX$230926[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T230826[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN10@GetTargetP
$LN9@GetTargetP:
	mov	DWORD PTR tv134[ebp], 0
$LN10@GetTargetP:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _rtnValue$[ebp], edx
$LN7@GetTargetP:

; 182  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 183  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ENDP	; CvAIOperation::GetTargetPlot
_TEXT	ENDS
PUBLIC	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z	; CvAIOperation::SetTargetPlot
; Function compile flags: /Odtp
;	COMDAT ?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pTarget$ = 8						; size = 4
?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z PROC	; CvAIOperation::SetTargetPlot, COMDAT
; _this$ = ecx

; 187  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 	m_iTargetX = pTarget->getX();

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], ecx

; 189  : 	m_iTargetY = pTarget->getY();

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], ecx

; 190  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ENDP	; CvAIOperation::SetTargetPlot
_TEXT	ENDS
PUBLIC	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ	; CvAIOperation::GetMusterPlot
; Function compile flags: /Odtp
;	COMDAT ?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
tv134 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T231046 = -52						; size = 4
$T231045 = -48						; size = 4
$T231000 = -44						; size = 4
$T230987 = -40						; size = 4
$T230983 = -36						; size = 4
$T230969 = -32						; size = 4
$T230965 = -25						; size = 1
$T230954 = -24						; size = 4
$T230950 = -17						; size = 1
_iMapY$231044 = -16					; size = 4
_iMapX$231043 = -12					; size = 4
$T230943 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ PROC	; CvAIOperation::GetMusterPlot, COMDAT
; _this$ = ecx

; 194  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 	CvPlot* rtnValue = NULL;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 196  : 	rtnValue =  GC.getMap().plot(m_iMusterX, m_iMusterY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230943[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T231046[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231045[ebp], ecx
	cmp	DWORD PTR $T231045[ebp], -2147483647	; 80000001H
	je	SHORT $LN5@GetMusterP@2
	cmp	DWORD PTR $T231046[ebp], -2147483647	; 80000001H
	jne	SHORT $LN6@GetMusterP@2
$LN5@GetMusterP@2:
	mov	DWORD PTR _rtnValue$[ebp], 0
	jmp	$LN7@GetMusterP@2
$LN6@GetMusterP@2:
	mov	edx, DWORD PTR $T230943[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T230950[ebp], al
	mov	ecx, DWORD PTR $T230943[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T230954[ebp], edx
	movzx	eax, BYTE PTR $T230950[ebp]
	test	eax, eax
	je	SHORT $LN18@GetMusterP@2
	cmp	DWORD PTR $T231045[ebp], 0
	jge	SHORT $LN17@GetMusterP@2
	mov	eax, DWORD PTR $T231045[ebp]
	cdq
	idiv	DWORD PTR $T230954[ebp]
	add	edx, DWORD PTR $T230954[ebp]
	mov	DWORD PTR _iMapX$231043[ebp], edx
	jmp	SHORT $LN19@GetMusterP@2
	jmp	SHORT $LN18@GetMusterP@2
$LN17@GetMusterP@2:
	mov	ecx, DWORD PTR $T231045[ebp]
	cmp	ecx, DWORD PTR $T230954[ebp]
	jl	SHORT $LN18@GetMusterP@2
	mov	eax, DWORD PTR $T231045[ebp]
	cdq
	idiv	DWORD PTR $T230954[ebp]
	mov	DWORD PTR _iMapX$231043[ebp], edx
	jmp	SHORT $LN19@GetMusterP@2
$LN18@GetMusterP@2:
	mov	edx, DWORD PTR $T231045[ebp]
	mov	DWORD PTR _iMapX$231043[ebp], edx
$LN19@GetMusterP@2:
	mov	eax, DWORD PTR $T230943[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T230965[ebp], cl
	mov	edx, DWORD PTR $T230943[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T230969[ebp], eax
	movzx	ecx, BYTE PTR $T230965[ebp]
	test	ecx, ecx
	je	SHORT $LN28@GetMusterP@2
	cmp	DWORD PTR $T231046[ebp], 0
	jge	SHORT $LN27@GetMusterP@2
	mov	eax, DWORD PTR $T231046[ebp]
	cdq
	idiv	DWORD PTR $T230969[ebp]
	add	edx, DWORD PTR $T230969[ebp]
	mov	DWORD PTR _iMapY$231044[ebp], edx
	jmp	SHORT $LN29@GetMusterP@2
	jmp	SHORT $LN28@GetMusterP@2
$LN27@GetMusterP@2:
	mov	edx, DWORD PTR $T231046[ebp]
	cmp	edx, DWORD PTR $T230969[ebp]
	jl	SHORT $LN28@GetMusterP@2
	mov	eax, DWORD PTR $T231046[ebp]
	cdq
	idiv	DWORD PTR $T230969[ebp]
	mov	DWORD PTR _iMapY$231044[ebp], edx
	jmp	SHORT $LN29@GetMusterP@2
$LN28@GetMusterP@2:
	mov	eax, DWORD PTR $T231046[ebp]
	mov	DWORD PTR _iMapY$231044[ebp], eax
$LN29@GetMusterP@2:
	cmp	DWORD PTR _iMapX$231043[ebp], 0
	jl	SHORT $LN33@GetMusterP@2
	mov	ecx, DWORD PTR $T230943[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T230983[ebp], edx
	mov	eax, DWORD PTR _iMapX$231043[ebp]
	cmp	eax, DWORD PTR $T230983[ebp]
	jge	SHORT $LN33@GetMusterP@2
	cmp	DWORD PTR _iMapY$231044[ebp], 0
	jl	SHORT $LN33@GetMusterP@2
	mov	ecx, DWORD PTR $T230943[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T230987[ebp], edx
	mov	eax, DWORD PTR _iMapY$231044[ebp]
	cmp	eax, DWORD PTR $T230987[ebp]
	jge	SHORT $LN33@GetMusterP@2
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $LN31@GetMusterP@2
$LN33@GetMusterP@2:
	mov	DWORD PTR tv149[ebp], 0
$LN31@GetMusterP@2:
	cmp	DWORD PTR tv149[ebp], 0
	je	SHORT $LN9@GetMusterP@2
	mov	ecx, DWORD PTR $T230943[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231000[ebp], edx
	mov	eax, DWORD PTR _iMapY$231044[ebp]
	imul	eax, DWORD PTR $T231000[ebp]
	add	eax, DWORD PTR _iMapX$231043[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T230943[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN10@GetMusterP@2
$LN9@GetMusterP@2:
	mov	DWORD PTR tv134[ebp], 0
$LN10@GetMusterP@2:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _rtnValue$[ebp], edx
$LN7@GetMusterP@2:

; 197  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 198  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ENDP	; CvAIOperation::GetMusterPlot
_TEXT	ENDS
PUBLIC	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z	; CvAIOperation::SetMusterPlot
; Function compile flags: /Odtp
;	COMDAT ?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pMuster$ = 8						; size = 4
?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z PROC	; CvAIOperation::SetMusterPlot, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	m_iMusterX = pMuster->getX();

	mov	eax, DWORD PTR _pMuster$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], ecx

; 204  : 	m_iMusterY = pMuster->getY();

	mov	eax, DWORD PTR _pMuster$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 205  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ENDP	; CvAIOperation::SetMusterPlot
_TEXT	ENDS
PUBLIC	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
; Function compile flags: /Odtp
;	COMDAT ?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
tv134 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T231163 = -52						; size = 4
$T231162 = -48						; size = 4
$T231117 = -44						; size = 4
$T231104 = -40						; size = 4
$T231100 = -36						; size = 4
$T231086 = -32						; size = 4
$T231082 = -25						; size = 1
$T231071 = -24						; size = 4
$T231067 = -17						; size = 1
_iMapY$231161 = -16					; size = 4
_iMapX$231160 = -12					; size = 4
$T231060 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ PROC	; CvAIOperation::GetStartCityPlot, COMDAT
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 	CvPlot* rtnValue = NULL;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 211  : 	rtnValue =  GC.getMap().plot(m_iStartCityX, m_iStartCityY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231060[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR $T231163[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T231162[ebp], ecx
	cmp	DWORD PTR $T231162[ebp], -2147483647	; 80000001H
	je	SHORT $LN5@GetStartCi
	cmp	DWORD PTR $T231163[ebp], -2147483647	; 80000001H
	jne	SHORT $LN6@GetStartCi
$LN5@GetStartCi:
	mov	DWORD PTR _rtnValue$[ebp], 0
	jmp	$LN7@GetStartCi
$LN6@GetStartCi:
	mov	edx, DWORD PTR $T231060[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T231067[ebp], al
	mov	ecx, DWORD PTR $T231060[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231071[ebp], edx
	movzx	eax, BYTE PTR $T231067[ebp]
	test	eax, eax
	je	SHORT $LN18@GetStartCi
	cmp	DWORD PTR $T231162[ebp], 0
	jge	SHORT $LN17@GetStartCi
	mov	eax, DWORD PTR $T231162[ebp]
	cdq
	idiv	DWORD PTR $T231071[ebp]
	add	edx, DWORD PTR $T231071[ebp]
	mov	DWORD PTR _iMapX$231160[ebp], edx
	jmp	SHORT $LN19@GetStartCi
	jmp	SHORT $LN18@GetStartCi
$LN17@GetStartCi:
	mov	ecx, DWORD PTR $T231162[ebp]
	cmp	ecx, DWORD PTR $T231071[ebp]
	jl	SHORT $LN18@GetStartCi
	mov	eax, DWORD PTR $T231162[ebp]
	cdq
	idiv	DWORD PTR $T231071[ebp]
	mov	DWORD PTR _iMapX$231160[ebp], edx
	jmp	SHORT $LN19@GetStartCi
$LN18@GetStartCi:
	mov	edx, DWORD PTR $T231162[ebp]
	mov	DWORD PTR _iMapX$231160[ebp], edx
$LN19@GetStartCi:
	mov	eax, DWORD PTR $T231060[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T231082[ebp], cl
	mov	edx, DWORD PTR $T231060[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T231086[ebp], eax
	movzx	ecx, BYTE PTR $T231082[ebp]
	test	ecx, ecx
	je	SHORT $LN28@GetStartCi
	cmp	DWORD PTR $T231163[ebp], 0
	jge	SHORT $LN27@GetStartCi
	mov	eax, DWORD PTR $T231163[ebp]
	cdq
	idiv	DWORD PTR $T231086[ebp]
	add	edx, DWORD PTR $T231086[ebp]
	mov	DWORD PTR _iMapY$231161[ebp], edx
	jmp	SHORT $LN29@GetStartCi
	jmp	SHORT $LN28@GetStartCi
$LN27@GetStartCi:
	mov	edx, DWORD PTR $T231163[ebp]
	cmp	edx, DWORD PTR $T231086[ebp]
	jl	SHORT $LN28@GetStartCi
	mov	eax, DWORD PTR $T231163[ebp]
	cdq
	idiv	DWORD PTR $T231086[ebp]
	mov	DWORD PTR _iMapY$231161[ebp], edx
	jmp	SHORT $LN29@GetStartCi
$LN28@GetStartCi:
	mov	eax, DWORD PTR $T231163[ebp]
	mov	DWORD PTR _iMapY$231161[ebp], eax
$LN29@GetStartCi:
	cmp	DWORD PTR _iMapX$231160[ebp], 0
	jl	SHORT $LN33@GetStartCi
	mov	ecx, DWORD PTR $T231060[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231100[ebp], edx
	mov	eax, DWORD PTR _iMapX$231160[ebp]
	cmp	eax, DWORD PTR $T231100[ebp]
	jge	SHORT $LN33@GetStartCi
	cmp	DWORD PTR _iMapY$231161[ebp], 0
	jl	SHORT $LN33@GetStartCi
	mov	ecx, DWORD PTR $T231060[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231104[ebp], edx
	mov	eax, DWORD PTR _iMapY$231161[ebp]
	cmp	eax, DWORD PTR $T231104[ebp]
	jge	SHORT $LN33@GetStartCi
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $LN31@GetStartCi
$LN33@GetStartCi:
	mov	DWORD PTR tv149[ebp], 0
$LN31@GetStartCi:
	cmp	DWORD PTR tv149[ebp], 0
	je	SHORT $LN9@GetStartCi
	mov	ecx, DWORD PTR $T231060[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231117[ebp], edx
	mov	eax, DWORD PTR _iMapY$231161[ebp]
	imul	eax, DWORD PTR $T231117[ebp]
	add	eax, DWORD PTR _iMapX$231160[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T231060[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN10@GetStartCi
$LN9@GetStartCi:
	mov	DWORD PTR tv134[ebp], 0
$LN10@GetStartCi:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _rtnValue$[ebp], edx
$LN7@GetStartCi:

; 212  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 213  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ENDP	; CvAIOperation::GetStartCityPlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pStartCity$ = 8					; size = 4
?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z PROC	; CvAIOperation::SetStartCityPlot, COMDAT
; _this$ = ecx

; 217  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 218  : 	m_iStartCityX = pStartCity->getX();

	mov	eax, DWORD PTR _pStartCity$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx

; 219  : 	m_iStartCityY = pStartCity->getY();

	mov	eax, DWORD PTR _pStartCity$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], ecx

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ENDP	; CvAIOperation::SetStartCityPlot
_TEXT	ENDS
PUBLIC	?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z ; OperationalAIHelpers::GetGatherRangeForXUnits
EXTRN	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ:PROC		; CvArmyAI::IsAllOceanGoing
EXTRN	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z:PROC ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
EXTRN	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetNumSlotsFilled
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
; Function compile flags: /Odtp
;	COMDAT ?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T231194 = -56						; size = 4
$T231189 = -52						; size = 4
$T231185 = -48						; size = 4
$T231181 = -44						; size = 4
$T231177 = -40						; size = 4
_iPlotIndex$222890 = -36				; size = 4
_iY$222886 = -32					; size = 4
_iX$222882 = -28					; size = 4
_iRange$222881 = -24					; size = 4
_iNumUnits$ = -20					; size = 4
_iRtnValue$ = -16					; size = 4
_pMap$ = -12						; size = 4
_pCell$ = -8						; size = 4
_iValidPlotsNearby$ = -4				; size = 4
_pArmy$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z PROC ; CvAIOperation::GetGatherTolerance, COMDAT
; _this$ = ecx

; 223  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 	CvTacticalAnalysisCell* pCell;
; 225  : 	CvTacticalAnalysisMap* pMap = GC.getGame().GetTacticalAnalysisMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231177[ebp], eax
	mov	ecx, DWORD PTR $T231177[ebp]
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	DWORD PTR _pMap$[ebp], eax

; 226  : 	int iRtnValue = 1;

	mov	DWORD PTR _iRtnValue$[ebp], 1

; 227  : 	int iValidPlotsNearby = 0;

	mov	DWORD PTR _iValidPlotsNearby$[ebp], 0

; 228  : 
; 229  : 	// Find out how many units are trying to gather
; 230  : 	int iNumUnits = pArmy->GetNumSlotsFilled();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	mov	DWORD PTR _iNumUnits$[ebp], eax

; 231  : 
; 232  : 	// If not more than 1, zero tolerance is fine (we should get the unit to the gather point)
; 233  : 	if(iNumUnits < 1)

	cmp	DWORD PTR _iNumUnits$[ebp], 1
	jge	SHORT $LN14@GetGatherT

; 234  : 	{
; 235  : 		iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 236  : 	}
; 237  : 	else

	jmp	$LN13@GetGatherT
$LN14@GetGatherT:

; 238  : 	{
; 239  : 		int iRange = OperationalAIHelpers::GetGatherRangeForXUnits(iNumUnits);

	mov	ecx, DWORD PTR _iNumUnits$[ebp]
	push	ecx
	call	?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z ; OperationalAIHelpers::GetGatherRangeForXUnits
	add	esp, 4
	mov	DWORD PTR _iRange$222881[ebp], eax

; 240  : 		for(int iX = -iRange; iX <= iRange; iX++)

	mov	edx, DWORD PTR _iRange$222881[ebp]
	neg	edx
	mov	DWORD PTR _iX$222882[ebp], edx
	jmp	SHORT $LN12@GetGatherT
$LN11@GetGatherT:
	mov	eax, DWORD PTR _iX$222882[ebp]
	add	eax, 1
	mov	DWORD PTR _iX$222882[ebp], eax
$LN12@GetGatherT:
	mov	ecx, DWORD PTR _iX$222882[ebp]
	cmp	ecx, DWORD PTR _iRange$222881[ebp]
	jg	$LN10@GetGatherT

; 241  : 		{
; 242  : 			for(int iY = -iRange; iY <= iRange; iY++)

	mov	edx, DWORD PTR _iRange$222881[ebp]
	neg	edx
	mov	DWORD PTR _iY$222886[ebp], edx
	jmp	SHORT $LN9@GetGatherT
$LN8@GetGatherT:
	mov	eax, DWORD PTR _iY$222886[ebp]
	add	eax, 1
	mov	DWORD PTR _iY$222886[ebp], eax
$LN9@GetGatherT:
	mov	ecx, DWORD PTR _iY$222886[ebp]
	cmp	ecx, DWORD PTR _iRange$222881[ebp]
	jg	$LN7@GetGatherT

; 243  : 			{
; 244  : 				int iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T231181[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T231185[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231189[ebp], eax
	mov	ecx, DWORD PTR $T231189[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T231194[ebp], edx
	mov	eax, DWORD PTR $T231181[ebp]
	imul	eax, DWORD PTR $T231194[ebp]
	add	eax, DWORD PTR $T231185[ebp]
	mov	DWORD PTR _iPlotIndex$222890[ebp], eax

; 245  : 				pCell = pMap->GetCell(iPlotIndex);

	mov	ecx, DWORD PTR _iPlotIndex$222890[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _pMap$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _pCell$[ebp], ecx

; 246  : 
; 247  : 				if((IsMixedLandNavalOperation() || IsAllNavalOperation()) && !pCell->CanUseForOperationGatheringCheckWater(true))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@GetGatherT
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@GetGatherT
$LN5@GetGatherT:
	push	1
	mov	ecx, DWORD PTR _pCell$[ebp]
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@GetGatherT

; 248  : 				{
; 249  : 					continue;

	jmp	$LN8@GetGatherT
$LN6@GetGatherT:

; 250  : 				}
; 251  : 
; 252  : 				if((IsMixedLandNavalOperation() || IsAllNavalOperation()) && !pArmy->IsAllOceanGoing() && pCell->IsOcean())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@GetGatherT
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@GetGatherT
$LN3@GetGatherT:
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ	; CvArmyAI::IsAllOceanGoing
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@GetGatherT
	mov	eax, DWORD PTR _pCell$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4096				; 00001000H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@GetGatherT

; 253  : 				{
; 254  : 					continue;

	jmp	$LN8@GetGatherT
$LN4@GetGatherT:

; 255  : 				}
; 256  : 
; 257  : 				iValidPlotsNearby++;

	mov	eax, DWORD PTR _iValidPlotsNearby$[ebp]
	add	eax, 1
	mov	DWORD PTR _iValidPlotsNearby$[ebp], eax

; 258  : 			}

	jmp	$LN8@GetGatherT
$LN7@GetGatherT:

; 259  : 		}

	jmp	$LN11@GetGatherT
$LN10@GetGatherT:

; 260  : 
; 261  : 		// Find more valid plots than units?
; 262  : 		if(iValidPlotsNearby > iNumUnits)

	mov	ecx, DWORD PTR _iValidPlotsNearby$[ebp]
	cmp	ecx, DWORD PTR _iNumUnits$[ebp]
	jle	SHORT $LN2@GetGatherT

; 263  : 		{
; 264  : 			// If so, just use normal range for this many units
; 265  : 			iRtnValue = iRange;

	mov	edx, DWORD PTR _iRange$222881[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], edx

; 266  : 		}
; 267  : 
; 268  : 		// Something constrained here, give ourselves a lot of leeway
; 269  : 		else

	jmp	SHORT $LN13@GetGatherT
$LN2@GetGatherT:

; 270  : 		{
; 271  : 			iRtnValue = 3;

	mov	DWORD PTR _iRtnValue$[ebp], 3
$LN13@GetGatherT:

; 272  : 		}
; 273  : 	}
; 274  : 
; 275  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 276  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z ENDP ; CvAIOperation::GetGatherTolerance
_TEXT	ENDS
PUBLIC	??0CvAIOperationNukeAttack@@QAE@XZ		; CvAIOperationNukeAttack::CvAIOperationNukeAttack
PUBLIC	??0CvAIOperationNavalCityStateAttack@@QAE@XZ	; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack
PUBLIC	??0CvAIOperationNavalSneakAttack@@QAE@XZ	; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack
PUBLIC	??0CvAIOperationNavalAttack@@QAE@XZ		; CvAIOperationNavalAttack::CvAIOperationNavalAttack
PUBLIC	??0CvAIOperationCityStateAttack@@QAE@XZ		; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack
PUBLIC	??0CvAIOperationSmallCityAttack@@QAE@XZ		; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack
PUBLIC	??0CvAIOperationSneakCityAttack@@QAE@XZ		; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack
PUBLIC	??0CvAIOperationQuickSneakCityAttack@@QAE@XZ	; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack
PUBLIC	??0CvAIOperationRapidResponse@@QAE@XZ		; CvAIOperationRapidResponse::CvAIOperationRapidResponse
PUBLIC	??0CvAIOperationCityCloseDefense@@QAE@XZ	; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense
PUBLIC	??0CvAIOperationPillageEnemy@@QAE@XZ		; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy
PUBLIC	??0CvAIOperationQuickColonize@@QAE@XZ		; CvAIOperationQuickColonize::CvAIOperationQuickColonize
PUBLIC	??0CvAINavalEscortedOperation@@QAE@XZ		; CvAINavalEscortedOperation::CvAINavalEscortedOperation
PUBLIC	??0CvAIOperationPureNavalCityAttack@@QAE@XZ	; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack
PUBLIC	??0CvAIOperationNavalSuperiority@@QAE@XZ	; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority
PUBLIC	??0CvAIOperationNavalBombardment@@QAE@XZ	; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment
PUBLIC	??0CvAIOperationConcertTour@@QAE@XZ		; CvAIOperationConcertTour::CvAIOperationConcertTour
PUBLIC	??0CvAIOperationMerchantDelegation@@QAE@XZ	; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation
PUBLIC	??0CvAIOperationFoundCity@@QAE@XZ		; CvAIOperationFoundCity::CvAIOperationFoundCity
PUBLIC	??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ	; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp
PUBLIC	??0CvAIOperationBasicCityAttack@@QAE@XZ		; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
PUBLIC	?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z ; CvAIOperation::CreateOperation
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
xdata$x	SEGMENT
__ehfuncinfo$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$20
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv375 = -276						; size = 4
tv364 = -272						; size = 4
tv353 = -268						; size = 4
tv342 = -264						; size = 4
tv331 = -260						; size = 4
tv320 = -256						; size = 4
tv277 = -252						; size = 4
tv266 = -248						; size = 4
tv239 = -244						; size = 4
tv228 = -240						; size = 4
tv217 = -236						; size = 4
tv206 = -232						; size = 4
tv195 = -228						; size = 4
tv184 = -224						; size = 4
tv173 = -220						; size = 4
tv162 = -216						; size = 4
tv151 = -212						; size = 4
tv140 = -208						; size = 4
tv129 = -204						; size = 4
tv86 = -200						; size = 4
tv75 = -196						; size = 4
tv64 = -192						; size = 4
$T231324 = -188						; size = 4
$T231320 = -184						; size = 4
$T231293 = -180						; size = 4
$T231292 = -176						; size = 4
$T231289 = -172						; size = 4
$T231288 = -168						; size = 4
$T231285 = -164						; size = 4
$T231284 = -160						; size = 4
$T231281 = -156						; size = 4
$T231280 = -152						; size = 4
$T231277 = -148						; size = 4
$T231276 = -144						; size = 4
$T231273 = -140						; size = 4
$T231272 = -136						; size = 4
$T231269 = -132						; size = 4
$T231268 = -128						; size = 4
$T231265 = -124						; size = 4
$T231264 = -120						; size = 4
$T231261 = -116						; size = 4
$T231260 = -112						; size = 4
$T231257 = -108						; size = 4
$T231256 = -104						; size = 4
$T231253 = -100						; size = 4
$T231252 = -96						; size = 4
$T231249 = -92						; size = 4
$T231248 = -88						; size = 4
$T231245 = -84						; size = 4
$T231244 = -80						; size = 4
$T231241 = -76						; size = 4
$T231240 = -72						; size = 4
$T231237 = -68						; size = 4
$T231236 = -64						; size = 4
$T231233 = -60						; size = 4
$T231232 = -56						; size = 4
$T231229 = -52						; size = 4
$T231228 = -48						; size = 4
$T231225 = -44						; size = 4
$T231224 = -40						; size = 4
$T231221 = -36						; size = 4
$T231220 = -32						; size = 4
$T231217 = -28						; size = 4
$T231216 = -24						; size = 4
$T231213 = -20						; size = 4
$T231212 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eAIOperationType$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z PROC ; CvAIOperation::CreateOperation, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 281  : 	switch(eAIOperationType)

	mov	eax, DWORD PTR _eAIOperationType$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 19			; 00000013H
	ja	$LN22@CreateOper
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN94@CreateOper[ecx*4]
$LN21@CreateOper:

; 282  : 	{
; 283  : 	case AI_OPERATION_BASIC_CITY_ATTACK:
; 284  : 		return FNEW(CvAIOperationBasicCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231213[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T231213[ebp], 0
	je	SHORT $LN26@CreateOper
	mov	ecx, DWORD PTR $T231213[ebp]
	call	??0CvAIOperationBasicCityAttack@@QAE@XZ	; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN27@CreateOper
$LN26@CreateOper:
	mov	DWORD PTR tv75[ebp], 0
$LN27@CreateOper:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T231212[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231212[ebp]
	jmp	$LN24@CreateOper
$LN20@CreateOper:

; 285  : 	case AI_OPERATION_DESTROY_BARBARIAN_CAMP:
; 286  : 		return FNEW(CvAIOperationDestroyBarbarianCamp(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231217[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T231217[ebp], 0
	je	SHORT $LN28@CreateOper
	mov	ecx, DWORD PTR $T231217[ebp]
	call	??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ ; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN29@CreateOper
$LN28@CreateOper:
	mov	DWORD PTR tv86[ebp], 0
$LN29@CreateOper:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T231216[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231216[ebp]
	jmp	$LN24@CreateOper
$LN19@CreateOper:

; 287  : 	case AI_OPERATION_FOUND_CITY:
; 288  : 		return FNEW(CvAIOperationFoundCity(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231221[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T231221[ebp], 0
	je	SHORT $LN30@CreateOper
	mov	ecx, DWORD PTR $T231221[ebp]
	call	??0CvAIOperationFoundCity@@QAE@XZ	; CvAIOperationFoundCity::CvAIOperationFoundCity
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN31@CreateOper
$LN30@CreateOper:
	mov	DWORD PTR tv129[ebp], 0
$LN31@CreateOper:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T231220[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231220[ebp]
	jmp	$LN24@CreateOper
$LN18@CreateOper:

; 289  : 	case AI_OPERATION_MERCHANT_DELEGATION:
; 290  : 		return FNEW(CvAIOperationMerchantDelegation(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231225[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T231225[ebp], 0
	je	SHORT $LN32@CreateOper
	mov	ecx, DWORD PTR $T231225[ebp]
	call	??0CvAIOperationMerchantDelegation@@QAE@XZ ; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN33@CreateOper
$LN32@CreateOper:
	mov	DWORD PTR tv140[ebp], 0
$LN33@CreateOper:
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR $T231224[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231224[ebp]
	jmp	$LN24@CreateOper
$LN17@CreateOper:

; 291  : 	case AI_OPERATION_CONCERT_TOUR:
; 292  : 		return FNEW(CvAIOperationConcertTour(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231229[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T231229[ebp], 0
	je	SHORT $LN34@CreateOper
	mov	ecx, DWORD PTR $T231229[ebp]
	call	??0CvAIOperationConcertTour@@QAE@XZ	; CvAIOperationConcertTour::CvAIOperationConcertTour
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN35@CreateOper
$LN34@CreateOper:
	mov	DWORD PTR tv151[ebp], 0
$LN35@CreateOper:
	mov	eax, DWORD PTR tv151[ebp]
	mov	DWORD PTR $T231228[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231228[ebp]
	jmp	$LN24@CreateOper
$LN16@CreateOper:

; 293  : 	case AI_OPERATION_NAVAL_BOMBARDMENT:
; 294  : 		return FNEW(CvAIOperationNavalBombardment(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231233[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR $T231233[ebp], 0
	je	SHORT $LN36@CreateOper
	mov	ecx, DWORD PTR $T231233[ebp]
	call	??0CvAIOperationNavalBombardment@@QAE@XZ ; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN37@CreateOper
$LN36@CreateOper:
	mov	DWORD PTR tv162[ebp], 0
$LN37@CreateOper:
	mov	ecx, DWORD PTR tv162[ebp]
	mov	DWORD PTR $T231232[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231232[ebp]
	jmp	$LN24@CreateOper
$LN15@CreateOper:

; 295  : 	case AI_OPERATION_NAVAL_SUPERIORITY:
; 296  : 		return FNEW(CvAIOperationNavalSuperiority(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231237[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	cmp	DWORD PTR $T231237[ebp], 0
	je	SHORT $LN38@CreateOper
	mov	ecx, DWORD PTR $T231237[ebp]
	call	??0CvAIOperationNavalSuperiority@@QAE@XZ ; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority
	mov	DWORD PTR tv173[ebp], eax
	jmp	SHORT $LN39@CreateOper
$LN38@CreateOper:
	mov	DWORD PTR tv173[ebp], 0
$LN39@CreateOper:
	mov	edx, DWORD PTR tv173[ebp]
	mov	DWORD PTR $T231236[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231236[ebp]
	jmp	$LN24@CreateOper
$LN14@CreateOper:

; 297  : 	case AI_OPERATION_PURE_NAVAL_CITY_ATTACK:
; 298  : 		return FNEW(CvAIOperationPureNavalCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231241[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T231241[ebp], 0
	je	SHORT $LN40@CreateOper
	mov	ecx, DWORD PTR $T231241[ebp]
	call	??0CvAIOperationPureNavalCityAttack@@QAE@XZ ; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack
	mov	DWORD PTR tv184[ebp], eax
	jmp	SHORT $LN41@CreateOper
$LN40@CreateOper:
	mov	DWORD PTR tv184[ebp], 0
$LN41@CreateOper:
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR $T231240[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231240[ebp]
	jmp	$LN24@CreateOper
$LN13@CreateOper:

; 299  : 	case AI_OPERATION_COLONIZE:
; 300  : 		return FNEW(CvAINavalEscortedOperation(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231245[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	cmp	DWORD PTR $T231245[ebp], 0
	je	SHORT $LN42@CreateOper
	mov	ecx, DWORD PTR $T231245[ebp]
	call	??0CvAINavalEscortedOperation@@QAE@XZ	; CvAINavalEscortedOperation::CvAINavalEscortedOperation
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN43@CreateOper
$LN42@CreateOper:
	mov	DWORD PTR tv195[ebp], 0
$LN43@CreateOper:
	mov	ecx, DWORD PTR tv195[ebp]
	mov	DWORD PTR $T231244[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231244[ebp]
	jmp	$LN24@CreateOper
$LN12@CreateOper:

; 301  : 	case AI_OPERATION_QUICK_COLONIZE:
; 302  : 		return FNEW(CvAIOperationQuickColonize(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231249[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	cmp	DWORD PTR $T231249[ebp], 0
	je	SHORT $LN44@CreateOper
	mov	ecx, DWORD PTR $T231249[ebp]
	call	??0CvAIOperationQuickColonize@@QAE@XZ	; CvAIOperationQuickColonize::CvAIOperationQuickColonize
	mov	DWORD PTR tv206[ebp], eax
	jmp	SHORT $LN45@CreateOper
$LN44@CreateOper:
	mov	DWORD PTR tv206[ebp], 0
$LN45@CreateOper:
	mov	edx, DWORD PTR tv206[ebp]
	mov	DWORD PTR $T231248[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231248[ebp]
	jmp	$LN24@CreateOper
$LN11@CreateOper:

; 303  : 	case AI_OPERATION_PILLAGE_ENEMY:
; 304  : 		return FNEW(CvAIOperationPillageEnemy(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231253[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T231253[ebp], 0
	je	SHORT $LN46@CreateOper
	mov	ecx, DWORD PTR $T231253[ebp]
	call	??0CvAIOperationPillageEnemy@@QAE@XZ	; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy
	mov	DWORD PTR tv217[ebp], eax
	jmp	SHORT $LN47@CreateOper
$LN46@CreateOper:
	mov	DWORD PTR tv217[ebp], 0
$LN47@CreateOper:
	mov	eax, DWORD PTR tv217[ebp]
	mov	DWORD PTR $T231252[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231252[ebp]
	jmp	$LN24@CreateOper
$LN10@CreateOper:

; 305  : 	case AI_OPERATION_CITY_CLOSE_DEFENSE:
; 306  : 		return FNEW(CvAIOperationCityCloseDefense(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231257[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T231257[ebp], 0
	je	SHORT $LN48@CreateOper
	mov	ecx, DWORD PTR $T231257[ebp]
	call	??0CvAIOperationCityCloseDefense@@QAE@XZ ; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN49@CreateOper
$LN48@CreateOper:
	mov	DWORD PTR tv228[ebp], 0
$LN49@CreateOper:
	mov	ecx, DWORD PTR tv228[ebp]
	mov	DWORD PTR $T231256[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231256[ebp]
	jmp	$LN24@CreateOper
$LN9@CreateOper:

; 307  : 	case AI_OPERATION_RAPID_RESPONSE:
; 308  : 		return FNEW(CvAIOperationRapidResponse(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231261[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	cmp	DWORD PTR $T231261[ebp], 0
	je	SHORT $LN50@CreateOper
	mov	ecx, DWORD PTR $T231261[ebp]
	call	??0CvAIOperationRapidResponse@@QAE@XZ	; CvAIOperationRapidResponse::CvAIOperationRapidResponse
	mov	DWORD PTR tv239[ebp], eax
	jmp	SHORT $LN51@CreateOper
$LN50@CreateOper:
	mov	DWORD PTR tv239[ebp], 0
$LN51@CreateOper:
	mov	edx, DWORD PTR tv239[ebp]
	mov	DWORD PTR $T231260[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231260[ebp]
	jmp	$LN24@CreateOper
$LN8@CreateOper:

; 309  : 	case AI_OPERATION_SNEAK_CITY_ATTACK:
; 310  : 	{
; 311  : 		if(GC.getGame().getGameTurn() < 50 && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() >= 5)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T231320[ebp], eax
	mov	ecx, DWORD PTR $T231320[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN7@CreateOper
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231324[ebp], ecx
	mov	ecx, DWORD PTR $T231324[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	cmp	eax, 5
	jl	SHORT $LN7@CreateOper

; 312  : 		{
; 313  : 			return FNEW(CvAIOperationQuickSneakCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231265[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T231265[ebp], 0
	je	SHORT $LN52@CreateOper
	mov	ecx, DWORD PTR $T231265[ebp]
	call	??0CvAIOperationQuickSneakCityAttack@@QAE@XZ ; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack
	mov	DWORD PTR tv266[ebp], eax
	jmp	SHORT $LN53@CreateOper
$LN52@CreateOper:
	mov	DWORD PTR tv266[ebp], 0
$LN53@CreateOper:
	mov	edx, DWORD PTR tv266[ebp]
	mov	DWORD PTR $T231264[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231264[ebp]
	jmp	$LN24@CreateOper
$LN7@CreateOper:

; 314  : 		}
; 315  : 		return FNEW(CvAIOperationSneakCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231269[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	cmp	DWORD PTR $T231269[ebp], 0
	je	SHORT $LN54@CreateOper
	mov	ecx, DWORD PTR $T231269[ebp]
	call	??0CvAIOperationSneakCityAttack@@QAE@XZ	; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN55@CreateOper
$LN54@CreateOper:
	mov	DWORD PTR tv277[ebp], 0
$LN55@CreateOper:
	mov	eax, DWORD PTR tv277[ebp]
	mov	DWORD PTR $T231268[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231268[ebp]
	jmp	$LN24@CreateOper
$LN6@CreateOper:

; 316  : 	}
; 317  : 	case AI_OPERATION_SMALL_CITY_ATTACK:
; 318  : 		return FNEW(CvAIOperationSmallCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231273[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	cmp	DWORD PTR $T231273[ebp], 0
	je	SHORT $LN56@CreateOper
	mov	ecx, DWORD PTR $T231273[ebp]
	call	??0CvAIOperationSmallCityAttack@@QAE@XZ	; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack
	mov	DWORD PTR tv320[ebp], eax
	jmp	SHORT $LN57@CreateOper
$LN56@CreateOper:
	mov	DWORD PTR tv320[ebp], 0
$LN57@CreateOper:
	mov	ecx, DWORD PTR tv320[ebp]
	mov	DWORD PTR $T231272[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231272[ebp]
	jmp	$LN24@CreateOper
$LN5@CreateOper:

; 319  : 	case AI_OPERATION_CITY_STATE_ATTACK:
; 320  : 		return FNEW(CvAIOperationCityStateAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231277[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	cmp	DWORD PTR $T231277[ebp], 0
	je	SHORT $LN58@CreateOper
	mov	ecx, DWORD PTR $T231277[ebp]
	call	??0CvAIOperationCityStateAttack@@QAE@XZ	; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack
	mov	DWORD PTR tv331[ebp], eax
	jmp	SHORT $LN59@CreateOper
$LN58@CreateOper:
	mov	DWORD PTR tv331[ebp], 0
$LN59@CreateOper:
	mov	edx, DWORD PTR tv331[ebp]
	mov	DWORD PTR $T231276[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231276[ebp]
	jmp	$LN24@CreateOper
$LN4@CreateOper:

; 321  : 	case AI_OPERATION_NAVAL_ATTACK:
; 322  : 		return FNEW(CvAIOperationNavalAttack(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231281[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	cmp	DWORD PTR $T231281[ebp], 0
	je	SHORT $LN60@CreateOper
	mov	ecx, DWORD PTR $T231281[ebp]
	call	??0CvAIOperationNavalAttack@@QAE@XZ	; CvAIOperationNavalAttack::CvAIOperationNavalAttack
	mov	DWORD PTR tv342[ebp], eax
	jmp	SHORT $LN61@CreateOper
$LN60@CreateOper:
	mov	DWORD PTR tv342[ebp], 0
$LN61@CreateOper:
	mov	eax, DWORD PTR tv342[ebp]
	mov	DWORD PTR $T231280[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231280[ebp]
	jmp	$LN24@CreateOper
$LN3@CreateOper:

; 323  : 	case AI_OPERATION_NAVAL_SNEAK_ATTACK:
; 324  : 		return FNEW(CvAIOperationNavalSneakAttack(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231285[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	cmp	DWORD PTR $T231285[ebp], 0
	je	SHORT $LN62@CreateOper
	mov	ecx, DWORD PTR $T231285[ebp]
	call	??0CvAIOperationNavalSneakAttack@@QAE@XZ ; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack
	mov	DWORD PTR tv353[ebp], eax
	jmp	SHORT $LN63@CreateOper
$LN62@CreateOper:
	mov	DWORD PTR tv353[ebp], 0
$LN63@CreateOper:
	mov	ecx, DWORD PTR tv353[ebp]
	mov	DWORD PTR $T231284[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231284[ebp]
	jmp	$LN24@CreateOper
$LN2@CreateOper:

; 325  : 	case AI_OPERATION_CITY_STATE_NAVAL_ATTACK:
; 326  : 		return FNEW(CvAIOperationNavalCityStateAttack(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231289[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 19		; 00000013H
	cmp	DWORD PTR $T231289[ebp], 0
	je	SHORT $LN64@CreateOper
	mov	ecx, DWORD PTR $T231289[ebp]
	call	??0CvAIOperationNavalCityStateAttack@@QAE@XZ ; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack
	mov	DWORD PTR tv364[ebp], eax
	jmp	SHORT $LN65@CreateOper
$LN64@CreateOper:
	mov	DWORD PTR tv364[ebp], 0
$LN65@CreateOper:
	mov	edx, DWORD PTR tv364[ebp]
	mov	DWORD PTR $T231288[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231288[ebp]
	jmp	SHORT $LN24@CreateOper
$LN1@CreateOper:

; 327  : 	case AI_OPERATION_NUKE_ATTACK:
; 328  : 		return FNEW(CvAIOperationNukeAttack(), c_eCiv5GameplayDLL, 0);

	push	116					; 00000074H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T231293[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	cmp	DWORD PTR $T231293[ebp], 0
	je	SHORT $LN66@CreateOper
	mov	ecx, DWORD PTR $T231293[ebp]
	call	??0CvAIOperationNukeAttack@@QAE@XZ	; CvAIOperationNukeAttack::CvAIOperationNukeAttack
	mov	DWORD PTR tv375[ebp], eax
	jmp	SHORT $LN67@CreateOper
$LN66@CreateOper:
	mov	DWORD PTR tv375[ebp], 0
$LN67@CreateOper:
	mov	eax, DWORD PTR tv375[ebp]
	mov	DWORD PTR $T231292[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T231292[ebp]
	jmp	SHORT $LN24@CreateOper
$LN22@CreateOper:

; 329  : 	}
; 330  : 
; 331  : 	return 0;

	xor	eax, eax
$LN24@CreateOper:

; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@CreateOper:
	DD	$LN10@CreateOper
	DD	$LN9@CreateOper
	DD	$LN21@CreateOper
	DD	$LN20@CreateOper
	DD	$LN19@CreateOper
	DD	$LN11@CreateOper
	DD	$LN8@CreateOper
	DD	$LN6@CreateOper
	DD	$LN18@CreateOper
	DD	$LN16@CreateOper
	DD	$LN15@CreateOper
	DD	$LN13@CreateOper
	DD	$LN12@CreateOper
	DD	$LN4@CreateOper
	DD	$LN3@CreateOper
	DD	$LN5@CreateOper
	DD	$LN2@CreateOper
	DD	$LN1@CreateOper
	DD	$LN14@CreateOper
	DD	$LN17@CreateOper
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$0:
	mov	eax, DWORD PTR $T231213[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$1:
	mov	eax, DWORD PTR $T231217[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$2:
	mov	eax, DWORD PTR $T231221[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$3:
	mov	eax, DWORD PTR $T231225[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$4:
	mov	eax, DWORD PTR $T231229[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$5:
	mov	eax, DWORD PTR $T231233[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$6:
	mov	eax, DWORD PTR $T231237[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$7:
	mov	eax, DWORD PTR $T231241[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$8:
	mov	eax, DWORD PTR $T231245[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$9:
	mov	eax, DWORD PTR $T231249[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$10:
	mov	eax, DWORD PTR $T231253[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$11:
	mov	eax, DWORD PTR $T231257[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$12:
	mov	eax, DWORD PTR $T231261[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$13:
	mov	eax, DWORD PTR $T231265[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$14:
	mov	eax, DWORD PTR $T231269[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$15:
	mov	eax, DWORD PTR $T231273[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$16:
	mov	eax, DWORD PTR $T231277[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$17:
	mov	eax, DWORD PTR $T231281[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$18:
	mov	eax, DWORD PTR $T231285[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$19:
	mov	eax, DWORD PTR $T231289[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$20:
	mov	eax, DWORD PTR $T231293[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z ENDP ; CvAIOperation::CreateOperation
PUBLIC	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
EXTRN	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ:PROC ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
EXTRN	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z:PROC ; CvGlobals::getMultiUnitFormationInfo
EXTRN	?GetFormationIndex@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetFormationIndex
EXTRN	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ:PROC ; CvArmyAI::GetArmyAIState
; Function compile flags: /Odtp
;	COMDAT ?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -168						; size = 4
$T231460 = -108						; size = 4
$T231456 = -104						; size = 4
$T231449 = -100						; size = 4
$T231423 = -96						; size = 4
$T231407 = -92						; size = 4
$T231442 = -88						; size = 4
$T231441 = -84						; size = 4
$T231440 = -80						; size = 4
$T231439 = -76						; size = 4
$T231438 = -72						; size = 4
$T231391 = -68						; size = 4
$T231365 = -64						; size = 4
$T231349 = -60						; size = 4
$T231378 = -56						; size = 4
$T231377 = -52						; size = 4
$T231376 = -48						; size = 4
$T231375 = -44						; size = 4
$T231374 = -40						; size = 4
_thisOperationSlot$223029 = -36				; size = 12
_iThisSlotIndex$223025 = -24				; size = 4
_thisFormation$223023 = -20				; size = 4
_iThisFormationIndex$223021 = -16			; size = 4
_pThisArmy$223018 = -12					; size = 4
_uiI$223014 = -8					; size = 4
_thisPlayer$ = -4					; size = 4
?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ PROC ; CvAIOperation::BuildListOfUnitsWeStillNeedToBuild, COMDAT
; _this$ = ecx

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	DWORD PTR _this$[ebp], ecx

; 337  : 	m_viListOfUnitsCitiesHaveCommittedToBuild.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR $T231391[ebp], eax
	mov	ecx, DWORD PTR $T231391[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231349[ebp], edx
	mov	eax, DWORD PTR $T231349[ebp]
	mov	DWORD PTR $T231375[ebp], eax
	mov	ecx, DWORD PTR $T231375[ebp]
	mov	DWORD PTR $T231374[ebp], ecx
	mov	edx, DWORD PTR $T231391[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231365[ebp], eax
	mov	ecx, DWORD PTR $T231365[ebp]
	mov	DWORD PTR $T231377[ebp], ecx
	mov	edx, DWORD PTR $T231377[ebp]
	mov	DWORD PTR $T231376[ebp], edx
	mov	eax, DWORD PTR $T231374[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231376[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231378[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231391[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 338  : 	m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T231449[ebp], eax
	mov	ecx, DWORD PTR $T231449[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231407[ebp], edx
	mov	eax, DWORD PTR $T231407[ebp]
	mov	DWORD PTR $T231439[ebp], eax
	mov	ecx, DWORD PTR $T231439[ebp]
	mov	DWORD PTR $T231438[ebp], ecx
	mov	edx, DWORD PTR $T231449[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231423[ebp], eax
	mov	ecx, DWORD PTR $T231423[ebp]
	mov	DWORD PTR $T231441[ebp], ecx
	mov	edx, DWORD PTR $T231441[ebp]
	mov	DWORD PTR $T231440[ebp], edx
	mov	eax, DWORD PTR $T231438[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231440[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231442[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231449[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 339  : 	CvPlayer& thisPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[ebp], ecx

; 340  : 	for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223014[ebp], 0
	jmp	SHORT $LN11@BuildListO
$LN10@BuildListO:
	mov	edx, DWORD PTR _uiI$223014[ebp]
	add	edx, 1
	mov	DWORD PTR _uiI$223014[ebp], edx
$LN11@BuildListO:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T231456[ebp], eax
	mov	ecx, DWORD PTR $T231456[ebp]
	mov	edx, DWORD PTR $T231456[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _uiI$223014[ebp], eax
	jae	$LN12@BuildListO

; 341  : 	{
; 342  : 		CvArmyAI* pThisArmy = thisPlayer.getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _uiI$223014[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T231460[ebp], ecx
	mov	edx, DWORD PTR $T231460[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223018[ebp], eax

; 343  : 		// if it is still waiting on initial units
; 344  : 		if(pThisArmy)

	cmp	DWORD PTR _pThisArmy$223018[ebp], 0
	je	$LN8@BuildListO

; 345  : 		{
; 346  : 			if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE)

	mov	ecx, DWORD PTR _pThisArmy$223018[ebp]
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	test	eax, eax
	jne	$LN8@BuildListO

; 347  : 			{
; 348  : 				int iThisFormationIndex = pThisArmy->GetFormationIndex();

	mov	ecx, DWORD PTR _pThisArmy$223018[ebp]
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	mov	DWORD PTR _iThisFormationIndex$223021[ebp], eax

; 349  : 				if(iThisFormationIndex != NO_MUFORMATION)

	cmp	DWORD PTR _iThisFormationIndex$223021[ebp], -1
	je	$LN8@BuildListO

; 350  : 				{
; 351  : 					CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(iThisFormationIndex);

	mov	ecx, DWORD PTR _iThisFormationIndex$223021[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	DWORD PTR _thisFormation$223023[ebp], eax

; 352  : 					if(thisFormation)

	cmp	DWORD PTR _thisFormation$223023[ebp], 0
	je	SHORT $LN8@BuildListO

; 353  : 					{
; 354  : 						for(int iThisSlotIndex = 0; iThisSlotIndex < thisFormation->getNumFormationSlotEntries(); iThisSlotIndex++)

	mov	DWORD PTR _iThisSlotIndex$223025[ebp], 0
	jmp	SHORT $LN4@BuildListO
$LN3@BuildListO:
	mov	edx, DWORD PTR _iThisSlotIndex$223025[ebp]
	add	edx, 1
	mov	DWORD PTR _iThisSlotIndex$223025[ebp], edx
$LN4@BuildListO:
	mov	ecx, DWORD PTR _thisFormation$223023[ebp]
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cmp	DWORD PTR _iThisSlotIndex$223025[ebp], eax
	jge	SHORT $LN8@BuildListO

; 355  : 						{
; 356  : 							OperationSlot thisOperationSlot;

	mov	DWORD PTR _thisOperationSlot$223029[ebp], -1
	mov	DWORD PTR _thisOperationSlot$223029[ebp+4], -1
	mov	DWORD PTR _thisOperationSlot$223029[ebp+8], -1

; 357  : 							thisOperationSlot.m_iOperationID = m_iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _thisOperationSlot$223029[ebp], ecx

; 358  : 							thisOperationSlot.m_iArmyID = m_viArmyIDs[uiI];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _uiI$223014[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _thisOperationSlot$223029[ebp+4], edx

; 359  : 							thisOperationSlot.m_iSlotID = iThisSlotIndex;

	mov	eax, DWORD PTR _iThisSlotIndex$223025[ebp]
	mov	DWORD PTR _thisOperationSlot$223029[ebp+8], eax

; 360  : 							m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot);

	lea	ecx, DWORD PTR _thisOperationSlot$223029[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 361  : 						}

	jmp	SHORT $LN3@BuildListO
$LN8@BuildListO:

; 362  : 					}
; 363  : 				}
; 364  : 				else
; 365  : 				{
; 366  : 					// punt -- sub-class should be taking care of this
; 367  : 					CvAssertMsg(false,"A sub-class should have dealt with this");
; 368  : 				}
; 369  : 			}
; 370  : 		}

	jmp	$LN10@BuildListO
$LN12@BuildListO:

; 371  : 	}
; 372  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ ENDP ; CvAIOperation::BuildListOfUnitsWeStillNeedToBuild
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
__Tmp$231666 = -32					; size = 4
$T231609 = -28						; size = 4
$T231651 = -24						; size = 4
$T231650 = -20						; size = 4
$T231596 = -16						; size = 4
_thisSlot$ = -12					; size = 12
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z PROC ; CvAIOperation::PeekAtNextUnitToBuild, COMDAT
; _this$ = ecx

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 	OperationSlot thisSlot;

	mov	DWORD PTR _thisSlot$[ebp], -1
	mov	DWORD PTR _thisSlot$[ebp+4], -1
	mov	DWORD PTR _thisSlot$[ebp+8], -1

; 378  : 	if(iAreaID == m_iDefaultArea && !m_viListOfUnitsWeStillNeedToBuild.empty())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iAreaID$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jne	SHORT $LN1@PeekAtNext
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T231596[ebp], edx
	mov	eax, DWORD PTR $T231596[ebp]
	mov	ecx, DWORD PTR $T231596[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@PeekAtNext

; 379  : 	{
; 380  : 		thisSlot = m_viListOfUnitsWeStillNeedToBuild.back();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T231609[ebp], ecx
	mov	edx, DWORD PTR $T231609[ebp]
	mov	DWORD PTR $T231650[ebp], edx
	mov	eax, DWORD PTR $T231650[ebp]
	mov	DWORD PTR __Tmp$231666[ebp], eax
	mov	ecx, 1
	neg	ecx
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Tmp$231666[ebp]
	mov	DWORD PTR __Tmp$231666[ebp], ecx
	mov	edx, DWORD PTR __Tmp$231666[ebp]
	mov	DWORD PTR $T231651[ebp], edx
	mov	eax, DWORD PTR $T231651[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _thisSlot$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _thisSlot$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _thisSlot$[ebp+8], eax
$LN1@PeekAtNext:

; 381  : 	}
; 382  : 	return thisSlot;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _thisSlot$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _thisSlot$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _thisSlot$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z ENDP ; CvAIOperation::PeekAtNextUnitToBuild
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back
EXTRN	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z:PROC	; CvArmyAI::SetEstimatedTurn
EXTRN	?GetX@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetX
EXTRN	?GetY@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetY
; Function compile flags: /Odtp
;	COMDAT ?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -208						; size = 4
$T231947 = -124						; size = 4
$T231938 = -120						; size = 4
$T231929 = -116						; size = 4
__Tmp$231755 = -40					; size = 4
$T231698 = -36						; size = 4
$T231740 = -32						; size = 4
$T231739 = -28						; size = 4
$T231685 = -24						; size = 4
_iTurnsFromCityToMusterGuess$223049 = -20		; size = 4
_pArmy$223047 = -16					; size = 4
_thisSlot$ = -12					; size = 12
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
_iTurns$ = 16						; size = 4
_pCity$ = 20						; size = 4
?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z PROC ; CvAIOperation::CommitToBuildNextUnit, COMDAT
; _this$ = ecx

; 387  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 	OperationSlot thisSlot;

	mov	DWORD PTR _thisSlot$[ebp], -1
	mov	DWORD PTR _thisSlot$[ebp+4], -1
	mov	DWORD PTR _thisSlot$[ebp+8], -1

; 389  : 	if(iAreaID == m_iDefaultArea && !m_viListOfUnitsWeStillNeedToBuild.empty())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iAreaID$[ebp]
	cmp	ecx, DWORD PTR [eax+64]
	jne	$LN2@CommitToBu
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T231685[ebp], edx
	mov	eax, DWORD PTR $T231685[ebp]
	mov	ecx, DWORD PTR $T231685[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	jne	$LN2@CommitToBu

; 390  : 	{
; 391  : 		thisSlot = m_viListOfUnitsWeStillNeedToBuild.back();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T231698[ebp], ecx
	mov	edx, DWORD PTR $T231698[ebp]
	mov	DWORD PTR $T231739[ebp], edx
	mov	eax, DWORD PTR $T231739[ebp]
	mov	DWORD PTR __Tmp$231755[ebp], eax
	mov	ecx, 1
	neg	ecx
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Tmp$231755[ebp]
	mov	DWORD PTR __Tmp$231755[ebp], ecx
	mov	edx, DWORD PTR __Tmp$231755[ebp]
	mov	DWORD PTR $T231740[ebp], edx
	mov	eax, DWORD PTR $T231740[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _thisSlot$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _thisSlot$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _thisSlot$[ebp+8], eax

; 392  : 		m_viListOfUnitsWeStillNeedToBuild.pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back

; 393  : 		m_viListOfUnitsCitiesHaveCommittedToBuild.push_back(thisSlot);

	lea	ecx, DWORD PTR _thisSlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 394  : 
; 395  : 		CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(thisSlot.m_iArmyID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231929[ebp], eax
	mov	ecx, DWORD PTR _thisSlot$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR $T231929[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pArmy$223047[ebp], eax

; 396  : 		if(pArmy)

	cmp	DWORD PTR _pArmy$223047[ebp], 0
	je	SHORT $LN2@CommitToBu

; 397  : 		{
; 398  : 			int iTurnsFromCityToMusterGuess;
; 399  : 			iTurnsFromCityToMusterGuess = plotDistance(pCity->getX(), pCity->getY(), pArmy->GetX(), pArmy->GetY()) / 2;

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T231938[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T231947[ebp], edx
	mov	ecx, DWORD PTR _pArmy$223047[ebp]
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, DWORD PTR _pArmy$223047[ebp]
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	mov	eax, DWORD PTR $T231938[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231947[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iTurnsFromCityToMusterGuess$223049[ebp], eax

; 400  : 			pArmy->SetEstimatedTurn(thisSlot.m_iSlotID, iTurns + iTurnsFromCityToMusterGuess);

	mov	edx, DWORD PTR _iTurns$[ebp]
	add	edx, DWORD PTR _iTurnsFromCityToMusterGuess$223049[ebp]
	push	edx
	mov	eax, DWORD PTR _thisSlot$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _pArmy$223047[ebp]
	call	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z	; CvArmyAI::SetEstimatedTurn
$LN2@CommitToBu:

; 401  : 		}
; 402  : 	}
; 403  : 	return thisSlot;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _thisSlot$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _thisSlot$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _thisSlot$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ENDP ; CvAIOperation::CommitToBuildNextUnit
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T232116 = -80						; size = 4
$T232089 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T232089[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T232089[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T232089[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T232116[ebp], edx
	mov	eax, DWORD PTR $T232116[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T232139 = -16						; size = 4
$T232131 = -12						; size = 4
$T232127 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T232127[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232131[ebp], ecx
	movzx	edx, BYTE PTR $T232127[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T232131[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T232131[ebp]
	mov	DWORD PTR $T232139[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T232131[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T232131[ebp]
	mov	DWORD PTR $T232139[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T232139[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T232139[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T232160 = -16						; size = 4
$T232152 = -12						; size = 4
$T232148 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T232148[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T232152[ebp], ecx
	movzx	edx, BYTE PTR $T232148[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T232152[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T232152[ebp]
	mov	DWORD PTR $T232160[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T232152[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T232152[ebp]
	mov	DWORD PTR $T232160[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T232160[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T232160[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
_TEXT	SEGMENT
tv192 = -176						; size = 4
_this$ = -172						; size = 4
$T232294 = -56						; size = 4
$T232284 = -52						; size = 4
$T232258 = -48						; size = 4
$T232257 = -44						; size = 4
$T232227 = -40						; size = 4
$T232261 = -36						; size = 4
$T232193 = -32						; size = 4
$T232177 = -28						; size = 4
$T232167 = -24						; size = 4
$T232166 = -20						; size = 4
$T232165 = -16						; size = 4
$T232164 = -12						; size = 4
$T232163 = -8						; size = 4
_iter$ = -4						; size = 4
_thisOperationSlot$ = 8					; size = 12
?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z PROC ; CvAIOperation::UncommitToBuild, COMDAT
; _this$ = ecx

; 412  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 	// find the operation in the list of committed units
; 414  : 	std::vector<OperationSlot>::iterator iter = find(m_viListOfUnitsCitiesHaveCommittedToBuild.begin(),m_viListOfUnitsCitiesHaveCommittedToBuild.end(),thisOperationSlot);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232177[ebp], ecx
	mov	edx, DWORD PTR $T232177[ebp]
	mov	DWORD PTR $T232163[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T232193[ebp], ecx
	mov	edx, DWORD PTR $T232193[ebp]
	mov	DWORD PTR $T232164[ebp], edx
	mov	eax, DWORD PTR $T232164[ebp]
	mov	DWORD PTR $T232284[ebp], eax
	mov	ecx, DWORD PTR $T232163[ebp]
	mov	DWORD PTR $T232258[ebp], ecx
	mov	edx, DWORD PTR $T232284[ebp]
	mov	DWORD PTR $T232257[ebp], edx
	jmp	SHORT $LN28@UncommitTo
$LN20@UncommitTo:
	mov	eax, DWORD PTR $T232257[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T232257[ebp], eax
$LN28@UncommitTo:
	mov	ecx, DWORD PTR $T232257[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T232258[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@UncommitTo
	mov	edx, DWORD PTR $T232257[ebp]
	mov	DWORD PTR $T232227[ebp], edx
	mov	eax, DWORD PTR $T232227[ebp]
	mov	ecx, DWORD PTR _thisOperationSlot$[ebp+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN38@UncommitTo
	mov	edx, DWORD PTR $T232227[ebp]
	mov	eax, DWORD PTR _thisOperationSlot$[ebp+8]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN38@UncommitTo
	mov	ecx, DWORD PTR $T232227[ebp]
	mov	edx, DWORD PTR _thisOperationSlot$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN38@UncommitTo
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN36@UncommitTo
$LN38@UncommitTo:
	mov	DWORD PTR tv192[ebp], 0
$LN36@UncommitTo:
	movzx	eax, BYTE PTR tv192[ebp]
	test	eax, eax
	je	SHORT $LN18@UncommitTo
	jmp	SHORT $LN19@UncommitTo
$LN18@UncommitTo:
	jmp	SHORT $LN20@UncommitTo
$LN19@UncommitTo:
	mov	ecx, DWORD PTR $T232257[ebp]
	mov	DWORD PTR $T232261[ebp], ecx
	mov	edx, DWORD PTR $T232261[ebp]
	mov	DWORD PTR $T232284[ebp], edx
	mov	eax, DWORD PTR $T232284[ebp]
	mov	DWORD PTR _iter$[ebp], eax

; 415  : 	// if we found it
; 416  : 	if(iter != m_viListOfUnitsCitiesHaveCommittedToBuild.end())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232294[ebp], edx
	mov	eax, DWORD PTR $T232294[ebp]
	mov	DWORD PTR $T232165[ebp], eax
	mov	ecx, DWORD PTR _iter$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T232165[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@UncommitTo

; 417  : 	{
; 418  : 		// add it to the list of stuff that needs to be built
; 419  : 		m_viListOfUnitsWeStillNeedToBuild.push_back(*iter);

	mov	edx, DWORD PTR _iter$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 420  : 		// remove it from the list of committed units
; 421  : 		m_viListOfUnitsCitiesHaveCommittedToBuild.erase(iter);

	mov	eax, DWORD PTR _iter$[ebp]
	mov	DWORD PTR $T232166[ebp], eax
	mov	ecx, DWORD PTR $T232166[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232167[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 422  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@UncommitTo
$LN1@UncommitTo:

; 423  : 	}
; 424  : 	return false;

	xor	al, al
$LN2@UncommitTo:

; 425  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z ENDP ; CvAIOperation::UncommitToBuild
_TEXT	ENDS
EXTRN	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z:PROC ; CvArmyAI::SetArmyAIState
; Function compile flags: /Odtp
;	COMDAT ?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
_TEXT	SEGMENT
tv217 = -132						; size = 4
_this$ = -128						; size = 4
$T232824 = -124						; size = 4
$T232820 = -120						; size = 4
$T232816 = -116						; size = 4
$T232812 = -112						; size = 4
$T232685 = -64						; size = 4
$T232675 = -60						; size = 4
$T232649 = -56						; size = 4
$T232648 = -52						; size = 4
$T232618 = -48						; size = 4
$T232651 = -44						; size = 4
$T232584 = -40						; size = 4
$T232568 = -36						; size = 4
$T232558 = -32						; size = 4
$T232557 = -28						; size = 4
$T232556 = -24						; size = 4
$T232555 = -20						; size = 4
$T232554 = -16						; size = 4
_pThisArmy$223241 = -12					; size = 4
_uiI$223237 = -8					; size = 4
_iter$ = -4						; size = 4
_thisOperationSlot$ = 8					; size = 12
?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z PROC ; CvAIOperation::FinishedBuilding, COMDAT
; _this$ = ecx

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 434  : 	// find the operation in the list of committed units
; 435  : 	std::vector<OperationSlot>::iterator iter = find(m_viListOfUnitsCitiesHaveCommittedToBuild.begin(),m_viListOfUnitsCitiesHaveCommittedToBuild.end(),thisOperationSlot);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232568[ebp], ecx
	mov	edx, DWORD PTR $T232568[ebp]
	mov	DWORD PTR $T232554[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T232584[ebp], ecx
	mov	edx, DWORD PTR $T232584[ebp]
	mov	DWORD PTR $T232555[ebp], edx
	mov	eax, DWORD PTR $T232555[ebp]
	mov	DWORD PTR $T232675[ebp], eax
	mov	ecx, DWORD PTR $T232554[ebp]
	mov	DWORD PTR $T232649[ebp], ecx
	mov	edx, DWORD PTR $T232675[ebp]
	mov	DWORD PTR $T232648[ebp], edx
	jmp	SHORT $LN33@FinishedBu
$LN25@FinishedBu:
	mov	eax, DWORD PTR $T232648[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T232648[ebp], eax
$LN33@FinishedBu:
	mov	ecx, DWORD PTR $T232648[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T232649[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@FinishedBu
	mov	edx, DWORD PTR $T232648[ebp]
	mov	DWORD PTR $T232618[ebp], edx
	mov	eax, DWORD PTR $T232618[ebp]
	mov	ecx, DWORD PTR _thisOperationSlot$[ebp+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN43@FinishedBu
	mov	edx, DWORD PTR $T232618[ebp]
	mov	eax, DWORD PTR _thisOperationSlot$[ebp+8]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN43@FinishedBu
	mov	ecx, DWORD PTR $T232618[ebp]
	mov	edx, DWORD PTR _thisOperationSlot$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN43@FinishedBu
	mov	DWORD PTR tv217[ebp], 1
	jmp	SHORT $LN41@FinishedBu
$LN43@FinishedBu:
	mov	DWORD PTR tv217[ebp], 0
$LN41@FinishedBu:
	movzx	eax, BYTE PTR tv217[ebp]
	test	eax, eax
	je	SHORT $LN23@FinishedBu
	jmp	SHORT $LN24@FinishedBu
$LN23@FinishedBu:
	jmp	SHORT $LN25@FinishedBu
$LN24@FinishedBu:
	mov	ecx, DWORD PTR $T232648[ebp]
	mov	DWORD PTR $T232651[ebp], ecx
	mov	edx, DWORD PTR $T232651[ebp]
	mov	DWORD PTR $T232675[ebp], edx
	mov	eax, DWORD PTR $T232675[ebp]
	mov	DWORD PTR _iter$[ebp], eax

; 436  : 	// if we found it
; 437  : 	if(iter != m_viListOfUnitsCitiesHaveCommittedToBuild.end())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T232685[ebp], edx
	mov	eax, DWORD PTR $T232685[ebp]
	mov	DWORD PTR $T232556[ebp], eax
	mov	ecx, DWORD PTR _iter$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T232556[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@FinishedBu

; 438  : 	{
; 439  : 		// remove it from the list of committed units
; 440  : 		m_viListOfUnitsCitiesHaveCommittedToBuild.erase(iter);

	mov	edx, DWORD PTR _iter$[ebp]
	mov	DWORD PTR $T232557[ebp], edx
	mov	eax, DWORD PTR $T232557[ebp]
	push	eax
	lea	ecx, DWORD PTR $T232558[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 441  : 
; 442  : 		// See if our army is now complete
; 443  : 		if(m_viListOfUnitsWeStillNeedToBuild.empty() && m_eCurrentState  == AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T232812[ebp], edx
	mov	eax, DWORD PTR $T232812[ebp]
	mov	ecx, DWORD PTR $T232812[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	je	$LN5@FinishedBu
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 1
	jne	$LN5@FinishedBu

; 444  : 		{
; 445  : 			m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 2

; 446  : 
; 447  : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223237[ebp], 0
	jmp	SHORT $LN4@FinishedBu
$LN3@FinishedBu:
	mov	edx, DWORD PTR _uiI$223237[ebp]
	add	edx, 1
	mov	DWORD PTR _uiI$223237[ebp], edx
$LN4@FinishedBu:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T232816[ebp], eax
	mov	ecx, DWORD PTR $T232816[ebp]
	mov	edx, DWORD PTR $T232816[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _uiI$223237[ebp], eax
	jae	SHORT $LN5@FinishedBu

; 448  : 			{
; 449  : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _uiI$223237[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T232820[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T232824[ebp], eax
	mov	ecx, DWORD PTR $T232820[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T232824[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223241[ebp], eax

; 450  : 				if(pThisArmy)

	cmp	DWORD PTR _pThisArmy$223241[ebp], 0
	je	SHORT $LN1@FinishedBu

; 451  : 				{
; 452  : 					pThisArmy->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pThisArmy$223241[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
$LN1@FinishedBu:

; 453  : 				}
; 454  : 			}

	jmp	SHORT $LN3@FinishedBu
$LN5@FinishedBu:

; 455  : 		}
; 456  : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@FinishedBu
$LN6@FinishedBu:

; 457  : 	}
; 458  : 	return false;

	xor	al, al
$LN7@FinishedBu:

; 459  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z ENDP ; CvAIOperation::FinishedBuilding
_TEXT	ENDS
PUBLIC	??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::vector<OperationSlot,std::allocator<OperationSlot> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z$2
__ehfuncinfo$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
_TEXT	SEGMENT
_this$ = -236						; size = 4
$T233175 = -200						; size = 4
$T233171 = -196						; size = 4
$T233053 = -144						; size = 4
$T233030 = -140						; size = 4
$T233006 = -136						; size = 4
$T232996 = -132						; size = 4
$T232970 = -128						; size = 4
$T232954 = -124						; size = 4
$T232982 = -120						; size = 4
$T232981 = -116						; size = 4
$T232980 = -112						; size = 4
$T232979 = -108						; size = 4
$T232978 = -104						; size = 4
$T232881 = -76						; size = 4
$T232857 = -72						; size = 4
$T232831 = -57						; size = 1
$T232830 = -56						; size = 4
$T232829 = -52						; size = 4
$T232828 = -48						; size = 4
$T232827 = -44						; size = 4
_pArmy$223274 = -40					; size = 4
_rtnValue$ = -35					; size = 1
_success$ = -34						; size = 1
_bRequired$ = -33					; size = 1
_secondList$ = -32					; size = 16
_it$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pMusterPlot$ = 8					; size = 4
_pTargetPlot$ = 12					; size = 4
?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z PROC ; CvAIOperation::GrabUnitsFromTheReserves, COMDAT
; _this$ = ecx

; 463  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 	bool rtnValue = true;

	mov	BYTE PTR _rtnValue$[ebp], 1

; 465  : 	bool success;
; 466  : 	std::vector<OperationSlot>::iterator it;

	mov	DWORD PTR _it$[ebp], 0

; 467  : 	bool bRequired;
; 468  : 
; 469  : 	// Copy over the list
; 470  : 	std::vector<OperationSlot> secondList;

	lea	ecx, DWORD PTR _secondList$[ebp]
	call	??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::vector<OperationSlot,std::allocator<OperationSlot> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 	for(it = m_viListOfUnitsWeStillNeedToBuild.begin(); it != m_viListOfUnitsWeStillNeedToBuild.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T232857[ebp], ecx
	mov	edx, DWORD PTR $T232857[ebp]
	mov	DWORD PTR $T232827[ebp], edx
	mov	eax, DWORD PTR $T232827[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN10@GrabUnitsF
$LN9@GrabUnitsF:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _it$[ebp], ecx
$LN10@GrabUnitsF:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T232881[ebp], eax
	mov	ecx, DWORD PTR $T232881[ebp]
	mov	DWORD PTR $T232828[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T232828[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN8@GrabUnitsF

; 472  : 	{
; 473  : 		secondList.push_back(*it);

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondList$[ebp]
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 474  : 	}

	jmp	SHORT $LN9@GrabUnitsF
$LN8@GrabUnitsF:

; 475  : 
; 476  : 	// Clear main list
; 477  : 	m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T232996[ebp], ecx
	mov	edx, DWORD PTR $T232996[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T232954[ebp], eax
	mov	ecx, DWORD PTR $T232954[ebp]
	mov	DWORD PTR $T232979[ebp], ecx
	mov	edx, DWORD PTR $T232979[ebp]
	mov	DWORD PTR $T232978[ebp], edx
	mov	eax, DWORD PTR $T232996[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T232970[ebp], ecx
	mov	edx, DWORD PTR $T232970[ebp]
	mov	DWORD PTR $T232981[ebp], edx
	mov	eax, DWORD PTR $T232981[ebp]
	mov	DWORD PTR $T232980[ebp], eax
	mov	ecx, DWORD PTR $T232978[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232980[ebp]
	push	edx
	lea	eax, DWORD PTR $T232982[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232996[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 478  : 
; 479  : 	for(it = secondList.begin(); it != secondList.end(); ++it)

	mov	ecx, DWORD PTR _secondList$[ebp+4]
	mov	DWORD PTR $T233006[ebp], ecx
	mov	edx, DWORD PTR $T233006[ebp]
	mov	DWORD PTR $T232829[ebp], edx
	mov	eax, DWORD PTR $T232829[ebp]
	mov	DWORD PTR _it$[ebp], eax
	jmp	SHORT $LN7@GrabUnitsF
$LN6@GrabUnitsF:
	mov	ecx, DWORD PTR _it$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _it$[ebp], ecx
$LN7@GrabUnitsF:
	mov	edx, DWORD PTR _secondList$[ebp+8]
	mov	DWORD PTR $T233030[ebp], edx
	mov	eax, DWORD PTR $T233030[ebp]
	mov	DWORD PTR $T232830[ebp], eax
	mov	ecx, DWORD PTR _it$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T232830[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@GrabUnitsF

; 480  : 	{
; 481  : 		success = FindBestFitReserveUnit(*it, pMusterPlot, pTargetPlot, &bRequired);

	mov	edx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233053[ebp], edx
	lea	eax, DWORD PTR _bRequired$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTargetPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMusterPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR $T233053[ebp]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+140]
	call	eax
	mov	BYTE PTR _success$[ebp], al

; 482  : 
; 483  : 		// If any fail, check to see if they were required
; 484  : 		if(!success)

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@GrabUnitsF

; 485  : 		{
; 486  : 			if(bRequired)

	movzx	edx, BYTE PTR _bRequired$[ebp]
	test	edx, edx
	je	SHORT $LN153@GrabUnitsF

; 487  : 			{
; 488  : 				// Return false to say that operation is not ready to roll yet
; 489  : 				rtnValue = false;

	mov	BYTE PTR _rtnValue$[ebp], 0

; 490  : 
; 491  : 				// And add them back to the list of units needed
; 492  : 				m_viListOfUnitsWeStillNeedToBuild.push_back(*it);

	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 493  : 			}
; 494  : 			else

	jmp	SHORT $LN4@GrabUnitsF

; 495  : 			{
; 496  : 				CvArmyAI* pArmy;
; 497  : 				pArmy = GET_PLAYER(m_eOwner).getArmyAI(it->m_iArmyID);

$LN153@GrabUnitsF:
	mov	ecx, DWORD PTR _it$[ebp]
	mov	DWORD PTR $T233171[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233175[ebp], eax
	mov	ecx, DWORD PTR $T233171[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR $T233175[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pArmy$223274[ebp], eax

; 498  : 				if(pArmy)

	cmp	DWORD PTR _pArmy$223274[ebp], 0
	je	SHORT $LN4@GrabUnitsF

; 499  : 				{
; 500  : 					pArmy->SetEstimatedTurn(it->m_iSlotID, ARMYSLOT_NOT_INCLUDING_IN_OPERATION);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$223274[ebp]
	call	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z	; CvArmyAI::SetEstimatedTurn
$LN4@GrabUnitsF:

; 501  : 				}
; 502  : 			}
; 503  : 		}
; 504  : 	}

	jmp	$LN6@GrabUnitsF
$LN5@GrabUnitsF:

; 505  : 
; 506  : 	return rtnValue;

	mov	dl, BYTE PTR _rtnValue$[ebp]
	mov	BYTE PTR $T232831[ebp], dl
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _secondList$[ebp]
	call	?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	al, BYTE PTR $T232831[ebp]

; 507  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z$0:
	lea	ecx, DWORD PTR _secondList$[ebp]
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__unwindfunclet$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z$2:
	lea	ecx, DWORD PTR _secondList$[ebp]
	jmp	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
__ehhandler$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z ENDP ; CvAIOperation::GrabUnitsFromTheReserves
EXTRN	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z:PROC ; CvArmyAI::GetFurthestUnitDistance
EXTRN	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z:PROC ; CvArmyAI::GetCenterOfMass
EXTRN	?GetNextUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetNextUnitID
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	?GetFirstUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetFirstUnitID
; Function compile flags: /Odtp
;	COMDAT ?CheckOnTarget@CvAIOperation@@UAE_NXZ
_TEXT	SEGMENT
tv422 = -572						; size = 4
tv317 = -568						; size = 4
tv265 = -564						; size = 4
tv216 = -560						; size = 4
tv193 = -556						; size = 4
tv68 = -552						; size = 4
_this$ = -548						; size = 4
$T233635 = -464						; size = 4
$T233631 = -460						; size = 4
$T233627 = -456						; size = 4
$T233626 = -452						; size = 4
$T233622 = -448						; size = 4
$T233621 = -444						; size = 4
$T233617 = -440						; size = 4
$T233613 = -436						; size = 4
$T233609 = -432						; size = 4
$T233544 = -360						; size = 4
$T233540 = -356						; size = 4
$T233472 = -284						; size = 4
$T233468 = -280						; size = 4
$T233464 = -276						; size = 4
$T233463 = -272						; size = 4
$T233459 = -268						; size = 4
$T233458 = -264						; size = 4
$T233454 = -260						; size = 4
$T233450 = -256						; size = 4
$T233446 = -252						; size = 4
$T233393 = -192						; size = 4
$T233389 = -188						; size = 4
$T233333 = -128						; size = 4
$T233329 = -124						; size = 4
$T233325 = -120						; size = 4
$T233324 = -116						; size = 4
$T233320 = -112						; size = 4
$T233319 = -108						; size = 4
$T233315 = -104						; size = 4
$T233311 = -100						; size = 4
$T233307 = -96						; size = 4
$T233303 = -92						; size = 4
$T233299 = -88						; size = 4
$T233295 = -84						; size = 4
$T233291 = -80						; size = 4
_pCenterOfMass$223344 = -76				; size = 4
_iGatherTolerance$223345 = -72				; size = 4
_pThisArmy$223343 = -68					; size = 4
_uiI$223339 = -64					; size = 4
_iTargetTolerance$223335 = -60				; size = 4
_iGatherTolerance$223332 = -56				; size = 4
_pCenterOfMass$223325 = -52				; size = 4
_pThisArmy$223324 = -48					; size = 4
_uiI$223320 = -44					; size = 4
_iTargetTolerance$223316 = -40				; size = 4
_iGatherTolerance$223313 = -36				; size = 4
_pCenterOfMass$223306 = -32				; size = 4
_pThisArmy$223305 = -28					; size = 4
_uiI$223301 = -24					; size = 4
_pThisArmy$223290 = -20					; size = 4
_pEscortPlot$ = -16					; size = 4
_pCivilianPlot$ = -12					; size = 4
_pCivilian$ = -8					; size = 4
_iUnitID$ = -4						; size = 4
?CheckOnTarget@CvAIOperation@@UAE_NXZ PROC		; CvAIOperation::CheckOnTarget, COMDAT
; _this$ = ecx

; 511  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 572				; 0000023cH
	mov	DWORD PTR _this$[ebp], ecx

; 512  : 	int iUnitID;
; 513  : 	CvUnit* pCivilian;
; 514  : 	CvPlot* pCivilianPlot = NULL;

	mov	DWORD PTR _pCivilianPlot$[ebp], 0

; 515  : 	CvPlot* pEscortPlot;
; 516  : 
; 517  : 	if(GetFirstArmyID() == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	cmp	eax, -1
	jne	SHORT $LN47@CheckOnTar

; 518  : 	{
; 519  : 		return false;

	xor	al, al
	jmp	$LN48@CheckOnTar
$LN47@CheckOnTar:

; 520  : 	}
; 521  : 
; 522  : 	switch(m_eMoveType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN45@CheckOnTar
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN318@CheckOnTar[edx*4]
$LN44@CheckOnTar:

; 523  : 	{
; 524  : 		{
; 525  : 		case AI_OPERATION_MOVETYPE_SINGLE_HEX:
; 526  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T233291[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233295[ebp], eax
	mov	ecx, DWORD PTR $T233291[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T233295[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223290[ebp], eax

; 527  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, DWORD PTR _pThisArmy$223290[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	$LN35@CheckOnTar

; 528  : 			{
; 529  : 				iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pThisArmy$223290[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 530  : 				if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN42@CheckOnTar

; 531  : 				{
; 532  : 					pCivilian = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233299[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233299[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pCivilian$[ebp], eax

; 533  : 					pCivilianPlot = pCivilian->plot();

	mov	ecx, DWORD PTR _pCivilian$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pCivilianPlot$[ebp], eax
$LN42@CheckOnTar:

; 534  : 				}
; 535  : 				if(m_eCurrentState == AI_OPERATION_STATE_MOVING_TO_TARGET && pCivilianPlot == GetTargetPlot())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 3
	jne	SHORT $LN41@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _pCivilianPlot$[ebp], eax
	jne	SHORT $LN41@CheckOnTar

; 536  : 				{
; 537  : 					ArmyInPosition(pThisArmy);

	mov	ecx, DWORD PTR _pThisArmy$223290[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 538  : 					return true;

	mov	al, 1
	jmp	$LN48@CheckOnTar
	jmp	$LN35@CheckOnTar
$LN41@CheckOnTar:

; 539  : 				}
; 540  : 				else if(m_eCurrentState == AI_OPERATION_STATE_GATHERING_FORCES)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 2
	jne	$LN35@CheckOnTar

; 541  : 				{
; 542  : 					if(pThisArmy->GetNumSlotsFilled() == 1)

	mov	ecx, DWORD PTR _pThisArmy$223290[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jne	SHORT $LN38@CheckOnTar

; 543  : 					{
; 544  : 						ArmyInPosition(pThisArmy);

	mov	ecx, DWORD PTR _pThisArmy$223290[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+60]
	call	edx

; 545  : 						return true;

	mov	al, 1
	jmp	$LN48@CheckOnTar

; 546  : 					}
; 547  : 					else

	jmp	SHORT $LN35@CheckOnTar
$LN38@CheckOnTar:

; 548  : 					{
; 549  : 						pEscortPlot = GET_PLAYER(m_eOwner).getUnit(pThisArmy->GetNextUnitID())->plot();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233303[ebp], ecx
	mov	ecx, DWORD PTR _pThisArmy$223290[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	push	eax
	mov	ecx, DWORD PTR $T233303[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pEscortPlot$[ebp], eax

; 550  : 						if(pCivilianPlot == pEscortPlot)

	mov	edx, DWORD PTR _pCivilianPlot$[ebp]
	cmp	edx, DWORD PTR _pEscortPlot$[ebp]
	jne	SHORT $LN35@CheckOnTar

; 551  : 						{
; 552  : 							ArmyInPosition(pThisArmy);

	mov	eax, DWORD PTR _pThisArmy$223290[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 553  : 							return true;

	mov	al, 1
	jmp	$LN48@CheckOnTar
$LN35@CheckOnTar:

; 554  : 						}
; 555  : 					}
; 556  : 				}
; 557  : 			}
; 558  : 			else
; 559  : 			{
; 560  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 561  : 				            "Found an escort operation with no units in it.  Show Ed and send save.");
; 562  : 			}
; 563  : 			break;

	jmp	$LN45@CheckOnTar
$LN34@CheckOnTar:

; 564  : 		}
; 565  : 
; 566  : 	case AI_OPERATION_MOVETYPE_ENEMY_TERRITORY:
; 567  : 	{
; 568  : 		// Let each army perform its own check
; 569  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223301[ebp], 0
	jmp	SHORT $LN33@CheckOnTar
$LN32@CheckOnTar:
	mov	ecx, DWORD PTR _uiI$223301[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiI$223301[ebp], ecx
$LN33@CheckOnTar:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T233307[ebp], edx
	mov	eax, DWORD PTR $T233307[ebp]
	mov	ecx, DWORD PTR $T233307[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _uiI$223301[ebp], edx
	jae	$LN31@CheckOnTar

; 570  : 		{
; 571  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$223301[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T233311[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233315[ebp], edx
	mov	eax, DWORD PTR $T233311[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T233315[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223305[ebp], eax

; 572  : 			CvPlot* pCenterOfMass;
; 573  : 
; 574  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, DWORD PTR _pThisArmy$223305[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	$LN23@CheckOnTar

; 575  : 			{
; 576  : 				switch(m_eCurrentState)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR tv193[ebp], eax
	cmp	DWORD PTR tv193[ebp], 2
	je	SHORT $LN27@CheckOnTar
	cmp	DWORD PTR tv193[ebp], 3
	je	$LN25@CheckOnTar
	jmp	$LN23@CheckOnTar
$LN27@CheckOnTar:

; 577  : 				{
; 578  : 				case AI_OPERATION_STATE_GATHERING_FORCES:
; 579  : 					{
; 580  : 						int iGatherTolerance = GetGatherTolerance(pThisArmy, GetMusterPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223305[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+48]
	call	edx
	mov	DWORD PTR _iGatherTolerance$223313[ebp], eax

; 581  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN50@CheckOnTar
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN50@CheckOnTar
	mov	DWORD PTR tv216[ebp], 2
	jmp	SHORT $LN51@CheckOnTar
$LN50@CheckOnTar:
	mov	DWORD PTR tv216[ebp], 0
$LN51@CheckOnTar:
	mov	ecx, DWORD PTR tv216[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pThisArmy$223305[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$223306[ebp], eax

; 582  : 						if(pCenterOfMass &&
; 583  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), GetMusterPlot()->getX(), GetMusterPlot()->getY()) <= iGatherTolerance &&
; 584  : 							pThisArmy->GetFurthestUnitDistance(GetMusterPlot()) <= (iGatherTolerance * 3 / 2))

	cmp	DWORD PTR _pCenterOfMass$223306[ebp], 0
	je	$LN26@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T233319[ebp], eax
	mov	edx, DWORD PTR $T233319[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T233320[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T233324[ebp], eax
	mov	ecx, DWORD PTR $T233324[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T233325[ebp], edx
	mov	eax, DWORD PTR _pCenterOfMass$223306[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T233329[ebp], ecx
	mov	edx, DWORD PTR _pCenterOfMass$223306[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T233333[ebp], eax
	mov	ecx, DWORD PTR $T233320[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233325[ebp]
	push	edx
	mov	eax, DWORD PTR $T233329[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233333[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iGatherTolerance$223313[ebp]
	jg	SHORT $LN26@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223305[ebp]
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	ecx, eax
	mov	eax, DWORD PTR _iGatherTolerance$223313[ebp]
	imul	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jg	SHORT $LN26@CheckOnTar

; 585  : 						{
; 586  : 							ArmyInPosition(pThisArmy);

	mov	edx, DWORD PTR _pThisArmy$223305[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 587  : 							return true;

	mov	al, 1
	jmp	$LN48@CheckOnTar
$LN26@CheckOnTar:

; 588  : 						}
; 589  : 					}
; 590  : 					break;

	jmp	$LN23@CheckOnTar
$LN25@CheckOnTar:

; 591  : 				case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 592  : 					{
; 593  : 						int iTargetTolerance = GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	DWORD PTR _iTargetTolerance$223316[ebp], ecx

; 594  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+40]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN52@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN52@CheckOnTar
	mov	DWORD PTR tv265[ebp], 2
	jmp	SHORT $LN53@CheckOnTar
$LN52@CheckOnTar:
	mov	DWORD PTR tv265[ebp], 0
$LN53@CheckOnTar:
	mov	edx, DWORD PTR tv265[ebp]
	push	edx
	mov	ecx, DWORD PTR _pThisArmy$223305[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$223306[ebp], eax

; 595  : 						if(pCenterOfMass &&
; 596  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= iTargetTolerance &&
; 597  : 							pThisArmy->GetFurthestUnitDistance(GetTargetPlot()) <= (iTargetTolerance * 3 / 2))

	cmp	DWORD PTR _pCenterOfMass$223306[ebp], 0
	je	$LN23@CheckOnTar
	mov	eax, DWORD PTR _pCenterOfMass$223306[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T233389[ebp], ecx
	mov	edx, DWORD PTR _pCenterOfMass$223306[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T233393[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	mov	edx, DWORD PTR $T233389[ebp]
	push	edx
	mov	eax, DWORD PTR $T233393[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iTargetTolerance$223316[ebp]
	jg	SHORT $LN23@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223305[ebp]
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	ecx, eax
	mov	eax, DWORD PTR _iTargetTolerance$223316[ebp]
	imul	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jg	SHORT $LN23@CheckOnTar

; 598  : 						{
; 599  : 							ArmyInPosition(pThisArmy);

	mov	edx, DWORD PTR _pThisArmy$223305[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 600  : 							return true;

	mov	al, 1
	jmp	$LN48@CheckOnTar
$LN23@CheckOnTar:

; 601  : 						}
; 602  : 					}
; 603  : 					break;
; 604  : 				}
; 605  : 			}
; 606  : 			else
; 607  : 			{
; 608  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 609  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 610  : 			}
; 611  : 		}

	jmp	$LN32@CheckOnTar
$LN31@CheckOnTar:

; 612  : 		break;

	jmp	$LN45@CheckOnTar
$LN22@CheckOnTar:

; 613  : 	}
; 614  : 
; 615  : 	case AI_OPERATION_MOVETYPE_NAVAL_ESCORT:
; 616  : 	{
; 617  : 		// Let each army perform its own check
; 618  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223320[ebp], 0
	jmp	SHORT $LN21@CheckOnTar
$LN20@CheckOnTar:
	mov	ecx, DWORD PTR _uiI$223320[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiI$223320[ebp], ecx
$LN21@CheckOnTar:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T233446[ebp], edx
	mov	eax, DWORD PTR $T233446[ebp]
	mov	ecx, DWORD PTR $T233446[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _uiI$223320[ebp], edx
	jae	$LN19@CheckOnTar

; 619  : 		{
; 620  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$223320[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T233450[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233454[ebp], edx
	mov	eax, DWORD PTR $T233450[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T233454[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223324[ebp], eax

; 621  : 			CvPlot* pCenterOfMass;
; 622  : 
; 623  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, DWORD PTR _pThisArmy$223324[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	$LN11@CheckOnTar

; 624  : 			{
; 625  : 				switch(m_eCurrentState)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR tv317[ebp], eax
	cmp	DWORD PTR tv317[ebp], 2
	je	SHORT $LN15@CheckOnTar
	cmp	DWORD PTR tv317[ebp], 3
	je	$LN13@CheckOnTar
	jmp	$LN11@CheckOnTar
$LN15@CheckOnTar:

; 626  : 				{
; 627  : 				case AI_OPERATION_STATE_GATHERING_FORCES:
; 628  : 					{
; 629  : 						int iGatherTolerance = GetGatherTolerance(pThisArmy, GetMusterPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223324[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+48]
	call	edx
	mov	DWORD PTR _iGatherTolerance$223332[ebp], eax

; 630  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, DWORD PTR _pThisArmy$223324[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$223325[ebp], eax

; 631  : 						if(pCenterOfMass &&
; 632  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), GetMusterPlot()->getX(), GetMusterPlot()->getY()) <= iGatherTolerance &&
; 633  : 							pThisArmy->GetFurthestUnitDistance(GetMusterPlot()) <= (iGatherTolerance * 3))

	cmp	DWORD PTR _pCenterOfMass$223325[ebp], 0
	je	$LN14@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T233458[ebp], eax
	mov	eax, DWORD PTR $T233458[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T233459[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T233463[ebp], eax
	mov	edx, DWORD PTR $T233463[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T233464[ebp], eax
	mov	ecx, DWORD PTR _pCenterOfMass$223325[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T233468[ebp], edx
	mov	eax, DWORD PTR _pCenterOfMass$223325[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T233472[ebp], ecx
	mov	edx, DWORD PTR $T233459[ebp]
	push	edx
	mov	eax, DWORD PTR $T233464[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233468[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233472[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iGatherTolerance$223332[ebp]
	jg	SHORT $LN14@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223324[ebp]
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	ecx, DWORD PTR _iGatherTolerance$223332[ebp]
	imul	ecx, 3
	cmp	eax, ecx
	jg	SHORT $LN14@CheckOnTar

; 634  : 						{
; 635  : 							ArmyInPosition(pThisArmy);

	mov	edx, DWORD PTR _pThisArmy$223324[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 636  : 							return true;

	mov	al, 1
	jmp	$LN48@CheckOnTar
$LN14@CheckOnTar:

; 637  : 						}
; 638  : 					}
; 639  : 					break;

	jmp	$LN11@CheckOnTar
$LN13@CheckOnTar:

; 640  : 				case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 641  : 					{
; 642  : 						int iTargetTolerance = GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	DWORD PTR _iTargetTolerance$223335[ebp], ecx

; 643  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, DWORD PTR _pThisArmy$223324[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$223325[ebp], eax

; 644  : 						if(pCenterOfMass &&
; 645  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= (iTargetTolerance  * 2) &&
; 646  : 							pThisArmy->GetFurthestUnitDistance(GetTargetPlot()) <= (iTargetTolerance * 3))

	cmp	DWORD PTR _pCenterOfMass$223325[ebp], 0
	je	$LN11@CheckOnTar
	mov	edx, DWORD PTR _pCenterOfMass$223325[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T233540[ebp], eax
	mov	ecx, DWORD PTR _pCenterOfMass$223325[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T233544[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	mov	ecx, DWORD PTR $T233540[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233544[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _iTargetTolerance$223335[ebp]
	shl	ecx, 1
	cmp	eax, ecx
	jg	SHORT $LN11@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223324[ebp]
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	edx, DWORD PTR _iTargetTolerance$223335[ebp]
	imul	edx, 3
	cmp	eax, edx
	jg	SHORT $LN11@CheckOnTar

; 647  : 						{
; 648  : 							ArmyInPosition(pThisArmy);

	mov	eax, DWORD PTR _pThisArmy$223324[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 649  : 							return true;

	mov	al, 1
	jmp	$LN48@CheckOnTar
$LN11@CheckOnTar:

; 650  : 						}
; 651  : 					}
; 652  : 					break;
; 653  : 				}
; 654  : 			}
; 655  : 			else
; 656  : 			{
; 657  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 658  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 659  : 			}
; 660  : 		}

	jmp	$LN20@CheckOnTar
$LN19@CheckOnTar:

; 661  : 		break;

	jmp	$LN45@CheckOnTar
$LN10@CheckOnTar:

; 662  : 	}
; 663  : 
; 664  : 	case AI_OPERATION_MOVETYPE_FREEFORM_NAVAL:
; 665  : 	{
; 666  : 		// Let each army perform its own check
; 667  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223339[ebp], 0
	jmp	SHORT $LN9@CheckOnTar
$LN8@CheckOnTar:
	mov	ecx, DWORD PTR _uiI$223339[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiI$223339[ebp], ecx
$LN9@CheckOnTar:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T233609[ebp], edx
	mov	eax, DWORD PTR $T233609[ebp]
	mov	ecx, DWORD PTR $T233609[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _uiI$223339[ebp], edx
	jae	$LN45@CheckOnTar

; 668  : 		{
; 669  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$223339[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T233613[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233617[ebp], edx
	mov	eax, DWORD PTR $T233613[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T233617[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223343[ebp], eax

; 670  : 			CvPlot* pCenterOfMass;
; 671  : 			int iGatherTolerance = GetGatherTolerance(pThisArmy, GetMusterPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	edx, DWORD PTR _pThisArmy$223343[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	mov	DWORD PTR _iGatherTolerance$223345[ebp], eax

; 672  : 
; 673  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, DWORD PTR _pThisArmy$223343[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	$LN1@CheckOnTar

; 674  : 			{
; 675  : 				switch(m_eCurrentState)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR tv422[ebp], edx
	cmp	DWORD PTR tv422[ebp], 2
	jl	$LN1@CheckOnTar
	cmp	DWORD PTR tv422[ebp], 3
	jle	SHORT $LN3@CheckOnTar
	jmp	$LN1@CheckOnTar
$LN3@CheckOnTar:

; 676  : 				{
; 677  : 				case AI_OPERATION_STATE_GATHERING_FORCES:
; 678  : 				case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 679  : 
; 680  : 					// We want to recompute a new target each turn.  So call ArmyInPosition() regardless of return status
; 681  : 					ArmyInPosition(pThisArmy);

	mov	eax, DWORD PTR _pThisArmy$223343[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 682  : 
; 683  : 					pCenterOfMass = pThisArmy->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, DWORD PTR _pThisArmy$223343[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$223344[ebp], eax

; 684  : 					if(pCenterOfMass &&
; 685  : 					        plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), GetTargetPlot()->getX(), GetTargetPlot()->getY()) <= iGatherTolerance &&
; 686  : 					        pThisArmy->GetFurthestUnitDistance(GetMusterPlot()) <= (iGatherTolerance * 3 / 2))

	cmp	DWORD PTR _pCenterOfMass$223344[ebp], 0
	je	$LN1@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T233621[ebp], eax
	mov	ecx, DWORD PTR $T233621[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T233622[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T233626[ebp], eax
	mov	eax, DWORD PTR $T233626[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T233627[ebp], ecx
	mov	edx, DWORD PTR _pCenterOfMass$223344[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T233631[ebp], eax
	mov	ecx, DWORD PTR _pCenterOfMass$223344[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T233635[ebp], edx
	mov	eax, DWORD PTR $T233622[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233627[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233631[ebp]
	push	edx
	mov	eax, DWORD PTR $T233635[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iGatherTolerance$223345[ebp]
	jg	SHORT $LN1@CheckOnTar
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223343[ebp]
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	ecx, eax
	mov	eax, DWORD PTR _iGatherTolerance$223345[ebp]
	imul	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jg	SHORT $LN1@CheckOnTar

; 687  : 					{
; 688  : 						return true;

	mov	al, 1
	jmp	SHORT $LN48@CheckOnTar
$LN1@CheckOnTar:

; 689  : 					}
; 690  : 					break;
; 691  : 				}
; 692  : 			}
; 693  : 			else
; 694  : 			{
; 695  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 696  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 697  : 			}
; 698  : 		}

	jmp	$LN8@CheckOnTar
$LN45@CheckOnTar:

; 699  : 		break;
; 700  : 	}
; 701  : 	}
; 702  : 	return false;

	xor	al, al
$LN48@CheckOnTar:

; 703  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN318@CheckOnTar:
	DD	$LN44@CheckOnTar
	DD	$LN34@CheckOnTar
	DD	$LN22@CheckOnTar
	DD	$LN10@CheckOnTar
?CheckOnTarget@CvAIOperation@@UAE_NXZ ENDP		; CvAIOperation::CheckOnTarget
_TEXT	ENDS
EXTRN	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ:PROC		; CvArmyAI::Plot
; Function compile flags: /Odtp
;	COMDAT ?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperation::ArmyInPosition, COMDAT
; _this$ = ecx

; 707  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 708  : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 709  : 
; 710  : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN4@ArmyInPosi
	cmp	DWORD PTR tv65[ebp], 3
	je	SHORT $LN3@ArmyInPosi
	jmp	SHORT $LN5@ArmyInPosi
$LN4@ArmyInPosi:

; 711  : 	{
; 712  : 		// If we were gathering forces, we're all set to move out
; 713  : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 714  : 	{
; 715  : 		m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 3

; 716  : 		bStateChanged = true;

	mov	BYTE PTR _bStateChanged$[ebp], 1

; 717  : 		pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 718  : 	}
; 719  : 	break;

	jmp	SHORT $LN5@ArmyInPosi
$LN3@ArmyInPosi:

; 720  : 
; 721  : 	// If we are moving to our target, check and see if we are there
; 722  : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 723  : 	{
; 724  : 		if(pArmy->Plot() == GetTargetPlot())

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	esi, eax
	jne	SHORT $LN5@ArmyInPosi

; 725  : 		{
; 726  : 			m_eCurrentState = AI_OPERATION_STATE_AT_TARGET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 4

; 727  : 			bStateChanged = true;

	mov	BYTE PTR _bStateChanged$[ebp], 1
$LN5@ArmyInPosi:

; 728  : 		}
; 729  : 	}
; 730  : 	break;
; 731  : 
; 732  : 	case AI_OPERATION_STATE_ABORTED:
; 733  : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 734  : 	case AI_OPERATION_STATE_AT_TARGET:
; 735  : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 736  : 		break;
; 737  : 	};
; 738  : 
; 739  : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]

; 740  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperation::ArmyInPosition
_TEXT	ENDS
EXTRN	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z:PROC ; CvStepPathFinder::GetStepDistanceBetweenPoints
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ:PROC	; CvArmyAI::GetGoalPlot
; Function compile flags: /Odtp
;	COMDAT ?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
_TEXT	SEGMENT
tv134 = -52						; size = 4
tv65 = -48						; size = 4
_this$ = -44						; size = 4
$T233739 = -40						; size = 4
$T233735 = -36						; size = 4
$T233731 = -32						; size = 4
_iTempValue$223391 = -28				; size = 4
_iDistanceCurrentToTarget$223385 = -24			; size = 4
_pCenterOfMass$223386 = -20				; size = 4
_iDistanceMusterToTarget$223384 = -16			; size = 4
_pArmy$223382 = -12					; size = 4
_uiI$223378 = -8					; size = 4
_iRtnValue$ = -4					; size = 4
?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ PROC ; CvAIOperation::PercentFromMusterPointToTarget, COMDAT
; _this$ = ecx

; 744  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 746  : 
; 747  : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 5
	ja	$LN14@PercentFro
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN26@PercentFro[edx*4]
$LN13@PercentFro:

; 748  : 	{
; 749  : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 750  : 	case AI_OPERATION_STATE_ABORTED:
; 751  : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 752  : 		return 0;

	xor	eax, eax
	jmp	$LN16@PercentFro
$LN12@PercentFro:

; 753  : 
; 754  : 	case AI_OPERATION_STATE_AT_TARGET:
; 755  : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 756  : 		return 100;

	mov	eax, 100				; 00000064H
	jmp	$LN16@PercentFro
$LN11@PercentFro:

; 757  : 
; 758  : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 759  : 	{
; 760  : 		// Let each army perform its own update
; 761  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223378[ebp], 0
	jmp	SHORT $LN10@PercentFro
$LN9@PercentFro:
	mov	eax, DWORD PTR _uiI$223378[ebp]
	add	eax, 1
	mov	DWORD PTR _uiI$223378[ebp], eax
$LN10@PercentFro:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T233731[ebp], ecx
	mov	edx, DWORD PTR $T233731[ebp]
	mov	eax, DWORD PTR $T233731[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _uiI$223378[ebp], ecx
	jae	$LN14@PercentFro

; 762  : 		{
; 763  : 			CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _uiI$223378[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T233735[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233739[ebp], ecx
	mov	edx, DWORD PTR $T233735[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR $T233739[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pArmy$223382[ebp], eax

; 764  : 
; 765  : 			if (pArmy->GetGoalPlot())

	mov	ecx, DWORD PTR _pArmy$223382[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	test	eax, eax
	je	$LN1@PercentFro

; 766  : 			{
; 767  : 				int iDistanceMusterToTarget;
; 768  : 				int iDistanceCurrentToTarget;
; 769  : 
; 770  : 				CvPlot *pCenterOfMass = pArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@PercentFro
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@PercentFro
	mov	DWORD PTR tv134[ebp], 2
	jmp	SHORT $LN19@PercentFro
$LN18@PercentFro:
	mov	DWORD PTR tv134[ebp], 0
$LN19@PercentFro:
	mov	ecx, DWORD PTR tv134[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$223382[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$223386[ebp], eax

; 771  : 
; 772  : 				// Use the step path finder to compute distance
; 773  : 				iDistanceMusterToTarget = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, GetMusterPlot(), pArmy->GetGoalPlot());

	mov	ecx, DWORD PTR _pArmy$223382[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	DWORD PTR _iDistanceMusterToTarget$223384[ebp], eax

; 774  : 				iDistanceCurrentToTarget = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pCenterOfMass, pArmy->GetGoalPlot());

	mov	ecx, DWORD PTR _pArmy$223382[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	push	eax
	mov	eax, DWORD PTR _pCenterOfMass$223386[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	DWORD PTR _iDistanceCurrentToTarget$223385[ebp], eax

; 775  : 
; 776  : 				if(iDistanceMusterToTarget <= 0)

	cmp	DWORD PTR _iDistanceMusterToTarget$223384[ebp], 0
	jg	SHORT $LN6@PercentFro

; 777  : 				{
; 778  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN16@PercentFro
	jmp	SHORT $LN1@PercentFro
$LN6@PercentFro:

; 779  : 				}
; 780  : 	
; 781  : 				// If within 2 of the final goal, consider ourselves there
; 782  : 				else if (iDistanceCurrentToTarget <= 2)

	cmp	DWORD PTR _iDistanceCurrentToTarget$223385[ebp], 2
	jg	SHORT $LN4@PercentFro

; 783  : 				{
; 784  : 					return 100;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN16@PercentFro

; 785  : 				}
; 786  : 
; 787  : 				else

	jmp	SHORT $LN1@PercentFro
$LN4@PercentFro:

; 788  : 				{
; 789  : 					int iTempValue = 100 - (100 * iDistanceCurrentToTarget / iDistanceMusterToTarget);

	mov	eax, DWORD PTR _iDistanceCurrentToTarget$223385[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iDistanceMusterToTarget$223384[ebp]
	mov	edx, 100				; 00000064H
	sub	edx, eax
	mov	DWORD PTR _iTempValue$223391[ebp], edx

; 790  : 					if(iTempValue > iRtnValue)

	mov	eax, DWORD PTR _iTempValue$223391[ebp]
	cmp	eax, DWORD PTR _iRtnValue$[ebp]
	jle	SHORT $LN1@PercentFro

; 791  : 					{
; 792  : 						iRtnValue = iTempValue;

	mov	ecx, DWORD PTR _iTempValue$223391[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], ecx
$LN1@PercentFro:

; 793  : 					}
; 794  : 				}
; 795  : 			}
; 796  : 			else 
; 797  : 			{
; 798  : 				CvAssertMsg (false, "Operational AI army without a goal plot!  Send save to Ed");
; 799  : 			}
; 800  : 		}

	jmp	$LN9@PercentFro
$LN14@PercentFro:

; 801  : 	}
; 802  : 	break;
; 803  : 	}
; 804  : 
; 805  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
$LN16@PercentFro:

; 806  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN26@PercentFro:
	DD	$LN13@PercentFro
	DD	$LN13@PercentFro
	DD	$LN13@PercentFro
	DD	$LN11@PercentFro
	DD	$LN12@PercentFro
	DD	$LN12@PercentFro
?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ ENDP ; CvAIOperation::PercentFromMusterPointToTarget
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z	; CvUnit::SetDeployFromOperationTurn
EXTRN	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:PROC ; CvArmyAI::GetNextUnit
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:PROC ; CvArmyAI::GetFirstUnit
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ShouldAbort@CvAIOperation@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$2
__ehfuncinfo$?ShouldAbort@CvAIOperation@@UAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ShouldAbort@CvAIOperation@@UAE_NXZ
_TEXT	SEGMENT
tv150 = -112						; size = 4
tv181 = -108						; size = 4
tv157 = -104						; size = 4
_this$ = -100						; size = 4
$T233848 = -96						; size = 4
$T233802 = -72						; size = 4
$T233798 = -68						; size = 4
$T233782 = -64						; size = 4
$T233765 = -60						; size = 4
$T233761 = -56						; size = 4
$T233757 = -52						; size = 4
$T233745 = -45						; size = 1
$T233744 = -44						; size = 8
$T233743 = -36						; size = 8
_pArmy$223403 = -28					; size = 4
_uiI$223399 = -24					; size = 4
_pUnit$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
?ShouldAbort@CvAIOperation@@UAE_NXZ PROC		; CvAIOperation::ShouldAbort, COMDAT
; _this$ = ecx

; 811  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShouldAbort@CvAIOperation@@UAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 812  : 	UnitHandle pUnit;

	mov	DWORD PTR _pUnit$[ebp], 0
	mov	BYTE PTR _pUnit$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 813  : 
; 814  : 	// Mark units in successful operation
; 815  : 	if(m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 5
	jne	$LN6@ShouldAbor

; 816  : 	{
; 817  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223399[ebp], 0
	jmp	SHORT $LN5@ShouldAbor
$LN4@ShouldAbor:
	mov	ecx, DWORD PTR _uiI$223399[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiI$223399[ebp], ecx
$LN5@ShouldAbor:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T233757[ebp], edx
	mov	eax, DWORD PTR $T233757[ebp]
	mov	ecx, DWORD PTR $T233757[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _uiI$223399[ebp], edx
	jae	$LN6@ShouldAbor

; 818  : 		{
; 819  : 			CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$223399[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T233761[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233765[ebp], edx
	mov	eax, DWORD PTR $T233761[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T233765[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pArmy$223403[ebp], eax

; 820  : 
; 821  : 			pUnit = pArmy->GetFirstUnit();

	lea	edx, DWORD PTR $T233743[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmy$223403[ebp]
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T233782[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T233782[ebp]
	lea	edx, DWORD PTR _pUnit$[ebp]
	cmp	ecx, edx
	je	SHORT $LN25@ShouldAbor
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN23@ShouldAbor
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN23@ShouldAbor:
	mov	eax, DWORD PTR $T233782[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pUnit$[ebp], ecx
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN25@ShouldAbor
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@ShouldAbor:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T233743[ebp], 0
	je	SHORT $LN36@ShouldAbor
	mov	ecx, DWORD PTR $T233743[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification

; 822  : 			while(pUnit)

$LN36@ShouldAbor:
	xor	edx, edx
	cmp	DWORD PTR _pUnit$[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@ShouldAbor

; 823  : 			{
; 824  : 				pUnit->SetDeployFromOperationTurn(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233798[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T233802[ebp], edx
	mov	ecx, DWORD PTR $T233798[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	ecx, DWORD PTR $T233802[ebp]
	call	?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z ; CvUnit::SetDeployFromOperationTurn

; 825  : 				pUnit = pArmy->GetNextUnit();

	lea	eax, DWORD PTR $T233744[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmy$223403[ebp]
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR tv181[ebp]
	mov	DWORD PTR $T233848[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T233848[ebp]
	lea	eax, DWORD PTR _pUnit$[ebp]
	cmp	edx, eax
	je	SHORT $LN55@ShouldAbor
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN53@ShouldAbor
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN53@ShouldAbor:
	mov	ecx, DWORD PTR $T233848[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pUnit$[ebp], edx
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN55@ShouldAbor
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN55@ShouldAbor:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T233744[ebp], 0
	je	SHORT $LN62@ShouldAbor
	mov	ecx, DWORD PTR $T233744[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@ShouldAbor:

; 826  : 			}

	jmp	$LN36@ShouldAbor
$LN1@ShouldAbor:

; 827  : 		}

	jmp	$LN4@ShouldAbor
$LN6@ShouldAbor:

; 828  : 	}
; 829  : 
; 830  : 	return (m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN9@ShouldAbor
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], 5
	je	SHORT $LN9@ShouldAbor
	mov	DWORD PTR tv150[ebp], 0
	jmp	SHORT $LN10@ShouldAbor
$LN9@ShouldAbor:
	mov	DWORD PTR tv150[ebp], 1
$LN10@ShouldAbor:
	mov	dl, BYTE PTR tv150[ebp]
	mov	BYTE PTR $T233745[ebp], dl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN67@ShouldAbor
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@ShouldAbor:
	mov	al, BYTE PTR $T233745[ebp]

; 831  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$1:
	lea	ecx, DWORD PTR $T233743[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$2:
	lea	ecx, DWORD PTR $T233744[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ShouldAbort@CvAIOperation@@UAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ShouldAbort@CvAIOperation@@UAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldAbort@CvAIOperation@@UAE_NXZ ENDP		; CvAIOperation::ShouldAbort
; Function compile flags: /Odtp
;	COMDAT ?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eReason$ = 8						; size = 4
?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z PROC ; CvAIOperation::SetToAbort, COMDAT
; _this$ = ecx

; 835  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 836  : 	m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 837  : 	m_eAbortReason = eReason;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eReason$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 838  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ENDP ; CvAIOperation::SetToAbort
_TEXT	ENDS
PUBLIC	?LogOperationEnd@CvAIOperation@@QAEXXZ		; CvAIOperation::LogOperationEnd
EXTRN	?deleteAIOperation@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::deleteAIOperation
; Function compile flags: /Odtp
;	COMDAT ?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_eOwner$ = -8						; size = 4
_iID$ = -4						; size = 4
_eReason$ = 8						; size = 4
?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z PROC ; CvAIOperation::Kill, COMDAT
; _this$ = ecx

; 842  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 	int iID = m_iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _iID$[ebp], ecx

; 844  : 	PlayerTypes eOwner = GetOwner();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _eOwner$[ebp], eax

; 845  : 
; 846  : 	if (m_eAbortReason == NO_ABORT_REASON)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+60], -1
	jne	SHORT $LN1@Kill

; 847  : 	{
; 848  : 		m_eAbortReason = eReason;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eReason$[ebp]
	mov	DWORD PTR [edx+60], eax
$LN1@Kill:

; 849  : 	}
; 850  : 
; 851  : 	LogOperationEnd();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationEnd@CvAIOperation@@QAEXXZ	; CvAIOperation::LogOperationEnd

; 852  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 853  : 	GET_PLAYER(eOwner).deleteAIOperation(iID);

	mov	ecx, DWORD PTR _iID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eOwner$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?deleteAIOperation@CvPlayer@@QAEXH@Z	; CvPlayer::deleteAIOperation

; 854  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ENDP ; CvAIOperation::Kill
_TEXT	ENDS
PUBLIC	?LogOperationStatus@CvAIOperation@@QAEXXZ	; CvAIOperation::LogOperationStatus
; Function compile flags: /Odtp
;	COMDAT ?DoTurn@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoTurn@CvAIOperation@@UAEXXZ PROC			; CvAIOperation::DoTurn, COMDAT
; _this$ = ecx

; 858  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 859  : 	LogOperationStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStatus@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStatus

; 860  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoTurn@CvAIOperation@@UAEXXZ ENDP			; CvAIOperation::DoTurn
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoDelayedDeath@CvAIOperation@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoDelayedDeath@CvAIOperation@@UAE_NXZ PROC		; CvAIOperation::DoDelayedDeath, COMDAT
; _this$ = ecx

; 864  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 865  : 	if(ShouldAbort())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@DoDelayedD

; 866  : 	{
; 867  : 		if (m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 5
	jne	SHORT $LN2@DoDelayedD

; 868  : 		{
; 869  : 			Kill(AI_ABORT_SUCCESS);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 870  : 		}
; 871  : 		else

	jmp	SHORT $LN1@DoDelayedD
$LN2@DoDelayedD:

; 872  : 		{
; 873  : 			Kill(AI_ABORT_KILLED);

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN1@DoDelayedD:

; 874  : 		}
; 875  : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@DoDelayedD
$LN3@DoDelayedD:

; 876  : 	}
; 877  : 
; 878  : 	return false;

	xor	al, al
$LN4@DoDelayedD:

; 879  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoDelayedDeath@CvAIOperation@@UAE_NXZ ENDP		; CvAIOperation::DoDelayedDeath
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getCitiesPerPlayer
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Odtp
;	COMDAT ?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T233912 = -60						; size = 4
$T233908 = -56						; size = 4
$T233904 = -52						; size = 4
$T233900 = -48						; size = 4
_pCity$223455 = -40					; size = 4
_pBestArea$ = -36					; size = 4
_pLoopArea$ = -32					; size = 4
_pCapitalCity$ = -28					; size = 4
_iMyCities$ = -24					; size = 4
_pBestCity$ = -20					; size = 4
_thisPlayer$ = -16					; size = 4
_iEnemyCities$ = -12					; size = 4
_iBestTotal$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ PROC ; CvAIOperation::GetOperationStartCity, COMDAT
; _this$ = ecx

; 883  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 	if(GetStartCityPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN18@GetOperati

; 885  : 	{
; 886  : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	jmp	$LN19@GetOperati
$LN18@GetOperati:

; 887  : 	}
; 888  : 
; 889  : 	CvCity* pCapitalCity;
; 890  : 	CvArea* pLoopArea;
; 891  : 	int iLoop;
; 892  : 	int iMyCities;
; 893  : 	int iEnemyCities;
; 894  : 	int iBestTotal = 0;

	mov	DWORD PTR _iBestTotal$[ebp], 0

; 895  : 	CvArea* pBestArea = NULL;

	mov	DWORD PTR _pBestArea$[ebp], 0

; 896  : 	CvCity* pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[ebp], 0

; 897  : 
; 898  : 	CvPlayer& thisPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[ebp], ecx

; 899  : 
; 900  : 	// Do we still have a capital?
; 901  : 	pCapitalCity = thisPlayer.getCapitalCity();

	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapitalCity$[ebp], eax

; 902  : 
; 903  : 	if(pCapitalCity != NULL)

	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	je	SHORT $LN17@GetOperati

; 904  : 	{
; 905  : 		return pCapitalCity;

	mov	eax, DWORD PTR _pCapitalCity$[ebp]
	jmp	$LN19@GetOperati
$LN17@GetOperati:

; 906  : 	}
; 907  : 
; 908  : 	// No capital, find the area with the most combined cities between us and our enemy (and need at least 1 from each)
; 909  : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233900[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233900[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
	jmp	SHORT $LN16@GetOperati
$LN15@GetOperati:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233904[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T233904[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
$LN16@GetOperati:
	cmp	DWORD PTR _pLoopArea$[ebp], 0
	je	$LN14@GetOperati

; 910  : 	{
; 911  : 		if(pLoopArea->isWater())

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@GetOperati

; 912  : 		{
; 913  : 			continue;

	jmp	SHORT $LN15@GetOperati
$LN13@GetOperati:

; 914  : 		}
; 915  : 
; 916  : 		iMyCities = pLoopArea->getCitiesPerPlayer(GetOwner());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T233908[ebp], edx
	mov	eax, DWORD PTR $T233908[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
	mov	DWORD PTR _iMyCities$[ebp], eax

; 917  : 		if(iMyCities > 0)

	cmp	DWORD PTR _iMyCities$[ebp], 0
	jle	SHORT $LN12@GetOperati

; 918  : 		{
; 919  : 			if(m_eEnemy != NO_PLAYER && m_eEnemy != BARBARIAN_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+76], -1
	je	SHORT $LN11@GetOperati
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 63			; 0000003fH
	je	SHORT $LN11@GetOperati

; 920  : 			{
; 921  : 				iEnemyCities = pLoopArea->getCitiesPerPlayer(m_eEnemy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
	mov	DWORD PTR _iEnemyCities$[ebp], eax

; 922  : 				if(iEnemyCities == 0)

	cmp	DWORD PTR _iEnemyCities$[ebp], 0
	jne	SHORT $LN10@GetOperati

; 923  : 				{
; 924  : 					continue;

	jmp	SHORT $LN15@GetOperati
$LN10@GetOperati:

; 925  : 				}
; 926  : 			}
; 927  : 			else

	jmp	SHORT $LN9@GetOperati
$LN11@GetOperati:

; 928  : 			{
; 929  : 				iEnemyCities = 0;

	mov	DWORD PTR _iEnemyCities$[ebp], 0
$LN9@GetOperati:

; 930  : 			}
; 931  : 
; 932  : 			if((iMyCities + iEnemyCities) > iBestTotal)

	mov	edx, DWORD PTR _iMyCities$[ebp]
	add	edx, DWORD PTR _iEnemyCities$[ebp]
	cmp	edx, DWORD PTR _iBestTotal$[ebp]
	jle	SHORT $LN12@GetOperati

; 933  : 			{
; 934  : 				iBestTotal = iMyCities + iEnemyCities;

	mov	eax, DWORD PTR _iMyCities$[ebp]
	add	eax, DWORD PTR _iEnemyCities$[ebp]
	mov	DWORD PTR _iBestTotal$[ebp], eax

; 935  : 				pBestArea = pLoopArea;

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	mov	DWORD PTR _pBestArea$[ebp], ecx
$LN12@GetOperati:

; 936  : 			}
; 937  : 		}
; 938  : 	}

	jmp	$LN15@GetOperati
$LN14@GetOperati:

; 939  : 
; 940  : 	if(pBestArea != NULL)

	cmp	DWORD PTR _pBestArea$[ebp], 0
	je	SHORT $LN7@GetOperati

; 941  : 	{
; 942  : 		// Know which continent to use, now use our largest city there as the start city
; 943  : 		CvCity* pCity;
; 944  : 		iBestTotal = 0;

	mov	DWORD PTR _iBestTotal$[ebp], 0

; 945  : 		for(pCity = thisPlayer.firstCity(&iLoop); pCity != NULL; pCity = thisPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$223455[ebp], eax
	jmp	SHORT $LN6@GetOperati
$LN5@GetOperati:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$223455[ebp], eax
$LN6@GetOperati:
	cmp	DWORD PTR _pCity$223455[ebp], 0
	je	SHORT $LN4@GetOperati

; 946  : 		{
; 947  : 			if(pCity->getArea() == pBestArea->GetID())

	mov	ecx, DWORD PTR _pBestArea$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T233912[ebp], edx
	mov	ecx, DWORD PTR _pCity$223455[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	eax, DWORD PTR $T233912[ebp]
	jne	SHORT $LN3@GetOperati

; 948  : 			{
; 949  : 				if(pCity->getPopulation() > iBestTotal)

	mov	ecx, DWORD PTR _pCity$223455[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, DWORD PTR _iBestTotal$[ebp]
	jle	SHORT $LN3@GetOperati

; 950  : 				{
; 951  : 					iBestTotal = pCity->getPopulation();

	mov	ecx, DWORD PTR _pCity$223455[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	DWORD PTR _iBestTotal$[ebp], eax

; 952  : 					pBestCity = pCity;

	mov	eax, DWORD PTR _pCity$223455[ebp]
	mov	DWORD PTR _pBestCity$[ebp], eax
$LN3@GetOperati:

; 953  : 				}
; 954  : 			}
; 955  : 		}

	jmp	SHORT $LN5@GetOperati
$LN4@GetOperati:

; 956  : 		return pBestCity;

	mov	eax, DWORD PTR _pBestCity$[ebp]
	jmp	SHORT $LN19@GetOperati

; 957  : 	}
; 958  : 	else

	jmp	SHORT $LN19@GetOperati
$LN7@GetOperati:

; 959  : 	{
; 960  : 		return NULL;

	xor	eax, eax
$LN19@GetOperati:

; 961  : 	}
; 962  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ ENDP ; CvAIOperation::GetOperationStartCity
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Odtp
;	COMDAT ?DeleteArmyAI@CvAIOperation@@QAE_NH@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T233960 = -28						; size = 4
$T233936 = -24						; size = 4
$T233918 = -20						; size = 4
$T233917 = -16						; size = 4
$T233916 = -12						; size = 4
$T233915 = -8						; size = 4
_iter$ = -4						; size = 4
_iID$ = 8						; size = 4
?DeleteArmyAI@CvAIOperation@@QAE_NH@Z PROC		; CvAIOperation::DeleteArmyAI, COMDAT
; _this$ = ecx

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 	std::vector<int>::iterator iter;

	mov	DWORD PTR _iter$[ebp], 0

; 968  : 	for(iter = m_viArmyIDs.begin(); iter != m_viArmyIDs.end(); ++iter)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T233936[ebp], ecx
	mov	edx, DWORD PTR $T233936[ebp]
	mov	DWORD PTR $T233915[ebp], edx
	mov	eax, DWORD PTR $T233915[ebp]
	mov	DWORD PTR _iter$[ebp], eax
	jmp	SHORT $LN4@DeleteArmy
$LN3@DeleteArmy:
	mov	ecx, DWORD PTR _iter$[ebp]
	add	ecx, 4
	mov	DWORD PTR _iter$[ebp], ecx
$LN4@DeleteArmy:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T233960[ebp], eax
	mov	ecx, DWORD PTR $T233960[ebp]
	mov	DWORD PTR $T233916[ebp], ecx
	mov	edx, DWORD PTR _iter$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T233916[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@DeleteArmy

; 969  : 	{
; 970  : 		if(*iter == iID)

	mov	eax, DWORD PTR _iter$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _iID$[ebp]
	jne	SHORT $LN1@DeleteArmy

; 971  : 		{
; 972  : 			m_viArmyIDs.erase(iter);

	mov	edx, DWORD PTR _iter$[ebp]
	mov	DWORD PTR $T233917[ebp], edx
	mov	eax, DWORD PTR $T233917[ebp]
	push	eax
	lea	ecx, DWORD PTR $T233918[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::erase

; 973  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@DeleteArmy
$LN1@DeleteArmy:

; 974  : 		}
; 975  : 	}

	jmp	SHORT $LN3@DeleteArmy
$LN2@DeleteArmy:

; 976  : 	return false;

	xor	al, al
$LN5@DeleteArmy:

; 977  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteArmyAI@CvAIOperation@@QAE_NH@Z ENDP		; CvAIOperation::DeleteArmyAI
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
_TEXT	SEGMENT
tv65 = -88						; size = 4
_this$ = -84						; size = 4
$T234177 = -80						; size = 4
_pkFormation$223493 = -20				; size = 4
_pThisArmy$223492 = -16					; size = 4
_slotToFill$223490 = -12				; size = 12
_iArmyID$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAIOperation@@UAEXHH@Z PROC		; CvAIOperation::UnitWasRemoved, COMDAT
; _this$ = ecx

; 981  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 	// For now, response is based on phase of operation
; 983  : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN5@UnitWasRem
	cmp	DWORD PTR tv65[ebp], 1
	jle	$LN9@UnitWasRem
	cmp	DWORD PTR tv65[ebp], 4
	jle	SHORT $LN4@UnitWasRem
	jmp	$LN9@UnitWasRem

; 984  : 	{
; 985  : 	case AI_OPERATION_STATE_ABORTED:
; 986  : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 987  : 		break;

	jmp	$LN9@UnitWasRem
$LN5@UnitWasRem:

; 988  : 
; 989  : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 990  : 	{
; 991  : 		// If recruiting units, read this unit to the list of what we need
; 992  : 		OperationSlot slotToFill;

	mov	DWORD PTR _slotToFill$223490[ebp], -1
	mov	DWORD PTR _slotToFill$223490[ebp+4], -1
	mov	DWORD PTR _slotToFill$223490[ebp+8], -1

; 993  : 
; 994  : 		slotToFill.m_iOperationID = m_iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _slotToFill$223490[ebp], eax

; 995  : 		slotToFill.m_iArmyID = iArmyID;

	mov	ecx, DWORD PTR _iArmyID$[ebp]
	mov	DWORD PTR _slotToFill$223490[ebp+4], ecx

; 996  : 		slotToFill.m_iSlotID = iSlotID;

	mov	edx, DWORD PTR _iSlotID$[ebp]
	mov	DWORD PTR _slotToFill$223490[ebp+8], edx

; 997  : 		m_viListOfUnitsWeStillNeedToBuild.push_back(slotToFill);

	lea	eax, DWORD PTR _slotToFill$223490[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 998  : 	}
; 999  : 	break;

	jmp	SHORT $LN9@UnitWasRem
$LN4@UnitWasRem:

; 1000 : 
; 1001 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 1002 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1003 : 	case AI_OPERATION_STATE_AT_TARGET:
; 1004 : 	{
; 1005 : 		// If down below half strength, abort
; 1006 : 		CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(iArmyID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234177[ebp], edx
	mov	eax, DWORD PTR _iArmyID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234177[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223492[ebp], eax

; 1007 : 		CvMultiUnitFormationInfo* pkFormation = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, DWORD PTR _pThisArmy$223492[ebp]
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	DWORD PTR _pkFormation$223493[ebp], eax

; 1008 : 		if(pkFormation)

	cmp	DWORD PTR _pkFormation$223493[ebp], 0
	je	SHORT $LN9@UnitWasRem

; 1009 : 		{
; 1010 : 			if(pThisArmy->GetNumSlotsFilled() <=0 ||
; 1011 : 			        pThisArmy->GetNumSlotsFilled() < pkFormation->getNumFormationSlotEntries() / 2)

	mov	ecx, DWORD PTR _pThisArmy$223492[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	test	eax, eax
	jle	SHORT $LN1@UnitWasRem
	mov	ecx, DWORD PTR _pThisArmy$223492[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	mov	esi, eax
	mov	ecx, DWORD PTR _pkFormation$223493[ebp]
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	esi, eax
	jge	SHORT $LN9@UnitWasRem
$LN1@UnitWasRem:

; 1012 : 			{
; 1013 : 				// Abort
; 1014 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 1015 : 				m_eAbortReason = AI_ABORT_HALF_STRENGTH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 6
$LN9@UnitWasRem:

; 1016 : 			}
; 1017 : 		}
; 1018 : 	}
; 1019 : 	break;
; 1020 : 	};
; 1021 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?UnitWasRemoved@CvAIOperation@@UAEXHH@Z ENDP		; CvAIOperation::UnitWasRemoved
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
PUBLIC	?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back
PUBLIC	?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z ; BaseVector<CvAStarNode *,1>::Destroy
PUBLIC	??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::FStaticVector<CvAStarNode *,200,1,297,0>
PUBLIC	__$ArrayPad$
EXTRN	?GetMovementRate@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetMovementRate
EXTRN	?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC	; StepDestValid
EXTRN	?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepValid
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepValidAnyArea
EXTRN	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z:PROC ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z$0
__ehfuncinfo$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
_TEXT	SEGMENT
tv453 = -1124						; size = 4
tv468 = -1120						; size = 4
tv413 = -1116						; size = 4
tv428 = -1112						; size = 4
tv245 = -1108						; size = 4
tv400 = -1104						; size = 4
tv149 = -1100						; size = 4
tv72 = -1096						; size = 4
_this$ = -1092						; size = 4
$T234494 = -1064					; size = 4
$T234493 = -1060					; size = 4
$T234492 = -1056					; size = 4
$T234447 = -1052					; size = 4
$T234434 = -1048					; size = 4
$T234430 = -1044					; size = 4
$T234416 = -1040					; size = 4
$T234412 = -1033					; size = 1
$T234401 = -1032					; size = 4
$T234397 = -1025					; size = 1
_iMapY$234456 = -1024					; size = 4
_iMapX$234455 = -1020					; size = 4
$T234390 = -1016					; size = 4
$T234386 = -1012					; size = 4
$T234385 = -1008					; size = 4
$T234340 = -1004					; size = 4
$T234327 = -1000					; size = 4
$T234323 = -996						; size = 4
$T234309 = -992						; size = 4
$T234305 = -985						; size = 1
$T234294 = -984						; size = 4
$T234290 = -977						; size = 1
_iMapY$234349 = -976					; size = 4
_iMapX$234348 = -972					; size = 4
$T234283 = -968						; size = 4
$T234271 = -964						; size = 4
$T234262 = -960						; size = 4
$T234255 = -956						; size = 4
$T234244 = -948						; size = 4
$T234243 = -944						; size = 4
$T234239 = -940						; size = 4
$T234235 = -936						; size = 4
$T234231 = -932						; size = 4
$T234227 = -928						; size = 4
$T234223 = -924						; size = 4
$T234219 = -920						; size = 4
$T234215 = -916						; size = 4
$T234211 = -912						; size = 4
$T234207 = -908						; size = 4
$T234206 = -904						; size = 4
$T234186 = -900						; size = 4
$T234185 = -896						; size = 4
$T234184 = -892						; size = 4
$T234183 = -888						; size = 4
_iNode2Index$223599 = -884				; size = 4
_iJumpAhead$223595 = -880				; size = 4
_iNode1Index$223596 = -876				; size = 4
_bFound$223590 = -869					; size = 1
_pLastTurnArmyPlot$223512 = -868			; size = 4
_pNode1$223513 = -864					; size = 4
_pCenterOfMass$223511 = -860				; size = 4
_pGoalPlot$223587 = -856				; size = 4
_pNode2$223514 = -852					; size = 4
_iLastNodeIndex$223515 = -848				; size = 4
_m_NodesOnPath$223586 = -844				; size = 816
__$ArrayPad$ = -24					; size = 4
_pRtnValue$ = -20					; size = 4
_kPlayer$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
_ppClosestCurrentCOMonPath$ = 12			; size = 4
?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z PROC ; CvAIOperation::ComputeCenterOfMassForTurn, COMDAT
; _this$ = ecx

; 1025 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1112				; 00000458H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1026 : 	CvPlot* pRtnValue = NULL;

	mov	DWORD PTR _pRtnValue$[ebp], 0

; 1027 : 	CvPlayer &kPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], ecx

; 1028 : 
; 1029 : 	switch(m_eCurrentState)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 0
	jle	$LN10@ComputeCen
	cmp	DWORD PTR tv72[ebp], 2
	jle	SHORT $LN8@ComputeCen
	cmp	DWORD PTR tv72[ebp], 3
	je	SHORT $LN7@ComputeCen
	jmp	$LN10@ComputeCen

; 1030 : 	{
; 1031 : 	case AI_OPERATION_STATE_ABORTED:
; 1032 : 	case AI_OPERATION_STATE_AT_TARGET:
; 1033 : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 1034 : 		break;

	jmp	$LN10@ComputeCen
$LN8@ComputeCen:

; 1035 : 
; 1036 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 1037 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 1038 : 		// Just use the muster point if we're still recruiting/gathering
; 1039 : 		pRtnValue = GetMusterPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR _pRtnValue$[ebp], eax

; 1040 : 		break;

	jmp	$LN10@ComputeCen
$LN7@ComputeCen:

; 1041 : 
; 1042 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1043 : 		{
; 1044 : 			CvPlot* pCenterOfMass = 0;

	mov	DWORD PTR _pCenterOfMass$223511[ebp], 0

; 1045 : 			CvPlot* pLastTurnArmyPlot = 0;

	mov	DWORD PTR _pLastTurnArmyPlot$223512[ebp], 0

; 1046 : 			CvAStarNode* pNode1 = 0;

	mov	DWORD PTR _pNode1$223513[ebp], 0

; 1047 : 			CvAStarNode* pNode2 = 0;

	mov	DWORD PTR _pNode2$223514[ebp], 0

; 1048 : 			int iLastNodeIndex = 0;

	mov	DWORD PTR _iLastNodeIndex$223515[ebp], 0

; 1049 : 			FStaticVector<CvAStarNode*, SAFE_ESTIMATE_MAX_PATH_LEN, true, c_eCiv5GameplayDLL, 0> m_NodesOnPath;

	lea	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	call	??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::FStaticVector<CvAStarNode *,200,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1050 : 
; 1051 : 			m_NodesOnPath.clear();

	mov	ecx, DWORD PTR _m_NodesOnPath$223586[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _m_NodesOnPath$223586[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	call	?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z ; BaseVector<CvAStarNode *,1>::Destroy
	mov	DWORD PTR _m_NodesOnPath$223586[ebp+4], 0

; 1052 : 
; 1053 : 			// Is goal a city and we're a naval operation?  If so, go just offshore.
; 1054 : 			CvPlot *pGoalPlot = pArmy->GetGoalPlot();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR _pGoalPlot$223587[ebp], eax

; 1055 : 			if (!pGoalPlot->isWater() && IsAllNavalOperation())

	mov	eax, DWORD PTR _pGoalPlot$223587[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN6@ComputeCen
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@ComputeCen

; 1056 : 			{
; 1057 : 				pGoalPlot = kPlayer.GetMilitaryAI()->GetCoastalPlotAdjacentToTarget(pGoalPlot, pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	eax, DWORD PTR _pGoalPlot$223587[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	DWORD PTR _pGoalPlot$223587[ebp], eax
$LN6@ComputeCen:

; 1058 : 			}
; 1059 : 
; 1060 : 			pLastTurnArmyPlot = pArmy->Plot();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	DWORD PTR _pLastTurnArmyPlot$223512[ebp], eax

; 1061 : 			pCenterOfMass = pArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN14@ComputeCen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@ComputeCen
	mov	DWORD PTR tv149[ebp], 2
	jmp	SHORT $LN15@ComputeCen
$LN14@ComputeCen:
	mov	DWORD PTR tv149[ebp], 0
$LN15@ComputeCen:
	mov	ecx, DWORD PTR tv149[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$223511[ebp], eax

; 1062 : 			if (pLastTurnArmyPlot && pCenterOfMass && pGoalPlot)

	cmp	DWORD PTR _pLastTurnArmyPlot$223512[ebp], 0
	je	$LN5@ComputeCen
	cmp	DWORD PTR _pCenterOfMass$223511[ebp], 0
	je	$LN5@ComputeCen
	cmp	DWORD PTR _pGoalPlot$223587[ebp], 0
	je	$LN5@ComputeCen

; 1063 : 			{
; 1064 : 				// Push center of mass forward a number of hexes equal to average movement
; 1065 : #ifdef AUI_WARNING_FIXES
; 1066 : 				CvStepPathFinder& kStepFinder = GC.getStepFinder();
; 1067 : 				kStepFinder.SetData(&m_eEnemy);
; 1068 : 				kStepFinder.SetDestValidFunc(NULL); // remove the area check
; 1069 : 				kStepFinder.SetValidFunc(StepValidAnyArea); // remove the area check
; 1070 : 				bool bFound = kStepFinder.GeneratePath(pCenterOfMass->getX(), pCenterOfMass->getY(), pGoalPlot->getX(), pGoalPlot->getY(), m_eOwner, false);
; 1071 : 				kStepFinder.SetValidFunc(StepValid); // remove the area check
; 1072 : 				kStepFinder.SetDestValidFunc(StepDestValid); // restore the area check
; 1073 : 				if (bFound)
; 1074 : 				{
; 1075 : 					pNode1 = kStepFinder.GetLastNode();
; 1076 : #else
; 1077 : 				GC.getStepFinder().SetData(&m_eEnemy);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR $T234207[ebp], edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T234206[ebp], eax
	mov	eax, DWORD PTR $T234206[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN28@ComputeCen
	mov	edx, DWORD PTR $T234206[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR $T234207[ebp]
	je	SHORT $LN28@ComputeCen
	mov	ecx, DWORD PTR $T234206[ebp]
	mov	BYTE PTR [ecx+78], 1
$LN28@ComputeCen:
	mov	edx, DWORD PTR $T234206[ebp]
	mov	eax, DWORD PTR $T234207[ebp]
	mov	DWORD PTR [edx+44], eax

; 1078 : 				GC.getStepFinder().SetDestValidFunc(NULL); // remove the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T234211[ebp], eax
	mov	ecx, DWORD PTR $T234211[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1079 : 				GC.getStepFinder().SetValidFunc(StepValidAnyArea); // remove the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T234215[ebp], eax
	mov	edx, DWORD PTR $T234215[ebp]
	mov	DWORD PTR [edx+16], OFFSET ?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValidAnyArea

; 1080 : 				bool bFound = GC.getStepFinder().GeneratePath(pCenterOfMass->getX(), pCenterOfMass->getY(), pGoalPlot->getX(), pGoalPlot->getY(), m_eOwner, false);

	mov	eax, DWORD PTR _pGoalPlot$223587[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T234219[ebp], ecx
	mov	edx, DWORD PTR _pGoalPlot$223587[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T234223[ebp], eax
	mov	ecx, DWORD PTR _pCenterOfMass$223511[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T234227[ebp], edx
	mov	eax, DWORD PTR _pCenterOfMass$223511[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T234231[ebp], ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR $T234219[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234223[ebp]
	push	edx
	mov	eax, DWORD PTR $T234227[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234231[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bFound$223590[ebp], al

; 1081 : 				GC.getStepFinder().SetValidFunc(StepValid); // remove the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T234235[ebp], eax
	mov	edx, DWORD PTR $T234235[ebp]
	mov	DWORD PTR [edx+16], OFFSET ?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValid

; 1082 : 				GC.getStepFinder().SetDestValidFunc(StepDestValid); // restore the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T234239[ebp], eax
	mov	eax, DWORD PTR $T234239[ebp]
	mov	DWORD PTR [eax+4], OFFSET ?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z ; StepDestValid

; 1083 : 				if (bFound)

	movzx	ecx, BYTE PTR _bFound$223590[ebp]
	test	ecx, ecx
	je	$LN4@ComputeCen

; 1084 : 				{
; 1085 : 					pNode1 = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T234243[ebp], eax
	mov	edx, DWORD PTR $T234243[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T234244[ebp], eax
	mov	ecx, DWORD PTR $T234244[ebp]
	mov	DWORD PTR _pNode1$223513[ebp], ecx
$LN3@ComputeCen:

; 1086 : #endif
; 1087 : 
; 1088 : 					// Starting at the end, loop through the entire path
; 1089 : 					while (pNode1)

	cmp	DWORD PTR _pNode1$223513[ebp], 0
	je	SHORT $LN2@ComputeCen

; 1090 : 					{
; 1091 : 						m_NodesOnPath.push_back(pNode1);

	lea	edx, DWORD PTR _pNode1$223513[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	call	?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back

; 1092 : 						pNode1 = pNode1->m_pParent;

	mov	eax, DWORD PTR _pNode1$223513[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pNode1$223513[ebp], ecx

; 1093 : 					}

	jmp	SHORT $LN3@ComputeCen
$LN2@ComputeCen:

; 1094 : 
; 1095 : 					iLastNodeIndex = m_NodesOnPath.size() - 1;

	mov	edx, DWORD PTR _m_NodesOnPath$223586[ebp+4]
	mov	DWORD PTR $T234255[ebp], edx
	mov	eax, DWORD PTR $T234255[ebp]
	sub	eax, 1
	mov	DWORD PTR _iLastNodeIndex$223515[ebp], eax

; 1096 : 
; 1097 : 					// Move back up path from best node a number of spaces equal to army's movement rate + 1
; 1098 : 					int iJumpAhead = pArmy->GetMovementRate() + 1;

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetMovementRate@CvArmyAI@@QAEHXZ	; CvArmyAI::GetMovementRate
	add	eax, 1
	mov	DWORD PTR _iJumpAhead$223595[ebp], eax

; 1099 : 					int iNode1Index = max(0, iLastNodeIndex - iJumpAhead);

	mov	ecx, DWORD PTR _iLastNodeIndex$223515[ebp]
	sub	ecx, DWORD PTR _iJumpAhead$223595[ebp]
	mov	DWORD PTR $T234183[ebp], ecx
	mov	DWORD PTR $T234184[ebp], 0
	mov	edx, DWORD PTR $T234184[ebp]
	cmp	edx, DWORD PTR $T234183[ebp]
	jge	SHORT $LN60@ComputeCen
	lea	eax, DWORD PTR $T234183[ebp]
	mov	DWORD PTR tv400[ebp], eax
	jmp	SHORT $LN61@ComputeCen
$LN60@ComputeCen:
	lea	ecx, DWORD PTR $T234184[ebp]
	mov	DWORD PTR tv400[ebp], ecx
$LN61@ComputeCen:
	mov	edx, DWORD PTR tv400[ebp]
	mov	DWORD PTR $T234262[ebp], edx
	mov	eax, DWORD PTR $T234262[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNode1Index$223596[ebp], ecx

; 1100 : 					int iNode2Index = min(iNode1Index + 2, iLastNodeIndex);

	mov	edx, DWORD PTR _iNode1Index$223596[ebp]
	add	edx, 2
	mov	DWORD PTR $T234185[ebp], edx
	mov	eax, DWORD PTR _iLastNodeIndex$223515[ebp]
	cmp	eax, DWORD PTR $T234185[ebp]
	jge	SHORT $LN64@ComputeCen
	lea	ecx, DWORD PTR _iLastNodeIndex$223515[ebp]
	mov	DWORD PTR tv245[ebp], ecx
	jmp	SHORT $LN65@ComputeCen
$LN64@ComputeCen:
	lea	edx, DWORD PTR $T234185[ebp]
	mov	DWORD PTR tv245[ebp], edx
$LN65@ComputeCen:
	mov	eax, DWORD PTR tv245[ebp]
	mov	DWORD PTR $T234271[ebp], eax
	mov	ecx, DWORD PTR $T234271[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNode2Index$223599[ebp], edx

; 1101 : 					pNode1 = m_NodesOnPath[iNode1Index];

	mov	eax, DWORD PTR _iNode1Index$223596[ebp]
	mov	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pNode1$223513[ebp], edx

; 1102 : 					pNode2 = m_NodesOnPath[iNode2Index];

	mov	eax, DWORD PTR _iNode2Index$223599[ebp]
	mov	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pNode2$223514[ebp], edx

; 1103 : 					
; 1104 : 					pRtnValue = GC.getMap().plot(pNode1->m_iX, pNode1->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234283[ebp], eax
	mov	ecx, DWORD PTR _pNode1$223513[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T234386[ebp], edx
	mov	eax, DWORD PTR _pNode1$223513[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T234385[ebp], ecx
	cmp	DWORD PTR $T234385[ebp], -2147483647	; 80000001H
	je	SHORT $LN72@ComputeCen
	cmp	DWORD PTR $T234386[ebp], -2147483647	; 80000001H
	jne	SHORT $LN73@ComputeCen
$LN72@ComputeCen:
	mov	DWORD PTR _pRtnValue$[ebp], 0
	jmp	$LN74@ComputeCen
$LN73@ComputeCen:
	mov	edx, DWORD PTR $T234283[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T234290[ebp], al
	mov	ecx, DWORD PTR $T234283[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T234294[ebp], edx
	movzx	eax, BYTE PTR $T234290[ebp]
	test	eax, eax
	je	SHORT $LN85@ComputeCen
	cmp	DWORD PTR $T234385[ebp], 0
	jge	SHORT $LN84@ComputeCen
	mov	eax, DWORD PTR $T234385[ebp]
	cdq
	idiv	DWORD PTR $T234294[ebp]
	add	edx, DWORD PTR $T234294[ebp]
	mov	DWORD PTR _iMapX$234348[ebp], edx
	jmp	SHORT $LN86@ComputeCen
	jmp	SHORT $LN85@ComputeCen
$LN84@ComputeCen:
	mov	ecx, DWORD PTR $T234385[ebp]
	cmp	ecx, DWORD PTR $T234294[ebp]
	jl	SHORT $LN85@ComputeCen
	mov	eax, DWORD PTR $T234385[ebp]
	cdq
	idiv	DWORD PTR $T234294[ebp]
	mov	DWORD PTR _iMapX$234348[ebp], edx
	jmp	SHORT $LN86@ComputeCen
$LN85@ComputeCen:
	mov	edx, DWORD PTR $T234385[ebp]
	mov	DWORD PTR _iMapX$234348[ebp], edx
$LN86@ComputeCen:
	mov	eax, DWORD PTR $T234283[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T234305[ebp], cl
	mov	edx, DWORD PTR $T234283[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T234309[ebp], eax
	movzx	ecx, BYTE PTR $T234305[ebp]
	test	ecx, ecx
	je	SHORT $LN95@ComputeCen
	cmp	DWORD PTR $T234386[ebp], 0
	jge	SHORT $LN94@ComputeCen
	mov	eax, DWORD PTR $T234386[ebp]
	cdq
	idiv	DWORD PTR $T234309[ebp]
	add	edx, DWORD PTR $T234309[ebp]
	mov	DWORD PTR _iMapY$234349[ebp], edx
	jmp	SHORT $LN96@ComputeCen
	jmp	SHORT $LN95@ComputeCen
$LN94@ComputeCen:
	mov	edx, DWORD PTR $T234386[ebp]
	cmp	edx, DWORD PTR $T234309[ebp]
	jl	SHORT $LN95@ComputeCen
	mov	eax, DWORD PTR $T234386[ebp]
	cdq
	idiv	DWORD PTR $T234309[ebp]
	mov	DWORD PTR _iMapY$234349[ebp], edx
	jmp	SHORT $LN96@ComputeCen
$LN95@ComputeCen:
	mov	eax, DWORD PTR $T234386[ebp]
	mov	DWORD PTR _iMapY$234349[ebp], eax
$LN96@ComputeCen:
	cmp	DWORD PTR _iMapX$234348[ebp], 0
	jl	SHORT $LN100@ComputeCen
	mov	ecx, DWORD PTR $T234283[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T234323[ebp], edx
	mov	eax, DWORD PTR _iMapX$234348[ebp]
	cmp	eax, DWORD PTR $T234323[ebp]
	jge	SHORT $LN100@ComputeCen
	cmp	DWORD PTR _iMapY$234349[ebp], 0
	jl	SHORT $LN100@ComputeCen
	mov	ecx, DWORD PTR $T234283[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T234327[ebp], edx
	mov	eax, DWORD PTR _iMapY$234349[ebp]
	cmp	eax, DWORD PTR $T234327[ebp]
	jge	SHORT $LN100@ComputeCen
	mov	DWORD PTR tv428[ebp], 1
	jmp	SHORT $LN98@ComputeCen
$LN100@ComputeCen:
	mov	DWORD PTR tv428[ebp], 0
$LN98@ComputeCen:
	cmp	DWORD PTR tv428[ebp], 0
	je	SHORT $LN76@ComputeCen
	mov	ecx, DWORD PTR $T234283[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T234340[ebp], edx
	mov	eax, DWORD PTR _iMapY$234349[ebp]
	imul	eax, DWORD PTR $T234340[ebp]
	add	eax, DWORD PTR _iMapX$234348[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T234283[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv413[ebp], eax
	jmp	SHORT $LN77@ComputeCen
$LN76@ComputeCen:
	mov	DWORD PTR tv413[ebp], 0
$LN77@ComputeCen:
	mov	edx, DWORD PTR tv413[ebp]
	mov	DWORD PTR _pRtnValue$[ebp], edx
$LN74@ComputeCen:

; 1105 : 					*ppClosestCurrentCOMonPath = GC.getMap().plot(pNode2->m_iX, pNode2->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234390[ebp], eax
	mov	ecx, DWORD PTR _pNode2$223514[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T234493[ebp], edx
	mov	eax, DWORD PTR _pNode2$223514[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T234492[ebp], ecx
	cmp	DWORD PTR $T234492[ebp], -2147483647	; 80000001H
	je	SHORT $LN112@ComputeCen
	cmp	DWORD PTR $T234493[ebp], -2147483647	; 80000001H
	jne	SHORT $LN113@ComputeCen
$LN112@ComputeCen:
	mov	DWORD PTR $T234494[ebp], 0
	jmp	$LN114@ComputeCen
$LN113@ComputeCen:
	mov	edx, DWORD PTR $T234390[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T234397[ebp], al
	mov	ecx, DWORD PTR $T234390[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T234401[ebp], edx
	movzx	eax, BYTE PTR $T234397[ebp]
	test	eax, eax
	je	SHORT $LN125@ComputeCen
	cmp	DWORD PTR $T234492[ebp], 0
	jge	SHORT $LN124@ComputeCen
	mov	eax, DWORD PTR $T234492[ebp]
	cdq
	idiv	DWORD PTR $T234401[ebp]
	add	edx, DWORD PTR $T234401[ebp]
	mov	DWORD PTR _iMapX$234455[ebp], edx
	jmp	SHORT $LN126@ComputeCen
	jmp	SHORT $LN125@ComputeCen
$LN124@ComputeCen:
	mov	ecx, DWORD PTR $T234492[ebp]
	cmp	ecx, DWORD PTR $T234401[ebp]
	jl	SHORT $LN125@ComputeCen
	mov	eax, DWORD PTR $T234492[ebp]
	cdq
	idiv	DWORD PTR $T234401[ebp]
	mov	DWORD PTR _iMapX$234455[ebp], edx
	jmp	SHORT $LN126@ComputeCen
$LN125@ComputeCen:
	mov	edx, DWORD PTR $T234492[ebp]
	mov	DWORD PTR _iMapX$234455[ebp], edx
$LN126@ComputeCen:
	mov	eax, DWORD PTR $T234390[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T234412[ebp], cl
	mov	edx, DWORD PTR $T234390[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T234416[ebp], eax
	movzx	ecx, BYTE PTR $T234412[ebp]
	test	ecx, ecx
	je	SHORT $LN135@ComputeCen
	cmp	DWORD PTR $T234493[ebp], 0
	jge	SHORT $LN134@ComputeCen
	mov	eax, DWORD PTR $T234493[ebp]
	cdq
	idiv	DWORD PTR $T234416[ebp]
	add	edx, DWORD PTR $T234416[ebp]
	mov	DWORD PTR _iMapY$234456[ebp], edx
	jmp	SHORT $LN136@ComputeCen
	jmp	SHORT $LN135@ComputeCen
$LN134@ComputeCen:
	mov	edx, DWORD PTR $T234493[ebp]
	cmp	edx, DWORD PTR $T234416[ebp]
	jl	SHORT $LN135@ComputeCen
	mov	eax, DWORD PTR $T234493[ebp]
	cdq
	idiv	DWORD PTR $T234416[ebp]
	mov	DWORD PTR _iMapY$234456[ebp], edx
	jmp	SHORT $LN136@ComputeCen
$LN135@ComputeCen:
	mov	eax, DWORD PTR $T234493[ebp]
	mov	DWORD PTR _iMapY$234456[ebp], eax
$LN136@ComputeCen:
	cmp	DWORD PTR _iMapX$234455[ebp], 0
	jl	SHORT $LN140@ComputeCen
	mov	ecx, DWORD PTR $T234390[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T234430[ebp], edx
	mov	eax, DWORD PTR _iMapX$234455[ebp]
	cmp	eax, DWORD PTR $T234430[ebp]
	jge	SHORT $LN140@ComputeCen
	cmp	DWORD PTR _iMapY$234456[ebp], 0
	jl	SHORT $LN140@ComputeCen
	mov	ecx, DWORD PTR $T234390[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T234434[ebp], edx
	mov	eax, DWORD PTR _iMapY$234456[ebp]
	cmp	eax, DWORD PTR $T234434[ebp]
	jge	SHORT $LN140@ComputeCen
	mov	DWORD PTR tv468[ebp], 1
	jmp	SHORT $LN138@ComputeCen
$LN140@ComputeCen:
	mov	DWORD PTR tv468[ebp], 0
$LN138@ComputeCen:
	cmp	DWORD PTR tv468[ebp], 0
	je	SHORT $LN116@ComputeCen
	mov	ecx, DWORD PTR $T234390[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T234447[ebp], edx
	mov	eax, DWORD PTR _iMapY$234456[ebp]
	imul	eax, DWORD PTR $T234447[ebp]
	add	eax, DWORD PTR _iMapX$234455[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T234390[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv453[ebp], eax
	jmp	SHORT $LN117@ComputeCen
$LN116@ComputeCen:
	mov	DWORD PTR tv453[ebp], 0
$LN117@ComputeCen:
	mov	edx, DWORD PTR tv453[ebp]
	mov	DWORD PTR $T234494[ebp], edx
$LN114@ComputeCen:
	mov	eax, DWORD PTR _ppClosestCurrentCOMonPath$[ebp]
	mov	ecx, DWORD PTR $T234494[ebp]
	mov	DWORD PTR [eax], ecx

; 1106 : 				}
; 1107 : 				else

	jmp	SHORT $LN5@ComputeCen
$LN4@ComputeCen:

; 1108 : 				{
; 1109 : 					// Can't plot a path, probably due to change of control of hexes.  Will probably abort the operation
; 1110 : 					return NULL;

	mov	DWORD PTR $T234186[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	call	??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
	mov	eax, DWORD PTR $T234186[ebp]
	jmp	SHORT $LN12@ComputeCen
$LN5@ComputeCen:

; 1111 : 				}
; 1112 : 			}
; 1113 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	call	??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
$LN10@ComputeCen:

; 1114 : 		break;
; 1115 : 	}
; 1116 : 	return pRtnValue;

	mov	eax, DWORD PTR _pRtnValue$[ebp]
$LN12@ComputeCen:

; 1117 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z$0:
	lea	ecx, DWORD PTR _m_NodesOnPath$223586[ebp]
	jmp	??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
__ehhandler$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z ENDP ; CvAIOperation::ComputeCenterOfMassForTurn
PUBLIC	?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ	; CvAIOperation::HasOneMoreSlotToFill
; Function compile flags: /Odtp
;	COMDAT ?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T234560 = -4						; size = 4
?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ PROC	; CvAIOperation::HasOneMoreSlotToFill, COMDAT
; _this$ = ecx

; 1120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1121 : 	if(m_viListOfUnitsWeStillNeedToBuild.size() == 1 && m_eCurrentState  == AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T234560[ebp], eax
	mov	ecx, DWORD PTR $T234560[ebp]
	mov	edx, DWORD PTR $T234560[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, 1
	jne	SHORT $LN1@HasOneMore
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 1
	jne	SHORT $LN1@HasOneMore

; 1122 : 	{
; 1123 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@HasOneMore
$LN1@HasOneMore:

; 1124 : 	}
; 1125 : 
; 1126 : 	return false;

	xor	al, al
$LN2@HasOneMore:

; 1127 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ ENDP	; CvAIOperation::HasOneMoreSlotToFill
_TEXT	ENDS
PUBLIC	?BuyFinalUnit@CvAIOperation@@QAE_NXZ		; CvAIOperation::BuyFinalUnit
EXTRN	?AddUnit@CvArmyAI@@QAEXHH@Z:PROC		; CvArmyAI::AddUnit
EXTRN	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z:PROC ; CvMilitaryAI::BuyEmergencyUnit
EXTRN	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z:PROC ; CvMultiUnitFormationInfo::getFormationSlotEntry
; Function compile flags: /Odtp
;	COMDAT ?BuyFinalUnit@CvAIOperation@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T234763 = -120						; size = 4
$T234759 = -116						; size = 4
$T234755 = -112						; size = 4
$T234751 = -108						; size = 4
$T234747 = -104						; size = 4
$T234672 = -76						; size = 4
$T234663 = -72						; size = 4
$T234659 = -68						; size = 4
__Tmp$234650 = -64					; size = 4
$T234593 = -60						; size = 4
$T234635 = -56						; size = 4
$T234634 = -52						; size = 4
$T234580 = -48						; size = 4
$T234571 = -44						; size = 4
_pThisArmy$223629 = -40					; size = 4
_uiI$223625 = -36					; size = 4
_pUnit$223621 = -32					; size = 4
_thisFormation$223619 = -28				; size = 4
_thisSlotEntry$223620 = -24				; size = 4
_thisSlot$223617 = -20					; size = 12
_pArmy$223618 = -8					; size = 4
_pCity$ = -4						; size = 4
?BuyFinalUnit@CvAIOperation@@QAE_NXZ PROC		; CvAIOperation::BuyFinalUnit, COMDAT
; _this$ = ecx

; 1130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 1131 : 	CvCity* pCity = GetOperationStartCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _pCity$[ebp], eax

; 1132 : 
; 1133 : 	if(!m_viListOfUnitsWeStillNeedToBuild.empty() && pCity != NULL && pCity->getOwner() == m_eOwner)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T234571[ebp], ecx
	mov	edx, DWORD PTR $T234571[ebp]
	mov	eax, DWORD PTR $T234571[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	jne	$LN7@BuyFinalUn
	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN7@BuyFinalUn
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T234580[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T234580[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jne	$LN7@BuyFinalUn

; 1134 : 	{
; 1135 : 		OperationSlot thisSlot = m_viListOfUnitsWeStillNeedToBuild.back();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T234593[ebp], edx
	mov	eax, DWORD PTR $T234593[ebp]
	mov	DWORD PTR $T234634[ebp], eax
	mov	ecx, DWORD PTR $T234634[ebp]
	mov	DWORD PTR __Tmp$234650[ebp], ecx
	mov	edx, 1
	neg	edx
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Tmp$234650[ebp]
	mov	DWORD PTR __Tmp$234650[ebp], edx
	mov	eax, DWORD PTR __Tmp$234650[ebp]
	mov	DWORD PTR $T234635[ebp], eax
	mov	ecx, DWORD PTR $T234635[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _thisSlot$223617[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _thisSlot$223617[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _thisSlot$223617[ebp+8], ecx

; 1136 : 		CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(thisSlot.m_iArmyID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234659[ebp], eax
	mov	ecx, DWORD PTR _thisSlot$223617[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR $T234659[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pArmy$223618[ebp], eax

; 1137 : 		CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(pArmy->GetFormationIndex());

	mov	ecx, DWORD PTR _pArmy$223618[ebp]
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	DWORD PTR _thisFormation$223619[ebp], eax

; 1138 : #ifdef AUI_WARNING_FIXES
; 1139 : 		if (!thisFormation)
; 1140 : 			return false;
; 1141 : #endif
; 1142 : 		const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(thisSlot.m_iSlotID);

	mov	edx, DWORD PTR _thisSlot$223617[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _thisFormation$223619[ebp]
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
	mov	DWORD PTR _thisSlotEntry$223620[ebp], eax

; 1143 : 
; 1144 : 		CvUnit* pUnit = GET_PLAYER(m_eOwner).GetMilitaryAI()->BuyEmergencyUnit((UnitAITypes)thisSlotEntry.m_primaryUnitType, pCity);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234663[ebp], ecx
	mov	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _thisSlotEntry$223620[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T234663[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit
	mov	DWORD PTR _pUnit$223621[ebp], eax

; 1145 : 		if(pUnit != NULL)

	cmp	DWORD PTR _pUnit$223621[ebp], 0
	je	$LN7@BuyFinalUn

; 1146 : 		{
; 1147 : 			pArmy->AddUnit(pUnit->GetID(), thisSlot.m_iSlotID);

	mov	edx, DWORD PTR _pUnit$223621[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T234672[ebp], eax
	mov	ecx, DWORD PTR _thisSlot$223617[ebp+8]
	push	ecx
	mov	edx, DWORD PTR $T234672[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmy$223618[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 1148 : 			m_viListOfUnitsWeStillNeedToBuild.pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back

; 1149 : 			if (m_viListOfUnitsWeStillNeedToBuild.size() == 0 && m_viListOfUnitsCitiesHaveCommittedToBuild.size() == 0 && m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T234747[ebp], eax
	mov	ecx, DWORD PTR $T234747[ebp]
	mov	edx, DWORD PTR $T234747[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	$LN5@BuyFinalUn
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR $T234751[ebp], edx
	mov	eax, DWORD PTR $T234751[ebp]
	mov	ecx, DWORD PTR $T234751[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	$LN5@BuyFinalUn
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 1
	jne	$LN5@BuyFinalUn

; 1150 : 			{
; 1151 : 				m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 2

; 1152 : 				for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223625[ebp], 0
	jmp	SHORT $LN4@BuyFinalUn
$LN3@BuyFinalUn:
	mov	ecx, DWORD PTR _uiI$223625[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiI$223625[ebp], ecx
$LN4@BuyFinalUn:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T234755[ebp], edx
	mov	eax, DWORD PTR $T234755[ebp]
	mov	ecx, DWORD PTR $T234755[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _uiI$223625[ebp], edx
	jae	SHORT $LN5@BuyFinalUn

; 1153 : 				{
; 1154 : 					CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$223625[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T234759[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234763[ebp], edx
	mov	eax, DWORD PTR $T234759[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T234763[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223629[ebp], eax

; 1155 : 					if(pThisArmy)

	cmp	DWORD PTR _pThisArmy$223629[ebp], 0
	je	SHORT $LN1@BuyFinalUn

; 1156 : 					{
; 1157 : 						pThisArmy->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pThisArmy$223629[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
$LN1@BuyFinalUn:

; 1158 : 					}
; 1159 : 				}

	jmp	SHORT $LN3@BuyFinalUn
$LN5@BuyFinalUn:

; 1160 : 			}
; 1161 : 			return true;

	mov	al, 1
	jmp	SHORT $LN8@BuyFinalUn
$LN7@BuyFinalUn:

; 1162 : 		}
; 1163 : 	}
; 1164 : 
; 1165 : 	return false;

	xor	al, al
$LN8@BuyFinalUn:

; 1166 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuyFinalUnit@CvAIOperation@@QAE_NXZ ENDP		; CvAIOperation::BuyFinalUnit
_TEXT	ENDS
PUBLIC	??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator>><OperationSlot>
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z ; operator>>
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z ; operator>>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z PROC	; CvAIOperation::Read, COMDAT
; _this$ = ecx

; 1170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1171 : 	// Version number to maintain backwards compatibility
; 1172 : 	uint uiVersion;
; 1173 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1174 : 
; 1175 : 	kStream >> m_iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1176 : 	kStream >> m_eOwner;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 1177 : 	kStream >> m_eEnemy;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 1178 : 	kStream >> m_eCurrentState;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z ; operator>>
	add	esp, 8

; 1179 : 	kStream >> m_iDefaultArea;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1180 : 	kStream >> m_bShouldReplaceLossesWithReinforcements;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 1181 : 	kStream >> m_eMoveType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z ; operator>>
	add	esp, 8

; 1182 : 	kStream >> m_iTargetX;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1183 : 	kStream >> m_iTargetY;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1184 : 	kStream >> m_iMusterX;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1185 : 	kStream >> m_iMusterY;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1186 : 	kStream >> m_iStartCityX;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1187 : 	kStream >> m_iStartCityY;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1188 : 	kStream >> m_iLastTurnMoved;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1189 : 	kStream >> m_viArmyIDs;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
	add	esp, 8

; 1190 : 	kStream >> m_viListOfUnitsWeStillNeedToBuild;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator>><OperationSlot>
	add	esp, 8

; 1191 : 	kStream >> m_viListOfUnitsCitiesHaveCommittedToBuild;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator>><OperationSlot>
	add	esp, 8

; 1192 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ENDP	; CvAIOperation::Read
_TEXT	ENDS
PUBLIC	??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator<<<OperationSlot>
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z ; operator<<
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z ; operator<<
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z PROC	; CvAIOperation::Write, COMDAT
; _this$ = ecx

; 1196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1197 : 	// Current version number
; 1198 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 1199 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1200 : 
; 1201 : 	kStream << m_iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1202 : 	kStream << m_eOwner;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 1203 : 	kStream << m_eEnemy;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 1204 : 	kStream << m_eCurrentState;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z ; operator<<
	add	esp, 8

; 1205 : 	kStream << m_iDefaultArea;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1206 : 	kStream << m_bShouldReplaceLossesWithReinforcements;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 1207 : 	kStream << m_eMoveType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z ; operator<<
	add	esp, 8

; 1208 : 	kStream << m_iTargetX;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1209 : 	kStream << m_iTargetY;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1210 : 	kStream << m_iMusterX;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1211 : 	kStream << m_iMusterY;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1212 : 	kStream << m_iStartCityX;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1213 : 	kStream << m_iStartCityY;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1214 : 	kStream << m_iLastTurnMoved;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1215 : 	kStream << m_viArmyIDs;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
	add	esp, 8

; 1216 : 	kStream << m_viListOfUnitsWeStillNeedToBuild;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator<<<OperationSlot>
	add	esp, 8

; 1217 : 	kStream << m_viListOfUnitsCitiesHaveCommittedToBuild;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator<<<OperationSlot>
	add	esp, 8

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ENDP	; CvAIOperation::Write
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@		; `string'
PUBLIC	??_C@_09MIJAKHKB@Completed?$AA@			; `string'
PUBLIC	??_C@_09NKKNDOP@At?5Target?$AA@			; `string'
PUBLIC	??_C@_0BB@BIOAFCPG@Moving?5To?5Target?$AA@	; `string'
PUBLIC	??_C@_0BB@CPNBHECI@Gathering?5Forces?$AA@	; `string'
PUBLIC	??_C@_0BB@CIPPDFHK@Recruiting?5Units?$AA@	; `string'
PUBLIC	??_C@_07LCKDCBKK@Aborted?$AA@			; `string'
PUBLIC	??_C@_0EB@EHKEONDP@Started?0?5Army?3?5?$CFd?0?5Units?5Recruit@ ; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogOperationStart@CvAIOperation@@QAEXXZ	; CvAIOperation::LogOperationStart
EXTRN	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z:PROC ; CvMilitaryAI::LogMilitarySummaryMessage
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	?GetID@CvArmyAI@@QAEHXZ:PROC			; CvArmyAI::GetID
EXTRN	?GetNumFormationEntries@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetNumFormationEntries
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@ DB ', vs. ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MIJAKHKB@Completed?$AA@
CONST	SEGMENT
??_C@_09MIJAKHKB@Completed?$AA@ DB 'Completed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKKNDOP@At?5Target?$AA@
CONST	SEGMENT
??_C@_09NKKNDOP@At?5Target?$AA@ DB 'At Target', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIOAFCPG@Moving?5To?5Target?$AA@
CONST	SEGMENT
??_C@_0BB@BIOAFCPG@Moving?5To?5Target?$AA@ DB 'Moving To Target', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CPNBHECI@Gathering?5Forces?$AA@
CONST	SEGMENT
??_C@_0BB@CPNBHECI@Gathering?5Forces?$AA@ DB 'Gathering Forces', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CIPPDFHK@Recruiting?5Units?$AA@
CONST	SEGMENT
??_C@_0BB@CIPPDFHK@Recruiting?5Units?$AA@ DB 'Recruiting Units', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCKDCBKK@Aborted?$AA@
CONST	SEGMENT
??_C@_07LCKDCBKK@Aborted?$AA@ DB 'Aborted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@EHKEONDP@Started?0?5Army?3?5?$CFd?0?5Units?5Recruit@
CONST	SEGMENT
??_C@_0EB@EHKEONDP@Started?0?5Army?3?5?$CFd?0?5Units?5Recruit@ DB 'Starte'
	DB	'd, Army: %d, Units Recruited: %d, Max Formation Size: %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationStart@CvAIOperation@@QAEXXZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?LogOperationStart@CvAIOperation@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationStart@CvAIOperation@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$9
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$10
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$12
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$13
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$14
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationStart@CvAIOperation@@QAEXXZ
_TEXT	SEGMENT
tv379 = -592						; size = 4
tv613 = -588						; size = 4
tv377 = -584						; size = 4
tv612 = -580						; size = 4
tv611 = -576						; size = 4
tv373 = -572						; size = 4
tv610 = -568						; size = 4
tv273 = -564						; size = 4
tv239 = -560						; size = 4
tv74 = -556						; size = 4
tv369 = -552						; size = 4
tv385 = -548						; size = 4
tv367 = -544						; size = 4
tv396 = -540						; size = 4
tv365 = -536						; size = 4
tv407 = -532						; size = 4
tv363 = -528						; size = 4
tv418 = -524						; size = 4
tv430 = -520						; size = 4
tv131 = -516						; size = 4
tv432 = -512						; size = 4
_this$ = -508						; size = 4
$T234979 = -504						; size = 4
$T234975 = -500						; size = 4
$T234969 = -496						; size = 4
$T234961 = -492						; size = 4
$T234957 = -488						; size = 4
$T234923 = -484						; size = 4
$T234919 = -480						; size = 4
$T234915 = -476						; size = 4
$T234911 = -472						; size = 4
$T234903 = -468						; size = 4
$T234895 = -464						; size = 4
$T234894 = -460						; size = 4
$T234890 = -456						; size = 4
$T234881 = -452						; size = 4
$T234846 = -448						; size = 28
$T234845 = -420						; size = 28
$T234844 = -392						; size = 28
$T234843 = -364						; size = 28
$T234842 = -336						; size = 28
$T234841 = -308						; size = 28
$T234840 = -280						; size = 28
$T234839 = -252						; size = 28
$T234838 = -224						; size = 28
$T234837 = -196						; size = 28
_pThisArmy$223713 = -168				; size = 4
_uiI$223709 = -164					; size = 4
_strOutBuf$223696 = -160				; size = 28
_strTemp2$223699 = -132					; size = 28
_strPlayerName$223700 = -104				; size = 28
_pLog$223701 = -76					; size = 4
_strBaseString$223697 = -72				; size = 28
_strTemp1$223698 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogOperationStart@CvAIOperation@@QAEXXZ PROC		; CvAIOperation::LogOperationStart, COMDAT
; _this$ = ecx

; 1224 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogOperationStart@CvAIOperation@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1225 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN17@LogOperati
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN17@LogOperati

; 1226 : 	{
; 1227 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1228 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$223697[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1229 : 		CvString strTemp1;

	lea	ecx, DWORD PTR _strTemp1$223698[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1230 : 		CvString strTemp2;

	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1231 : 
; 1232 : 		CvString strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234881[ebp], eax
	mov	ecx, DWORD PTR $T234881[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T234890[ebp], eax
	cmp	DWORD PTR $T234890[ebp], 0
	je	SHORT $LN50@LogOperati
	mov	ecx, DWORD PTR $T234890[ebp]
	mov	DWORD PTR tv432[ebp], ecx
	jmp	SHORT $LN51@LogOperati
$LN50@LogOperati:
	mov	DWORD PTR tv432[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN51@LogOperati:
	mov	edx, DWORD PTR tv432[ebp]
	push	edx
	lea	ecx, DWORD PTR _strPlayerName$223700[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1233 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv131[ebp], eax
	lea	eax, DWORD PTR _strPlayerName$223700[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234837[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	DWORD PTR tv430[ebp], eax
	mov	edx, DWORD PTR tv430[ebp]
	mov	DWORD PTR $T234894[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T234894[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T234895[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T234895[ebp]
	push	eax
	mov	ecx, DWORD PTR tv131[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv131[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$223701[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T234837[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1234 : 
; 1235 : 		// Get the leading info for this line
; 1236 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234903[ebp], ecx
	mov	ecx, DWORD PTR $T234903[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$223697[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1237 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	lea	eax, DWORD PTR $T234838[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	DWORD PTR tv418[ebp], eax
	mov	ecx, DWORD PTR tv418[ebp]
	mov	DWORD PTR tv363[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _strPlayerName$223700[ebp]
	push	edx
	lea	eax, DWORD PTR $T234839[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv407[ebp], eax
	mov	ecx, DWORD PTR tv407[ebp]
	mov	DWORD PTR tv365[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR tv363[ebp]
	push	edx
	mov	eax, DWORD PTR tv365[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234840[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv396[ebp], eax
	mov	edx, DWORD PTR tv396[ebp]
	mov	DWORD PTR tv367[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	eax, DWORD PTR tv367[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234841[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv385[ebp], eax
	mov	edx, DWORD PTR tv385[ebp]
	mov	DWORD PTR tv369[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	eax, DWORD PTR tv369[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223697[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T234841[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T234840[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T234839[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T234838[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1238 : 
; 1239 : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223709[ebp], 0
	jmp	SHORT $LN15@LogOperati
$LN14@LogOperati:
	mov	ecx, DWORD PTR _uiI$223709[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiI$223709[ebp], ecx
$LN15@LogOperati:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T234911[ebp], edx
	mov	eax, DWORD PTR $T234911[ebp]
	mov	ecx, DWORD PTR $T234911[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _uiI$223709[ebp], edx
	jae	$LN13@LogOperati

; 1240 : 		{
; 1241 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$223709[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T234915[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234919[ebp], edx
	mov	eax, DWORD PTR $T234915[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T234919[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223713[ebp], eax

; 1242 : 			strTemp1.Format("Started, Army: %d, Units Recruited: %d, Max Formation Size: %d, ", pThisArmy->GetID(), pThisArmy->GetNumSlotsFilled(), pThisArmy->GetNumFormationEntries());

	mov	ecx, DWORD PTR _pThisArmy$223713[ebp]
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223713[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223713[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	push	OFFSET ??_C@_0EB@EHKEONDP@Started?0?5Army?3?5?$CFd?0?5Units?5Recruit@
	lea	edx, DWORD PTR _strTemp1$223698[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1243 : 		}

	jmp	$LN14@LogOperati
$LN13@LogOperati:

; 1244 : 
; 1245 : 		strOutBuf = strBaseString + strTemp1;

	lea	eax, DWORD PTR _strTemp1$223698[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223697[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234842[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T234923[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T234923[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T234842[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1246 : 		switch(m_eCurrentState)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR tv239[ebp], edx
	cmp	DWORD PTR tv239[ebp], 5
	ja	$LN11@LogOperati
	mov	eax, DWORD PTR tv239[ebp]
	jmp	DWORD PTR $LN127@LogOperati[eax*4]
$LN10@LogOperati:

; 1247 : 		{
; 1248 : 		case AI_OPERATION_STATE_ABORTED:
; 1249 : 			strTemp2 = "Aborted";

	mov	ecx, OFFSET ??_C@_07LCKDCBKK@Aborted?$AA@
	test	ecx, ecx
	je	SHORT $LN72@LogOperati
	push	OFFSET ??_C@_07LCKDCBKK@Aborted?$AA@
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN73@LogOperati
$LN72@LogOperati:
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN73@LogOperati:

; 1250 : 			break;

	jmp	$LN11@LogOperati
$LN9@LogOperati:

; 1251 : 		case AI_OPERATION_STATE_RECRUITING_UNITS:
; 1252 : 			strTemp2 = "Recruiting Units";

	mov	edx, OFFSET ??_C@_0BB@CIPPDFHK@Recruiting?5Units?$AA@
	test	edx, edx
	je	SHORT $LN76@LogOperati
	push	OFFSET ??_C@_0BB@CIPPDFHK@Recruiting?5Units?$AA@
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN77@LogOperati
$LN76@LogOperati:
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN77@LogOperati:

; 1253 : 			break;

	jmp	$LN11@LogOperati
$LN8@LogOperati:

; 1254 : 		case AI_OPERATION_STATE_GATHERING_FORCES:
; 1255 : 			strTemp2 = "Gathering Forces";

	mov	eax, OFFSET ??_C@_0BB@CPNBHECI@Gathering?5Forces?$AA@
	test	eax, eax
	je	SHORT $LN80@LogOperati
	push	OFFSET ??_C@_0BB@CPNBHECI@Gathering?5Forces?$AA@
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN81@LogOperati
$LN80@LogOperati:
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN81@LogOperati:

; 1256 : 			break;

	jmp	SHORT $LN11@LogOperati
$LN7@LogOperati:

; 1257 : 		case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1258 : 			strTemp2 = "Moving To Target";

	mov	ecx, OFFSET ??_C@_0BB@BIOAFCPG@Moving?5To?5Target?$AA@
	test	ecx, ecx
	je	SHORT $LN84@LogOperati
	push	OFFSET ??_C@_0BB@BIOAFCPG@Moving?5To?5Target?$AA@
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN85@LogOperati
$LN84@LogOperati:
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN85@LogOperati:

; 1259 : 			break;

	jmp	SHORT $LN11@LogOperati
$LN6@LogOperati:

; 1260 : 		case AI_OPERATION_STATE_AT_TARGET:
; 1261 : 			strTemp2 = "At Target";

	mov	edx, OFFSET ??_C@_09NKKNDOP@At?5Target?$AA@
	test	edx, edx
	je	SHORT $LN88@LogOperati
	push	OFFSET ??_C@_09NKKNDOP@At?5Target?$AA@
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN89@LogOperati
$LN88@LogOperati:
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN89@LogOperati:

; 1262 : 			break;

	jmp	SHORT $LN11@LogOperati
$LN5@LogOperati:

; 1263 : 		case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 1264 : 			strTemp2 = "Completed";

	mov	eax, OFFSET ??_C@_09MIJAKHKB@Completed?$AA@
	test	eax, eax
	je	SHORT $LN92@LogOperati
	push	OFFSET ??_C@_09MIJAKHKB@Completed?$AA@
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN11@LogOperati
$LN92@LogOperati:
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN11@LogOperati:

; 1265 : 			break;
; 1266 : 		};
; 1267 : 
; 1268 : 		strOutBuf += strTemp2;

	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1269 : 
; 1270 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T234957[ebp], eax
	mov	edx, DWORD PTR $T234957[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$223701[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$223701[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 1271 : 
; 1272 : 		// Message to summary log?
; 1273 : 		switch (GetOperationType())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR tv273[ebp], eax
	mov	ecx, DWORD PTR tv273[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv273[ebp], ecx
	cmp	DWORD PTR tv273[ebp], 16		; 00000010H
	ja	$LN3@LogOperati
	mov	edx, DWORD PTR tv273[ebp]
	movzx	eax, BYTE PTR $LN125@LogOperati[edx]
	jmp	DWORD PTR $LN128@LogOperati[eax*4]
$LN2@LogOperati:

; 1274 : 		{
; 1275 : 		case AI_OPERATION_BASIC_CITY_ATTACK:
; 1276 : 		case AI_OPERATION_PILLAGE_ENEMY:
; 1277 : 		case AI_OPERATION_SNEAK_CITY_ATTACK:
; 1278 : 		case AI_OPERATION_SMALL_CITY_ATTACK:
; 1279 : 		case AI_OPERATION_NAVAL_BOMBARDMENT:
; 1280 : 		case AI_OPERATION_NAVAL_SUPERIORITY:
; 1281 : 		case AI_OPERATION_COLONIZE:
; 1282 : 		case AI_OPERATION_NAVAL_ATTACK:
; 1283 : 		case AI_OPERATION_NAVAL_SNEAK_ATTACK:
; 1284 : 		case AI_OPERATION_CITY_STATE_ATTACK:
; 1285 : 		case AI_OPERATION_CITY_STATE_NAVAL_ATTACK:
; 1286 : 		case AI_OPERATION_NUKE_ATTACK:
; 1287 : 		case AI_OPERATION_PURE_NAVAL_CITY_ATTACK:
; 1288 : 			
; 1289 : 			strOutBuf = GetOperationName() + ", ";

	lea	ecx, DWORD PTR $T234843[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx
	mov	DWORD PTR tv610[ebp], eax
	mov	eax, DWORD PTR tv610[ebp]
	mov	DWORD PTR tv373[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv373[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234844[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv611[ebp], eax
	mov	eax, DWORD PTR tv611[ebp]
	mov	DWORD PTR $T234961[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T234961[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T234844[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T234843[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1290 : 			strOutBuf += strTemp1 + strTemp2;

	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	push	ecx
	lea	edx, DWORD PTR _strTemp1$223698[ebp]
	push	edx
	lea	eax, DWORD PTR $T234845[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv612[ebp], eax
	mov	ecx, DWORD PTR tv612[ebp]
	mov	DWORD PTR tv377[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	edx, DWORD PTR tv377[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T234845[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1291 : 			if (m_eEnemy != NO_PLAYER)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], -1
	je	$LN1@LogOperati

; 1292 : 			{
; 1293 : 				strPlayerName = GET_PLAYER(m_eEnemy).getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234969[ebp], edx
	mov	ecx, DWORD PTR $T234969[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T234975[ebp], eax
	cmp	DWORD PTR $T234975[ebp], 0
	je	SHORT $LN105@LogOperati
	mov	eax, DWORD PTR $T234975[ebp]
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$223700[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN106@LogOperati
$LN105@LogOperati:
	lea	ecx, DWORD PTR _strPlayerName$223700[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN106@LogOperati:

; 1294 : 				strOutBuf += ", vs. " + strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$223700[ebp]
	push	ecx
	push	OFFSET ??_C@_06MFGNCDAK@?0?5vs?4?5?$AA@
	lea	edx, DWORD PTR $T234846[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv613[ebp], eax
	mov	eax, DWORD PTR tv613[ebp]
	mov	DWORD PTR tv379[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR tv379[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T234846[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@LogOperati:

; 1295 : 			}
; 1296 : 			GET_PLAYER(m_eOwner).GetMilitaryAI()->LogMilitarySummaryMessage(strOutBuf);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T234979[ebp], eax
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234979[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage
$LN3@LogOperati:

; 1297 : 		}
; 1298 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strPlayerName$223700[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp1$223698[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$223697[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@LogOperati:

; 1299 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN127@LogOperati:
	DD	$LN10@LogOperati
	DD	$LN9@LogOperati
	DD	$LN8@LogOperati
	DD	$LN7@LogOperati
	DD	$LN6@LogOperati
	DD	$LN5@LogOperati
$LN128@LogOperati:
	DD	$LN2@LogOperati
	DD	$LN3@LogOperati
$LN125@LogOperati:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$223696[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$223697[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp1$223698[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp2$223699[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$4:
	lea	ecx, DWORD PTR _strPlayerName$223700[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T234837[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T234838[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T234839[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T234840[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$9:
	lea	ecx, DWORD PTR $T234841[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$10:
	lea	ecx, DWORD PTR $T234842[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$11:
	lea	ecx, DWORD PTR $T234843[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$12:
	lea	ecx, DWORD PTR $T234844[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$13:
	lea	ecx, DWORD PTR $T234845[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$14:
	lea	ecx, DWORD PTR $T234846[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationStart@CvAIOperation@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-584]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogOperationStart@CvAIOperation@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationStart@CvAIOperation@@QAEXXZ ENDP		; CvAIOperation::LogOperationStart
PUBLIC	??_C@_0EF@FHGPAJDC@Moving?5To?5Target?0?5Army?3?5?$CFd?0?5At?5X@ ; `string'
PUBLIC	??_C@_0P@PLPDEHNG@?$CFs?5at?5?$CI?$CFd?9?$CFd?$CJ?0?$AA@ ; `string'
PUBLIC	??_C@_0DJ@KMPHNCDI@Gathering?5Forces?0?5Army?3?5?$CFd?0?5Gath@ ; `string'
PUBLIC	??_C@_0P@JHDBKLGK@?$CFs?5?9?5Turn?5?$CFd?0?5?$AA@ ; `string'
PUBLIC	??_C@_0BH@PLOHNPGL@Gathering?5at?5?$CI?$CFd?9?$CFd?$CJ?0?5?$AA@ ; `string'
PUBLIC	??_C@_0M@BEHMMLIH@Training?5?9?5?$AA@		; `string'
PUBLIC	??_C@_09DNFIMIEE@Turn?5?$CFd?0?5?$AA@		; `string'
PUBLIC	??_C@_0L@OHAALPNH@Skipping?0?5?$AA@		; `string'
PUBLIC	??_C@_09NECDCMKH@No?5Info?0?5?$AA@		; `string'
PUBLIC	??_C@_0DM@HGAKGADP@Recruiting?5Units?0?5Army?3?5?$CFd?0?5Must@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetTurnAtNextCheckpoint
;	COMDAT ??_C@_0EF@FHGPAJDC@Moving?5To?5Target?0?5Army?3?5?$CFd?0?5At?5X@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0EF@FHGPAJDC@Moving?5To?5Target?0?5Army?3?5?$CFd?0?5At?5X@ DB 'Movi'
	DB	'ng To Target, Army: %d, At X: %d, At Y: %d, To X: %d, To Y: %'
	DB	'd, ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PLPDEHNG@?$CFs?5at?5?$CI?$CFd?9?$CFd?$CJ?0?$AA@
CONST	SEGMENT
??_C@_0P@PLPDEHNG@?$CFs?5at?5?$CI?$CFd?9?$CFd?$CJ?0?$AA@ DB '%s at (%d-%d'
	DB	'),', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@KMPHNCDI@Gathering?5Forces?0?5Army?3?5?$CFd?0?5Gath@
CONST	SEGMENT
??_C@_0DJ@KMPHNCDI@Gathering?5Forces?0?5Army?3?5?$CFd?0?5Gath@ DB 'Gather'
	DB	'ing Forces, Army: %d, Gather X: %d, Gather Y: %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JHDBKLGK@?$CFs?5?9?5Turn?5?$CFd?0?5?$AA@
CONST	SEGMENT
??_C@_0P@JHDBKLGK@?$CFs?5?9?5Turn?5?$CFd?0?5?$AA@ DB '%s - Turn %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PLOHNPGL@Gathering?5at?5?$CI?$CFd?9?$CFd?$CJ?0?5?$AA@
CONST	SEGMENT
??_C@_0BH@PLOHNPGL@Gathering?5at?5?$CI?$CFd?9?$CFd?$CJ?0?5?$AA@ DB 'Gathe'
	DB	'ring at (%d-%d), ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BEHMMLIH@Training?5?9?5?$AA@
CONST	SEGMENT
??_C@_0M@BEHMMLIH@Training?5?9?5?$AA@ DB 'Training - ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DNFIMIEE@Turn?5?$CFd?0?5?$AA@
CONST	SEGMENT
??_C@_09DNFIMIEE@Turn?5?$CFd?0?5?$AA@ DB 'Turn %d, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OHAALPNH@Skipping?0?5?$AA@
CONST	SEGMENT
??_C@_0L@OHAALPNH@Skipping?0?5?$AA@ DB 'Skipping, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NECDCMKH@No?5Info?0?5?$AA@
CONST	SEGMENT
??_C@_09NECDCMKH@No?5Info?0?5?$AA@ DB 'No Info, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HGAKGADP@Recruiting?5Units?0?5Army?3?5?$CFd?0?5Must@
CONST	SEGMENT
??_C@_0DM@HGAKGADP@Recruiting?5Units?0?5Army?3?5?$CFd?0?5Must@ DB 'Recrui'
	DB	'ting Units, Army: %d, Muster Turn: %d, SLOT DETAIL:, ', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationStatus@CvAIOperation@@QAEXXZ DD 019930522H
	DD	014H
	DD	FLAT:__unwindtable$?LogOperationStatus@CvAIOperation@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationStatus@CvAIOperation@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$12
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$14
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$16
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$18
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$19
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationStatus@CvAIOperation@@QAEXXZ
_TEXT	SEGMENT
tv971 = -808						; size = 4
tv970 = -804						; size = 4
tv969 = -800						; size = 4
tv74 = -796						; size = 4
tv649 = -792						; size = 4
tv197 = -788						; size = 4
tv629 = -784						; size = 4
tv660 = -780						; size = 4
tv627 = -776						; size = 4
tv671 = -772						; size = 4
tv625 = -768						; size = 4
tv682 = -764						; size = 4
tv623 = -760						; size = 4
tv693 = -756						; size = 4
tv704 = -752						; size = 4
tv135 = -748						; size = 4
_this$ = -744						; size = 4
$T235437 = -740						; size = 4
$T235433 = -736						; size = 4
$T235406 = -732						; size = 4
$T235402 = -728						; size = 4
$T235398 = -724						; size = 4
$T235389 = -720						; size = 4
$T235385 = -716						; size = 4
$T235376 = -712						; size = 4
$T235369 = -708						; size = 4
$T235359 = -704						; size = 4
$T235355 = -700						; size = 4
$T235351 = -696						; size = 4
$T235347 = -692						; size = 4
$T235325 = -688						; size = 4
$T235321 = -684						; size = 4
$T235317 = -680						; size = 4
$T235308 = -676						; size = 4
$T235304 = -672						; size = 4
$T235295 = -668						; size = 4
$T235288 = -664						; size = 4
$T235278 = -660						; size = 4
$T235274 = -656						; size = 4
$T235270 = -652						; size = 4
$T235266 = -648						; size = 4
$T235244 = -644						; size = 4
$T235240 = -640						; size = 4
$T235236 = -636						; size = 4
$T235229 = -632						; size = 4
$T235219 = -628						; size = 4
$T235215 = -624						; size = 4
$T235202 = -620						; size = 4
$T235193 = -616						; size = 4
$T235189 = -612						; size = 4
$T235180 = -608						; size = 4
$T235173 = -604						; size = 4
$T235163 = -600						; size = 4
$T235159 = -596						; size = 4
$T235152 = -592						; size = 4
$T235148 = -588						; size = 4
$T235144 = -584						; size = 4
$T235135 = -580						; size = 4
$T235126 = -576						; size = 4
$T235114 = -572						; size = 4
$T235110 = -568						; size = 4
$T235106 = -564						; size = 4
$T235088 = -560						; size = 4
$T235080 = -556						; size = 4
$T235079 = -552						; size = 4
$T235075 = -548						; size = 4
$T235069 = -544						; size = 4
$T235021 = -540						; size = 28
$T235020 = -512						; size = 28
$T235019 = -484						; size = 28
$T235018 = -456						; size = 28
$T235017 = -428						; size = 28
$T235016 = -400						; size = 28
$T235015 = -372						; size = 28
$T235014 = -344						; size = 28
$T235013 = -316						; size = 28
$T235012 = -288						; size = 28
_pThisUnit$223822 = -260				; size = 8
_iUnitID$223818 = -252					; size = 4
_pThisArmy$223816 = -248				; size = 4
_uiI$223812 = -244					; size = 4
_pThisUnit$223807 = -240				; size = 8
_iUnitID$223803 = -232					; size = 4
_pThisArmy$223801 = -228				; size = 4
_uiI$223797 = -224					; size = 4
_pThisUnit$223792 = -220				; size = 8
_pThisUnit$223788 = -212				; size = 8
_pSlot$223775 = -204					; size = 4
_iI$223771 = -200					; size = 4
_pThisArmy$223769 = -196				; size = 4
_uiI$223765 = -192					; size = 4
_strOutBuf$223747 = -188				; size = 28
_szTemp2$223750 = -160					; size = 28
_strPlayerName$223752 = -132				; size = 28
_szTemp3$223751 = -104					; size = 28
_pLog$223753 = -76					; size = 4
_strTemp$223749 = -72					; size = 28
_strBaseString$223748 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogOperationStatus@CvAIOperation@@QAEXXZ PROC		; CvAIOperation::LogOperationStatus, COMDAT
; _this$ = ecx

; 1303 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogOperationStatus@CvAIOperation@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 796				; 0000031cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1304 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN38@LogOperati@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN38@LogOperati@2

; 1305 : 	{
; 1306 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$223747[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1307 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$223748[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1308 : 		CvString strTemp, szTemp2, szTemp3;

	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _szTemp3$223751[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1309 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$223752[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1310 : 		FILogFile* pLog;
; 1311 : 
; 1312 : 		strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235069[ebp], eax
	mov	ecx, DWORD PTR $T235069[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T235075[ebp], eax
	cmp	DWORD PTR $T235075[ebp], 0
	je	SHORT $LN81@LogOperati@2
	mov	ecx, DWORD PTR $T235075[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$223752[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN82@LogOperati@2
$LN81@LogOperati@2:
	lea	ecx, DWORD PTR _strPlayerName$223752[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN82@LogOperati@2:

; 1313 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv135[ebp], eax
	lea	edx, DWORD PTR _strPlayerName$223752[ebp]
	push	edx
	lea	eax, DWORD PTR $T235012[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	DWORD PTR tv704[ebp], eax
	mov	ecx, DWORD PTR tv704[ebp]
	mov	DWORD PTR $T235079[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T235079[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235080[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T235080[ebp]
	push	edx
	mov	eax, DWORD PTR tv135[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv135[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$223753[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235012[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1314 : 
; 1315 : 		// Get the leading info for this line
; 1316 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235088[ebp], ecx
	mov	ecx, DWORD PTR $T235088[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$223748[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1317 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	lea	eax, DWORD PTR $T235013[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	DWORD PTR tv693[ebp], eax
	mov	ecx, DWORD PTR tv693[ebp]
	mov	DWORD PTR tv623[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _strPlayerName$223752[ebp]
	push	edx
	lea	eax, DWORD PTR $T235014[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv682[ebp], eax
	mov	ecx, DWORD PTR tv682[ebp]
	mov	DWORD PTR tv625[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR tv623[ebp]
	push	edx
	mov	eax, DWORD PTR tv625[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235015[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv671[ebp], eax
	mov	edx, DWORD PTR tv671[ebp]
	mov	DWORD PTR tv627[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	eax, DWORD PTR tv627[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235016[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv660[ebp], eax
	mov	edx, DWORD PTR tv660[ebp]
	mov	DWORD PTR tv629[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	eax, DWORD PTR tv629[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223748[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T235016[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T235015[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T235014[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235013[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1318 : 
; 1319 : 		switch(m_eCurrentState)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR tv197[ebp], edx
	cmp	DWORD PTR tv197[ebp], 5
	ja	$LN35@LogOperati@2
	mov	eax, DWORD PTR tv197[ebp]
	jmp	DWORD PTR $LN302@LogOperati@2[eax*4]
$LN34@LogOperati@2:

; 1320 : 		{
; 1321 : 		case AI_OPERATION_STATE_ABORTED:
; 1322 : 			strTemp = "Aborted";

	mov	ecx, OFFSET ??_C@_07LCKDCBKK@Aborted?$AA@
	test	ecx, ecx
	je	SHORT $LN95@LogOperati@2
	push	OFFSET ??_C@_07LCKDCBKK@Aborted?$AA@
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN96@LogOperati@2
$LN95@LogOperati@2:
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN96@LogOperati@2:

; 1323 : 			break;

	jmp	$LN35@LogOperati@2
$LN33@LogOperati@2:

; 1324 : 		case AI_OPERATION_STATE_RECRUITING_UNITS:
; 1325 : 			strTemp = "";

	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	edx, edx
	je	SHORT $LN99@LogOperati@2
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN100@LogOperati@2
$LN99@LogOperati@2:
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN100@LogOperati@2:

; 1326 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223765[ebp], 0
	jmp	SHORT $LN32@LogOperati@2
$LN31@LogOperati@2:
	mov	eax, DWORD PTR _uiI$223765[ebp]
	add	eax, 1
	mov	DWORD PTR _uiI$223765[ebp], eax
$LN32@LogOperati@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T235106[ebp], ecx
	mov	edx, DWORD PTR $T235106[ebp]
	mov	eax, DWORD PTR $T235106[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _uiI$223765[ebp], ecx
	jae	$LN30@LogOperati@2

; 1327 : 			{
; 1328 : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _uiI$223765[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235110[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235114[ebp], ecx
	mov	edx, DWORD PTR $T235110[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR $T235114[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223769[ebp], eax

; 1329 : 				szTemp2.Format("Recruiting Units, Army: %d, Muster Turn: %d, SLOT DETAIL:, ", pThisArmy->GetID(), pThisArmy->GetTurnAtNextCheckpoint());

	mov	ecx, DWORD PTR _pThisArmy$223769[ebp]
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223769[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	push	OFFSET ??_C@_0DM@HGAKGADP@Recruiting?5Units?0?5Army?3?5?$CFd?0?5Must@
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1330 : 				strTemp += szTemp2;

	lea	edx, DWORD PTR _szTemp2$223750[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1331 : 
; 1332 : 				for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	DWORD PTR _iI$223771[ebp], 0
	jmp	SHORT $LN29@LogOperati@2
$LN28@LogOperati@2:
	mov	eax, DWORD PTR _iI$223771[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$223771[ebp], eax
$LN29@LogOperati@2:
	mov	ecx, DWORD PTR _pThisArmy$223769[ebp]
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	DWORD PTR _iI$223771[ebp], eax
	jge	$LN27@LogOperati@2

; 1333 : 				{
; 1334 : 					CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	ecx, DWORD PTR _iI$223771[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pThisArmy$223769[ebp]
	add	ecx, DWORD PTR [edx+44]
	mov	DWORD PTR _pSlot$223775[ebp], ecx

; 1335 : 					if(pSlot->GetTurnAtCheckpoint() == ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT)

	mov	eax, DWORD PTR _pSlot$223775[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235126[ebp], ecx
	cmp	DWORD PTR $T235126[ebp], -1
	jne	SHORT $LN26@LogOperati@2

; 1336 : 					{
; 1337 : 						szTemp2 = "No Info, ";

	mov	edx, OFFSET ??_C@_09NECDCMKH@No?5Info?0?5?$AA@
	test	edx, edx
	je	SHORT $LN115@LogOperati@2
	push	OFFSET ??_C@_09NECDCMKH@No?5Info?0?5?$AA@
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN116@LogOperati@2
$LN115@LogOperati@2:
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN116@LogOperati@2:

; 1338 : 					}
; 1339 : 					else if(pSlot->GetTurnAtCheckpoint() == ARMYSLOT_NOT_INCLUDING_IN_OPERATION)

	jmp	$LN25@LogOperati@2
$LN26@LogOperati@2:
	mov	eax, DWORD PTR _pSlot$223775[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235135[ebp], ecx
	cmp	DWORD PTR $T235135[ebp], -2		; fffffffeH
	jne	SHORT $LN24@LogOperati@2

; 1340 : 					{
; 1341 : 						szTemp2 = "Skipping, ";

	mov	edx, OFFSET ??_C@_0L@OHAALPNH@Skipping?0?5?$AA@
	test	edx, edx
	je	SHORT $LN121@LogOperati@2
	push	OFFSET ??_C@_0L@OHAALPNH@Skipping?0?5?$AA@
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN122@LogOperati@2
$LN121@LogOperati@2:
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN122@LogOperati@2:

; 1342 : 					}
; 1343 : 					else if(pSlot->GetUnitID() == NO_UNIT)

	jmp	$LN25@LogOperati@2
$LN24@LogOperati@2:
	mov	eax, DWORD PTR _pSlot$223775[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235144[ebp], ecx
	cmp	DWORD PTR $T235144[ebp], -1
	jne	$LN130@LogOperati@2

; 1344 : 					{
; 1345 : 						szTemp3.Format("Turn %d, ", pSlot->GetTurnAtCheckpoint());

	mov	edx, DWORD PTR _pSlot$223775[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235148[ebp], eax
	mov	ecx, DWORD PTR $T235148[ebp]
	push	ecx
	push	OFFSET ??_C@_09DNFIMIEE@Turn?5?$CFd?0?5?$AA@
	lea	edx, DWORD PTR _szTemp3$223751[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1346 : 						szTemp2 = "Training - " + szTemp3;

	lea	eax, DWORD PTR _szTemp3$223751[ebp]
	push	eax
	push	OFFSET ??_C@_0M@BEHMMLIH@Training?5?9?5?$AA@
	lea	ecx, DWORD PTR $T235017[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv649[ebp], eax
	mov	edx, DWORD PTR tv649[ebp]
	mov	DWORD PTR $T235152[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T235152[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235017[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN25@LogOperati@2

; 1347 : 					}
; 1348 : 					else if(pSlot->HasStartedOnOperation())

$LN130@LogOperati@2:
	mov	eax, DWORD PTR _pSlot$223775[ebp]
	cmp	DWORD PTR [eax+8], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN20@LogOperati@2

; 1349 : 					{
; 1350 : 						UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(pSlot->GetUnitID());

	mov	eax, DWORD PTR _pSlot$223775[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235159[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235163[ebp], eax
	mov	ecx, DWORD PTR $T235159[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235163[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T235173[ebp], eax
	mov	edx, DWORD PTR $T235173[ebp]
	mov	DWORD PTR _pThisUnit$223788[ebp], edx
	mov	BYTE PTR _pThisUnit$223788[ebp+4], 0
	cmp	DWORD PTR _pThisUnit$223788[ebp], 0
	je	SHORT $LN137@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223788[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN137@LogOperati@2:
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH

; 1351 : 						if(pThisUnit)

	xor	eax, eax
	cmp	DWORD PTR _pThisUnit$223788[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@LogOperati@2

; 1352 : 						{
; 1353 : 							szTemp2.Format("Gathering at (%d-%d), ", pThisUnit->getX(), pThisUnit->getY());

	mov	edx, DWORD PTR _pThisUnit$223788[ebp]
	mov	DWORD PTR $T235180[ebp], edx
	mov	eax, DWORD PTR $T235180[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T235189[ebp], ecx
	mov	edx, DWORD PTR _pThisUnit$223788[ebp]
	mov	DWORD PTR $T235193[ebp], edx
	mov	eax, DWORD PTR $T235193[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T235202[ebp], ecx
	mov	edx, DWORD PTR $T235189[ebp]
	push	edx
	mov	eax, DWORD PTR $T235202[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@PLOHNPGL@Gathering?5at?5?$CI?$CFd?9?$CFd?$CJ?0?5?$AA@
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN19@LogOperati@2:

; 1354 : 						}
; 1355 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR _pThisUnit$223788[ebp], 0
	je	SHORT $LN156@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223788[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN156@LogOperati@2:

; 1356 : 					else

	jmp	$LN25@LogOperati@2
$LN20@LogOperati@2:

; 1357 : 					{
; 1358 : 						UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(pSlot->GetUnitID());

	mov	edx, DWORD PTR _pSlot$223775[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T235215[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235219[ebp], edx
	mov	eax, DWORD PTR $T235215[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235219[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T235229[ebp], eax
	mov	ecx, DWORD PTR $T235229[ebp]
	mov	DWORD PTR _pThisUnit$223792[ebp], ecx
	mov	BYTE PTR _pThisUnit$223792[ebp+4], 0
	cmp	DWORD PTR _pThisUnit$223792[ebp], 0
	je	SHORT $LN165@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223792[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN165@LogOperati@2:
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH

; 1359 : 						if(pThisUnit)

	xor	edx, edx
	cmp	DWORD PTR _pThisUnit$223792[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN17@LogOperati@2

; 1360 : 						{
; 1361 : 							szTemp2.Format("%s - Turn %d, ", pThisUnit->getName().GetCString(), pSlot->GetTurnAtCheckpoint());

	mov	ecx, DWORD PTR _pThisUnit$223792[ebp]
	mov	DWORD PTR $T235240[ebp], ecx
	lea	edx, DWORD PTR $T235018[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235240[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv74[ebp], eax
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T235244[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR _pSlot$223775[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235236[ebp], edx
	mov	eax, DWORD PTR $T235236[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235244[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0P@JHDBKLGK@?$CFs?5?9?5Turn?5?$CFd?0?5?$AA@
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	lea	ecx, DWORD PTR $T235018[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@LogOperati@2:

; 1362 : 						}
; 1363 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR _pThisUnit$223792[ebp], 0
	je	SHORT $LN25@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223792[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN25@LogOperati@2:

; 1364 : 					strTemp += szTemp2;

	lea	edx, DWORD PTR _szTemp2$223750[ebp]
	push	edx
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1365 : 				}

	jmp	$LN28@LogOperati@2
$LN27@LogOperati@2:

; 1366 : 			}

	jmp	$LN31@LogOperati@2
$LN30@LogOperati@2:

; 1367 : 			break;

	jmp	$LN35@LogOperati@2
$LN16@LogOperati@2:

; 1368 : 		case AI_OPERATION_STATE_GATHERING_FORCES:
; 1369 : 			strTemp = "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	eax, eax
	je	SHORT $LN186@LogOperati@2
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN187@LogOperati@2
$LN186@LogOperati@2:
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN187@LogOperati@2:

; 1370 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223797[ebp], 0
	jmp	SHORT $LN15@LogOperati@2
$LN14@LogOperati@2:
	mov	ecx, DWORD PTR _uiI$223797[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiI$223797[ebp], ecx
$LN15@LogOperati@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T235266[ebp], edx
	mov	eax, DWORD PTR $T235266[ebp]
	mov	ecx, DWORD PTR $T235266[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _uiI$223797[ebp], edx
	jae	$LN13@LogOperati@2

; 1371 : 			{
; 1372 : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _uiI$223797[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T235270[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235274[ebp], edx
	mov	eax, DWORD PTR $T235270[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T235274[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223801[ebp], eax

; 1373 : 				szTemp2.Format("Gathering Forces, Army: %d, Gather X: %d, Gather Y: %d, ", pThisArmy->GetID(), pThisArmy->GetX(), pThisArmy->GetY());

	mov	ecx, DWORD PTR _pThisArmy$223801[ebp]
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223801[ebp]
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223801[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	push	OFFSET ??_C@_0DJ@KMPHNCDI@Gathering?5Forces?0?5Army?3?5?$CFd?0?5Gath@
	lea	edx, DWORD PTR _szTemp2$223750[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1374 : 				strTemp += szTemp2;

	lea	eax, DWORD PTR _szTemp2$223750[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1375 : 				int iUnitID;
; 1376 : 				iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pThisArmy$223801[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$223803[ebp], eax
$LN12@LogOperati@2:

; 1377 : 				while(iUnitID != ARMY_NO_UNIT)

	cmp	DWORD PTR _iUnitID$223803[ebp], -1
	je	$LN11@LogOperati@2

; 1378 : 				{
; 1379 : 					// do something with each entry
; 1380 : 					UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235278[ebp], edx
	mov	eax, DWORD PTR _iUnitID$223803[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235278[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T235288[ebp], eax
	mov	ecx, DWORD PTR $T235288[ebp]
	mov	DWORD PTR _pThisUnit$223807[ebp], ecx
	mov	BYTE PTR _pThisUnit$223807[ebp+4], 0
	cmp	DWORD PTR _pThisUnit$223807[ebp], 0
	je	SHORT $LN198@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223807[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN198@LogOperati@2:
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH

; 1381 : 					if(pThisUnit)

	xor	edx, edx
	cmp	DWORD PTR _pThisUnit$223807[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN10@LogOperati@2

; 1382 : 					{
; 1383 : 						szTemp2.Format("%s at (%d-%d),", pThisUnit->getName().GetCString(), pThisUnit->getX(), pThisUnit->getY());

	mov	ecx, DWORD PTR _pThisUnit$223807[ebp]
	mov	DWORD PTR $T235321[ebp], ecx
	lea	edx, DWORD PTR $T235019[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235321[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv969[ebp], eax
	mov	eax, DWORD PTR tv969[ebp]
	mov	DWORD PTR $T235325[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR _pThisUnit$223807[ebp]
	mov	DWORD PTR $T235295[ebp], ecx
	mov	edx, DWORD PTR $T235295[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T235304[ebp], eax
	mov	ecx, DWORD PTR _pThisUnit$223807[ebp]
	mov	DWORD PTR $T235308[ebp], ecx
	mov	edx, DWORD PTR $T235308[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T235317[ebp], eax
	mov	ecx, DWORD PTR $T235304[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235317[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235325[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0P@PLPDEHNG@?$CFs?5at?5?$CI?$CFd?9?$CFd?$CJ?0?$AA@
	lea	eax, DWORD PTR _szTemp2$223750[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	lea	ecx, DWORD PTR $T235019[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1384 : 						strTemp += szTemp2;

	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN10@LogOperati@2:

; 1385 : 					}
; 1386 : 					iUnitID = pThisArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pThisArmy$223801[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$223803[ebp], eax

; 1387 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR _pThisUnit$223807[ebp], 0
	je	SHORT $LN224@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223807[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN224@LogOperati@2:
	jmp	$LN12@LogOperati@2
$LN11@LogOperati@2:

; 1388 : 			}

	jmp	$LN14@LogOperati@2
$LN13@LogOperati@2:

; 1389 : 			break;

	jmp	$LN35@LogOperati@2
$LN9@LogOperati@2:

; 1390 : 		case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1391 : 			strTemp = "";

	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	edx, edx
	je	SHORT $LN229@LogOperati@2
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN230@LogOperati@2
$LN229@LogOperati@2:
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN230@LogOperati@2:

; 1392 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	DWORD PTR _uiI$223812[ebp], 0
	jmp	SHORT $LN8@LogOperati@2
$LN7@LogOperati@2:
	mov	eax, DWORD PTR _uiI$223812[ebp]
	add	eax, 1
	mov	DWORD PTR _uiI$223812[ebp], eax
$LN8@LogOperati@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T235347[ebp], ecx
	mov	edx, DWORD PTR $T235347[ebp]
	mov	eax, DWORD PTR $T235347[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	cmp	DWORD PTR _uiI$223812[ebp], ecx
	jae	$LN6@LogOperati@2

; 1393 : 			{
; 1394 : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _uiI$223812[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235351[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235355[ebp], ecx
	mov	edx, DWORD PTR $T235351[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR $T235355[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$223816[ebp], eax

; 1395 : 				szTemp2.Format("Moving To Target, Army: %d, At X: %d, At Y: %d, To X: %d, To Y: %d, ", pThisArmy->GetID(), pThisArmy->GetX(), pThisArmy->GetY(), m_iTargetX, m_iTargetY);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	mov	ecx, DWORD PTR _pThisArmy$223816[ebp]
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223816[ebp]
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$223816[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	push	OFFSET ??_C@_0EF@FHGPAJDC@Moving?5To?5Target?0?5Army?3?5?$CFd?0?5At?5X@
	lea	edx, DWORD PTR _szTemp2$223750[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 1396 : 				strTemp += szTemp2;

	lea	eax, DWORD PTR _szTemp2$223750[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1397 : 				int iUnitID;
; 1398 : 				iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pThisArmy$223816[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$223818[ebp], eax
$LN5@LogOperati@2:

; 1399 : 				while(iUnitID != ARMY_NO_UNIT)

	cmp	DWORD PTR _iUnitID$223818[ebp], -1
	je	$LN4@LogOperati@2

; 1400 : 				{
; 1401 : 					// do something with each entry
; 1402 : 					UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235359[ebp], edx
	mov	eax, DWORD PTR _iUnitID$223818[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235359[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T235369[ebp], eax
	mov	ecx, DWORD PTR $T235369[ebp]
	mov	DWORD PTR _pThisUnit$223822[ebp], ecx
	mov	BYTE PTR _pThisUnit$223822[ebp+4], 0
	cmp	DWORD PTR _pThisUnit$223822[ebp], 0
	je	SHORT $LN241@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223822[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN241@LogOperati@2:
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H

; 1403 : 					if(pThisUnit)

	xor	edx, edx
	cmp	DWORD PTR _pThisUnit$223822[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN3@LogOperati@2

; 1404 : 					{
; 1405 : 						szTemp2.Format("%s at (%d-%d),", pThisUnit->getName().GetCString(), pThisUnit->getX(), pThisUnit->getY());

	mov	ecx, DWORD PTR _pThisUnit$223822[ebp]
	mov	DWORD PTR $T235402[ebp], ecx
	lea	edx, DWORD PTR $T235020[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235402[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv970[ebp], eax
	mov	eax, DWORD PTR tv970[ebp]
	mov	DWORD PTR $T235406[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR _pThisUnit$223822[ebp]
	mov	DWORD PTR $T235376[ebp], ecx
	mov	edx, DWORD PTR $T235376[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T235385[ebp], eax
	mov	ecx, DWORD PTR _pThisUnit$223822[ebp]
	mov	DWORD PTR $T235389[ebp], ecx
	mov	edx, DWORD PTR $T235389[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T235398[ebp], eax
	mov	ecx, DWORD PTR $T235385[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235398[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235406[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0P@PLPDEHNG@?$CFs?5at?5?$CI?$CFd?9?$CFd?$CJ?0?$AA@
	lea	eax, DWORD PTR _szTemp2$223750[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	lea	ecx, DWORD PTR $T235020[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1406 : 						strTemp += szTemp2;

	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN3@LogOperati@2:

; 1407 : 					}
; 1408 : 					iUnitID = pThisArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pThisArmy$223816[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$223818[ebp], eax

; 1409 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	cmp	DWORD PTR _pThisUnit$223822[ebp], 0
	je	SHORT $LN267@LogOperati@2
	mov	ecx, DWORD PTR _pThisUnit$223822[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN267@LogOperati@2:
	jmp	$LN5@LogOperati@2
$LN4@LogOperati@2:

; 1410 : 			}

	jmp	$LN7@LogOperati@2
$LN6@LogOperati@2:

; 1411 : 			break;

	jmp	SHORT $LN35@LogOperati@2
$LN2@LogOperati@2:

; 1412 : 		case AI_OPERATION_STATE_AT_TARGET:
; 1413 : 			strTemp = "At Target";

	mov	edx, OFFSET ??_C@_09NKKNDOP@At?5Target?$AA@
	test	edx, edx
	je	SHORT $LN272@LogOperati@2
	push	OFFSET ??_C@_09NKKNDOP@At?5Target?$AA@
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN273@LogOperati@2
$LN272@LogOperati@2:
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN273@LogOperati@2:

; 1414 : 			break;

	jmp	SHORT $LN35@LogOperati@2
$LN1@LogOperati@2:

; 1415 : 		case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 1416 : 			strTemp = "Completed";

	mov	eax, OFFSET ??_C@_09MIJAKHKB@Completed?$AA@
	test	eax, eax
	je	SHORT $LN276@LogOperati@2
	push	OFFSET ??_C@_09MIJAKHKB@Completed?$AA@
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@LogOperati@2
$LN276@LogOperati@2:
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@LogOperati@2:

; 1417 : 			break;
; 1418 : 		};
; 1419 : 
; 1420 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$223748[ebp]
	push	edx
	lea	eax, DWORD PTR $T235021[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv971[ebp], eax
	mov	ecx, DWORD PTR tv971[ebp]
	mov	DWORD PTR $T235433[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	ecx, DWORD PTR $T235433[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223747[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235021[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1421 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$223747[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235437[ebp], eax
	mov	edx, DWORD PTR $T235437[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$223753[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$223753[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 1422 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strPlayerName$223752[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _szTemp3$223751[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$223748[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$223747[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN38@LogOperati@2:

; 1423 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN302@LogOperati@2:
	DD	$LN34@LogOperati@2
	DD	$LN33@LogOperati@2
	DD	$LN16@LogOperati@2
	DD	$LN9@LogOperati@2
	DD	$LN2@LogOperati@2
	DD	$LN1@LogOperati@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$223747[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$223748[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$223749[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$3:
	lea	ecx, DWORD PTR _szTemp2$223750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$4:
	lea	ecx, DWORD PTR _szTemp3$223751[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$5:
	lea	ecx, DWORD PTR _strPlayerName$223752[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T235012[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T235013[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T235014[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$9:
	lea	ecx, DWORD PTR $T235015[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$10:
	lea	ecx, DWORD PTR $T235016[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$11:
	lea	ecx, DWORD PTR $T235017[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$12:
	lea	ecx, DWORD PTR _pThisUnit$223788[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$13:
	lea	ecx, DWORD PTR _pThisUnit$223792[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$14:
	lea	ecx, DWORD PTR $T235018[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$15:
	lea	ecx, DWORD PTR _pThisUnit$223807[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$16:
	lea	ecx, DWORD PTR $T235019[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$17:
	lea	ecx, DWORD PTR _pThisUnit$223822[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$18:
	lea	ecx, DWORD PTR $T235020[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$19:
	lea	ecx, DWORD PTR $T235021[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationStatus@CvAIOperation@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-800]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogOperationStatus@CvAIOperation@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationStatus@CvAIOperation@@QAEXXZ ENDP		; CvAIOperation::LogOperationStatus
PUBLIC	__$ArrayPad$
PUBLIC	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$7
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
tv302 = -352						; size = 4
tv220 = -348						; size = 4
tv301 = -344						; size = 4
tv218 = -340						; size = 4
tv74 = -336						; size = 4
tv216 = -332						; size = 4
tv228 = -328						; size = 4
tv214 = -324						; size = 4
tv239 = -320						; size = 4
tv251 = -316						; size = 4
tv93 = -312						; size = 4
tv253 = -308						; size = 4
_this$ = -304						; size = 4
$T235532 = -300						; size = 4
$T235528 = -296						; size = 4
$T235520 = -292						; size = 4
$T235512 = -288						; size = 4
$T235511 = -284						; size = 4
$T235507 = -280						; size = 4
$T235498 = -276						; size = 4
$T235477 = -272						; size = 28
$T235476 = -244						; size = 28
$T235475 = -216						; size = 28
$T235474 = -188						; size = 28
$T235473 = -160						; size = 28
$T235472 = -132						; size = 28
_strOutBuf$223833 = -104				; size = 28
_strPlayerName$223835 = -76				; size = 28
_pLog$223836 = -48					; size = 4
_strBaseString$223834 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z PROC ; CvAIOperation::LogOperationSpecialMessage, COMDAT
; _this$ = ecx

; 1426 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1427 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogOperati@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogOperati@3

; 1428 : 	{
; 1429 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$223833[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1430 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$223834[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1431 : 
; 1432 : 		CvString strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235498[ebp], eax
	mov	ecx, DWORD PTR $T235498[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T235507[ebp], eax
	cmp	DWORD PTR $T235507[ebp], 0
	je	SHORT $LN23@LogOperati@3
	mov	ecx, DWORD PTR $T235507[ebp]
	mov	DWORD PTR tv253[ebp], ecx
	jmp	SHORT $LN24@LogOperati@3
$LN23@LogOperati@3:
	mov	DWORD PTR tv253[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN24@LogOperati@3:
	mov	edx, DWORD PTR tv253[ebp]
	push	edx
	lea	ecx, DWORD PTR _strPlayerName$223835[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1433 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv93[ebp], eax
	lea	eax, DWORD PTR _strPlayerName$223835[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235472[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	DWORD PTR tv251[ebp], eax
	mov	edx, DWORD PTR tv251[ebp]
	mov	DWORD PTR $T235511[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T235511[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235512[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T235512[ebp]
	push	eax
	mov	ecx, DWORD PTR tv93[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$223836[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T235472[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1434 : 
; 1435 : 		// Get the leading info for this line
; 1436 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235520[ebp], ecx
	mov	ecx, DWORD PTR $T235520[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$223834[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1437 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	lea	eax, DWORD PTR $T235473[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR tv214[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _strPlayerName$223835[ebp]
	push	edx
	lea	eax, DWORD PTR $T235474[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv228[ebp], eax
	mov	ecx, DWORD PTR tv228[ebp]
	mov	DWORD PTR tv216[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv214[ebp]
	push	edx
	mov	eax, DWORD PTR tv216[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235475[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv218[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	eax, DWORD PTR tv218[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235476[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv301[ebp], eax
	mov	edx, DWORD PTR tv301[ebp]
	mov	DWORD PTR tv220[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR tv220[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223834[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T235476[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235475[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T235474[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T235473[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1438 : 		strOutBuf = strBaseString + strMsg;

	mov	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$223834[ebp]
	push	edx
	lea	eax, DWORD PTR $T235477[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv302[ebp], eax
	mov	ecx, DWORD PTR tv302[ebp]
	mov	DWORD PTR $T235528[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T235528[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223833[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T235477[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1439 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$223833[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235532[ebp], eax
	mov	edx, DWORD PTR $T235532[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$223836[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$223836[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 1440 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strPlayerName$223835[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$223834[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$223833[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogOperati@3:

; 1441 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$223833[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$223834[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$223835[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$3:
	lea	ecx, DWORD PTR $T235472[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$4:
	lea	ecx, DWORD PTR $T235473[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$5:
	lea	ecx, DWORD PTR $T235474[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$6:
	lea	ecx, DWORD PTR $T235475[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$7:
	lea	ecx, DWORD PTR $T235476[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$8:
	lea	ecx, DWORD PTR $T235477[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ENDP ; CvAIOperation::LogOperationSpecialMessage
PUBLIC	??_C@_0BE@OBMOPGHO@Lost?5Path?5to?5Target?$AA@	; `string'
PUBLIC	??_C@_0BF@EPLJLEGB@Diplo?5Opinion?5Change?$AA@	; `string'
PUBLIC	??_C@_0BB@BIJNELJ@War?5State?5Change?$AA@	; `string'
PUBLIC	??_C@_06GJNLCKAP@Killed?$AA@			; `string'
PUBLIC	??_C@_08GMDFOKCG@No?5nukes?$AA@			; `string'
PUBLIC	??_C@_0M@GGMPJFAL@Escort?5died?$AA@		; `string'
PUBLIC	??_C@_0O@JMHHOGKD@Lost?5civilian?$AA@		; `string'
PUBLIC	??_C@_0BA@MDHGHDBP@No?5muster?5point?$AA@	; `string'
PUBLIC	??_C@_0O@OJHAAKCC@Half?5strength?$AA@		; `string'
PUBLIC	??_C@_0BC@GDPHOJEN@No?5room?5to?5deploy?$AA@	; `string'
PUBLIC	??_C@_0BI@LDHPGICP@Target?5already?5captured?$AA@ ; `string'
PUBLIC	??_C@_0M@MAALIOOA@Lost?5target?$AA@		; `string'
PUBLIC	??_C@_0O@GPALCFOB@Repeat?5target?$AA@		; `string'
PUBLIC	??_C@_09BNIJGNFC@No?5target?$AA@		; `string'
PUBLIC	??_C@_07PBILKAFL@Success?$AA@			; `string'
PUBLIC	??_C@_07PCAJJFKE@Ended?0?5?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
;	COMDAT ??_C@_0BE@OBMOPGHO@Lost?5Path?5to?5Target?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BE@OBMOPGHO@Lost?5Path?5to?5Target?$AA@ DB 'Lost Path to Target', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EPLJLEGB@Diplo?5Opinion?5Change?$AA@
CONST	SEGMENT
??_C@_0BF@EPLJLEGB@Diplo?5Opinion?5Change?$AA@ DB 'Diplo Opinion Change', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIJNELJ@War?5State?5Change?$AA@
CONST	SEGMENT
??_C@_0BB@BIJNELJ@War?5State?5Change?$AA@ DB 'War State Change', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJNLCKAP@Killed?$AA@
CONST	SEGMENT
??_C@_06GJNLCKAP@Killed?$AA@ DB 'Killed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GMDFOKCG@No?5nukes?$AA@
CONST	SEGMENT
??_C@_08GMDFOKCG@No?5nukes?$AA@ DB 'No nukes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGMPJFAL@Escort?5died?$AA@
CONST	SEGMENT
??_C@_0M@GGMPJFAL@Escort?5died?$AA@ DB 'Escort died', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMHHOGKD@Lost?5civilian?$AA@
CONST	SEGMENT
??_C@_0O@JMHHOGKD@Lost?5civilian?$AA@ DB 'Lost civilian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MDHGHDBP@No?5muster?5point?$AA@
CONST	SEGMENT
??_C@_0BA@MDHGHDBP@No?5muster?5point?$AA@ DB 'No muster point', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OJHAAKCC@Half?5strength?$AA@
CONST	SEGMENT
??_C@_0O@OJHAAKCC@Half?5strength?$AA@ DB 'Half strength', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GDPHOJEN@No?5room?5to?5deploy?$AA@
CONST	SEGMENT
??_C@_0BC@GDPHOJEN@No?5room?5to?5deploy?$AA@ DB 'No room to deploy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LDHPGICP@Target?5already?5captured?$AA@
CONST	SEGMENT
??_C@_0BI@LDHPGICP@Target?5already?5captured?$AA@ DB 'Target already capt'
	DB	'ured', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MAALIOOA@Lost?5target?$AA@
CONST	SEGMENT
??_C@_0M@MAALIOOA@Lost?5target?$AA@ DB 'Lost target', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GPALCFOB@Repeat?5target?$AA@
CONST	SEGMENT
??_C@_0O@GPALCFOB@Repeat?5target?$AA@ DB 'Repeat target', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNIJGNFC@No?5target?$AA@
CONST	SEGMENT
??_C@_09BNIJGNFC@No?5target?$AA@ DB 'No target', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBILKAFL@Success?$AA@
CONST	SEGMENT
??_C@_07PBILKAFL@Success?$AA@ DB 'Success', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCAJJFKE@Ended?0?5?$AA@
CONST	SEGMENT
??_C@_07PCAJJFKE@Ended?0?5?$AA@ DB 'Ended, ', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationEnd@CvAIOperation@@QAEXXZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogOperationEnd@CvAIOperation@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationEnd@CvAIOperation@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$8
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$9
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationEnd@CvAIOperation@@QAEXXZ
_TEXT	SEGMENT
tv491 = -464						; size = 4
tv370 = -460						; size = 4
tv490 = -456						; size = 4
tv310 = -452						; size = 4
tv489 = -448						; size = 4
tv192 = -444						; size = 4
tv366 = -440						; size = 4
tv74 = -436						; size = 4
tv364 = -432						; size = 4
tv378 = -428						; size = 4
tv362 = -424						; size = 4
tv389 = -420						; size = 4
tv360 = -416						; size = 4
tv400 = -412						; size = 4
tv412 = -408						; size = 4
tv128 = -404						; size = 4
tv414 = -400						; size = 4
_this$ = -396						; size = 4
$T235640 = -392						; size = 4
$T235632 = -388						; size = 4
$T235628 = -384						; size = 4
$T235624 = -380						; size = 4
$T235611 = -376						; size = 4
$T235603 = -372						; size = 4
$T235602 = -368						; size = 4
$T235598 = -364						; size = 4
$T235589 = -360						; size = 4
$T235561 = -356						; size = 28
$T235560 = -328						; size = 28
$T235559 = -300						; size = 28
$T235558 = -272						; size = 28
$T235557 = -244						; size = 28
$T235556 = -216						; size = 28
$T235555 = -188						; size = 28
$T235554 = -160						; size = 28
_strOutBuf$223847 = -132				; size = 28
_strPlayerName$223850 = -104				; size = 28
_pLog$223851 = -76					; size = 4
_strTemp$223849 = -72					; size = 28
_strBaseString$223848 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogOperationEnd@CvAIOperation@@QAEXXZ PROC		; CvAIOperation::LogOperationEnd, COMDAT
; _this$ = ecx

; 1445 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogOperationEnd@CvAIOperation@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 452				; 000001c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1446 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN22@LogOperati@4
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN22@LogOperati@4

; 1447 : 	{
; 1448 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$223847[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1449 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$223848[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1450 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1451 : 
; 1452 : 		CvString strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235589[ebp], eax
	mov	ecx, DWORD PTR $T235589[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T235598[ebp], eax
	cmp	DWORD PTR $T235598[ebp], 0
	je	SHORT $LN49@LogOperati@4
	mov	ecx, DWORD PTR $T235598[ebp]
	mov	DWORD PTR tv414[ebp], ecx
	jmp	SHORT $LN50@LogOperati@4
$LN49@LogOperati@4:
	mov	DWORD PTR tv414[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN50@LogOperati@4:
	mov	edx, DWORD PTR tv414[ebp]
	push	edx
	lea	ecx, DWORD PTR _strPlayerName$223850[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1453 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv128[ebp], eax
	lea	eax, DWORD PTR _strPlayerName$223850[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235554[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	DWORD PTR tv412[ebp], eax
	mov	edx, DWORD PTR tv412[ebp]
	mov	DWORD PTR $T235602[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T235602[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235603[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T235603[ebp]
	push	eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$223851[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235554[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1454 : 
; 1455 : 		// Get the leading info for this line
; 1456 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235611[ebp], ecx
	mov	ecx, DWORD PTR $T235611[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$223848[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1457 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	lea	eax, DWORD PTR $T235555[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	DWORD PTR tv400[ebp], eax
	mov	ecx, DWORD PTR tv400[ebp]
	mov	DWORD PTR tv360[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _strPlayerName$223850[ebp]
	push	edx
	lea	eax, DWORD PTR $T235556[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv389[ebp], eax
	mov	ecx, DWORD PTR tv389[ebp]
	mov	DWORD PTR tv362[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv360[ebp]
	push	edx
	mov	eax, DWORD PTR tv362[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235557[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv378[ebp], eax
	mov	edx, DWORD PTR tv378[ebp]
	mov	DWORD PTR tv364[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	eax, DWORD PTR tv364[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235558[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv366[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR tv366[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$223848[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T235558[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T235557[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235556[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235555[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1458 : 
; 1459 : 		strTemp = "Ended, ";

	mov	ecx, OFFSET ??_C@_07PCAJJFKE@Ended?0?5?$AA@
	test	ecx, ecx
	je	SHORT $LN63@LogOperati@4
	push	OFFSET ??_C@_07PCAJJFKE@Ended?0?5?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN64@LogOperati@4
$LN63@LogOperati@4:
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN64@LogOperati@4:

; 1460 : 
; 1461 : 		switch(m_eAbortReason)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR tv192[ebp], eax
	cmp	DWORD PTR tv192[ebp], 14		; 0000000eH
	ja	$LN19@LogOperati@4
	mov	ecx, DWORD PTR tv192[ebp]
	jmp	DWORD PTR $LN91@LogOperati@4[ecx*4]
$LN18@LogOperati@4:

; 1462 : 		{
; 1463 : 		case AI_ABORT_SUCCESS:
; 1464 : 			strTemp += "Success";

	push	OFFSET ??_C@_07PBILKAFL@Success?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1465 : 			break;

	jmp	$LN19@LogOperati@4
$LN17@LogOperati@4:

; 1466 : 		case AI_ABORT_NO_TARGET:
; 1467 : 			strTemp += "No target";

	push	OFFSET ??_C@_09BNIJGNFC@No?5target?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1468 : 			break;

	jmp	$LN19@LogOperati@4
$LN16@LogOperati@4:

; 1469 : 		case AI_ABORT_REPEAT_TARGET:
; 1470 : 			strTemp += "Repeat target";

	push	OFFSET ??_C@_0O@GPALCFOB@Repeat?5target?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1471 : 			break;

	jmp	$LN19@LogOperati@4
$LN15@LogOperati@4:

; 1472 : 		case AI_ABORT_LOST_TARGET:
; 1473 : 			strTemp += "Lost target";

	push	OFFSET ??_C@_0M@MAALIOOA@Lost?5target?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1474 : 			break;

	jmp	$LN19@LogOperati@4
$LN14@LogOperati@4:

; 1475 : 		case AI_ABORT_TARGET_ALREADY_CAPTURED:
; 1476 : 			strTemp += "Target already captured";

	push	OFFSET ??_C@_0BI@LDHPGICP@Target?5already?5captured?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1477 : 			break;

	jmp	$LN19@LogOperati@4
$LN13@LogOperati@4:

; 1478 : 		case AI_ABORT_NO_ROOM_DEPLOY:
; 1479 : 			strTemp += "No room to deploy";

	push	OFFSET ??_C@_0BC@GDPHOJEN@No?5room?5to?5deploy?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1480 : 			break;

	jmp	$LN19@LogOperati@4
$LN12@LogOperati@4:

; 1481 : 		case AI_ABORT_HALF_STRENGTH:
; 1482 : 			strTemp += "Half strength";

	push	OFFSET ??_C@_0O@OJHAAKCC@Half?5strength?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1483 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN11@LogOperati@4:

; 1484 : 		case AI_ABORT_NO_MUSTER:
; 1485 : 			strTemp += "No muster point";

	push	OFFSET ??_C@_0BA@MDHGHDBP@No?5muster?5point?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1486 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN10@LogOperati@4:

; 1487 : 		case AI_ABORT_LOST_CIVILIAN:
; 1488 : 			strTemp += "Lost civilian";

	push	OFFSET ??_C@_0O@JMHHOGKD@Lost?5civilian?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1489 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN9@LogOperati@4:

; 1490 : 		case AI_ABORT_ESCORT_DIED:
; 1491 : 			strTemp += "Escort died";

	push	OFFSET ??_C@_0M@GGMPJFAL@Escort?5died?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1492 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN8@LogOperati@4:

; 1493 : 		case AI_ABORT_NO_NUKES:
; 1494 : 			strTemp += "No nukes";

	push	OFFSET ??_C@_08GMDFOKCG@No?5nukes?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1495 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN7@LogOperati@4:

; 1496 : 		case AI_ABORT_KILLED:
; 1497 : 			strTemp += "Killed";

	push	OFFSET ??_C@_06GJNLCKAP@Killed?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1498 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN6@LogOperati@4:

; 1499 : 		case AI_ABORT_WAR_STATE_CHANGE:
; 1500 : 			strTemp += "War State Change";

	push	OFFSET ??_C@_0BB@BIJNELJ@War?5State?5Change?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1501 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN5@LogOperati@4:

; 1502 : 		case AI_ABORT_DIPLO_OPINION_CHANGE:
; 1503 : 			strTemp += "Diplo Opinion Change";

	push	OFFSET ??_C@_0BF@EPLJLEGB@Diplo?5Opinion?5Change?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1504 : 			break;

	jmp	SHORT $LN19@LogOperati@4
$LN4@LogOperati@4:

; 1505 : 		case AI_ABORT_LOST_PATH:
; 1506 : 			strTemp += "Lost Path to Target";

	push	OFFSET ??_C@_0BE@OBMOPGHO@Lost?5Path?5to?5Target?$AA@
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN19@LogOperati@4:

; 1507 : 			break;
; 1508 : 		}
; 1509 : 
; 1510 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$223849[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$223848[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235559[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv489[ebp], eax
	mov	edx, DWORD PTR tv489[ebp]
	mov	DWORD PTR $T235624[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T235624[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223847[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235559[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1511 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$223847[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235628[ebp], eax
	mov	eax, DWORD PTR $T235628[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$223851[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$223851[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1512 : 
; 1513 : 		// Message to summary log?
; 1514 : 		switch (GetOperationType())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR tv310[ebp], eax
	mov	eax, DWORD PTR tv310[ebp]
	sub	eax, 2
	mov	DWORD PTR tv310[ebp], eax
	cmp	DWORD PTR tv310[ebp], 16		; 00000010H
	ja	$LN2@LogOperati@4
	mov	ecx, DWORD PTR tv310[ebp]
	movzx	edx, BYTE PTR $LN89@LogOperati@4[ecx]
	jmp	DWORD PTR $LN92@LogOperati@4[edx*4]
$LN1@LogOperati@4:

; 1515 : 		{
; 1516 : 		case AI_OPERATION_BASIC_CITY_ATTACK:
; 1517 : 		case AI_OPERATION_PILLAGE_ENEMY:
; 1518 : 		case AI_OPERATION_SNEAK_CITY_ATTACK:
; 1519 : 		case AI_OPERATION_SMALL_CITY_ATTACK:
; 1520 : 		case AI_OPERATION_NAVAL_BOMBARDMENT:
; 1521 : 		case AI_OPERATION_NAVAL_SUPERIORITY:
; 1522 : 		case AI_OPERATION_COLONIZE:
; 1523 : 		case AI_OPERATION_NAVAL_ATTACK:
; 1524 : 		case AI_OPERATION_NAVAL_SNEAK_ATTACK:
; 1525 : 		case AI_OPERATION_CITY_STATE_ATTACK:
; 1526 : 		case AI_OPERATION_CITY_STATE_NAVAL_ATTACK:
; 1527 : 		case AI_OPERATION_NUKE_ATTACK:
; 1528 : 		case AI_OPERATION_PURE_NAVAL_CITY_ATTACK:
; 1529 : 			strOutBuf = GetOperationName() + ", ";

	lea	eax, DWORD PTR $T235560[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+132]
	call	eax
	mov	DWORD PTR tv490[ebp], eax
	mov	ecx, DWORD PTR tv490[ebp]
	mov	DWORD PTR tv370[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	edx, DWORD PTR tv370[ebp]
	push	edx
	lea	eax, DWORD PTR $T235561[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv491[ebp], eax
	mov	ecx, DWORD PTR tv491[ebp]
	mov	DWORD PTR $T235632[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T235632[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$223847[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T235561[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T235560[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1530 : 			strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$223849[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$223847[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1531 : 			GET_PLAYER(m_eOwner).GetMilitaryAI()->LogMilitarySummaryMessage(strOutBuf);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235640[ebp], ecx
	lea	edx, DWORD PTR _strOutBuf$223847[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235640[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage
$LN2@LogOperati@4:

; 1532 : 		}
; 1533 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strPlayerName$223850[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$223848[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$223847[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN22@LogOperati@4:

; 1534 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN91@LogOperati@4:
	DD	$LN18@LogOperati@4
	DD	$LN17@LogOperati@4
	DD	$LN16@LogOperati@4
	DD	$LN15@LogOperati@4
	DD	$LN14@LogOperati@4
	DD	$LN13@LogOperati@4
	DD	$LN12@LogOperati@4
	DD	$LN11@LogOperati@4
	DD	$LN10@LogOperati@4
	DD	$LN9@LogOperati@4
	DD	$LN8@LogOperati@4
	DD	$LN7@LogOperati@4
	DD	$LN6@LogOperati@4
	DD	$LN5@LogOperati@4
	DD	$LN4@LogOperati@4
$LN92@LogOperati@4:
	DD	$LN1@LogOperati@4
	DD	$LN2@LogOperati@4
$LN89@LogOperati@4:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$223847[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$223848[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$223849[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strPlayerName$223850[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T235554[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T235555[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T235556[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T235557[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T235558[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$9:
	lea	ecx, DWORD PTR $T235559[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$10:
	lea	ecx, DWORD PTR $T235560[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$11:
	lea	ecx, DWORD PTR $T235561[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationEnd@CvAIOperation@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-456]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogOperationEnd@CvAIOperation@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationEnd@CvAIOperation@@QAEXXZ ENDP		; CvAIOperation::LogOperationEnd
PUBLIC	??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@ DB 'OperationalAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@
CONST	SEGMENT
??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@ DB 'OperationalAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
tv142 = -124						; size = 4
tv129 = -120						; size = 4
tv169 = -116						; size = 4
_this$ = -112						; size = 4
$T235684 = -108						; size = 4
$T235675 = -104						; size = 4
$T235670 = -100						; size = 28
$T235669 = -72						; size = 28
_strLogName$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z PROC ; CvAIOperation::GetLogFileName, COMDAT
; _this$ = ecx

; 1538 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T235675[ebp], 0

; 1539 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1540 : 
; 1541 : 	// Open the log file
; 1542 : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetLogFile

; 1543 : 	{
; 1544 : 		strLogName = "OperationalAILog_" + playerName + ".csv";

	mov	ecx, DWORD PTR _playerName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BC@HIMKCNF@OperationalAILog_?$AA@
	lea	edx, DWORD PTR $T235669[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	ecx, DWORD PTR tv129[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235670[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv142[ebp], eax
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T235684[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T235684[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T235670[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T235669[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1545 : 	}
; 1546 : 	else

	jmp	SHORT $LN1@GetLogFile
$LN2@GetLogFile:

; 1547 : 	{
; 1548 : 		strLogName = "OperationalAILog.csv";

	mov	ecx, OFFSET ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN16@GetLogFile
	push	OFFSET ??_C@_0BF@DBIOHPFH@OperationalAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@GetLogFile
$LN16@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@GetLogFile:

; 1549 : 	}
; 1550 : 
; 1551 : 	return strLogName;

	lea	edx, DWORD PTR _strLogName$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T235675[ebp]
	or	eax, 1
	mov	DWORD PTR $T235675[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1552 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$0:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T235669[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T235670[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$3:
	mov	eax, DWORD PTR $T235675[ebp]
	and	eax, 1
	je	$LN9@GetLogFile
	and	DWORD PTR $T235675[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN9@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ENDP ; CvAIOperation::GetLogFileName
EXTRN	?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z:PROC ; CvStepPathFinder::GetLastOwnedPlot
; Function compile flags: /Odtp
;	COMDAT ?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T235709 = -16						; size = 4
_pStartCityPlot$ = -12					; size = 4
_pStartCity$ = -8					; size = 4
_pMusterPt$ = -4					; size = 4
_pThisArmy$ = 8						; size = 4
?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z PROC ; CvAIOperation::SelectInitialMusterPoint, COMDAT
; _this$ = ecx

; 1556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1557 : 	CvPlot* pMusterPt = NULL;

	mov	DWORD PTR _pMusterPt$[ebp], 0

; 1558 : 	CvPlot* pStartCityPlot;
; 1559 : 	CvCity* pStartCity;
; 1560 : 
; 1561 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _pStartCity$[ebp], eax

; 1562 : 	if(pStartCity)

	cmp	DWORD PTR _pStartCity$[ebp], 0
	je	SHORT $LN4@SelectInit

; 1563 : 	{
; 1564 : 		pStartCityPlot = pStartCity->plot();

	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pStartCityPlot$[ebp], eax

; 1565 : 
; 1566 : 		if(pStartCityPlot != NULL)

	cmp	DWORD PTR _pStartCityPlot$[ebp], 0
	je	SHORT $LN4@SelectInit

; 1567 : 		{
; 1568 : 			// Generate a step path from our start to the target
; 1569 : 			pMusterPt = GC.getStepFinder().GetLastOwnedPlot(GetOwner(), GetEnemy(), pStartCityPlot, pThisArmy->GetGoalPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T235709[ebp], edx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	push	eax
	mov	eax, DWORD PTR _pStartCityPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	ecx, DWORD PTR $T235709[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z ; CvStepPathFinder::GetLastOwnedPlot
	mov	DWORD PTR _pMusterPt$[ebp], eax

; 1570 : 
; 1571 : 			// Should find a space we own
; 1572 : 			if(pMusterPt == NULL)

	cmp	DWORD PTR _pMusterPt$[ebp], 0
	jne	SHORT $LN2@SelectInit

; 1573 : 			{
; 1574 : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN5@SelectInit

; 1575 : 			}
; 1576 : 			else

	jmp	SHORT $LN4@SelectInit
$LN2@SelectInit:

; 1577 : 			{
; 1578 : 				SetMusterPlot(pMusterPt);

	mov	edx, DWORD PTR _pMusterPt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot
$LN4@SelectInit:

; 1579 : 			}
; 1580 : 		}
; 1581 : 	}
; 1582 : 
; 1583 : 	return pMusterPt;

	mov	eax, DWORD PTR _pMusterPt$[ebp]
$LN5@SelectInit:

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ENDP ; CvAIOperation::SelectInitialMusterPoint
_TEXT	ENDS
PUBLIC	??_C@_0FE@POAHIEHE@Could?5not?5recruit?5from?5secondary@ ; `string'
PUBLIC	??_C@_0FC@DDBJBAJA@Could?5not?5recruit?5from?5primary?5u@ ; `string'
PUBLIC	??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
PUBLIC	?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
PUBLIC	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
PUBLIC	??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::FStaticVector<CvOperationSearchUnit,128,1,297,0>
PUBLIC	__$ArrayPad$
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?getDropRange@CvUnit@@QBEHXZ:PROC		; CvUnit::getDropRange
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ:PROC	; CvUnit::canRecruitFromTacticalAI
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ:PROC ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
;	COMDAT ??_C@_0FE@POAHIEHE@Could?5not?5recruit?5from?5secondary@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0FE@POAHIEHE@Could?5not?5recruit?5from?5secondary@ DB 'Could not re'
	DB	'cruit from secondary units for muster at x=%d y=%d, target of'
	DB	' x=%d y=%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DDBJBAJA@Could?5not?5recruit?5from?5primary?5u@
CONST	SEGMENT
??_C@_0FC@DDBJBAJA@Could?5not?5recruit?5from?5primary?5u@ DB 'Could not r'
	DB	'ecruit from primary units for muster at x=%d y=%d, target of '
	DB	'x=%d y=%d', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$1
__ehfuncinfo$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
_TEXT	SEGMENT
tv568 = -1612						; size = 4
tv563 = -1608						; size = 4
tv558 = -1604						; size = 4
tv553 = -1600						; size = 4
tv343 = -1596						; size = 4
tv338 = -1592						; size = 4
tv333 = -1588						; size = 4
tv328 = -1584						; size = 4
tv159 = -1580						; size = 4
_this$ = -1576						; size = 4
$T236177 = -1548					; size = 4
$T236097 = -1472					; size = 4
$T236093 = -1468					; size = 4
$T236089 = -1464					; size = 4
$T236085 = -1460					; size = 4
$T236081 = -1456					; size = 4
$T236077 = -1452					; size = 4
$T236024 = -1392					; size = 4
$T236020 = -1388					; size = 4
$T236016 = -1384					; size = 4
$T236012 = -1380					; size = 4
$T236005 = -1376					; size = 4
$T236001 = -1372					; size = 4
$T235997 = -1368					; size = 4
$T235988 = -1364					; size = 4
_i$235971 = -1360					; size = 4
$T235930 = -1348					; size = 4
$T235874 = -1296					; size = 4
$T235870 = -1292					; size = 4
$T235866 = -1288					; size = 4
$T235862 = -1284					; size = 4
$T235858 = -1280					; size = 4
$T235854 = -1276					; size = 4
$T235813 = -1228					; size = 4
$T235809 = -1224					; size = 4
$T235805 = -1220					; size = 4
$T235801 = -1216					; size = 4
$T235794 = -1212					; size = 4
$T235790 = -1208					; size = 4
$T235786 = -1204					; size = 4
$T235777 = -1200					; size = 4
$T235765 = -1196					; size = 4
$T235761 = -1192					; size = 4
$T235735 = -1186					; size = 1
$T235726 = -1185					; size = 1
$T235725 = -1184					; size = 8
$T235716 = -1173					; size = 1
$T235715 = -1172					; size = 8
_pkLoopUnitPlot$224204 = -1164				; size = 4
_iDistance$224205 = -1160				; size = 4
_unitInfo$224192 = -1156				; size = 4
_eLoopUnitAIType$224190 = -1152				; size = 4
_pLoopUnit$224186 = -1148				; size = 4
_pkLoopUnitPlot$224173 = -1144				; size = 4
_iDistance$224174 = -1140				; size = 4
_unitInfo$224161 = -1136				; size = 4
_eLoopUnitAIType$224159 = -1132				; size = 4
_pLoopUnit$224155 = -1128				; size = 4
_thisSlotEntry$224152 = -1124				; size = 4
_bMustBeDeepWaterNaval$224153 = -1117			; size = 1
_iLoop$224154 = -1116					; size = 4
_thisFormation$224150 = -1112				; size = 4
_strMsg$ = -1108					; size = 28
_pBestUnit$ = -1080					; size = 4
_iThisFormationIndex$ = -1076				; size = 4
_ownerPlayer$ = -1072					; size = 4
_pThisArmy$ = -1068					; size = 4
_pTargetToUse$ = -1064					; size = 4
_kSearchList$ = -1060					; size = 1040
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_thisOperationSlot$ = 8					; size = 12
_pMusterPlot$ = 20					; size = 4
_pTargetPlot$ = 24					; size = 4
_bRequired$ = 28					; size = 4
?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z PROC ; CvAIOperation::FindBestFitReserveUnit, COMDAT
; _this$ = ecx

; 1694 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1600				; 00000640H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1695 : 	CvUnit* pBestUnit = NULL;

	mov	DWORD PTR _pBestUnit$[ebp], 0

; 1696 : 	CvPlayerAI& ownerPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _ownerPlayer$[ebp], ecx

; 1697 : 	CvArmyAI* pThisArmy = ownerPlayer.getArmyAI(thisOperationSlot.m_iArmyID);

	mov	edx, DWORD PTR _thisOperationSlot$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$[ebp], eax

; 1698 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1699 : 	CvPlot *pTargetToUse = pTargetPlot;

	mov	eax, DWORD PTR _pTargetPlot$[ebp]
	mov	DWORD PTR _pTargetToUse$[ebp], eax

; 1700 : 
; 1701 : 	CvOperationSearchUnitList kSearchList;

	lea	ecx, DWORD PTR _kSearchList$[ebp]
	call	??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::FStaticVector<CvOperationSearchUnit,128,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1702 : 
; 1703 : 	*bRequired = true;

	mov	ecx, DWORD PTR _bRequired$[ebp]
	mov	BYTE PTR [ecx], 1

; 1704 : 
; 1705 : 	// All naval operation targeting a city?   Change target
; 1706 : 	if (pTargetToUse && !pTargetToUse->isWater() && IsAllNavalOperation())

	cmp	DWORD PTR _pTargetToUse$[ebp], 0
	je	SHORT $LN48@FindBestFi
	mov	edx, DWORD PTR _pTargetToUse$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN48@FindBestFi
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN48@FindBestFi

; 1707 : 	{
; 1708 : 		pTargetToUse = ownerPlayer.GetMilitaryAI()->GetCoastalPlotAdjacentToTarget(pTargetToUse, pThisArmy);

	mov	edx, DWORD PTR _pThisArmy$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTargetToUse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	DWORD PTR _pTargetToUse$[ebp], eax
$LN48@FindBestFi:

; 1709 : 	}
; 1710 : 
; 1711 : 	int iThisFormationIndex = pThisArmy->GetFormationIndex();

	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	mov	DWORD PTR _iThisFormationIndex$[ebp], eax

; 1712 : 	if(iThisFormationIndex != NO_MUFORMATION)

	cmp	DWORD PTR _iThisFormationIndex$[ebp], -1
	je	$LN47@FindBestFi

; 1713 : 	{
; 1714 : 		CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(iThisFormationIndex);

	mov	ecx, DWORD PTR _iThisFormationIndex$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	DWORD PTR _thisFormation$224150[ebp], eax

; 1715 : 		if(thisFormation)

	cmp	DWORD PTR _thisFormation$224150[ebp], 0
	je	$LN47@FindBestFi

; 1716 : 		{
; 1717 : 			const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(thisOperationSlot.m_iSlotID);

	mov	edx, DWORD PTR _thisOperationSlot$[ebp+8]
	push	edx
	mov	ecx, DWORD PTR _thisFormation$224150[ebp]
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
	mov	DWORD PTR _thisSlotEntry$224152[ebp], eax

; 1718 : 			bool bMustBeDeepWaterNaval = GET_TEAM(ownerPlayer.getTeam()).canEmbarkAllWaterPassage() && thisFormation->IsRequiresNavalUnitConsistency();

	mov	eax, DWORD PTR _ownerPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235761[ebp], eax
	mov	edx, DWORD PTR $T235761[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235765[ebp], edx
	mov	ecx, DWORD PTR $T235765[ebp]
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN51@FindBestFi
	mov	ecx, DWORD PTR _thisFormation$224150[ebp]
	call	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN51@FindBestFi
	mov	DWORD PTR tv159[ebp], 1
	jmp	SHORT $LN52@FindBestFi
$LN51@FindBestFi:
	mov	DWORD PTR tv159[ebp], 0
$LN52@FindBestFi:
	mov	dl, BYTE PTR tv159[ebp]
	mov	BYTE PTR _bMustBeDeepWaterNaval$224153[ebp], dl

; 1719 : 
; 1720 : 			int iLoop = 0;

	mov	DWORD PTR _iLoop$224154[ebp], 0

; 1721 : 			for(CvUnit* pLoopUnit = ownerPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$224154[ebp]
	push	eax
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$224155[ebp], eax
	jmp	SHORT $LN45@FindBestFi
$LN44@FindBestFi:
	push	0
	lea	ecx, DWORD PTR _iLoop$224154[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$224155[ebp], eax
$LN45@FindBestFi:
	cmp	DWORD PTR _pLoopUnit$224155[ebp], 0
	je	$LN43@FindBestFi

; 1722 : 			{
; 1723 : 				const UnitAITypes eLoopUnitAIType = pLoopUnit->AI_getUnitAIType();

	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	mov	DWORD PTR _eLoopUnitAIType$224159[ebp], eax

; 1724 : 
; 1725 : 				// Make sure he's not needed by the tactical AI or already in an army or scouting
; 1726 : 				if(pLoopUnit->canRecruitFromTacticalAI() && pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX &&
; 1727 : 				        eLoopUnitAIType != UNITAI_EXPLORE && eLoopUnitAIType != UNITAI_EXPLORE_SEA && pLoopUnit->getDropRange() == 0 /* no paratroopers */)

	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	movzx	edx, al
	test	edx, edx
	je	$LN42@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN42@FindBestFi
	cmp	DWORD PTR _eLoopUnitAIType$224159[ebp], 10 ; 0000000aH
	je	$LN42@FindBestFi
	cmp	DWORD PTR _eLoopUnitAIType$224159[ebp], 21 ; 00000015H
	je	$LN42@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?getDropRange@CvUnit@@QBEHXZ		; CvUnit::getDropRange
	test	eax, eax
	jne	$LN42@FindBestFi

; 1728 : 				{
; 1729 : 					// Is this unit one of the requested types?
; 1730 : 					CvUnitEntry* unitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());

	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _unitInfo$224161[ebp], eax

; 1731 : 					if(unitInfo == NULL)

	cmp	DWORD PTR _unitInfo$224161[ebp], 0
	jne	SHORT $LN41@FindBestFi

; 1732 : 						continue;

	jmp	$LN44@FindBestFi
$LN41@FindBestFi:

; 1733 : 
; 1734 : 					// PRIMARY UNIT TYPE (ONLY)
; 1735 : 
; 1736 : 					if(unitInfo->GetUnitAIType((UnitAITypes)thisSlotEntry.m_primaryUnitType))

	mov	eax, DWORD PTR _thisSlotEntry$224152[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _unitInfo$224161[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	edx, al
	test	edx, edx
	je	$LN42@FindBestFi

; 1737 : 					{
; 1738 : 						// Is his health okay?
; 1739 : 						if(!pLoopUnit->IsCombatUnit() || pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	mov	eax, DWORD PTR _pLoopUnit$224155[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN97@FindBestFi
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	DWORD PTR $T235777[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	esi, eax
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	imul	eax, DWORD PTR $T235777[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	esi, eax
	jl	$LN42@FindBestFi

; 1740 : 						{
; 1741 : 							// Not finishing up an operation?
; 1742 : 							if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

$LN97@FindBestFi:
	mov	edx, DWORD PTR _pLoopUnit$224155[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR $T235786[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T235790[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235794[ebp], edx
	mov	esi, DWORD PTR $T235786[ebp]
	add	esi, DWORD PTR $T235790[ebp]
	mov	ecx, DWORD PTR $T235794[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jge	$LN42@FindBestFi

; 1743 : 							{
; 1744 : 								if((!IsAllNavalOperation() && !IsMixedLandNavalOperation()) || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN34@FindBestFi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN35@FindBestFi
$LN34@FindBestFi:
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN35@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	ecx, al
	test	ecx, ecx
	je	$LN42@FindBestFi
$LN35@FindBestFi:

; 1745 : 								{
; 1746 : 									if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	movzx	edx, BYTE PTR _bMustBeDeepWaterNaval$224153[ebp]
	test	edx, edx
	je	SHORT $LN32@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN32@FindBestFi
	push	6
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	add	ecx, 1972				; 000007b4H
	call	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN42@FindBestFi
$LN32@FindBestFi:

; 1747 : 									{
; 1748 : 										// Get raw distance to the muster point or target
; 1749 : 										CvPlot* pkLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pkLoopUnitPlot$224173[ebp], eax

; 1750 : 										int iDistance;
; 1751 : 										if(pMusterPlot != NULL)

	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	$LN31@FindBestFi

; 1752 : 										{
; 1753 : 											iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pMusterPlot->getX(), pMusterPlot->getY());

	mov	eax, DWORD PTR _pMusterPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235801[ebp], ecx
	mov	edx, DWORD PTR _pMusterPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235805[ebp], eax
	mov	ecx, DWORD PTR _pkLoopUnitPlot$224173[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235809[ebp], edx
	mov	eax, DWORD PTR _pkLoopUnitPlot$224173[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T235813[ebp], ecx
	mov	edx, DWORD PTR $T235801[ebp]
	push	edx
	mov	eax, DWORD PTR $T235805[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235809[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235813[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$224174[ebp], eax

; 1754 : 											// Double the distance if this is a land unit on a different landmass (it's dangerous to go over water!)
; 1755 : 											if(pMusterPlot != NULL && pLoopUnit->getDomainType() == DOMAIN_LAND && pkLoopUnitPlot->getArea() != pMusterPlot->getArea())

	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	SHORT $LN30@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224155[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN30@FindBestFi
	mov	eax, DWORD PTR _pkLoopUnitPlot$224173[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T235854[ebp], ecx
	mov	edx, DWORD PTR _pMusterPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T235858[ebp], eax
	mov	ecx, DWORD PTR $T235854[ebp]
	cmp	ecx, DWORD PTR $T235858[ebp]
	je	SHORT $LN30@FindBestFi

; 1756 : 											{
; 1757 : 												iDistance *= 2;

	mov	edx, DWORD PTR _iDistance$224174[ebp]
	shl	edx, 1
	mov	DWORD PTR _iDistance$224174[ebp], edx
$LN30@FindBestFi:

; 1758 : 											}
; 1759 : 										}
; 1760 : 										else

	jmp	SHORT $LN29@FindBestFi
$LN31@FindBestFi:

; 1761 : 										{
; 1762 : 											if (pTargetToUse != NULL)

	cmp	DWORD PTR _pTargetToUse$[ebp], 0
	je	SHORT $LN28@FindBestFi

; 1763 : 												iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pTargetToUse->getX(), pTargetToUse->getY());

	mov	eax, DWORD PTR _pTargetToUse$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235862[ebp], ecx
	mov	edx, DWORD PTR _pTargetToUse$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235866[ebp], eax
	mov	ecx, DWORD PTR _pkLoopUnitPlot$224173[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235870[ebp], edx
	mov	eax, DWORD PTR _pkLoopUnitPlot$224173[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T235874[ebp], ecx
	mov	edx, DWORD PTR $T235862[ebp]
	push	edx
	mov	eax, DWORD PTR $T235866[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235870[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235874[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$224174[ebp], eax

; 1764 : 											else

	jmp	SHORT $LN29@FindBestFi
$LN28@FindBestFi:

; 1765 : 											{
; 1766 : 												CvAssertMsg(0, "No muster or target!");
; 1767 : 												iDistance = MAX_INT;

	mov	DWORD PTR _iDistance$224174[ebp], 2147483647 ; 7fffffffH
$LN29@FindBestFi:

; 1768 : 											}
; 1769 : 										}
; 1770 : 
; 1771 : 										kSearchList.push_back(CvOperationSearchUnit(pLoopUnit, iDistance));

	mov	eax, DWORD PTR _pLoopUnit$224155[ebp]
	mov	DWORD PTR $T235715[ebp+4], eax
	mov	ecx, DWORD PTR _iDistance$224174[ebp]
	mov	DWORD PTR $T235715[ebp], ecx
	lea	edx, DWORD PTR $T235715[ebp]
	push	edx
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	call	?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
$LN42@FindBestFi:

; 1772 : 									}
; 1773 : 								}
; 1774 : 							}
; 1775 : 						}
; 1776 : 					}
; 1777 : 				}
; 1778 : 			}

	jmp	$LN44@FindBestFi
$LN43@FindBestFi:

; 1779 : 
; 1780 : 			pBestUnit = GetClosestUnit(kSearchList, pMusterPlot, pTargetToUse, NeedToCheckPathToTarget());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _pTargetToUse$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMusterPlot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	push	ecx
	call	?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z ; GetClosestUnit
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pBestUnit$[ebp], eax

; 1781 : 
; 1782 : 			// Did we find one?
; 1783 : 			if(pBestUnit != NULL)

	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN26@FindBestFi

; 1784 : 			{
; 1785 : 				pThisArmy->AddUnit(pBestUnit->GetID(), thisOperationSlot.m_iSlotID);

	mov	edx, DWORD PTR _pBestUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T235930[ebp], eax
	mov	ecx, DWORD PTR _thisOperationSlot$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR $T235930[ebp]
	push	edx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 1786 : 				return true;

	mov	BYTE PTR $T235716[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	call	??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T235716[ebp]
	jmp	$LN49@FindBestFi

; 1787 : 			}
; 1788 : 			else

	jmp	$LN25@FindBestFi
$LN26@FindBestFi:

; 1789 : 			{
; 1790 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN25@FindBestFi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN25@FindBestFi

; 1791 : 				{
; 1792 : 					strMsg.Format("Could not recruit from primary units for muster at x=%d y=%d, target of x=%d y=%d", (pMusterPlot)?pMusterPlot->getX():-1, (pMusterPlot)?pMusterPlot->getY():-1, (pTargetToUse)?pTargetToUse->getX():-1, (pTargetToUse)?pTargetToUse->getY():-1);

	cmp	DWORD PTR _pTargetToUse$[ebp], 0
	je	SHORT $LN53@FindBestFi
	mov	edx, DWORD PTR _pTargetToUse$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR tv328[ebp], eax
	jmp	SHORT $LN54@FindBestFi
$LN53@FindBestFi:
	mov	DWORD PTR tv328[ebp], -1
$LN54@FindBestFi:
	cmp	DWORD PTR _pTargetToUse$[ebp], 0
	je	SHORT $LN55@FindBestFi
	mov	ecx, DWORD PTR _pTargetToUse$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR tv333[ebp], edx
	jmp	SHORT $LN56@FindBestFi
$LN55@FindBestFi:
	mov	DWORD PTR tv333[ebp], -1
$LN56@FindBestFi:
	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	SHORT $LN57@FindBestFi
	mov	eax, DWORD PTR _pMusterPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR tv338[ebp], ecx
	jmp	SHORT $LN58@FindBestFi
$LN57@FindBestFi:
	mov	DWORD PTR tv338[ebp], -1
$LN58@FindBestFi:
	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	SHORT $LN59@FindBestFi
	mov	edx, DWORD PTR _pMusterPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR tv343[ebp], eax
	jmp	SHORT $LN60@FindBestFi
$LN59@FindBestFi:
	mov	DWORD PTR tv343[ebp], -1
$LN60@FindBestFi:
	mov	ecx, DWORD PTR tv328[ebp]
	push	ecx
	mov	edx, DWORD PTR tv333[ebp]
	push	edx
	mov	eax, DWORD PTR tv338[ebp]
	push	eax
	mov	ecx, DWORD PTR tv343[ebp]
	push	ecx
	push	OFFSET ??_C@_0FC@DDBJBAJA@Could?5not?5recruit?5from?5primary?5u@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1793 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN25@FindBestFi:

; 1794 : 				}
; 1795 : 			}
; 1796 : 
; 1797 : 			kSearchList.clear();

	xor	ecx, ecx
	je	SHORT $LN212@FindBestFi
	mov	DWORD PTR _i$235971[ebp], 0
	jmp	SHORT $LN210@FindBestFi
$LN209@FindBestFi:
	mov	edx, DWORD PTR _i$235971[ebp]
	add	edx, 1
	mov	DWORD PTR _i$235971[ebp], edx
$LN210@FindBestFi:
	mov	eax, DWORD PTR _i$235971[ebp]
	cmp	eax, DWORD PTR _kSearchList$[ebp+4]
	jae	SHORT $LN212@FindBestFi
	jmp	SHORT $LN209@FindBestFi
$LN212@FindBestFi:
	mov	DWORD PTR _kSearchList$[ebp+4], 0

; 1798 : 			// Loop again this time through secondary units
; 1799 : 			for(CvUnit* pLoopUnit = ownerPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$224154[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$224186[ebp], eax
	jmp	SHORT $LN23@FindBestFi
$LN22@FindBestFi:
	push	0
	lea	edx, DWORD PTR _iLoop$224154[ebp]
	push	edx
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$224186[ebp], eax
$LN23@FindBestFi:
	cmp	DWORD PTR _pLoopUnit$224186[ebp], 0
	je	$LN21@FindBestFi

; 1800 : 			{
; 1801 : 				const UnitAITypes eLoopUnitAIType = pLoopUnit->AI_getUnitAIType();

	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	mov	DWORD PTR _eLoopUnitAIType$224190[ebp], eax

; 1802 : 
; 1803 : 				// Make sure he's not needed by the tactical AI or already in an army or scouting
; 1804 : 				if(pLoopUnit->canRecruitFromTacticalAI() && pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX &&
; 1805 : 				        eLoopUnitAIType != UNITAI_EXPLORE && eLoopUnitAIType != UNITAI_EXPLORE_SEA && pLoopUnit->getDropRange() == 0 /* no paratroopers */)

	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	movzx	eax, al
	test	eax, eax
	je	$LN20@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN20@FindBestFi
	cmp	DWORD PTR _eLoopUnitAIType$224190[ebp], 10 ; 0000000aH
	je	$LN20@FindBestFi
	cmp	DWORD PTR _eLoopUnitAIType$224190[ebp], 21 ; 00000015H
	je	$LN20@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?getDropRange@CvUnit@@QBEHXZ		; CvUnit::getDropRange
	test	eax, eax
	jne	$LN20@FindBestFi

; 1806 : 				{
; 1807 : 					// Is this unit one of the requested types?
; 1808 : 					CvUnitEntry* unitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());

	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _unitInfo$224192[ebp], eax

; 1809 : 					if(unitInfo == NULL)

	cmp	DWORD PTR _unitInfo$224192[ebp], 0
	jne	SHORT $LN19@FindBestFi

; 1810 : 						continue;

	jmp	$LN22@FindBestFi
$LN19@FindBestFi:

; 1811 : 
; 1812 : 					// SECONDARY UNIT TYPE (ONLY)
; 1813 : 
; 1814 : 					if(unitInfo->GetUnitAIType((UnitAITypes)thisSlotEntry.m_secondaryUnitType))

	mov	ecx, DWORD PTR _thisSlotEntry$224152[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _unitInfo$224192[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	je	$LN20@FindBestFi

; 1815 : 					{
; 1816 : 						// Is his health okay?
; 1817 : 						if(!pLoopUnit->IsCombatUnit() || pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN222@FindBestFi
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	DWORD PTR $T235988[ebp], ecx
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	mov	esi, eax
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	imul	eax, DWORD PTR $T235988[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	esi, eax
	jl	$LN20@FindBestFi

; 1818 : 						{
; 1819 : 							// Not finishing up an operation?
; 1820 : 							if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

$LN222@FindBestFi:
	mov	edx, DWORD PTR _pLoopUnit$224186[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR $T235997[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T236001[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236005[ebp], edx
	mov	esi, DWORD PTR $T235997[ebp]
	add	esi, DWORD PTR $T236001[ebp]
	mov	ecx, DWORD PTR $T236005[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jge	$LN20@FindBestFi

; 1821 : 							{
; 1822 : 								if((!IsAllNavalOperation() && !IsMixedLandNavalOperation()) || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@FindBestFi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@FindBestFi
$LN12@FindBestFi:
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN13@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	ecx, al
	test	ecx, ecx
	je	$LN20@FindBestFi
$LN13@FindBestFi:

; 1823 : 								{
; 1824 : 									if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	movzx	edx, BYTE PTR _bMustBeDeepWaterNaval$224153[ebp]
	test	edx, edx
	je	SHORT $LN10@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN10@FindBestFi
	push	6
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	add	ecx, 1972				; 000007b4H
	call	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	$LN20@FindBestFi
$LN10@FindBestFi:

; 1825 : 									{
; 1826 : 										// Get raw distance to the muster point or target
; 1827 : 										CvPlot* pkLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pkLoopUnitPlot$224204[ebp], eax

; 1828 : 										int iDistance;
; 1829 : 										if(pMusterPlot != NULL)

	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	$LN9@FindBestFi

; 1830 : 										{
; 1831 : 											iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pMusterPlot->getX(), pMusterPlot->getY());

	mov	eax, DWORD PTR _pMusterPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236012[ebp], ecx
	mov	edx, DWORD PTR _pMusterPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236016[ebp], eax
	mov	ecx, DWORD PTR _pkLoopUnitPlot$224204[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236020[ebp], edx
	mov	eax, DWORD PTR _pkLoopUnitPlot$224204[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T236024[ebp], ecx
	mov	edx, DWORD PTR $T236012[ebp]
	push	edx
	mov	eax, DWORD PTR $T236016[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236020[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236024[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$224205[ebp], eax

; 1832 : 											// Double the distance if this is a land unit on a different landmass (it's dangerous to go over water!)
; 1833 : 											if(pMusterPlot != NULL && pLoopUnit->getDomainType() == DOMAIN_LAND && pkLoopUnitPlot->getArea() != pMusterPlot->getArea())

	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	SHORT $LN8@FindBestFi
	mov	ecx, DWORD PTR _pLoopUnit$224186[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN8@FindBestFi
	mov	eax, DWORD PTR _pkLoopUnitPlot$224204[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T236077[ebp], ecx
	mov	edx, DWORD PTR _pMusterPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T236081[ebp], eax
	mov	ecx, DWORD PTR $T236077[ebp]
	cmp	ecx, DWORD PTR $T236081[ebp]
	je	SHORT $LN8@FindBestFi

; 1834 : 											{
; 1835 : 												iDistance *= 2;

	mov	edx, DWORD PTR _iDistance$224205[ebp]
	shl	edx, 1
	mov	DWORD PTR _iDistance$224205[ebp], edx
$LN8@FindBestFi:

; 1836 : 											}
; 1837 : 										}
; 1838 : 										else

	jmp	SHORT $LN7@FindBestFi
$LN9@FindBestFi:

; 1839 : 										{
; 1840 : 											if (pTargetToUse != NULL)

	cmp	DWORD PTR _pTargetToUse$[ebp], 0
	je	SHORT $LN6@FindBestFi

; 1841 : 												iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pTargetToUse->getX(), pTargetToUse->getY());

	mov	eax, DWORD PTR _pTargetToUse$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236085[ebp], ecx
	mov	edx, DWORD PTR _pTargetToUse$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236089[ebp], eax
	mov	ecx, DWORD PTR _pkLoopUnitPlot$224204[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236093[ebp], edx
	mov	eax, DWORD PTR _pkLoopUnitPlot$224204[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T236097[ebp], ecx
	mov	edx, DWORD PTR $T236085[ebp]
	push	edx
	mov	eax, DWORD PTR $T236089[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236093[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236097[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$224205[ebp], eax

; 1842 : 											else

	jmp	SHORT $LN7@FindBestFi
$LN6@FindBestFi:

; 1843 : 											{
; 1844 : 												CvAssertMsg(0, "No muster or target!");
; 1845 : 												iDistance = MAX_INT;

	mov	DWORD PTR _iDistance$224205[ebp], 2147483647 ; 7fffffffH
$LN7@FindBestFi:

; 1846 : 											}
; 1847 : 										}
; 1848 : 
; 1849 : 										kSearchList.push_back(CvOperationSearchUnit(pLoopUnit, iDistance));

	mov	eax, DWORD PTR _pLoopUnit$224186[ebp]
	mov	DWORD PTR $T235725[ebp+4], eax
	mov	ecx, DWORD PTR _iDistance$224205[ebp]
	mov	DWORD PTR $T235725[ebp], ecx
	lea	edx, DWORD PTR $T235725[ebp]
	push	edx
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	call	?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
$LN20@FindBestFi:

; 1850 : 									}
; 1851 : 								}
; 1852 : 							}
; 1853 : 						}
; 1854 : 					}
; 1855 : 				}
; 1856 : 			}

	jmp	$LN22@FindBestFi
$LN21@FindBestFi:

; 1857 : 
; 1858 : 			pBestUnit = GetClosestUnit(kSearchList, pMusterPlot, pTargetToUse, NeedToCheckPathToTarget());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _pTargetToUse$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMusterPlot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	push	ecx
	call	?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z ; GetClosestUnit
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pBestUnit$[ebp], eax

; 1859 : 
; 1860 : 			// Did we find one?
; 1861 : 			if(pBestUnit != NULL)

	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN4@FindBestFi

; 1862 : 			{
; 1863 : 				pThisArmy->AddUnit(pBestUnit->GetID(), thisOperationSlot.m_iSlotID);

	mov	edx, DWORD PTR _pBestUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T236177[ebp], eax
	mov	ecx, DWORD PTR _thisOperationSlot$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR $T236177[ebp]
	push	edx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 1864 : 				return true;

	mov	BYTE PTR $T235726[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	call	??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T235726[ebp]
	jmp	$LN49@FindBestFi

; 1865 : 			}
; 1866 : 			else

	jmp	$LN3@FindBestFi
$LN4@FindBestFi:

; 1867 : 			{
; 1868 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN3@FindBestFi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@FindBestFi

; 1869 : 				{
; 1870 : 					strMsg.Format("Could not recruit from secondary units for muster at x=%d y=%d, target of x=%d y=%d", (pMusterPlot)?pMusterPlot->getX():-1, (pMusterPlot)?pMusterPlot->getY():-1, (pTargetToUse)?pTargetToUse->getX():-1, (pTargetToUse)?pTargetToUse->getY():-1);

	cmp	DWORD PTR _pTargetToUse$[ebp], 0
	je	SHORT $LN61@FindBestFi
	mov	edx, DWORD PTR _pTargetToUse$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR tv553[ebp], eax
	jmp	SHORT $LN62@FindBestFi
$LN61@FindBestFi:
	mov	DWORD PTR tv553[ebp], -1
$LN62@FindBestFi:
	cmp	DWORD PTR _pTargetToUse$[ebp], 0
	je	SHORT $LN63@FindBestFi
	mov	ecx, DWORD PTR _pTargetToUse$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR tv558[ebp], edx
	jmp	SHORT $LN64@FindBestFi
$LN63@FindBestFi:
	mov	DWORD PTR tv558[ebp], -1
$LN64@FindBestFi:
	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	SHORT $LN65@FindBestFi
	mov	eax, DWORD PTR _pMusterPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR tv563[ebp], ecx
	jmp	SHORT $LN66@FindBestFi
$LN65@FindBestFi:
	mov	DWORD PTR tv563[ebp], -1
$LN66@FindBestFi:
	cmp	DWORD PTR _pMusterPlot$[ebp], 0
	je	SHORT $LN67@FindBestFi
	mov	edx, DWORD PTR _pMusterPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR tv568[ebp], eax
	jmp	SHORT $LN68@FindBestFi
$LN67@FindBestFi:
	mov	DWORD PTR tv568[ebp], -1
$LN68@FindBestFi:
	mov	ecx, DWORD PTR tv553[ebp]
	push	ecx
	mov	edx, DWORD PTR tv558[ebp]
	push	edx
	mov	eax, DWORD PTR tv563[ebp]
	push	eax
	mov	ecx, DWORD PTR tv568[ebp]
	push	ecx
	push	OFFSET ??_C@_0FE@POAHIEHE@Could?5not?5recruit?5from?5secondary@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1871 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@FindBestFi:

; 1872 : 				}
; 1873 : 			}
; 1874 : 
; 1875 : 			// If not required, let our calling routine know that
; 1876 : 			if(!thisSlotEntry.m_requiredSlot)

	mov	ecx, DWORD PTR _thisSlotEntry$224152[ebp]
	movzx	edx, BYTE PTR [ecx+12]
	test	edx, edx
	jne	SHORT $LN47@FindBestFi

; 1877 : 			{
; 1878 : 				*bRequired = false;

	mov	eax, DWORD PTR _bRequired$[ebp]
	mov	BYTE PTR [eax], 0
$LN47@FindBestFi:

; 1879 : 			}
; 1880 : 		}
; 1881 : 	}
; 1882 : 
; 1883 : 	return false;

	mov	BYTE PTR $T235735[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	call	??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T235735[ebp]
$LN49@FindBestFi:

; 1884 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$1:
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	jmp	??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
__ehhandler$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1608]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ENDP ; CvAIOperation::FindBestFitReserveUnit
PUBLIC	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
EXTRN	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ:PROC ; CvIgnoreUnitsPathFinder::GetPathLength
EXTRN	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z:PROC ; CvIgnoreUnitsPathFinder::DoesPathExist
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
; Function compile flags: /Odtp
;	COMDAT ?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z
_TEXT	SEGMENT
$T236325 = -80						; size = 4
$T236271 = -40						; size = 4
$T236267 = -36						; size = 4
$T236263 = -32						; size = 4
_iDistance$224124 = -28					; size = 4
_iPathDistance$224125 = -24				; size = 4
_pkLoopUnit$224123 = -20				; size = 4
_itr$224119 = -16					; size = 4
_iBestDistance$224117 = -12				; size = 4
_kPathFinder$224118 = -8				; size = 4
_pkBestUnit$ = -4					; size = 4
_kSearchList$ = 8					; size = 4
_pkMusterPlot$ = 12					; size = 4
_pkTarget$ = 16						; size = 4
_bNeedToCheckTarget$ = 20				; size = 1
?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z PROC ; GetClosestUnit, COMDAT

; 1622 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 1623 : 	CvUnit* pkBestUnit = NULL;

	mov	DWORD PTR _pkBestUnit$[ebp], 0

; 1624 : 	if (kSearchList.size())

	mov	eax, DWORD PTR _kSearchList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236263[ebp], ecx
	cmp	DWORD PTR $T236263[ebp], 0
	je	$LN12@GetClosest

; 1625 : 	{
; 1626 : 		std::stable_sort(kSearchList.begin(), kSearchList.end());

	mov	edx, DWORD PTR _kSearchList$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _kSearchList$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T236267[ebp], eax
	mov	ecx, DWORD PTR _kSearchList$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T236271[ebp], edx
	mov	eax, DWORD PTR $T236271[ebp]
	cmp	eax, DWORD PTR $T236267[ebp]
	je	SHORT $LN22@GetClosest
	push	0
	push	0
	mov	ecx, DWORD PTR $T236267[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236271[ebp]
	push	edx
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H
$LN22@GetClosest:

; 1627 : 
; 1628 : 		int iBestDistance = MAX_INT;

	mov	DWORD PTR _iBestDistance$224117[ebp], 2147483647 ; 7fffffffH

; 1629 : 		CvIgnoreUnitsPathFinder& kPathFinder = GC.getIgnoreUnitsPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR _kPathFinder$224118[ebp], eax

; 1630 : 		for (CvOperationSearchUnitList::iterator itr = kSearchList.begin(); itr != kSearchList.end(); ++itr)

	mov	eax, DWORD PTR _kSearchList$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _itr$224119[ebp], ecx
	jmp	SHORT $LN41@GetClosest
$LN10@GetClosest:
	mov	edx, DWORD PTR _itr$224119[ebp]
	add	edx, 8
	mov	DWORD PTR _itr$224119[ebp], edx
$LN41@GetClosest:
	mov	eax, DWORD PTR _kSearchList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _kSearchList$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	cmp	DWORD PTR _itr$224119[ebp], ecx
	je	$LN12@GetClosest

; 1631 : 		{
; 1632 : 			CvUnit *pkLoopUnit = (*itr).GetUnit();

	mov	edx, DWORD PTR _itr$224119[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _pkLoopUnit$224123[ebp], eax

; 1633 : #ifdef AUI_WARNING_FIXES
; 1634 : 			if (!pkLoopUnit)
; 1635 : 				continue;
; 1636 : #endif
; 1637 : 			int iDistance = (*itr).GetDistance();

	mov	ecx, DWORD PTR _itr$224119[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iDistance$224124[ebp], edx

; 1638 : 
; 1639 : 			int iPathDistance = MAX_INT;

	mov	DWORD PTR _iPathDistance$224125[ebp], 2147483647 ; 7fffffffH

; 1640 : 			// Now loop through the units, using the pathfinder to do the final evaluation
; 1641 : 			if (pkMusterPlot != NULL)

	cmp	DWORD PTR _pkMusterPlot$[ebp], 0
	je	SHORT $LN8@GetClosest

; 1642 : 			{
; 1643 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1644 : 				if (!kPathFinder.DoesPathExist(pkLoopUnit, pkLoopUnit->plot(), pkMusterPlot))
; 1645 : #else
; 1646 : 				if (!kPathFinder.DoesPathExist(*pkLoopUnit, pkLoopUnit->plot(), pkMusterPlot))

	mov	eax, DWORD PTR _pkMusterPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkLoopUnit$224123[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pkLoopUnit$224123[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPathFinder$224118[ebp]
	call	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@GetClosest

; 1647 : #endif
; 1648 : 					continue;

	jmp	SHORT $LN10@GetClosest
$LN7@GetClosest:

; 1649 : 
; 1650 : 				iPathDistance = kPathFinder.GetPathLength();

	mov	ecx, DWORD PTR _kPathFinder$224118[ebp]
	call	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ ; CvIgnoreUnitsPathFinder::GetPathLength
	mov	DWORD PTR _iPathDistance$224125[ebp], eax
$LN8@GetClosest:

; 1651 : 			}
; 1652 : 
; 1653 : 			if(pkTarget != NULL && bNeedToCheckTarget)

	cmp	DWORD PTR _pkTarget$[ebp], 0
	je	SHORT $LN6@GetClosest
	movzx	eax, BYTE PTR _bNeedToCheckTarget$[ebp]
	test	eax, eax
	je	SHORT $LN6@GetClosest

; 1654 : 			{
; 1655 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1656 : 				if (!kPathFinder.DoesPathExist(pkLoopUnit, pkLoopUnit->plot(), pkTarget))
; 1657 : #else
; 1658 : 				if (!kPathFinder.DoesPathExist(*pkLoopUnit, pkLoopUnit->plot(), pkTarget))

	mov	ecx, DWORD PTR _pkTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkLoopUnit$224123[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	edx, DWORD PTR _pkLoopUnit$224123[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPathFinder$224118[ebp]
	call	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@GetClosest

; 1659 : #endif
; 1660 : 					continue;

	jmp	$LN10@GetClosest
$LN5@GetClosest:

; 1661 : 
; 1662 : 				if (pkMusterPlot == NULL)

	cmp	DWORD PTR _pkMusterPlot$[ebp], 0
	jne	SHORT $LN6@GetClosest

; 1663 : 					iPathDistance = kPathFinder.GetPathLength();

	mov	ecx, DWORD PTR _kPathFinder$224118[ebp]
	call	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ ; CvIgnoreUnitsPathFinder::GetPathLength
	mov	DWORD PTR _iPathDistance$224125[ebp], eax
$LN6@GetClosest:

; 1664 : 			}
; 1665 : 
; 1666 : 			// Reasonably close?
; 1667 : 			if (iPathDistance <= iDistance && iPathDistance <= iBestDistance)

	mov	ecx, DWORD PTR _iPathDistance$224125[ebp]
	cmp	ecx, DWORD PTR _iDistance$224124[ebp]
	jg	SHORT $LN3@GetClosest
	mov	edx, DWORD PTR _iPathDistance$224125[ebp]
	cmp	edx, DWORD PTR _iBestDistance$224117[ebp]
	jg	SHORT $LN3@GetClosest

; 1668 : 			{
; 1669 : 				pkBestUnit = pkLoopUnit;

	mov	eax, DWORD PTR _pkLoopUnit$224123[ebp]
	mov	DWORD PTR _pkBestUnit$[ebp], eax

; 1670 : 				break;

	jmp	SHORT $LN12@GetClosest
$LN3@GetClosest:

; 1671 : 			}
; 1672 : 
; 1673 : 			if (iPathDistance < iBestDistance)

	mov	ecx, DWORD PTR _iPathDistance$224125[ebp]
	cmp	ecx, DWORD PTR _iBestDistance$224117[ebp]
	jge	SHORT $LN2@GetClosest

; 1674 : 			{
; 1675 : 				pkBestUnit = pkLoopUnit;

	mov	edx, DWORD PTR _pkLoopUnit$224123[ebp]
	mov	DWORD PTR _pkBestUnit$[ebp], edx

; 1676 : 				iBestDistance = iPathDistance;

	mov	eax, DWORD PTR _iPathDistance$224125[ebp]
	mov	DWORD PTR _iBestDistance$224117[ebp], eax
$LN2@GetClosest:

; 1677 : 			}
; 1678 : 
; 1679 : 			// Were we far away?  If so, this is probably the best we are going to do
; 1680 : 			if (iDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572
	mov	DWORD PTR $T236325[ebp], ecx
	mov	edx, DWORD PTR _iDistance$224124[ebp]
	cmp	edx, DWORD PTR $T236325[ebp]
	jl	SHORT $LN1@GetClosest

; 1681 : 				break;

	jmp	SHORT $LN12@GetClosest
$LN1@GetClosest:

; 1682 : 		}

	jmp	$LN10@GetClosest
$LN12@GetClosest:

; 1683 : 	}
; 1684 : 
; 1685 : 	return pkBestUnit;

	mov	eax, DWORD PTR _pkBestUnit$[ebp]

; 1686 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z ENDP ; GetClosestUnit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z
_TEXT	SEGMENT
$T236328 = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z PROC ; operator<<, COMDAT

; 1887 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1888 : 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236328[ebp], ecx
	lea	edx, DWORD PTR $T236328[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1889 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 1890 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z ENDP ; operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z
_TEXT	SEGMENT
_v$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z PROC ; operator>>, COMDAT

; 1892 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1893 : 	int v;
; 1894 : 	loadFrom >> v;

	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1895 : 	writeTo = static_cast<AIOperationMovementType>(v);

	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx

; 1896 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 1897 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??_7CvAIEnemyTerritoryOperation@@6B@		; CvAIEnemyTerritoryOperation::`vftable'
PUBLIC	??0CvAIEnemyTerritoryOperation@@QAE@XZ		; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
PUBLIC	?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIEnemyTerritoryOperation::Init
PUBLIC	?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ ; CvAIEnemyTerritoryOperation::GetMaximumRecruitTurns
PUBLIC	?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ; CvAIEnemyTerritoryOperation::SelectInitialMusterPoint
PUBLIC	?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ ; CvAIEnemyTerritoryOperation::GetDeployRange
EXTRN	??_ECvAIEnemyTerritoryOperation@@UAEPAXI@Z:PROC	; CvAIEnemyTerritoryOperation::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_7CvAIEnemyTerritoryOperation@@6B@
CONST	SEGMENT
??_7CvAIEnemyTerritoryOperation@@6B@ DD FLAT:??_ECvAIEnemyTerritoryOperation@@UAEPAXI@Z ; CvAIEnemyTerritoryOperation::`vftable'
	DD	FLAT:?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIEnemyTerritoryOperation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIEnemyTerritoryOperation@@QAE@XZ PROC		; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation, COMDAT
; _this$ = ecx

; 1903 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@

; 1904 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIEnemyTerritoryOperation@@QAE@XZ ENDP		; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
_TEXT	ENDS
PUBLIC	??1CvAIEnemyTerritoryOperation@@UAE@XZ		; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIEnemyTerritoryOperation@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIEnemyTerritoryOperation@@UAEPAXI@Z PROC		; CvAIEnemyTerritoryOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEnemyTerritoryOperation@@UAE@XZ	; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIEnemyTerritoryOperation@@UAEPAXI@Z ENDP		; CvAIEnemyTerritoryOperation::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIEnemyTerritoryOperation@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIEnemyTerritoryOperation@@UAE@XZ PROC		; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation, COMDAT
; _this$ = ecx

; 1907 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@

; 1908 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIEnemyTerritoryOperation@@UAE@XZ ENDP		; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T236350 = -4						; size = 4
?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ PROC ; CvAIEnemyTerritoryOperation::GetMaximumRecruitTurns, COMDAT
; _this$ = ecx

; 1912 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1913 : 	return GC.getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7856
	mov	DWORD PTR $T236350[ebp], eax
	mov	eax, DWORD PTR $T236350[ebp]

; 1914 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ ENDP ; CvAIEnemyTerritoryOperation::GetMaximumRecruitTurns
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
EXTRN	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z:PROC ; CvStepPathFinder::GetXPlotsFromEnd
EXTRN	?SetXY@CvArmyAI@@QAEXHH@Z:PROC			; CvArmyAI::SetXY
EXTRN	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z:PROC	; CvArmyAI::SetGoalPlot
EXTRN	?SetFormationIndex@CvArmyAI@@QAEXH@Z:PROC	; CvArmyAI::SetFormationIndex
EXTRN	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z:PROC	; CvArmyAI::Init
EXTRN	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ:PROC	; CvPlayer::addArmyAI
; Function compile flags: /Odtp
;	COMDAT ?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T236503 = -112						; size = 4
$T236499 = -108						; size = 4
$T236495 = -104						; size = 4
$T236494 = -100						; size = 4
$T236490 = -96						; size = 4
$T236486 = -92						; size = 4
$T236485 = -88						; size = 4
$T236353 = -20						; size = 4
_pDeployPt$224263 = -16					; size = 4
_pTargetPlot$224258 = -12				; size = 4
_pArmyAI$224255 = -8					; size = 4
_kPlayer$224254 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIEnemyTerritoryOperation::Init, COMDAT
; _this$ = ecx

; 1918 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 1919 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 1920 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 1

; 1921 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 1922 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 1923 : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 1924 : 
; 1925 : 	if(iID != -1)

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN13@Init

; 1926 : 	{
; 1927 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 1928 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224254[ebp], eax

; 1929 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, DWORD PTR _kPlayer$224254[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$224255[ebp], eax

; 1930 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$224255[ebp], 0
	je	$LN13@Init

; 1931 : 		{
; 1932 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T236353[ebp], eax
	lea	ecx, DWORD PTR $T236353[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 1933 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 1934 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 1935 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 1936 : 
; 1937 : 			// Figure out the initial rally point
; 1938 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pTargetPlot$224258[ebp], eax

; 1939 : 			if(pTargetPlot != NULL)

	cmp	DWORD PTR _pTargetPlot$224258[ebp], 0
	je	$LN10@Init

; 1940 : 			{
; 1941 : 				SetTargetPlot(pTargetPlot);

	mov	ecx, DWORD PTR _pTargetPlot$224258[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 1942 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	mov	edx, DWORD PTR _pTargetPlot$224258[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 1943 : 				if(SelectInitialMusterPoint(pArmyAI) != NULL)

	mov	eax, DWORD PTR _pArmyAI$224255[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax
	test	eax, eax
	je	$LN9@Init

; 1944 : 				{
; 1945 : 					pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T236485[ebp], eax
	mov	ecx, DWORD PTR $T236485[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236486[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T236490[ebp], eax
	mov	eax, DWORD PTR $T236486[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236490[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 1946 : 					SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T236494[ebp], eax
	mov	eax, DWORD PTR $T236494[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T236495[ebp], ecx
	mov	edx, DWORD PTR $T236495[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 1947 : 
; 1948 : 					if (GetDefaultArea() != pTargetPlot->getArea())

	mov	eax, DWORD PTR _pTargetPlot$224258[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T236499[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDefaultArea@CvAIOperation@@QBEHXZ	; CvAIOperation::GetDefaultArea
	cmp	eax, DWORD PTR $T236499[ebp]
	je	SHORT $LN8@Init

; 1949 : 					{
; 1950 : 						pArmyAI->SetGoalPlot(pTargetPlot);

	mov	edx, DWORD PTR _pTargetPlot$224258[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 1951 : 					}
; 1952 : 					else

	jmp	SHORT $LN7@Init
$LN8@Init:

; 1953 : 					{
; 1954 : 						CvPlot* pDeployPt;
; 1955 : 						pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), GetMusterPlot(), GetTargetPlot(), (GetDeployRange() / 2), true);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T236503[ebp], ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	eax, DWORD PTR $T236503[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	DWORD PTR _pDeployPt$224263[ebp], eax

; 1956 : 						if (pDeployPt)

	cmp	DWORD PTR _pDeployPt$224263[ebp], 0
	je	SHORT $LN6@Init

; 1957 : 						{
; 1958 : 							pArmyAI->SetGoalPlot(pDeployPt);

	mov	ecx, DWORD PTR _pDeployPt$224263[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 1959 : 						}
; 1960 : 						else

	jmp	SHORT $LN7@Init
$LN6@Init:

; 1961 : 						{
; 1962 : 							// No path, abort
; 1963 : 							m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1964 : 							m_eAbortReason = AI_ABORT_LOST_PATH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 14			; 0000000eH
$LN7@Init:

; 1965 : 						}
; 1966 : 					}
; 1967 : 
; 1968 : 					// Find the list of units we need to build before starting this operation in earnest
; 1969 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 1970 : 
; 1971 : 					// try to get as many units as possible from existing units that are waiting around
; 1972 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), pTargetPlot))

	mov	ecx, DWORD PTR _pTargetPlot$224258[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Init

; 1973 : 					{
; 1974 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$224255[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 1975 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 2

; 1976 : 					}
; 1977 : 					else

	jmp	SHORT $LN3@Init
$LN4@Init:

; 1978 : 					{
; 1979 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 1
$LN3@Init:

; 1980 : 					}
; 1981 : 
; 1982 : 					LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart

; 1983 : 				}
; 1984 : 				else

	jmp	SHORT $LN2@Init
$LN9@Init:

; 1985 : 				{
; 1986 : 					// No muster point, abort
; 1987 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 1988 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 7
$LN2@Init:

; 1989 : 				}
; 1990 : 			}
; 1991 : 
; 1992 : 			else

	jmp	SHORT $LN13@Init
$LN10@Init:

; 1993 : 			{
; 1994 : 				// Lost our target, abort
; 1995 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1996 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 3
$LN13@Init:

; 1997 : 			}
; 1998 : 		}
; 1999 : 	}
; 2000 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIEnemyTerritoryOperation::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T236509 = -4						; size = 4
?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ PROC ; CvAIEnemyTerritoryOperation::GetDeployRange, COMDAT
; _this$ = ecx

; 2004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2005 : 	return GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	DWORD PTR $T236509[ebp], eax
	mov	eax, DWORD PTR $T236509[ebp]

; 2006 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ ENDP ; CvAIEnemyTerritoryOperation::GetDeployRange
_TEXT	ENDS
PUBLIC	??_C@_0EE@EIEODNPF@No?5muster?5point?5found?0?5Operation@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
;	COMDAT ??_C@_0EE@EIEODNPF@No?5muster?5point?5found?0?5Operation@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0EE@EIEODNPF@No?5muster?5point?5found?0?5Operation@ DB 'No muster p'
	DB	'oint found, Operation aborting, Target was, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0
__ehfuncinfo$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -172						; size = 4
$T236603 = -168						; size = 4
$T236599 = -164						; size = 4
$T236598 = -160						; size = 4
$T236590 = -156						; size = 4
$T236586 = -152						; size = 4
$T236582 = -148						; size = 4
$T236578 = -144						; size = 4
$T236574 = -140						; size = 4
$T236573 = -136						; size = 4
$T236560 = -132						; size = 4
$T236554 = -128						; size = 4
$T236550 = -124						; size = 4
$T236546 = -120						; size = 4
$T236542 = -116						; size = 4
$T236538 = -112						; size = 4
$T236537 = -108						; size = 4
$T236533 = -104						; size = 4
$T236532 = -100						; size = 4
$T236528 = -96						; size = 4
$T236527 = -92						; size = 4
$T236522 = -88						; size = 4
$T236521 = -84						; size = 4
$T236517 = -80						; size = 4
_szMsg$224301 = -76					; size = 28
__$ArrayPad$ = -48					; size = 4
_pNode$224287 = -44					; size = 4
_pStartCityPlot$ = -40					; size = 4
_pStartCity$ = -36					; size = 4
_pDeployPlot$ = -32					; size = 4
_iDangerousPlots$ = -28					; size = 4
_pCurrentPlot$ = -24					; size = 4
_iSpacesFromTarget$ = -20				; size = 4
_pMusterPt$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pThisArmy$ = 8						; size = 4
?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z PROC ; CvAIEnemyTerritoryOperation::SelectInitialMusterPoint, COMDAT
; _this$ = ecx

; 2010 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2011 : 	CvPlot* pMusterPt = NULL;

	mov	DWORD PTR _pMusterPt$[ebp], 0

; 2012 : 	CvPlot* pStartCityPlot;
; 2013 : 	CvCity* pStartCity;
; 2014 : 	CvPlot* pCurrentPlot;
; 2015 : 	int iSpacesFromTarget = 0;

	mov	DWORD PTR _iSpacesFromTarget$[ebp], 0

; 2016 : 	CvPlot* pDeployPlot = NULL;

	mov	DWORD PTR _pDeployPlot$[ebp], 0

; 2017 : 	int iDangerousPlots = 0;

	mov	DWORD PTR _iDangerousPlots$[ebp], 0

; 2018 : 
; 2019 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _pStartCity$[ebp], eax

; 2020 : 	if(pStartCity)

	cmp	DWORD PTR _pStartCity$[ebp], 0
	je	$LN15@SelectInit@2

; 2021 : 	{
; 2022 : 		pStartCityPlot = pStartCity->plot();

	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pStartCityPlot$[ebp], eax

; 2023 : 
; 2024 : 		if(pStartCityPlot != NULL)

	cmp	DWORD PTR _pStartCityPlot$[ebp], 0
	je	$LN15@SelectInit@2

; 2025 : 		{
; 2026 : 			// Different areas?  If so, just muster at start city
; 2027 : 			if (pStartCityPlot->getArea() != pThisArmy->GetGoalPlot()->getArea())

	mov	ecx, DWORD PTR _pStartCityPlot$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T236517[ebp], edx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T236521[ebp], eax
	mov	eax, DWORD PTR $T236521[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T236522[ebp], ecx
	mov	edx, DWORD PTR $T236517[ebp]
	cmp	edx, DWORD PTR $T236522[ebp]
	je	SHORT $LN13@SelectInit@2

; 2028 : 			{
; 2029 : 				SetMusterPlot(pStartCityPlot);

	mov	eax, DWORD PTR _pStartCityPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 2030 : 				return pStartCityPlot;

	mov	eax, DWORD PTR _pStartCityPlot$[ebp]
	jmp	$LN16@SelectInit@2
$LN13@SelectInit@2:

; 2031 : 			}
; 2032 : 
; 2033 : 			CvAStarNode* pNode;
; 2034 : 
; 2035 : 			// Generate path
; 2036 : 			GC.getStepFinder().SetData(&m_eEnemy);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR $T236528[ebp], ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T236527[ebp], eax
	mov	edx, DWORD PTR $T236527[ebp]
	movzx	eax, BYTE PTR [edx+80]
	test	eax, eax
	je	SHORT $LN23@SelectInit@2
	mov	ecx, DWORD PTR $T236527[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR $T236528[ebp]
	je	SHORT $LN23@SelectInit@2
	mov	eax, DWORD PTR $T236527[ebp]
	mov	BYTE PTR [eax+78], 1
$LN23@SelectInit@2:
	mov	ecx, DWORD PTR $T236527[ebp]
	mov	edx, DWORD PTR $T236528[ebp]
	mov	DWORD PTR [ecx+44], edx

; 2037 : 			if(GC.getStepFinder().GeneratePath(pStartCityPlot->getX(), pStartCityPlot->getY(), pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY(), m_eOwner, false))

	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T236532[ebp], eax
	mov	eax, DWORD PTR $T236532[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236533[ebp], ecx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T236537[ebp], eax
	mov	edx, DWORD PTR $T236537[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236538[ebp], eax
	mov	ecx, DWORD PTR _pStartCityPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236542[ebp], edx
	mov	eax, DWORD PTR _pStartCityPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T236546[ebp], ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR $T236533[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236538[ebp]
	push	edx
	mov	eax, DWORD PTR $T236542[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236546[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	edx, al
	test	edx, edx
	je	$LN15@SelectInit@2

; 2038 : 			{
; 2039 : 				pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T236550[ebp], eax
	mov	eax, DWORD PTR $T236550[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$224287[ebp], ecx
$LN11@SelectInit@2:

; 2040 : 
; 2041 : 				// Starting at the end, loop until we find a plot from this owner
; 2042 : 				while(pNode != NULL)

	cmp	DWORD PTR _pNode$224287[ebp], 0
	je	$LN10@SelectInit@2

; 2043 : 				{
; 2044 : 					pCurrentPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236554[ebp], edx
	mov	eax, DWORD PTR _pNode$224287[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR $T236574[ebp], ecx
	mov	edx, DWORD PTR _pNode$224287[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR $T236573[ebp], eax
	cmp	DWORD PTR $T236573[ebp], -2147483647	; 80000001H
	je	SHORT $LN38@SelectInit@2
	cmp	DWORD PTR $T236574[ebp], -2147483647	; 80000001H
	jne	SHORT $LN39@SelectInit@2
$LN38@SelectInit@2:
	mov	DWORD PTR _pCurrentPlot$[ebp], 0
	jmp	SHORT $LN40@SelectInit@2
$LN39@SelectInit@2:
	mov	ecx, DWORD PTR $T236554[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T236560[ebp], edx
	mov	eax, DWORD PTR $T236574[ebp]
	imul	eax, DWORD PTR $T236560[ebp]
	add	eax, DWORD PTR $T236573[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T236554[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pCurrentPlot$[ebp], eax
$LN40@SelectInit@2:

; 2045 : 
; 2046 : 					// Is this the deploy point?
; 2047 : 					if(iSpacesFromTarget == GetDeployRange())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	cmp	DWORD PTR _iSpacesFromTarget$[ebp], eax
	jne	SHORT $LN9@SelectInit@2

; 2048 : 					{
; 2049 : 						pDeployPlot = pCurrentPlot;

	mov	eax, DWORD PTR _pCurrentPlot$[ebp]
	mov	DWORD PTR _pDeployPlot$[ebp], eax
$LN9@SelectInit@2:

; 2050 : 					}
; 2051 : 
; 2052 : 					// Check and see if this plot has the right owner
; 2053 : 					if(pCurrentPlot->getOwner() == GetOwner())

	mov	ecx, DWORD PTR _pCurrentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T236578[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T236582[ebp], ecx
	mov	edx, DWORD PTR $T236578[ebp]
	cmp	edx, DWORD PTR $T236582[ebp]
	jne	SHORT $LN8@SelectInit@2

; 2054 : 					{
; 2055 : 						pMusterPt = pCurrentPlot;

	mov	eax, DWORD PTR _pCurrentPlot$[ebp]
	mov	DWORD PTR _pMusterPt$[ebp], eax

; 2056 : 						break;

	jmp	SHORT $LN10@SelectInit@2

; 2057 : 					}
; 2058 : 
; 2059 : 					else

	jmp	SHORT $LN7@SelectInit@2
$LN8@SelectInit@2:

; 2060 : 					{
; 2061 : 						// Is this a dangerous plot?
; 2062 : 						if(GET_PLAYER(m_eOwner).GetPlotDanger(*pCurrentPlot) > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236586[ebp], edx
	mov	eax, DWORD PTR _pCurrentPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236586[ebp]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	SHORT $LN7@SelectInit@2

; 2063 : 						{
; 2064 : 							iDangerousPlots++;

	mov	ecx, DWORD PTR _iDangerousPlots$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDangerousPlots$[ebp], ecx
$LN7@SelectInit@2:

; 2065 : 						}
; 2066 : 					}
; 2067 : 
; 2068 : 					// Move to the previous plot on the path
; 2069 : 					iSpacesFromTarget++;

	mov	edx, DWORD PTR _iSpacesFromTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _iSpacesFromTarget$[ebp], edx

; 2070 : 					pNode = pNode->m_pParent;

	mov	eax, DWORD PTR _pNode$224287[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pNode$224287[ebp], ecx

; 2071 : 				}

	jmp	$LN11@SelectInit@2
$LN10@SelectInit@2:

; 2072 : 
; 2073 : 				// Is the path safe?  If so, let's just muster at the deploy point
; 2074 : 				if(iSpacesFromTarget > 0 && (iDangerousPlots * 100 / iSpacesFromTarget) < GC.getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER())

	cmp	DWORD PTR _iSpacesFromTarget$[ebp], 0
	jle	SHORT $LN15@SelectInit@2
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2432
	mov	DWORD PTR $T236590[ebp], edx
	mov	eax, DWORD PTR _iDangerousPlots$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iSpacesFromTarget$[ebp]
	cmp	eax, DWORD PTR $T236590[ebp]
	jge	SHORT $LN15@SelectInit@2

; 2075 : 				{
; 2076 : 					if(pDeployPlot)

	cmp	DWORD PTR _pDeployPlot$[ebp], 0
	je	SHORT $LN15@SelectInit@2

; 2077 : 					{
; 2078 : 						pMusterPt = pDeployPlot;

	mov	eax, DWORD PTR _pDeployPlot$[ebp]
	mov	DWORD PTR _pMusterPt$[ebp], eax
$LN15@SelectInit@2:

; 2079 : 					}
; 2080 : 				}
; 2081 : 			}
; 2082 : 		}
; 2083 : 	}
; 2084 : 
; 2085 : 	if(pMusterPt != NULL)

	cmp	DWORD PTR _pMusterPt$[ebp], 0
	je	SHORT $LN3@SelectInit@2

; 2086 : 	{
; 2087 : 		SetMusterPlot(pMusterPt);

	mov	ecx, DWORD PTR _pMusterPt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 2088 : 	}
; 2089 : 	else

	jmp	$LN2@SelectInit@2
$LN3@SelectInit@2:

; 2090 : 	{
; 2091 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN2@SelectInit@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@SelectInit@2

; 2092 : 		{
; 2093 : 			CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$224301[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2094 : 			szMsg.Format("No muster point found, Operation aborting, Target was, X: %d, Y: %d", pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY());

	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T236598[ebp], eax
	mov	ecx, DWORD PTR $T236598[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236599[ebp], edx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T236603[ebp], eax
	mov	eax, DWORD PTR $T236599[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236603[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0EE@EIEODNPF@No?5muster?5point?5found?0?5Operation@
	lea	eax, DWORD PTR _szMsg$224301[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2095 : 			LogOperationSpecialMessage(szMsg);

	lea	ecx, DWORD PTR _szMsg$224301[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage

; 2096 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szMsg$224301[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@SelectInit@2:

; 2097 : 	}
; 2098 : 
; 2099 : 	return pMusterPt;

	mov	eax, DWORD PTR _pMusterPt$[ebp]
$LN16@SelectInit@2:

; 2100 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _szMsg$224301[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ENDP ; CvAIEnemyTerritoryOperation::SelectInitialMusterPoint
PUBLIC	??_7CvAIOperationBasicCityAttack@@6B@		; CvAIOperationBasicCityAttack::`vftable'
PUBLIC	?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationBasicCityAttack::Init
PUBLIC	?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ ; CvAIOperationBasicCityAttack::GetOperationType
PUBLIC	?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ ; CvAIOperationBasicCityAttack::NeedToCheckPathToTarget
PUBLIC	?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationBasicCityAttack::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationBasicCityAttack::ArmyInPosition
PUBLIC	?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ ; CvAIOperationBasicCityAttack::ShouldAbort
PUBLIC	?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationBasicCityAttack::Read
PUBLIC	?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationBasicCityAttack::Write
PUBLIC	?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationBasicCityAttack::GetOperationName
PUBLIC	?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationBasicCityAttack::FindBestTarget
EXTRN	??_ECvAIOperationBasicCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationBasicCityAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationBasicCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationBasicCityAttack@@6B@ DD FLAT:??_ECvAIOperationBasicCityAttack@@UAEPAXI@Z ; CvAIOperationBasicCityAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationBasicCityAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationBasicCityAttack@@QAE@XZ PROC		; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack, COMDAT
; _this$ = ecx

; 2108 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIEnemyTerritoryOperation@@QAE@XZ	; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationBasicCityAttack@@6B@

; 2109 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationBasicCityAttack@@QAE@XZ ENDP		; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
_TEXT	ENDS
PUBLIC	??1CvAIOperationBasicCityAttack@@UAE@XZ		; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationBasicCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationBasicCityAttack@@UAEPAXI@Z PROC	; CvAIOperationBasicCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationBasicCityAttack@@UAE@XZ	; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationBasicCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationBasicCityAttack::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationBasicCityAttack@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationBasicCityAttack@@UAE@XZ PROC		; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack, COMDAT
; _this$ = ecx

; 2113 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationBasicCityAttack@@6B@

; 2114 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEnemyTerritoryOperation@@UAE@XZ	; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationBasicCityAttack@@UAE@XZ ENDP		; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T236770 = -104						; size = 4
$T236766 = -100						; size = 4
$T236765 = -96						; size = 4
$T236761 = -92						; size = 4
$T236757 = -88						; size = 4
$T236756 = -84						; size = 4
$T236624 = -16						; size = 4
_pDeployPt$224328 = -12					; size = 4
_pArmyAI$224324 = -8					; size = 4
_kPlayer$224323 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
_pTarget$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationBasicCityAttack::Init, COMDAT
; _this$ = ecx

; 2118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 2119 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 2120 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 1

; 2121 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 2122 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 2123 : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 2124 : 	SetStartCityPlot(pMuster->plot());

	mov	ecx, DWORD PTR _pMuster$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetStartCityPlot

; 2125 : 
; 2126 : 	if(iID != -1)

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN9@Init@2

; 2127 : 	{
; 2128 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 2129 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$224323[ebp], eax

; 2130 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, DWORD PTR _kPlayer$224323[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$224324[ebp], eax

; 2131 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$224324[ebp], 0
	je	$LN9@Init@2

; 2132 : 		{
; 2133 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T236624[ebp], eax
	lea	ecx, DWORD PTR $T236624[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 2134 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 2135 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2136 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 2137 : 
; 2138 : 			if(pTarget)

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	$LN6@Init@2

; 2139 : 			{
; 2140 : 				SetTargetPlot(pTarget->plot());

	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 2141 : 				pArmyAI->SetGoalPlot(GetTargetPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2142 : 				SetMusterPlot(GetStartCityPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 2143 : 				pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T236756[ebp], eax
	mov	ecx, DWORD PTR $T236756[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236757[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T236761[ebp], eax
	mov	eax, DWORD PTR $T236757[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236761[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 2144 : 				SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T236765[ebp], eax
	mov	eax, DWORD PTR $T236765[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T236766[ebp], ecx
	mov	edx, DWORD PTR $T236766[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 2145 : 
; 2146 : 				// Reset our destination to be a few plots shy of the final target
; 2147 : 				CvPlot* pDeployPt;
; 2148 : 				pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), GetMusterPlot(), GetTargetPlot(), (GetDeployRange() / 2), true);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T236770[ebp], ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	eax, DWORD PTR $T236770[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	DWORD PTR _pDeployPt$224328[ebp], eax

; 2149 : 				if (pDeployPt)

	cmp	DWORD PTR _pDeployPt$224328[ebp], 0
	je	SHORT $LN5@Init@2

; 2150 : 				{
; 2151 : 					pArmyAI->SetGoalPlot(pDeployPt);

	mov	ecx, DWORD PTR _pDeployPt$224328[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2152 : 
; 2153 : 					// Find the list of units we need to build before starting this operation in earnest
; 2154 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 2155 : 
; 2156 : 					// try to get as many units as possible from existing units that are waiting around
; 2157 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetTargetPlot()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Init@2

; 2158 : 					{
; 2159 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$224324[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2160 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 2

; 2161 : 					}
; 2162 : 					else

	jmp	SHORT $LN3@Init@2
$LN4@Init@2:

; 2163 : 					{
; 2164 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN3@Init@2:

; 2165 : 					}
; 2166 : 
; 2167 : 					LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart

; 2168 : 				}
; 2169 : 				else

	jmp	SHORT $LN2@Init@2
$LN5@Init@2:

; 2170 : 				{
; 2171 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2172 : 					m_eAbortReason = AI_ABORT_LOST_PATH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 14			; 0000000eH
$LN2@Init@2:

; 2173 : 				}
; 2174 : 			}
; 2175 : 
; 2176 : 			else

	jmp	SHORT $LN9@Init@2
$LN6@Init@2:

; 2177 : 			{
; 2178 : 				// Lost our target, abort
; 2179 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 2180 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 3
$LN9@Init@2:

; 2181 : 			}
; 2182 : 		}
; 2183 : 	}
; 2184 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationBasicCityAttack::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationBasicCityAttack::Read, COMDAT
; _this$ = ecx

; 2188 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2189 : 	// read the base class' entries
; 2190 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2191 : 
; 2192 : 	// Version number to maintain backwards compatibility
; 2193 : 	uint uiVersion;
; 2194 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2195 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationBasicCityAttack::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationBasicCityAttack::Write, COMDAT
; _this$ = ecx

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2200 : 	// write the base class' entries
; 2201 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2202 : 
; 2203 : 	// Current version number
; 2204 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 2205 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2206 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationBasicCityAttack::Write
_TEXT	ENDS
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
; Function compile flags: /Odtp
;	COMDAT ?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
tv81 = -24						; size = 4
_this$ = -20						; size = 4
$T236797 = -16						; size = 4
$T236793 = -12						; size = 4
$T236792 = -8						; size = 4
$T236788 = -4						; size = 4
?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationBasicCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 2209 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2210 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236788[ebp], eax
	mov	ecx, DWORD PTR $T236788[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T236792[ebp], eax
	mov	ecx, DWORD PTR $T236792[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236793[ebp], edx
	cmp	DWORD PTR $T236793[ebp], 4
	jle	SHORT $LN3@GetFormati
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236797[ebp], eax
	mov	ecx, DWORD PTR $T236797[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	jne	SHORT $LN3@GetFormati
	mov	DWORD PTR tv81[ebp], 18			; 00000012H
	jmp	SHORT $LN4@GetFormati
$LN3@GetFormati:
	mov	DWORD PTR tv81[ebp], 0
$LN4@GetFormati:
	mov	eax, DWORD PTR tv81[ebp]

; 2211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationBasicCityAttack::GetFormation
_TEXT	ENDS
EXTRN	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z:PROC ; CvTacticalAI::AddTemporaryZone
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
EXTRN	?SetMusteringForAttack@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::SetMusteringForAttack
; Function compile flags: /Odtp
;	COMDAT ?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -136						; size = 4
_this$ = -132						; size = 4
$T236902 = -128						; size = 4
$T236898 = -124						; size = 4
$T236894 = -120						; size = 4
$T236890 = -116						; size = 4
$T236883 = -112						; size = 4
$T236879 = -108						; size = 4
$T236875 = -104						; size = 4
$T236871 = -100						; size = 4
$T236859 = -96						; size = 4
$T236855 = -92						; size = 4
$T236851 = -88						; size = 4
$T236810 = -40						; size = 4
$T236806 = -36						; size = 4
_zone$224362 = -32					; size = 20
_pCenterOfMass$224360 = -12				; size = 4
_pTarget$224357 = -8					; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationBasicCityAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 2215 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	DWORD PTR _this$[ebp], ecx

; 2216 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 2217 : 
; 2218 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	$LN6@ArmyInPosi@2
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN68@ArmyInPosi@2[edx*4]
$LN5@ArmyInPosi@2:

; 2219 : 	{
; 2220 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 2221 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2222 : 	{
; 2223 : 		// First do base case processing
; 2224 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 2225 : 
; 2226 : 		// Is target still under enemy control?
; 2227 : 		CvPlot* pTarget = GetTargetPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR _pTarget$224357[ebp], eax

; 2228 : 		if(pTarget->getOwner() != m_eEnemy)

	mov	ecx, DWORD PTR _pTarget$224357[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+76]
	je	SHORT $LN4@ArmyInPosi@2

; 2229 : 		{
; 2230 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2231 : 			m_eAbortReason = AI_ABORT_TARGET_ALREADY_CAPTURED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 4
$LN4@ArmyInPosi@2:

; 2232 : 		}
; 2233 : 	}
; 2234 : 	break;

	jmp	$LN6@ArmyInPosi@2
$LN3@ArmyInPosi@2:

; 2235 : 
; 2236 : 	// See if reached our target, if so give control of these units to the tactical AI
; 2237 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2238 : 	{
; 2239 : 		CvPlot *pCenterOfMass = pArmy->GetCenterOfMass(DOMAIN_LAND);

	push	2
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$224360[ebp], eax

; 2240 : 
; 2241 : 		// Are we within tactical range of our target?
; 2242 : 		if(pCenterOfMass && plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE())

	cmp	DWORD PTR _pCenterOfMass$224360[ebp], 0
	je	$LN2@ArmyInPosi@2
	mov	eax, DWORD PTR _pCenterOfMass$224360[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236806[ebp], ecx
	mov	edx, DWORD PTR _pCenterOfMass$224360[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236810[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	DWORD PTR $T236851[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	mov	eax, DWORD PTR $T236806[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236810[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR $T236851[ebp]
	jg	$LN2@ArmyInPosi@2

; 2243 : 		{
; 2244 : 			// Notify Diplo AI we're in place for attack
; 2245 : 			GET_PLAYER(GetOwner()).GetDiplomacyAI()->SetMusteringForAttack(GetEnemy(), true);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR $T236855[ebp], eax
	mov	ecx, DWORD PTR $T236855[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236859[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	ecx, DWORD PTR $T236859[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetMusteringForAttack@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetMusteringForAttack

; 2246 : 
; 2247 : 			// Notify tactical AI to focus on this area
; 2248 : 			CvTemporaryZone zone;

	mov	DWORD PTR _zone$224362[ebp], 0
	mov	DWORD PTR _zone$224362[ebp+4], 0
	mov	DWORD PTR _zone$224362[ebp+8], 0
	mov	DWORD PTR _zone$224362[ebp+12], 0

; 2249 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T236871[ebp], eax
	mov	edx, DWORD PTR $T236871[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236875[ebp], eax
	mov	ecx, DWORD PTR $T236875[ebp]
	mov	DWORD PTR _zone$224362[ebp], ecx

; 2250 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T236879[ebp], eax
	mov	edx, DWORD PTR $T236879[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T236883[ebp], eax
	mov	ecx, DWORD PTR $T236883[ebp]
	mov	DWORD PTR _zone$224362[ebp+4], ecx

; 2251 : 			zone.SetTargetType(AI_TACTICAL_TARGET_CITY);

	mov	DWORD PTR _zone$224362[ebp+8], 1

; 2252 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236890[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T236894[ebp], eax
	mov	ecx, DWORD PTR $T236890[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR $T236894[ebp]
	mov	DWORD PTR $T236898[ebp], eax
	mov	ecx, DWORD PTR $T236898[ebp]
	mov	DWORD PTR _zone$224362[ebp+12], ecx

; 2253 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T236902[ebp], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR _zone$224362[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _zone$224362[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _zone$224362[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _zone$224362[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _zone$224362[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	ecx, DWORD PTR $T236902[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 2254 : 
; 2255 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 5
$LN2@ArmyInPosi@2:

; 2256 : 		}
; 2257 : 	}
; 2258 : 	break;

	jmp	SHORT $LN6@ArmyInPosi@2
$LN1@ArmyInPosi@2:

; 2259 : 
; 2260 : 	// In all other cases use base class version
; 2261 : 	case AI_OPERATION_STATE_ABORTED:
; 2262 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2263 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2264 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	jmp	SHORT $LN8@ArmyInPosi@2
$LN6@ArmyInPosi@2:

; 2265 : 		break;
; 2266 : 	};
; 2267 : 
; 2268 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
$LN8@ArmyInPosi@2:

; 2269 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN68@ArmyInPosi@2:
	DD	$LN1@ArmyInPosi@2
	DD	$LN1@ArmyInPosi@2
	DD	$LN5@ArmyInPosi@2
	DD	$LN3@ArmyInPosi@2
	DD	$LN1@ArmyInPosi@2
?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationBasicCityAttack::ArmyInPosition
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T236914 = -12						; size = 4
_rtnValue$ = -1						; size = 1
?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ PROC	; CvAIOperationBasicCityAttack::ShouldAbort, COMDAT
; _this$ = ecx

; 2273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2274 : 	// If parent says we're done, don't even check anything else
; 2275 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	BYTE PTR _rtnValue$[ebp], al

; 2276 : 
; 2277 : 	if(!rtnValue)

	movzx	eax, BYTE PTR _rtnValue$[ebp]
	test	eax, eax
	jne	SHORT $LN3@ShouldAbor@2

; 2278 : 	{
; 2279 : 		// See if our target city is still owned by our enemy
; 2280 : 		if(GetTargetPlot()->getPlotCity() == NULL || GetTargetPlot()->getOwner() != m_eEnemy)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	je	SHORT $LN1@ShouldAbor@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T236914[ebp], eax
	mov	ecx, DWORD PTR $T236914[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+76]
	je	SHORT $LN3@ShouldAbor@2
$LN1@ShouldAbor@2:

; 2281 : 		{
; 2282 : 			// Success!  The city has been captured/destroyed
; 2283 : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@ShouldAbor@2
$LN3@ShouldAbor@2:

; 2284 : 		}
; 2285 : 	}
; 2286 : 
; 2287 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[ebp]
$LN4@ShouldAbor@2:

; 2288 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ ENDP	; CvAIOperationBasicCityAttack::ShouldAbort
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationBasicCityAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 2292 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2293 : 	CvAssertMsg(false, "Obsolete function called CvAIOperationBasicCityAttack::FindBestTarget()");
; 2294 : 
; 2295 : 	return NULL;

	xor	eax, eax

; 2296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationBasicCityAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationSneakCityAttack@@6B@		; CvAIOperationSneakCityAttack::`vftable'
PUBLIC	?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ ; CvAIOperationSneakCityAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationSneakCityAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationSneakCityAttack::GetOperationName
EXTRN	??_ECvAIOperationSneakCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationSneakCityAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationSneakCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationSneakCityAttack@@6B@ DD FLAT:??_ECvAIOperationSneakCityAttack@@UAEPAXI@Z ; CvAIOperationSneakCityAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationSneakCityAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationSneakCityAttack@@QAE@XZ PROC		; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack, COMDAT
; _this$ = ecx

; 2304 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperationBasicCityAttack@@QAE@XZ	; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationSneakCityAttack@@6B@

; 2305 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationSneakCityAttack@@QAE@XZ ENDP		; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationSneakCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationSneakCityAttack@@UAEPAXI@Z PROC	; CvAIOperationSneakCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationBasicCityAttack@@UAE@XZ	; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationSneakCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationSneakCityAttack::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
tv81 = -24						; size = 4
_this$ = -20						; size = 4
$T236942 = -16						; size = 4
$T236938 = -12						; size = 4
$T236937 = -8						; size = 4
$T236933 = -4						; size = 4
?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationSneakCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 2307 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2308 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236933[ebp], eax
	mov	ecx, DWORD PTR $T236933[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T236937[ebp], eax
	mov	ecx, DWORD PTR $T236937[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236938[ebp], edx
	cmp	DWORD PTR $T236938[ebp], 4
	jle	SHORT $LN3@GetFormati@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236942[ebp], eax
	mov	ecx, DWORD PTR $T236942[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	jne	SHORT $LN3@GetFormati@2
	mov	DWORD PTR tv81[ebp], 18			; 00000012H
	jmp	SHORT $LN4@GetFormati@2
$LN3@GetFormati@2:
	mov	DWORD PTR tv81[ebp], 0
$LN4@GetFormati@2:
	mov	eax, DWORD PTR tv81[ebp]

; 2309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationSneakCityAttack::GetFormation
_TEXT	ENDS
PUBLIC	??_7CvAIOperationQuickSneakCityAttack@@6B@	; CvAIOperationQuickSneakCityAttack::`vftable'
PUBLIC	?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationQuickSneakCityAttack::GetFormation
EXTRN	??_ECvAIOperationQuickSneakCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationQuickSneakCityAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationQuickSneakCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationQuickSneakCityAttack@@6B@ DD FLAT:??_ECvAIOperationQuickSneakCityAttack@@UAEPAXI@Z ; CvAIOperationQuickSneakCityAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationQuickSneakCityAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationQuickSneakCityAttack@@QAE@XZ PROC	; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack, COMDAT
; _this$ = ecx

; 2312 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperationSneakCityAttack@@QAE@XZ	; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationQuickSneakCityAttack@@6B@

; 2313 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationQuickSneakCityAttack@@QAE@XZ ENDP	; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationQuickSneakCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationQuickSneakCityAttack@@UAEPAXI@Z PROC	; CvAIOperationQuickSneakCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationBasicCityAttack@@UAE@XZ	; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationQuickSneakCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationQuickSneakCityAttack::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CvAIOperationSmallCityAttack@@6B@		; CvAIOperationSmallCityAttack::`vftable'
PUBLIC	?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ ; CvAIOperationSmallCityAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationSmallCityAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationSmallCityAttack::GetOperationName
EXTRN	??_ECvAIOperationSmallCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationSmallCityAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationSmallCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationSmallCityAttack@@6B@ DD FLAT:??_ECvAIOperationSmallCityAttack@@UAEPAXI@Z ; CvAIOperationSmallCityAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationSmallCityAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationSmallCityAttack@@QAE@XZ PROC		; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack, COMDAT
; _this$ = ecx

; 2321 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperationBasicCityAttack@@QAE@XZ	; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationSmallCityAttack@@6B@

; 2322 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationSmallCityAttack@@QAE@XZ ENDP		; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationSmallCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationSmallCityAttack@@UAEPAXI@Z PROC	; CvAIOperationSmallCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationBasicCityAttack@@UAE@XZ	; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationSmallCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationSmallCityAttack::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CvAIOperationCityStateAttack@@6B@		; CvAIOperationCityStateAttack::`vftable'
PUBLIC	?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ ; CvAIOperationCityStateAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationCityStateAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ ; CvAIOperationCityStateAttack::GetOperationName
EXTRN	??_ECvAIOperationCityStateAttack@@UAEPAXI@Z:PROC ; CvAIOperationCityStateAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationCityStateAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationCityStateAttack@@6B@ DD FLAT:??_ECvAIOperationCityStateAttack@@UAEPAXI@Z ; CvAIOperationCityStateAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationCityStateAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationCityStateAttack@@QAE@XZ PROC		; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack, COMDAT
; _this$ = ecx

; 2330 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperationBasicCityAttack@@QAE@XZ	; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationCityStateAttack@@6B@

; 2331 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationCityStateAttack@@QAE@XZ ENDP		; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationCityStateAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationCityStateAttack@@UAEPAXI@Z PROC	; CvAIOperationCityStateAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationBasicCityAttack@@UAE@XZ	; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationCityStateAttack@@UAEPAXI@Z ENDP	; CvAIOperationCityStateAttack::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
tv81 = -24						; size = 4
_this$ = -20						; size = 4
$T236992 = -16						; size = 4
$T236988 = -12						; size = 4
$T236987 = -8						; size = 4
$T236983 = -4						; size = 4
?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationCityStateAttack::GetFormation, COMDAT
; _this$ = ecx

; 2333 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2334 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_CITY_STATE_ATTACK_FORCE;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236983[ebp], eax
	mov	ecx, DWORD PTR $T236983[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T236987[ebp], eax
	mov	ecx, DWORD PTR $T236987[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236988[ebp], edx
	cmp	DWORD PTR $T236988[ebp], 4
	jle	SHORT $LN3@GetFormati@3
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236992[ebp], eax
	mov	ecx, DWORD PTR $T236992[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
	jne	SHORT $LN3@GetFormati@3
	mov	DWORD PTR tv81[ebp], 18			; 00000012H
	jmp	SHORT $LN4@GetFormati@3
$LN3@GetFormati@3:
	mov	DWORD PTR tv81[ebp], 1
$LN4@GetFormati@3:
	mov	eax, DWORD PTR tv81[ebp]

; 2335 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationCityStateAttack::GetFormation
_TEXT	ENDS
PUBLIC	??_7CvAIOperationDestroyBarbarianCamp@@6B@	; CvAIOperationDestroyBarbarianCamp::`vftable'
PUBLIC	?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ; CvAIOperationDestroyBarbarianCamp::GetOperationType
PUBLIC	?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationDestroyBarbarianCamp::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationDestroyBarbarianCamp::ArmyInPosition
PUBLIC	?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ ; CvAIOperationDestroyBarbarianCamp::ShouldAbort
PUBLIC	?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z ; CvAIOperationDestroyBarbarianCamp::Read
PUBLIC	?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z ; CvAIOperationDestroyBarbarianCamp::Write
PUBLIC	?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ ; CvAIOperationDestroyBarbarianCamp::GetOperationName
PUBLIC	?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ; CvAIOperationDestroyBarbarianCamp::GetDeployRange
PUBLIC	?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ ; CvAIOperationDestroyBarbarianCamp::FindBestTarget
EXTRN	??_ECvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z:PROC ; CvAIOperationDestroyBarbarianCamp::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationDestroyBarbarianCamp@@6B@
CONST	SEGMENT
??_7CvAIOperationDestroyBarbarianCamp@@6B@ DD FLAT:??_ECvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z ; CvAIOperationDestroyBarbarianCamp::`vftable'
	DD	FLAT:?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ PROC	; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp, COMDAT
; _this$ = ecx

; 2343 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIEnemyTerritoryOperation@@QAE@XZ	; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationDestroyBarbarianCamp@@6B@

; 2344 : 	m_bCivilianRescue = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+112], 0

; 2345 : 	m_iUnitToRescue = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 0

; 2346 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ ENDP	; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp
_TEXT	ENDS
PUBLIC	??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ	; CvAIOperationDestroyBarbarianCamp::~CvAIOperationDestroyBarbarianCamp
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z PROC	; CvAIOperationDestroyBarbarianCamp::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ ; CvAIOperationDestroyBarbarianCamp::~CvAIOperationDestroyBarbarianCamp
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z ENDP	; CvAIOperationDestroyBarbarianCamp::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ PROC	; CvAIOperationDestroyBarbarianCamp::~CvAIOperationDestroyBarbarianCamp, COMDAT
; _this$ = ecx

; 2350 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationDestroyBarbarianCamp@@6B@

; 2351 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEnemyTerritoryOperation@@UAE@XZ	; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ ENDP	; CvAIOperationDestroyBarbarianCamp::~CvAIOperationDestroyBarbarianCamp
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T237006 = -4						; size = 4
?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ PROC ; CvAIOperationDestroyBarbarianCamp::GetDeployRange, COMDAT
; _this$ = ecx

; 2355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2356 : 	return GC.getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2416
	mov	DWORD PTR $T237006[ebp], eax
	mov	eax, DWORD PTR $T237006[ebp]

; 2357 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetDeployRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationDestroyBarbarianCamp::Read, COMDAT
; _this$ = ecx

; 2361 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2362 : 	// read the base class' entries
; 2363 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2364 : 
; 2365 : 	// Version number to maintain backwards compatibility
; 2366 : 	uint uiVersion;
; 2367 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2368 : 	m_bCivilianRescue = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+112], 0

; 2369 : 	kStream >> m_bCivilianRescue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2370 : 	kStream >> m_iUnitToRescue;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2371 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationDestroyBarbarianCamp::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationDestroyBarbarianCamp::Write, COMDAT
; _this$ = ecx

; 2375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2376 : 	// write the base class' entries
; 2377 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2378 : 
; 2379 : 	// Current version number
; 2380 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 2381 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2382 : 	kStream << m_bCivilianRescue;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2383 : 	kStream << m_iUnitToRescue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2384 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationDestroyBarbarianCamp::Write
_TEXT	ENDS
EXTRN	?GetGoalX@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetGoalX
EXTRN	?GetGoalY@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetGoalY
EXTRN	?GetArea@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetArea
; Function compile flags: /Odtp
;	COMDAT ?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -128						; size = 4
_this$ = -124						; size = 4
$T237122 = -120						; size = 4
$T237118 = -116						; size = 4
$T237114 = -112						; size = 4
$T237110 = -108						; size = 4
$T237103 = -104						; size = 4
$T237099 = -100						; size = 4
$T237095 = -96						; size = 4
$T237091 = -92						; size = 4
$T237042 = -44						; size = 4
$T237038 = -40						; size = 4
$T237034 = -36						; size = 4
_zone$224459 = -32					; size = 20
_pDeployPt$224454 = -12					; size = 4
_possibleBetterTarget$224449 = -8			; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationDestroyBarbarianCamp::ArmyInPosition, COMDAT
; _this$ = ecx

; 2388 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 2389 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 2390 : 
; 2391 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	$LN11@ArmyInPosi@3
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN67@ArmyInPosi@3[edx*4]
$LN10@ArmyInPosi@3:

; 2392 : 	{
; 2393 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 2394 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2395 : 	{
; 2396 : 		// First do base case processing
; 2397 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 2398 : 
; 2399 : 		// Now revisit target
; 2400 : 		CvPlot* possibleBetterTarget;
; 2401 : 		possibleBetterTarget = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _possibleBetterTarget$224449[ebp], eax

; 2402 : 
; 2403 : 		// If no target left, abort
; 2404 : 		if(possibleBetterTarget == NULL)

	cmp	DWORD PTR _possibleBetterTarget$224449[ebp], 0
	jne	SHORT $LN9@ArmyInPosi@3

; 2405 : 		{
; 2406 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2407 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 3
	jmp	$LN8@ArmyInPosi@3
$LN9@ArmyInPosi@3:

; 2408 : 		}
; 2409 : 
; 2410 : 		// If target changed, reset to this new one
; 2411 : 		else if(possibleBetterTarget != GetTargetPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _possibleBetterTarget$224449[ebp], eax
	je	$LN8@ArmyInPosi@3

; 2412 : 		{
; 2413 : 			// If we're traveling on a single continent, set our destination to be a few plots shy of the final target
; 2414 : 			if (pArmy->GetArea() == possibleBetterTarget->getArea())

	mov	eax, DWORD PTR _possibleBetterTarget$224449[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T237034[ebp], ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetArea@CvArmyAI@@QBEHXZ		; CvArmyAI::GetArea
	cmp	eax, DWORD PTR $T237034[ebp]
	jne	SHORT $LN6@ArmyInPosi@3

; 2415 : 			{
; 2416 : 				CvPlot* pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), possibleBetterTarget, GC.getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE(), false);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2416
	mov	DWORD PTR $T237038[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T237042[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T237038[ebp]
	push	edx
	mov	eax, DWORD PTR _possibleBetterTarget$224449[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	ecx, DWORD PTR $T237042[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	DWORD PTR _pDeployPt$224454[ebp], eax

; 2417 : 				if(pDeployPt != NULL)

	cmp	DWORD PTR _pDeployPt$224454[ebp], 0
	je	SHORT $LN5@ArmyInPosi@3

; 2418 : 				{
; 2419 : 					pArmy->SetGoalPlot(pDeployPt);

	mov	edx, DWORD PTR _pDeployPt$224454[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2420 : 					SetTargetPlot(possibleBetterTarget);

	mov	eax, DWORD PTR _possibleBetterTarget$224449[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot
$LN5@ArmyInPosi@3:

; 2421 : 				}
; 2422 : 			}
; 2423 : 
; 2424 : 			// Coming in from the sea. Just head to the camp
; 2425 : 			else

	jmp	SHORT $LN8@ArmyInPosi@3
$LN6@ArmyInPosi@3:

; 2426 : 			{
; 2427 : 				pArmy->SetGoalPlot(possibleBetterTarget);

	mov	ecx, DWORD PTR _possibleBetterTarget$224449[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2428 : 				SetTargetPlot(possibleBetterTarget);

	mov	edx, DWORD PTR _possibleBetterTarget$224449[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot
$LN8@ArmyInPosi@3:

; 2429 : 			}
; 2430 : 		}
; 2431 : 	}
; 2432 : 	break;

	jmp	$LN11@ArmyInPosi@3
$LN3@ArmyInPosi@3:

; 2433 : 
; 2434 : 	// See if reached our target, if so give control of these units to the tactical AI
; 2435 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2436 : 	{
; 2437 : 		if (plotDistance(pArmy->GetX(), pArmy->GetY(), pArmy->GetGoalX(), pArmy->GetGoalY()) <= 1)

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetGoalY@CvArmyAI@@QBEHXZ		; CvArmyAI::GetGoalY
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetGoalX@CvArmyAI@@QBEHXZ		; CvArmyAI::GetGoalX
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jg	$LN2@ArmyInPosi@3

; 2438 : 		{
; 2439 : 			// Notify tactical AI to focus on this area
; 2440 : 			CvTemporaryZone zone;

	mov	DWORD PTR _zone$224459[ebp], 0
	mov	DWORD PTR _zone$224459[ebp+4], 0
	mov	DWORD PTR _zone$224459[ebp+8], 0
	mov	DWORD PTR _zone$224459[ebp+12], 0

; 2441 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T237091[ebp], eax
	mov	eax, DWORD PTR $T237091[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T237095[ebp], ecx
	mov	edx, DWORD PTR $T237095[ebp]
	mov	DWORD PTR _zone$224459[ebp], edx

; 2442 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T237099[ebp], eax
	mov	eax, DWORD PTR $T237099[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237103[ebp], ecx
	mov	edx, DWORD PTR $T237103[ebp]
	mov	DWORD PTR _zone$224459[ebp+4], edx

; 2443 : 			zone.SetTargetType(AI_TACTICAL_TARGET_BARBARIAN_CAMP);

	mov	DWORD PTR _zone$224459[ebp+8], 2

; 2444 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237110[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T237114[ebp], ecx
	mov	ecx, DWORD PTR $T237110[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR $T237114[ebp]
	mov	DWORD PTR $T237118[ebp], eax
	mov	edx, DWORD PTR $T237118[ebp]
	mov	DWORD PTR _zone$224459[ebp+12], edx

; 2445 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237122[ebp], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _zone$224459[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _zone$224459[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _zone$224459[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _zone$224459[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _zone$224459[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T237122[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 2446 : 
; 2447 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 5
$LN2@ArmyInPosi@3:

; 2448 : 		}
; 2449 : 	}
; 2450 : 	break;

	jmp	SHORT $LN11@ArmyInPosi@3
$LN1@ArmyInPosi@3:

; 2451 : 
; 2452 : 	// In all other cases use base class version
; 2453 : 	case AI_OPERATION_STATE_ABORTED:
; 2454 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2455 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2456 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	jmp	SHORT $LN13@ArmyInPosi@3
$LN11@ArmyInPosi@3:

; 2457 : 		break;
; 2458 : 	};
; 2459 : 
; 2460 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
$LN13@ArmyInPosi@3:

; 2461 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN67@ArmyInPosi@3:
	DD	$LN1@ArmyInPosi@3
	DD	$LN1@ArmyInPosi@3
	DD	$LN10@ArmyInPosi@3
	DD	$LN3@ArmyInPosi@3
	DD	$LN1@ArmyInPosi@3
?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationDestroyBarbarianCamp::ArmyInPosition
_TEXT	ENDS
PUBLIC	??_C@_0DL@FOJDPNNE@Barbarian?5camp?5stronger?5?$CI?$CFd?$CJ?5tha@ ; `string'
PUBLIC	??_C@_0DM@PPKMANMA@Civilian?5can?5no?5longer?5be?5rescue@ ; `string'
PUBLIC	??_C@_0DJ@EABIOBKP@Barbarian?5camp?5at?5?$CIx?$DN?$CFd?5y?$DN?$CFd?$CJ?5no@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?GetPower@CvUnit@@QBEHXZ:PROC			; CvUnit::GetPower
EXTRN	?GetTotalPower@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetTotalPower
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
EXTRN	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ:PROC ; CvUnit::GetOriginalOwner
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
;	COMDAT ??_C@_0DL@FOJDPNNE@Barbarian?5camp?5stronger?5?$CI?$CFd?$CJ?5tha@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DL@FOJDPNNE@Barbarian?5camp?5stronger?5?$CI?$CFd?$CJ?5tha@ DB 'Bar'
	DB	'barian camp stronger (%d) than our units (%d). Aborting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@PPKMANMA@Civilian?5can?5no?5longer?5be?5rescue@
CONST	SEGMENT
??_C@_0DM@PPKMANMA@Civilian?5can?5no?5longer?5be?5rescue@ DB 'Civilian ca'
	DB	'n no longer be rescued from barbarians. Aborting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EABIOBKP@Barbarian?5camp?5at?5?$CIx?$DN?$CFd?5y?$DN?$CFd?$CJ?5no@
CONST	SEGMENT
??_C@_0DJ@EABIOBKP@Barbarian?5camp?5at?5?$CIx?$DN?$CFd?5y?$DN?$CFd?$CJ?5no@ DB 'B'
	DB	'arbarian camp at (x=%d y=%d) no longer exists. Aborting', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$1
__ehfuncinfo$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T237184 = -112						; size = 4
$T237180 = -108						; size = 4
$T237173 = -104						; size = 4
$T237169 = -100						; size = 4
$T237150 = -96						; size = 4
$T237146 = -92						; size = 4
$T237145 = -88						; size = 4
$T237141 = -84						; size = 4
$T237131 = -77						; size = 1
$T237130 = -76						; size = 1
$T237129 = -75						; size = 1
$T237128 = -74						; size = 1
$T237127 = -73						; size = 1
_pCampDefender$224489 = -72				; size = 8
_pTarget$224488 = -64					; size = 4
_pThisArmy$224487 = -60					; size = 4
_pUnitToRescue$224475 = -56				; size = 4
_BarbPlayer$224473 = -52				; size = 4
_strMsg$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_rtnValue$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ PROC ; CvAIOperationDestroyBarbarianCamp::ShouldAbort, COMDAT
; _this$ = ecx

; 2465 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2466 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2467 : 
; 2468 : 	// If parent says we're done, don't even check anything else
; 2469 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	BYTE PTR _rtnValue$[ebp], al

; 2470 : 
; 2471 : 	if(!rtnValue)

	movzx	eax, BYTE PTR _rtnValue$[ebp]
	test	eax, eax
	jne	$LN15@ShouldAbor@3

; 2472 : 	{
; 2473 : 		// See if our target camp is still there
; 2474 : 		if (!m_bCivilianRescue && GetTargetPlot()->getImprovementType() != GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+112]
	test	edx, edx
	jne	$LN14@ShouldAbor@3
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T237141[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ecx, eax
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR $T237141[ebp]
	je	$LN14@ShouldAbor@3

; 2475 : 		{
; 2476 : 			// Success!  The camp is gone
; 2477 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@ShouldAbor@3

; 2478 : 			{
; 2479 : 				strMsg.Format("Barbarian camp at (x=%d y=%d) no longer exists. Aborting", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T237145[ebp], eax
	mov	eax, DWORD PTR $T237145[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237146[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T237150[ebp], eax
	mov	edx, DWORD PTR $T237146[ebp]
	push	edx
	mov	eax, DWORD PTR $T237150[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DJ@EABIOBKP@Barbarian?5camp?5at?5?$CIx?$DN?$CFd?5y?$DN?$CFd?$CJ?5no@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2480 : 				LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN13@ShouldAbor@3:

; 2481 : 			}
; 2482 : 			return true;

	mov	BYTE PTR $T237127[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T237127[ebp]
	jmp	$LN16@ShouldAbor@3
	jmp	$LN15@ShouldAbor@3
$LN14@ShouldAbor@3:

; 2483 : 		}
; 2484 : 
; 2485 : 		else if (m_bCivilianRescue)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+112]
	test	edx, edx
	je	$LN11@ShouldAbor@3

; 2486 : 		{
; 2487 : 			// is the unit rescued?
; 2488 : 			CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

	mov	eax, 63					; 0000003fH
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _BarbPlayer$224473[ebp], eax

; 2489 : 			CvUnit* pUnitToRescue = BarbPlayer.getUnit(m_iUnitToRescue);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	mov	ecx, DWORD PTR _BarbPlayer$224473[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pUnitToRescue$224475[ebp], eax

; 2490 : 			if (!pUnitToRescue)

	cmp	DWORD PTR _pUnitToRescue$224475[ebp], 0
	jne	SHORT $LN10@ShouldAbor@3

; 2491 : 			{
; 2492 : 				if (GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@ShouldAbor@3

; 2493 : 				{
; 2494 : 					strMsg.Format ("Civilian can no longer be rescued from barbarians. Aborting");

	push	OFFSET ??_C@_0DM@PPKMANMA@Civilian?5can?5no?5longer?5be?5rescue@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 2495 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN9@ShouldAbor@3:

; 2496 : 				}
; 2497 : 				return true;

	mov	BYTE PTR $T237128[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T237128[ebp]
	jmp	$LN16@ShouldAbor@3

; 2498 : 			}
; 2499 : 			else

	jmp	$LN8@ShouldAbor@3
$LN10@ShouldAbor@3:

; 2500 : 			{
; 2501 : 				if (pUnitToRescue->GetOriginalOwner() != m_eOwner || (pUnitToRescue->AI_getUnitAIType() != UNITAI_SETTLE && pUnitToRescue->AI_getUnitAIType() != UNITAI_WORKER))

	mov	ecx, DWORD PTR _pUnitToRescue$224475[ebp]
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+72]
	jne	SHORT $LN6@ShouldAbor@3
	mov	ecx, DWORD PTR _pUnitToRescue$224475[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	SHORT $LN8@ShouldAbor@3
	mov	ecx, DWORD PTR _pUnitToRescue$224475[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN8@ShouldAbor@3
$LN6@ShouldAbor@3:

; 2502 : 				{
; 2503 : 					if (GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@ShouldAbor@3

; 2504 : 					{
; 2505 : 						strMsg.Format ("Civilian can no longer be rescued from barbarians. Aborting");

	push	OFFSET ??_C@_0DM@PPKMANMA@Civilian?5can?5no?5longer?5be?5rescue@
	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 2506 : 						LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN5@ShouldAbor@3:

; 2507 : 					}
; 2508 : 					return true;

	mov	BYTE PTR $T237129[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T237129[ebp]
	jmp	$LN16@ShouldAbor@3
$LN8@ShouldAbor@3:

; 2509 : 				}
; 2510 : 			}

	jmp	$LN15@ShouldAbor@3
$LN11@ShouldAbor@3:

; 2511 : 		}
; 2512 : 
; 2513 : 		else if(m_eCurrentState != AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 1
	je	$LN15@ShouldAbor@3

; 2514 : 		{
; 2515 : 			// If down below strength of camp, abort
; 2516 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	xor	ecx, ecx
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T237169[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237173[ebp], ecx
	mov	edx, DWORD PTR $T237169[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR $T237173[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$224487[ebp], eax

; 2517 : 			CvPlot* pTarget = GetTargetPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR _pTarget$224488[ebp], eax

; 2518 : 			UnitHandle pCampDefender = pTarget->getBestDefender(NO_PLAYER);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	lea	ecx, DWORD PTR _pCampDefender$224489[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTarget$224488[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2519 : 			if(pCampDefender && pThisArmy->GetTotalPower() < pCampDefender->GetPower())

	xor	edx, edx
	cmp	DWORD PTR _pCampDefender$224489[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN2@ShouldAbor@3
	mov	ecx, DWORD PTR _pCampDefender$224489[ebp]
	mov	DWORD PTR $T237180[ebp], ecx
	mov	ecx, DWORD PTR _pThisArmy$224487[ebp]
	call	?GetTotalPower@CvArmyAI@@QAEHXZ		; CvArmyAI::GetTotalPower
	mov	esi, eax
	mov	ecx, DWORD PTR $T237180[ebp]
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	cmp	esi, eax
	jge	$LN2@ShouldAbor@3

; 2520 : 			{
; 2521 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@ShouldAbor@3

; 2522 : 				{
; 2523 : 					strMsg.Format("Barbarian camp stronger (%d) than our units (%d). Aborting", pCampDefender->GetPower(), pThisArmy->GetTotalPower());

	mov	ecx, DWORD PTR _pCampDefender$224489[ebp]
	mov	DWORD PTR $T237184[ebp], ecx
	mov	ecx, DWORD PTR _pThisArmy$224487[ebp]
	call	?GetTotalPower@CvArmyAI@@QAEHXZ		; CvArmyAI::GetTotalPower
	push	eax
	mov	ecx, DWORD PTR $T237184[ebp]
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	push	eax
	push	OFFSET ??_C@_0DL@FOJDPNNE@Barbarian?5camp?5stronger?5?$CI?$CFd?$CJ?5tha@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2524 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN1@ShouldAbor@3:

; 2525 : 				}
; 2526 : 				return true;

	mov	BYTE PTR $T237130[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pCampDefender$224489[ebp], 0
	je	SHORT $LN51@ShouldAbor@3
	mov	ecx, DWORD PTR _pCampDefender$224489[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN51@ShouldAbor@3:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T237130[ebp]
	jmp	SHORT $LN16@ShouldAbor@3
$LN2@ShouldAbor@3:

; 2527 : 			}
; 2528 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pCampDefender$224489[ebp], 0
	je	SHORT $LN15@ShouldAbor@3
	mov	ecx, DWORD PTR _pCampDefender$224489[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN15@ShouldAbor@3:

; 2529 : 	}
; 2530 : 
; 2531 : 	return rtnValue;

	mov	cl, BYTE PTR _rtnValue$[ebp]
	mov	BYTE PTR $T237131[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T237131[ebp]
$LN16@ShouldAbor@3:

; 2532 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$1:
	lea	ecx, DWORD PTR _pCampDefender$224489[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ ENDP ; CvAIOperationDestroyBarbarianCamp::ShouldAbort
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedImprovementType
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -72						; size = 4
_uiOffset$237269 = -68					; size = 4
$T237257 = -64						; size = 4
$T237253 = -60						; size = 4
$T237249 = -56						; size = 4
$T237245 = -52						; size = 4
$T237222 = -48						; size = 4
_pLoopUnit$224511 = -44					; size = 4
_BarbPlayer$224509 = -40				; size = 4
_iLoop$224512 = -36					; size = 4
_pPlot$ = -32						; size = 4
_pStartCity$ = -28					; size = 4
_iPlotLoop$ = -24					; size = 4
_pBestPlot$ = -20					; size = 4
_iBestPlotDistance$ = -16				; size = 4
_eBarbCamp$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_iCurPlotDistance$ = -4					; size = 4
?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationDestroyBarbarianCamp::FindBestTarget, COMDAT
; _this$ = ecx

; 2536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 2537 : #ifdef AUI_WARNING_FIXES
; 2538 : 	uint iPlotLoop;
; 2539 : #else
; 2540 : 	int iPlotLoop;
; 2541 : #endif
; 2542 : 	CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 2543 : 	CvPlot* pPlot;
; 2544 : 	int iBestPlotDistance = MAX_INT;

	mov	DWORD PTR _iBestPlotDistance$[ebp], 2147483647 ; 7fffffffH

; 2545 : 	int iCurPlotDistance;
; 2546 : 
; 2547 : 	m_bCivilianRescue = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+112], 0

; 2548 : 
; 2549 : 	TeamTypes eTeam = GET_PLAYER(m_eOwner).getTeam();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237222[ebp], edx
	mov	eax, DWORD PTR $T237222[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 2550 : 	ImprovementTypes eBarbCamp = (ImprovementTypes) GC.getBARBARIAN_CAMP_IMPROVEMENT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR _eBarbCamp$[ebp], edx

; 2551 : 
; 2552 : 	CvCity* pStartCity;
; 2553 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _pStartCity$[ebp], eax

; 2554 : 	if(pStartCity != NULL)

	cmp	DWORD PTR _pStartCity$[ebp], 0
	je	$LN14@FindBestTa

; 2555 : 	{
; 2556 : 
; 2557 : 		// look for good captured civilians of ours (settlers and workers, not missionaries) 
; 2558 : 		// these will be even more important than just a camp
; 2559 : 		// btw - the AI will cheat here - as a human I would use a combination of memory and intuition to find these, since our current AI has neither of these...
; 2560 : 		CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

	mov	ecx, 63					; 0000003fH
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _BarbPlayer$224509[ebp], ecx

; 2561 : 
; 2562 : 		CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$224511[ebp], 0

; 2563 : 		int iLoop;
; 2564 : 		for (pLoopUnit = BarbPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$224512[ebp]
	push	edx
	mov	ecx, DWORD PTR _BarbPlayer$224509[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$224511[ebp], eax
	jmp	SHORT $LN13@FindBestTa
$LN12@FindBestTa:
	push	0
	lea	eax, DWORD PTR _iLoop$224512[ebp]
	push	eax
	mov	ecx, DWORD PTR _BarbPlayer$224509[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$224511[ebp], eax
$LN13@FindBestTa:
	cmp	DWORD PTR _pLoopUnit$224511[ebp], 0
	je	$LN11@FindBestTa

; 2565 : 		{
; 2566 : 			if (pLoopUnit->GetOriginalOwner() == m_eOwner && (pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER || pLoopUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST))

	mov	ecx, DWORD PTR _pLoopUnit$224511[ebp]
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+72]
	jne	$LN10@FindBestTa
	mov	ecx, DWORD PTR _pLoopUnit$224511[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	SHORT $LN9@FindBestTa
	mov	ecx, DWORD PTR _pLoopUnit$224511[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN9@FindBestTa
	mov	ecx, DWORD PTR _pLoopUnit$224511[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN10@FindBestTa
$LN9@FindBestTa:

; 2567 : 			{
; 2568 : 				iCurPlotDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pLoopUnit->plot(), pStartCity->plot());

	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$224511[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	DWORD PTR _iCurPlotDistance$[ebp], eax

; 2569 : 				if (iCurPlotDistance < iBestPlotDistance)

	mov	eax, DWORD PTR _iCurPlotDistance$[ebp]
	cmp	eax, DWORD PTR _iBestPlotDistance$[ebp]
	jge	SHORT $LN10@FindBestTa

; 2570 : 				{
; 2571 : 					pBestPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$224511[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pBestPlot$[ebp], eax

; 2572 : 					iBestPlotDistance = iCurPlotDistance;

	mov	ecx, DWORD PTR _iCurPlotDistance$[ebp]
	mov	DWORD PTR _iBestPlotDistance$[ebp], ecx

; 2573 : 					m_bCivilianRescue = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+112], 1

; 2574 : 					m_iUnitToRescue = pLoopUnit->GetID();

	mov	eax, DWORD PTR _pLoopUnit$224511[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T237245[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T237245[ebp]
	mov	DWORD PTR [edx+116], eax
$LN10@FindBestTa:

; 2575 : 				}
; 2576 : 			}
; 2577 : 		}

	jmp	$LN12@FindBestTa
$LN11@FindBestTa:

; 2578 : 
; 2579 : 		if (!pBestPlot)

	cmp	DWORD PTR _pBestPlot$[ebp], 0
	jne	$LN14@FindBestTa

; 2580 : 		{
; 2581 : 			// Look at map for Barbarian camps
; 2582 : 			for (iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$[ebp], 0
	jmp	SHORT $LN6@FindBestTa
$LN5@FindBestTa:
	mov	ecx, DWORD PTR _iPlotLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlotLoop$[ebp], ecx
$LN6@FindBestTa:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237249[ebp], edx
	mov	eax, DWORD PTR $T237249[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T237253[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	cmp	edx, DWORD PTR $T237253[ebp]
	jge	$LN14@FindBestTa

; 2583 : 			{
; 2584 : 				pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237257[ebp], eax
	mov	ecx, DWORD PTR _iPlotLoop$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T237257[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$[ebp], ecx

; 2585 : 
; 2586 : 				if (pPlot->isRevealed(eTeam))

	mov	eax, DWORD PTR _eTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$237269[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$237269[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$237269[ebp]
	mov	edx, DWORD PTR _pPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@FindBestTa

; 2587 : 				{
; 2588 : 					if (pPlot->getRevealedImprovementType(eTeam) == eBarbCamp)

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	cmp	eax, DWORD PTR _eBarbCamp$[ebp]
	jne	SHORT $LN3@FindBestTa

; 2589 : 					{
; 2590 : 						// Make sure camp is in the same area as our start city
; 2591 : 						//if (pPlot->getArea() == pStartCity->getArea())
; 2592 : 						{
; 2593 : 							iCurPlotDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pPlot, pStartCity->plot());

	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	DWORD PTR _iCurPlotDistance$[ebp], eax

; 2594 : 
; 2595 : 							if (iCurPlotDistance < iBestPlotDistance)

	mov	edx, DWORD PTR _iCurPlotDistance$[ebp]
	cmp	edx, DWORD PTR _iBestPlotDistance$[ebp]
	jge	SHORT $LN3@FindBestTa

; 2596 : 							{
; 2597 : 								pBestPlot = pPlot;

	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], eax

; 2598 : 								iBestPlotDistance = iCurPlotDistance;

	mov	ecx, DWORD PTR _iCurPlotDistance$[ebp]
	mov	DWORD PTR _iBestPlotDistance$[ebp], ecx
$LN3@FindBestTa:

; 2599 : 							}
; 2600 : 						}
; 2601 : 					}
; 2602 : 				}
; 2603 : 			}

	jmp	$LN5@FindBestTa
$LN14@FindBestTa:

; 2604 : 		}
; 2605 : 
; 2606 : 	}
; 2607 : 
; 2608 : 	return pBestPlot;

	mov	eax, DWORD PTR _pBestPlot$[ebp]

; 2609 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationDestroyBarbarianCamp::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationPillageEnemy@@6B@		; CvAIOperationPillageEnemy::`vftable'
PUBLIC	?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ ; CvAIOperationPillageEnemy::GetOperationType
PUBLIC	?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ ; CvAIOperationPillageEnemy::NeedToCheckPathToTarget
PUBLIC	?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationPillageEnemy::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationPillageEnemy::ArmyInPosition
PUBLIC	?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationPillageEnemy::ArmyMoved
PUBLIC	?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z ; CvAIOperationPillageEnemy::Read
PUBLIC	?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z ; CvAIOperationPillageEnemy::Write
PUBLIC	?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ ; CvAIOperationPillageEnemy::GetOperationName
PUBLIC	?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ ; CvAIOperationPillageEnemy::GetDeployRange
PUBLIC	?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ ; CvAIOperationPillageEnemy::FindBestTarget
EXTRN	??_ECvAIOperationPillageEnemy@@UAEPAXI@Z:PROC	; CvAIOperationPillageEnemy::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationPillageEnemy@@6B@
CONST	SEGMENT
??_7CvAIOperationPillageEnemy@@6B@ DD FLAT:??_ECvAIOperationPillageEnemy@@UAEPAXI@Z ; CvAIOperationPillageEnemy::`vftable'
	DD	FLAT:?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationPillageEnemy@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationPillageEnemy@@QAE@XZ PROC		; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy, COMDAT
; _this$ = ecx

; 2617 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIEnemyTerritoryOperation@@QAE@XZ	; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationPillageEnemy@@6B@

; 2618 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationPillageEnemy@@QAE@XZ ENDP		; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy
_TEXT	ENDS
PUBLIC	??1CvAIOperationPillageEnemy@@UAE@XZ		; CvAIOperationPillageEnemy::~CvAIOperationPillageEnemy
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationPillageEnemy@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationPillageEnemy@@UAEPAXI@Z PROC		; CvAIOperationPillageEnemy::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationPillageEnemy@@UAE@XZ	; CvAIOperationPillageEnemy::~CvAIOperationPillageEnemy
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationPillageEnemy@@UAEPAXI@Z ENDP		; CvAIOperationPillageEnemy::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationPillageEnemy@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationPillageEnemy@@UAE@XZ PROC		; CvAIOperationPillageEnemy::~CvAIOperationPillageEnemy, COMDAT
; _this$ = ecx

; 2622 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationPillageEnemy@@6B@

; 2623 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEnemyTerritoryOperation@@UAE@XZ	; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationPillageEnemy@@UAE@XZ ENDP		; CvAIOperationPillageEnemy::~CvAIOperationPillageEnemy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T237284 = -4						; size = 4
?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ PROC	; CvAIOperationPillageEnemy::GetDeployRange, COMDAT
; _this$ = ecx

; 2627 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2628 : 	return GC.getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2424
	mov	DWORD PTR $T237284[ebp], eax
	mov	eax, DWORD PTR $T237284[ebp]

; 2629 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ ENDP	; CvAIOperationPillageEnemy::GetDeployRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationPillageEnemy::Read, COMDAT
; _this$ = ecx

; 2633 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2634 : 	// read the base class' entries
; 2635 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2636 : 
; 2637 : 	// Version number to maintain backwards compatibility
; 2638 : 	uint uiVersion;
; 2639 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2640 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationPillageEnemy::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationPillageEnemy::Write, COMDAT
; _this$ = ecx

; 2644 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2645 : 	// write the base class' entries
; 2646 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2647 : 
; 2648 : 	// Current version number
; 2649 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 2650 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2651 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationPillageEnemy::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -28						; size = 4
_this$ = -24						; size = 4
$T237304 = -20						; size = 4
$T237300 = -16						; size = 4
_pDeployPt$224563 = -12					; size = 4
_pBetterTarget$ = -8					; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationPillageEnemy::ArmyMoved, COMDAT
; _this$ = ecx

; 2655 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 2656 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 2657 : 	CvPlot* pBetterTarget;
; 2658 : 
; 2659 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	$LN6@ArmyMoved
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN16@ArmyMoved[edx*4]
$LN5@ArmyMoved:

; 2660 : 	{
; 2661 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2662 : 	{
; 2663 : 		// Find best pillage target
; 2664 : 		pBetterTarget = FindBestTarget();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pBetterTarget$[ebp], eax

; 2665 : 
; 2666 : 		// No targets at all!  Abort
; 2667 : 		if(pBetterTarget == NULL)

	cmp	DWORD PTR _pBetterTarget$[ebp], 0
	jne	SHORT $LN4@ArmyMoved

; 2668 : 		{
; 2669 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 2670 : 			m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 1
	jmp	SHORT $LN3@ArmyMoved
$LN4@ArmyMoved:

; 2671 : 		}
; 2672 : 
; 2673 : 		// If this is a new target, switch to it
; 2674 : 		else if(pBetterTarget != GetTargetPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _pBetterTarget$[ebp], eax
	je	SHORT $LN3@ArmyMoved

; 2675 : 		{
; 2676 : 			SetTargetPlot(pBetterTarget);

	mov	eax, DWORD PTR _pBetterTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 2677 : 			pArmy->SetGoalPlot(pBetterTarget);

	mov	ecx, DWORD PTR _pBetterTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2678 : 
; 2679 : 			// Reset our destination to be a few plots shy of the final target
; 2680 : 			CvPlot* pDeployPt;
; 2681 : 			pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), pBetterTarget, GC.getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE(), false);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2424
	mov	DWORD PTR $T237300[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T237304[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T237300[ebp]
	push	edx
	mov	eax, DWORD PTR _pBetterTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	ecx, DWORD PTR $T237304[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	DWORD PTR _pDeployPt$224563[ebp], eax

; 2682 : 			pArmy->SetGoalPlot(pDeployPt);

	mov	edx, DWORD PTR _pDeployPt$224563[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN3@ArmyMoved:

; 2683 : 		}
; 2684 : 	}
; 2685 : 	break;

	jmp	SHORT $LN6@ArmyMoved

; 2686 : 
; 2687 : 	// In all other cases use base class version
; 2688 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2689 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2690 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2691 : 	case AI_OPERATION_STATE_ABORTED:
; 2692 : 		return CvAIOperation::ArmyMoved(pArmy);

$LN14@ArmyMoved:
	xor	al, al
	jmp	SHORT $LN8@ArmyMoved
$LN6@ArmyMoved:

; 2693 : 		break;
; 2694 : 	};
; 2695 : 
; 2696 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
$LN8@ArmyMoved:

; 2697 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN16@ArmyMoved:
	DD	$LN14@ArmyMoved
	DD	$LN14@ArmyMoved
	DD	$LN14@ArmyMoved
	DD	$LN5@ArmyMoved
	DD	$LN14@ArmyMoved
?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationPillageEnemy::ArmyMoved
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationPillageEnemy::ArmyInPosition, COMDAT
; _this$ = ecx

; 2701 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2702 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 2703 : 
; 2704 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	SHORT $LN4@ArmyInPosi@4
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN8@ArmyInPosi@4[edx*4]
$LN3@ArmyInPosi@4:

; 2705 : 	{
; 2706 : 		// See if reached our target, if so give control of these units to the tactical AI
; 2707 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2708 : 	{
; 2709 : 		if(pArmy->Plot() == pArmy->GetGoalPlot())

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	cmp	esi, eax
	jne	SHORT $LN2@ArmyInPosi@4

; 2710 : 		{
; 2711 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 5
$LN2@ArmyInPosi@4:

; 2712 : 		}
; 2713 : 	}
; 2714 : 	break;

	jmp	SHORT $LN4@ArmyInPosi@4
$LN1@ArmyInPosi@4:

; 2715 : 
; 2716 : 	// In all other cases use base class version
; 2717 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2718 : 	case AI_OPERATION_STATE_ABORTED:
; 2719 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2720 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2721 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al
$LN4@ArmyInPosi@4:

; 2722 : 		break;
; 2723 : 	};
; 2724 : 
; 2725 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]

; 2726 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN8@ArmyInPosi@4:
	DD	$LN1@ArmyInPosi@4
	DD	$LN1@ArmyInPosi@4
	DD	$LN1@ArmyInPosi@4
	DD	$LN3@ArmyInPosi@4
	DD	$LN1@ArmyInPosi@4
?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationPillageEnemy::ArmyInPosition
_TEXT	ENDS
EXTRN	?countNumImprovedPlots@CvCity@@QBEHW4ImprovementTypes@@_N@Z:PROC ; CvCity::countNumImprovedPlots
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T237325 = -33						; size = 1
_iDistance$ = -32					; size = 4
_pBestTargetCity$ = -28					; size = 4
_pStartCity$ = -24					; size = 4
_iBestValue$ = -20					; size = 4
_kEnemyPlayer$ = -16					; size = 4
_iValue$ = -12						; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationPillageEnemy::FindBestTarget, COMDAT
; _this$ = ecx

; 2730 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2731 : 	CvCity* pBestTargetCity = NULL;

	mov	DWORD PTR _pBestTargetCity$[ebp], 0

; 2732 : 	int iValue;
; 2733 : 	int iBestValue;
; 2734 : 	CvCity* pLoopCity;
; 2735 : 	CvCity* pStartCity;
; 2736 : 	int iDistance;
; 2737 : 	int iLoop;
; 2738 : 
; 2739 : 	CvPlayerAI& kEnemyPlayer = GET_PLAYER(m_eEnemy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kEnemyPlayer$[ebp], ecx

; 2740 : 
; 2741 : 	if(!kEnemyPlayer.isAlive())

	mov	edx, DWORD PTR _kEnemyPlayer$[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T237325[ebp], al
	movzx	ecx, BYTE PTR $T237325[ebp]
	test	ecx, ecx
	jne	SHORT $LN10@FindBestTa@2

; 2742 : 	{
; 2743 : 		return NULL;

	xor	eax, eax
	jmp	$LN11@FindBestTa@2
$LN10@FindBestTa@2:

; 2744 : 	}
; 2745 : 
; 2746 : 	iBestValue = 0;

	mov	DWORD PTR _iBestValue$[ebp], 0

; 2747 : 	pStartCity = GetOperationStartCity();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	DWORD PTR _pStartCity$[ebp], eax

; 2748 : 	if(pStartCity != NULL)

	cmp	DWORD PTR _pStartCity$[ebp], 0
	je	$LN9@FindBestTa@2

; 2749 : 	{
; 2750 : 		for(pLoopCity = kEnemyPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kEnemyPlayer.nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kEnemyPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN8@FindBestTa@2
$LN7@FindBestTa@2:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kEnemyPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN8@FindBestTa@2:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN9@FindBestTa@2

; 2751 : 		{
; 2752 : 			// Make sure city is in the same area as our start city
; 2753 : 			if(pLoopCity->getArea() == pStartCity->getArea())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	esi, eax
	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	esi, eax
	jne	SHORT $LN5@FindBestTa@2

; 2754 : 			{
; 2755 : 				// Initial value of target is the number of improved plots
; 2756 : 				iValue = pLoopCity->countNumImprovedPlots();

	push	0
	push	-1
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?countNumImprovedPlots@CvCity@@QBEHW4ImprovementTypes@@_N@Z ; CvCity::countNumImprovedPlots
	mov	DWORD PTR _iValue$[ebp], eax

; 2757 : 
; 2758 : 				// Adjust value based on proximity to our start location
; 2759 : 				iDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pLoopCity->plot(), pStartCity->plot());

	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	DWORD PTR _iDistance$[ebp], eax

; 2760 : 				if(iDistance > 0)

	cmp	DWORD PTR _iDistance$[ebp], 0
	jle	SHORT $LN4@FindBestTa@2

; 2761 : 				{
; 2762 : 					iValue = iValue * 100 / iDistance;

	mov	eax, DWORD PTR _iValue$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iDistance$[ebp]
	mov	DWORD PTR _iValue$[ebp], eax
$LN4@FindBestTa@2:

; 2763 : 				}
; 2764 : 
; 2765 : 				if(iValue > iBestValue)

	mov	eax, DWORD PTR _iValue$[ebp]
	cmp	eax, DWORD PTR _iBestValue$[ebp]
	jle	SHORT $LN5@FindBestTa@2

; 2766 : 				{
; 2767 : 					iBestValue = iValue;

	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], ecx

; 2768 : 					pBestTargetCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestTargetCity$[ebp], edx
$LN5@FindBestTa@2:

; 2769 : 				}
; 2770 : 			}
; 2771 : 		}

	jmp	$LN7@FindBestTa@2
$LN9@FindBestTa@2:

; 2772 : 	}
; 2773 : 
; 2774 : 	if(pBestTargetCity == NULL)

	cmp	DWORD PTR _pBestTargetCity$[ebp], 0
	jne	SHORT $LN2@FindBestTa@2

; 2775 : 	{
; 2776 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN11@FindBestTa@2

; 2777 : 	}
; 2778 : 	else

	jmp	SHORT $LN11@FindBestTa@2
$LN2@FindBestTa@2:

; 2779 : 	{
; 2780 : 		return pBestTargetCity->plot();

	mov	ecx, DWORD PTR _pBestTargetCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
$LN11@FindBestTa@2:

; 2781 : 	}
; 2782 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationPillageEnemy::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIEscortedOperation@@6B@			; CvAIEscortedOperation::`vftable'
PUBLIC	??0CvAIEscortedOperation@@QAE@XZ		; CvAIEscortedOperation::CvAIEscortedOperation
PUBLIC	?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIEscortedOperation::Init
PUBLIC	?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z	; CvAIEscortedOperation::UnitWasRemoved
PUBLIC	?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z ; CvAIEscortedOperation::Read
PUBLIC	?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z ; CvAIEscortedOperation::Write
PUBLIC	?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ ; CvAIEscortedOperation::FindBestCivilian
EXTRN	??_ECvAIEscortedOperation@@UAEPAXI@Z:PROC	; CvAIEscortedOperation::`vector deleting destructor'
;	COMDAT ??_7CvAIEscortedOperation@@6B@
CONST	SEGMENT
??_7CvAIEscortedOperation@@6B@ DD FLAT:??_ECvAIEscortedOperation@@UAEPAXI@Z ; CvAIEscortedOperation::`vftable'
	DD	FLAT:?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIEscortedOperation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIEscortedOperation@@QAE@XZ PROC			; CvAIEscortedOperation::CvAIEscortedOperation, COMDAT
; _this$ = ecx

; 2788 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIEscortedOperation@@6B@

; 2789 : 	m_bEscorted = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+112], 1

; 2790 : 	m_iTargetArea = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], -1

; 2791 : #ifdef AUI_WARNING_FIXES
; 2792 : 	m_eCivilianType = NO_UNITAI;
; 2793 : #endif
; 2794 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIEscortedOperation@@QAE@XZ ENDP			; CvAIEscortedOperation::CvAIEscortedOperation
_TEXT	ENDS
PUBLIC	??1CvAIEscortedOperation@@UAE@XZ		; CvAIEscortedOperation::~CvAIEscortedOperation
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIEscortedOperation@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIEscortedOperation@@UAEPAXI@Z PROC		; CvAIEscortedOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEscortedOperation@@UAE@XZ	; CvAIEscortedOperation::~CvAIEscortedOperation
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIEscortedOperation@@UAEPAXI@Z ENDP		; CvAIEscortedOperation::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIEscortedOperation@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIEscortedOperation@@UAE@XZ PROC			; CvAIEscortedOperation::~CvAIEscortedOperation, COMDAT
; _this$ = ecx

; 2797 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIEscortedOperation@@6B@

; 2798 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIEscortedOperation@@UAE@XZ ENDP			; CvAIEscortedOperation::~CvAIEscortedOperation
_TEXT	ENDS
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
; Function compile flags: /Odtp
;	COMDAT ?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -456						; size = 4
$T238165 = -452						; size = 4
$T238161 = -448						; size = 4
$T238160 = -444						; size = 4
$T238156 = -440						; size = 4
$T237989 = -372						; size = 4
$T237973 = -368						; size = 4
$T238142 = -364						; size = 4
$T238141 = -360						; size = 4
$T238140 = -356						; size = 4
$T238139 = -352						; size = 4
$T238138 = -348						; size = 4
$T237838 = -288						; size = 4
$T237686 = -232						; size = 4
$T237670 = -228						; size = 4
$T237824 = -224						; size = 4
$T237823 = -220						; size = 4
$T237822 = -216						; size = 4
$T237821 = -212						; size = 4
$T237820 = -208						; size = 4
$T237557 = -156						; size = 4
$T237431 = -120						; size = 4
$T237415 = -116						; size = 4
$T237543 = -112						; size = 4
$T237542 = -108						; size = 4
$T237541 = -104						; size = 4
$T237540 = -100						; size = 4
$T237539 = -96						; size = 4
$T237399 = -92						; size = 4
$T237395 = -88						; size = 4
$T237386 = -84						; size = 4
$T237379 = -80						; size = 4
$T237340 = -52						; size = 4
$T237336 = -48						; size = 4
_thisOperationSlot2$224633 = -44			; size = 12
_thisOperationSlot$224628 = -32				; size = 12
_pMusterPt$224625 = -20					; size = 4
_pArmyAI$224622 = -16					; size = 4
_pOurCivilian$ = -12					; size = 4
_pNewTarget$ = -8					; size = 4
_pTargetSite$ = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIEscortedOperation::Init, COMDAT
; _this$ = ecx

; 2802 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 456				; 000001c8H
	mov	DWORD PTR _this$[ebp], ecx

; 2803 : 	CvUnit* pOurCivilian;
; 2804 : 	CvPlot* pTargetSite, *pNewTarget;
; 2805 : 
; 2806 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 2807 : 	m_eMoveType = AI_OPERATION_MOVETYPE_SINGLE_HEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 2808 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 2809 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 2810 : 
; 2811 : 	// Find the free civilian (that triggered this operation)
; 2812 : 	pOurCivilian = FindBestCivilian();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	call	eax
	mov	DWORD PTR _pOurCivilian$[ebp], eax

; 2813 : 
; 2814 : 	if(pOurCivilian != NULL && iID != -1)

	cmp	DWORD PTR _pOurCivilian$[ebp], 0
	je	$LN12@Init@3
	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN12@Init@3

; 2815 : 	{
; 2816 : 		// Find a destination (not worrying about safe paths)
; 2817 : 		pTargetSite = FindBestTarget(pOurCivilian, false);

	push	0
	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	DWORD PTR _pTargetSite$[ebp], eax

; 2818 : 
; 2819 : 		if(pTargetSite != NULL)

	cmp	DWORD PTR _pTargetSite$[ebp], 0
	je	$LN10@Init@3

; 2820 : 		{
; 2821 : 			SetTargetPlot(pTargetSite);

	mov	eax, DWORD PTR _pTargetSite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 2822 : 
; 2823 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 2824 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237340[ebp], edx
	mov	ecx, DWORD PTR $T237340[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$224622[ebp], eax

; 2825 : 			if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$224622[ebp], 0
	je	$LN9@Init@3

; 2826 : 			{
; 2827 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T237336[ebp], eax
	lea	eax, DWORD PTR $T237336[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 2828 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 2829 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2830 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 2831 : 
; 2832 : 				// Figure out the initial rally point - for this operation it is wherever our civilian is standing
; 2833 : 				pArmyAI->SetGoalPlot(pTargetSite);

	mov	eax, DWORD PTR _pTargetSite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2834 : 				CvPlot* pMusterPt = pOurCivilian->plot();

	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pMusterPt$224625[ebp], eax

; 2835 : 				SetMusterPlot(pMusterPt);

	mov	ecx, DWORD PTR _pMusterPt$224625[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 2836 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	mov	edx, DWORD PTR _pMusterPt$224625[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T237379[ebp], eax
	mov	ecx, DWORD PTR $T237379[ebp]
	push	ecx
	mov	edx, DWORD PTR _pMusterPt$224625[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 2837 : 				SetDefaultArea(pMusterPt->getArea());

	mov	ecx, DWORD PTR _pMusterPt$224625[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T237386[ebp], edx
	mov	eax, DWORD PTR $T237386[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 2838 : 
; 2839 : 				// Add the civilian to our army
; 2840 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T237395[ebp], edx
	push	0
	mov	eax, DWORD PTR $T237395[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 2841 : 
; 2842 : 				// Skip escorting if this operation has to go across water
; 2843 : 				if (pTargetSite->getArea() != pOurCivilian->getArea())

	mov	ecx, DWORD PTR _pTargetSite$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T237399[ebp], edx
	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	cmp	DWORD PTR $T237399[ebp], eax
	je	SHORT $LN8@Init@3

; 2844 : 				{
; 2845 : 					m_bEscorted = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+112], 0
$LN8@Init@3:

; 2846 : 				}
; 2847 : 
; 2848 : 				if (m_bEscorted)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+112]
	test	edx, edx
	je	$LN7@Init@3

; 2849 : 				{
; 2850 : 					m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T237557[ebp], eax
	mov	ecx, DWORD PTR $T237557[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237415[ebp], edx
	mov	eax, DWORD PTR $T237415[ebp]
	mov	DWORD PTR $T237540[ebp], eax
	mov	ecx, DWORD PTR $T237540[ebp]
	mov	DWORD PTR $T237539[ebp], ecx
	mov	edx, DWORD PTR $T237557[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237431[ebp], eax
	mov	ecx, DWORD PTR $T237431[ebp]
	mov	DWORD PTR $T237542[ebp], ecx
	mov	edx, DWORD PTR $T237542[ebp]
	mov	DWORD PTR $T237541[ebp], edx
	mov	eax, DWORD PTR $T237539[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237541[ebp]
	push	ecx
	lea	edx, DWORD PTR $T237543[ebp]
	push	edx
	mov	ecx, DWORD PTR $T237557[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 2851 : 					OperationSlot thisOperationSlot;

	mov	DWORD PTR _thisOperationSlot$224628[ebp], -1
	mov	DWORD PTR _thisOperationSlot$224628[ebp+4], -1
	mov	DWORD PTR _thisOperationSlot$224628[ebp+8], -1

; 2852 : 					thisOperationSlot.m_iOperationID = m_iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _thisOperationSlot$224628[ebp], ecx

; 2853 : 					thisOperationSlot.m_iArmyID = pArmyAI->GetID();

	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR _thisOperationSlot$224628[ebp+4], eax

; 2854 : 					thisOperationSlot.m_iSlotID = 1;

	mov	DWORD PTR _thisOperationSlot$224628[ebp+8], 1

; 2855 : 					m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot);

	lea	edx, DWORD PTR _thisOperationSlot$224628[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 2856 : 
; 2857 : 					// try to get the escort from existing units that are waiting around
; 2858 : 					GrabUnitsFromTheReserves(pMusterPt, pTargetSite);

	mov	eax, DWORD PTR _pTargetSite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMusterPt$224625[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx

; 2859 : 					if(pArmyAI->GetNumSlotsFilled() > 1)

	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jle	SHORT $LN6@Init@3

; 2860 : 					{
; 2861 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2862 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 2

; 2863 : 					}
; 2864 : 					else

	jmp	SHORT $LN7@Init@3
$LN6@Init@3:

; 2865 : 					{
; 2866 : 						m_bEscorted = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+112], 0
$LN7@Init@3:

; 2867 : 					}
; 2868 : 				}
; 2869 : 
; 2870 : 				if (!m_bEscorted)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+112]
	test	eax, eax
	jne	$LN4@Init@3

; 2871 : 				{
; 2872 : 					// There was no escort immediately available.  Let's look for a "safe" city site instead
; 2873 : 					pNewTarget = FindBestTarget(pOurCivilian, true);

	push	1
	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	DWORD PTR _pNewTarget$[ebp], eax

; 2874 : 
; 2875 : 					// If no better target, we'll wait it out for an escort
; 2876 : 					if(pNewTarget == NULL)

	cmp	DWORD PTR _pNewTarget$[ebp], 0
	jne	$LN3@Init@3

; 2877 : 					{
; 2878 : 						m_bEscorted = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+112], 1

; 2879 : 
; 2880 : 						// Need to add it back in to list of what to build (was cleared before since marked optional)
; 2881 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T237838[ebp], ecx
	mov	edx, DWORD PTR $T237838[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T237670[ebp], eax
	mov	ecx, DWORD PTR $T237670[ebp]
	mov	DWORD PTR $T237821[ebp], ecx
	mov	edx, DWORD PTR $T237821[ebp]
	mov	DWORD PTR $T237820[ebp], edx
	mov	eax, DWORD PTR $T237838[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237686[ebp], ecx
	mov	edx, DWORD PTR $T237686[ebp]
	mov	DWORD PTR $T237823[ebp], edx
	mov	eax, DWORD PTR $T237823[ebp]
	mov	DWORD PTR $T237822[ebp], eax
	mov	ecx, DWORD PTR $T237820[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237822[ebp]
	push	edx
	lea	eax, DWORD PTR $T237824[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237838[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 2882 : 						OperationSlot thisOperationSlot2;

	mov	DWORD PTR _thisOperationSlot2$224633[ebp], -1
	mov	DWORD PTR _thisOperationSlot2$224633[ebp+4], -1
	mov	DWORD PTR _thisOperationSlot2$224633[ebp+8], -1

; 2883 : 						thisOperationSlot2.m_iOperationID = m_iID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR _thisOperationSlot2$224633[ebp], edx

; 2884 : 						thisOperationSlot2.m_iArmyID = pArmyAI->GetID();

	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR _thisOperationSlot2$224633[ebp+4], eax

; 2885 : 						thisOperationSlot2.m_iSlotID = 1;

	mov	DWORD PTR _thisOperationSlot2$224633[ebp+8], 1

; 2886 : 						m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot2);

	lea	eax, DWORD PTR _thisOperationSlot2$224633[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 2887 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 1

; 2888 : 					}
; 2889 : 
; 2890 : 					// Send the civilian by himself to this safe location
; 2891 : 					else

	jmp	$LN4@Init@3
$LN3@Init@3:

; 2892 : 					{
; 2893 : 						// Clear the list of units we need
; 2894 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T238156[ebp], edx
	mov	eax, DWORD PTR $T238156[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237973[ebp], ecx
	mov	edx, DWORD PTR $T237973[ebp]
	mov	DWORD PTR $T238139[ebp], edx
	mov	eax, DWORD PTR $T238139[ebp]
	mov	DWORD PTR $T238138[ebp], eax
	mov	ecx, DWORD PTR $T238156[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237989[ebp], edx
	mov	eax, DWORD PTR $T237989[ebp]
	mov	DWORD PTR $T238141[ebp], eax
	mov	ecx, DWORD PTR $T238141[ebp]
	mov	DWORD PTR $T238140[ebp], ecx
	mov	edx, DWORD PTR $T238138[ebp]
	push	edx
	mov	eax, DWORD PTR $T238140[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238142[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238156[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 2895 : 
; 2896 : 						// Change the muster point
; 2897 : 						pArmyAI->SetGoalPlot(pNewTarget);

	mov	edx, DWORD PTR _pNewTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2898 : 						SetMusterPlot(pOurCivilian->plot());

	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 2899 : 						pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T238160[ebp], eax
	mov	eax, DWORD PTR $T238160[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T238161[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T238165[ebp], eax
	mov	edx, DWORD PTR $T238161[ebp]
	push	edx
	mov	eax, DWORD PTR $T238165[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 2900 : 
; 2901 : 						// Send the civilian directly to the target
; 2902 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pArmyAI$224622[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2903 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 3
$LN4@Init@3:

; 2904 : 					}
; 2905 : 				}
; 2906 : 				LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN9@Init@3:

; 2907 : 			}
; 2908 : 		}
; 2909 : 
; 2910 : 		else

	jmp	SHORT $LN12@Init@3
$LN10@Init@3:

; 2911 : 		{
; 2912 : 			// Lost our target, abort
; 2913 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 2914 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 3
$LN12@Init@3:

; 2915 : 		}
; 2916 : 	}
; 2917 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIEscortedOperation::Init
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4UnitAITypes@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z PROC ; CvAIEscortedOperation::Read, COMDAT
; _this$ = ecx

; 2921 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2922 : 	// read the base class' entries
; 2923 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2924 : 
; 2925 : 	// Version number to maintain backwards compatibility
; 2926 : 	uint uiVersion;
; 2927 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2928 : 
; 2929 : 	kStream >> m_bEscorted;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2930 : 	kStream >> m_eCivilianType;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitAITypes@@@Z ; operator>>
	add	esp, 8

; 2931 : 	m_iTargetArea = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], -1

; 2932 : 	kStream >> m_iTargetArea;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 120				; 00000078H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2933 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z ENDP ; CvAIEscortedOperation::Read
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4UnitAITypes@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z PROC ; CvAIEscortedOperation::Write, COMDAT
; _this$ = ecx

; 2937 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2938 : 	// write the base class' entries
; 2939 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2940 : 
; 2941 : 	// Version number to maintain backwards compatibility
; 2942 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 2943 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2944 : 
; 2945 : 	kStream << m_bEscorted;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2946 : 	kStream << m_eCivilianType;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitAITypes@@@Z ; operator<<
	add	esp, 8

; 2947 : 	kStream << m_iTargetArea;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2948 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z ENDP ; CvAIEscortedOperation::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z PROC	; CvAIEscortedOperation::UnitWasRemoved, COMDAT
; _this$ = ecx

; 2952 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2953 : 	// Assumes civilian is in the first slot of the formation
; 2954 : 	if(iSlotID == 0)

	cmp	DWORD PTR _iSlotID$[ebp], 0
	jne	SHORT $LN2@UnitWasRem@2

; 2955 : 	{
; 2956 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 2957 : 		m_eAbortReason = AI_ABORT_LOST_CIVILIAN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 8

; 2958 : 	}
; 2959 : 	else

	jmp	SHORT $LN3@UnitWasRem@2
$LN2@UnitWasRem@2:

; 2960 : 	{
; 2961 : 		m_bEscorted = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+112], 0
$LN3@UnitWasRem@2:

; 2962 : 	}
; 2963 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z ENDP	; CvAIEscortedOperation::UnitWasRemoved
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T238199 = -16						; size = 4
$T238195 = -12						; size = 4
_pLoopUnit$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ PROC ; CvAIEscortedOperation::FindBestCivilian, COMDAT
; _this$ = ecx

; 2967 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2968 : 	int iUnitLoop;
; 2969 : 	CvUnit* pLoopUnit;
; 2970 : 
; 2971 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238195[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238195[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN6@FindBestCi
$LN5@FindBestCi:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238199[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238199[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN6@FindBestCi:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN4@FindBestCi

; 2972 : 	{
; 2973 : 		if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN3@FindBestCi

; 2974 : 		{
; 2975 : 			if(pLoopUnit->AI_getUnitAIType() == m_eCivilianType)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+116]
	jne	SHORT $LN3@FindBestCi

; 2976 : 			{
; 2977 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN3@FindBestCi

; 2978 : 				{
; 2979 : 					return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN7@FindBestCi
$LN3@FindBestCi:

; 2980 : 				}
; 2981 : 			}
; 2982 : 		}
; 2983 : 	}

	jmp	SHORT $LN5@FindBestCi
$LN4@FindBestCi:

; 2984 : 
; 2985 : 	return NULL;

	xor	eax, eax
$LN7@FindBestCi:

; 2986 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ ENDP ; CvAIEscortedOperation::FindBestCivilian
_TEXT	ENDS
PUBLIC	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian
; Function compile flags: /Odtp
;	COMDAT ?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pBetterTarget$ = -4					; size = 4
_pCivilian$ = 8						; size = 4
_pArmy$ = 12						; size = 4
?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z PROC ; CvAIEscortedOperation::RetargetCivilian, COMDAT
; _this$ = ecx

; 2990 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2991 : 	CvPlot* pBetterTarget;
; 2992 : 
; 2993 : 	// Find best city site (taking into account whether or not we are escorted)
; 2994 : 	pBetterTarget = FindBestTarget(pCivilian, !m_bEscorted);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+112]
	test	ecx, ecx
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR _pCivilian$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	DWORD PTR _pBetterTarget$[ebp], eax

; 2995 : 
; 2996 : 	// No targets at all!  Abort
; 2997 : 	if(pBetterTarget == NULL)

	cmp	DWORD PTR _pBetterTarget$[ebp], 0
	jne	SHORT $LN4@RetargetCi

; 2998 : 	{
; 2999 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 3000 : 		m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 1

; 3001 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@RetargetCi
	jmp	SHORT $LN3@RetargetCi
$LN4@RetargetCi:

; 3002 : 	}
; 3003 : 	// If this is a new target, switch to it
; 3004 : 	else if(pBetterTarget != GetTargetPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _pBetterTarget$[ebp], eax
	je	SHORT $LN2@RetargetCi

; 3005 : 	{
; 3006 : 		SetTargetPlot(pBetterTarget);

	mov	edx, DWORD PTR _pBetterTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 3007 : 		pArmy->SetGoalPlot(pBetterTarget);

	mov	eax, DWORD PTR _pBetterTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3008 : 	}
; 3009 : 	else

	jmp	SHORT $LN3@RetargetCi
$LN2@RetargetCi:

; 3010 : 	{
; 3011 : 		SetToAbort(AI_ABORT_REPEAT_TARGET);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 3012 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@RetargetCi
$LN3@RetargetCi:

; 3013 : 	}
; 3014 : 
; 3015 : 	pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3016 : 	m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 3

; 3017 : 
; 3018 : 	return true;

	mov	al, 1
$LN5@RetargetCi:

; 3019 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ENDP ; CvAIEscortedOperation::RetargetCivilian
_TEXT	ENDS
PUBLIC	??_7CvAIOperationFoundCity@@6B@			; CvAIOperationFoundCity::`vftable'
PUBLIC	?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationFoundCity::Init
PUBLIC	?GetOperationType@CvAIOperationFoundCity@@UBEHXZ ; CvAIOperationFoundCity::GetOperationType
PUBLIC	?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationFoundCity::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationFoundCity::ArmyInPosition
PUBLIC	?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ	; CvAIOperationFoundCity::ShouldAbort
PUBLIC	?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ ; CvAIOperationFoundCity::GetOperationName
PUBLIC	?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationFoundCity::FindBestTarget
EXTRN	??_ECvAIOperationFoundCity@@UAEPAXI@Z:PROC	; CvAIOperationFoundCity::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationFoundCity@@6B@
CONST	SEGMENT
??_7CvAIOperationFoundCity@@6B@ DD FLAT:??_ECvAIOperationFoundCity@@UAEPAXI@Z ; CvAIOperationFoundCity::`vftable'
	DD	FLAT:?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationFoundCity@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationFoundCity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationFoundCity@@QAE@XZ PROC			; CvAIOperationFoundCity::CvAIOperationFoundCity, COMDAT
; _this$ = ecx

; 3027 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIEscortedOperation@@QAE@XZ	; CvAIEscortedOperation::CvAIEscortedOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationFoundCity@@6B@

; 3028 : 	m_eCivilianType = UNITAI_SETTLE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 1

; 3029 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationFoundCity@@QAE@XZ ENDP			; CvAIOperationFoundCity::CvAIOperationFoundCity
_TEXT	ENDS
PUBLIC	??1CvAIOperationFoundCity@@UAE@XZ		; CvAIOperationFoundCity::~CvAIOperationFoundCity
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationFoundCity@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationFoundCity@@UAEPAXI@Z PROC		; CvAIOperationFoundCity::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationFoundCity@@UAE@XZ	; CvAIOperationFoundCity::~CvAIOperationFoundCity
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationFoundCity@@UAEPAXI@Z ENDP		; CvAIOperationFoundCity::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationFoundCity@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationFoundCity@@UAE@XZ PROC			; CvAIOperationFoundCity::~CvAIOperationFoundCity, COMDAT
; _this$ = ecx

; 3033 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationFoundCity@@6B@

; 3034 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEscortedOperation@@UAE@XZ	; CvAIEscortedOperation::~CvAIEscortedOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationFoundCity@@UAE@XZ ENDP			; CvAIOperationFoundCity::~CvAIOperationFoundCity
_TEXT	ENDS
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
; Function compile flags: /Odtp
;	COMDAT ?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -460						; size = 4
$T239045 = -456						; size = 4
$T239041 = -452						; size = 4
$T239040 = -448						; size = 4
$T239036 = -444						; size = 4
$T238869 = -376						; size = 4
$T238853 = -372						; size = 4
$T239022 = -368						; size = 4
$T239021 = -364						; size = 4
$T239020 = -360						; size = 4
$T239019 = -356						; size = 4
$T239018 = -352						; size = 4
$T238718 = -292						; size = 4
$T238566 = -236						; size = 4
$T238550 = -232						; size = 4
$T238705 = -228						; size = 4
$T238704 = -224						; size = 4
$T238703 = -220						; size = 4
$T238702 = -216						; size = 4
$T238701 = -212						; size = 4
$T238534 = -208						; size = 4
$T238530 = -204						; size = 4
$T238429 = -152						; size = 4
$T238303 = -116						; size = 4
$T238287 = -112						; size = 4
$T238415 = -108						; size = 4
$T238414 = -104						; size = 4
$T238413 = -100						; size = 4
$T238412 = -96						; size = 4
$T238411 = -92						; size = 4
$T238271 = -88						; size = 4
$T238262 = -84						; size = 4
$T238255 = -80						; size = 4
$T238216 = -52						; size = 4
$T238212 = -48						; size = 4
_thisOperationSlot2$224708 = -44			; size = 12
_thisOperationSlot$224702 = -32				; size = 12
_pMusterPt$224701 = -20					; size = 4
_pArmyAI$224698 = -16					; size = 4
_pOurCivilian$ = -12					; size = 4
_pNewTarget$ = -8					; size = 4
_pTargetSite$ = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationFoundCity::Init, COMDAT
; _this$ = ecx

; 3038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 460				; 000001ccH
	mov	DWORD PTR _this$[ebp], ecx

; 3039 : 	m_iTargetArea = iDefaultArea;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iDefaultArea$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 3040 : 	CvUnit* pOurCivilian;
; 3041 : 	CvPlot* pTargetSite = NULL;

	mov	DWORD PTR _pTargetSite$[ebp], 0

; 3042 : 	CvPlot* pNewTarget = NULL;

	mov	DWORD PTR _pNewTarget$[ebp], 0

; 3043 : 
; 3044 : 	Reset();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 3045 : 	m_eMoveType = AI_OPERATION_MOVETYPE_SINGLE_HEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 3046 : 	m_iID = iID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 3047 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 3048 : 
; 3049 : 	// Find the free civilian (that triggered this operation)
; 3050 : 	pOurCivilian = FindBestCivilian();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	mov	DWORD PTR _pOurCivilian$[ebp], eax

; 3051 : 
; 3052 : 	if(pOurCivilian != NULL && iID != -1)

	cmp	DWORD PTR _pOurCivilian$[ebp], 0
	je	$LN11@Init@4
	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN11@Init@4

; 3053 : 	{
; 3054 : 		// Find a destination (not worrying about safe paths)
; 3055 : 		pTargetSite = FindBestTarget(pOurCivilian, false);

	push	0
	mov	eax, DWORD PTR _pOurCivilian$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pTargetSite$[ebp], eax

; 3056 : 
; 3057 : 		if(pTargetSite != NULL)

	cmp	DWORD PTR _pTargetSite$[ebp], 0
	je	$LN9@Init@4

; 3058 : 		{
; 3059 : 			SetTargetPlot(pTargetSite);

	mov	ecx, DWORD PTR _pTargetSite$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 3060 : 
; 3061 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 3062 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238216[ebp], eax
	mov	ecx, DWORD PTR $T238216[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$224698[ebp], eax

; 3063 : 			if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$224698[ebp], 0
	je	$LN8@Init@4

; 3064 : 			{
; 3065 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T238212[ebp], eax
	lea	ecx, DWORD PTR $T238212[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3066 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 3067 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3068 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 3069 : 
; 3070 : 				// Figure out the initial rally point - for this operation it is wherever our civilian is standing
; 3071 : 				pArmyAI->SetGoalPlot(pTargetSite);

	mov	ecx, DWORD PTR _pTargetSite$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3072 : 				CvPlot* pMusterPt = pOurCivilian->plot();

	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pMusterPt$224701[ebp], eax

; 3073 : 				SetMusterPlot(pMusterPt);

	mov	edx, DWORD PTR _pMusterPt$224701[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 3074 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	mov	eax, DWORD PTR _pMusterPt$224701[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T238255[ebp], ecx
	mov	edx, DWORD PTR $T238255[ebp]
	push	edx
	mov	eax, DWORD PTR _pMusterPt$224701[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3075 : 				SetDefaultArea(pMusterPt->getArea());

	mov	edx, DWORD PTR _pMusterPt$224701[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T238262[ebp], eax
	mov	ecx, DWORD PTR $T238262[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 3076 : 
; 3077 : 				// Add the settler to our army
; 3078 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	edx, DWORD PTR _pOurCivilian$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T238271[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T238271[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 3079 : 
; 3080 : 				// Add the escort as a unit we need to build
; 3081 : 				m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T238429[ebp], edx
	mov	eax, DWORD PTR $T238429[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238287[ebp], ecx
	mov	edx, DWORD PTR $T238287[ebp]
	mov	DWORD PTR $T238412[ebp], edx
	mov	eax, DWORD PTR $T238412[ebp]
	mov	DWORD PTR $T238411[ebp], eax
	mov	ecx, DWORD PTR $T238429[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238303[ebp], edx
	mov	eax, DWORD PTR $T238303[ebp]
	mov	DWORD PTR $T238414[ebp], eax
	mov	ecx, DWORD PTR $T238414[ebp]
	mov	DWORD PTR $T238413[ebp], ecx
	mov	edx, DWORD PTR $T238411[ebp]
	push	edx
	mov	eax, DWORD PTR $T238413[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238415[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238429[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 3082 : 				OperationSlot thisOperationSlot;

	mov	DWORD PTR _thisOperationSlot$224702[ebp], -1
	mov	DWORD PTR _thisOperationSlot$224702[ebp+4], -1
	mov	DWORD PTR _thisOperationSlot$224702[ebp+8], -1

; 3083 : 				thisOperationSlot.m_iOperationID = m_iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _thisOperationSlot$224702[ebp], eax

; 3084 : 				thisOperationSlot.m_iArmyID = pArmyAI->GetID();

	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR _thisOperationSlot$224702[ebp+4], eax

; 3085 : 				thisOperationSlot.m_iSlotID = 1;

	mov	DWORD PTR _thisOperationSlot$224702[ebp+8], 1

; 3086 : 				m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot);

	lea	ecx, DWORD PTR _thisOperationSlot$224702[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 3087 : 
; 3088 : 				// try to get the escort from existing units that are waiting around
; 3089 : 				GrabUnitsFromTheReserves(pMusterPt, pTargetSite);

	mov	edx, DWORD PTR _pTargetSite$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMusterPt$224701[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax

; 3090 : 				if(pArmyAI->GetNumSlotsFilled() > 1)

	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jle	SHORT $LN7@Init@4

; 3091 : 				{
; 3092 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3093 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 2

; 3094 : 				}
; 3095 : 				else

	jmp	$LN6@Init@4
$LN7@Init@4:

; 3096 : 				{
; 3097 : 					// There was no escort immediately available.  Let's look for a "safe" city site instead
; 3098 : 
; 3099 : 					if (eOwner == -1 || GET_PLAYER(eOwner).getNumCities() > 1 || GET_PLAYER(eOwner).GetDiplomacyAI()->GetBoldness() > 5) // unless we'd rather play it safe

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN4@Init@4
	mov	edx, DWORD PTR _eOwner$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238530[ebp], edx
	mov	ecx, DWORD PTR $T238530[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jg	SHORT $LN4@Init@4
	mov	eax, DWORD PTR _eOwner$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238534[ebp], eax
	mov	ecx, DWORD PTR $T238534[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	cmp	eax, 5
	jle	SHORT $LN5@Init@4
$LN4@Init@4:

; 3100 : 					{
; 3101 : 						pNewTarget = FindBestTarget(pOurCivilian, true);

	push	1
	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	mov	DWORD PTR _pNewTarget$[ebp], eax
$LN5@Init@4:

; 3102 : 					}
; 3103 : 
; 3104 : 					// If no better target, we'll wait it out for an escort
; 3105 : 					if(pNewTarget == NULL)

	cmp	DWORD PTR _pNewTarget$[ebp], 0
	jne	$LN3@Init@4

; 3106 : 					{
; 3107 : 						// Need to add it back in to list of what to build (was cleared before since marked optional)
; 3108 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T238718[ebp], eax
	mov	ecx, DWORD PTR $T238718[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238550[ebp], edx
	mov	eax, DWORD PTR $T238550[ebp]
	mov	DWORD PTR $T238702[ebp], eax
	mov	ecx, DWORD PTR $T238702[ebp]
	mov	DWORD PTR $T238701[ebp], ecx
	mov	edx, DWORD PTR $T238718[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238566[ebp], eax
	mov	ecx, DWORD PTR $T238566[ebp]
	mov	DWORD PTR $T238704[ebp], ecx
	mov	edx, DWORD PTR $T238704[ebp]
	mov	DWORD PTR $T238703[ebp], edx
	mov	eax, DWORD PTR $T238701[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238703[ebp]
	push	ecx
	lea	edx, DWORD PTR $T238705[ebp]
	push	edx
	mov	ecx, DWORD PTR $T238718[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 3109 : 						OperationSlot thisOperationSlot2;

	mov	DWORD PTR _thisOperationSlot2$224708[ebp], -1
	mov	DWORD PTR _thisOperationSlot2$224708[ebp+4], -1
	mov	DWORD PTR _thisOperationSlot2$224708[ebp+8], -1

; 3110 : 						thisOperationSlot2.m_iOperationID = m_iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR _thisOperationSlot2$224708[ebp], ecx

; 3111 : 						thisOperationSlot2.m_iArmyID = pArmyAI->GetID();

	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR _thisOperationSlot2$224708[ebp+4], eax

; 3112 : 						thisOperationSlot2.m_iSlotID = 1;

	mov	DWORD PTR _thisOperationSlot2$224708[ebp+8], 1

; 3113 : 						m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot2);

	lea	edx, DWORD PTR _thisOperationSlot2$224708[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 3114 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1

; 3115 : 					}
; 3116 : 
; 3117 : 					// Send the settler by himself to this safe location
; 3118 : 					else

	jmp	$LN6@Init@4
$LN3@Init@4:

; 3119 : 					{
; 3120 : 						m_bEscorted = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+112], 0

; 3121 : 
; 3122 : 						// Clear the list of units we need
; 3123 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T239036[ebp], edx
	mov	eax, DWORD PTR $T239036[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238853[ebp], ecx
	mov	edx, DWORD PTR $T238853[ebp]
	mov	DWORD PTR $T239019[ebp], edx
	mov	eax, DWORD PTR $T239019[ebp]
	mov	DWORD PTR $T239018[ebp], eax
	mov	ecx, DWORD PTR $T239036[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238869[ebp], edx
	mov	eax, DWORD PTR $T238869[ebp]
	mov	DWORD PTR $T239021[ebp], eax
	mov	ecx, DWORD PTR $T239021[ebp]
	mov	DWORD PTR $T239020[ebp], ecx
	mov	edx, DWORD PTR $T239018[ebp]
	push	edx
	mov	eax, DWORD PTR $T239020[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239022[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239036[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 3124 : 
; 3125 : 						// Change the muster point
; 3126 : 						pArmyAI->SetGoalPlot(pNewTarget);

	mov	edx, DWORD PTR _pNewTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3127 : 						SetMusterPlot(pOurCivilian->plot());

	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 3128 : 						pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T239040[ebp], eax
	mov	eax, DWORD PTR $T239040[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239041[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T239045[ebp], eax
	mov	edx, DWORD PTR $T239041[ebp]
	push	edx
	mov	eax, DWORD PTR $T239045[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3129 : 
; 3130 : 						// Send the settler directly to the target
; 3131 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pArmyAI$224698[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3132 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 3
$LN6@Init@4:

; 3133 : 					}
; 3134 : 				}
; 3135 : 				LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN8@Init@4:

; 3136 : 			}
; 3137 : 		}
; 3138 : 
; 3139 : 		else

	jmp	SHORT $LN11@Init@4
$LN9@Init@4:

; 3140 : 		{
; 3141 : 			// Lost our target, abort
; 3142 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 3143 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 3
$LN11@Init@4:

; 3144 : 		}
; 3145 : 	}
; 3146 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationFoundCity::Init
_TEXT	ENDS
PUBLIC	??_C@_0EA@ICOKGFKM@At?5target?5but?5can?5no?5longer?5sett@ ; `string'
PUBLIC	??_C@_0CL@PNICIAMM@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?0?5@ ; `string'
PUBLIC	??_C@_0EE@FOABIEGA@Now?5at?5target?5but?5can?5no?5longer?5@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getTotalFoundValue@CvArea@@QBEHXZ:PROC		; CvArea::getTotalFoundValue
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z:PROC ; CvUnit::PushMission
EXTRN	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FOUND
EXTRN	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ:PROC ; CvGame::GetSettlerSiteEvaluator
EXTRN	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canFound
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::IsAdjacentOwnedByOtherTeam
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
;	COMDAT ??_C@_0EA@ICOKGFKM@At?5target?5but?5can?5no?5longer?5sett@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0EA@ICOKGFKM@At?5target?5but?5can?5no?5longer?5sett@ DB 'At target '
	DB	'but can no longer settle here. Target was (X=%d Y=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PNICIAMM@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?0?5@
CONST	SEGMENT
??_C@_0CL@PNICIAMM@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?0?5@ DB 'C'
	DB	'ity founded, At X=%d, At Y=%d, %s, %d, %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FOABIEGA@Now?5at?5target?5but?5can?5no?5longer?5@
CONST	SEGMENT
??_C@_0EE@FOABIEGA@Now?5at?5target?5but?5can?5no?5longer?5@ DB 'Now at ta'
	DB	'rget but can no longer settle here. Target was (X=%d Y=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$1
__ehfuncinfo$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv532 = -212						; size = 4
tv359 = -208						; size = 4
tv72 = -204						; size = 4
_this$ = -200						; size = 4
$T239153 = -196						; size = 4
$T239149 = -192						; size = 4
$T239145 = -188						; size = 4
$T239144 = -184						; size = 4
$T239136 = -180						; size = 4
$T239132 = -176						; size = 4
$T239128 = -172						; size = 4
$T239127 = -168						; size = 4
$T239118 = -160						; size = 4
$T239114 = -156						; size = 4
$T239110 = -152						; size = 4
$T239106 = -148						; size = 4
$T239102 = -144						; size = 4
$T239101 = -140						; size = 4
$T239097 = -136						; size = 4
$T239093 = -132						; size = 4
$T239089 = -128						; size = 4
$T239073 = -124						; size = 4
$T239069 = -120						; size = 4
$T239055 = -114						; size = 1
$T239054 = -113						; size = 1
$T239053 = -112						; size = 28
$T239052 = -84						; size = 1
$T239051 = -83						; size = 1
$T239050 = -82						; size = 1
$T239049 = -81						; size = 1
_pArea$224752 = -80					; size = 4
_pCity$224753 = -76					; size = 4
_pCityPlot$224749 = -72					; size = 4
_iPlotValue$224750 = -68				; size = 4
_pBetterTarget$224733 = -64				; size = 4
_strMsg$ = -60						; size = 28
__$ArrayPad$ = -32					; size = 4
_pSettler$ = -28					; size = 4
_bStateChanged$ = -21					; size = 1
_pEscort$ = -20						; size = 4
_iUnitID$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationFoundCity::ArmyInPosition, COMDAT
; _this$ = ecx

; 3151 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3152 : 	int iUnitID = 0;

	mov	DWORD PTR _iUnitID$[ebp], 0

; 3153 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 3154 : 	CvUnit* pSettler = 0, *pEscort = 0;

	mov	DWORD PTR _pSettler$[ebp], 0
	mov	DWORD PTR _pEscort$[ebp], 0

; 3155 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3156 : 
; 3157 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 4
	ja	$LN27@ArmyInPosi@5
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN95@ArmyInPosi@5[edx*4]
$LN26@ArmyInPosi@5:

; 3158 : 	{
; 3159 : 		// If we were gathering forces, we have to insist that any escort is in the same plot as the settler.
; 3160 : 		// If not we'll fall through and just stay in this state.
; 3161 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 3162 : 
; 3163 : 		// No escort, can just let base class handle it
; 3164 : 		if(!m_bEscorted)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+112]
	test	ecx, ecx
	jne	SHORT $LN25@ArmyInPosi@5

; 3165 : 		{
; 3166 : 			return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239049[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239049[ebp]
	jmp	$LN29@ArmyInPosi@5

; 3167 : 		}
; 3168 : 
; 3169 : 		// More complex if we are waiting for an escort
; 3170 : 		else

	jmp	$LN24@ArmyInPosi@5
$LN25@ArmyInPosi@5:

; 3171 : 		{
; 3172 : 			iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3173 : 			if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN23@ArmyInPosi@5

; 3174 : 			{
; 3175 : 				pSettler = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239069[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239069[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pSettler$[ebp], eax
$LN23@ArmyInPosi@5:

; 3176 : 			}
; 3177 : 			iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3178 : 			if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN22@ArmyInPosi@5

; 3179 : 			{
; 3180 : 				pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239073[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239073[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 3181 : 			}
; 3182 : 			else

	jmp	SHORT $LN21@ArmyInPosi@5
$LN22@ArmyInPosi@5:

; 3183 : 			{
; 3184 : 				// Escort died while gathering forces.  Abort (and return TRUE since state changed)
; 3185 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 3186 : 				m_eAbortReason = AI_ABORT_ESCORT_DIED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 9

; 3187 : 				return true;

	mov	BYTE PTR $T239050[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239050[ebp]
	jmp	$LN29@ArmyInPosi@5
$LN21@ArmyInPosi@5:

; 3188 : 			}
; 3189 : 			if(pSettler != NULL && pEscort != NULL && pSettler->plot() == pEscort->plot())

	cmp	DWORD PTR _pSettler$[ebp], 0
	je	$LN24@ArmyInPosi@5
	cmp	DWORD PTR _pEscort$[ebp], 0
	je	$LN24@ArmyInPosi@5
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	esi, eax
	jne	$LN24@ArmyInPosi@5

; 3190 : 			{
; 3191 : 				// let's see if the target still makes sense (this is modified from RetargetCivilian)
; 3192 : 				CvPlot* pBetterTarget = FindBestTarget(pSettler, true);

	push	1
	mov	edx, DWORD PTR _pSettler$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pBetterTarget$224733[ebp], eax

; 3193 : 
; 3194 : 				// No targets at all!  Abort
; 3195 : 				if(pBetterTarget == NULL)

	cmp	DWORD PTR _pBetterTarget$224733[ebp], 0
	jne	SHORT $LN19@ArmyInPosi@5

; 3196 : 				{
; 3197 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 3198 : 					m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 1

; 3199 : 					return false;

	mov	BYTE PTR $T239051[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239051[ebp]
	jmp	$LN29@ArmyInPosi@5

; 3200 : 				}
; 3201 : 				// If we have a target
; 3202 : 				else

	jmp	SHORT $LN18@ArmyInPosi@5
$LN19@ArmyInPosi@5:

; 3203 : 				{
; 3204 : 					SetTargetPlot(pBetterTarget);

	mov	eax, DWORD PTR _pBetterTarget$224733[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 3205 : 					pArmy->SetGoalPlot(pBetterTarget);

	mov	ecx, DWORD PTR _pBetterTarget$224733[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN18@ArmyInPosi@5:

; 3206 : 				}
; 3207 : 				return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239052[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239052[ebp]
	jmp	$LN29@ArmyInPosi@5
$LN24@ArmyInPosi@5:

; 3208 : 			}
; 3209 : 		}
; 3210 : 		break;

	jmp	$LN27@ArmyInPosi@5
$LN17@ArmyInPosi@5:

; 3211 : 
; 3212 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 3213 : 	case AI_OPERATION_STATE_AT_TARGET:
; 3214 : 
; 3215 : 		// Call base class version and see if it thinks we're done
; 3216 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 3217 : 
; 3218 : 		// Now get the settler
; 3219 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3220 : 		if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN16@ArmyInPosi@5

; 3221 : 		{
; 3222 : 			pSettler = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239089[ebp], edx
	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239089[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pSettler$[ebp], eax
$LN16@ArmyInPosi@5:

; 3223 : 		}
; 3224 : 
; 3225 : 		if(pSettler != NULL)

	cmp	DWORD PTR _pSettler$[ebp], 0
	je	$LN15@ArmyInPosi@5

; 3226 : 		{
; 3227 : 			if((GetTargetPlot()->getOwner() != NO_PLAYER && GetTargetPlot()->getOwner() != m_eOwner) || GetTargetPlot()->IsAdjacentOwnedByOtherTeam(pSettler->getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239093[ebp], eax
	mov	ecx, DWORD PTR $T239093[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	je	SHORT $LN12@ArmyInPosi@5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239097[ebp], eax
	mov	eax, DWORD PTR $T239097[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+72]
	jne	SHORT $LN13@ArmyInPosi@5
$LN12@ArmyInPosi@5:
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ecx, eax
	call	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
	movzx	eax, al
	test	eax, eax
	je	$LN14@ArmyInPosi@5
$LN13@ArmyInPosi@5:

; 3228 : 			{
; 3229 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@ArmyInPosi@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@ArmyInPosi@5

; 3230 : 				{
; 3231 : 					strMsg.Format("Now at target but can no longer settle here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239101[ebp], eax
	mov	eax, DWORD PTR $T239101[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239102[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239106[ebp], eax
	mov	edx, DWORD PTR $T239102[ebp]
	push	edx
	mov	eax, DWORD PTR $T239106[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0EE@FOABIEGA@Now?5at?5target?5but?5can?5no?5longer?5@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3232 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN11@ArmyInPosi@5:

; 3233 : 				}
; 3234 : 				RetargetCivilian(pSettler, pArmy);

	mov	ecx, DWORD PTR _pArmy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSettler$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 3235 : 				pSettler->finishMoves();

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3236 : 				iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3237 : 				if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN10@ArmyInPosi@5

; 3238 : 				{
; 3239 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239110[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239110[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 3240 : 					pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN10@ArmyInPosi@5:

; 3241 : 				}
; 3242 : 			}

	jmp	$LN15@ArmyInPosi@5
$LN14@ArmyInPosi@5:

; 3243 : 			// If the settler made it, we don't care about the entire army
; 3244 : 			else if(pSettler->plot() == GetTargetPlot() && pSettler->canMove() && pSettler->canFound(pSettler->plot()))

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	esi, eax
	jne	$LN8@ArmyInPosi@5
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	$LN8@ArmyInPosi@5
	push	0
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@ArmyInPosi@5

; 3245 : 			{
; 3246 : 				CvPlot* pCityPlot = pSettler->plot();

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pCityPlot$224749[ebp], eax

; 3247 : 				int iPlotValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pCityPlot, &GET_PLAYER(m_eOwner), NO_YIELD, false);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239114[ebp], edx
	mov	ecx, DWORD PTR $T239114[ebp]
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	DWORD PTR tv359[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239118[ebp], ecx
	push	0
	push	-1
	mov	edx, DWORD PTR $T239118[ebp]
	push	edx
	mov	eax, DWORD PTR _pCityPlot$224749[ebp]
	push	eax
	mov	ecx, DWORD PTR tv359[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv359[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _iPlotValue$224750[ebp], eax

; 3248 : 
; 3249 : 				pSettler->PushMission(CvTypes::getMISSION_FOUND());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	push	eax
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3250 : 
; 3251 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@ArmyInPosi@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN7@ArmyInPosi@5

; 3252 : 				{
; 3253 : 					CvArea* pArea = pCityPlot->area();

	mov	ecx, DWORD PTR _pCityPlot$224749[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pArea$224752[ebp], eax

; 3254 : 					CvCity* pCity = pCityPlot->getPlotCity();

	mov	ecx, DWORD PTR _pCityPlot$224749[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$224753[ebp], eax

; 3255 : 
; 3256 : 					if (pCity != NULL)

	cmp	DWORD PTR _pCity$224753[ebp], 0
	je	$LN7@ArmyInPosi@5

; 3257 : 					{
; 3258 : 						strMsg.Format("City founded, At X=%d, At Y=%d, %s, %d, %d", pCityPlot->getX(), pCityPlot->getY(), pCity->getName().GetCString(), iPlotValue, pArea->getTotalFoundValue());

	lea	eax, DWORD PTR $T239053[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$224753[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv532[ebp], eax
	mov	ecx, DWORD PTR tv532[ebp]
	mov	DWORD PTR $T239127[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T239127[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T239128[ebp], eax
	mov	edx, DWORD PTR _pCityPlot$224749[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239132[ebp], eax
	mov	ecx, DWORD PTR _pCityPlot$224749[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239136[ebp], edx
	mov	ecx, DWORD PTR _pArea$224752[ebp]
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	push	eax
	mov	eax, DWORD PTR _iPlotValue$224750[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239128[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239132[ebp]
	push	edx
	mov	eax, DWORD PTR $T239136[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@PNICIAMM@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?0?5@
	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T239053[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3259 : 						LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN7@ArmyInPosi@5:

; 3260 : 					}
; 3261 : 				}
; 3262 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 5
	jmp	$LN15@ArmyInPosi@5
$LN8@ArmyInPosi@5:

; 3263 : 			}
; 3264 : 
; 3265 : 			// If we're at our target but can no longer found a city, might be someone else beat us to this area
; 3266 : 			// So move back out, picking a new target
; 3267 : 			else if(pSettler->plot() == GetTargetPlot() && !pSettler->canFound(pSettler->plot()))

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	esi, eax
	jne	$LN15@ArmyInPosi@5
	push	0
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN15@ArmyInPosi@5

; 3268 : 			{
; 3269 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ArmyInPosi@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ArmyInPosi@5

; 3270 : 				{
; 3271 : 					strMsg.Format("At target but can no longer settle here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239144[ebp], eax
	mov	ecx, DWORD PTR $T239144[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T239145[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239149[ebp], eax
	mov	eax, DWORD PTR $T239145[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239149[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0EA@ICOKGFKM@At?5target?5but?5can?5no?5longer?5sett@
	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3272 : 					LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@5:

; 3273 : 				}
; 3274 : 				RetargetCivilian(pSettler, pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSettler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 3275 : 				pSettler->finishMoves();

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3276 : 				iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3277 : 				if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN15@ArmyInPosi@5

; 3278 : 				{
; 3279 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239153[ebp], edx
	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239153[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 3280 : 					pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN15@ArmyInPosi@5:

; 3281 : 				}
; 3282 : 			}
; 3283 : 		}
; 3284 : 		break;

	jmp	SHORT $LN27@ArmyInPosi@5
$LN1@ArmyInPosi@5:

; 3285 : 
; 3286 : 		// In all other cases use base class version
; 3287 : 	case AI_OPERATION_STATE_ABORTED:
; 3288 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 3289 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239054[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239054[ebp]
	jmp	SHORT $LN29@ArmyInPosi@5
$LN27@ArmyInPosi@5:

; 3290 : 		break;
; 3291 : 	};
; 3292 : 
; 3293 : 	return bStateChanged;

	mov	dl, BYTE PTR _bStateChanged$[ebp]
	mov	BYTE PTR $T239055[ebp], dl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239055[ebp]
$LN29@ArmyInPosi@5:

; 3294 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN95@ArmyInPosi@5:
	DD	$LN1@ArmyInPosi@5
	DD	$LN1@ArmyInPosi@5
	DD	$LN26@ArmyInPosi@5
	DD	$LN17@ArmyInPosi@5
	DD	$LN17@ArmyInPosi@5
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$1:
	lea	ecx, DWORD PTR $T239053[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationFoundCity::ArmyInPosition
EXTRN	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z:PROC ; CvPlayer::GetBestSettlePlot
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T239178 = -12						; size = 4
$T239174 = -8						; size = 4
_pResult$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationFoundCity::FindBestTarget, COMDAT
; _this$ = ecx

; 3298 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3299 : 	CvPlot* pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, bOnlySafePaths /*m_bEscorted*/, m_iTargetArea);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239174[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	movzx	ecx, BYTE PTR _bOnlySafePaths$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239174[ebp]
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
	mov	DWORD PTR _pResult$[ebp], eax

; 3300 : 	if (pResult == NULL)

	cmp	DWORD PTR _pResult$[ebp], 0
	jne	SHORT $LN1@FindBestTa@3

; 3301 : 	{
; 3302 : 		m_iTargetArea = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], -1

; 3303 : 		pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, bOnlySafePaths /*m_bEscorted*/, -1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239178[ebp], edx
	push	-1
	movzx	eax, BYTE PTR _bOnlySafePaths$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239178[ebp]
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
	mov	DWORD PTR _pResult$[ebp], eax
$LN1@FindBestTa@3:

; 3304 : 	}
; 3305 : 	return pResult;

	mov	eax, DWORD PTR _pResult$[ebp]

; 3306 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationFoundCity::FindBestTarget
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ$0
__ehfuncinfo$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T239317 = -128						; size = 4
$T239313 = -124						; size = 4
$T239309 = -120						; size = 4
$T239299 = -116						; size = 4
$T239295 = -112						; size = 4
$T239291 = -108						; size = 4
$T239279 = -104						; size = 4
$T239275 = -100						; size = 4
$T239271 = -96						; size = 4
$T239245 = -92						; size = 4
$T239229 = -88						; size = 4
$T239257 = -84						; size = 4
$T239256 = -80						; size = 4
$T239255 = -76						; size = 4
$T239254 = -72						; size = 4
$T239253 = -68						; size = 4
$T239213 = -64						; size = 4
$T239209 = -60						; size = 4
$T239205 = -56						; size = 4
$T239201 = -52						; size = 4
$T239189 = -48						; size = 4
$T239185 = -44						; size = 4
_pUnit$224790 = -40					; size = 8
_pSlot$224788 = -32					; size = 4
_pThisArmy$224787 = -28					; size = 4
_pSlot$224779 = -24					; size = 4
_pThisArmy$224778 = -20					; size = 4
_rtnValue$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ PROC	; CvAIOperationFoundCity::ShouldAbort, COMDAT
; _this$ = ecx

; 3311 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3312 : 	// If parent says we're done, don't even check anything else
; 3313 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	BYTE PTR _rtnValue$[ebp], al

; 3314 : 
; 3315 : 	if(!rtnValue)

	movzx	eax, BYTE PTR _rtnValue$[ebp]
	test	eax, eax
	jne	$LN11@ShouldAbor@4

; 3316 : 	{
; 3317 : 		if(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS && m_bEscorted)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], 1
	jne	$LN10@ShouldAbor@4
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+112]
	test	eax, eax
	je	$LN10@ShouldAbor@4

; 3318 : 		{
; 3319 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	xor	ecx, ecx
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T239185[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239189[ebp], ecx
	mov	edx, DWORD PTR $T239185[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR $T239189[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$224778[ebp], eax

; 3320 : 			CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(0);

	xor	ecx, ecx
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pThisArmy$224778[ebp]
	add	ecx, DWORD PTR [edx+44]
	mov	DWORD PTR _pSlot$224779[ebp], ecx

; 3321 : 
; 3322 : 			if (GetMusterPlot()->getOwner() != m_eOwner || GC.getGame().getGameTurn() - pSlot->GetTurnAtCheckpoint() > 15) // fifteen turns and still no escort even being built?

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T239201[ebp], eax
	mov	eax, DWORD PTR $T239201[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+72]
	jne	SHORT $LN8@ShouldAbor@4
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239205[ebp], eax
	mov	ecx, DWORD PTR _pSlot$224779[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239209[ebp], edx
	mov	ecx, DWORD PTR $T239205[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, DWORD PTR $T239209[ebp]
	cmp	eax, 15					; 0000000fH
	jle	$LN9@ShouldAbor@4
$LN8@ShouldAbor@4:

; 3323 : 			{
; 3324 : 				if (m_viListOfUnitsCitiesHaveCommittedToBuild.size() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR $T239213[ebp], eax
	mov	ecx, DWORD PTR $T239213[ebp]
	mov	edx, DWORD PTR $T239213[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	$LN9@ShouldAbor@4

; 3325 : 				{
; 3326 : 					// try to get the escort from existing units that are waiting around
; 3327 : 					GrabUnitsFromTheReserves(GetMusterPlot(), GetTargetPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+112]
	call	edx

; 3328 : 					if(pThisArmy->GetNumSlotsFilled() > 1)

	mov	ecx, DWORD PTR _pThisArmy$224778[ebp]
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jle	SHORT $LN6@ShouldAbor@4

; 3329 : 					{
; 3330 : 						pThisArmy->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pThisArmy$224778[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3331 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 2

; 3332 : 					}
; 3333 : 					else

	jmp	SHORT $LN9@ShouldAbor@4
$LN6@ShouldAbor@4:

; 3334 : 					{
; 3335 : 						// we are going by our lonesome
; 3336 : 						m_bEscorted = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+112], 0

; 3337 : 						// Clear the list of units we need
; 3338 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T239271[ebp], edx
	mov	eax, DWORD PTR $T239271[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T239229[ebp], ecx
	mov	edx, DWORD PTR $T239229[ebp]
	mov	DWORD PTR $T239254[ebp], edx
	mov	eax, DWORD PTR $T239254[ebp]
	mov	DWORD PTR $T239253[ebp], eax
	mov	ecx, DWORD PTR $T239271[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239245[ebp], edx
	mov	eax, DWORD PTR $T239245[ebp]
	mov	DWORD PTR $T239256[ebp], eax
	mov	ecx, DWORD PTR $T239256[ebp]
	mov	DWORD PTR $T239255[ebp], ecx
	mov	edx, DWORD PTR $T239253[ebp]
	push	edx
	mov	eax, DWORD PTR $T239255[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239257[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239271[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 3339 : 						// Send the settler directly to the target
; 3340 : 						pThisArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pThisArmy$224778[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3341 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 3
$LN9@ShouldAbor@4:

; 3342 : 					}
; 3343 : 				}
; 3344 : 			}
; 3345 : 		}

	jmp	$LN11@ShouldAbor@4
$LN10@ShouldAbor@4:

; 3346 : 		else if (m_eCurrentState == AI_OPERATION_STATE_GATHERING_FORCES && m_bEscorted)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 2
	jne	$LN11@ShouldAbor@4
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+112]
	test	edx, edx
	je	$LN11@ShouldAbor@4

; 3347 : 		{
; 3348 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239275[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239279[ebp], eax
	mov	ecx, DWORD PTR $T239275[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T239279[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$224787[ebp], eax

; 3349 : 			CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(0);

	xor	eax, eax
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _pThisArmy$224787[ebp]
	add	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR _pSlot$224788[ebp], eax

; 3350 : 			if (pSlot->GetUnitID() != NO_UNIT)

	mov	edx, DWORD PTR _pSlot$224788[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239291[ebp], eax
	cmp	DWORD PTR $T239291[ebp], -1
	je	$LN11@ShouldAbor@4

; 3351 : 			{
; 3352 : 				UnitHandle pUnit = GET_PLAYER(m_eOwner).getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR _pSlot$224788[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239295[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239299[ebp], ecx
	mov	edx, DWORD PTR $T239295[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239299[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR $T239309[ebp], eax
	mov	eax, DWORD PTR $T239309[ebp]
	mov	DWORD PTR _pUnit$224790[ebp], eax
	mov	BYTE PTR _pUnit$224790[ebp+4], 0
	cmp	DWORD PTR _pUnit$224790[ebp], 0
	je	SHORT $LN60@ShouldAbor@4
	mov	ecx, DWORD PTR _pUnit$224790[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN60@ShouldAbor@4:
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3353 : 				if (pUnit->plot()->isWater())

	mov	ecx, DWORD PTR _pUnit$224790[ebp]
	mov	DWORD PTR $T239313[ebp], ecx
	mov	ecx, DWORD PTR $T239313[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T239317[ebp], eax
	mov	edx, DWORD PTR $T239317[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@ShouldAbor@4

; 3354 : 				{
; 3355 : 					// we are going by our lonesome
; 3356 : 					m_bEscorted = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+112], 0

; 3357 : 					pThisArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pThisArmy$224787[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3358 : 					m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 3
$LN1@ShouldAbor@4:

; 3359 : 				}
; 3360 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$224790[ebp], 0
	je	SHORT $LN11@ShouldAbor@4
	mov	ecx, DWORD PTR _pUnit$224790[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@ShouldAbor@4:

; 3361 : 		}
; 3362 : 	}
; 3363 : 
; 3364 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[ebp]

; 3365 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ$0:
	lea	ecx, DWORD PTR _pUnit$224790[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ ENDP	; CvAIOperationFoundCity::ShouldAbort
PUBLIC	??_7CvAIOperationQuickColonize@@6B@		; CvAIOperationQuickColonize::`vftable'
PUBLIC	?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationQuickColonize::Init
PUBLIC	?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ ; CvAIOperationQuickColonize::GetOperationType
PUBLIC	?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationQuickColonize::GetFormation
PUBLIC	?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ ; CvAIOperationQuickColonize::GetOperationName
PUBLIC	?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ ; CvAIOperationQuickColonize::FindBestCivilian
PUBLIC	?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationQuickColonize::FindBestTarget
EXTRN	??_ECvAIOperationQuickColonize@@UAEPAXI@Z:PROC	; CvAIOperationQuickColonize::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationQuickColonize@@6B@
CONST	SEGMENT
??_7CvAIOperationQuickColonize@@6B@ DD FLAT:??_ECvAIOperationQuickColonize@@UAEPAXI@Z ; CvAIOperationQuickColonize::`vftable'
	DD	FLAT:?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationQuickColonize@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationQuickColonize@@QAE@XZ PROC		; CvAIOperationQuickColonize::CvAIOperationQuickColonize, COMDAT
; _this$ = ecx

; 3374 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperationFoundCity@@QAE@XZ	; CvAIOperationFoundCity::CvAIOperationFoundCity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationQuickColonize@@6B@

; 3375 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationQuickColonize@@QAE@XZ ENDP		; CvAIOperationQuickColonize::CvAIOperationQuickColonize
_TEXT	ENDS
PUBLIC	??1CvAIOperationQuickColonize@@UAE@XZ		; CvAIOperationQuickColonize::~CvAIOperationQuickColonize
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationQuickColonize@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationQuickColonize@@UAEPAXI@Z PROC		; CvAIOperationQuickColonize::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationQuickColonize@@UAE@XZ	; CvAIOperationQuickColonize::~CvAIOperationQuickColonize
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationQuickColonize@@UAEPAXI@Z ENDP		; CvAIOperationQuickColonize::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationQuickColonize@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationQuickColonize@@UAE@XZ PROC		; CvAIOperationQuickColonize::~CvAIOperationQuickColonize, COMDAT
; _this$ = ecx

; 3379 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationQuickColonize@@6B@

; 3380 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationFoundCity@@UAE@XZ	; CvAIOperationFoundCity::~CvAIOperationFoundCity
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationQuickColonize@@UAE@XZ ENDP		; CvAIOperationQuickColonize::~CvAIOperationQuickColonize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T239461 = -84						; size = 4
$T239452 = -80						; size = 4
$T239445 = -76						; size = 4
$T239347 = -24						; size = 4
$T239343 = -20						; size = 4
_pMusterPt$224818 = -16					; size = 4
_pArmyAI$224815 = -12					; size = 4
_pOurCivilian$ = -8					; size = 4
_pTargetSite$ = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationQuickColonize::Init, COMDAT
; _this$ = ecx

; 3384 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 3385 : 	CvUnit* pOurCivilian;
; 3386 : 	CvPlot* pTargetSite;
; 3387 : 
; 3388 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 3389 : 	m_eMoveType = AI_OPERATION_MOVETYPE_SINGLE_HEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 3390 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 3391 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 3392 : 	m_iTargetArea = iDefaultArea;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iDefaultArea$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 3393 : 
; 3394 : 	// Find the free civilian (that triggered this operation)
; 3395 : 	pOurCivilian = FindBestCivilian();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	mov	DWORD PTR _pOurCivilian$[ebp], eax

; 3396 : 
; 3397 : 	if(pOurCivilian != NULL && iID != -1)

	cmp	DWORD PTR _pOurCivilian$[ebp], 0
	je	$LN5@Init@5
	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN5@Init@5

; 3398 : 	{
; 3399 : 		// Find a destination (not worrying about safe paths)
; 3400 : 		pTargetSite = FindBestTarget(pOurCivilian, false);

	push	0
	mov	eax, DWORD PTR _pOurCivilian$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pTargetSite$[ebp], eax

; 3401 : 
; 3402 : 		if(pTargetSite != NULL)

	cmp	DWORD PTR _pTargetSite$[ebp], 0
	je	$LN3@Init@5

; 3403 : 		{
; 3404 : 			SetTargetPlot(pTargetSite);

	mov	ecx, DWORD PTR _pTargetSite$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 3405 : 
; 3406 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239347[ebp], eax
	mov	ecx, DWORD PTR $T239347[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$224815[ebp], eax

; 3407 : 			if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$224815[ebp], 0
	je	$LN2@Init@5

; 3408 : 			{
; 3409 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T239343[ebp], eax
	lea	ecx, DWORD PTR $T239343[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3410 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 3411 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 3412 : 
; 3413 : 				// Figure out the initial rally point - for this operation it is wherever our civilian is standing
; 3414 : 				pArmyAI->SetGoalPlot(pTargetSite);

	mov	ecx, DWORD PTR _pTargetSite$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3415 : 				CvPlot* pMusterPt = pOurCivilian->plot();

	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pMusterPt$224818[ebp], eax

; 3416 : 				SetMusterPlot(pMusterPt);

	mov	edx, DWORD PTR _pMusterPt$224818[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 3417 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	mov	eax, DWORD PTR _pMusterPt$224818[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239445[ebp], ecx
	mov	edx, DWORD PTR $T239445[ebp]
	push	edx
	mov	eax, DWORD PTR _pMusterPt$224818[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3418 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3419 : 				SetDefaultArea(pMusterPt->getArea());

	mov	edx, DWORD PTR _pMusterPt$224818[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T239452[ebp], eax
	mov	ecx, DWORD PTR $T239452[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 3420 : 
; 3421 : 				// Add the settler to our army
; 3422 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	edx, DWORD PTR _pOurCivilian$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T239461[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T239461[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$224815[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 3423 : 				m_bEscorted = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+112], 0

; 3424 : 
; 3425 : 				m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 3

; 3426 : 				LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN2@Init@5:

; 3427 : 			}
; 3428 : 		}
; 3429 : 
; 3430 : 		else

	jmp	SHORT $LN5@Init@5
$LN3@Init@5:

; 3431 : 		{
; 3432 : 			// Lost our target, abort
; 3433 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 3434 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 3
$LN5@Init@5:

; 3435 : 		}
; 3436 : 	}
; 3437 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationQuickColonize::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T239471 = -16						; size = 4
$T239467 = -12						; size = 4
_pLoopUnit$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ PROC ; CvAIOperationQuickColonize::FindBestCivilian, COMDAT
; _this$ = ecx

; 3441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3442 : 	int iUnitLoop;
; 3443 : 	CvUnit* pLoopUnit;
; 3444 : 
; 3445 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239467[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239467[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN6@FindBestCi@2
$LN5@FindBestCi@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239471[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239471[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN6@FindBestCi@2:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN4@FindBestCi@2

; 3446 : 	{
; 3447 : 		if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN3@FindBestCi@2

; 3448 : 		{
; 3449 : 			if(pLoopUnit->AI_getUnitAIType() == m_eCivilianType)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+116]
	jne	SHORT $LN3@FindBestCi@2

; 3450 : 			{
; 3451 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN3@FindBestCi@2

; 3452 : 				{
; 3453 : 					return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN7@FindBestCi@2
$LN3@FindBestCi@2:

; 3454 : 				}
; 3455 : 			}
; 3456 : 		}
; 3457 : 	}

	jmp	SHORT $LN5@FindBestCi@2
$LN4@FindBestCi@2:

; 3458 : 	return NULL;

	xor	eax, eax
$LN7@FindBestCi@2:

; 3459 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ ENDP ; CvAIOperationQuickColonize::FindBestCivilian
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T239481 = -12						; size = 4
$T239477 = -8						; size = 4
_pResult$ = -4						; size = 4
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 1
?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationQuickColonize::FindBestTarget, COMDAT
; _this$ = ecx

; 3463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3464 : 	CvPlot* pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, false, m_iTargetArea);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239477[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239477[ebp]
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
	mov	DWORD PTR _pResult$[ebp], eax

; 3465 : 	if (pResult == NULL)

	cmp	DWORD PTR _pResult$[ebp], 0
	jne	SHORT $LN1@FindBestTa@4

; 3466 : 	{
; 3467 : 		m_iTargetArea = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], -1

; 3468 : 		pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, false, -1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239481[ebp], ecx
	push	-1
	push	0
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239481[ebp]
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
	mov	DWORD PTR _pResult$[ebp], eax
$LN1@FindBestTa@4:

; 3469 : 	}
; 3470 : 	return pResult;

	mov	eax, DWORD PTR _pResult$[ebp]

; 3471 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationQuickColonize::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationMerchantDelegation@@6B@	; CvAIOperationMerchantDelegation::`vftable'
PUBLIC	?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ ; CvAIOperationMerchantDelegation::GetOperationType
PUBLIC	?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationMerchantDelegation::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationMerchantDelegation::ArmyInPosition
PUBLIC	?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ ; CvAIOperationMerchantDelegation::GetOperationName
PUBLIC	?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationMerchantDelegation::FindBestTarget
EXTRN	??_ECvAIOperationMerchantDelegation@@UAEPAXI@Z:PROC ; CvAIOperationMerchantDelegation::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationMerchantDelegation@@6B@
CONST	SEGMENT
??_7CvAIOperationMerchantDelegation@@6B@ DD FLAT:??_ECvAIOperationMerchantDelegation@@UAEPAXI@Z ; CvAIOperationMerchantDelegation::`vftable'
	DD	FLAT:?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationMerchantDelegation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationMerchantDelegation@@QAE@XZ PROC		; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation, COMDAT
; _this$ = ecx

; 3479 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIEscortedOperation@@QAE@XZ	; CvAIEscortedOperation::CvAIEscortedOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationMerchantDelegation@@6B@

; 3480 : 	m_eCivilianType = UNITAI_MERCHANT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 14			; 0000000eH

; 3481 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationMerchantDelegation@@QAE@XZ ENDP		; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation
_TEXT	ENDS
PUBLIC	??1CvAIOperationMerchantDelegation@@UAE@XZ	; CvAIOperationMerchantDelegation::~CvAIOperationMerchantDelegation
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationMerchantDelegation@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationMerchantDelegation@@UAEPAXI@Z PROC	; CvAIOperationMerchantDelegation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationMerchantDelegation@@UAE@XZ ; CvAIOperationMerchantDelegation::~CvAIOperationMerchantDelegation
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@13
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationMerchantDelegation@@UAEPAXI@Z ENDP	; CvAIOperationMerchantDelegation::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationMerchantDelegation@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationMerchantDelegation@@UAE@XZ PROC		; CvAIOperationMerchantDelegation::~CvAIOperationMerchantDelegation, COMDAT
; _this$ = ecx

; 3485 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationMerchantDelegation@@6B@

; 3486 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEscortedOperation@@UAE@XZ	; CvAIEscortedOperation::~CvAIEscortedOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationMerchantDelegation@@UAE@XZ ENDP		; CvAIOperationMerchantDelegation::~CvAIOperationMerchantDelegation
_TEXT	ENDS
PUBLIC	??_C@_0DP@HPGBNOI@At?5target?5but?5can?5no?5longer?5trad@ ; `string'
PUBLIC	??_C@_0DJ@BILFGJIE@Great?5Merchant?5finishing?5trade?5m@ ; `string'
PUBLIC	??_C@_0DD@EKLKMGLE@Great?5Merchant?5buying?5city?9state@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_TRADE
EXTRN	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_BUY_CITY_STATE
EXTRN	?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ:PROC ; CvPlayerAI::GreatMerchantWantsCash
EXTRN	?canBuyCityState@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canBuyCityState
EXTRN	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canTrade
;	COMDAT ??_C@_0DP@HPGBNOI@At?5target?5but?5can?5no?5longer?5trad@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DP@HPGBNOI@At?5target?5but?5can?5no?5longer?5trad@ DB 'At target b'
	DB	'ut can no longer trade here. Target was (X=%d Y=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BILFGJIE@Great?5Merchant?5finishing?5trade?5m@
CONST	SEGMENT
??_C@_0DJ@BILFGJIE@Great?5Merchant?5finishing?5trade?5m@ DB 'Great Mercha'
	DB	'nt finishing trade mission, At X=%d, At Y=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EKLKMGLE@Great?5Merchant?5buying?5city?9state@
CONST	SEGMENT
??_C@_0DD@EKLKMGLE@Great?5Merchant?5buying?5city?9state@ DB 'Great Mercha'
	DB	'nt buying city-state, At X=%d, At Y=%d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv72 = -136						; size = 4
_this$ = -132						; size = 4
$T239566 = -128						; size = 4
$T239562 = -124						; size = 4
$T239558 = -120						; size = 4
$T239557 = -116						; size = 4
$T239553 = -112						; size = 4
$T239549 = -108						; size = 4
$T239548 = -104						; size = 4
$T239544 = -100						; size = 4
$T239540 = -96						; size = 4
$T239539 = -92						; size = 4
$T239535 = -88						; size = 4
$T239531 = -84						; size = 4
$T239515 = -80						; size = 4
$T239511 = -76						; size = 4
$T239498 = -70						; size = 1
$T239497 = -69						; size = 1
$T239496 = -68						; size = 1
$T239495 = -67						; size = 1
$T239494 = -66						; size = 1
$T239493 = -65						; size = 1
_pBetterTarget$224870 = -64				; size = 4
_strMsg$ = -60						; size = 28
__$ArrayPad$ = -32					; size = 4
_pMerchant$ = -28					; size = 4
_bStateChanged$ = -21					; size = 1
_pEscort$ = -20						; size = 4
_iUnitID$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationMerchantDelegation::ArmyInPosition, COMDAT
; _this$ = ecx

; 3490 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3491 : 	int iUnitID = 0;

	mov	DWORD PTR _iUnitID$[ebp], 0

; 3492 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 3493 : 	CvUnit* pMerchant = 0, *pEscort = 0;

	mov	DWORD PTR _pMerchant$[ebp], 0
	mov	DWORD PTR _pEscort$[ebp], 0

; 3494 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3495 : 
; 3496 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 4
	ja	$LN24@ArmyInPosi@6
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN73@ArmyInPosi@6[edx*4]
$LN23@ArmyInPosi@6:

; 3497 : 	{
; 3498 : 		// If we were gathering forces, we have to insist that any escort is in the same plot as the merchant.
; 3499 : 		// If not we'll fall through and just stay in this state.
; 3500 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 3501 : 
; 3502 : 		// No escort, can just let base class handle it
; 3503 : 		if(!m_bEscorted)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+112]
	test	ecx, ecx
	jne	SHORT $LN22@ArmyInPosi@6

; 3504 : 		{
; 3505 : 			return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239493[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239493[ebp]
	jmp	$LN26@ArmyInPosi@6

; 3506 : 		}
; 3507 : 
; 3508 : 		// More complex if we are waiting for an escort
; 3509 : 		else

	jmp	$LN21@ArmyInPosi@6
$LN22@ArmyInPosi@6:

; 3510 : 		{
; 3511 : 			iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3512 : 			if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN20@ArmyInPosi@6

; 3513 : 			{
; 3514 : 				pMerchant = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239511[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239511[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pMerchant$[ebp], eax
$LN20@ArmyInPosi@6:

; 3515 : 			}
; 3516 : 			iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3517 : 			if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN19@ArmyInPosi@6

; 3518 : 			{
; 3519 : 				pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239515[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239515[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 3520 : 			}
; 3521 : 			else

	jmp	SHORT $LN18@ArmyInPosi@6
$LN19@ArmyInPosi@6:

; 3522 : 			{
; 3523 : 				// Escort died while gathering forces.  Abort (and return TRUE since state changed)
; 3524 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 3525 : 				m_eAbortReason = AI_ABORT_ESCORT_DIED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 9

; 3526 : 				return true;

	mov	BYTE PTR $T239494[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239494[ebp]
	jmp	$LN26@ArmyInPosi@6
$LN18@ArmyInPosi@6:

; 3527 : 			}
; 3528 : 			if(pMerchant != NULL && pEscort != NULL && pMerchant->plot() == pEscort->plot())

	cmp	DWORD PTR _pMerchant$[ebp], 0
	je	$LN21@ArmyInPosi@6
	cmp	DWORD PTR _pEscort$[ebp], 0
	je	$LN21@ArmyInPosi@6
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	esi, eax
	jne	$LN21@ArmyInPosi@6

; 3529 : 			{
; 3530 : 				// let's see if the target still makes sense (this is modified from RetargetCivilian)
; 3531 : 				CvPlot* pBetterTarget = FindBestTarget(pMerchant, true);

	push	1
	mov	edx, DWORD PTR _pMerchant$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pBetterTarget$224870[ebp], eax

; 3532 : 
; 3533 : 				// No targets at all!  Abort
; 3534 : 				if(pBetterTarget == NULL)

	cmp	DWORD PTR _pBetterTarget$224870[ebp], 0
	jne	SHORT $LN16@ArmyInPosi@6

; 3535 : 				{
; 3536 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 3537 : 					m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 1

; 3538 : 					return false;

	mov	BYTE PTR $T239495[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239495[ebp]
	jmp	$LN26@ArmyInPosi@6

; 3539 : 				}
; 3540 : 				// If we have a target
; 3541 : 				else

	jmp	SHORT $LN15@ArmyInPosi@6
$LN16@ArmyInPosi@6:

; 3542 : 				{
; 3543 : 					SetTargetPlot(pBetterTarget);

	mov	eax, DWORD PTR _pBetterTarget$224870[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 3544 : 					pArmy->SetGoalPlot(pBetterTarget);

	mov	ecx, DWORD PTR _pBetterTarget$224870[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN15@ArmyInPosi@6:

; 3545 : 				}
; 3546 : 				return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239496[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239496[ebp]
	jmp	$LN26@ArmyInPosi@6
$LN21@ArmyInPosi@6:

; 3547 : 			}
; 3548 : 		}
; 3549 : 		break;

	jmp	$LN24@ArmyInPosi@6
$LN14@ArmyInPosi@6:

; 3550 : 
; 3551 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 3552 : 	case AI_OPERATION_STATE_AT_TARGET:
; 3553 : 
; 3554 : 		// Call base class version and see if it thinks we're done
; 3555 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 3556 : 
; 3557 : 		// Now get the merchant
; 3558 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3559 : 		if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN13@ArmyInPosi@6

; 3560 : 		{
; 3561 : 			pMerchant = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239531[ebp], edx
	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239531[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pMerchant$[ebp], eax
$LN13@ArmyInPosi@6:

; 3562 : 		}
; 3563 : 
; 3564 : 		if(pMerchant != NULL)

	cmp	DWORD PTR _pMerchant$[ebp], 0
	je	$LN12@ArmyInPosi@6

; 3565 : 		{
; 3566 : 			// If the merchant made it, we don't care about the entire army
; 3567 : 			if(pMerchant->plot() == GetTargetPlot() && pMerchant->canMove() && pMerchant->canTrade(pMerchant->plot()))

	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	esi, eax
	jne	$LN11@ArmyInPosi@6
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	ecx, al
	test	ecx, ecx
	je	$LN11@ArmyInPosi@6
	push	0
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canTrade
	movzx	edx, al
	test	edx, edx
	je	$LN11@ArmyInPosi@6

; 3568 : 			{
; 3569 : 				if (pMerchant->canBuyCityState(pMerchant->plot()) && !GET_PLAYER(m_eOwner).GreatMerchantWantsCash())

	push	0
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?canBuyCityState@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBuyCityState
	movzx	eax, al
	test	eax, eax
	je	$LN10@ArmyInPosi@6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239535[ebp], edx
	mov	ecx, DWORD PTR $T239535[ebp]
	call	?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ ; CvPlayerAI::GreatMerchantWantsCash
	movzx	eax, al
	test	eax, eax
	jne	$LN10@ArmyInPosi@6

; 3570 : 				{
; 3571 : 					pMerchant->PushMission(CvTypes::getMISSION_BUY_CITY_STATE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUY_CITY_STATE
	push	eax
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3572 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@ArmyInPosi@6
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@ArmyInPosi@6

; 3573 : 					{
; 3574 : 						strMsg.Format("Great Merchant buying city-state, At X=%d, At Y=%d", pMerchant->plot()->getX(), pMerchant->plot()->getY());

	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T239539[ebp], eax
	mov	eax, DWORD PTR $T239539[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239540[ebp], ecx
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T239544[ebp], eax
	mov	edx, DWORD PTR $T239540[ebp]
	push	edx
	mov	eax, DWORD PTR $T239544[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DD@EKLKMGLE@Great?5Merchant?5buying?5city?9state@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3575 : 						LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN9@ArmyInPosi@6:

; 3576 : 					}
; 3577 : 				}
; 3578 : 				else

	jmp	$LN8@ArmyInPosi@6
$LN10@ArmyInPosi@6:

; 3579 : 				{
; 3580 : 					pMerchant->PushMission(CvTypes::getMISSION_TRADE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_TRADE
	push	eax
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3581 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@ArmyInPosi@6
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@ArmyInPosi@6

; 3582 : 					{
; 3583 : 						strMsg.Format("Great Merchant finishing trade mission, At X=%d, At Y=%d", pMerchant->plot()->getX(), pMerchant->plot()->getY());

	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T239548[ebp], eax
	mov	eax, DWORD PTR $T239548[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239549[ebp], ecx
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T239553[ebp], eax
	mov	edx, DWORD PTR $T239549[ebp]
	push	edx
	mov	eax, DWORD PTR $T239553[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DJ@BILFGJIE@Great?5Merchant?5finishing?5trade?5m@
	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3584 : 						LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN8@ArmyInPosi@6:

; 3585 : 					}
; 3586 : 				}
; 3587 : 
; 3588 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 5
	jmp	$LN12@ArmyInPosi@6
$LN11@ArmyInPosi@6:

; 3589 : 			}
; 3590 : 
; 3591 : 			// Does it look like we should be done?
; 3592 : 			else if(pMerchant->plot() == GetTargetPlot())

	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	esi, eax
	jne	$LN12@ArmyInPosi@6

; 3593 : 			{
; 3594 : 				// We're at our target but can no longer trade, city state was probably conquered
; 3595 : 				if(!pMerchant->canTrade(pMerchant->plot()))

	push	0
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canTrade
	movzx	edx, al
	test	edx, edx
	jne	$LN12@ArmyInPosi@6

; 3596 : 				{
; 3597 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ArmyInPosi@6
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ArmyInPosi@6

; 3598 : 					{
; 3599 : 						strMsg.Format("At target but can no longer trade here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239557[ebp], eax
	mov	edx, DWORD PTR $T239557[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239558[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239562[ebp], eax
	mov	ecx, DWORD PTR $T239558[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239562[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DP@HPGBNOI@At?5target?5but?5can?5no?5longer?5trad@
	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3600 : 						LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@6:

; 3601 : 					}
; 3602 : 					RetargetCivilian(pMerchant, pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMerchant$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 3603 : 					pMerchant->finishMoves();

	mov	ecx, DWORD PTR _pMerchant$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3604 : 					iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3605 : 					if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN12@ArmyInPosi@6

; 3606 : 					{
; 3607 : 						pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239566[ebp], eax
	mov	ecx, DWORD PTR _iUnitID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239566[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 3608 : 						pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN12@ArmyInPosi@6:

; 3609 : 					}
; 3610 : 				}
; 3611 : 			}
; 3612 : 		}
; 3613 : 		break;

	jmp	SHORT $LN24@ArmyInPosi@6
$LN1@ArmyInPosi@6:

; 3614 : 
; 3615 : 		// In all other cases use base class version
; 3616 : 	case AI_OPERATION_STATE_ABORTED:
; 3617 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 3618 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239497[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239497[ebp]
	jmp	SHORT $LN26@ArmyInPosi@6
$LN24@ArmyInPosi@6:

; 3619 : 		break;
; 3620 : 	};
; 3621 : 
; 3622 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
	mov	BYTE PTR $T239498[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239498[ebp]
$LN26@ArmyInPosi@6:

; 3623 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN73@ArmyInPosi@6:
	DD	$LN1@ArmyInPosi@6
	DD	$LN1@ArmyInPosi@6
	DD	$LN23@ArmyInPosi@6
	DD	$LN14@ArmyInPosi@6
	DD	$LN14@ArmyInPosi@6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationMerchantDelegation::ArmyInPosition
EXTRN	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:PROC ; CvPlayerAI::FindBestMerchantTargetPlot
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T239596 = -8						; size = 4
$T239592 = -4						; size = 4
_pUnit$ = 8						; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationMerchantDelegation::FindBestTarget, COMDAT
; _this$ = ecx

; 3627 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3628 : 	CvAssertMsg(pUnit, "pUnit cannot be null");
; 3629 : 	if(!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN6@FindBestTa@5

; 3630 : 	{
; 3631 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN2@FindBestTa@5

; 3632 : 	}
; 3633 : 
; 3634 : 	return GET_PLAYER(pUnit->getOwner()).FindBestMerchantTargetPlot(pUnit, !bOnlySafePaths /*m_bEscorted*/);

$LN6@FindBestTa@5:
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T239592[ebp], ecx
	mov	edx, DWORD PTR $T239592[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239596[ebp], edx
	movzx	eax, BYTE PTR _bOnlySafePaths$[ebp]
	test	eax, eax
	sete	cl
	movzx	edx, cl
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239596[ebp]
	call	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMerchantTargetPlot
$LN2@FindBestTa@5:

; 3635 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationMerchantDelegation::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationConcertTour@@6B@		; CvAIOperationConcertTour::`vftable'
PUBLIC	?GetOperationType@CvAIOperationConcertTour@@UBEHXZ ; CvAIOperationConcertTour::GetOperationType
PUBLIC	?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationConcertTour::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationConcertTour::ArmyInPosition
PUBLIC	?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ ; CvAIOperationConcertTour::GetOperationName
PUBLIC	?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationConcertTour::FindBestTarget
EXTRN	??_ECvAIOperationConcertTour@@UAEPAXI@Z:PROC	; CvAIOperationConcertTour::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationConcertTour@@6B@
CONST	SEGMENT
??_7CvAIOperationConcertTour@@6B@ DD FLAT:??_ECvAIOperationConcertTour@@UAEPAXI@Z ; CvAIOperationConcertTour::`vftable'
	DD	FLAT:?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationConcertTour@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationConcertTour@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationConcertTour@@QAE@XZ PROC		; CvAIOperationConcertTour::CvAIOperationConcertTour, COMDAT
; _this$ = ecx

; 3643 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIEscortedOperation@@QAE@XZ	; CvAIEscortedOperation::CvAIEscortedOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationConcertTour@@6B@

; 3644 : 	m_eCivilianType = UNITAI_MUSICIAN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 41			; 00000029H

; 3645 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationConcertTour@@QAE@XZ ENDP		; CvAIOperationConcertTour::CvAIOperationConcertTour
_TEXT	ENDS
PUBLIC	??1CvAIOperationConcertTour@@UAE@XZ		; CvAIOperationConcertTour::~CvAIOperationConcertTour
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationConcertTour@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationConcertTour@@UAEPAXI@Z PROC		; CvAIOperationConcertTour::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationConcertTour@@UAE@XZ	; CvAIOperationConcertTour::~CvAIOperationConcertTour
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@14
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@14:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationConcertTour@@UAEPAXI@Z ENDP		; CvAIOperationConcertTour::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationConcertTour@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationConcertTour@@UAE@XZ PROC		; CvAIOperationConcertTour::~CvAIOperationConcertTour, COMDAT
; _this$ = ecx

; 3649 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationConcertTour@@6B@

; 3650 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEscortedOperation@@UAE@XZ	; CvAIEscortedOperation::~CvAIEscortedOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationConcertTour@@UAE@XZ ENDP		; CvAIOperationConcertTour::~CvAIOperationConcertTour
_TEXT	ENDS
PUBLIC	??_C@_0EG@DKDFHLBF@At?5target?5but?5can?5no?5longer?5hold@ ; `string'
PUBLIC	??_C@_0DJ@LDIIAOIN@Great?5Musician?5performing?5concer@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ONE_SHOT_TOURISM
EXTRN	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canBlastTourism
;	COMDAT ??_C@_0EG@DKDFHLBF@At?5target?5but?5can?5no?5longer?5hold@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0EG@DKDFHLBF@At?5target?5but?5can?5no?5longer?5hold@ DB 'At target '
	DB	'but can no longer hold concert here. Target was (X=%d Y=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LDIIAOIN@Great?5Musician?5performing?5concer@
CONST	SEGMENT
??_C@_0DJ@LDIIAOIN@Great?5Musician?5performing?5concer@ DB 'Great Musicia'
	DB	'n performing concert tour, At X=%d, At Y=%d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv72 = -120						; size = 4
_this$ = -116						; size = 4
$T239668 = -112						; size = 4
$T239664 = -108						; size = 4
$T239660 = -104						; size = 4
$T239659 = -100						; size = 4
$T239655 = -96						; size = 4
$T239651 = -92						; size = 4
$T239650 = -88						; size = 4
$T239646 = -84						; size = 4
$T239630 = -80						; size = 4
$T239626 = -76						; size = 4
$T239613 = -70						; size = 1
$T239612 = -69						; size = 1
$T239611 = -68						; size = 1
$T239610 = -67						; size = 1
$T239609 = -66						; size = 1
$T239608 = -65						; size = 1
_pBetterTarget$224932 = -64				; size = 4
_strMsg$ = -60						; size = 28
__$ArrayPad$ = -32					; size = 4
_pMusician$ = -28					; size = 4
_bStateChanged$ = -21					; size = 1
_pEscort$ = -20						; size = 4
_iUnitID$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationConcertTour::ArmyInPosition, COMDAT
; _this$ = ecx

; 3654 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3655 : 	int iUnitID = 0;

	mov	DWORD PTR _iUnitID$[ebp], 0

; 3656 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 3657 : 	CvUnit* pMusician = 0, *pEscort = 0;

	mov	DWORD PTR _pMusician$[ebp], 0
	mov	DWORD PTR _pEscort$[ebp], 0

; 3658 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3659 : 
; 3660 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 4
	ja	$LN21@ArmyInPosi@7
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN64@ArmyInPosi@7[edx*4]
$LN20@ArmyInPosi@7:

; 3661 : 	{
; 3662 : 		// If we were gathering forces, we have to insist that any escort is in the same plot as the merchant.
; 3663 : 		// If not we'll fall through and just stay in this state.
; 3664 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 3665 : 
; 3666 : 		// No escort, can just let base class handle it
; 3667 : 		if(!m_bEscorted)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+112]
	test	ecx, ecx
	jne	SHORT $LN19@ArmyInPosi@7

; 3668 : 		{
; 3669 : 			return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239608[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239608[ebp]
	jmp	$LN23@ArmyInPosi@7

; 3670 : 		}
; 3671 : 
; 3672 : 		// More complex if we are waiting for an escort
; 3673 : 		else

	jmp	$LN18@ArmyInPosi@7
$LN19@ArmyInPosi@7:

; 3674 : 		{
; 3675 : 			iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3676 : 			if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN17@ArmyInPosi@7

; 3677 : 			{
; 3678 : 				pMusician = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239626[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239626[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pMusician$[ebp], eax
$LN17@ArmyInPosi@7:

; 3679 : 			}
; 3680 : 			iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3681 : 			if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN16@ArmyInPosi@7

; 3682 : 			{
; 3683 : 				pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239630[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239630[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 3684 : 			}
; 3685 : 			else

	jmp	SHORT $LN15@ArmyInPosi@7
$LN16@ArmyInPosi@7:

; 3686 : 			{
; 3687 : 				// Escort died while gathering forces.  Abort (and return TRUE since state changed)
; 3688 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 3689 : 				m_eAbortReason = AI_ABORT_ESCORT_DIED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 9

; 3690 : 				return true;

	mov	BYTE PTR $T239609[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239609[ebp]
	jmp	$LN23@ArmyInPosi@7
$LN15@ArmyInPosi@7:

; 3691 : 			}
; 3692 : 			if(pMusician != NULL && pEscort != NULL && pMusician->plot() == pEscort->plot())

	cmp	DWORD PTR _pMusician$[ebp], 0
	je	$LN18@ArmyInPosi@7
	cmp	DWORD PTR _pEscort$[ebp], 0
	je	$LN18@ArmyInPosi@7
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	esi, eax
	jne	$LN18@ArmyInPosi@7

; 3693 : 			{
; 3694 : 				// let's see if the target still makes sense (this is modified from RetargetCivilian)
; 3695 : 				CvPlot* pBetterTarget = FindBestTarget(pMusician, true);

	push	1
	mov	edx, DWORD PTR _pMusician$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pBetterTarget$224932[ebp], eax

; 3696 : 
; 3697 : 				// No targets at all!  Abort
; 3698 : 				if(pBetterTarget == NULL)

	cmp	DWORD PTR _pBetterTarget$224932[ebp], 0
	jne	SHORT $LN13@ArmyInPosi@7

; 3699 : 				{
; 3700 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 3701 : 					m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 1

; 3702 : 					return false;

	mov	BYTE PTR $T239610[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239610[ebp]
	jmp	$LN23@ArmyInPosi@7

; 3703 : 				}
; 3704 : 				// If we have a target
; 3705 : 				else

	jmp	SHORT $LN12@ArmyInPosi@7
$LN13@ArmyInPosi@7:

; 3706 : 				{
; 3707 : 					SetTargetPlot(pBetterTarget);

	mov	eax, DWORD PTR _pBetterTarget$224932[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 3708 : 					pArmy->SetGoalPlot(pBetterTarget);

	mov	ecx, DWORD PTR _pBetterTarget$224932[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN12@ArmyInPosi@7:

; 3709 : 				}
; 3710 : 				return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239611[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239611[ebp]
	jmp	$LN23@ArmyInPosi@7
$LN18@ArmyInPosi@7:

; 3711 : 			}
; 3712 : 		}
; 3713 : 		break;

	jmp	$LN21@ArmyInPosi@7
$LN11@ArmyInPosi@7:

; 3714 : 
; 3715 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 3716 : 	case AI_OPERATION_STATE_AT_TARGET:
; 3717 : 
; 3718 : 		// Call base class version and see if it thinks we're done
; 3719 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 3720 : 
; 3721 : 		// Now get the musician
; 3722 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3723 : 		if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN10@ArmyInPosi@7

; 3724 : 		{
; 3725 : 			pMusician = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239646[ebp], edx
	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239646[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pMusician$[ebp], eax
$LN10@ArmyInPosi@7:

; 3726 : 		}
; 3727 : 
; 3728 : 		if(pMusician != NULL)

	cmp	DWORD PTR _pMusician$[ebp], 0
	je	$LN9@ArmyInPosi@7

; 3729 : 		{
; 3730 : 			// If the merchant made it, we don't care about the entire army
; 3731 : 			if(pMusician->plot() == GetTargetPlot() && pMusician->canMove() && pMusician->canBlastTourism(pMusician->plot()))

	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	esi, eax
	jne	$LN8@ArmyInPosi@7
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@ArmyInPosi@7
	push	0
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBlastTourism
	movzx	edx, al
	test	edx, edx
	je	$LN8@ArmyInPosi@7

; 3732 : 			{
; 3733 : 				pMusician->PushMission(CvTypes::getMISSION_ONE_SHOT_TOURISM());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ONE_SHOT_TOURISM
	push	eax
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3734 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@ArmyInPosi@7
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@ArmyInPosi@7

; 3735 : 				{
; 3736 : 					strMsg.Format("Great Musician performing concert tour, At X=%d, At Y=%d", pMusician->plot()->getX(), pMusician->plot()->getY());

	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T239650[ebp], eax
	mov	edx, DWORD PTR $T239650[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239651[ebp], eax
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T239655[ebp], eax
	mov	ecx, DWORD PTR $T239651[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239655[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DJ@LDIIAOIN@Great?5Musician?5performing?5concer@
	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3737 : 					LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN7@ArmyInPosi@7:

; 3738 : 				}
; 3739 : 
; 3740 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 5
	jmp	$LN9@ArmyInPosi@7
$LN8@ArmyInPosi@7:

; 3741 : 			}
; 3742 : 
; 3743 : 			// Does it look like we should be done?
; 3744 : 			else if(pMusician->plot() == GetTargetPlot())

	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	esi, eax
	jne	$LN9@ArmyInPosi@7

; 3745 : 			{
; 3746 : 				// We're at our target but can no longer perform concert, enemy city was probably conquered
; 3747 : 				if(!pMusician->canBlastTourism(pMusician->plot()))

	push	0
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBlastTourism
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN9@ArmyInPosi@7

; 3748 : 				{
; 3749 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@ArmyInPosi@7
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ArmyInPosi@7

; 3750 : 					{
; 3751 : 						strMsg.Format("At target but can no longer hold concert here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239659[ebp], eax
	mov	ecx, DWORD PTR $T239659[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T239660[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T239664[ebp], eax
	mov	eax, DWORD PTR $T239660[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239664[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0EG@DKDFHLBF@At?5target?5but?5can?5no?5longer?5hold@
	lea	eax, DWORD PTR _strMsg$[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3752 : 						LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@7:

; 3753 : 					}
; 3754 : 					RetargetCivilian(pMusician, pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	eax, DWORD PTR _pMusician$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 3755 : 					pMusician->finishMoves();

	mov	ecx, DWORD PTR _pMusician$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3756 : 					iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 3757 : 					if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN9@ArmyInPosi@7

; 3758 : 					{
; 3759 : 						pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239668[ebp], edx
	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239668[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 3760 : 						pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN9@ArmyInPosi@7:

; 3761 : 					}
; 3762 : 				}
; 3763 : 			}
; 3764 : 		}
; 3765 : 		break;

	jmp	SHORT $LN21@ArmyInPosi@7
$LN1@ArmyInPosi@7:

; 3766 : 
; 3767 : 		// In all other cases use base class version
; 3768 : 	case AI_OPERATION_STATE_ABORTED:
; 3769 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 3770 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T239612[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239612[ebp]
	jmp	SHORT $LN23@ArmyInPosi@7
$LN21@ArmyInPosi@7:

; 3771 : 		break;
; 3772 : 	};
; 3773 : 
; 3774 : 	return bStateChanged;

	mov	dl, BYTE PTR _bStateChanged$[ebp]
	mov	BYTE PTR $T239613[ebp], dl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T239613[ebp]
$LN23@ArmyInPosi@7:

; 3775 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN64@ArmyInPosi@7:
	DD	$LN1@ArmyInPosi@7
	DD	$LN1@ArmyInPosi@7
	DD	$LN20@ArmyInPosi@7
	DD	$LN11@ArmyInPosi@7
	DD	$LN11@ArmyInPosi@7
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationConcertTour::ArmyInPosition
EXTRN	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:PROC ; CvPlayerAI::FindBestMusicianTargetPlot
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T239698 = -8						; size = 4
$T239694 = -4						; size = 4
_pUnit$ = 8						; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationConcertTour::FindBestTarget, COMDAT
; _this$ = ecx

; 3779 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3780 : 	CvAssertMsg(pUnit, "pUnit cannot be null");
; 3781 : 	if(!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN6@FindBestTa@6

; 3782 : 	{
; 3783 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN2@FindBestTa@6

; 3784 : 	}
; 3785 : 
; 3786 : 	return GET_PLAYER(pUnit->getOwner()).FindBestMusicianTargetPlot(pUnit, !bOnlySafePaths /*m_bEscorted*/);

$LN6@FindBestTa@6:
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T239694[ebp], ecx
	mov	edx, DWORD PTR $T239694[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239698[ebp], edx
	movzx	eax, BYTE PTR _bOnlySafePaths$[ebp]
	test	eax, eax
	sete	cl
	movzx	edx, cl
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239698[ebp]
	call	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot
$LN2@FindBestTa@6:

; 3787 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationConcertTour::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAINavalOperation@@6B@			; CvAINavalOperation::`vftable'
PUBLIC	??0CvAINavalOperation@@QAE@XZ			; CvAINavalOperation::CvAINavalOperation
PUBLIC	?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ ; CvAINavalOperation::GetMaximumRecruitTurns
PUBLIC	?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAINavalOperation::GetFormation
PUBLIC	?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ ; CvAINavalOperation::IsAllNavalOperation
PUBLIC	?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ ; CvAINavalOperation::GetOperationStartCity
PUBLIC	?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalOperation::Read
PUBLIC	?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalOperation::Write
PUBLIC	?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ; CvAINavalOperation::SelectInitialMusterPoint
PUBLIC	?GetDeployRange@CvAINavalOperation@@UBEHXZ	; CvAINavalOperation::GetDeployRange
PUBLIC	?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ ; CvAINavalOperation::FindInitialUnit
EXTRN	??_ECvAINavalOperation@@UAEPAXI@Z:PROC		; CvAINavalOperation::`vector deleting destructor'
;	COMDAT ??_7CvAINavalOperation@@6B@
CONST	SEGMENT
??_7CvAINavalOperation@@6B@ DD FLAT:??_ECvAINavalOperation@@UAEPAXI@Z ; CvAINavalOperation::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:__purecall
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAINavalOperation@@UBEHXZ
	DD	FLAT:__purecall
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAINavalOperation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAINavalOperation@@QAE@XZ PROC			; CvAINavalOperation::CvAINavalOperation, COMDAT
; _this$ = ecx

; 3795 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIEnemyTerritoryOperation@@QAE@XZ	; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAINavalOperation@@6B@

; 3796 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAINavalOperation@@QAE@XZ ENDP			; CvAINavalOperation::CvAINavalOperation
_TEXT	ENDS
PUBLIC	??1CvAINavalOperation@@UAE@XZ			; CvAINavalOperation::~CvAINavalOperation
; Function compile flags: /Odtp
;	COMDAT ??_GCvAINavalOperation@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAINavalOperation@@UAEPAXI@Z PROC			; CvAINavalOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAINavalOperation@@UAE@XZ		; CvAINavalOperation::~CvAINavalOperation
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@15
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@15:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAINavalOperation@@UAEPAXI@Z ENDP			; CvAINavalOperation::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAINavalOperation@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAINavalOperation@@UAE@XZ PROC			; CvAINavalOperation::~CvAINavalOperation, COMDAT
; _this$ = ecx

; 3800 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAINavalOperation@@6B@

; 3801 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIEnemyTerritoryOperation@@UAE@XZ	; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAINavalOperation@@UAE@XZ ENDP			; CvAINavalOperation::~CvAINavalOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z PROC	; CvAINavalOperation::Read, COMDAT
; _this$ = ecx

; 3805 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3806 : 	// read the base class' entries
; 3807 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 3808 : 
; 3809 : 	// Version number to maintain backwards compatibility
; 3810 : 	uint uiVersion;
; 3811 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 3812 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z ENDP	; CvAINavalOperation::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z PROC	; CvAINavalOperation::Write, COMDAT
; _this$ = ecx

; 3816 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3817 : 	// write the base class' entries
; 3818 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 3819 : 
; 3820 : 	// Current version number
; 3821 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 3822 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 3823 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z ENDP	; CvAINavalOperation::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDeployRange@CvAINavalOperation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T239722 = -4						; size = 4
?GetDeployRange@CvAINavalOperation@@UBEHXZ PROC		; CvAINavalOperation::GetDeployRange, COMDAT
; _this$ = ecx

; 3827 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3828 : 	return GC.getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2428
	mov	DWORD PTR $T239722[ebp], eax
	mov	eax, DWORD PTR $T239722[ebp]

; 3829 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeployRange@CvAINavalOperation@@UBEHXZ ENDP		; CvAINavalOperation::GetDeployRange
_TEXT	ENDS
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Odtp
;	COMDAT ?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T239737 = -20						; size = 4
$T239733 = -16						; size = 4
_pCity$ = -8						; size = 4
_iLoop$ = -4						; size = 4
?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ PROC ; CvAINavalOperation::GetOperationStartCity, COMDAT
; _this$ = ecx

; 3833 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3834 : 	if(GetStartCityPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN5@GetOperati@2

; 3835 : 	{
; 3836 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	jmp	SHORT $LN6@GetOperati@2
$LN5@GetOperati@2:

; 3837 : 	}
; 3838 : 
; 3839 : 	int iLoop;
; 3840 : 	CvCity* pCity;
; 3841 : 
; 3842 : 	// Just find first coastal city
; 3843 : 	for(pCity = GET_PLAYER(m_eOwner).firstCity(&iLoop); pCity != NULL; pCity = GET_PLAYER(m_eOwner).nextCity(&iLoop))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239733[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239733[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN4@GetOperati@2
$LN3@GetOperati@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239737[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239737[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN4@GetOperati@2:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN2@GetOperati@2

; 3844 : 	{
; 3845 : 		if(pCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetOperati@2

; 3846 : 		{
; 3847 : 			return pCity;

	mov	eax, DWORD PTR _pCity$[ebp]
	jmp	SHORT $LN6@GetOperati@2
$LN1@GetOperati@2:

; 3848 : 		}
; 3849 : 	}

	jmp	SHORT $LN3@GetOperati@2
$LN2@GetOperati@2:

; 3850 : 
; 3851 : 	return NULL;

	xor	eax, eax
$LN6@GetOperati@2:

; 3852 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ ENDP ; CvAINavalOperation::GetOperationStartCity
_TEXT	ENDS
PUBLIC	??_C@_0EK@IFBNEFJG@No?5muster?5point?5found?0?5Naval?5ope@ ; `string'
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0EK@IFBNEFJG@No?5muster?5point?5found?0?5Naval?5ope@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0EK@IFBNEFJG@No?5muster?5point?5found?0?5Naval?5ope@ DB 'No muster '
	DB	'point found, Naval operation aborting, Target was, X: %d, Y: '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0
__ehfuncinfo$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -236						; size = 4
$T239971 = -232						; size = 4
$T239967 = -228						; size = 4
$T239966 = -224						; size = 4
$T239958 = -220						; size = 4
$T239957 = -216						; size = 4
$T239944 = -212						; size = 4
$T239938 = -208						; size = 4
$T239934 = -204						; size = 4
$T239930 = -200						; size = 4
$T239926 = -196						; size = 4
$T239922 = -192						; size = 4
$T239921 = -188						; size = 4
$T239917 = -184						; size = 4
$T239916 = -180						; size = 4
$T239912 = -176						; size = 4
$T239911 = -172						; size = 4
$T239749 = -88						; size = 4
$T239745 = -84						; size = 4
_szMsg$225019 = -80					; size = 28
__$ArrayPad$ = -52					; size = 4
_pStartCityPlot$ = -48					; size = 4
_pStartCity$ = -44					; size = 4
_pNode$ = -40						; size = 4
_iDirectionLoop$ = -36					; size = 4
_pCurrentPlot$ = -32					; size = 4
_iSpacesFromTarget$ = -28				; size = 4
_pAdjacentPlot$ = -24					; size = 4
_pMusterPt$ = -20					; size = 4
_bMusterPointFound$ = -13				; size = 1
__$EHRec$ = -12						; size = 12
_pThisArmy$ = 8						; size = 4
?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z PROC ; CvAINavalOperation::SelectInitialMusterPoint, COMDAT
; _this$ = ecx

; 3856 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3857 : 	CvPlot* pMusterPt = NULL;

	mov	DWORD PTR _pMusterPt$[ebp], 0

; 3858 : 	CvPlot* pStartCityPlot;
; 3859 : 	CvCity* pStartCity;
; 3860 : 	CvPlot* pCurrentPlot;
; 3861 : 	CvPlot* pAdjacentPlot;
; 3862 : 	int iSpacesFromTarget = 0;

	mov	DWORD PTR _iSpacesFromTarget$[ebp], 0

; 3863 : 	int iDirectionLoop;
; 3864 : 	CvAStarNode* pNode;
; 3865 : 	bool bMusterPointFound = false;

	mov	BYTE PTR _bMusterPointFound$[ebp], 0

; 3866 : 
; 3867 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _pStartCity$[ebp], eax

; 3868 : 	if(pStartCity)

	cmp	DWORD PTR _pStartCity$[ebp], 0
	je	$LN13@SelectInit@3

; 3869 : 	{
; 3870 : 		pStartCityPlot = pStartCity->plot();

	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pStartCityPlot$[ebp], eax

; 3871 : 
; 3872 : 		if(pStartCityPlot != NULL)

	cmp	DWORD PTR _pStartCityPlot$[ebp], 0
	je	$LN13@SelectInit@3

; 3873 : 		{
; 3874 : 			// Find an adjacent water tile
; 3875 : 			for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES && !bMusterPointFound; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$[ebp], 0
	jmp	SHORT $LN11@SelectInit@3
$LN10@SelectInit@3:
	mov	ecx, DWORD PTR _iDirectionLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDirectionLoop$[ebp], ecx
$LN11@SelectInit@3:
	cmp	DWORD PTR _iDirectionLoop$[ebp], 6
	jge	$LN13@SelectInit@3
	movzx	edx, BYTE PTR _bMusterPointFound$[ebp]
	test	edx, edx
	jne	$LN13@SelectInit@3

; 3876 : 			{
; 3877 : 				pAdjacentPlot = plotDirection(pStartCityPlot->getX(), pStartCityPlot->getY(), ((DirectionTypes)iDirectionLoop));

	mov	eax, DWORD PTR _pStartCityPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239745[ebp], ecx
	mov	edx, DWORD PTR _pStartCityPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T239749[ebp], eax
	mov	ecx, DWORD PTR _iDirectionLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239745[ebp]
	push	edx
	mov	eax, DWORD PTR $T239749[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3878 : 				if(pAdjacentPlot != NULL && pAdjacentPlot->isWater())

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	$LN8@SelectInit@3
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@SelectInit@3

; 3879 : 				{
; 3880 : 					// Generate path
; 3881 : 					GC.getStepFinder().SetData(&m_eEnemy);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR $T239912[ebp], edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T239911[ebp], eax
	mov	eax, DWORD PTR $T239911[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN87@SelectInit@3
	mov	edx, DWORD PTR $T239911[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR $T239912[ebp]
	je	SHORT $LN87@SelectInit@3
	mov	ecx, DWORD PTR $T239911[ebp]
	mov	BYTE PTR [ecx+78], 1
$LN87@SelectInit@3:
	mov	edx, DWORD PTR $T239911[ebp]
	mov	eax, DWORD PTR $T239912[ebp]
	mov	DWORD PTR [edx+44], eax

; 3882 : 					if(GC.getStepFinder().GeneratePath(pAdjacentPlot->getX(), pAdjacentPlot->getY(), pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY(), m_eOwner, false))

	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T239916[ebp], eax
	mov	ecx, DWORD PTR $T239916[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T239917[ebp], edx
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T239921[ebp], eax
	mov	eax, DWORD PTR $T239921[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239922[ebp], ecx
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239926[ebp], eax
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239930[ebp], edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR $T239917[ebp]
	push	edx
	mov	eax, DWORD PTR $T239922[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239926[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239930[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	eax, al
	test	eax, eax
	je	$LN8@SelectInit@3

; 3883 : 					{
; 3884 : 						pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T239934[ebp], eax
	mov	ecx, DWORD PTR $T239934[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$[ebp], edx
$LN6@SelectInit@3:

; 3885 : 
; 3886 : 						// Starting at the end, loop until we find a plot from this owner
; 3887 : 						while(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN8@SelectInit@3

; 3888 : 						{
; 3889 : 							pCurrentPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T239938[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T239958[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T239957[ebp], ecx
	cmp	DWORD PTR $T239957[ebp], -2147483647	; 80000001H
	je	SHORT $LN102@SelectInit@3
	cmp	DWORD PTR $T239958[ebp], -2147483647	; 80000001H
	jne	SHORT $LN103@SelectInit@3
$LN102@SelectInit@3:
	mov	DWORD PTR _pCurrentPlot$[ebp], 0
	jmp	SHORT $LN104@SelectInit@3
$LN103@SelectInit@3:
	mov	edx, DWORD PTR $T239938[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T239944[ebp], eax
	mov	ecx, DWORD PTR $T239958[ebp]
	imul	ecx, DWORD PTR $T239944[ebp]
	add	ecx, DWORD PTR $T239957[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T239938[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pCurrentPlot$[ebp], ecx
$LN104@SelectInit@3:

; 3890 : 
; 3891 : 							// Is this the deploy point?
; 3892 : 							if(iSpacesFromTarget == GetDeployRange())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	call	eax
	cmp	DWORD PTR _iSpacesFromTarget$[ebp], eax
	jne	SHORT $LN4@SelectInit@3

; 3893 : 							{
; 3894 : 								pMusterPt = pCurrentPlot;

	mov	ecx, DWORD PTR _pCurrentPlot$[ebp]
	mov	DWORD PTR _pMusterPt$[ebp], ecx

; 3895 : 								bMusterPointFound = true;

	mov	BYTE PTR _bMusterPointFound$[ebp], 1

; 3896 : 								break;

	jmp	SHORT $LN8@SelectInit@3
$LN4@SelectInit@3:

; 3897 : 							}
; 3898 : 
; 3899 : 							// Move to the previous plot on the path
; 3900 : 							iSpacesFromTarget++;

	mov	edx, DWORD PTR _iSpacesFromTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _iSpacesFromTarget$[ebp], edx

; 3901 : 							pNode = pNode->m_pParent;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pNode$[ebp], ecx

; 3902 : 						}

	jmp	$LN6@SelectInit@3
$LN8@SelectInit@3:

; 3903 : 					}
; 3904 : 				}
; 3905 : 			}

	jmp	$LN10@SelectInit@3
$LN13@SelectInit@3:

; 3906 : 		}
; 3907 : 	}
; 3908 : 
; 3909 : 	if(pMusterPt != NULL)

	cmp	DWORD PTR _pMusterPt$[ebp], 0
	je	SHORT $LN3@SelectInit@3

; 3910 : 	{
; 3911 : 		SetMusterPlot(pMusterPt);

	mov	edx, DWORD PTR _pMusterPt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 3912 : 	}
; 3913 : 	else

	jmp	$LN2@SelectInit@3
$LN3@SelectInit@3:

; 3914 : 	{
; 3915 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@SelectInit@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@SelectInit@3

; 3916 : 		{
; 3917 : 			CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$225019[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3918 : 			szMsg.Format("No muster point found, Naval operation aborting, Target was, X: %d, Y: %d", pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY());

	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T239966[ebp], eax
	mov	edx, DWORD PTR $T239966[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239967[ebp], eax
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	DWORD PTR $T239971[ebp], eax
	mov	ecx, DWORD PTR $T239967[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239971[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0EK@IFBNEFJG@No?5muster?5point?5found?0?5Naval?5ope@
	lea	ecx, DWORD PTR _szMsg$225019[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3919 : 			LogOperationSpecialMessage(szMsg);

	lea	edx, DWORD PTR _szMsg$225019[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage

; 3920 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szMsg$225019[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@SelectInit@3:

; 3921 : 	}
; 3922 : 
; 3923 : 	return pMusterPt;

	mov	eax, DWORD PTR _pMusterPt$[ebp]

; 3924 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _szMsg$225019[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ENDP ; CvAINavalOperation::SelectInitialMusterPoint
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T240188 = -80						; size = 4
$T240143 = -76						; size = 4
$T240130 = -72						; size = 4
$T240126 = -68						; size = 4
$T240112 = -64						; size = 4
$T240108 = -57						; size = 1
$T240097 = -56						; size = 4
$T240093 = -49						; size = 1
_iMapY$240187 = -48					; size = 4
_iMapX$240186 = -44					; size = 4
$T240086 = -40						; size = 4
$T240062 = -36						; size = 4
$T240025 = -32						; size = 4
$T240013 = -28						; size = 4
$T240009 = -21						; size = 1
$T239998 = -20						; size = 4
$T239994 = -13						; size = 1
_iMapY$240061 = -12					; size = 4
_iMapX$240060 = -8					; size = 4
$T239987 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T239987[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T240062[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T239987[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T239994[ebp], dl
	mov	eax, DWORD PTR $T239987[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T239998[ebp], ecx
	movzx	edx, BYTE PTR $T239994[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T239998[ebp]
	add	edx, DWORD PTR $T239998[ebp]
	mov	DWORD PTR _iMapX$240060[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T239998[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T239998[ebp]
	mov	DWORD PTR _iMapX$240060[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$240060[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T239987[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T240009[ebp], al
	mov	ecx, DWORD PTR $T239987[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T240013[ebp], edx
	movzx	eax, BYTE PTR $T240009[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240013[ebp]
	add	edx, DWORD PTR $T240013[ebp]
	mov	DWORD PTR _iMapY$240061[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T240013[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240013[ebp]
	mov	DWORD PTR _iMapY$240061[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$240061[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$240061[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$240060[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239987[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T239987[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T240025[ebp], eax
	mov	ecx, DWORD PTR _iMapY$240061[ebp]
	imul	ecx, DWORD PTR $T240025[ebp]
	add	ecx, DWORD PTR _iMapX$240060[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T239987[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T240062[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T240062[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240086[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T240188[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T240086[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T240093[ebp], dl
	mov	eax, DWORD PTR $T240086[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240097[ebp], ecx
	movzx	edx, BYTE PTR $T240093[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T240097[ebp]
	add	edx, DWORD PTR $T240097[ebp]
	mov	DWORD PTR _iMapX$240186[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T240097[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T240097[ebp]
	mov	DWORD PTR _iMapX$240186[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$240186[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T240086[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T240108[ebp], al
	mov	ecx, DWORD PTR $T240086[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T240112[ebp], edx
	movzx	eax, BYTE PTR $T240108[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240112[ebp]
	add	edx, DWORD PTR $T240112[ebp]
	mov	DWORD PTR _iMapY$240187[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T240112[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240112[ebp]
	mov	DWORD PTR _iMapY$240187[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$240187[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$240186[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T240086[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240126[ebp], ecx
	mov	edx, DWORD PTR _iMapX$240186[ebp]
	cmp	edx, DWORD PTR $T240126[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$240187[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T240086[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T240130[ebp], ecx
	mov	edx, DWORD PTR _iMapY$240187[ebp]
	cmp	edx, DWORD PTR $T240130[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T240086[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240143[ebp], ecx
	mov	edx, DWORD PTR _iMapY$240187[ebp]
	imul	edx, DWORD PTR $T240143[ebp]
	add	edx, DWORD PTR _iMapX$240186[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T240086[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T240188[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T240188[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
_TEXT	ENDS
;	COMDAT ?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T240198 = -20						; size = 4
$T240194 = -16						; size = 4
_pkUnitEntry$225031 = -12				; size = 4
_pLoopUnit$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ PROC ; CvAINavalOperation::FindInitialUnit, COMDAT
; _this$ = ecx

; 3928 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3929 : 	int iUnitLoop;
; 3930 : 	CvUnit* pLoopUnit;
; 3931 : 
; 3932 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240194[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T240194[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN7@FindInitia
$LN6@FindInitia:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240198[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T240198[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN7@FindInitia:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN5@FindInitia

; 3933 : 	{
; 3934 : 		if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN4@FindInitia

; 3935 : 		{
; 3936 : 			if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	SHORT $LN4@FindInitia

; 3937 : 			{
; 3938 : 				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopUnit->getUnitType());

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitEntry$225031[ebp], eax

; 3939 : 				if(pkUnitEntry && pkUnitEntry->GetUnitAIType(UNITAI_ATTACK_SEA))

	cmp	DWORD PTR _pkUnitEntry$225031[ebp], 0
	je	SHORT $LN4@FindInitia
	push	18					; 00000012H
	mov	ecx, DWORD PTR _pkUnitEntry$225031[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@FindInitia

; 3940 : 				{
; 3941 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN4@FindInitia

; 3942 : 					{
; 3943 : 						return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN8@FindInitia
$LN4@FindInitia:

; 3944 : 					}
; 3945 : 				}
; 3946 : 			}
; 3947 : 		}
; 3948 : 	}

	jmp	SHORT $LN6@FindInitia
$LN5@FindInitia:

; 3949 : 	return NULL;

	xor	eax, eax
$LN8@FindInitia:

; 3950 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ ENDP ; CvAINavalOperation::FindInitialUnit
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalBombardment@@6B@		; CvAIOperationNavalBombardment::`vftable'
PUBLIC	?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNavalBombardment::Init
PUBLIC	?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ ; CvAIOperationNavalBombardment::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalBombardment::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNavalBombardment::ArmyInPosition
PUBLIC	?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z ; CvAIOperationNavalBombardment::Read
PUBLIC	?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z ; CvAIOperationNavalBombardment::Write
PUBLIC	?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ ; CvAIOperationNavalBombardment::GetOperationName
PUBLIC	?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ ; CvAIOperationNavalBombardment::FindBestTarget
EXTRN	??_ECvAIOperationNavalBombardment@@UAEPAXI@Z:PROC ; CvAIOperationNavalBombardment::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationNavalBombardment@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalBombardment@@6B@ DD FLAT:??_ECvAIOperationNavalBombardment@@UAEPAXI@Z ; CvAIOperationNavalBombardment::`vftable'
	DD	FLAT:?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalBombardment@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationNavalBombardment@@QAE@XZ PROC		; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment, COMDAT
; _this$ = ecx

; 3958 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAINavalOperation@@QAE@XZ		; CvAINavalOperation::CvAINavalOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalBombardment@@6B@

; 3959 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationNavalBombardment@@QAE@XZ ENDP		; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalBombardment@@UAE@XZ	; CvAIOperationNavalBombardment::~CvAIOperationNavalBombardment
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationNavalBombardment@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationNavalBombardment@@UAEPAXI@Z PROC	; CvAIOperationNavalBombardment::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationNavalBombardment@@UAE@XZ ; CvAIOperationNavalBombardment::~CvAIOperationNavalBombardment
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@16
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@16:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationNavalBombardment@@UAEPAXI@Z ENDP	; CvAIOperationNavalBombardment::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationNavalBombardment@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationNavalBombardment@@UAE@XZ PROC		; CvAIOperationNavalBombardment::~CvAIOperationNavalBombardment, COMDAT
; _this$ = ecx

; 3963 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalBombardment@@6B@

; 3964 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAINavalOperation@@UAE@XZ		; CvAINavalOperation::~CvAINavalOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationNavalBombardment@@UAE@XZ ENDP		; CvAIOperationNavalBombardment::~CvAIOperationNavalBombardment
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T240351 = -100						; size = 4
$T240350 = -96						; size = 4
$T240346 = -92						; size = 4
$T240342 = -88						; size = 4
$T240341 = -84						; size = 4
$T240209 = -16						; size = 4
_pTargetPlot$225058 = -12				; size = 4
_pArmyAI$225055 = -8					; size = 4
_kPlayer$225054 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNavalBombardment::Init, COMDAT
; _this$ = ecx

; 3968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 3969 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 3970 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 1

; 3971 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 3972 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 3973 : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 3974 : 
; 3975 : 	if(iID != -1 && GetOperationStartCity())

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN9@Init@6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	test	eax, eax
	je	$LN9@Init@6

; 3976 : 	{
; 3977 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 3978 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225054[ebp], ecx

; 3979 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, DWORD PTR _kPlayer$225054[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225055[ebp], eax

; 3980 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225055[ebp], 0
	je	$LN9@Init@6

; 3981 : 		{
; 3982 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T240209[ebp], eax
	lea	edx, DWORD PTR $T240209[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3983 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 3984 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3985 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 3986 : 
; 3987 : 			// Figure out the initial rally point
; 3988 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pTargetPlot$225058[ebp], eax

; 3989 : 			if(pTargetPlot != NULL)

	cmp	DWORD PTR _pTargetPlot$225058[ebp], 0
	je	$LN6@Init@6

; 3990 : 			{
; 3991 : 				SetTargetPlot(pTargetPlot);

	mov	ecx, DWORD PTR _pTargetPlot$225058[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 3992 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	mov	edx, DWORD PTR _pTargetPlot$225058[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3993 : 				if(SelectInitialMusterPoint(pArmyAI) != NULL)

	mov	eax, DWORD PTR _pArmyAI$225055[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax
	test	eax, eax
	je	$LN5@Init@6

; 3994 : 				{
; 3995 : 					pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T240341[ebp], eax
	mov	ecx, DWORD PTR $T240341[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240342[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T240346[ebp], eax
	mov	eax, DWORD PTR $T240342[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240346[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3996 : 					SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T240350[ebp], eax
	mov	eax, DWORD PTR $T240350[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T240351[ebp], ecx
	mov	edx, DWORD PTR $T240351[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 3997 : 
; 3998 : 					// Find the list of units we need to build before starting this operation in earnest
; 3999 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 4000 : 
; 4001 : 					// try to get as many units as possible from existing units that are waiting around
; 4002 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetMusterPlot()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Init@6

; 4003 : 					{
; 4004 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$225055[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4005 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 2

; 4006 : 					}
; 4007 : 					else

	jmp	SHORT $LN3@Init@6
$LN4@Init@6:

; 4008 : 					{
; 4009 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN3@Init@6:

; 4010 : 					}
; 4011 : 
; 4012 : 					LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart

; 4013 : 				}
; 4014 : 				else

	jmp	SHORT $LN2@Init@6
$LN5@Init@6:

; 4015 : 				{
; 4016 : 					// No muster point, abort
; 4017 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 4018 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 7
$LN2@Init@6:

; 4019 : 				}
; 4020 : 			}
; 4021 : 
; 4022 : 			else

	jmp	SHORT $LN9@Init@6
$LN6@Init@6:

; 4023 : 			{
; 4024 : 				// Lost our target, abort
; 4025 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 4026 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 3
$LN9@Init@6:

; 4027 : 			}
; 4028 : 		}
; 4029 : 	}
; 4030 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNavalBombardment::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalBombardment::Read, COMDAT
; _this$ = ecx

; 4034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4035 : 	// read the base class' entries
; 4036 : 	CvAINavalOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalOperation::Read

; 4037 : 
; 4038 : 	// Version number to maintain backwards compatibility
; 4039 : 	uint uiVersion;
; 4040 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4041 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalBombardment::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalBombardment::Write, COMDAT
; _this$ = ecx

; 4045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4046 : 	// write the base class' entries
; 4047 : 	CvAINavalOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalOperation::Write

; 4048 : 
; 4049 : 	// Current version number
; 4050 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 4051 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4052 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalBombardment::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -76						; size = 4
_this$ = -72						; size = 4
$T240410 = -68						; size = 4
$T240406 = -64						; size = 4
$T240402 = -60						; size = 4
$T240398 = -56						; size = 4
$T240391 = -52						; size = 4
$T240387 = -48						; size = 4
$T240383 = -44						; size = 4
$T240379 = -40						; size = 4
$T240367 = -36						; size = 4
_zone$225093 = -32					; size = 20
_pDeployPt$225089 = -12					; size = 4
_possibleBetterTarget$225085 = -8			; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNavalBombardment::ArmyInPosition, COMDAT
; _this$ = ecx

; 4056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4057 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 4058 : 
; 4059 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	$LN9@ArmyInPosi@8
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN37@ArmyInPosi@8[edx*4]
$LN8@ArmyInPosi@8:

; 4060 : 	{
; 4061 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 4062 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4063 : 	{
; 4064 : 		// First do base case processing
; 4065 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 4066 : 
; 4067 : 		// Now revisit target
; 4068 : 		CvPlot* possibleBetterTarget;
; 4069 : 		possibleBetterTarget = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _possibleBetterTarget$225085[ebp], eax

; 4070 : 
; 4071 : 		// If no target left, abort
; 4072 : 		if(possibleBetterTarget == NULL)

	cmp	DWORD PTR _possibleBetterTarget$225085[ebp], 0
	jne	SHORT $LN7@ArmyInPosi@8

; 4073 : 		{
; 4074 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 4075 : 			m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 1
	jmp	SHORT $LN6@ArmyInPosi@8
$LN7@ArmyInPosi@8:

; 4076 : 		}
; 4077 : 
; 4078 : 		// If target changed, reset to this new one
; 4079 : 		else if(possibleBetterTarget != GetTargetPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _possibleBetterTarget$225085[ebp], eax
	je	SHORT $LN6@ArmyInPosi@8

; 4080 : 		{
; 4081 : 			// Reset our destination to be a few plots shy of the final target
; 4082 : 			CvPlot* pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), possibleBetterTarget, GetDeployRange(), false);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T240367[ebp], ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	push	eax
	mov	eax, DWORD PTR _possibleBetterTarget$225085[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	ecx, DWORD PTR $T240367[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	DWORD PTR _pDeployPt$225089[ebp], eax

; 4083 : 			if(pDeployPt != NULL)

	cmp	DWORD PTR _pDeployPt$225089[ebp], 0
	je	SHORT $LN6@ArmyInPosi@8

; 4084 : 			{
; 4085 : 				pArmy->SetGoalPlot(pDeployPt);

	mov	edx, DWORD PTR _pDeployPt$225089[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4086 : 				SetTargetPlot(possibleBetterTarget);

	mov	eax, DWORD PTR _possibleBetterTarget$225085[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot
$LN6@ArmyInPosi@8:

; 4087 : 			}
; 4088 : 		}
; 4089 : 	}
; 4090 : 	break;

	jmp	$LN9@ArmyInPosi@8
$LN3@ArmyInPosi@8:

; 4091 : 
; 4092 : 	// See if reached our target, if so give control of these units to the tactical AI
; 4093 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4094 : 	{
; 4095 : 		if(pArmy->Plot() == pArmy->GetGoalPlot())

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	esi, eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	cmp	esi, eax
	jne	$LN2@ArmyInPosi@8

; 4096 : 		{
; 4097 : 			// Notify tactical AI to focus on this area
; 4098 : 			CvTemporaryZone zone;

	mov	DWORD PTR _zone$225093[ebp], 0
	mov	DWORD PTR _zone$225093[ebp+4], 0
	mov	DWORD PTR _zone$225093[ebp+8], 0
	mov	DWORD PTR _zone$225093[ebp+12], 0

; 4099 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T240379[ebp], eax
	mov	ecx, DWORD PTR $T240379[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T240383[ebp], edx
	mov	eax, DWORD PTR $T240383[ebp]
	mov	DWORD PTR _zone$225093[ebp], eax

; 4100 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T240387[ebp], eax
	mov	ecx, DWORD PTR $T240387[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240391[ebp], edx
	mov	eax, DWORD PTR $T240391[ebp]
	mov	DWORD PTR _zone$225093[ebp+4], eax

; 4101 : 			zone.SetTargetType(AI_TACTICAL_TARGET_BOMBARDMENT_ZONE);

	mov	DWORD PTR _zone$225093[ebp+8], 12	; 0000000cH

; 4102 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240398[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2456
	mov	DWORD PTR $T240402[ebp], edx
	mov	ecx, DWORD PTR $T240398[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR $T240402[ebp]
	mov	DWORD PTR $T240406[ebp], eax
	mov	eax, DWORD PTR $T240406[ebp]
	mov	DWORD PTR _zone$225093[ebp+12], eax

; 4103 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T240410[ebp], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	ecx, DWORD PTR _zone$225093[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _zone$225093[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _zone$225093[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _zone$225093[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _zone$225093[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR $T240410[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 4104 : 
; 4105 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 5
$LN2@ArmyInPosi@8:

; 4106 : 		}
; 4107 : 	}
; 4108 : 	break;

	jmp	SHORT $LN9@ArmyInPosi@8
$LN1@ArmyInPosi@8:

; 4109 : 
; 4110 : 	// In all other cases use base class version
; 4111 : 	case AI_OPERATION_STATE_ABORTED:
; 4112 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4113 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4114 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	jmp	SHORT $LN11@ArmyInPosi@8
$LN9@ArmyInPosi@8:

; 4115 : 		break;
; 4116 : 	};
; 4117 : 
; 4118 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
$LN11@ArmyInPosi@8:

; 4119 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN37@ArmyInPosi@8:
	DD	$LN1@ArmyInPosi@8
	DD	$LN1@ArmyInPosi@8
	DD	$LN8@ArmyInPosi@8
	DD	$LN3@ArmyInPosi@8
	DD	$LN1@ArmyInPosi@8
?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNavalBombardment::ArmyInPosition
_TEXT	ENDS
EXTRN	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z:PROC ; CvUnit::GeneratePath
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -172						; size = 4
$T240462 = -80						; size = 4
$T240458 = -76						; size = 4
_uiOffset$240453 = -72					; size = 4
$T240444 = -68						; size = 4
$T240432 = -64						; size = 4
$T240428 = -60						; size = 4
$T240424 = -56						; size = 4
$T240420 = -52						; size = 4
_pUnit$225119 = -48					; size = 4
_iUnitID$225110 = -44					; size = 4
_pThisArmy$225109 = -40					; size = 4
_iBestTurns$ = -36					; size = 4
_iCurrentTurns$ = -32					; size = 4
_pPlot$ = -28						; size = 4
_iPlotLoop$ = -24					; size = 4
_pBestPlot$ = -20					; size = 4
_owningPlayer$ = -16					; size = 4
_iDirectionLoop$ = -12					; size = 4
_pInitialUnit$ = -8					; size = 4
_pAdjacentPlot$ = -4					; size = 4
?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNavalBombardment::FindBestTarget, COMDAT
; _this$ = ecx

; 4123 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	DWORD PTR _this$[ebp], ecx

; 4124 : #ifdef AUI_WARNING_FIXES
; 4125 : 	uint iPlotLoop;
; 4126 : 	int iDirectionLoop;
; 4127 : #else
; 4128 : 	int iPlotLoop, iDirectionLoop;
; 4129 : #endif
; 4130 : 	CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 4131 : 	CvPlot* pPlot;
; 4132 : 	CvPlot* pAdjacentPlot;
; 4133 : 	int iBestTurns = MAX_INT;

	mov	DWORD PTR _iBestTurns$[ebp], 2147483647	; 7fffffffH

; 4134 : 	int iCurrentTurns;
; 4135 : 	CvUnit* pInitialUnit;
; 4136 : 
; 4137 : 	CvPlayer& owningPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$[ebp], ecx

; 4138 : 
; 4139 : 	if(GetFirstArmyID() == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	cmp	eax, -1
	jne	SHORT $LN17@FindBestTa@7

; 4140 : 	{
; 4141 : 		pInitialUnit = FindInitialUnit();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx
	mov	DWORD PTR _pInitialUnit$[ebp], eax

; 4142 : 	}
; 4143 : 	else

	jmp	SHORT $LN16@FindBestTa@7
$LN17@FindBestTa@7:

; 4144 : 	{
; 4145 : 		CvArmyAI* pThisArmy = owningPlayer.getArmyAI(m_viArmyIDs[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240420[ebp], eax
	mov	edx, DWORD PTR $T240420[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _owningPlayer$[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$225109[ebp], eax

; 4146 : 		int iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pThisArmy$225109[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$225110[ebp], eax

; 4147 : 		if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$225110[ebp], -1
	je	SHORT $LN15@FindBestTa@7

; 4148 : 		{
; 4149 : 			pInitialUnit = owningPlayer.getUnit(iUnitID);

	mov	ecx, DWORD PTR _iUnitID$225110[ebp]
	push	ecx
	mov	ecx, DWORD PTR _owningPlayer$[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pInitialUnit$[ebp], eax

; 4150 : 		}
; 4151 : 		else

	jmp	SHORT $LN16@FindBestTa@7
$LN15@FindBestTa@7:

; 4152 : 		{
; 4153 : 			pInitialUnit = FindInitialUnit();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx
	mov	DWORD PTR _pInitialUnit$[ebp], eax
$LN16@FindBestTa@7:

; 4154 : 		}
; 4155 : 	}
; 4156 : 
; 4157 : 	if(pInitialUnit != NULL)

	cmp	DWORD PTR _pInitialUnit$[ebp], 0
	je	$LN13@FindBestTa@7

; 4158 : 	{
; 4159 : 		// Look at map for enemy units on the coast
; 4160 : 		for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$[ebp], 0
	jmp	SHORT $LN12@FindBestTa@7
$LN11@FindBestTa@7:
	mov	eax, DWORD PTR _iPlotLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlotLoop$[ebp], eax
$LN12@FindBestTa@7:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240424[ebp], ecx
	mov	edx, DWORD PTR $T240424[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T240428[ebp], eax
	mov	ecx, DWORD PTR _iPlotLoop$[ebp]
	cmp	ecx, DWORD PTR $T240428[ebp]
	jge	$LN13@FindBestTa@7

; 4161 : 		{
; 4162 : 			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240432[ebp], edx
	mov	eax, DWORD PTR _iPlotLoop$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T240432[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pPlot$[ebp], eax

; 4163 : 
; 4164 : 			if(pPlot->isRevealed(owningPlayer.getTeam()))

	mov	edx, DWORD PTR _owningPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240444[ebp], eax
	mov	ecx, DWORD PTR $T240444[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$240453[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$240453[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T240444[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$240453[ebp]
	mov	edx, DWORD PTR _pPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@FindBestTa@7

; 4165 : 			{
; 4166 : 				if(pPlot->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	edx, al
	test	edx, edx
	je	$LN9@FindBestTa@7

; 4167 : 				{
; 4168 : 					// Enemy defender here? (for now let's not add cities; they fire back!)
; 4169 : 					CvUnit* pUnit = pPlot->getVisibleEnemyDefender(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	DWORD PTR _pUnit$225119[ebp], eax

; 4170 : 					if(pUnit)

	cmp	DWORD PTR _pUnit$225119[ebp], 0
	je	$LN9@FindBestTa@7

; 4171 : 					{
; 4172 : 						// Find an adjacent coastal water tile
; 4173 : 						for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$[ebp], 0
	jmp	SHORT $LN6@FindBestTa@7
$LN5@FindBestTa@7:
	mov	edx, DWORD PTR _iDirectionLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iDirectionLoop$[ebp], edx
$LN6@FindBestTa@7:
	cmp	DWORD PTR _iDirectionLoop$[ebp], 6
	jge	$LN9@FindBestTa@7

; 4174 : 						{
; 4175 : 							pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T240458[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T240462[ebp], eax
	mov	ecx, DWORD PTR _iDirectionLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240458[ebp]
	push	edx
	mov	eax, DWORD PTR $T240462[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 4176 : 							if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN3@FindBestTa@7
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@FindBestTa@7
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@FindBestTa@7

; 4177 : 							{
; 4178 : 								if(pInitialUnit->GeneratePath(pAdjacentPlot, 0, false, &iCurrentTurns))

	lea	eax, DWORD PTR _iCurrentTurns$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@FindBestTa@7

; 4179 : 								{
; 4180 : 									if(iCurrentTurns < iBestTurns)

	mov	eax, DWORD PTR _iCurrentTurns$[ebp]
	cmp	eax, DWORD PTR _iBestTurns$[ebp]
	jge	SHORT $LN3@FindBestTa@7

; 4181 : 									{
; 4182 : 										iBestTurns = iCurrentTurns;

	mov	ecx, DWORD PTR _iCurrentTurns$[ebp]
	mov	DWORD PTR _iBestTurns$[ebp], ecx

; 4183 : 										pBestPlot = pAdjacentPlot;

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], edx
$LN3@FindBestTa@7:

; 4184 : 									}
; 4185 : 								}
; 4186 : 							}
; 4187 : 						}

	jmp	$LN5@FindBestTa@7
$LN9@FindBestTa@7:

; 4188 : 					}
; 4189 : 				}
; 4190 : 			}
; 4191 : 		}

	jmp	$LN11@FindBestTa@7
$LN13@FindBestTa@7:

; 4192 : 	}
; 4193 : 
; 4194 : 	return pBestPlot;

	mov	eax, DWORD PTR _pBestPlot$[ebp]

; 4195 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNavalBombardment::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalSuperiority@@6B@		; CvAIOperationNavalSuperiority::`vftable'
PUBLIC	?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNavalSuperiority::Init
PUBLIC	?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ ; CvAIOperationNavalSuperiority::GetOperationType
PUBLIC	?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ ; CvAIOperationNavalSuperiority::CanTacticalAIInterruptOperation
PUBLIC	?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNavalSuperiority::ArmyInPosition
PUBLIC	?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z ; CvAIOperationNavalSuperiority::Read
PUBLIC	?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z ; CvAIOperationNavalSuperiority::Write
PUBLIC	?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ ; CvAIOperationNavalSuperiority::GetOperationName
PUBLIC	?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ ; CvAIOperationNavalSuperiority::FindBestTarget
EXTRN	??_ECvAIOperationNavalSuperiority@@UAEPAXI@Z:PROC ; CvAIOperationNavalSuperiority::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationNavalSuperiority@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalSuperiority@@6B@ DD FLAT:??_ECvAIOperationNavalSuperiority@@UAEPAXI@Z ; CvAIOperationNavalSuperiority::`vftable'
	DD	FLAT:?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalSuperiority@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationNavalSuperiority@@QAE@XZ PROC		; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority, COMDAT
; _this$ = ecx

; 4203 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAINavalOperation@@QAE@XZ		; CvAINavalOperation::CvAINavalOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalSuperiority@@6B@

; 4204 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationNavalSuperiority@@QAE@XZ ENDP		; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalSuperiority@@UAE@XZ	; CvAIOperationNavalSuperiority::~CvAIOperationNavalSuperiority
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationNavalSuperiority@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationNavalSuperiority@@UAEPAXI@Z PROC	; CvAIOperationNavalSuperiority::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationNavalSuperiority@@UAE@XZ ; CvAIOperationNavalSuperiority::~CvAIOperationNavalSuperiority
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@17
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@17:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationNavalSuperiority@@UAEPAXI@Z ENDP	; CvAIOperationNavalSuperiority::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationNavalSuperiority@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationNavalSuperiority@@UAE@XZ PROC		; CvAIOperationNavalSuperiority::~CvAIOperationNavalSuperiority, COMDAT
; _this$ = ecx

; 4208 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalSuperiority@@6B@

; 4209 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAINavalOperation@@UAE@XZ		; CvAINavalOperation::~CvAINavalOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationNavalSuperiority@@UAE@XZ ENDP		; CvAIOperationNavalSuperiority::~CvAIOperationNavalSuperiority
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T240825 = -100						; size = 4
$T240824 = -96						; size = 4
$T240820 = -92						; size = 4
$T240816 = -88						; size = 4
$T240815 = -84						; size = 4
$T240683 = -16						; size = 4
_pTargetPlot$225152 = -12				; size = 4
_pArmyAI$225149 = -8					; size = 4
_kPlayer$225148 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNavalSuperiority::Init, COMDAT
; _this$ = ecx

; 4213 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 4214 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 4215 : 	m_eMoveType = AI_OPERATION_MOVETYPE_FREEFORM_NAVAL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 3

; 4216 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 4217 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 4218 : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 4219 : 
; 4220 : 	if(iID != -1 && GetOperationStartCity())

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN9@Init@7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	test	eax, eax
	je	$LN9@Init@7

; 4221 : 	{
; 4222 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4223 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225148[ebp], ecx

; 4224 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, DWORD PTR _kPlayer$225148[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225149[ebp], eax

; 4225 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225149[ebp], 0
	je	$LN9@Init@7

; 4226 : 		{
; 4227 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T240683[ebp], eax
	lea	edx, DWORD PTR $T240683[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4228 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4229 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4230 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4231 : 
; 4232 : 			// Figure out the initial rally point
; 4233 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pTargetPlot$225152[ebp], eax

; 4234 : 			if(pTargetPlot != NULL)

	cmp	DWORD PTR _pTargetPlot$225152[ebp], 0
	je	$LN6@Init@7

; 4235 : 			{
; 4236 : 				SetTargetPlot(pTargetPlot);

	mov	ecx, DWORD PTR _pTargetPlot$225152[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 4237 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	mov	edx, DWORD PTR _pTargetPlot$225152[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4238 : 				if(SelectInitialMusterPoint(pArmyAI) != NULL)

	mov	eax, DWORD PTR _pArmyAI$225149[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax
	test	eax, eax
	je	$LN5@Init@7

; 4239 : 				{
; 4240 : 					pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T240815[ebp], eax
	mov	ecx, DWORD PTR $T240815[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240816[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T240820[ebp], eax
	mov	eax, DWORD PTR $T240816[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240820[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4241 : 					SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T240824[ebp], eax
	mov	eax, DWORD PTR $T240824[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T240825[ebp], ecx
	mov	edx, DWORD PTR $T240825[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 4242 : 
; 4243 : 					// Find the list of units we need to build before starting this operation in earnest
; 4244 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 4245 : 
; 4246 : 					// try to get as many units as possible from existing units that are waiting around
; 4247 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetMusterPlot()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Init@7

; 4248 : 					{
; 4249 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$225149[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4250 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 3

; 4251 : 					}
; 4252 : 					else

	jmp	SHORT $LN3@Init@7
$LN4@Init@7:

; 4253 : 					{
; 4254 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN3@Init@7:

; 4255 : 					}
; 4256 : 
; 4257 : 					LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart

; 4258 : 				}
; 4259 : 				else

	jmp	SHORT $LN2@Init@7
$LN5@Init@7:

; 4260 : 				{
; 4261 : 					// No muster point, abort
; 4262 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 4263 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 7
$LN2@Init@7:

; 4264 : 				}
; 4265 : 			}
; 4266 : 
; 4267 : 			else

	jmp	SHORT $LN9@Init@7
$LN6@Init@7:

; 4268 : 			{
; 4269 : 				// Lost our target, abort
; 4270 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 4271 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 3
$LN9@Init@7:

; 4272 : 			}
; 4273 : 		}
; 4274 : 	}
; 4275 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNavalSuperiority::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalSuperiority::Read, COMDAT
; _this$ = ecx

; 4279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4280 : 	// read the base class' entries
; 4281 : 	CvAINavalOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalOperation::Read

; 4282 : 
; 4283 : 	// Version number to maintain backwards compatibility
; 4284 : 	uint uiVersion;
; 4285 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4286 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalSuperiority::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalSuperiority::Write, COMDAT
; _this$ = ecx

; 4290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4291 : 	// write the base class' entries
; 4292 : 	CvAINavalOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalOperation::Write

; 4293 : 
; 4294 : 	// Current version number
; 4295 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 4296 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4297 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalSuperiority::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -24						; size = 4
_this$ = -20						; size = 4
$T240841 = -16						; size = 4
_pDeployPt$225183 = -12					; size = 4
_possibleBetterTarget$225179 = -8			; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNavalSuperiority::ArmyInPosition, COMDAT
; _this$ = ecx

; 4301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4302 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 4303 : 
; 4304 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	$LN7@ArmyInPosi@9
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN13@ArmyInPosi@9[edx*4]
$LN6@ArmyInPosi@9:

; 4305 : 	{
; 4306 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 4307 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4308 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4309 : 	{
; 4310 : 		// First do base case processing
; 4311 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 4312 : 
; 4313 : 		// Now revisit target
; 4314 : 		CvPlot* possibleBetterTarget;
; 4315 : 		possibleBetterTarget = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _possibleBetterTarget$225179[ebp], eax

; 4316 : 
; 4317 : 		// If no target left, abort
; 4318 : 		if(possibleBetterTarget == NULL)

	cmp	DWORD PTR _possibleBetterTarget$225179[ebp], 0
	jne	SHORT $LN5@ArmyInPosi@9

; 4319 : 		{
; 4320 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 4321 : 			m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 1
	jmp	SHORT $LN4@ArmyInPosi@9
$LN5@ArmyInPosi@9:

; 4322 : 		}
; 4323 : 
; 4324 : 		// If target changed, reset to this new one
; 4325 : 		else if(possibleBetterTarget != GetTargetPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _possibleBetterTarget$225179[ebp], eax
	je	SHORT $LN4@ArmyInPosi@9

; 4326 : 		{
; 4327 : 			// Reset our destination to be a few plots shy of the final target
; 4328 : 			CvPlot* pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), possibleBetterTarget, GetDeployRange(), false);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T240841[ebp], ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	call	edx
	push	eax
	mov	eax, DWORD PTR _possibleBetterTarget$225179[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	ecx, DWORD PTR $T240841[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	mov	DWORD PTR _pDeployPt$225183[ebp], eax

; 4329 : 			if(pDeployPt != NULL)

	cmp	DWORD PTR _pDeployPt$225183[ebp], 0
	je	SHORT $LN4@ArmyInPosi@9

; 4330 : 			{
; 4331 : 				pArmy->SetGoalPlot(pDeployPt);

	mov	edx, DWORD PTR _pDeployPt$225183[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4332 : 				SetTargetPlot(possibleBetterTarget);

	mov	eax, DWORD PTR _possibleBetterTarget$225179[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot
$LN4@ArmyInPosi@9:

; 4333 : 			}
; 4334 : 		}
; 4335 : 	}
; 4336 : 	break;

	jmp	SHORT $LN7@ArmyInPosi@9
$LN1@ArmyInPosi@9:

; 4337 : 
; 4338 : 		// In all other cases use base class version
; 4339 : 	case AI_OPERATION_STATE_ABORTED:
; 4340 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4341 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4342 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	jmp	SHORT $LN9@ArmyInPosi@9
$LN7@ArmyInPosi@9:

; 4343 : 		break;
; 4344 : 	};
; 4345 : 
; 4346 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
$LN9@ArmyInPosi@9:

; 4347 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN13@ArmyInPosi@9:
	DD	$LN1@ArmyInPosi@9
	DD	$LN1@ArmyInPosi@9
	DD	$LN6@ArmyInPosi@9
	DD	$LN6@ArmyInPosi@9
	DD	$LN1@ArmyInPosi@9
?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNavalSuperiority::ArmyInPosition
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back
PUBLIC	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
PUBLIC	__$ArrayPad$
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ$0
__ehfuncinfo$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
tv366 = -596						; size = 4
tv365 = -592						; size = 4
_this$ = -588						; size = 4
$T241347 = -484						; size = 4
$T241343 = -480						; size = 4
$T241183 = -404						; size = 4
$T241182 = -400						; size = 4
$T241178 = -396						; size = 4
$T241177 = -392						; size = 4
$T241173 = -388						; size = 4
$T241114 = -328						; size = 4
$T241105 = -324						; size = 4
$T241096 = -320						; size = 4
$T241092 = -316						; size = 4
$T241088 = -312						; size = 4
$T241047 = -264						; size = 4
$T241038 = -260						; size = 4
$T241029 = -256						; size = 4
$T241020 = -252						; size = 4
$T241011 = -248						; size = 4
_weightedElem$240992 = -236				; size = 8
$T240983 = -225						; size = 1
$T240974 = -224						; size = 4
$T240928 = -176						; size = 4
$T240924 = -172						; size = 4
_uiOffset$240916 = -168					; size = 4
$T240907 = -164						; size = 4
$T240895 = -160						; size = 4
$T240891 = -156						; size = 4
$T240887 = -152						; size = 4
$T240855 = -148						; size = 4
$T240846 = -144						; size = 4
_pAdjacentPlot$225501 = -140				; size = 4
_iDirectionLoop$225497 = -136				; size = 4
_pAdjacentPlot$225491 = -132				; size = 4
_iDirectionLoop$225487 = -128				; size = 4
_iScore$225472 = -124					; size = 4
_pLoopUnit$225470 = -120				; size = 4
_iPlotDistance$225466 = -116				; size = 4
_iBestTurns$225483 = -112				; size = 4
_iUnitY$225458 = -108					; size = 4
_iBaseMoves$225459 = -104				; size = 4
_iUnitX$225457 = -100					; size = 4
_aPlotList$225456 = -96					; size = 24
__$ArrayPad$ = -72					; size = 4
_iUnitID$225452 = -68					; size = 4
_pThisArmy$225451 = -64					; size = 4
_iDistance$ = -60					; size = 4
_iClosestCampDistance$ = -56				; size = 4
_pPlot$ = -52						; size = 4
_pCoastalBarbarianCamp$ = -48				; size = 4
_pEnemyCoastalCity$ = -44				; size = 4
_iPlotLoop$ = -40					; size = 4
_pBestPlot$ = -36					; size = 4
_pCity$ = -32						; size = 4
_owningPlayer$ = -28					; size = 4
_pInitialUnit$ = -24					; size = 4
_iUnitLoop$ = -20					; size = 4
_iClosestEnemyDistance$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNavalSuperiority::FindBestTarget, COMDAT
; _this$ = ecx

; 4416 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 584				; 00000248H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4417 : #ifdef AUI_WARNING_FIXES
; 4418 : 	uint iPlotLoop, iUnitLoop;
; 4419 : #else
; 4420 : 	int iPlotLoop, iUnitLoop;
; 4421 : #endif
; 4422 : 	CvPlot* pPlot;
; 4423 : 	CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 4424 : 	CvUnit* pInitialUnit;
; 4425 : 	CvCity* pCity;
; 4426 : 	CvCity* pEnemyCoastalCity = NULL;

	mov	DWORD PTR _pEnemyCoastalCity$[ebp], 0

; 4427 : 	CvPlot* pCoastalBarbarianCamp = NULL;

	mov	DWORD PTR _pCoastalBarbarianCamp$[ebp], 0

; 4428 : 	int iClosestEnemyDistance = MAX_INT;

	mov	DWORD PTR _iClosestEnemyDistance$[ebp], 2147483647 ; 7fffffffH

; 4429 : 	int iClosestCampDistance = MAX_INT;

	mov	DWORD PTR _iClosestCampDistance$[ebp], 2147483647 ; 7fffffffH

; 4430 : 	int iDistance;
; 4431 : 	CvPlayer& owningPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$[ebp], ecx

; 4432 : 
; 4433 : 	if(GetFirstArmyID() == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFirstArmyID@CvAIOperation@@QAEHXZ	; CvAIOperation::GetFirstArmyID
	cmp	eax, -1
	jne	SHORT $LN39@FindBestTa@8

; 4434 : 	{
; 4435 : 		pInitialUnit = FindInitialUnit();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx
	mov	DWORD PTR _pInitialUnit$[ebp], eax

; 4436 : 	}
; 4437 : 	else

	jmp	SHORT $LN38@FindBestTa@8
$LN39@FindBestTa@8:

; 4438 : 	{
; 4439 : 		CvArmyAI* pThisArmy = owningPlayer.getArmyAI(m_viArmyIDs[0]);

	xor	eax, eax
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240855[ebp], eax
	mov	edx, DWORD PTR $T240855[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _owningPlayer$[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$225451[ebp], eax

; 4440 : 		int iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pThisArmy$225451[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$225452[ebp], eax

; 4441 : 		if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$225452[ebp], -1
	je	SHORT $LN37@FindBestTa@8

; 4442 : 		{
; 4443 : 			pInitialUnit = owningPlayer.getUnit(iUnitID);

	mov	ecx, DWORD PTR _iUnitID$225452[ebp]
	push	ecx
	mov	ecx, DWORD PTR _owningPlayer$[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pInitialUnit$[ebp], eax

; 4444 : 		}
; 4445 : 		else

	jmp	SHORT $LN38@FindBestTa@8
$LN37@FindBestTa@8:

; 4446 : 		{
; 4447 : 			pInitialUnit = FindInitialUnit();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+152]
	call	edx
	mov	DWORD PTR _pInitialUnit$[ebp], eax
$LN38@FindBestTa@8:

; 4448 : 		}
; 4449 : 	}
; 4450 : 
; 4451 : 	if(pInitialUnit != NULL)

	cmp	DWORD PTR _pInitialUnit$[ebp], 0
	je	$LN35@FindBestTa@8

; 4452 : 	{
; 4453 : 		WeightedPlotVector aPlotList;

	lea	ecx, DWORD PTR _aPlotList$225456[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4454 : 		aPlotList.reserve(64);

	push	64					; 00000040H
	lea	ecx, DWORD PTR _aPlotList$225456[ebp]
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit

; 4455 : 
; 4456 : 		int iUnitX = pInitialUnit->getX();

	mov	eax, DWORD PTR _pInitialUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _iUnitX$225457[ebp], ecx

; 4457 : 		int iUnitY = pInitialUnit->getY();

	mov	edx, DWORD PTR _pInitialUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR _iUnitY$225458[ebp], eax

; 4458 : 		int iBaseMoves = pInitialUnit->baseMoves();

	push	-1
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	mov	DWORD PTR _iBaseMoves$225459[ebp], eax

; 4459 : 
; 4460 : 		// Look at map for enemy naval units
; 4461 : 		for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$[ebp], 0
	jmp	SHORT $LN34@FindBestTa@8
$LN33@FindBestTa@8:
	mov	ecx, DWORD PTR _iPlotLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlotLoop$[ebp], ecx
$LN34@FindBestTa@8:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240887[ebp], edx
	mov	eax, DWORD PTR $T240887[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T240891[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	cmp	edx, DWORD PTR $T240891[ebp]
	jge	$LN32@FindBestTa@8

; 4462 : 		{
; 4463 : 			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240895[ebp], eax
	mov	ecx, DWORD PTR _iPlotLoop$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T240895[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$[ebp], ecx

; 4464 : 
; 4465 : 			if(pPlot->isRevealed(owningPlayer.getTeam()))

	mov	eax, DWORD PTR _owningPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240907[ebp], eax
	mov	edx, DWORD PTR $T240907[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$240916[ebp], edx
	mov	eax, DWORD PTR _uiOffset$240916[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T240907[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$240916[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN31@FindBestTa@8

; 4466 : 			{
; 4467 : 				if(pPlot->isWater())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN30@FindBestTa@8

; 4468 : 				{
; 4469 : 					if(pPlot->getNumUnits() > 0)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN29@FindBestTa@8

; 4470 : 					{
; 4471 : 						int iPlotDistance = plotDistance(iUnitX, iUnitY, pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T240924[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T240928[ebp], edx
	mov	eax, DWORD PTR $T240924[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240928[ebp]
	push	ecx
	mov	edx, DWORD PTR _iUnitY$225458[ebp]
	push	edx
	mov	eax, DWORD PTR _iUnitX$225457[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$225466[ebp], eax

; 4472 : 						for(iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$[ebp], 0
	jmp	SHORT $LN28@FindBestTa@8
$LN27@FindBestTa@8:
	mov	ecx, DWORD PTR _iUnitLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iUnitLoop$[ebp], ecx
$LN28@FindBestTa@8:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$[ebp], eax
	jge	$LN29@FindBestTa@8

; 4473 : 						{
; 4474 : 							CvUnit* pLoopUnit = pPlot->getUnitByIndex(iUnitLoop);

	mov	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pLoopUnit$225470[ebp], eax

; 4475 : 							{
; 4476 : 								if(pLoopUnit->isEnemy(owningPlayer.getTeam()))

	mov	eax, DWORD PTR _owningPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240974[ebp], eax
	push	0
	mov	edx, DWORD PTR $T240974[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$225470[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	movzx	eax, al
	test	eax, eax
	je	$LN25@FindBestTa@8

; 4477 : 								{
; 4478 : 									int iScore = iBaseMoves * iPlotDistance;

	mov	ecx, DWORD PTR _iBaseMoves$225459[ebp]
	imul	ecx, DWORD PTR _iPlotDistance$225466[ebp]
	mov	DWORD PTR _iScore$225472[ebp], ecx

; 4479 : 									if (pLoopUnit->isTrade()) // we want to plunder trade routes of possible

	mov	ecx, DWORD PTR _pLoopUnit$225470[ebp]
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN115@FindBestTa@8

; 4480 : 									{
; 4481 : 										iScore /= 3;

	mov	eax, DWORD PTR _iScore$225472[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _iScore$225472[ebp], eax

; 4482 : 									}
; 4483 : 									if (pLoopUnit->isEmbarked()) // we want to take out embarked units more than ships

$LN115@FindBestTa@8:
	mov	edx, DWORD PTR _pLoopUnit$225470[ebp]
	mov	al, BYTE PTR [edx+1652]
	mov	BYTE PTR $T240983[ebp], al
	movzx	ecx, BYTE PTR $T240983[ebp]
	test	ecx, ecx
	je	SHORT $LN23@FindBestTa@8

; 4484 : 									{
; 4485 : 										iScore = (iScore * 2) / 3;

	mov	eax, DWORD PTR _iScore$225472[ebp]
	shl	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _iScore$225472[ebp], eax
$LN23@FindBestTa@8:

; 4486 : 									}
; 4487 : 
; 4488 : 									aPlotList.push_back(pPlot, iScore);

	mov	DWORD PTR _weightedElem$240992[ebp], 0
	mov	DWORD PTR _weightedElem$240992[ebp+4], 0
	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	DWORD PTR _weightedElem$240992[ebp], edx
	mov	eax, DWORD PTR _iScore$225472[ebp]
	mov	DWORD PTR _weightedElem$240992[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$240992[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aPlotList$225456[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back
$LN25@FindBestTa@8:

; 4489 : 								}
; 4490 : 							}
; 4491 : 						}

	jmp	$LN27@FindBestTa@8
$LN29@FindBestTa@8:

; 4492 : 					}
; 4493 : 				}

	jmp	$LN31@FindBestTa@8
$LN30@FindBestTa@8:

; 4494 : 
; 4495 : 				// Backup plan is a coastal enemy city
; 4496 : 				else if(pPlot->isCity() && pPlot->isCoastalLand())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	je	$LN21@FindBestTa@8
	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	je	$LN21@FindBestTa@8

; 4497 : 				{
; 4498 : 					pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 4499 : 					if(pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN20@FindBestTa@8

; 4500 : 					{
; 4501 : 						if(atWar(owningPlayer.getTeam(), pCity->getTeam()))

	mov	ecx, DWORD PTR _owningPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T241011[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	eax, DWORD PTR $T241011[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@FindBestTa@8

; 4502 : 						{
; 4503 : 							iDistance = plotDistance(pInitialUnit->getX(), pInitialUnit->getY(), pCity->getX(), pCity->getY());

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T241020[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T241029[ebp], edx
	mov	eax, DWORD PTR _pInitialUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T241038[ebp], ecx
	mov	edx, DWORD PTR _pInitialUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T241047[ebp], eax
	mov	ecx, DWORD PTR $T241020[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241029[ebp]
	push	edx
	mov	eax, DWORD PTR $T241038[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241047[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$[ebp], eax

; 4504 : 							if(iDistance < iClosestEnemyDistance)

	mov	edx, DWORD PTR _iDistance$[ebp]
	cmp	edx, DWORD PTR _iClosestEnemyDistance$[ebp]
	jge	SHORT $LN20@FindBestTa@8

; 4505 : 							{
; 4506 : 								iClosestEnemyDistance = iDistance;

	mov	eax, DWORD PTR _iDistance$[ebp]
	mov	DWORD PTR _iClosestEnemyDistance$[ebp], eax

; 4507 : 								pEnemyCoastalCity = pCity;

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	DWORD PTR _pEnemyCoastalCity$[ebp], ecx
$LN20@FindBestTa@8:

; 4508 : 							}
; 4509 : 						}
; 4510 : 					}
; 4511 : 				}

	jmp	$LN31@FindBestTa@8
$LN21@FindBestTa@8:

; 4512 : 
; 4513 : 				else if(pPlot->isCoastalLand() && pPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	edx, al
	test	edx, edx
	je	$LN31@FindBestTa@8
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T241088[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR $T241088[ebp]
	jne	SHORT $LN31@FindBestTa@8

; 4514 : 				{
; 4515 : 					iDistance = plotDistance(pInitialUnit->getX(), pInitialUnit->getY(), pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T241092[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T241096[ebp], ecx
	mov	edx, DWORD PTR _pInitialUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T241105[ebp], eax
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T241114[ebp], edx
	mov	eax, DWORD PTR $T241092[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241096[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241105[ebp]
	push	edx
	mov	eax, DWORD PTR $T241114[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$[ebp], eax

; 4516 : 					if(iDistance < iClosestCampDistance)

	mov	ecx, DWORD PTR _iDistance$[ebp]
	cmp	ecx, DWORD PTR _iClosestCampDistance$[ebp]
	jge	SHORT $LN31@FindBestTa@8

; 4517 : 					{
; 4518 : 						iClosestCampDistance = iDistance;

	mov	edx, DWORD PTR _iDistance$[ebp]
	mov	DWORD PTR _iClosestCampDistance$[ebp], edx

; 4519 : 						pCoastalBarbarianCamp = pPlot;

	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	DWORD PTR _pCoastalBarbarianCamp$[ebp], eax
$LN31@FindBestTa@8:

; 4520 : 					}
; 4521 : 				}
; 4522 : 			}
; 4523 : 		}

	jmp	$LN33@FindBestTa@8
$LN32@FindBestTa@8:

; 4524 : 
; 4525 : 		int iBestTurns;
; 4526 : 		pBestPlot = GetReachablePlot(pInitialUnit, aPlotList, &iBestTurns);

	lea	ecx, DWORD PTR _iBestTurns$225483[ebp]
	push	ecx
	lea	edx, DWORD PTR _aPlotList$225456[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T240846[ebp], esp
	mov	DWORD PTR $T241173[ebp], eax
	mov	ecx, DWORD PTR $T241173[ebp]
	mov	edx, DWORD PTR _pInitialUnit$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T241173[ebp]
	mov	BYTE PTR [eax+4], 0
	mov	ecx, DWORD PTR $T241173[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN222@FindBestTa@8
	mov	edx, DWORD PTR $T241173[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN222@FindBestTa@8:
	mov	eax, DWORD PTR $T241173[ebp]
	mov	DWORD PTR tv365[ebp], eax
	call	?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z ; GetReachablePlot
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv366[ebp], eax
	mov	ecx, DWORD PTR tv366[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], ecx

; 4527 : 
; 4528 : 		// None found, patrol over near closest enemy coastal city, or if not that a water tile adjacent to a camp
; 4529 : 		if(pBestPlot == NULL)

	cmp	DWORD PTR _pBestPlot$[ebp], 0
	jne	$LN14@FindBestTa@8

; 4530 : 		{
; 4531 : 			if(pEnemyCoastalCity != NULL)

	cmp	DWORD PTR _pEnemyCoastalCity$[ebp], 0
	je	$LN13@FindBestTa@8

; 4532 : 			{
; 4533 : 				// Find a coastal water tile adjacent to enemy city
; 4534 : 				for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$225487[ebp], 0
	jmp	SHORT $LN12@FindBestTa@8
$LN11@FindBestTa@8:
	mov	edx, DWORD PTR _iDirectionLoop$225487[ebp]
	add	edx, 1
	mov	DWORD PTR _iDirectionLoop$225487[ebp], edx
$LN12@FindBestTa@8:
	cmp	DWORD PTR _iDirectionLoop$225487[ebp], 6
	jge	$LN10@FindBestTa@8

; 4535 : 				{
; 4536 : 					CvPlot* pAdjacentPlot = plotDirection(pEnemyCoastalCity->plot()->getX(), pEnemyCoastalCity->plot()->getY(), ((DirectionTypes)iDirectionLoop));

	mov	ecx, DWORD PTR _pEnemyCoastalCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T241177[ebp], eax
	mov	eax, DWORD PTR $T241177[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T241178[ebp], ecx
	mov	ecx, DWORD PTR _pEnemyCoastalCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T241182[ebp], eax
	mov	edx, DWORD PTR $T241182[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T241183[ebp], eax
	mov	ecx, DWORD PTR _iDirectionLoop$225487[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241178[ebp]
	push	edx
	mov	eax, DWORD PTR $T241183[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$225491[ebp], eax

; 4537 : 					if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	cmp	DWORD PTR _pAdjacentPlot$225491[ebp], 0
	je	SHORT $LN9@FindBestTa@8
	mov	ecx, DWORD PTR _pAdjacentPlot$225491[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@FindBestTa@8
	mov	ecx, DWORD PTR _pAdjacentPlot$225491[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@FindBestTa@8

; 4538 : 					{
; 4539 : 						if(pInitialUnit->GeneratePath(pAdjacentPlot))

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pAdjacentPlot$225491[ebp]
	push	eax
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@FindBestTa@8

; 4540 : 						{
; 4541 : 							pBestPlot = pAdjacentPlot;

	mov	edx, DWORD PTR _pAdjacentPlot$225491[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], edx
$LN9@FindBestTa@8:

; 4542 : 						}
; 4543 : 					}
; 4544 : 				}

	jmp	$LN11@FindBestTa@8
$LN10@FindBestTa@8:

; 4545 : 			}
; 4546 : 
; 4547 : 			else

	jmp	$LN14@FindBestTa@8
$LN13@FindBestTa@8:

; 4548 : 			{
; 4549 : 				if(pCoastalBarbarianCamp != NULL)

	cmp	DWORD PTR _pCoastalBarbarianCamp$[ebp], 0
	je	$LN14@FindBestTa@8

; 4550 : 				{
; 4551 : 					// Find a coastal water tile adjacent to camp
; 4552 : 					for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$225497[ebp], 0
	jmp	SHORT $LN5@FindBestTa@8
$LN4@FindBestTa@8:
	mov	eax, DWORD PTR _iDirectionLoop$225497[ebp]
	add	eax, 1
	mov	DWORD PTR _iDirectionLoop$225497[ebp], eax
$LN5@FindBestTa@8:
	cmp	DWORD PTR _iDirectionLoop$225497[ebp], 6
	jge	$LN14@FindBestTa@8

; 4553 : 					{
; 4554 : 						CvPlot* pAdjacentPlot = plotDirection(pCoastalBarbarianCamp->getX(), pCoastalBarbarianCamp->getY(), ((DirectionTypes)iDirectionLoop));

	mov	ecx, DWORD PTR _pCoastalBarbarianCamp$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T241343[ebp], edx
	mov	eax, DWORD PTR _pCoastalBarbarianCamp$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T241347[ebp], ecx
	mov	edx, DWORD PTR _iDirectionLoop$225497[ebp]
	push	edx
	mov	eax, DWORD PTR $T241343[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241347[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$225501[ebp], eax

; 4555 : 						if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	cmp	DWORD PTR _pAdjacentPlot$225501[ebp], 0
	je	SHORT $LN2@FindBestTa@8
	mov	edx, DWORD PTR _pAdjacentPlot$225501[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@FindBestTa@8
	mov	ecx, DWORD PTR _pAdjacentPlot$225501[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@FindBestTa@8

; 4556 : 						{
; 4557 : 							if(pInitialUnit->GeneratePath(pAdjacentPlot))

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pAdjacentPlot$225501[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pInitialUnit$[ebp]
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@FindBestTa@8

; 4558 : 							{
; 4559 : 								pBestPlot = pAdjacentPlot;

	mov	eax, DWORD PTR _pAdjacentPlot$225501[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], eax
$LN2@FindBestTa@8:

; 4560 : 							}
; 4561 : 						}
; 4562 : 					}

	jmp	$LN4@FindBestTa@8
$LN14@FindBestTa@8:

; 4563 : 				}
; 4564 : 			}
; 4565 : 		}
; 4566 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aPlotList$225456[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
$LN35@FindBestTa@8:

; 4567 : 
; 4568 : 	return pBestPlot;

	mov	eax, DWORD PTR _pBestPlot$[ebp]

; 4569 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ$0:
	lea	ecx, DWORD PTR _aPlotList$225456[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
__ehhandler$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-588]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNavalSuperiority::FindBestTarget
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z$0
__ehfuncinfo$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
_TEXT	SEGMENT
tv170 = -108						; size = 4
tv169 = -104						; size = 4
tv163 = -100						; size = 4
tv162 = -96						; size = 4
$T241674 = -92						; size = 4
$T241664 = -88						; size = 4
_elem$241649 = -84					; size = 8
$T241621 = -76						; size = 4
$T241617 = -72						; size = 4
$T241608 = -68						; size = 4
$T241600 = -64						; size = 4
$T241599 = -60						; size = 4
$T241598 = -56						; size = 4
$T241597 = -52						; size = 4
_iTurnsCalculated$225426 = -48				; size = 4
_iTurnsCalculated$225420 = -44				; size = 4
_pPlot$225416 = -40					; size = 4
_iWeight$225417 = -36					; size = 4
_i$225412 = -32						; size = 4
_iFoundWeight$ = -28					; size = 4
_uiListSize$ = -24					; size = 4
_pFoundPlot$ = -20					; size = 4
_iFoundTurns$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_aPlots$ = 16						; size = 4
_iTurns$ = 20						; size = 4
?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z PROC ; GetReachablePlot, COMDAT

; 4355 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4356 : 	CvPlot *pFoundPlot = NULL;

	mov	DWORD PTR _pFoundPlot$[ebp], 0

; 4357 : 	int iFoundWeight = 0;

	mov	DWORD PTR _iFoundWeight$[ebp], 0

; 4358 : 	int iFoundTurns = 0;

	mov	DWORD PTR _iFoundTurns$[ebp], 0

; 4359 : 	uint uiListSize;	
; 4360 : 	if ((uiListSize = aPlots.size()) > 0)

	mov	eax, DWORD PTR _aPlots$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241608[ebp], ecx
	mov	edx, DWORD PTR $T241608[ebp]
	mov	DWORD PTR _uiListSize$[ebp], edx
	cmp	DWORD PTR _uiListSize$[ebp], 0
	jbe	$LN13@GetReachab

; 4361 : 	{
; 4362 : 		aPlots.SortItems();

	mov	eax, DWORD PTR _aPlots$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _aPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T241617[ebp], ecx
	mov	edx, DWORD PTR _aPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241621[ebp], eax
	mov	ecx, DWORD PTR $T241617[ebp]
	sub	ecx, DWORD PTR $T241621[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T241617[ebp]
	push	edx
	mov	eax, DWORD PTR $T241621[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 4363 : 
; 4364 : 		// This will check all the plots that have the same weight.  It will mean a few more path-finds, but it will
; 4365 : 		// be more accurate.
; 4366 : 		for (uint i = uiListSize; i--; )		// Go backward, the CvWeightedVector sorts highest to lowest

	mov	ecx, DWORD PTR _uiListSize$[ebp]
	mov	DWORD PTR _i$225412[ebp], ecx
$LN12@GetReachab:
	mov	edx, DWORD PTR _i$225412[ebp]
	mov	eax, DWORD PTR _i$225412[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$225412[ebp], eax
	test	edx, edx
	je	$LN13@GetReachab

; 4367 : 		{
; 4368 : 			CvPlot* pPlot = aPlots.GetElement(i);

	mov	ecx, DWORD PTR _aPlots$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$225412[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _pPlot$225416[ebp], ecx

; 4369 : 			int iWeight = aPlots.GetWeight(i);

	mov	DWORD PTR _elem$241649[ebp], 0
	mov	DWORD PTR _elem$241649[ebp+4], 0
	mov	edx, DWORD PTR _aPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$225412[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$241649[ebp], edx
	mov	DWORD PTR _elem$241649[ebp+4], eax
	mov	ecx, DWORD PTR _elem$241649[ebp+4]
	mov	DWORD PTR _iWeight$225417[ebp], ecx

; 4370 : 
; 4371 : 			if (pFoundPlot)

	cmp	DWORD PTR _pFoundPlot$[ebp], 0
	je	$LN10@GetReachab

; 4372 : 			{
; 4373 : 				if (iWeight > iFoundWeight)

	mov	edx, DWORD PTR _iWeight$225417[ebp]
	cmp	edx, DWORD PTR _iFoundWeight$[ebp]
	jle	SHORT $LN9@GetReachab

; 4374 : 					break;		// Already found one of a lower weight

	jmp	$LN13@GetReachab
$LN9@GetReachab:

; 4375 : 			
; 4376 : 				int iTurnsCalculated = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, false);

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _pPlot$225416[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T241597[ebp], esp
	mov	DWORD PTR $T241664[ebp], ecx
	mov	edx, DWORD PTR $T241664[ebp]
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T241664[ebp]
	mov	dl, BYTE PTR _pUnit$[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T241664[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN42@GetReachab
	mov	ecx, DWORD PTR $T241664[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN42@GetReachab:
	mov	edx, DWORD PTR $T241664[ebp]
	mov	DWORD PTR tv162[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv163[ebp], eax
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR _iTurnsCalculated$225420[ebp], eax

; 4377 : 				if (iTurnsCalculated != MAX_INT)

	cmp	DWORD PTR _iTurnsCalculated$225420[ebp], 2147483647 ; 7fffffffH
	je	SHORT $LN8@GetReachab

; 4378 : 				{
; 4379 : 					if (iTurnsCalculated < iFoundTurns)

	mov	ecx, DWORD PTR _iTurnsCalculated$225420[ebp]
	cmp	ecx, DWORD PTR _iFoundTurns$[ebp]
	jge	SHORT $LN8@GetReachab

; 4380 : 					{
; 4381 : 						iFoundWeight = iWeight;

	mov	edx, DWORD PTR _iWeight$225417[ebp]
	mov	DWORD PTR _iFoundWeight$[ebp], edx

; 4382 : 						pFoundPlot = pPlot;

	mov	eax, DWORD PTR _pPlot$225416[ebp]
	mov	DWORD PTR _pFoundPlot$[ebp], eax

; 4383 : 						iFoundTurns = iTurnsCalculated;

	mov	ecx, DWORD PTR _iTurnsCalculated$225420[ebp]
	mov	DWORD PTR _iFoundTurns$[ebp], ecx

; 4384 : 						if (iFoundTurns == 1)

	cmp	DWORD PTR _iFoundTurns$[ebp], 1
	jne	SHORT $LN8@GetReachab

; 4385 : 							break;		// Not getting better than this

	jmp	SHORT $LN13@GetReachab
$LN8@GetReachab:

; 4386 : 					}
; 4387 : 				}
; 4388 : 			}
; 4389 : 			else

	jmp	SHORT $LN5@GetReachab
$LN10@GetReachab:

; 4390 : 			{
; 4391 : 				int iTurnsCalculated = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, false);

	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _pPlot$225416[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T241598[ebp], esp
	mov	DWORD PTR $T241674[ebp], eax
	mov	ecx, DWORD PTR $T241674[ebp]
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T241674[ebp]
	mov	cl, BYTE PTR _pUnit$[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T241674[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN47@GetReachab
	mov	eax, DWORD PTR $T241674[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN47@GetReachab:
	mov	ecx, DWORD PTR $T241674[ebp]
	mov	DWORD PTR tv169[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv170[ebp], eax
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR _iTurnsCalculated$225426[ebp], edx

; 4392 : 				if (iTurnsCalculated != MAX_INT)

	cmp	DWORD PTR _iTurnsCalculated$225426[ebp], 2147483647 ; 7fffffffH
	je	SHORT $LN5@GetReachab

; 4393 : 				{
; 4394 : 					iFoundWeight = iWeight;

	mov	eax, DWORD PTR _iWeight$225417[ebp]
	mov	DWORD PTR _iFoundWeight$[ebp], eax

; 4395 : 					pFoundPlot = pPlot;

	mov	ecx, DWORD PTR _pPlot$225416[ebp]
	mov	DWORD PTR _pFoundPlot$[ebp], ecx

; 4396 : 					iFoundTurns = iTurnsCalculated;

	mov	edx, DWORD PTR _iTurnsCalculated$225426[ebp]
	mov	DWORD PTR _iFoundTurns$[ebp], edx

; 4397 : 					if (iFoundTurns == 1)

	cmp	DWORD PTR _iFoundTurns$[ebp], 1
	jne	SHORT $LN5@GetReachab

; 4398 : 						break;		// Not getting better than this

	jmp	SHORT $LN13@GetReachab
$LN5@GetReachab:

; 4399 : 				}
; 4400 : 			}
; 4401 : 		}

	jmp	$LN12@GetReachab
$LN13@GetReachab:

; 4402 : 	}
; 4403 : 
; 4404 : 	if (pFoundPlot)

	cmp	DWORD PTR _pFoundPlot$[ebp], 0
	je	SHORT $LN2@GetReachab

; 4405 : 	{
; 4406 : 		if (iTurns)

	cmp	DWORD PTR _iTurns$[ebp], 0
	je	SHORT $LN1@GetReachab

; 4407 : 			*iTurns = iFoundTurns;

	mov	eax, DWORD PTR _iTurns$[ebp]
	mov	ecx, DWORD PTR _iFoundTurns$[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@GetReachab:

; 4408 : 		return pFoundPlot;

	mov	edx, DWORD PTR _pFoundPlot$[ebp]
	mov	DWORD PTR $T241599[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN52@GetReachab
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN52@GetReachab:
	mov	eax, DWORD PTR $T241599[ebp]
	jmp	SHORT $LN14@GetReachab
$LN2@GetReachab:

; 4409 : 	}
; 4410 : 
; 4411 : 	return NULL;

	mov	DWORD PTR $T241600[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN57@GetReachab
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@GetReachab:
	mov	eax, DWORD PTR $T241600[ebp]
$LN14@GetReachab:

; 4412 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z ENDP ; GetReachablePlot
PUBLIC	??_7CvAIOperationPureNavalCityAttack@@6B@	; CvAIOperationPureNavalCityAttack::`vftable'
PUBLIC	?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationPureNavalCityAttack::Init
PUBLIC	?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ ; CvAIOperationPureNavalCityAttack::GetOperationType
PUBLIC	?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ ; CvAIOperationPureNavalCityAttack::CanTacticalAIInterruptOperation
PUBLIC	?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationPureNavalCityAttack::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationPureNavalCityAttack::ArmyInPosition
PUBLIC	?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ ; CvAIOperationPureNavalCityAttack::ShouldAbort
PUBLIC	?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationPureNavalCityAttack::Read
PUBLIC	?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationPureNavalCityAttack::Write
PUBLIC	?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationPureNavalCityAttack::GetOperationName
PUBLIC	?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ ; CvAIOperationPureNavalCityAttack::GetDeployRange
PUBLIC	?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationPureNavalCityAttack::FindBestTarget
EXTRN	??_ECvAIOperationPureNavalCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationPureNavalCityAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationPureNavalCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationPureNavalCityAttack@@6B@ DD FLAT:??_ECvAIOperationPureNavalCityAttack@@UAEPAXI@Z ; CvAIOperationPureNavalCityAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationPureNavalCityAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationPureNavalCityAttack@@QAE@XZ PROC	; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack, COMDAT
; _this$ = ecx

; 4577 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAINavalOperation@@QAE@XZ		; CvAINavalOperation::CvAINavalOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationPureNavalCityAttack@@6B@

; 4578 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationPureNavalCityAttack@@QAE@XZ ENDP	; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack
_TEXT	ENDS
PUBLIC	??1CvAIOperationPureNavalCityAttack@@UAE@XZ	; CvAIOperationPureNavalCityAttack::~CvAIOperationPureNavalCityAttack
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationPureNavalCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationPureNavalCityAttack@@UAEPAXI@Z PROC	; CvAIOperationPureNavalCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationPureNavalCityAttack@@UAE@XZ ; CvAIOperationPureNavalCityAttack::~CvAIOperationPureNavalCityAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@18
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@18:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationPureNavalCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationPureNavalCityAttack::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationPureNavalCityAttack@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationPureNavalCityAttack@@UAE@XZ PROC	; CvAIOperationPureNavalCityAttack::~CvAIOperationPureNavalCityAttack, COMDAT
; _this$ = ecx

; 4582 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationPureNavalCityAttack@@6B@

; 4583 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAINavalOperation@@UAE@XZ		; CvAINavalOperation::~CvAINavalOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationPureNavalCityAttack@@UAE@XZ ENDP	; CvAIOperationPureNavalCityAttack::~CvAIOperationPureNavalCityAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T241850 = -96						; size = 4
$T241846 = -92						; size = 4
$T241845 = -88						; size = 4
$T241841 = -84						; size = 4
$T241709 = -16						; size = 4
_pCoastalMuster$225530 = -12				; size = 4
_pArmyAI$225526 = -8					; size = 4
_kPlayer$225525 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
_pTarget$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationPureNavalCityAttack::Init, COMDAT
; _this$ = ecx

; 4587 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 4588 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 4589 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 1

; 4590 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 4591 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 4592 : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 4593 : 
; 4594 : 	if(iID != -1)

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN9@Init@8

; 4595 : 	{
; 4596 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4597 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225525[ebp], eax

; 4598 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, DWORD PTR _kPlayer$225525[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225526[ebp], eax

; 4599 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225526[ebp], 0
	je	$LN9@Init@8

; 4600 : 		{
; 4601 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T241709[ebp], eax
	lea	ecx, DWORD PTR $T241709[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4602 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4603 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4604 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4605 : 
; 4606 : 			if(pTarget)

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	$LN6@Init@8

; 4607 : 			{
; 4608 : 				SetTargetPlot(pTarget->plot());

	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 4609 : 				pArmyAI->SetGoalPlot(GetTargetPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4610 : 
; 4611 : 				// Muster just off the coast
; 4612 : 				CvPlot *pCoastalMuster = kPlayer.GetMilitaryAI()->GetCoastalPlotAdjacentToTarget(pMuster->plot(), pArmyAI);

	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pMuster$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _kPlayer$225525[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	DWORD PTR _pCoastalMuster$225530[ebp], eax

; 4613 : 				if (pCoastalMuster)

	cmp	DWORD PTR _pCoastalMuster$225530[ebp], 0
	je	$LN5@Init@8

; 4614 : 				{
; 4615 : 					SetDefaultArea(pCoastalMuster->getArea());

	mov	edx, DWORD PTR _pCoastalMuster$225530[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T241841[ebp], eax
	mov	ecx, DWORD PTR $T241841[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 4616 : 					SetStartCityPlot(pCoastalMuster);

	mov	edx, DWORD PTR _pCoastalMuster$225530[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetStartCityPlot

; 4617 : 					SetMusterPlot(GetStartCityPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 4618 : 					pArmyAI->SetXY(GetStartCityPlot()->getX(), GetStartCityPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	DWORD PTR $T241845[ebp], eax
	mov	eax, DWORD PTR $T241845[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T241846[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	DWORD PTR $T241850[ebp], eax
	mov	edx, DWORD PTR $T241846[ebp]
	push	edx
	mov	eax, DWORD PTR $T241850[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4619 : 
; 4620 : 					// Find the list of units we need to build before starting this operation in earnest
; 4621 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 4622 : 
; 4623 : 					// try to get as many units as possible from existing units that are waiting around
; 4624 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetMusterPlot()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Init@8

; 4625 : 					{
; 4626 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$225526[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4627 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 2

; 4628 : 					}
; 4629 : 					else

	jmp	SHORT $LN3@Init@8
$LN4@Init@8:

; 4630 : 					{
; 4631 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN3@Init@8:

; 4632 : 					}
; 4633 : 
; 4634 : 					LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart

; 4635 : 				}
; 4636 : 				else

	jmp	SHORT $LN2@Init@8
$LN5@Init@8:

; 4637 : 				{
; 4638 : 					// No muster point, abort
; 4639 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 4640 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 7
$LN2@Init@8:

; 4641 : 				}
; 4642 : 			}
; 4643 : 
; 4644 : 			else

	jmp	SHORT $LN9@Init@8
$LN6@Init@8:

; 4645 : 			{
; 4646 : 				// Lost our target, abort
; 4647 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 4648 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 3
$LN9@Init@8:

; 4649 : 			}
; 4650 : 		}
; 4651 : 	}
; 4652 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationPureNavalCityAttack::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationPureNavalCityAttack::Read, COMDAT
; _this$ = ecx

; 4656 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4657 : 	// read the base class' entries
; 4658 : 	CvAINavalOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalOperation::Read

; 4659 : 
; 4660 : 	// Version number to maintain backwards compatibility
; 4661 : 	uint uiVersion;
; 4662 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4663 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationPureNavalCityAttack::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationPureNavalCityAttack::Write, COMDAT
; _this$ = ecx

; 4667 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4668 : 	// write the base class' entries
; 4669 : 	CvAINavalOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalOperation::Write

; 4670 : 
; 4671 : 	// Current version number
; 4672 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 4673 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4674 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationPureNavalCityAttack::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T241866 = -4						; size = 4
?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ PROC ; CvAIOperationPureNavalCityAttack::GetDeployRange, COMDAT
; _this$ = ecx

; 4678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4679 : 	return GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	DWORD PTR $T241866[ebp], eax
	mov	eax, DWORD PTR $T241866[ebp]

; 4680 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ ENDP ; CvAIOperationPureNavalCityAttack::GetDeployRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -144						; size = 4
_this$ = -140						; size = 4
$T241971 = -136						; size = 4
$T241967 = -132						; size = 4
$T241963 = -128						; size = 4
$T241959 = -124						; size = 4
$T241952 = -120						; size = 4
$T241948 = -116						; size = 4
$T241944 = -112						; size = 4
$T241940 = -108						; size = 4
$T241891 = -60						; size = 4
$T241890 = -56						; size = 4
$T241886 = -52						; size = 4
$T241885 = -48						; size = 4
$T241881 = -44						; size = 4
$T241880 = -40						; size = 4
$T241876 = -36						; size = 4
$T241875 = -32						; size = 4
_zone$225563 = -28					; size = 20
_pTarget$225559 = -8					; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationPureNavalCityAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 4684 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	DWORD PTR _this$[ebp], ecx

; 4685 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 4686 : 
; 4687 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	$LN6@ArmyInPosi@10
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN66@ArmyInPosi@10[edx*4]
$LN5@ArmyInPosi@10:

; 4688 : 	{
; 4689 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 4690 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4691 : 		{
; 4692 : 			// First do base case processing
; 4693 : 			bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 4694 : 
; 4695 : 			// Is target still under enemy control?
; 4696 : 			CvPlot* pTarget = GetTargetPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR _pTarget$225559[ebp], eax

; 4697 : 			if(pTarget->getOwner() != m_eEnemy)

	mov	ecx, DWORD PTR _pTarget$225559[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+76]
	je	SHORT $LN4@ArmyInPosi@10

; 4698 : 			{
; 4699 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 4700 : 				m_eAbortReason = AI_ABORT_TARGET_ALREADY_CAPTURED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 4
$LN4@ArmyInPosi@10:

; 4701 : 			}
; 4702 : 		}
; 4703 : 		break;

	jmp	$LN6@ArmyInPosi@10
$LN3@ArmyInPosi@10:

; 4704 : 
; 4705 : 		// See if within 2 spaces of our target, if so give control of these units to the tactical AI
; 4706 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4707 : 		{
; 4708 : 			if (plotDistance(pArmy->Plot()->getX(), pArmy->Plot()->getY(), GetTargetPlot()->getX(), GetTargetPlot()->getY()) < 2)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T241875[ebp], eax
	mov	eax, DWORD PTR $T241875[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T241876[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T241880[ebp], eax
	mov	edx, DWORD PTR $T241880[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T241881[ebp], eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	DWORD PTR $T241885[ebp], eax
	mov	ecx, DWORD PTR $T241885[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T241886[ebp], edx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	DWORD PTR $T241890[ebp], eax
	mov	eax, DWORD PTR $T241890[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T241891[ebp], ecx
	mov	edx, DWORD PTR $T241876[ebp]
	push	edx
	mov	eax, DWORD PTR $T241881[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241886[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241891[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jge	$LN2@ArmyInPosi@10

; 4709 : 			{
; 4710 : 				// Notify tactical AI to focus on this area
; 4711 : 				CvTemporaryZone zone;

	mov	DWORD PTR _zone$225563[ebp], 0
	mov	DWORD PTR _zone$225563[ebp+4], 0
	mov	DWORD PTR _zone$225563[ebp+8], 0
	mov	DWORD PTR _zone$225563[ebp+12], 0

; 4712 : 				zone.SetX(GetTargetPlot()->getX());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T241940[ebp], eax
	mov	eax, DWORD PTR $T241940[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T241944[ebp], ecx
	mov	edx, DWORD PTR $T241944[ebp]
	mov	DWORD PTR _zone$225563[ebp], edx

; 4713 : 				zone.SetY(GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T241948[ebp], eax
	mov	eax, DWORD PTR $T241948[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T241952[ebp], ecx
	mov	edx, DWORD PTR $T241952[ebp]
	mov	DWORD PTR _zone$225563[ebp+4], edx

; 4714 : 				zone.SetTargetType(AI_TACTICAL_TARGET_CITY);

	mov	DWORD PTR _zone$225563[ebp+8], 1

; 4715 : 				zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241959[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T241963[ebp], ecx
	mov	ecx, DWORD PTR $T241959[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR $T241963[ebp]
	mov	DWORD PTR $T241967[ebp], eax
	mov	edx, DWORD PTR $T241967[ebp]
	mov	DWORD PTR _zone$225563[ebp+12], edx

; 4716 : 				GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241971[ebp], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _zone$225563[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _zone$225563[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _zone$225563[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _zone$225563[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _zone$225563[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T241971[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 4717 : 
; 4718 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 5
$LN2@ArmyInPosi@10:

; 4719 : 			}
; 4720 : 		}
; 4721 : 		break;

	jmp	SHORT $LN6@ArmyInPosi@10
$LN1@ArmyInPosi@10:

; 4722 : 
; 4723 : 		// In all other cases use base class version
; 4724 : 	case AI_OPERATION_STATE_ABORTED:
; 4725 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4726 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4727 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	jmp	SHORT $LN8@ArmyInPosi@10
$LN6@ArmyInPosi@10:

; 4728 : 		break;
; 4729 : 	};
; 4730 : 
; 4731 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
$LN8@ArmyInPosi@10:

; 4732 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN66@ArmyInPosi@10:
	DD	$LN1@ArmyInPosi@10
	DD	$LN1@ArmyInPosi@10
	DD	$LN5@ArmyInPosi@10
	DD	$LN3@ArmyInPosi@10
	DD	$LN1@ArmyInPosi@10
?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationPureNavalCityAttack::ArmyInPosition
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T241978 = -8						; size = 4
_rtnValue$ = -1						; size = 1
?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ PROC ; CvAIOperationPureNavalCityAttack::ShouldAbort, COMDAT
; _this$ = ecx

; 4736 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4737 : 	// If parent says we're done, don't even check anything else
; 4738 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	BYTE PTR _rtnValue$[ebp], al

; 4739 : 
; 4740 : 	if(!rtnValue)

	movzx	eax, BYTE PTR _rtnValue$[ebp]
	test	eax, eax
	jne	SHORT $LN2@ShouldAbor@5

; 4741 : 	{
; 4742 : 		// See if our target city is still owned by our enemy
; 4743 : 		if(GetTargetPlot()->getOwner() != m_eEnemy)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T241978[ebp], eax
	mov	ecx, DWORD PTR $T241978[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+76]
	je	SHORT $LN2@ShouldAbor@5

; 4744 : 		{
; 4745 : 			// Success!  The city has been captured/destroyed
; 4746 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@ShouldAbor@5
$LN2@ShouldAbor@5:

; 4747 : 		}
; 4748 : 	}
; 4749 : 
; 4750 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[ebp]
$LN3@ShouldAbor@5:

; 4751 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ ENDP ; CvAIOperationPureNavalCityAttack::ShouldAbort
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationPureNavalCityAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 4755 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4756 : 	CvAssertMsg(false, "Obsolete function called CvAIOperationPureNavalCityAttack::FindBestTarget()");
; 4757 : 
; 4758 : 	return NULL;

	xor	eax, eax

; 4759 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationPureNavalCityAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationCityCloseDefense@@6B@		; CvAIOperationCityCloseDefense::`vftable'
PUBLIC	?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationCityCloseDefense::Init
PUBLIC	?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ ; CvAIOperationCityCloseDefense::GetOperationType
PUBLIC	?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationCityCloseDefense::GetFormation
PUBLIC	?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z ; CvAIOperationCityCloseDefense::Read
PUBLIC	?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z ; CvAIOperationCityCloseDefense::Write
PUBLIC	?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ ; CvAIOperationCityCloseDefense::GetOperationName
EXTRN	??_ECvAIOperationCityCloseDefense@@UAEPAXI@Z:PROC ; CvAIOperationCityCloseDefense::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationCityCloseDefense@@6B@
CONST	SEGMENT
??_7CvAIOperationCityCloseDefense@@6B@ DD FLAT:??_ECvAIOperationCityCloseDefense@@UAEPAXI@Z ; CvAIOperationCityCloseDefense::`vftable'
	DD	FLAT:?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationCityCloseDefense@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationCityCloseDefense@@QAE@XZ PROC		; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense, COMDAT
; _this$ = ecx

; 4767 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationCityCloseDefense@@6B@

; 4768 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationCityCloseDefense@@QAE@XZ ENDP		; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense
_TEXT	ENDS
PUBLIC	??1CvAIOperationCityCloseDefense@@UAE@XZ	; CvAIOperationCityCloseDefense::~CvAIOperationCityCloseDefense
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationCityCloseDefense@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationCityCloseDefense@@UAEPAXI@Z PROC	; CvAIOperationCityCloseDefense::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationCityCloseDefense@@UAE@XZ ; CvAIOperationCityCloseDefense::~CvAIOperationCityCloseDefense
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@19
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@19:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationCityCloseDefense@@UAEPAXI@Z ENDP	; CvAIOperationCityCloseDefense::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationCityCloseDefense@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationCityCloseDefense@@UAE@XZ PROC		; CvAIOperationCityCloseDefense::~CvAIOperationCityCloseDefense, COMDAT
; _this$ = ecx

; 4772 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationCityCloseDefense@@6B@

; 4773 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationCityCloseDefense@@UAE@XZ ENDP		; CvAIOperationCityCloseDefense::~CvAIOperationCityCloseDefense
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ ; CvAIOperationCityCloseDefense::FindBestTarget
; Function compile flags: /Odtp
;	COMDAT ?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T242134 = -100						; size = 4
$T242133 = -96						; size = 4
$T242129 = -92						; size = 4
$T242125 = -88						; size = 4
$T242124 = -84						; size = 4
$T241995 = -16						; size = 4
$T241991 = -12						; size = 4
_pTargetPlot$225597 = -8				; size = 4
_pArmyAI$225594 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationCityCloseDefense::Init, COMDAT
; _this$ = ecx

; 4777 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 4778 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 4779 : 	m_iID = iID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 4780 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 4781 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [edx+76], eax

; 4782 : 
; 4783 : 	if(iID != -1)

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN6@Init@9

; 4784 : 	{
; 4785 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4786 : 		CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241995[ebp], edx
	mov	ecx, DWORD PTR $T241995[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225594[ebp], eax

; 4787 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225594[ebp], 0
	je	$LN6@Init@9

; 4788 : 		{
; 4789 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T241991[ebp], eax
	lea	eax, DWORD PTR $T241991[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4790 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4791 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4792 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4793 : 
; 4794 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ ; CvAIOperationCityCloseDefense::FindBestTarget
	mov	DWORD PTR _pTargetPlot$225597[ebp], eax

; 4795 : 			if(pTargetPlot != NULL)

	cmp	DWORD PTR _pTargetPlot$225597[ebp], 0
	je	$LN6@Init@9

; 4796 : 			{
; 4797 : 				SetTargetPlot(pTargetPlot);

	mov	eax, DWORD PTR _pTargetPlot$225597[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 4798 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	mov	ecx, DWORD PTR _pTargetPlot$225597[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4799 : 				SetMusterPlot(pTargetPlot);  // Gather directly at the point we're trying to defend

	mov	edx, DWORD PTR _pTargetPlot$225597[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 4800 : 				pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T242124[ebp], eax
	mov	eax, DWORD PTR $T242124[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T242125[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T242129[ebp], eax
	mov	edx, DWORD PTR $T242125[ebp]
	push	edx
	mov	eax, DWORD PTR $T242129[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4801 : 				SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T242133[ebp], eax
	mov	edx, DWORD PTR $T242133[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T242134[ebp], eax
	mov	ecx, DWORD PTR $T242134[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 4802 : 
; 4803 : 				// Find the list of units we need to build before starting this operation in earnest
; 4804 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 4805 : 
; 4806 : 				// Try to get as many units as possible from existing units that are waiting around
; 4807 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Init@9

; 4808 : 				{
; 4809 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$225594[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4810 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 2

; 4811 : 				}
; 4812 : 				else

	jmp	SHORT $LN1@Init@9
$LN2@Init@9:

; 4813 : 				{
; 4814 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN1@Init@9:

; 4815 : 				}
; 4816 : 
; 4817 : 				LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN6@Init@9:

; 4818 : 			}
; 4819 : 		}
; 4820 : 	}
; 4821 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationCityCloseDefense::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationCityCloseDefense::Read, COMDAT
; _this$ = ecx

; 4825 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4826 : 	// read the base class' entries
; 4827 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 4828 : 
; 4829 : 	// Version number to maintain backwards compatibility
; 4830 : 	uint uiVersion;
; 4831 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4832 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationCityCloseDefense::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationCityCloseDefense::Write, COMDAT
; _this$ = ecx

; 4836 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4837 : 	// write the base class' entries
; 4838 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 4839 : 
; 4840 : 	// Current version number
; 4841 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 4842 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4843 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationCityCloseDefense::Write
_TEXT	ENDS
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
EXTRN	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z:PROC ; CvMilitaryAI::GetMostThreatenedCity
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T242180 = -40						; size = 4
$T242176 = -36						; size = 4
$T242167 = -32						; size = 4
$T242158 = -28						; size = 4
$T242154 = -24						; size = 4
$T242150 = -20						; size = 4
_pPlot$ = -16						; size = 4
_pCity$ = -12						; size = 4
_pEnemyCapital$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ PROC ; CvAIOperationCityCloseDefense::FindBestTarget, COMDAT
; _this$ = ecx

; 4847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 4848 : 	CvCity* pCity;
; 4849 : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 4850 : 	CvCity* pEnemyCapital;
; 4851 : 	int iLoop;
; 4852 : 
; 4853 : 	// Defend the city most under threat
; 4854 : 	pCity = GET_PLAYER(m_eOwner).GetMilitaryAI()->GetMostThreatenedCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242150[ebp], ecx
	push	0
	mov	ecx, DWORD PTR $T242150[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity
	mov	DWORD PTR _pCity$[ebp], eax

; 4855 : 
; 4856 : 	// If no city is threatened just defend whichever of our cities is closest to the enemy capital
; 4857 : 	if(pCity == NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	$LN3@FindBestTa@9

; 4858 : 	{
; 4859 : 		pEnemyCapital = GET_PLAYER(m_eEnemy).getCapitalCity();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242154[ebp], eax
	mov	ecx, DWORD PTR $T242154[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pEnemyCapital$[ebp], eax

; 4860 : 		if(pEnemyCapital == NULL)

	cmp	DWORD PTR _pEnemyCapital$[ebp], 0
	jne	SHORT $LN14@FindBestTa@9

; 4861 : 		{
; 4862 : 			pEnemyCapital = GET_PLAYER(m_eEnemy).firstCity(&iLoop);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242158[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242158[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pEnemyCapital$[ebp], eax

; 4863 : 		}
; 4864 : 		pCity = GC.getMap().findCity(pEnemyCapital->getX(), pEnemyCapital->getY(), m_eOwner, NO_TEAM, true, false, NO_TEAM, NO_DIRECTION, NULL);

$LN14@FindBestTa@9:
	mov	ecx, DWORD PTR _pEnemyCapital$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T242167[ebp], edx
	mov	eax, DWORD PTR _pEnemyCapital$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T242176[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T242180[ebp], edx
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR $T242167[ebp]
	push	edx
	mov	eax, DWORD PTR $T242176[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242180[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN3@FindBestTa@9:

; 4865 : 	}
; 4866 : 
; 4867 : 	if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN1@FindBestTa@9

; 4868 : 	{
; 4869 : 		pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$[ebp], eax
$LN1@FindBestTa@9:

; 4870 : 	}
; 4871 : 
; 4872 : 	return pPlot;

	mov	eax, DWORD PTR _pPlot$[ebp]

; 4873 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ ENDP ; CvAIOperationCityCloseDefense::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationRapidResponse@@6B@		; CvAIOperationRapidResponse::`vftable'
PUBLIC	?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationRapidResponse::Init
PUBLIC	?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ ; CvAIOperationRapidResponse::GetOperationType
PUBLIC	?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationRapidResponse::GetFormation
PUBLIC	?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::ArmyInPosition
PUBLIC	?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::ArmyMoved
PUBLIC	?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z ; CvAIOperationRapidResponse::Read
PUBLIC	?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z ; CvAIOperationRapidResponse::Write
PUBLIC	?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ ; CvAIOperationRapidResponse::GetOperationName
EXTRN	??_ECvAIOperationRapidResponse@@UAEPAXI@Z:PROC	; CvAIOperationRapidResponse::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationRapidResponse@@6B@
CONST	SEGMENT
??_7CvAIOperationRapidResponse@@6B@ DD FLAT:??_ECvAIOperationRapidResponse@@UAEPAXI@Z ; CvAIOperationRapidResponse::`vftable'
	DD	FLAT:?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationRapidResponse@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationRapidResponse@@QAE@XZ PROC		; CvAIOperationRapidResponse::CvAIOperationRapidResponse, COMDAT
; _this$ = ecx

; 4881 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationRapidResponse@@6B@

; 4882 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationRapidResponse@@QAE@XZ ENDP		; CvAIOperationRapidResponse::CvAIOperationRapidResponse
_TEXT	ENDS
PUBLIC	??1CvAIOperationRapidResponse@@UAE@XZ		; CvAIOperationRapidResponse::~CvAIOperationRapidResponse
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationRapidResponse@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationRapidResponse@@UAEPAXI@Z PROC		; CvAIOperationRapidResponse::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationRapidResponse@@UAE@XZ	; CvAIOperationRapidResponse::~CvAIOperationRapidResponse
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@20
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@20:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationRapidResponse@@UAEPAXI@Z ENDP		; CvAIOperationRapidResponse::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationRapidResponse@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationRapidResponse@@UAE@XZ PROC		; CvAIOperationRapidResponse::~CvAIOperationRapidResponse, COMDAT
; _this$ = ecx

; 4886 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationRapidResponse@@6B@

; 4887 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationRapidResponse@@UAE@XZ ENDP		; CvAIOperationRapidResponse::~CvAIOperationRapidResponse
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ; CvAIOperationRapidResponse::FindBestTarget
; Function compile flags: /Odtp
;	COMDAT ?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T242334 = -100						; size = 4
$T242333 = -96						; size = 4
$T242329 = -92						; size = 4
$T242325 = -88						; size = 4
$T242324 = -84						; size = 4
$T242195 = -16						; size = 4
$T242191 = -12						; size = 4
_pTargetPlot$225644 = -8				; size = 4
_pArmyAI$225641 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationRapidResponse::Init, COMDAT
; _this$ = ecx

; 4891 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 4892 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 4893 : 	m_iID = iID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 4894 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 4895 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [edx+76], eax

; 4896 : 
; 4897 : 	if(iID != -1)

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN6@Init@10

; 4898 : 	{
; 4899 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4900 : 		CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242195[ebp], edx
	mov	ecx, DWORD PTR $T242195[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225641[ebp], eax

; 4901 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225641[ebp], 0
	je	$LN6@Init@10

; 4902 : 		{
; 4903 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T242191[ebp], eax
	lea	eax, DWORD PTR $T242191[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4904 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4905 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4906 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+32]
	call	edx
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4907 : 
; 4908 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ; CvAIOperationRapidResponse::FindBestTarget
	mov	DWORD PTR _pTargetPlot$225644[ebp], eax

; 4909 : 			if(pTargetPlot != NULL)

	cmp	DWORD PTR _pTargetPlot$225644[ebp], 0
	je	$LN6@Init@10

; 4910 : 			{
; 4911 : 				SetTargetPlot(pTargetPlot);

	mov	eax, DWORD PTR _pTargetPlot$225644[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 4912 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	mov	ecx, DWORD PTR _pTargetPlot$225644[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4913 : 				SetMusterPlot(pTargetPlot);  // Gather directly at the point we're trying to defend

	mov	edx, DWORD PTR _pTargetPlot$225644[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 4914 : 				pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T242324[ebp], eax
	mov	eax, DWORD PTR $T242324[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T242325[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T242329[ebp], eax
	mov	edx, DWORD PTR $T242325[ebp]
	push	edx
	mov	eax, DWORD PTR $T242329[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4915 : 				SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR $T242333[ebp], eax
	mov	edx, DWORD PTR $T242333[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T242334[ebp], eax
	mov	ecx, DWORD PTR $T242334[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 4916 : 
; 4917 : 				// Find the list of units we need to build before starting this operation in earnest
; 4918 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 4919 : 
; 4920 : 				// Try to get as many units as possible from existing units that are waiting around
; 4921 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Init@10

; 4922 : 				{
; 4923 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$225641[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4924 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 2

; 4925 : 				}
; 4926 : 				else

	jmp	SHORT $LN1@Init@10
$LN2@Init@10:

; 4927 : 				{
; 4928 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN1@Init@10:

; 4929 : 				}
; 4930 : 
; 4931 : 				LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN6@Init@10:

; 4932 : 			}
; 4933 : 		}
; 4934 : 	}
; 4935 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationRapidResponse::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationRapidResponse::Read, COMDAT
; _this$ = ecx

; 4939 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4940 : 	// read the base class' entries
; 4941 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 4942 : 
; 4943 : 	// Version number to maintain backwards compatibility
; 4944 : 	uint uiVersion;
; 4945 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4946 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationRapidResponse::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationRapidResponse::Write, COMDAT
; _this$ = ecx

; 4950 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4951 : 	// write the base class' entries
; 4952 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 4953 : 
; 4954 : 	// Current version number
; 4955 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 4956 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4957 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationRapidResponse::Write
_TEXT	ENDS
PUBLIC	?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::RetargetDefensiveArmy
; Function compile flags: /Odtp
;	COMDAT ?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationRapidResponse::ArmyInPosition, COMDAT
; _this$ = ecx

; 4961 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4962 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 4963 : 
; 4964 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	SHORT $LN3@ArmyInPosi@11
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN7@ArmyInPosi@11[edx*4]
$LN2@ArmyInPosi@11:

; 4965 : 	{
; 4966 : 		// See if reached our target
; 4967 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4968 : 	{
; 4969 : 		// For now never end, even at target
; 4970 : 		bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 4971 : 
; 4972 : 		// ... but we might want to move to a greater threat
; 4973 : 		RetargetDefensiveArmy(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::RetargetDefensiveArmy

; 4974 : 	}
; 4975 : 	break;

	jmp	SHORT $LN3@ArmyInPosi@11
$LN1@ArmyInPosi@11:

; 4976 : 
; 4977 : 	// In all other cases use base class version
; 4978 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4979 : 	case AI_OPERATION_STATE_ABORTED:
; 4980 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4981 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4982 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al
$LN3@ArmyInPosi@11:

; 4983 : 		break;
; 4984 : 	};
; 4985 : 
; 4986 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]

; 4987 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN7@ArmyInPosi@11:
	DD	$LN1@ArmyInPosi@11
	DD	$LN1@ArmyInPosi@11
	DD	$LN1@ArmyInPosi@11
	DD	$LN2@ArmyInPosi@11
	DD	$LN1@ArmyInPosi@11
?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationRapidResponse::ArmyInPosition
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
_bStateChanged$ = -1					; size = 1
_pArmy$ = 8						; size = 4
?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationRapidResponse::ArmyMoved, COMDAT
; _this$ = ecx

; 4991 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4992 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 4993 : 
; 4994 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	SHORT $LN3@ArmyMoved@2
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN9@ArmyMoved@2[edx*4]
$LN2@ArmyMoved@2:

; 4995 : 	{
; 4996 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4997 : 	{
; 4998 : 		RetargetDefensiveArmy(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::RetargetDefensiveArmy

; 4999 : 	}
; 5000 : 	break;

	jmp	SHORT $LN3@ArmyMoved@2

; 5001 : 
; 5002 : 	// In all other cases use base class version
; 5003 : 	case AI_OPERATION_STATE_AT_TARGET:
; 5004 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 5005 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 5006 : 	case AI_OPERATION_STATE_ABORTED:
; 5007 : 		return CvAIOperation::ArmyMoved(pArmy);

$LN7@ArmyMoved@2:
	xor	al, al
	jmp	SHORT $LN5@ArmyMoved@2
$LN3@ArmyMoved@2:

; 5008 : 		break;
; 5009 : 	};
; 5010 : 
; 5011 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
$LN5@ArmyMoved@2:

; 5012 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN9@ArmyMoved@2:
	DD	$LN7@ArmyMoved@2
	DD	$LN7@ArmyMoved@2
	DD	$LN7@ArmyMoved@2
	DD	$LN2@ArmyMoved@2
	DD	$LN7@ArmyMoved@2
?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationRapidResponse::ArmyMoved
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pBetterTarget$ = -4					; size = 4
_pArmy$ = 8						; size = 4
?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationRapidResponse::RetargetDefensiveArmy, COMDAT
; _this$ = ecx

; 5016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5017 : 	CvPlot* pBetterTarget;
; 5018 : 
; 5019 : 	// Find most threatened city
; 5020 : 	pBetterTarget = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ; CvAIOperationRapidResponse::FindBestTarget
	mov	DWORD PTR _pBetterTarget$[ebp], eax

; 5021 : 
; 5022 : 	// No targets at all!  Abort
; 5023 : 	if(pBetterTarget == NULL)

	cmp	DWORD PTR _pBetterTarget$[ebp], 0
	jne	SHORT $LN3@RetargetDe

; 5024 : 	{
; 5025 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 5026 : 		m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 1

; 5027 : 		return false;

	xor	al, al
	jmp	SHORT $LN4@RetargetDe
	jmp	SHORT $LN2@RetargetDe
$LN3@RetargetDe:

; 5028 : 	}
; 5029 : 
; 5030 : 	// If this is a new target, switch to it
; 5031 : 	else if(pBetterTarget != GetTargetPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _pBetterTarget$[ebp], eax
	je	SHORT $LN2@RetargetDe

; 5032 : 	{
; 5033 : 		SetTargetPlot(pBetterTarget);

	mov	edx, DWORD PTR _pBetterTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 5034 : 		pArmy->SetGoalPlot(pBetterTarget);

	mov	eax, DWORD PTR _pBetterTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN2@RetargetDe:

; 5035 : 	}
; 5036 : 
; 5037 : 	pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5038 : 	m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 3

; 5039 : 
; 5040 : 	return true;

	mov	al, 1
$LN4@RetargetDe:

; 5041 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationRapidResponse::RetargetDefensiveArmy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T242391 = -40						; size = 4
$T242387 = -36						; size = 4
$T242378 = -32						; size = 4
$T242369 = -28						; size = 4
$T242365 = -24						; size = 4
$T242361 = -20						; size = 4
_pPlot$ = -16						; size = 4
_pCity$ = -12						; size = 4
_pEnemyCapital$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ PROC ; CvAIOperationRapidResponse::FindBestTarget, COMDAT
; _this$ = ecx

; 5045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 5046 : 	CvCity* pCity;
; 5047 : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 5048 : 	CvCity* pEnemyCapital;
; 5049 : 	int iLoop;
; 5050 : 
; 5051 : 	// Defend the city most under threat
; 5052 : 	pCity = GET_PLAYER(m_eOwner).GetMilitaryAI()->GetMostThreatenedCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242361[ebp], ecx
	push	0
	mov	ecx, DWORD PTR $T242361[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity
	mov	DWORD PTR _pCity$[ebp], eax

; 5053 : 
; 5054 : 	// If no city is threatened just defend whichever of our cities is closest to the enemy capital
; 5055 : 	if(pCity == NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	$LN3@FindBestTa@10

; 5056 : 	{
; 5057 : 		pEnemyCapital = GET_PLAYER(m_eEnemy).getCapitalCity();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242365[ebp], eax
	mov	ecx, DWORD PTR $T242365[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pEnemyCapital$[ebp], eax

; 5058 : 		if(pEnemyCapital == NULL)

	cmp	DWORD PTR _pEnemyCapital$[ebp], 0
	jne	SHORT $LN14@FindBestTa@10

; 5059 : 		{
; 5060 : 			pEnemyCapital = GET_PLAYER(m_eEnemy).firstCity(&iLoop);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242369[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242369[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pEnemyCapital$[ebp], eax

; 5061 : 		}
; 5062 : 		pCity = GC.getMap().findCity(pEnemyCapital->getX(), pEnemyCapital->getY(), m_eOwner, NO_TEAM, true, false, NO_TEAM, NO_DIRECTION, NULL);

$LN14@FindBestTa@10:
	mov	ecx, DWORD PTR _pEnemyCapital$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T242378[ebp], edx
	mov	eax, DWORD PTR _pEnemyCapital$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T242387[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T242391[ebp], edx
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR $T242378[ebp]
	push	edx
	mov	eax, DWORD PTR $T242387[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242391[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN3@FindBestTa@10:

; 5063 : 	}
; 5064 : 
; 5065 : 	if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN1@FindBestTa@10

; 5066 : 	{
; 5067 : 		pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$[ebp], eax
$LN1@FindBestTa@10:

; 5068 : 	}
; 5069 : 
; 5070 : 	return pPlot;

	mov	eax, DWORD PTR _pPlot$[ebp]

; 5071 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ENDP ; CvAIOperationRapidResponse::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAINavalEscortedOperation@@6B@		; CvAINavalEscortedOperation::`vftable'
PUBLIC	?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAINavalEscortedOperation::Init
PUBLIC	?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ ; CvAINavalEscortedOperation::GetOperationType
PUBLIC	?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAINavalEscortedOperation::GetFormation
PUBLIC	?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ ; CvAINavalEscortedOperation::IsMixedLandNavalOperation
PUBLIC	?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ ; CvAINavalEscortedOperation::GetOperationStartCity
PUBLIC	?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::ArmyInPosition
PUBLIC	?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z ; CvAINavalEscortedOperation::UnitWasRemoved
PUBLIC	?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalEscortedOperation::Read
PUBLIC	?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalEscortedOperation::Write
PUBLIC	?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ ; CvAINavalEscortedOperation::GetOperationName
PUBLIC	?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ ; CvAINavalEscortedOperation::IsCivilianRequired
PUBLIC	?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ ; CvAINavalEscortedOperation::FindBestCivilian
EXTRN	??_ECvAINavalEscortedOperation@@UAEPAXI@Z:PROC	; CvAINavalEscortedOperation::`vector deleting destructor'
;	COMDAT ??_7CvAINavalEscortedOperation@@6B@
CONST	SEGMENT
??_7CvAINavalEscortedOperation@@6B@ DD FLAT:??_ECvAINavalEscortedOperation@@UAEPAXI@Z ; CvAINavalEscortedOperation::`vftable'
	DD	FLAT:?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAINavalEscortedOperation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAINavalEscortedOperation@@QAE@XZ PROC		; CvAINavalEscortedOperation::CvAINavalEscortedOperation, COMDAT
; _this$ = ecx

; 5077 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAINavalEscortedOperation@@6B@

; 5078 : 	// *** Move into subclass later?
; 5079 : 	m_eCivilianType = UNITAI_SETTLE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 1

; 5080 : 	m_iInitialAreaID = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], -1

; 5081 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAINavalEscortedOperation@@QAE@XZ ENDP		; CvAINavalEscortedOperation::CvAINavalEscortedOperation
_TEXT	ENDS
PUBLIC	??1CvAINavalEscortedOperation@@UAE@XZ		; CvAINavalEscortedOperation::~CvAINavalEscortedOperation
; Function compile flags: /Odtp
;	COMDAT ??_GCvAINavalEscortedOperation@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAINavalEscortedOperation@@UAEPAXI@Z PROC		; CvAINavalEscortedOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAINavalEscortedOperation@@UAE@XZ	; CvAINavalEscortedOperation::~CvAINavalEscortedOperation
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@21
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@21:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAINavalEscortedOperation@@UAEPAXI@Z ENDP		; CvAINavalEscortedOperation::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAINavalEscortedOperation@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAINavalEscortedOperation@@UAE@XZ PROC		; CvAINavalEscortedOperation::~CvAINavalEscortedOperation, COMDAT
; _this$ = ecx

; 5084 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAINavalEscortedOperation@@6B@

; 5085 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAINavalEscortedOperation@@UAE@XZ ENDP		; CvAINavalEscortedOperation::~CvAINavalEscortedOperation
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z ; CvAINavalEscortedOperation::FindBestTarget
; Function compile flags: /Odtp
;	COMDAT ?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
tv132 = -108						; size = 4
_this$ = -104						; size = 4
$T242549 = -100						; size = 4
$T242537 = -96						; size = 4
$T242408 = -28						; size = 4
$T242404 = -24						; size = 4
_pMusterPt$225725 = -20					; size = 4
_pArmyAI$225722 = -16					; size = 4
_pTargetSite$225720 = -12				; size = 4
_pOurCivilian$ = -8					; size = 4
_pStartCity$ = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAINavalEscortedOperation::Init, COMDAT
; _this$ = ecx

; 5089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 5090 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 5091 : 	m_eMoveType = AI_OPERATION_MOVETYPE_NAVAL_ESCORT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 2

; 5092 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 5093 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 5094 : 	SetDefaultArea(iDefaultArea);   // Area settler starts in

	mov	eax, DWORD PTR _iDefaultArea$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 5095 : 
; 5096 : 	// Find the free civilian (that triggered this operation)
; 5097 : 	CvUnit* pOurCivilian = FindBestCivilian();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pOurCivilian$[ebp], eax

; 5098 : 	m_iInitialAreaID = (pOurCivilian != NULL)? pOurCivilian->getArea() : -1;

	cmp	DWORD PTR _pOurCivilian$[ebp], 0
	je	SHORT $LN9@Init@11
	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN10@Init@11
$LN9@Init@11:
	mov	DWORD PTR tv132[ebp], -1
$LN10@Init@11:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR [ecx+116], edx

; 5099 : 
; 5100 : 	CvCity* pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _pStartCity$[ebp], eax

; 5101 : 
; 5102 : 	if(pOurCivilian != NULL && iID != -1 && pStartCity)

	cmp	DWORD PTR _pOurCivilian$[ebp], 0
	je	$LN7@Init@11
	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN7@Init@11
	cmp	DWORD PTR _pStartCity$[ebp], 0
	je	$LN7@Init@11

; 5103 : 	{
; 5104 : 		// Find a destination (not worrying about safe paths)
; 5105 : 		CvPlot* pTargetSite = FindBestTarget(pOurCivilian);

	mov	ecx, DWORD PTR _pOurCivilian$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z ; CvAINavalEscortedOperation::FindBestTarget
	mov	DWORD PTR _pTargetSite$225720[ebp], eax

; 5106 : 
; 5107 : 		if(pTargetSite != NULL)

	cmp	DWORD PTR _pTargetSite$225720[ebp], 0
	je	$LN5@Init@11

; 5108 : 		{
; 5109 : 			SetTargetPlot(pTargetSite);

	mov	edx, DWORD PTR _pTargetSite$225720[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 5110 : 
; 5111 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 5112 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242408[ebp], ecx
	mov	ecx, DWORD PTR $T242408[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225722[ebp], eax

; 5113 : 			if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225722[ebp], 0
	je	$LN4@Init@11

; 5114 : 			{
; 5115 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T242404[ebp], eax
	lea	edx, DWORD PTR $T242404[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 5116 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 5117 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5118 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 5119 : 
; 5120 : 				pArmyAI->SetGoalPlot(pTargetSite);

	mov	ecx, DWORD PTR _pTargetSite$225720[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 5121 : 				CvPlot* pMusterPt = pStartCity->plot();

	mov	ecx, DWORD PTR _pStartCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pMusterPt$225725[ebp], eax

; 5122 : 				SetMusterPlot(pMusterPt);

	mov	edx, DWORD PTR _pMusterPt$225725[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 5123 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	mov	eax, DWORD PTR _pMusterPt$225725[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T242537[ebp], ecx
	mov	edx, DWORD PTR $T242537[ebp]
	push	edx
	mov	eax, DWORD PTR _pMusterPt$225725[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 5124 : 
; 5125 : 				// Add the settler to our army
; 5126 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	edx, DWORD PTR _pOurCivilian$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T242549[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T242549[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 5127 : 
; 5128 : 				// try to get the escort from existing units that are waiting around
; 5129 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 5130 : 
; 5131 : 				// Try to get as many units as possible from existing units that are waiting around
; 5132 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Init@11

; 5133 : 				{
; 5134 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$225722[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5135 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 2

; 5136 : 				}
; 5137 : 				else

	jmp	SHORT $LN2@Init@11
$LN3@Init@11:

; 5138 : 				{
; 5139 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN2@Init@11:

; 5140 : 				}
; 5141 : 				LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN4@Init@11:

; 5142 : 			}
; 5143 : 		}
; 5144 : 
; 5145 : 		else

	jmp	SHORT $LN7@Init@11
$LN5@Init@11:

; 5146 : 		{
; 5147 : 			// Lost our target, abort
; 5148 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 5149 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 3
$LN7@Init@11:

; 5150 : 		}
; 5151 : 	}
; 5152 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAINavalEscortedOperation::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kOwner$ = -12						; size = 4
_pCity$ = -8						; size = 4
_iLoop$ = -4						; size = 4
?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ PROC ; CvAINavalEscortedOperation::GetOperationStartCity, COMDAT
; _this$ = ecx

; 5156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 5157 : 	if(GetStartCityPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN14@GetOperati@3

; 5158 : 	{
; 5159 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	jmp	SHORT $LN7@GetOperati@3

; 5160 : 	}
; 5161 : 
; 5162 : 	CvPlayerAI& kOwner = GET_PLAYER(m_eOwner);

$LN14@GetOperati@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kOwner$[ebp], ecx

; 5163 : 
; 5164 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[ebp], 0

; 5165 : 	CvCity* pCity = NULL;

	mov	DWORD PTR _pCity$[ebp], 0

; 5166 : 
; 5167 : 	// Find first coastal city in same area as settler
; 5168 : 	for(pCity = kOwner.firstCity(&iLoop); pCity != NULL; pCity = kOwner.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kOwner$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN5@GetOperati@3
$LN4@GetOperati@3:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kOwner$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN5@GetOperati@3:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN3@GetOperati@3

; 5169 : 	{
; 5170 : 		if(pCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetOperati@3

; 5171 : 		{
; 5172 : 			if(pCity->getArea() == m_iInitialAreaID)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+116]
	jne	SHORT $LN2@GetOperati@3

; 5173 : 			{
; 5174 : 				return pCity;

	mov	eax, DWORD PTR _pCity$[ebp]
	jmp	SHORT $LN7@GetOperati@3
$LN2@GetOperati@3:

; 5175 : 			}
; 5176 : 		}
; 5177 : 	}

	jmp	SHORT $LN4@GetOperati@3
$LN3@GetOperati@3:

; 5178 : 
; 5179 : 	return NULL;

	xor	eax, eax
$LN7@GetOperati@3:

; 5180 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ ENDP ; CvAINavalEscortedOperation::GetOperationStartCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z PROC ; CvAINavalEscortedOperation::UnitWasRemoved, COMDAT
; _this$ = ecx

; 5184 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5185 : 	// Assumes civilian is in the first slot of the formation
; 5186 : 	if(iSlotID == 0)

	cmp	DWORD PTR _iSlotID$[ebp], 0
	jne	SHORT $LN2@UnitWasRem@3

; 5187 : 	{
; 5188 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 5189 : 		m_eAbortReason = AI_ABORT_LOST_CIVILIAN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 8
$LN2@UnitWasRem@3:

; 5190 : 	}
; 5191 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z ENDP ; CvAINavalEscortedOperation::UnitWasRemoved
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_kOwner$ = -12						; size = 4
_pLoopUnit$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ PROC ; CvAINavalEscortedOperation::FindBestCivilian, COMDAT
; _this$ = ecx

; 5195 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 5196 : 	int iUnitLoop = 0;

	mov	DWORD PTR _iUnitLoop$[ebp], 0

; 5197 : 	CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$[ebp], 0

; 5198 : 
; 5199 : 	CvPlayerAI& kOwner = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kOwner$[ebp], ecx

; 5200 : 
; 5201 : 	for(pLoopUnit = kOwner.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kOwner.nextUnit(&iUnitLoop))

	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kOwner$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN6@FindBestCi@3
$LN5@FindBestCi@3:
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kOwner$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN6@FindBestCi@3:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN4@FindBestCi@3

; 5202 : 	{
; 5203 : 		if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN3@FindBestCi@3

; 5204 : 		{
; 5205 : 			if(pLoopUnit->AI_getUnitAIType() == m_eCivilianType)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+112]
	jne	SHORT $LN3@FindBestCi@3

; 5206 : 			{
; 5207 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN3@FindBestCi@3

; 5208 : 				{
; 5209 : 					return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN7@FindBestCi@3
$LN3@FindBestCi@3:

; 5210 : 				}
; 5211 : 			}
; 5212 : 		}
; 5213 : 	}

	jmp	SHORT $LN5@FindBestCi@3
$LN4@FindBestCi@3:

; 5214 : 	return NULL;

	xor	eax, eax
$LN7@FindBestCi@3:

; 5215 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ ENDP ; CvAINavalEscortedOperation::FindBestCivilian
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z PROC ; CvAINavalEscortedOperation::Read, COMDAT
; _this$ = ecx

; 5219 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5220 : 	// read the base class' entries
; 5221 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 5222 : 
; 5223 : 	// Version number to maintain backwards compatibility
; 5224 : 	uint uiVersion;
; 5225 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5226 : 
; 5227 : 	kStream >> m_eCivilianType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitAITypes@@@Z ; operator>>
	add	esp, 8

; 5228 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z ENDP ; CvAINavalEscortedOperation::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z PROC ; CvAINavalEscortedOperation::Write, COMDAT
; _this$ = ecx

; 5232 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5233 : 	// write the base class' entries
; 5234 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 5235 : 
; 5236 : 	// Current version number
; 5237 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 5238 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5239 : 
; 5240 : 	kStream << m_eCivilianType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitAITypes@@@Z ; operator<<
	add	esp, 8

; 5241 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z ENDP ; CvAINavalEscortedOperation::Write
_TEXT	ENDS
PUBLIC	??_C@_0BP@IMMOANAE@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@ ; `string'
PUBLIC	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian
PUBLIC	??_C@_0EE@IEDLHDEB@Not?5at?5target?5but?5can?5no?5longer?5@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BP@IMMOANAE@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@IMMOANAE@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@ DB 'C'
	DB	'ity founded, At X=%d, At Y=%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@IEDLHDEB@Not?5at?5target?5but?5can?5no?5longer?5@
CONST	SEGMENT
??_C@_0EE@IEDLHDEB@Not?5at?5target?5but?5can?5no?5longer?5@ DB 'Not at ta'
	DB	'rget but can no longer settle here. Target was (X=%d Y=%d)', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv72 = -108						; size = 4
_this$ = -104						; size = 4
$T242622 = -100						; size = 4
$T242615 = -96						; size = 4
$T242608 = -92						; size = 4
$T242604 = -88						; size = 4
$T242597 = -84						; size = 4
$T242590 = -80						; size = 4
$T242581 = -74						; size = 1
$T242580 = -73						; size = 1
_pSettlerPlot$225787 = -72				; size = 4
_pTargetPlot$225785 = -68				; size = 4
_pTargetPlotOwner$225786 = -64				; size = 4
_strMsg$ = -60						; size = 28
__$ArrayPad$ = -32					; size = 4
_pSettler$ = -28					; size = 4
_bStateChanged$ = -21					; size = 1
_pEscort$ = -20						; size = 4
_iUnitID$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAINavalEscortedOperation::ArmyInPosition, COMDAT
; _this$ = ecx

; 5245 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5246 : 	int iUnitID = 0;

	mov	DWORD PTR _iUnitID$[ebp], 0

; 5247 : 	bool bStateChanged = false;

	mov	BYTE PTR _bStateChanged$[ebp], 0

; 5248 : 	CvUnit* pSettler = 0, *pEscort = 0;

	mov	DWORD PTR _pSettler$[ebp], 0
	mov	DWORD PTR _pEscort$[ebp], 0

; 5249 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5250 : 
; 5251 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 4
	ja	$LN17@ArmyInPosi@12
	mov	edx, DWORD PTR tv72[ebp]
	jmp	DWORD PTR $LN52@ArmyInPosi@12[edx*4]
$LN16@ArmyInPosi@12:

; 5252 : 	{
; 5253 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 5254 : 	case AI_OPERATION_STATE_AT_TARGET:
; 5255 : 
; 5256 : 		// Call base class version and see if it thinks we're done
; 5257 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[ebp], al

; 5258 : 
; 5259 : 		// Now get the settler
; 5260 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 5261 : 		if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN15@ArmyInPosi@12

; 5262 : 		{
; 5263 : 			pSettler = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242590[ebp], edx
	mov	eax, DWORD PTR _iUnitID$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242590[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pSettler$[ebp], eax
$LN15@ArmyInPosi@12:

; 5264 : 		}
; 5265 : 
; 5266 : 		if(pSettler != NULL)

	cmp	DWORD PTR _pSettler$[ebp], 0
	je	$LN14@ArmyInPosi@12

; 5267 : 		{
; 5268 : 			CvPlot* pTargetPlot = GetTargetPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR _pTargetPlot$225785[ebp], eax

; 5269 : 			const PlayerTypes pTargetPlotOwner = pTargetPlot->getOwner();

	mov	ecx, DWORD PTR _pTargetPlot$225785[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _pTargetPlotOwner$225786[ebp], edx

; 5270 : 
; 5271 : 			CvPlot* pSettlerPlot = pSettler->plot();

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pSettlerPlot$225787[ebp], eax

; 5272 : 
; 5273 : 			if((pTargetPlotOwner != NO_PLAYER && pTargetPlotOwner != m_eOwner) || pTargetPlot->IsAdjacentOwnedByOtherTeam(pSettler->getTeam()))

	cmp	DWORD PTR _pTargetPlotOwner$225786[ebp], -1
	je	SHORT $LN11@ArmyInPosi@12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTargetPlotOwner$225786[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jne	SHORT $LN12@ArmyInPosi@12
$LN11@ArmyInPosi@12:
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _pTargetPlot$225785[ebp]
	call	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
	movzx	edx, al
	test	edx, edx
	je	$LN13@ArmyInPosi@12
$LN12@ArmyInPosi@12:

; 5274 : 			{
; 5275 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@ArmyInPosi@12
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@ArmyInPosi@12

; 5276 : 				{
; 5277 : 					strMsg.Format("Not at target but can no longer settle here. Target was (X=%d Y=%d)", pTargetPlot->getX(), pTargetPlot->getY());

	mov	edx, DWORD PTR _pTargetPlot$225785[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T242597[ebp], eax
	mov	ecx, DWORD PTR $T242597[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTargetPlot$225785[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0EE@IEDLHDEB@Not?5at?5target?5but?5can?5no?5longer?5@
	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5278 : 					LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN10@ArmyInPosi@12:

; 5279 : 				}
; 5280 : 				RetargetCivilian(pSettler, pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSettler$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian

; 5281 : 				pSettler->finishMoves();

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5282 : 				iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 5283 : 				if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN9@ArmyInPosi@12

; 5284 : 				{
; 5285 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242604[ebp], eax
	mov	ecx, DWORD PTR _iUnitID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T242604[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 5286 : 					pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN9@ArmyInPosi@12:

; 5287 : 				}
; 5288 : 			}

	jmp	$LN14@ArmyInPosi@12
$LN13@ArmyInPosi@12:

; 5289 : 			// If the settler made it, we don't care about the entire army
; 5290 : 			else if(pSettlerPlot == pTargetPlot && pSettler->canMove() && pSettler->canFound(pSettlerPlot))

	mov	edx, DWORD PTR _pSettlerPlot$225787[ebp]
	cmp	edx, DWORD PTR _pTargetPlot$225785[ebp]
	jne	$LN7@ArmyInPosi@12
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	$LN7@ArmyInPosi@12
	push	0
	mov	ecx, DWORD PTR _pSettlerPlot$225787[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	movzx	edx, al
	test	edx, edx
	je	$LN7@ArmyInPosi@12

; 5291 : 			{
; 5292 : 				pSettler->PushMission(CvTypes::getMISSION_FOUND());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	push	eax
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5293 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@ArmyInPosi@12
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@ArmyInPosi@12

; 5294 : 				{
; 5295 : 					strMsg.Format("City founded, At X=%d, At Y=%d", pSettlerPlot->getX(), pSettlerPlot->getY());

	mov	edx, DWORD PTR _pSettlerPlot$225787[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T242608[ebp], eax
	mov	ecx, DWORD PTR $T242608[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSettlerPlot$225787[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0BP@IMMOANAE@City?5founded?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@
	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5296 : 					LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN6@ArmyInPosi@12:

; 5297 : 				}
; 5298 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 5
	jmp	$LN14@ArmyInPosi@12
$LN7@ArmyInPosi@12:

; 5299 : 			}
; 5300 : 
; 5301 : 			// If we're at our target but can no longer found a city, might be someone else beat us to this area
; 5302 : 			// So move back out, picking a new target
; 5303 : 			else if(pSettlerPlot == GetTargetPlot() && !pSettler->canFound(pSettlerPlot))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _pSettlerPlot$225787[ebp], eax
	jne	$LN14@ArmyInPosi@12
	push	0
	mov	ecx, DWORD PTR _pSettlerPlot$225787[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	movzx	edx, al
	test	edx, edx
	jne	$LN14@ArmyInPosi@12

; 5304 : 			{
; 5305 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ArmyInPosi@12
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ArmyInPosi@12

; 5306 : 				{
; 5307 : 					strMsg.Format("At target but can no longer settle here. Target was (X=%d Y=%d)", pTargetPlot->getX(), pTargetPlot->getY());

	mov	edx, DWORD PTR _pTargetPlot$225785[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T242615[ebp], eax
	mov	ecx, DWORD PTR $T242615[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTargetPlot$225785[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0EA@ICOKGFKM@At?5target?5but?5can?5no?5longer?5sett@
	lea	ecx, DWORD PTR _strMsg$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5308 : 					LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@12:

; 5309 : 				}
; 5310 : 				RetargetCivilian(pSettler, pArmy);

	mov	eax, DWORD PTR _pArmy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSettler$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian

; 5311 : 				pSettler->finishMoves();

	mov	ecx, DWORD PTR _pSettler$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5312 : 				iUnitID = pArmy->GetNextUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	DWORD PTR _iUnitID$[ebp], eax

; 5313 : 				if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$[ebp], -1
	je	SHORT $LN14@ArmyInPosi@12

; 5314 : 				{
; 5315 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242622[ebp], eax
	mov	ecx, DWORD PTR _iUnitID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T242622[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pEscort$[ebp], eax

; 5316 : 					pEscort->finishMoves();

	mov	ecx, DWORD PTR _pEscort$[ebp]
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN14@ArmyInPosi@12:

; 5317 : 				}
; 5318 : 			}
; 5319 : 		}
; 5320 : 		break;

	jmp	SHORT $LN17@ArmyInPosi@12
$LN1@ArmyInPosi@12:

; 5321 : 
; 5322 : 		// In all other cases use base class version
; 5323 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 5324 : 	case AI_OPERATION_STATE_ABORTED:
; 5325 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 5326 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR $T242580[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T242580[ebp]
	jmp	SHORT $LN19@ArmyInPosi@12
$LN17@ArmyInPosi@12:

; 5327 : 		break;
; 5328 : 	};
; 5329 : 
; 5330 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[ebp]
	mov	BYTE PTR $T242581[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T242581[ebp]
$LN19@ArmyInPosi@12:

; 5331 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN52@ArmyInPosi@12:
	DD	$LN1@ArmyInPosi@12
	DD	$LN1@ArmyInPosi@12
	DD	$LN1@ArmyInPosi@12
	DD	$LN16@ArmyInPosi@12
	DD	$LN16@ArmyInPosi@12
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAINavalEscortedOperation::ArmyInPosition
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T242643 = -4						; size = 4
_pUnit$ = 8						; size = 4
?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvAINavalEscortedOperation::FindBestTarget, COMDAT
; _this$ = ecx

; 5335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5336 : 	return GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, true, -1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242643[ebp], ecx
	push	-1
	push	1
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T242643[ebp]
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot

; 5337 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvAINavalEscortedOperation::FindBestTarget
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pBetterTarget$ = -4					; size = 4
_pCivilian$ = 8						; size = 4
_pArmy$ = 12						; size = 4
?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z PROC ; CvAINavalEscortedOperation::RetargetCivilian, COMDAT
; _this$ = ecx

; 5341 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5342 : 	CvPlot* pBetterTarget;
; 5343 : 
; 5344 : 	// Find best city site (taking into account whether or not we are escorted)
; 5345 : 	pBetterTarget = FindBestTarget(pCivilian);

	mov	eax, DWORD PTR _pCivilian$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z ; CvAINavalEscortedOperation::FindBestTarget
	mov	DWORD PTR _pBetterTarget$[ebp], eax

; 5346 : 
; 5347 : 	// No targets at all!  Abort
; 5348 : 	if(pBetterTarget == NULL)

	cmp	DWORD PTR _pBetterTarget$[ebp], 0
	jne	SHORT $LN3@RetargetCi@2

; 5349 : 	{
; 5350 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 5351 : 		m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 1

; 5352 : 		return false;

	xor	al, al
	jmp	SHORT $LN4@RetargetCi@2
	jmp	SHORT $LN2@RetargetCi@2
$LN3@RetargetCi@2:

; 5353 : 	}
; 5354 : 
; 5355 : 	// If this is a new target, switch to it
; 5356 : 	else if(pBetterTarget != GetTargetPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	DWORD PTR _pBetterTarget$[ebp], eax
	je	SHORT $LN2@RetargetCi@2

; 5357 : 	{
; 5358 : 		SetTargetPlot(pBetterTarget);

	mov	eax, DWORD PTR _pBetterTarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 5359 : 		pArmy->SetGoalPlot(pBetterTarget);

	mov	ecx, DWORD PTR _pBetterTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN2@RetargetCi@2:

; 5360 : 	}
; 5361 : 
; 5362 : 	pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5363 : 	m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 3

; 5364 : 
; 5365 : 	return true;

	mov	al, 1
$LN4@RetargetCi@2:

; 5366 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ENDP ; CvAINavalEscortedOperation::RetargetCivilian
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalAttack@@6B@		; CvAIOperationNavalAttack::`vftable'
PUBLIC	?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNavalAttack::Init
PUBLIC	?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ ; CvAIOperationNavalAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalAttack::GetFormation
PUBLIC	?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ ; CvAIOperationNavalAttack::GetOperationStartCity
PUBLIC	?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNavalAttack::ArmyInPosition
PUBLIC	?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z ; CvAIOperationNavalAttack::UnitWasRemoved
PUBLIC	?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationNavalAttack::Read
PUBLIC	?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationNavalAttack::Write
PUBLIC	?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ ; CvAIOperationNavalAttack::GetOperationName
PUBLIC	?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ ; CvAIOperationNavalAttack::IsCivilianRequired
PUBLIC	?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationNavalAttack::FindBestTarget
EXTRN	??_ECvAIOperationNavalAttack@@UAEPAXI@Z:PROC	; CvAIOperationNavalAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationNavalAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalAttack@@6B@ DD FLAT:??_ECvAIOperationNavalAttack@@UAEPAXI@Z ; CvAIOperationNavalAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationNavalAttack@@QAE@XZ PROC		; CvAIOperationNavalAttack::CvAIOperationNavalAttack, COMDAT
; _this$ = ecx

; 5372 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAINavalEscortedOperation@@QAE@XZ	; CvAINavalEscortedOperation::CvAINavalEscortedOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalAttack@@6B@

; 5373 : 	m_eCivilianType = NO_UNITAI;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], -1

; 5374 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationNavalAttack@@QAE@XZ ENDP		; CvAIOperationNavalAttack::CvAIOperationNavalAttack
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalAttack@@UAE@XZ		; CvAIOperationNavalAttack::~CvAIOperationNavalAttack
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationNavalAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationNavalAttack@@UAEPAXI@Z PROC		; CvAIOperationNavalAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationNavalAttack@@UAE@XZ	; CvAIOperationNavalAttack::~CvAIOperationNavalAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@22
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@22:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationNavalAttack@@UAEPAXI@Z ENDP		; CvAIOperationNavalAttack::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationNavalAttack@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationNavalAttack@@UAE@XZ PROC		; CvAIOperationNavalAttack::~CvAIOperationNavalAttack, COMDAT
; _this$ = ecx

; 5377 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalAttack@@6B@

; 5378 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAINavalEscortedOperation@@UAE@XZ	; CvAINavalEscortedOperation::~CvAINavalEscortedOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationNavalAttack@@UAE@XZ ENDP		; CvAIOperationNavalAttack::~CvAIOperationNavalAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T242794 = -88						; size = 4
$T242790 = -84						; size = 4
$T242789 = -80						; size = 4
$T242660 = -12						; size = 4
$T242656 = -8						; size = 4
_pArmyAI$225839 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
_pTarget$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNavalAttack::Init, COMDAT
; _this$ = ecx

; 5382 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 5383 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 5384 : 	m_eMoveType = AI_OPERATION_MOVETYPE_NAVAL_ESCORT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 2

; 5385 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 5386 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 5387 : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 5388 : 	SetDefaultArea(iDefaultArea);

	mov	edx, DWORD PTR _iDefaultArea$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultArea@CvAIOperation@@QAEXH@Z	; CvAIOperation::SetDefaultArea

; 5389 : 
; 5390 : 	SetStartCityPlot(pMuster->plot());

	mov	ecx, DWORD PTR _pMuster$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetStartCityPlot

; 5391 : 
; 5392 : 	if(iID != -1)

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN7@Init@12

; 5393 : 	{
; 5394 : 		if(pTarget)

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	$LN5@Init@12

; 5395 : 		{
; 5396 : 			SetTargetPlot(pTarget->plot());

	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 5397 : 
; 5398 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 5399 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242660[ebp], ecx
	mov	ecx, DWORD PTR $T242660[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225839[ebp], eax

; 5400 : 			if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225839[ebp], 0
	je	$LN4@Init@12

; 5401 : 			{
; 5402 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T242656[ebp], eax
	lea	edx, DWORD PTR $T242656[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 5403 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 5404 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5405 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 5406 : 
; 5407 : 				pArmyAI->SetGoalPlot(GetTargetPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 5408 : 				SetMusterPlot(GetStartCityPlot());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetMusterPlot

; 5409 : 				pArmyAI->SetXY(GetStartCityPlot()->getX(), GetStartCityPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	DWORD PTR $T242789[ebp], eax
	mov	ecx, DWORD PTR $T242789[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T242790[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	DWORD PTR $T242794[ebp], eax
	mov	eax, DWORD PTR $T242790[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242794[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 5410 : 
; 5411 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 5412 : 
; 5413 : 				// Try to get as many units as possible from existing units that are waiting around
; 5414 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Init@12

; 5415 : 				{
; 5416 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, DWORD PTR _pArmyAI$225839[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5417 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 2

; 5418 : 				}
; 5419 : 				else

	jmp	SHORT $LN2@Init@12
$LN3@Init@12:

; 5420 : 				{
; 5421 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1
$LN2@Init@12:

; 5422 : 				}
; 5423 : 				LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN4@Init@12:

; 5424 : 			}
; 5425 : 		}
; 5426 : 
; 5427 : 		else

	jmp	SHORT $LN7@Init@12
$LN5@Init@12:

; 5428 : 		{
; 5429 : 			// Lost our target, abort
; 5430 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 5431 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 3
$LN7@Init@12:

; 5432 : 		}
; 5433 : 	}
; 5434 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNavalAttack::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iArmyID$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z PROC	; CvAIOperationNavalAttack::UnitWasRemoved, COMDAT
; _this$ = ecx

; 5438 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5439 : 	// Call root class version
; 5440 : 	CvAIOperation::UnitWasRemoved(iArmyID, iSlotID);

	mov	eax, DWORD PTR _iSlotID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iArmyID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnitWasRemoved@CvAIOperation@@UAEXHH@Z	; CvAIOperation::UnitWasRemoved

; 5441 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z ENDP	; CvAIOperationNavalAttack::UnitWasRemoved
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalAttack::Read, COMDAT
; _this$ = ecx

; 5445 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5446 : 	// read the base class' entries
; 5447 : 	CvAINavalEscortedOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalEscortedOperation::Read

; 5448 : 
; 5449 : 	// Version number to maintain backwards compatibility
; 5450 : 	uint uiVersion;
; 5451 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5452 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalAttack::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalAttack::Write, COMDAT
; _this$ = ecx

; 5456 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5457 : 	// write the base class' entries
; 5458 : 	CvAINavalEscortedOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalEscortedOperation::Write

; 5459 : 
; 5460 : 	// Current version number
; 5461 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 5462 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5463 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalAttack::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
tv69 = -128						; size = 4
_this$ = -124						; size = 4
$T242911 = -120						; size = 4
$T242904 = -116						; size = 4
$T242900 = -112						; size = 4
$T242896 = -108						; size = 4
$T242889 = -104						; size = 4
$T242885 = -100						; size = 4
$T242881 = -96						; size = 4
$T242877 = -92						; size = 4
$T242865 = -88						; size = 4
$T242861 = -84						; size = 4
$T242857 = -80						; size = 4
$T242816 = -32						; size = 4
$T242812 = -28						; size = 4
_zone$225871 = -24					; size = 20
_pCenterOfMass$225869 = -4				; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNavalAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 5467 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 5468 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR tv69[ebp], ecx
	cmp	DWORD PTR tv69[ebp], 4
	ja	$LN4@ArmyInPosi@13
	mov	edx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN66@ArmyInPosi@13[edx*4]
$LN3@ArmyInPosi@13:

; 5469 : 	{
; 5470 : 		// See if reached our target, if so give control of these units to the tactical AI
; 5471 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 5472 : 	{
; 5473 : 		CvPlot *pCenterOfMass = pArmy->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	DWORD PTR _pCenterOfMass$225869[ebp], eax

; 5474 : 
; 5475 : 		// Are we within tactical range of our target? (larger than usual range for a naval attack)
; 5476 : 		if(pCenterOfMass && plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE() * 2)

	cmp	DWORD PTR _pCenterOfMass$225869[ebp], 0
	je	$LN2@ArmyInPosi@13
	mov	eax, DWORD PTR _pCenterOfMass$225869[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T242812[ebp], ecx
	mov	edx, DWORD PTR _pCenterOfMass$225869[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T242816[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	DWORD PTR $T242857[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	mov	eax, DWORD PTR $T242812[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242816[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR $T242857[ebp]
	shl	edx, 1
	cmp	eax, edx
	jg	$LN2@ArmyInPosi@13

; 5477 : 		{
; 5478 : 			// Notify Diplo AI we're in place for attack
; 5479 : 			GET_PLAYER(GetOwner()).GetDiplomacyAI()->SetMusteringForAttack(GetEnemy(), true);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T242861[ebp], ecx
	mov	edx, DWORD PTR $T242861[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242865[ebp], edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ; CvAIOperation::GetEnemy
	push	eax
	mov	ecx, DWORD PTR $T242865[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetMusteringForAttack@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetMusteringForAttack

; 5480 : 
; 5481 : 			// Notify tactical AI to focus on this area
; 5482 : 			CvTemporaryZone zone;

	mov	DWORD PTR _zone$225871[ebp], 0
	mov	DWORD PTR _zone$225871[ebp+4], 0
	mov	DWORD PTR _zone$225871[ebp+8], 0
	mov	DWORD PTR _zone$225871[ebp+12], 0

; 5483 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T242877[ebp], eax
	mov	eax, DWORD PTR $T242877[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T242881[ebp], ecx
	mov	edx, DWORD PTR $T242881[ebp]
	mov	DWORD PTR _zone$225871[ebp], edx

; 5484 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR $T242885[ebp], eax
	mov	eax, DWORD PTR $T242885[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T242889[ebp], ecx
	mov	edx, DWORD PTR $T242889[ebp]
	mov	DWORD PTR _zone$225871[ebp+4], edx

; 5485 : 			zone.SetTargetType(AI_TACTICAL_TARGET_CITY);

	mov	DWORD PTR _zone$225871[ebp+8], 1

; 5486 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T242896[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	DWORD PTR $T242900[ebp], ecx
	mov	ecx, DWORD PTR $T242896[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	eax, DWORD PTR $T242900[ebp]
	mov	DWORD PTR $T242904[ebp], eax
	mov	edx, DWORD PTR $T242904[ebp]
	mov	DWORD PTR _zone$225871[ebp+12], edx

; 5487 : 			zone.SetNavalInvasion(true);

	mov	BYTE PTR _zone$225871[ebp+16], 1

; 5488 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242911[ebp], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	eax, DWORD PTR _zone$225871[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _zone$225871[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _zone$225871[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _zone$225871[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _zone$225871[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T242911[ebp]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 5489 : 
; 5490 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 5

; 5491 : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@ArmyInPosi@13
$LN2@ArmyInPosi@13:

; 5492 : 		}
; 5493 : 	}
; 5494 : 	break;

	jmp	SHORT $LN4@ArmyInPosi@13
$LN1@ArmyInPosi@13:

; 5495 : 
; 5496 : 	// In all other cases use base class version
; 5497 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 5498 : 	case AI_OPERATION_STATE_ABORTED:
; 5499 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 5500 : 	case AI_OPERATION_STATE_AT_TARGET:
; 5501 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	jmp	SHORT $LN6@ArmyInPosi@13
$LN4@ArmyInPosi@13:

; 5502 : 		break;
; 5503 : 	};
; 5504 : 
; 5505 : 	return false;

	xor	al, al
$LN6@ArmyInPosi@13:

; 5506 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN66@ArmyInPosi@13:
	DD	$LN1@ArmyInPosi@13
	DD	$LN1@ArmyInPosi@13
	DD	$LN1@ArmyInPosi@13
	DD	$LN3@ArmyInPosi@13
	DD	$LN1@ArmyInPosi@13
?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNavalAttack::ArmyInPosition
_TEXT	ENDS
EXTRN	?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z:PROC ; CvMilitaryAI::GetNearestCoastalCity
; Function compile flags: /Odtp
;	COMDAT ?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T242923 = -8						; size = 4
?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ PROC ; CvAIOperationNavalAttack::GetOperationStartCity, COMDAT
; _this$ = ecx

; 5510 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 5511 : 	if(GetStartCityPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN1@GetOperati@4

; 5512 : 	{
; 5513 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	jmp	SHORT $LN2@GetOperati@4
$LN1@GetOperati@4:

; 5514 : 	}
; 5515 : 
; 5516 : 	return GET_PLAYER(m_eOwner).GetMilitaryAI()->GetNearestCoastalCity(m_eEnemy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T242923[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	mov	ecx, DWORD PTR $T242923[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetNearestCoastalCity
$LN2@GetOperati@4:

; 5517 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ ENDP ; CvAIOperationNavalAttack::GetOperationStartCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNavalAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 5521 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5522 : 	CvAssertMsg(false, "Obsolete function called CvAIOperationNavalAttack::FindBestTarget()");
; 5523 : 
; 5524 : 	return NULL;

	xor	eax, eax

; 5525 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNavalAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalSneakAttack@@6B@		; CvAIOperationNavalSneakAttack::`vftable'
PUBLIC	?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ ; CvAIOperationNavalSneakAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalSneakAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ ; CvAIOperationNavalSneakAttack::GetOperationName
EXTRN	??_ECvAIOperationNavalSneakAttack@@UAEPAXI@Z:PROC ; CvAIOperationNavalSneakAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationNavalSneakAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalSneakAttack@@6B@ DD FLAT:??_ECvAIOperationNavalSneakAttack@@UAEPAXI@Z ; CvAIOperationNavalSneakAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalSneakAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationNavalSneakAttack@@QAE@XZ PROC		; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack, COMDAT
; _this$ = ecx

; 5533 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperationNavalAttack@@QAE@XZ	; CvAIOperationNavalAttack::CvAIOperationNavalAttack
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalSneakAttack@@6B@

; 5534 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationNavalSneakAttack@@QAE@XZ ENDP		; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNavalSneakAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationNavalSneakAttack@@UAEPAXI@Z PROC	; CvAIOperationNavalSneakAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationNavalAttack@@UAE@XZ	; CvAIOperationNavalAttack::~CvAIOperationNavalAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@23
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@23:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationNavalSneakAttack@@UAEPAXI@Z ENDP	; CvAIOperationNavalSneakAttack::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalCityStateAttack@@6B@	; CvAIOperationNavalCityStateAttack::`vftable'
PUBLIC	?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ ; CvAIOperationNavalCityStateAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalCityStateAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ ; CvAIOperationNavalCityStateAttack::GetOperationName
EXTRN	??_ECvAIOperationNavalCityStateAttack@@UAEPAXI@Z:PROC ; CvAIOperationNavalCityStateAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationNavalCityStateAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalCityStateAttack@@6B@ DD FLAT:??_ECvAIOperationNavalCityStateAttack@@UAEPAXI@Z ; CvAIOperationNavalCityStateAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalCityStateAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationNavalCityStateAttack@@QAE@XZ PROC	; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack, COMDAT
; _this$ = ecx

; 5542 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperationNavalAttack@@QAE@XZ	; CvAIOperationNavalAttack::CvAIOperationNavalAttack
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNavalCityStateAttack@@6B@

; 5543 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationNavalCityStateAttack@@QAE@XZ ENDP	; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNavalCityStateAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationNavalCityStateAttack@@UAEPAXI@Z PROC	; CvAIOperationNavalCityStateAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationNavalAttack@@UAE@XZ	; CvAIOperationNavalAttack::~CvAIOperationNavalAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@24
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@24:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationNavalCityStateAttack@@UAEPAXI@Z ENDP	; CvAIOperationNavalCityStateAttack::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNukeAttack@@6B@		; CvAIOperationNukeAttack::`vftable'
PUBLIC	?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNukeAttack::Init
PUBLIC	?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ ; CvAIOperationNukeAttack::GetOperationType
PUBLIC	?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ ; CvAIOperationNukeAttack::NeedToCheckPathToTarget
PUBLIC	?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNukeAttack::GetFormation
PUBLIC	?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ ; CvAIOperationNukeAttack::GetOperationStartCity
PUBLIC	?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNukeAttack::ArmyInPosition
PUBLIC	?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationNukeAttack::Read
PUBLIC	?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationNukeAttack::Write
PUBLIC	?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ ; CvAIOperationNukeAttack::GetOperationName
PUBLIC	?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ; CvAIOperationNukeAttack::FindBestFitReserveUnit
PUBLIC	?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ	; CvAIOperationNukeAttack::GetDeployRange
PUBLIC	?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationNukeAttack::FindBestTarget
EXTRN	??_ECvAIOperationNukeAttack@@UAEPAXI@Z:PROC	; CvAIOperationNukeAttack::`vector deleting destructor'
;	COMDAT ??_7CvAIOperationNukeAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNukeAttack@@6B@ DD FLAT:??_ECvAIOperationNukeAttack@@UAEPAXI@Z ; CvAIOperationNukeAttack::`vftable'
	DD	FLAT:?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvAIOperationNukeAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAIOperationNukeAttack@@QAE@XZ PROC			; CvAIOperationNukeAttack::CvAIOperationNukeAttack, COMDAT
; _this$ = ecx

; 5547 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNukeAttack@@6B@

; 5548 : 	m_iBestUnitID = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], -1

; 5549 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAIOperationNukeAttack@@QAE@XZ ENDP			; CvAIOperationNukeAttack::CvAIOperationNukeAttack
_TEXT	ENDS
PUBLIC	??1CvAIOperationNukeAttack@@UAE@XZ		; CvAIOperationNukeAttack::~CvAIOperationNukeAttack
; Function compile flags: /Odtp
;	COMDAT ??_GCvAIOperationNukeAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvAIOperationNukeAttack@@UAEPAXI@Z PROC		; CvAIOperationNukeAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperationNukeAttack@@UAE@XZ	; CvAIOperationNukeAttack::~CvAIOperationNukeAttack
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@25
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@25:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvAIOperationNukeAttack@@UAEPAXI@Z ENDP		; CvAIOperationNukeAttack::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAIOperationNukeAttack@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAIOperationNukeAttack@@UAE@XZ PROC			; CvAIOperationNukeAttack::~CvAIOperationNukeAttack, COMDAT
; _this$ = ecx

; 5552 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvAIOperationNukeAttack@@6B@

; 5553 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAIOperationNukeAttack@@UAE@XZ ENDP			; CvAIOperationNukeAttack::~CvAIOperationNukeAttack
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T243107 = -100						; size = 4
$T243106 = -96						; size = 4
$T243105 = -92						; size = 4
$T243092 = -88						; size = 4
$T243086 = -84						; size = 4
$T242954 = -16						; size = 4
_pTargetPlot$225922 = -12				; size = 4
_pArmyAI$225919 = -8					; size = 4
_kPlayer$225918 = -4					; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNukeAttack::Init, COMDAT
; _this$ = ecx

; 5556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 5557 : 	Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 5558 : 	m_eMoveType = AI_OPERATION_MOVETYPE_STATIC; // this operation will only work when the units are already in place

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 5

; 5559 : 	m_iID = iID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [edx+52], eax

; 5560 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 5561 : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 5562 : 
; 5563 : 	if(iID != -1)

	cmp	DWORD PTR _iID$[ebp], -1
	je	$LN7@Init@13

; 5564 : 	{
; 5565 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 5566 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225918[ebp], eax

; 5567 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, DWORD PTR _kPlayer$225918[ebp]
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	DWORD PTR _pArmyAI$225919[ebp], eax

; 5568 : 		if(pArmyAI)

	cmp	DWORD PTR _pArmyAI$225919[ebp], 0
	je	$LN7@Init@13

; 5569 : 		{
; 5570 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, DWORD PTR _pArmyAI$225919[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T242954[ebp], eax
	lea	ecx, DWORD PTR $T242954[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 5571 : 			pArmyAI->Init(pArmyAI->GetID(), m_eOwner, m_iID);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225919[ebp]
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225919[ebp]
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 5572 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, DWORD PTR _pArmyAI$225919[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5573 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pArmyAI$225919[ebp]
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 5574 : 
; 5575 : 			// Figure out the target spot
; 5576 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	mov	DWORD PTR _pTargetPlot$225922[ebp], eax

; 5577 : 			if(pTargetPlot != NULL)

	cmp	DWORD PTR _pTargetPlot$225922[ebp], 0
	je	$LN4@Init@13

; 5578 : 			{
; 5579 : 				SetTargetPlot(pTargetPlot);

	mov	ecx, DWORD PTR _pTargetPlot$225922[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetTargetPlot

; 5580 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	mov	edx, DWORD PTR _pTargetPlot$225922[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArmyAI$225919[ebp]
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 5581 : 				// Find the list of units we need to build before starting this operation in earnest
; 5582 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	call	eax

; 5583 : 				// try to get as many units as possible from existing units that are waiting around
; 5584 : 				if(GrabUnitsFromTheReserves(GC.getMap().plotCheckInvalid(m_iMusterX, m_iMusterY), pTargetPlot))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T243086[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T243106[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T243105[ebp], edx
	cmp	DWORD PTR $T243105[ebp], -2147483647	; 80000001H
	je	SHORT $LN63@Init@13
	cmp	DWORD PTR $T243106[ebp], -2147483647	; 80000001H
	jne	SHORT $LN64@Init@13
$LN63@Init@13:
	mov	DWORD PTR $T243107[ebp], 0
	jmp	SHORT $LN65@Init@13
$LN64@Init@13:
	mov	eax, DWORD PTR $T243086[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T243092[ebp], ecx
	mov	edx, DWORD PTR $T243106[ebp]
	imul	edx, DWORD PTR $T243092[ebp]
	add	edx, DWORD PTR $T243105[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T243086[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR $T243107[ebp], edx
$LN65@Init@13:
	mov	ecx, DWORD PTR _pTargetPlot$225922[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243107[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Init@13

; 5585 : 				{
; 5586 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_AT_DESTINATION);

	push	3
	mov	ecx, DWORD PTR _pArmyAI$225919[ebp]
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5587 : 					m_eCurrentState = AI_OPERATION_STATE_AT_TARGET;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 4

; 5588 : 					LogOperationStart();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart

; 5589 : 					ArmyInPosition(pArmyAI);

	mov	eax, DWORD PTR _pArmyAI$225919[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	call	eax

; 5590 : 				}
; 5591 : 				else

	jmp	SHORT $LN2@Init@13
$LN3@Init@13:

; 5592 : 				{
; 5593 : 					// No nukes, abort
; 5594 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 5595 : 					m_eAbortReason = AI_ABORT_NO_NUKES;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 10			; 0000000aH
$LN2@Init@13:

; 5596 : 				}
; 5597 : 			}
; 5598 : 
; 5599 : 			else

	jmp	SHORT $LN7@Init@13
$LN4@Init@13:

; 5600 : 			{
; 5601 : 				// No target, abort
; 5602 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0

; 5603 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 3
$LN7@Init@13:

; 5604 : 			}
; 5605 : 		}
; 5606 : 	}
; 5607 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNukeAttack::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNukeAttack::Read, COMDAT
; _this$ = ecx

; 5612 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5613 : 	// read the base class' entries
; 5614 : 	CvAIOperation::Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 5615 : 
; 5616 : 	// Version number to maintain backwards compatibility
; 5617 : 	uint uiVersion;
; 5618 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5619 : 
; 5620 : 	kStream >> m_iBestUnitID;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5621 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNukeAttack::Read
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNukeAttack::Write, COMDAT
; _this$ = ecx

; 5625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 5626 : 	// write the base class' entries
; 5627 : 	CvAIOperation::Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 5628 : 
; 5629 : 	// Current version number
; 5630 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 5631 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5632 : 
; 5633 : 	kStream << m_iBestUnitID;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5634 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNukeAttack::Write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T243155 = -24						; size = 4
$T243154 = -20						; size = 4
$T243153 = -16						; size = 4
$T243140 = -12						; size = 4
$T243134 = -8						; size = 4
?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ PROC ; CvAIOperationNukeAttack::GetOperationStartCity, COMDAT
; _this$ = ecx

; 5637 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 5638 : 	if(GetStartCityPlot())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN1@GetOperati@5

; 5639 : 	{
; 5640 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	jmp	SHORT $LN2@GetOperati@5
$LN1@GetOperati@5:

; 5641 : 	}
; 5642 : 
; 5643 : 	return GC.getMap().plotCheckInvalid(m_iMusterX, m_iMusterY)->getPlotCity();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T243134[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T243154[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T243153[ebp], ecx
	cmp	DWORD PTR $T243153[ebp], -2147483647	; 80000001H
	je	SHORT $LN11@GetOperati@5
	cmp	DWORD PTR $T243154[ebp], -2147483647	; 80000001H
	jne	SHORT $LN12@GetOperati@5
$LN11@GetOperati@5:
	mov	DWORD PTR $T243155[ebp], 0
	jmp	SHORT $LN13@GetOperati@5
$LN12@GetOperati@5:
	mov	edx, DWORD PTR $T243134[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T243140[ebp], eax
	mov	ecx, DWORD PTR $T243154[ebp]
	imul	ecx, DWORD PTR $T243140[ebp]
	add	ecx, DWORD PTR $T243153[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T243134[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR $T243155[ebp], ecx
$LN13@GetOperati@5:
	mov	ecx, DWORD PTR $T243155[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
$LN2@GetOperati@5:

; 5644 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ ENDP ; CvAIOperationNukeAttack::GetOperationStartCity
_TEXT	ENDS
PUBLIC	??_C@_0BN@LCJMDPJ@City?5nuked?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_NUKE
EXTRN	?canNukeAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canNukeAt
;	COMDAT ??_C@_0BN@LCJMDPJ@City?5nuked?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BN@LCJMDPJ@City?5nuked?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@ DB 'C'
	DB	'ity nuked, At X=%d, At Y=%d', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T243192 = -80						; size = 4
$T243184 = -76						; size = 4
$T243180 = -72						; size = 4
$T243176 = -68						; size = 4
$T243172 = -64						; size = 4
$T243168 = -60						; size = 4
_strMsg$225953 = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_pNuke$225948 = -24					; size = 4
_iUnitID$225947 = -20					; size = 4
_pTargetPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNukeAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 5647 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5648 : 	CvPlot* pTargetPlot = GetTargetPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	DWORD PTR _pTargetPlot$[ebp], eax

; 5649 : 	if(pTargetPlot)

	cmp	DWORD PTR _pTargetPlot$[ebp], 0
	je	$LN5@ArmyInPosi@14

; 5650 : 	{
; 5651 : 		// Now get the nuke
; 5652 : 		int iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[ebp]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	DWORD PTR _iUnitID$225947[ebp], eax

; 5653 : 		CvUnit* pNuke = NULL;

	mov	DWORD PTR _pNuke$225948[ebp], 0

; 5654 : 		if(iUnitID != -1)

	cmp	DWORD PTR _iUnitID$225947[ebp], -1
	je	SHORT $LN4@ArmyInPosi@14

; 5655 : 		{
; 5656 : 			pNuke = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243168[ebp], ecx
	mov	edx, DWORD PTR _iUnitID$225947[ebp]
	push	edx
	mov	ecx, DWORD PTR $T243168[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	DWORD PTR _pNuke$225948[ebp], eax
$LN4@ArmyInPosi@14:

; 5657 : 		}
; 5658 : 
; 5659 : 		if(pNuke != NULL)

	cmp	DWORD PTR _pNuke$225948[ebp], 0
	je	$LN5@ArmyInPosi@14

; 5660 : 		{
; 5661 : 			if(pNuke->canMove() && pNuke->canNukeAt(pNuke->plot(),pTargetPlot->getX(),pTargetPlot->getY()))

	mov	ecx, DWORD PTR _pNuke$225948[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	$LN5@ArmyInPosi@14
	mov	ecx, DWORD PTR _pTargetPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T243172[ebp], edx
	mov	eax, DWORD PTR _pTargetPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T243176[ebp], ecx
	mov	edx, DWORD PTR $T243172[ebp]
	push	edx
	mov	eax, DWORD PTR $T243176[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNuke$225948[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pNuke$225948[ebp]
	call	?canNukeAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z	; CvUnit::canNukeAt
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@ArmyInPosi@14

; 5662 : 			{
; 5663 : 				pNuke->PushMission(CvTypes::getMISSION_NUKE(), pTargetPlot->getX(), pTargetPlot->getY());

	mov	edx, DWORD PTR _pTargetPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T243180[ebp], eax
	mov	ecx, DWORD PTR _pTargetPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T243184[ebp], edx
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T243180[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243184[ebp]
	push	ecx
	call	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_NUKE
	push	eax
	mov	ecx, DWORD PTR _pNuke$225948[ebp]
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5664 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@ArmyInPosi@14
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@ArmyInPosi@14

; 5665 : 				{
; 5666 : 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$225953[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5667 : 					strMsg.Format("City nuked, At X=%d, At Y=%d", pTargetPlot->getX(), pTargetPlot->getY());

	mov	ecx, DWORD PTR _pTargetPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T243192[ebp], edx
	mov	eax, DWORD PTR $T243192[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTargetPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0BN@LCJMDPJ@City?5nuked?0?5At?5X?$DN?$CFd?0?5At?5Y?$DN?$CFd?$AA@
	lea	eax, DWORD PTR _strMsg$225953[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5668 : 					LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$225953[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage

; 5669 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$225953[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ArmyInPosi@14:

; 5670 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 5
$LN5@ArmyInPosi@14:

; 5671 : 			}
; 5672 : 		}
; 5673 : 	}
; 5674 : 	return true;

	mov	al, 1

; 5675 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$225953[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNukeAttack::ArmyInPosition
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?canNuke@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canNuke
; Function compile flags: /Odtp
;	COMDAT ?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -276						; size = 4
$T243491 = -272						; size = 4
$T243482 = -268						; size = 4
$T243473 = -264						; size = 4
_playerID$243449 = -260					; size = 4
$T243332 = -188						; size = 4
$T243328 = -184						; size = 4
$T243263 = -112						; size = 4
$T243254 = -108						; size = 4
$T243245 = -104						; size = 4
$T243236 = -100						; size = 4
_eUnitOwner$226011 = -96				; size = 4
_eUnitTeam$226012 = -92					; size = 4
_pUnitNode$226005 = -88					; size = 4
_ePlotTeam$225993 = -84					; size = 4
_pInnerLoopUnit$226006 = -80				; size = 4
_ePlotOwner$225992 = -76				; size = 4
_pLoopPlot$225990 = -72					; size = 4
_iDY$225986 = -68					; size = 4
_iDX$225982 = -64					; size = 4
_pCityPlot$225980 = -60					; size = 4
_iThisCityValue$225981 = -56				; size = 4
_iUnitRange$225973 = -52				; size = 4
_pLoopCity$225974 = -48					; size = 4
_iBlastRadius$ = -44					; size = 4
_iCityLoop$ = -40					; size = 4
_pBestUnit$ = -36					; size = 4
_ourTeam$ = -32						; size = 4
_pLoopUnit$ = -28					; size = 4
_pBestCity$ = -24					; size = 4
_iBestCity$ = -20					; size = 4
_iUnitLoop$ = -16					; size = 4
_eTeam$ = -12						; size = 4
_enemyPlayer$ = -8					; size = 4
_ownerPlayer$ = -4					; size = 4
?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNukeAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 5678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	DWORD PTR _this$[ebp], ecx

; 5679 : 	CvUnit* pLoopUnit;
; 5680 : 	CvUnit* pBestUnit = NULL;

	mov	DWORD PTR _pBestUnit$[ebp], 0

; 5681 : 	CvCity* pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[ebp], 0

; 5682 : 	int iBestCity = 0;

	mov	DWORD PTR _iBestCity$[ebp], 0

; 5683 : 	int iUnitLoop = 0;

	mov	DWORD PTR _iUnitLoop$[ebp], 0

; 5684 : 	int iCityLoop = 0;

	mov	DWORD PTR _iCityLoop$[ebp], 0

; 5685 : 	CvPlayerAI& ownerPlayer = GET_PLAYER(m_eOwner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _ownerPlayer$[ebp], ecx

; 5686 : 	TeamTypes eTeam = ownerPlayer.getTeam();

	mov	edx, DWORD PTR _ownerPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 5687 : 	CvTeam& ourTeam = GET_TEAM(eTeam);

	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _ourTeam$[ebp], ecx

; 5688 : 	CvPlayerAI& enemyPlayer = GET_PLAYER(m_eEnemy);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _enemyPlayer$[ebp], eax

; 5689 : 
; 5690 : 	int iBlastRadius = GC.getNUKE_BLAST_RADIUS();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6672
	mov	DWORD PTR _iBlastRadius$[ebp], ecx

; 5691 : 
; 5692 : 	// check all of our units to find the nukes
; 5693 : 	for(pLoopUnit = ownerPlayer.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iUnitLoop))

	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN38@FindBestTa@11
$LN37@FindBestTa@11:
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN38@FindBestTa@11:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN36@FindBestTa@11

; 5694 : 	{
; 5695 : 		if(pLoopUnit && pLoopUnit->canNuke(NULL))

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN35@FindBestTa@11
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canNuke@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canNuke
	movzx	ecx, al
	test	ecx, ecx
	je	$LN35@FindBestTa@11

; 5696 : 		{
; 5697 : 			int iUnitRange = pLoopUnit->GetRange();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	mov	DWORD PTR _iUnitRange$225973[ebp], eax

; 5698 : 			// for all cities of this enemy
; 5699 : 			CvCity* pLoopCity;
; 5700 : 			for(pLoopCity = enemyPlayer.firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = enemyPlayer.nextCity(&iCityLoop))

	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _enemyPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$225974[ebp], eax
	jmp	SHORT $LN34@FindBestTa@11
$LN33@FindBestTa@11:
	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _enemyPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$225974[ebp], eax
$LN34@FindBestTa@11:
	cmp	DWORD PTR _pLoopCity$225974[ebp], 0
	je	$LN35@FindBestTa@11

; 5701 : 			{
; 5702 : 				if(pLoopCity)

	cmp	DWORD PTR _pLoopCity$225974[ebp], 0
	je	$LN31@FindBestTa@11

; 5703 : 				{
; 5704 : 					if(plotDistance(pLoopUnit->getX(),pLoopUnit->getY(),pLoopCity->getX(),pLoopCity->getY()) <= iUnitRange)

	mov	ecx, DWORD PTR _pLoopCity$225974[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T243236[ebp], edx
	mov	eax, DWORD PTR _pLoopCity$225974[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T243245[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T243254[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T243263[ebp], edx
	mov	eax, DWORD PTR $T243236[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243245[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243254[ebp]
	push	edx
	mov	eax, DWORD PTR $T243263[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iUnitRange$225973[ebp]
	jg	$LN31@FindBestTa@11

; 5705 : 					{
; 5706 : 						CvPlot* pCityPlot = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$225974[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pCityPlot$225980[ebp], eax

; 5707 : 						int iThisCityValue = pLoopCity->getPopulation();

	mov	ecx, DWORD PTR _pLoopCity$225974[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	DWORD PTR _iThisCityValue$225981[ebp], eax

; 5708 : 						iThisCityValue -= pLoopCity->getDamage() / 5; // No point nuking a city that is already trashed unless it is good city

	mov	ecx, DWORD PTR _pLoopCity$225974[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	cdq
	mov	ecx, 5
	idiv	ecx
	mov	edx, DWORD PTR _iThisCityValue$225981[ebp]
	sub	edx, eax
	mov	DWORD PTR _iThisCityValue$225981[ebp], edx

; 5709 : 
; 5710 : 						// check to see if there is anything good or bad in the radius that we should account for
; 5711 : 
; 5712 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 5713 : 						int iMaxDX, iDX;
; 5714 : 						CvPlot* pLoopPlot;
; 5715 : 						for (int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)
; 5716 : 						{
; 5717 : 							iMaxDX = iBlastRadius - MAX(0, iDY);
; 5718 : 							for (iDX = -iBlastRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 5719 : 							{
; 5720 : 								// No need for range check because loops are set up properly
; 5721 : 								pLoopPlot = plotXY(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY);
; 5722 : #else
; 5723 : 						for(int iDX = -iBlastRadius; iDX <= iBlastRadius; iDX++)

	mov	eax, DWORD PTR _iBlastRadius$[ebp]
	neg	eax
	mov	DWORD PTR _iDX$225982[ebp], eax
	jmp	SHORT $LN29@FindBestTa@11
$LN28@FindBestTa@11:
	mov	ecx, DWORD PTR _iDX$225982[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDX$225982[ebp], ecx
$LN29@FindBestTa@11:
	mov	edx, DWORD PTR _iDX$225982[ebp]
	cmp	edx, DWORD PTR _iBlastRadius$[ebp]
	jg	$LN27@FindBestTa@11

; 5724 : 						{
; 5725 : 							for(int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)

	mov	eax, DWORD PTR _iBlastRadius$[ebp]
	neg	eax
	mov	DWORD PTR _iDY$225986[ebp], eax
	jmp	SHORT $LN26@FindBestTa@11
$LN25@FindBestTa@11:
	mov	ecx, DWORD PTR _iDY$225986[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$225986[ebp], ecx
$LN26@FindBestTa@11:
	mov	edx, DWORD PTR _iDY$225986[ebp]
	cmp	edx, DWORD PTR _iBlastRadius$[ebp]
	jg	$LN24@FindBestTa@11

; 5726 : 							{
; 5727 : 								CvPlot* pLoopPlot = plotXYWithRangeCheck(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY, iBlastRadius);

	mov	eax, DWORD PTR _pCityPlot$225980[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T243328[ebp], ecx
	mov	edx, DWORD PTR _pCityPlot$225980[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T243332[ebp], eax
	mov	ecx, DWORD PTR _iBlastRadius$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDY$225986[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$225982[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243328[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243332[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$225990[ebp], eax

; 5728 : #endif
; 5729 : 								if(pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$225990[ebp], 0
	je	$LN23@FindBestTa@11

; 5730 : 								{
; 5731 : 									// who owns this plot?
; 5732 : 									PlayerTypes ePlotOwner = pLoopPlot->getOwner();

	mov	eax, DWORD PTR _pLoopPlot$225990[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _ePlotOwner$225992[ebp], ecx

; 5733 : 									TeamTypes ePlotTeam = pLoopPlot->getTeam();

	mov	edx, DWORD PTR _pLoopPlot$225990[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$243449[ebp], eax
	cmp	DWORD PTR _playerID$243449[ebp], -1
	je	SHORT $LN173@FindBestTa@11
	mov	ecx, DWORD PTR _playerID$243449[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlotTeam$225993[ebp], eax
	jmp	SHORT $LN174@FindBestTa@11
	jmp	SHORT $LN174@FindBestTa@11
$LN173@FindBestTa@11:
	mov	DWORD PTR _ePlotTeam$225993[ebp], -1
$LN174@FindBestTa@11:

; 5734 : 									// are we at war with them (or are they us)
; 5735 : 									if(ePlotOwner == m_eOwner)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ePlotOwner$225992[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jne	SHORT $LN22@FindBestTa@11

; 5736 : 									{
; 5737 : 										iThisCityValue -= 1;

	mov	ecx, DWORD PTR _iThisCityValue$225981[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iThisCityValue$225981[ebp], ecx

; 5738 : 										if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN21@FindBestTa@11

; 5739 : 										{
; 5740 : 											if(!pLoopPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN21@FindBestTa@11

; 5741 : 											{
; 5742 : 												iThisCityValue -= 5;

	mov	eax, DWORD PTR _iThisCityValue$225981[ebp]
	sub	eax, 5
	mov	DWORD PTR _iThisCityValue$225981[ebp], eax

; 5743 : 												if(pLoopPlot->getResourceType(ePlotTeam) != NO_RESOURCE)  // we aren't nuking our own resources

	mov	ecx, DWORD PTR _ePlotTeam$225993[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN21@FindBestTa@11

; 5744 : 												{
; 5745 : 													iThisCityValue -= 1000;

	mov	edx, DWORD PTR _iThisCityValue$225981[ebp]
	sub	edx, 1000				; 000003e8H
	mov	DWORD PTR _iThisCityValue$225981[ebp], edx
$LN21@FindBestTa@11:

; 5746 : 												}
; 5747 : 											}
; 5748 : 										}
; 5749 : 									}

	jmp	SHORT $LN18@FindBestTa@11
$LN22@FindBestTa@11:

; 5750 : 									else if(ePlotTeam != NO_TEAM && ourTeam.isAtWar(ePlotTeam))

	cmp	DWORD PTR _ePlotTeam$225993[ebp], -1
	je	SHORT $LN17@FindBestTa@11
	mov	eax, DWORD PTR _ePlotTeam$225993[ebp]
	push	eax
	mov	ecx, DWORD PTR _ourTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@FindBestTa@11

; 5751 : 									{
; 5752 : 										iThisCityValue += 1;

	mov	edx, DWORD PTR _iThisCityValue$225981[ebp]
	add	edx, 1
	mov	DWORD PTR _iThisCityValue$225981[ebp], edx

; 5753 : 										if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN16@FindBestTa@11

; 5754 : 										{
; 5755 : 											if(!pLoopPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN16@FindBestTa@11

; 5756 : 											{
; 5757 : 												iThisCityValue += 2;

	mov	ecx, DWORD PTR _iThisCityValue$225981[ebp]
	add	ecx, 2
	mov	DWORD PTR _iThisCityValue$225981[ebp], ecx

; 5758 : 												if(pLoopPlot->getResourceType(ePlotTeam) != NO_RESOURCE)  // we like nuking our their resources

	mov	edx, DWORD PTR _ePlotTeam$225993[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN16@FindBestTa@11

; 5759 : 												{
; 5760 : 													iThisCityValue += 5;

	mov	eax, DWORD PTR _iThisCityValue$225981[ebp]
	add	eax, 5
	mov	DWORD PTR _iThisCityValue$225981[ebp], eax
$LN16@FindBestTa@11:

; 5761 : 												}
; 5762 : 											}
; 5763 : 										}
; 5764 : 									}

	jmp	SHORT $LN18@FindBestTa@11
$LN17@FindBestTa@11:

; 5765 : 									else if (ePlotOwner != NO_PLAYER) // this will trigger a war

	cmp	DWORD PTR _ePlotOwner$225992[ebp], -1
	je	SHORT $LN18@FindBestTa@11

; 5766 : 									{
; 5767 : 										iThisCityValue -= 1000;

	mov	ecx, DWORD PTR _iThisCityValue$225981[ebp]
	sub	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iThisCityValue$225981[ebp], ecx
$LN18@FindBestTa@11:

; 5768 : 									}
; 5769 : 
; 5770 : 									// will we hit any units here?
; 5771 : 
; 5772 : 									// Do we want a visibility check here?  We shouldn't know they are here.
; 5773 : 
; 5774 : 									const IDInfo* pUnitNode = pLoopPlot->headUnitNode();

	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$226005[ebp], eax
$LN11@FindBestTa@11:

; 5775 : 									const CvUnit* pInnerLoopUnit;
; 5776 : 									while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$226005[ebp], 0
	je	$LN23@FindBestTa@11

; 5777 : 									{
; 5778 : 										pInnerLoopUnit = ::getUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$226005[ebp]
	push	edx
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4
	mov	DWORD PTR _pInnerLoopUnit$226006[ebp], eax

; 5779 : 										pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$226005[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$225990[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$226005[ebp], eax

; 5780 : 										if(pInnerLoopUnit != NULL)

	cmp	DWORD PTR _pInnerLoopUnit$226006[ebp], 0
	je	SHORT $LN9@FindBestTa@11

; 5781 : 										{
; 5782 : 											PlayerTypes eUnitOwner = pInnerLoopUnit->getOwner();

	mov	ecx, DWORD PTR _pInnerLoopUnit$226006[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _eUnitOwner$226011[ebp], edx

; 5783 : 											TeamTypes eUnitTeam = pInnerLoopUnit->getTeam();

	mov	ecx, DWORD PTR _pInnerLoopUnit$226006[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _eUnitTeam$226012[ebp], eax

; 5784 : 											// are we at war with them (or are they us)
; 5785 : 											if(eUnitOwner == m_eOwner)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eUnitOwner$226011[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jne	SHORT $LN8@FindBestTa@11

; 5786 : 											{
; 5787 : 												iThisCityValue -= 2;

	mov	edx, DWORD PTR _iThisCityValue$225981[ebp]
	sub	edx, 2
	mov	DWORD PTR _iThisCityValue$225981[ebp], edx
	jmp	SHORT $LN9@FindBestTa@11
$LN8@FindBestTa@11:

; 5788 : 											}
; 5789 : 											else if(ourTeam.isAtWar(eUnitTeam))

	mov	eax, DWORD PTR _eUnitTeam$226012[ebp]
	push	eax
	mov	ecx, DWORD PTR _ourTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@FindBestTa@11

; 5790 : 											{
; 5791 : 												iThisCityValue += 2;

	mov	edx, DWORD PTR _iThisCityValue$225981[ebp]
	add	edx, 2
	mov	DWORD PTR _iThisCityValue$225981[ebp], edx
	jmp	SHORT $LN9@FindBestTa@11
$LN6@FindBestTa@11:

; 5792 : 											}
; 5793 : 											else if (ePlotOwner != NO_PLAYER) // this will trigger a war

	cmp	DWORD PTR _ePlotOwner$225992[ebp], -1
	je	SHORT $LN9@FindBestTa@11

; 5794 : 											{
; 5795 : 												iThisCityValue -= 1000;

	mov	eax, DWORD PTR _iThisCityValue$225981[ebp]
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR _iThisCityValue$225981[ebp], eax
$LN9@FindBestTa@11:

; 5796 : 											}
; 5797 : 										}
; 5798 : 									}

	jmp	$LN11@FindBestTa@11
$LN23@FindBestTa@11:

; 5799 : 								}
; 5800 : 							}

	jmp	$LN25@FindBestTa@11
$LN24@FindBestTa@11:

; 5801 : 						}

	jmp	$LN28@FindBestTa@11
$LN27@FindBestTa@11:

; 5802 : 
; 5803 : 						// if this is the capital
; 5804 : 						if(pLoopCity->isCapital())

	mov	ecx, DWORD PTR _pLoopCity$225974[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@FindBestTa@11

; 5805 : 						{
; 5806 : 							iThisCityValue *= 2;

	mov	edx, DWORD PTR _iThisCityValue$225981[ebp]
	shl	edx, 1
	mov	DWORD PTR _iThisCityValue$225981[ebp], edx
$LN3@FindBestTa@11:

; 5807 : 						}
; 5808 : 
; 5809 : 						if(iThisCityValue > iBestCity)

	mov	eax, DWORD PTR _iThisCityValue$225981[ebp]
	cmp	eax, DWORD PTR _iBestCity$[ebp]
	jle	SHORT $LN31@FindBestTa@11

; 5810 : 						{
; 5811 : 							pBestUnit = pLoopUnit;

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR _pBestUnit$[ebp], ecx

; 5812 : 							pBestCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$225974[ebp]
	mov	DWORD PTR _pBestCity$[ebp], edx

; 5813 : 							iBestCity = iThisCityValue;

	mov	eax, DWORD PTR _iThisCityValue$225981[ebp]
	mov	DWORD PTR _iBestCity$[ebp], eax
$LN31@FindBestTa@11:

; 5814 : 						}
; 5815 : 					}
; 5816 : 				}
; 5817 : 			}

	jmp	$LN33@FindBestTa@11
$LN35@FindBestTa@11:

; 5818 : 		}
; 5819 : 	}

	jmp	$LN37@FindBestTa@11
$LN36@FindBestTa@11:

; 5820 : 
; 5821 : 	if(pBestCity && pBestUnit)

	cmp	DWORD PTR _pBestCity$[ebp], 0
	je	SHORT $LN1@FindBestTa@11
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN1@FindBestTa@11

; 5822 : 	{
; 5823 : 		m_iMusterX = pBestUnit->getX();

	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T243473[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T243473[ebp]
	mov	DWORD PTR [eax+96], ecx

; 5824 : 		m_iMusterY = pBestUnit->getY();

	mov	edx, DWORD PTR _pBestUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T243482[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T243482[ebp]
	mov	DWORD PTR [ecx+100], edx

; 5825 : 		m_iBestUnitID = pBestUnit->GetID();

	mov	eax, DWORD PTR _pBestUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T243491[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T243491[ebp]
	mov	DWORD PTR [edx+112], eax

; 5826 : 		return pBestCity->plot();

	mov	ecx, DWORD PTR _pBestCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	jmp	SHORT $LN39@FindBestTa@11
$LN1@FindBestTa@11:

; 5827 : 	}
; 5828 : 
; 5829 : 	return NULL;

	xor	eax, eax
$LN39@FindBestTa@11:

; 5830 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNukeAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216767 = -20					; size = 4
_iAbsDX$216766 = -16					; size = 4
_iAbsDY$216764 = -12					; size = 4
_iAbsDX$216763 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216763[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216764[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216763[ebp]
	add	edx, DWORD PTR _iAbsDY$216764[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216766[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216767[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216766[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216767[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216766[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216767[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T243746 = -56						; size = 4
$T243701 = -52						; size = 4
$T243688 = -48						; size = 4
$T243684 = -44						; size = 4
$T243670 = -40						; size = 4
$T243666 = -33						; size = 1
$T243655 = -32						; size = 4
$T243651 = -25						; size = 1
_iMapY$243710 = -24					; size = 4
_iMapX$243709 = -20					; size = 4
$T243644 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T243644[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T243746[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T243644[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T243651[ebp], dl
	mov	eax, DWORD PTR $T243644[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T243655[ebp], ecx
	movzx	edx, BYTE PTR $T243651[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T243655[ebp]
	add	edx, DWORD PTR $T243655[ebp]
	mov	DWORD PTR _iMapX$243709[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T243655[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T243655[ebp]
	mov	DWORD PTR _iMapX$243709[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$243709[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T243644[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T243666[ebp], al
	mov	ecx, DWORD PTR $T243644[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T243670[ebp], edx
	movzx	eax, BYTE PTR $T243666[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T243670[ebp]
	add	edx, DWORD PTR $T243670[ebp]
	mov	DWORD PTR _iMapY$243710[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T243670[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T243670[ebp]
	mov	DWORD PTR _iMapY$243710[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$243710[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$243709[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T243644[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T243684[ebp], ecx
	mov	edx, DWORD PTR _iMapX$243709[ebp]
	cmp	edx, DWORD PTR $T243684[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$243710[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T243644[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T243688[ebp], ecx
	mov	edx, DWORD PTR _iMapY$243710[ebp]
	cmp	edx, DWORD PTR $T243688[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T243644[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T243701[ebp], ecx
	mov	edx, DWORD PTR _iMapY$243710[ebp]
	imul	edx, DWORD PTR $T243701[ebp]
	add	edx, DWORD PTR _iMapX$243709[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T243644[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T243746[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T243746[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
_TEXT	ENDS
;	COMDAT ?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_ownerPlayer$ = -8					; size = 4
_pThisArmy$ = -4					; size = 4
_thisOperationSlot$ = 8					; size = 12
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
_bRequired$ = 28					; size = 4
?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z PROC ; CvAIOperationNukeAttack::FindBestFitReserveUnit, COMDAT
; _this$ = ecx

; 5838 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 5839 : 	// okay, this can be simplified to
; 5840 : 	*bRequired = true;

	mov	eax, DWORD PTR _bRequired$[ebp]
	mov	BYTE PTR [eax], 1

; 5841 : 	CvPlayerAI& ownerPlayer = GET_PLAYER(m_eOwner);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _ownerPlayer$[ebp], edx

; 5842 : 	CvArmyAI* pThisArmy = ownerPlayer.getArmyAI(thisOperationSlot.m_iArmyID);

	mov	eax, DWORD PTR _thisOperationSlot$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _ownerPlayer$[ebp]
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	DWORD PTR _pThisArmy$[ebp], eax

; 5843 : 	pThisArmy->AddUnit(m_iBestUnitID, thisOperationSlot.m_iSlotID);

	mov	ecx, DWORD PTR _thisOperationSlot$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	mov	ecx, DWORD PTR _pThisArmy$[ebp]
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 5844 : 	return true;

	mov	al, 1

; 5845 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ENDP ; CvAIOperationNukeAttack::FindBestFitReserveUnit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z
_TEXT	SEGMENT
_v$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z PROC ; operator<<, COMDAT

; 5849 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5850 : 	int v = static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _v$[ebp], ecx

; 5851 : 	saveTo << v;

	lea	edx, DWORD PTR _v$[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5852 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 5853 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z ENDP ; operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z
_TEXT	SEGMENT
_v$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z PROC ; operator>>, COMDAT

; 5856 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5857 : 	int v;
; 5858 : 	loadFrom >> v;

	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5859 : 	writeTo = static_cast<AIOperationState>(v);

	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], edx

; 5860 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 5861 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z	; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z PROC	; operator<<, COMDAT

; 5864 : {

	push	ebp
	mov	ebp, esp

; 5865 : 	saveTo << readFrom.m_iOperationID;

	mov	eax, DWORD PTR _readFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5866 : 	saveTo << readFrom.m_iArmyID;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5867 : 	saveTo << readFrom.m_iSlotID;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5868 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 5869 : }

	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z	; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z PROC	; operator>>, COMDAT

; 5872 : {

	push	ebp
	mov	ebp, esp

; 5873 : 	loadFrom >> writeTo.m_iOperationID;

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5874 : 	loadFrom >> writeTo.m_iArmyID;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5875 : 	loadFrom >> writeTo.m_iSlotID;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5876 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 5877 : }

	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z ENDP	; operator>>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z
_TEXT	SEGMENT
_iRange$ = -4						; size = 4
_iTotalUnits$ = 8					; size = 4
?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z PROC ; OperationalAIHelpers::GetGatherRangeForXUnits, COMDAT

; 5880 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5881 : 	int iRange = 0;

	mov	DWORD PTR _iRange$[ebp], 0

; 5882 : 
; 5883 : 	if(iTotalUnits <= 2)

	cmp	DWORD PTR _iTotalUnits$[ebp], 2
	jg	SHORT $LN6@GetGatherR

; 5884 : 	{
; 5885 : 		iRange = 1;

	mov	DWORD PTR _iRange$[ebp], 1
	jmp	SHORT $LN5@GetGatherR
$LN6@GetGatherR:

; 5886 : 	}
; 5887 : 	else if(iTotalUnits <= 6)

	cmp	DWORD PTR _iTotalUnits$[ebp], 6
	jg	SHORT $LN4@GetGatherR

; 5888 : 	{
; 5889 : 		iRange = 2;

	mov	DWORD PTR _iRange$[ebp], 2
	jmp	SHORT $LN5@GetGatherR
$LN4@GetGatherR:

; 5890 : 	}
; 5891 : 	else if(iTotalUnits <= 10)

	cmp	DWORD PTR _iTotalUnits$[ebp], 10	; 0000000aH
	jg	SHORT $LN2@GetGatherR

; 5892 : 	{
; 5893 : 		iRange = 3;

	mov	DWORD PTR _iRange$[ebp], 3

; 5894 : 	}
; 5895 : 	else

	jmp	SHORT $LN5@GetGatherR
$LN2@GetGatherR:

; 5896 : 	{
; 5897 : 		iRange = 4;

	mov	DWORD PTR _iRange$[ebp], 4
$LN5@GetGatherR:

; 5898 : 	}
; 5899 : 
; 5900 : 	return iRange;

	mov	eax, DWORD PTR _iRange$[ebp]

; 5901 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z ENDP ; OperationalAIHelpers::GetGatherRangeForXUnits
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T243841 = -44						; size = 4
$T243840 = -40						; size = 4
$T243829 = -36						; size = 4
$T243828 = -32						; size = 4
__Cat$243835 = -28					; size = 1
$T243832 = -27						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 4
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243841[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 4
	mov	DWORD PTR $T243840[ebp], ecx
	mov	edx, DWORD PTR $T243841[ebp]
	mov	DWORD PTR $T243829[ebp], edx
	mov	eax, DWORD PTR $T243840[ebp]
	mov	DWORD PTR $T243828[ebp], eax
	mov	cl, BYTE PTR __Cat$243835[ebp]
	mov	BYTE PTR $T243832[ebp], cl

; 1021 : 		--_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1022 : 		return (_Make_iter(_Where));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T243893 = -30						; size = 1
$T243880 = -29						; size = 1
$T243876 = -28						; size = 4
$T243869 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::vector<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T243893[ebp]
	mov	DWORD PTR $T243869[ebp], eax
	lea	ecx, DWORD PTR $T243880[ebp]
	mov	DWORD PTR $T243876[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::vector<OperationSlot,std::allocator<OperationSlot> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
PUBLIC	?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert
PUBLIC	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T244078 = -32						; size = 4
$T244068 = -28						; size = 4
$T244058 = -24						; size = 4
__Cat$244065 = -19					; size = 1
$T244062 = -18						; size = 1
$T244061 = -17						; size = 1
$T244035 = -16						; size = 4
$T244031 = -12						; size = 4
$T244030 = -8						; size = 4
$T244029 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T244035[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	edx, DWORD PTR $T244035[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244068[ebp], ecx
	mov	edx, DWORD PTR $T244068[ebp]
	mov	DWORD PTR $T244058[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T244061[ebp], al
	mov	cl, BYTE PTR __Cat$244065[ebp]
	mov	BYTE PTR $T244062[ebp], cl
	movzx	edx, BYTE PTR $T244061[ebp]
	push	edx
	movzx	eax, BYTE PTR $T244062[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T244058[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR $T244068[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244078[ebp], ecx
	mov	edx, DWORD PTR $T244078[ebp]
	mov	DWORD PTR $T244030[ebp], edx
	mov	eax, DWORD PTR $T244030[ebp]
	mov	DWORD PTR $T244029[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244029[ebp]
	push	edx
	lea	eax, DWORD PTR $T244031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T244215 = -24						; size = 4
$T244214 = -20						; size = 4
$T244196 = -16						; size = 4
$T244195 = -12						; size = 4
$T244179 = -8						; size = 4
__Cat$244202 = -2					; size = 1
$T244199 = -1						; size = 1
?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back, COMDAT
; _this$ = ecx

; 841  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 842  : 		if (!empty())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@pop_back

; 843  : 			{	// erase last element
; 844  : 			_Destroy(_Mylast - 1, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244215[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T244214[ebp], eax
	mov	ecx, DWORD PTR $T244215[ebp]
	mov	DWORD PTR $T244196[ebp], ecx
	mov	edx, DWORD PTR $T244214[ebp]
	mov	DWORD PTR $T244195[ebp], edx
	mov	al, BYTE PTR __Cat$244202[ebp]
	mov	BYTE PTR $T244199[ebp], al
	mov	ecx, DWORD PTR $T244195[ebp]
	mov	DWORD PTR $T244179[ebp], ecx
	jmp	SHORT $LN16@pop_back
$LN15@pop_back:
	mov	edx, DWORD PTR $T244179[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T244179[ebp], edx
$LN16@pop_back:
	mov	eax, DWORD PTR $T244179[ebp]
	cmp	eax, DWORD PTR $T244196[ebp]
	je	SHORT $LN8@pop_back
	jmp	SHORT $LN15@pop_back
$LN8@pop_back:

; 845  : 			--_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN2@pop_back:

; 846  : 			}
; 847  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T244320 = -56						; size = 4
$T244319 = -52						; size = 4
$T244301 = -48						; size = 4
$T244300 = -44						; size = 4
$T244284 = -40						; size = 4
__Cat$244308 = -34					; size = 1
$T244305 = -33						; size = 1
$T244258 = -32						; size = 4
$T244257 = -28						; size = 4
$T244256 = -24						; size = 4
$T244239 = -18						; size = 1
$T244238 = -17						; size = 1
$T244237 = -16						; size = 4
$T244236 = -12						; size = 4
__Cat$244247 = -4					; size = 1
$T244244 = -3						; size = 1
$T244243 = -2						; size = 1
$T244242 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244258[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244257[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T244256[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244242[ebp], cl
	mov	dl, BYTE PTR __Cat$244247[ebp]
	mov	BYTE PTR $T244243[ebp], dl
	mov	al, BYTE PTR $T244242[ebp]
	mov	BYTE PTR $T244239[ebp], al
	mov	cl, BYTE PTR $T244244[ebp]
	mov	BYTE PTR $T244238[ebp], cl
	mov	edx, DWORD PTR $T244258[ebp]
	mov	DWORD PTR $T244237[ebp], edx
	mov	eax, DWORD PTR $T244256[ebp]
	mov	DWORD PTR $T244236[ebp], eax
	jmp	SHORT $LN11@erase
$LN10@erase:
	mov	ecx, DWORD PTR $T244237[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T244237[ebp], ecx
	mov	edx, DWORD PTR $T244236[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T244236[ebp], edx
$LN11@erase:
	mov	eax, DWORD PTR $T244236[ebp]
	cmp	eax, DWORD PTR $T244257[ebp]
	je	SHORT $LN3@erase
	mov	ecx, DWORD PTR $T244236[ebp]
	mov	edx, DWORD PTR $T244237[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN10@erase
$LN3@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T244320[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T244319[ebp], edx
	mov	eax, DWORD PTR $T244320[ebp]
	mov	DWORD PTR $T244301[ebp], eax
	mov	ecx, DWORD PTR $T244319[ebp]
	mov	DWORD PTR $T244300[ebp], ecx
	mov	dl, BYTE PTR __Cat$244308[ebp]
	mov	BYTE PTR $T244305[ebp], dl
	mov	eax, DWORD PTR $T244300[ebp]
	mov	DWORD PTR $T244284[ebp], eax
	jmp	SHORT $LN22@erase
$LN21@erase:
	mov	ecx, DWORD PTR $T244284[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T244284[ebp], ecx
$LN22@erase:
	mov	edx, DWORD PTR $T244284[ebp]
	cmp	edx, DWORD PTR $T244301[ebp]
	je	SHORT $LN14@erase
	jmp	SHORT $LN21@erase
$LN14@erase:

; 1021 : 		--_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T244348 = -20						; size = 4
_pRet$244344 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::FStaticVector<CvAStarNode *,200,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 200			; 000000c8H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244348[ebp], edx
	cmp	DWORD PTR $T244348[ebp], 200		; 000000c8H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T244348[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$244344[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T244348[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$244344[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 200			; 000000c8H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$244344[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
__ehhandler$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::FStaticVector<CvAStarNode *,200,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T244379 = -24						; size = 4
$T244378 = -20						; size = 4
_i$244374 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244379[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244378[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$244374[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$244374[ebp]
	add	eax, 1
	mov	DWORD PTR _i$244374[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$244374[ebp]
	cmp	ecx, DWORD PTR $T244379[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T244378[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T244378[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
__ehhandler$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T244391 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+812], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T244391[ebp], ecx
	cmp	DWORD PTR $T244391[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR $T244391[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T244391[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T244445 = -20						; size = 4
_pRet$244441 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::FStaticVector<CvOperationSearchUnit,128,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 128			; 00000080H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244445[ebp], edx
	cmp	DWORD PTR $T244445[ebp], 128		; 00000080H
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T244445[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$244441[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T244445[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$244441[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 128			; 00000080H
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$244441[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>
__ehhandler$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::FStaticVector<CvOperationSearchUnit,128,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T244476 = -24						; size = 4
$T244475 = -20						; size = 4
_i$244470 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244476[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244475[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$244470[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$244470[ebp]
	add	eax, 1
	mov	DWORD PTR _i$244470[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$244470[ebp]
	cmp	ecx, DWORD PTR $T244476[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T244475[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T244475[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>
__ehhandler$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T244488 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1036], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T244488[ebp], ecx
	cmp	DWORD PTR $T244488[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T244488[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T244488[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::~_Vector_val<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::~_Vector_val<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$244620 = -24					; size = 4
$T244603 = -20						; size = 4
$T244584 = -16						; size = 4
$T244571 = -12						; size = 4
$T244568 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244584[ebp], eax
	mov	ecx, DWORD PTR $T244584[ebp]
	mov	DWORD PTR $T244568[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T244568[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244603[ebp], eax
	mov	ecx, DWORD PTR $T244603[ebp]
	mov	DWORD PTR $T244571[ebp], ecx
	mov	edx, DWORD PTR $T244571[ebp]
	mov	DWORD PTR __Tmp$244620[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Tmp$244620[ebp]
	mov	DWORD PTR __Tmp$244620[ebp], eax
	mov	ecx, DWORD PTR __Tmp$244620[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T244767 = -64						; size = 4
$T244749 = -60						; size = 4
$T244748 = -56						; size = 4
$T244732 = -52						; size = 4
__Cat$244751 = -46					; size = 1
$T244766 = -45						; size = 1
$T244706 = -44						; size = 4
$T244705 = -40						; size = 4
$T244704 = -36						; size = 4
$T244687 = -30						; size = 1
$T244686 = -29						; size = 1
$T244685 = -28						; size = 4
$T244684 = -24						; size = 4
__Cat$244694 = -16					; size = 1
$T244692 = -15						; size = 1
$T244691 = -14						; size = 1
$T244690 = -13						; size = 1
__Ptr$226256 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244706[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244705[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T244704[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T244690[ebp], cl
	mov	dl, BYTE PTR __Cat$244694[ebp]
	mov	BYTE PTR $T244691[ebp], dl
	mov	al, BYTE PTR $T244690[ebp]
	mov	BYTE PTR $T244687[ebp], al
	mov	cl, BYTE PTR $T244692[ebp]
	mov	BYTE PTR $T244686[ebp], cl
	mov	edx, DWORD PTR $T244706[ebp]
	mov	DWORD PTR $T244685[ebp], edx
	mov	eax, DWORD PTR $T244704[ebp]
	mov	DWORD PTR $T244684[ebp], eax
	jmp	SHORT $LN28@erase@2
$LN27@erase@2:
	mov	ecx, DWORD PTR $T244685[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T244685[ebp], ecx
	mov	edx, DWORD PTR $T244684[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T244684[ebp], edx
$LN28@erase@2:
	mov	eax, DWORD PTR $T244684[ebp]
	cmp	eax, DWORD PTR $T244705[ebp]
	je	SHORT $LN20@erase@2
	mov	ecx, DWORD PTR $T244684[ebp]
	mov	edx, DWORD PTR $T244685[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN27@erase@2
$LN20@erase@2:
	mov	edx, DWORD PTR $T244685[ebp]
	mov	DWORD PTR __Ptr$226256[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244767[ebp], ecx
	mov	edx, DWORD PTR $T244767[ebp]
	mov	DWORD PTR $T244749[ebp], edx
	mov	eax, DWORD PTR __Ptr$226256[ebp]
	mov	DWORD PTR $T244748[ebp], eax
	mov	cl, BYTE PTR __Cat$244751[ebp]
	mov	BYTE PTR $T244766[ebp], cl
	mov	edx, DWORD PTR $T244748[ebp]
	mov	DWORD PTR $T244732[ebp], edx
	jmp	SHORT $LN39@erase@2
$LN38@erase@2:
	mov	eax, DWORD PTR $T244732[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T244732[ebp], eax
$LN39@erase@2:
	mov	ecx, DWORD PTR $T244732[ebp]
	cmp	ecx, DWORD PTR $T244749[ebp]
	je	SHORT $LN31@erase@2
	jmp	SHORT $LN38@erase@2
$LN31@erase@2:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$226256[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ; std::_Allocate<OperationSlot>
PUBLIC	?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$244784 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$244784[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$244784[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$244784[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ; std::_Allocate<OperationSlot>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T244878 = -32						; size = 4
$T244877 = -28						; size = 4
$T244873 = -24						; size = 4
$T244872 = -20						; size = 4
$T244854 = -16						; size = 4
$T244853 = -12						; size = 4
$T244837 = -8						; size = 4
__Cat$244860 = -2					; size = 1
$T244857 = -1						; size = 1
?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244873[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244872[ebp], ecx
	mov	edx, DWORD PTR $T244873[ebp]
	mov	DWORD PTR $T244854[ebp], edx
	mov	eax, DWORD PTR $T244872[ebp]
	mov	DWORD PTR $T244853[ebp], eax
	mov	cl, BYTE PTR __Cat$244860[ebp]
	mov	BYTE PTR $T244857[ebp], cl
	mov	edx, DWORD PTR $T244853[ebp]
	mov	DWORD PTR $T244837[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T244837[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T244837[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T244837[ebp]
	cmp	ecx, DWORD PTR $T244854[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T244878[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244877[ebp], eax
	mov	ecx, DWORD PTR $T244877[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T244915 = -36						; size = 4
$T244914 = -32						; size = 4
_i$244910 = -28						; size = 4
$T244890 = -24						; size = 4
_pRet$244886 = -20					; size = 4
$T244881 = -16						; size = 4
_i$226322 = -12						; size = 4
_uiNewSize$226314 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$226314[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$226314[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$226314[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244890[ebp], ecx
	cmp	DWORD PTR $T244890[ebp], 200		; 000000c8H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T244890[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$244886[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T244890[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$244886[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 200			; 000000c8H
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$244886[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$226322[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$226322[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226322[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$226322[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$226322[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T244881[ebp], ecx
	cmp	DWORD PTR $T244881[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T244881[ebp]
	mov	edx, DWORD PTR _i$226322[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T244881[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244915[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T244914[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$244910[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	edx, DWORD PTR _i$244910[ebp]
	add	edx, 1
	mov	DWORD PTR _i$244910[ebp], edx
$LN26@GrowSize:
	mov	eax, DWORD PTR _i$244910[ebp]
	cmp	eax, DWORD PTR $T244915[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T244914[ebp], ecx
	je	SHORT $LN22@GrowSize
	mov	edx, DWORD PTR $T244914[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+812], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T244953 = -36						; size = 4
$T244952 = -32						; size = 4
_i$244947 = -28						; size = 4
$T244928 = -24						; size = 4
_pRet$244924 = -20					; size = 4
$T244919 = -16						; size = 4
_i$226358 = -12						; size = 4
_uiNewSize$226350 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$226350[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$226350[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$226350[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T244928[ebp], ecx
	cmp	DWORD PTR $T244928[ebp], 128		; 00000080H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T244928[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$244924[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T244928[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@2
$LN15@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$244924[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 128			; 00000080H
$LN16@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$244924[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$226358[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$226358[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226358[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$226358[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$226358[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T244919[ebp], ecx
	cmp	DWORD PTR $T244919[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$226358[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T244919[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T244919[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@2:
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244953[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244952[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@2
	xor	edx, edx
	je	SHORT $LN21@GrowSize@2
	mov	DWORD PTR _i$244947[ebp], 0
	jmp	SHORT $LN26@GrowSize@2
$LN25@GrowSize@2:
	mov	eax, DWORD PTR _i$244947[ebp]
	add	eax, 1
	mov	DWORD PTR _i$244947[ebp], eax
$LN26@GrowSize@2:
	mov	ecx, DWORD PTR _i$244947[ebp]
	cmp	ecx, DWORD PTR $T244953[ebp]
	jae	SHORT $LN21@GrowSize@2
	jmp	SHORT $LN25@GrowSize@2
$LN21@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T244952[ebp], edx
	je	SHORT $LN22@GrowSize@2
	mov	eax, DWORD PTR $T244952[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1036], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ PROC ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ ENDP ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T244968 = -20						; size = 4
_pRet$244965 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244968[ebp], edx
	cmp	DWORD PTR $T244968[ebp], 1
	jbe	SHORT $LN7@FStaticVec@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T244968[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$244965[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T244968[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@5
$LN7@FStaticVec@5:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$244965[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@FStaticVec@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$244965[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T244999 = -24						; size = 4
$T244998 = -20						; size = 4
_i$244994 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244999[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244998[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@6
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@6
	mov	DWORD PTR _i$244994[ebp], 0
	jmp	SHORT $LN10@FStaticVec@6
$LN9@FStaticVec@6:
	mov	eax, DWORD PTR _i$244994[ebp]
	add	eax, 1
	mov	DWORD PTR _i$244994[ebp], eax
$LN10@FStaticVec@6:
	mov	ecx, DWORD PTR _i$244994[ebp]
	cmp	ecx, DWORD PTR $T244999[ebp]
	jae	SHORT $LN5@FStaticVec@6
	jmp	SHORT $LN9@FStaticVec@6
$LN5@FStaticVec@6:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T244998[ebp], edx
	je	SHORT $LN1@FStaticVec@6
	mov	eax, DWORD PTR $T244998[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@6:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T245012 = -8						; size = 4
$T245011 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+20], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T245012[ebp], ecx
	cmp	DWORD PTR $T245012[ebp], 0
	je	SHORT $LN4@push_back@4
	mov	edx, DWORD PTR $T245012[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T245012[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T245012[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@4
$LN4@push_back@4:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@4:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T245011[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
PUBLIC	??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$2
__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$0
__unwindtable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
_TEXT	SEGMENT
tv84 = -440						; size = 4
tv304 = -436						; size = 4
tv290 = -432						; size = 4
tv282 = -428						; size = 4
_this$ = -424						; size = 4
$T245747 = -420						; size = 4
$T245739 = -416						; size = 4
$T245738 = -412						; size = 4
$T245715 = -406						; size = 1
$T245714 = -405						; size = 1
$T245713 = -404						; size = 4
$T245712 = -400						; size = 4
$T245700 = -393						; size = 1
$T245699 = -392						; size = 4
$T245698 = -388						; size = 4
$T245697 = -384						; size = 4
__Cat$245732 = -380					; size = 1
$T245730 = -379						; size = 1
$T245729 = -378						; size = 1
__Cat$245722 = -376					; size = 1
$T245720 = -375						; size = 1
$T245719 = -374						; size = 1
$T245718 = -373						; size = 1
$T245672 = -372						; size = 4
$T245653 = -368						; size = 4
$T245636 = -361						; size = 1
$T245635 = -360						; size = 4
$T245625 = -356						; size = 4
$T245624 = -352						; size = 4
__Cat$245670 = -346					; size = 1
$T245668 = -345						; size = 1
$T245667 = -344						; size = 1
__Cat$245661 = -343					; size = 1
$T245659 = -342						; size = 1
$T245658 = -341						; size = 1
$T245600 = -340						; size = 4
$T245592 = -336						; size = 4
$T245584 = -332						; size = 4
$T245566 = -328						; size = 4
$T245565 = -324						; size = 4
$T245549 = -320						; size = 4
__Cat$245572 = -314					; size = 1
$T245570 = -313						; size = 1
$T245523 = -312						; size = 4
$T245522 = -308						; size = 4
$T245512 = -304						; size = 4
__Cat$245519 = -299					; size = 1
$T245517 = -298						; size = 1
$T245516 = -297						; size = 1
$T245496 = -296						; size = 4
$T245477 = -292						; size = 4
$T245460 = -285						; size = 1
$T245459 = -284						; size = 4
$T245449 = -280						; size = 4
$T245448 = -276						; size = 4
__Cat$245494 = -270					; size = 1
$T245491 = -269						; size = 1
$T245490 = -268						; size = 1
__Cat$245485 = -267					; size = 1
$T245482 = -266						; size = 1
$T245481 = -265						; size = 1
$T245424 = -264						; size = 4
$T245423 = -260						; size = 4
$T245419 = -256						; size = 4
$T245418 = -252						; size = 4
$T245400 = -248						; size = 4
$T245399 = -244						; size = 4
$T245383 = -240						; size = 4
__Cat$245407 = -234					; size = 1
$T245404 = -233						; size = 1
$T245334 = -232						; size = 4
$T245333 = -228						; size = 4
$T245317 = -224						; size = 4
__Cat$245341 = -218					; size = 1
$T245338 = -217						; size = 1
$T245274 = -216						; size = 4
$T245273 = -212						; size = 4
$T245257 = -208						; size = 4
__Cat$245281 = -202					; size = 1
$T245278 = -201						; size = 1
$T245231 = -200						; size = 4
$T245219 = -196						; size = 4
$T245209 = -189						; size = 1
$T245208 = -188						; size = 4
__Cat$245226 = -183					; size = 1
$T245223 = -182						; size = 1
$T245222 = -181						; size = 1
$T245196 = -180						; size = 4
$T245184 = -176						; size = 4
$T245174 = -169						; size = 1
$T245173 = -168						; size = 4
__Cat$245191 = -163					; size = 1
$T245188 = -162						; size = 1
$T245187 = -161						; size = 1
$T245161 = -160						; size = 4
$T245151 = -156						; size = 4
__Cat$245158 = -151					; size = 1
$T245155 = -150						; size = 1
$T245154 = -149						; size = 1
__Count$245121 = -136					; size = 4
__Count$245095 = -64					; size = 4
__Tmp$226452 = -60					; size = 12
__Oldend$226453 = -48					; size = 4
__Tmp$226442 = -44					; size = 12
__Ncopied$226429 = -32					; size = 4
__Newvec$226427 = -28					; size = 4
__Whereoff$226428 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$245095[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$245095[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	eax, DWORD PTR __Count$245095[ebp]
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR tv290[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$245121[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$245121[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	edx, DWORD PTR __Count$245121[ebp]
	mov	DWORD PTR tv304[ebp], edx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv304[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ; std::_Allocate<OperationSlot>
	add	esp, 8
	mov	DWORD PTR __Newvec$226427[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$226428[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$226429[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$226428[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$226427[ebp]
	mov	DWORD PTR $T245161[ebp], edx
	mov	eax, DWORD PTR $T245161[ebp]
	mov	DWORD PTR $T245151[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245154[ebp], cl
	mov	dl, BYTE PTR __Cat$245158[ebp]
	mov	BYTE PTR $T245155[ebp], dl
	movzx	eax, BYTE PTR $T245154[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T245155[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245151[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$226429[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$226429[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245196[ebp], edx
	mov	eax, DWORD PTR __Newvec$226427[ebp]
	mov	DWORD PTR $T245184[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245187[ebp], cl
	mov	dl, BYTE PTR __Cat$245191[ebp]
	mov	BYTE PTR $T245188[ebp], dl
	mov	al, BYTE PTR $T245187[ebp]
	mov	BYTE PTR $T245174[ebp], al
	mov	ecx, DWORD PTR $T245184[ebp]
	mov	DWORD PTR $T245173[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T245173[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245196[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$226429[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$226429[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245231[ebp], edx
	mov	eax, DWORD PTR __Whereoff$226428[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$226427[ebp]
	mov	DWORD PTR $T245219[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245222[ebp], cl
	mov	dl, BYTE PTR __Cat$245226[ebp]
	mov	BYTE PTR $T245223[ebp], dl
	mov	al, BYTE PTR $T245222[ebp]
	mov	BYTE PTR $T245209[ebp], al
	mov	ecx, DWORD PTR $T245219[ebp]
	mov	DWORD PTR $T245208[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T245208[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245231[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$226429[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$226428[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$226427[ebp]
	mov	DWORD PTR $T245274[ebp], eax
	mov	ecx, DWORD PTR __Newvec$226427[ebp]
	mov	DWORD PTR $T245273[ebp], ecx
	mov	dl, BYTE PTR __Cat$245281[ebp]
	mov	BYTE PTR $T245278[ebp], dl
	mov	eax, DWORD PTR $T245273[ebp]
	mov	DWORD PTR $T245257[ebp], eax
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	ecx, DWORD PTR $T245257[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T245257[ebp], ecx
$LN91@Insert_n:
	mov	edx, DWORD PTR $T245257[ebp]
	cmp	edx, DWORD PTR $T245274[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$226429[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Whereoff$226428[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$226427[ebp]
	add	ecx, eax
	mov	DWORD PTR $T245334[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$226428[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$226427[ebp]
	mov	DWORD PTR $T245333[ebp], edx
	mov	al, BYTE PTR __Cat$245341[ebp]
	mov	BYTE PTR $T245338[ebp], al
	mov	ecx, DWORD PTR $T245333[ebp]
	mov	DWORD PTR $T245317[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T245317[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T245317[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T245317[ebp]
	cmp	eax, DWORD PTR $T245334[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$226427[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245419[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245418[ebp], eax
	mov	ecx, DWORD PTR $T245419[ebp]
	mov	DWORD PTR $T245400[ebp], ecx
	mov	edx, DWORD PTR $T245418[ebp]
	mov	DWORD PTR $T245399[ebp], edx
	mov	al, BYTE PTR __Cat$245407[ebp]
	mov	BYTE PTR $T245404[ebp], al
	mov	ecx, DWORD PTR $T245399[ebp]
	mov	DWORD PTR $T245383[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T245383[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T245383[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T245383[ebp]
	cmp	eax, DWORD PTR $T245400[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T245424[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245423[ebp], eax
	mov	ecx, DWORD PTR $T245423[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$226427[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$226427[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$226427[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$226442[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$226442[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$226442[ebp+8], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245496[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245477[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245481[ebp], al
	mov	cl, BYTE PTR __Cat$245485[ebp]
	mov	BYTE PTR $T245482[ebp], cl
	mov	dl, BYTE PTR $T245481[ebp]
	mov	BYTE PTR $T245460[ebp], dl
	mov	eax, DWORD PTR $T245477[ebp]
	mov	DWORD PTR $T245459[ebp], eax
	mov	ecx, DWORD PTR $T245459[ebp]
	mov	DWORD PTR $T245449[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245448[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245490[ebp], al
	mov	cl, BYTE PTR __Cat$245494[ebp]
	mov	BYTE PTR $T245491[ebp], cl
	movzx	edx, BYTE PTR $T245490[ebp]
	push	edx
	movzx	eax, BYTE PTR $T245491[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245449[ebp]
	push	edx
	mov	eax, DWORD PTR $T245496[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245448[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T245523[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245522[ebp], ecx
	mov	edx, DWORD PTR $T245522[ebp]
	mov	DWORD PTR $T245512[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245516[ebp], al
	mov	cl, BYTE PTR __Cat$245519[ebp]
	mov	BYTE PTR $T245517[ebp], cl
	movzx	edx, BYTE PTR $T245516[ebp]
	push	edx
	movzx	eax, BYTE PTR $T245517[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$226442[ebp]
	push	edx
	mov	eax, DWORD PTR $T245523[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245512[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245584[ebp], edx
	mov	ecx, DWORD PTR $T245584[ebp]
	mov	DWORD PTR $T245566[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245565[ebp], edx
	mov	al, BYTE PTR __Cat$245572[ebp]
	mov	BYTE PTR $T245570[ebp], al
	mov	ecx, DWORD PTR $T245565[ebp]
	mov	DWORD PTR $T245549[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T245549[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T245549[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T245549[ebp]
	cmp	eax, DWORD PTR $T245566[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T245600[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245592[ebp], ecx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	edx, DWORD PTR $T245592[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T245592[ebp], edx
$LN171@Insert_n:
	mov	eax, DWORD PTR $T245592[ebp]
	cmp	eax, DWORD PTR $T245600[ebp]
	je	SHORT $LN167@Insert_n
	mov	ecx, DWORD PTR $T245592[ebp]
	mov	edx, DWORD PTR __Tmp$226442[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$226442[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$226442[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$226452[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$226452[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$226452[ebp+8], eax

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$226453[ebp], edx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245672[ebp], ecx
	mov	edx, DWORD PTR $T245672[ebp]
	mov	DWORD PTR $T245653[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T245658[ebp], al
	mov	cl, BYTE PTR __Cat$245661[ebp]
	mov	BYTE PTR $T245659[ebp], cl
	mov	dl, BYTE PTR $T245658[ebp]
	mov	BYTE PTR $T245636[ebp], dl
	mov	eax, DWORD PTR $T245653[ebp]
	mov	DWORD PTR $T245635[ebp], eax
	mov	ecx, DWORD PTR $T245635[ebp]
	mov	DWORD PTR $T245625[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR __Oldend$226453[ebp]
	sub	eax, edx
	mov	DWORD PTR $T245624[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245667[ebp], cl
	mov	dl, BYTE PTR __Cat$245670[ebp]
	mov	BYTE PTR $T245668[ebp], dl
	movzx	eax, BYTE PTR $T245667[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T245668[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T245625[ebp]
	push	eax
	mov	ecx, DWORD PTR __Oldend$226453[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245624[ebp]
	push	edx
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$226453[ebp]
	mov	DWORD PTR $T245739[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245738[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245718[ebp], cl
	mov	dl, BYTE PTR __Cat$245722[ebp]
	mov	BYTE PTR $T245719[ebp], dl
	mov	al, BYTE PTR $T245718[ebp]
	mov	BYTE PTR $T245715[ebp], al
	mov	cl, BYTE PTR $T245720[ebp]
	mov	BYTE PTR $T245714[ebp], cl
	mov	edx, DWORD PTR $T245739[ebp]
	mov	DWORD PTR $T245713[ebp], edx
	mov	eax, DWORD PTR $T245738[ebp]
	mov	DWORD PTR $T245712[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T245729[ebp], cl
	mov	dl, BYTE PTR __Cat$245732[ebp]
	mov	BYTE PTR $T245730[ebp], dl
	mov	al, BYTE PTR $T245729[ebp]
	mov	BYTE PTR $T245700[ebp], al
	mov	ecx, DWORD PTR $T245713[ebp]
	mov	DWORD PTR $T245699[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR __Oldend$226453[ebp]
	sub	eax, edx
	mov	DWORD PTR $T245698[ebp], eax
	mov	ecx, DWORD PTR $T245712[ebp]
	mov	DWORD PTR $T245697[ebp], ecx
$LN197@Insert_n:
	mov	edx, DWORD PTR $T245697[ebp]
	cmp	edx, DWORD PTR $T245698[ebp]
	je	SHORT $LN186@Insert_n
	mov	eax, DWORD PTR $T245698[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T245698[ebp], eax
	mov	ecx, DWORD PTR $T245699[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T245699[ebp], ecx
	mov	edx, DWORD PTR $T245698[ebp]
	mov	eax, DWORD PTR $T245699[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245747[ebp], eax
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	ecx, DWORD PTR $T245747[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T245747[ebp], ecx
$LN204@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T245747[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T245747[ebp]
	mov	ecx, DWORD PTR __Tmp$226452[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$226452[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$226452[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-444]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T245769 = -80						; size = 28
$T245768 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T245769[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T245768[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T245768[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T245769[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245768[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T245768[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T245768[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T245769[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T245769[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T245768[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@26
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@26:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@27
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@27:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T245862 = -44						; size = 4
$T245861 = -40						; size = 4
_i$245854 = -36						; size = 4
$T245840 = -32						; size = 4
$T245833 = -28						; size = 4
_pRet$245830 = -24					; size = 4
$T245823 = -20						; size = 4
$T245822 = -16						; size = 4
_i$226503 = -12						; size = 4
_uiNewSize$226495 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@3

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$226495[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$226495[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@3

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@3
$LN6@GrowSize@3:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$226495[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@3
$LN7@GrowSize@3:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245833[ebp], ecx
	cmp	DWORD PTR $T245833[ebp], 1
	jbe	SHORT $LN16@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T245833[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$245830[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T245833[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$245830[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN17@GrowSize@3:
	mov	ecx, DWORD PTR _pRet$245830[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@3

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@3
$LN5@GrowSize@3:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$226503[ebp], 0
	jmp	SHORT $LN3@GrowSize@3
$LN2@GrowSize@3:
	mov	edx, DWORD PTR _i$226503[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226503[ebp], edx
$LN3@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$226503[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@3

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$226503[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T245823[ebp], ecx
	cmp	DWORD PTR $T245823[ebp], 0
	je	SHORT $LN12@GrowSize@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$226503[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T245840[ebp], edx
	mov	eax, DWORD PTR $T245823[ebp]
	mov	ecx, DWORD PTR $T245840[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T245823[ebp]
	mov	ecx, DWORD PTR $T245840[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T245823[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@3
$LN12@GrowSize@3:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@3:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T245822[ebp], ecx
	jmp	SHORT $LN2@GrowSize@3
$LN4@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245862[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T245861[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@3
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@3
	mov	DWORD PTR _i$245854[ebp], 0
	jmp	SHORT $LN29@GrowSize@3
$LN28@GrowSize@3:
	mov	edx, DWORD PTR _i$245854[ebp]
	add	edx, 1
	mov	DWORD PTR _i$245854[ebp], edx
$LN29@GrowSize@3:
	mov	eax, DWORD PTR _i$245854[ebp]
	cmp	eax, DWORD PTR $T245862[ebp]
	jae	SHORT $LN24@GrowSize@3
	jmp	SHORT $LN28@GrowSize@3
$LN24@GrowSize@3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T245861[ebp], ecx
	je	SHORT $LN25@GrowSize@3
	mov	edx, DWORD PTR $T245861[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+20], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv158 = -48						; size = 4
_this$ = -44						; size = 4
$T245905 = -40						; size = 4
$T245904 = -36						; size = 4
_i$245897 = -32						; size = 4
$T245883 = -28						; size = 4
$T245876 = -24						; size = 4
_pRet$245873 = -20					; size = 4
$T245866 = -16						; size = 4
$T245865 = -12						; size = 4
_i$226522 = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiFit$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN6@GrowSizeTo

; 778  : 			return;

	jmp	$LN7@GrowSizeTo
$LN6@GrowSizeTo:

; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245876[ebp], edx
	cmp	DWORD PTR $T245876[ebp], 1
	jbe	SHORT $LN13@GrowSizeTo
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T245876[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$245873[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T245876[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN14@GrowSizeTo
$LN13@GrowSizeTo:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$245873[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN14@GrowSizeTo:
	mov	edx, DWORD PTR _pRet$245873[ebp]
	mov	DWORD PTR _pTemp$[ebp], edx

; 782  : 		if( bPODType ){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@GrowSizeTo

; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pTemp$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 784  : 		}else{

	jmp	SHORT $LN4@GrowSizeTo
$LN5@GrowSizeTo:

; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$226522[ebp], 0
	jmp	SHORT $LN3@GrowSizeTo
$LN2@GrowSizeTo:
	mov	eax, DWORD PTR _i$226522[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226522[ebp], eax
$LN3@GrowSizeTo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$226522[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN4@GrowSizeTo

; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, DWORD PTR _i$226522[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T245866[ebp], edx
	cmp	DWORD PTR $T245866[ebp], 0
	je	SHORT $LN9@GrowSizeTo
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$226522[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T245883[ebp], eax
	mov	ecx, DWORD PTR $T245866[ebp]
	mov	edx, DWORD PTR $T245883[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T245866[ebp]
	mov	edx, DWORD PTR $T245883[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR $T245866[ebp]
	mov	DWORD PTR tv158[ebp], ecx
	jmp	SHORT $LN10@GrowSizeTo
$LN9@GrowSizeTo:
	mov	DWORD PTR tv158[ebp], 0
$LN10@GrowSizeTo:
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR $T245865[ebp], edx
	jmp	SHORT $LN2@GrowSizeTo
$LN4@GrowSizeTo:

; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245905[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245904[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSizeTo
	xor	edx, edx
	je	SHORT $LN21@GrowSizeTo
	mov	DWORD PTR _i$245897[ebp], 0
	jmp	SHORT $LN26@GrowSizeTo
$LN25@GrowSizeTo:
	mov	eax, DWORD PTR _i$245897[ebp]
	add	eax, 1
	mov	DWORD PTR _i$245897[ebp], eax
$LN26@GrowSizeTo:
	mov	ecx, DWORD PTR _i$245897[ebp]
	cmp	ecx, DWORD PTR $T245905[ebp]
	jae	SHORT $LN21@GrowSizeTo
	jmp	SHORT $LN25@GrowSizeTo
$LN21@GrowSizeTo:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T245904[ebp], edx
	je	SHORT $LN22@GrowSizeTo
	mov	eax, DWORD PTR $T245904[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+20], 1
$LN7@GrowSizeTo:

; 792  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z PROC ; operator>><OperationSlot>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ENDP ; operator>><OperationSlot>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z
_TEXT	SEGMENT
$T245988 = -68						; size = 8
$T245987 = -60						; size = 4
$T245986 = -56						; size = 4
$T245968 = -52						; size = 4
__ChkFirst$245981 = -48					; size = 4
__ChkLast$245982 = -44					; size = 4
$T245945 = -40						; size = 4
$T245936 = -36						; size = 4
$T245924 = -32						; size = 4
$T245926 = -28						; size = 4
$T245915 = -24						; size = 8
$T245914 = -16						; size = 4
$T245913 = -12						; size = 4
$T245912 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z PROC ; operator<<<OperationSlot>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T245912[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T245912[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T245926[ebp], eax
	mov	edx, DWORD PTR $T245912[ebp]
	mov	DWORD PTR $T245924[ebp], edx
	lea	eax, DWORD PTR $T245926[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245924[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245936[ebp], edx
	mov	eax, DWORD PTR $T245936[ebp]
	mov	DWORD PTR $T245913[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245945[ebp], edx
	mov	eax, DWORD PTR $T245945[ebp]
	mov	DWORD PTR $T245914[ebp], eax
	mov	ecx, DWORD PTR $T245912[ebp]
	mov	DWORD PTR $T245988[ebp], ecx
	mov	edx, DWORD PTR $T245912[ebp+4]
	mov	DWORD PTR $T245988[ebp+4], edx
	mov	eax, DWORD PTR $T245913[ebp]
	mov	DWORD PTR $T245987[ebp], eax
	mov	ecx, DWORD PTR $T245914[ebp]
	mov	DWORD PTR $T245986[ebp], ecx
	mov	edx, DWORD PTR $T245986[ebp]
	mov	DWORD PTR __ChkFirst$245981[ebp], edx
	mov	eax, DWORD PTR $T245987[ebp]
	mov	DWORD PTR __ChkLast$245982[ebp], eax
	jmp	SHORT $LN24@operator
$LN18@operator:
	mov	ecx, DWORD PTR __ChkFirst$245981[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __ChkFirst$245981[ebp], ecx
$LN24@operator:
	mov	edx, DWORD PTR __ChkFirst$245981[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$245982[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator
	mov	eax, DWORD PTR __ChkFirst$245981[ebp]
	mov	DWORD PTR $T245968[ebp], eax
	mov	ecx, DWORD PTR $T245968[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245988[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator
$LN17@operator:
	mov	eax, DWORD PTR $T245988[ebp]
	mov	DWORD PTR $T245915[ebp], eax
	mov	ecx, DWORD PTR $T245988[ebp+4]
	mov	DWORD PTR $T245915[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ENDP ; operator<<<OperationSlot>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z
_TEXT	SEGMENT
$T245995 = -16						; size = 4
$T245991 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z PROC ; std::_Allocate<OperationSlot>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T245995[ebp], 0
	lea	eax, DWORD PTR $T245995[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245991[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T245991[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T245991[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ENDP ; std::_Allocate<OperationSlot>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@28
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@28:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
_TEXT	ENDS
;	COMDAT ??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z
_TEXT	SEGMENT
$T246036 = -48						; size = 4
$T246020 = -44						; size = 4
$T246174 = -40						; size = 4
$T246173 = -36						; size = 4
$T246172 = -32						; size = 4
$T246171 = -28						; size = 4
$T246170 = -24						; size = 4
_v$226916 = -20						; size = 12
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246020[ebp], ecx
	mov	edx, DWORD PTR $T246020[ebp]
	mov	DWORD PTR $T246171[ebp], edx
	mov	eax, DWORD PTR $T246171[ebp]
	mov	DWORD PTR $T246170[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246036[ebp], edx
	mov	eax, DWORD PTR $T246036[ebp]
	mov	DWORD PTR $T246173[ebp], eax
	mov	ecx, DWORD PTR $T246173[ebp]
	mov	DWORD PTR $T246172[ebp], ecx
	mov	edx, DWORD PTR $T246170[ebp]
	push	edx
	mov	eax, DWORD PTR $T246172[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246174[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT

; 89   : 	{
; 90   : 		ElementType v;

	mov	DWORD PTR _v$226916[ebp], -1
	mov	DWORD PTR _v$226916[ebp+4], -1
	mov	DWORD PTR _v$226916[ebp+8], -1

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$226916[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$226916[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT
$LN4@SerializeT:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
PUBLIC	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
_TEXT	SEGMENT
$T246417 = -112						; size = 4
__Next$246425 = -108					; size = 4
$T246334 = -48						; size = 4
$T246330 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z PROC ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3411 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3412 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T246330[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T246330[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T246334[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T246334[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H

; 3415 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$246425[ebp], edx
	jmp	SHORT $LN62@Stable_sor
$LN61@Stable_sor:
	mov	eax, DWORD PTR __Next$246425[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$246425[ebp], eax
$LN62@Stable_sor:
	mov	ecx, DWORD PTR __Next$246425[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor
	jmp	SHORT $LN61@Stable_sor
$LN60@Stable_sor:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T246417[ebp], edx
	mov	eax, DWORD PTR $T246417[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z ENDP ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z
_TEXT	SEGMENT
$T246561 = -128						; size = 4
__Mid$227047 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$227047[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$227047[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$227047[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$227047[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$227047[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$227047[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$227047[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T246561[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T246561[ebp]
	sub	eax, 8
	mov	DWORD PTR $T246561[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T246561[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T246561[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T246561[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T246658 = -28						; size = 4
__Vptr$246656 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$246656[ebp], eax
	mov	ecx, DWORD PTR __Vptr$246656[ebp]
	mov	DWORD PTR $T246658[ebp], ecx
	cmp	DWORD PTR $T246658[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T246658[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T246658[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T246691 = -8						; size = 4
__Next$227185 = -4					; size = 4
??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$227185[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$227185[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$227185[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$227185[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246691[ebp], ecx
	mov	edx, DWORD PTR $T246691[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
PUBLIC	??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
PUBLIC	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
__Count2$227244 = -8					; size = 4
__Mid$227245 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H

; 3382 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
	add	esp, 12					; 0000000cH

; 3384 : 	else

	jmp	$LN5@Stable_sor@2
$LN4@Stable_sor@2:

; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$227244[ebp], eax

; 3387 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$227245[ebp], edx

; 3388 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$227244[ebp]
	mov	ecx, DWORD PTR __Mid$227245[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$227245[ebp], edx

; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	DWORD PTR __Count2$227244[ebp], eax
	jg	SHORT $LN2@Stable_sor@2

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$227244[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$227245[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$227244[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$227245[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN1@Stable_sor@2
$LN2@Stable_sor@2:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$227244[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$227245[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Count2$227244[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$227245[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H
$LN1@Stable_sor@2:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$227244[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$227244[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$227245[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 24					; 00000018H
$LN5@Stable_sor@2:

; 3403 : 		}
; 3404 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
$T247216 = -124						; size = 4
__Tmp$247215 = -120					; size = 8
$T247196 = -112						; size = 4
$T247195 = -108						; size = 4
__Tmp$247194 = -104					; size = 8
$T247175 = -96						; size = 4
__Tmp$247174 = -92					; size = 8
$T247155 = -84						; size = 4
$T247154 = -80						; size = 4
__Tmp$247153 = -76					; size = 8
$T247134 = -68						; size = 4
$T247133 = -64						; size = 4
__Tmp$247132 = -60					; size = 8
$T247110 = -52						; size = 4
$T247109 = -48						; size = 4
__Tmp$247108 = -44					; size = 8
$T247083 = -36						; size = 4
__Tmp$247082 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T247083[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T247083[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T247083[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$247082[ebp], edx
	mov	eax, DWORD PTR $T247083[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$247082[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T247083[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$247082[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$247082[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T247110[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T247109[ebp], edx
	mov	eax, DWORD PTR $T247109[ebp]
	cmp	eax, DWORD PTR $T247110[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T247109[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$247108[ebp], edx
	mov	eax, DWORD PTR $T247109[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$247108[ebp+4], ecx
	mov	edx, DWORD PTR $T247110[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T247109[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T247110[ebp]
	mov	ecx, DWORD PTR __Tmp$247108[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$247108[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T247134[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T247133[ebp], eax
	mov	ecx, DWORD PTR $T247133[ebp]
	cmp	ecx, DWORD PTR $T247134[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T247133[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$247132[ebp], eax
	mov	ecx, DWORD PTR $T247133[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$247132[ebp+4], edx
	mov	eax, DWORD PTR $T247134[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T247133[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T247134[ebp]
	mov	edx, DWORD PTR __Tmp$247132[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$247132[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T247155[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T247154[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T247154[ebp]
	cmp	eax, DWORD PTR $T247155[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T247154[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$247153[ebp], edx
	mov	eax, DWORD PTR $T247154[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$247153[ebp+4], ecx
	mov	edx, DWORD PTR $T247155[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T247154[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T247155[ebp]
	mov	ecx, DWORD PTR __Tmp$247153[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$247153[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T247175[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T247175[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$247174[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$247174[ebp+4], eax
	mov	ecx, DWORD PTR $T247175[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T247175[ebp]
	mov	eax, DWORD PTR __Tmp$247174[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$247174[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T247196[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T247195[ebp], ecx
	mov	edx, DWORD PTR $T247195[ebp]
	cmp	edx, DWORD PTR $T247196[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T247195[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$247194[ebp], ecx
	mov	edx, DWORD PTR $T247195[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$247194[ebp+4], eax
	mov	ecx, DWORD PTR $T247196[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T247195[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T247196[ebp]
	mov	eax, DWORD PTR __Tmp$247194[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$247194[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T247216[ebp], eax
	mov	ecx, DWORD PTR $T247216[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T247216[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$247215[ebp], eax
	mov	ecx, DWORD PTR $T247216[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$247215[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T247216[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$247215[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$247215[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z ; std::get_temporary_buffer<CvOperationSearchUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$227432 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$227432[ebp]
	push	ecx
	call	??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z ; std::get_temporary_buffer<CvOperationSearchUnit>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227432[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227432[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227432[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$227432[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T247255 = -2092					; size = 4
$T247254 = -2088					; size = 4
$T247253 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T247253[ebp], eax
	mov	ecx, DWORD PTR $T247253[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T247254[ebp], eax
	mov	eax, DWORD PTR $T247254[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T247255[ebp], eax
	mov	ecx, DWORD PTR $T247255[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
tv139 = -260						; size = 4
$T247583 = -133						; size = 1
$T247408 = -132						; size = 4
$T247404 = -128						; size = 4
$T247367 = -104						; size = 4
$T247316 = -64						; size = 4
$T247258 = -20						; size = 4
__Chunk$227502 = -16					; size = 4
__Midend$227500 = -12					; size = 4
__Nleft$227496 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 3355 : 	{	// sort using temp buffer for merges, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$227496[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$227496[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$227496[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$227496[ebp], 32	; 00000020H
	jl	SHORT $LN44@Buffered_m

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midend$227500[ebp], eax

; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	shl	ecx, 3
	add	ecx, DWORD PTR __Midend$227500[ebp]
	mov	DWORD PTR __Midend$227500[ebp], ecx

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	mov	edx, DWORD PTR __Midend$227500[ebp]
	mov	DWORD PTR $T247316[ebp], edx
	push	0
	mov	eax, DWORD PTR $T247316[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
	add	esp, 12					; 0000000cH

; 3363 : 		_Mid = _Midend;

	mov	edx, DWORD PTR __Midend$227500[ebp]
	mov	DWORD PTR __Mid$[ebp], edx

; 3364 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

$LN44@Buffered_m:
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
	add	esp, 12					; 0000000cH

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$227502[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	edx, DWORD PTR __Chunk$227502[ebp]
	shl	edx, 1
	mov	DWORD PTR __Chunk$227502[ebp], edx
$LN3@Buffered_m:
	mov	eax, DWORD PTR __Chunk$227502[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$227502[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T247258[ebp], esp
	mov	DWORD PTR $T247367[ebp], edx
	mov	eax, DWORD PTR $T247367[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T247367[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T247367[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T247367[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T247367[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T247367[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
	add	esp, 36					; 00000024H

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	ecx, DWORD PTR __Chunk$227502[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$227502[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T247404[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T247408[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T247583[ebp], dl
	movzx	eax, BYTE PTR $T247583[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$227502[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247404[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247408[ebp]
	push	edx
	call	??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
	add	esp, 24					; 00000018H

; 3373 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3374 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
PUBLIC	??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
PUBLIC	??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
PUBLIC	??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
PUBLIC	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
tv221 = -312						; size = 4
tv220 = -308						; size = 4
tv217 = -304						; size = 4
tv216 = -300						; size = 4
$T247863 = -228						; size = 4
$T247845 = -220						; size = 4
$T247844 = -216						; size = 4
$T247767 = -176						; size = 4
$T247749 = -168						; size = 4
$T247748 = -164						; size = 4
$T247722 = -157						; size = 1
$T247717 = -156						; size = 4
$T247713 = -152						; size = 4
$T247698 = -148						; size = 4
__Next$247701 = -144					; size = 4
$T247690 = -140						; size = 4
$T247677 = -128						; size = 4
$T247676 = -124						; size = 4
$T247675 = -120						; size = 4
$T247671 = -114						; size = 1
$T247670 = -113						; size = 1
$T247660 = -112						; size = 4
$T247656 = -108						; size = 4
$T247641 = -104						; size = 4
__Next$247649 = -100					; size = 4
$T247633 = -96						; size = 4
__Tmp$247620 = -84					; size = 8
$T247602 = -76						; size = 4
$T247598 = -72						; size = 4
$T247589 = -68						; size = 20
$T247588 = -48						; size = 4
$T247587 = -44						; size = 20
$T247586 = -24						; size = 4
__Firstn$227572 = -20					; size = 4
__Count2n$227575 = -16					; size = 4
__Midn$227592 = -12					; size = 4
__Lastn$227573 = -8					; size = 4
__Count1n$227574 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T247598[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T247602[ebp], ecx
	mov	edx, DWORD PTR $T247598[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T247602[ebp]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Buffered_m@2

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$247620[ebp], ecx
	mov	DWORD PTR __Tmp$247620[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$247620[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$247620[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN8@Buffered_m@2:

; 2764 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Count1$[ebp]
	cmp	ecx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T247586[ebp], esp
	mov	DWORD PTR $T247633[ebp], ecx
	mov	edx, DWORD PTR $T247633[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T247633[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T247633[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T247633[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T247633[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T247633[ebp]
	mov	DWORD PTR tv216[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T247587[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv217[ebp], eax
	cmp	DWORD PTR $T247587[ebp], 0
	je	SHORT $LN40@Buffered_m@2
	mov	ecx, DWORD PTR $T247587[ebp]
	mov	DWORD PTR __Next$247649[ebp], ecx
	jmp	SHORT $LN38@Buffered_m@2
$LN37@Buffered_m@2:
	mov	edx, DWORD PTR __Next$247649[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$247649[ebp], edx
$LN38@Buffered_m@2:
	mov	eax, DWORD PTR __Next$247649[ebp]
	cmp	eax, DWORD PTR $T247587[ebp+8]
	je	SHORT $LN36@Buffered_m@2
	jmp	SHORT $LN37@Buffered_m@2
$LN36@Buffered_m@2:
	mov	ecx, DWORD PTR $T247587[ebp]
	mov	DWORD PTR $T247641[ebp], ecx
	mov	edx, DWORD PTR $T247641[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN40@Buffered_m@2:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247656[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T247660[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247677[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T247676[ebp], ecx
	mov	edx, DWORD PTR $T247660[ebp]
	mov	DWORD PTR $T247675[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247670[ebp], al
	movzx	ecx, BYTE PTR $T247670[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T247671[ebp]
	push	edx
	mov	eax, DWORD PTR $T247677[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247676[ebp]
	push	edx
	mov	eax, DWORD PTR $T247656[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247675[ebp]
	push	ecx
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T247588[ebp], esp
	mov	DWORD PTR $T247690[ebp], ecx
	mov	edx, DWORD PTR $T247690[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T247690[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T247690[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T247690[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T247690[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T247690[ebp]
	mov	DWORD PTR tv220[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	lea	eax, DWORD PTR $T247589[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR $T247589[ebp], 0
	je	SHORT $LN67@Buffered_m@2
	mov	ecx, DWORD PTR $T247589[ebp]
	mov	DWORD PTR __Next$247701[ebp], ecx
	jmp	SHORT $LN65@Buffered_m@2
$LN64@Buffered_m@2:
	mov	edx, DWORD PTR __Next$247701[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$247701[ebp], edx
$LN65@Buffered_m@2:
	mov	eax, DWORD PTR __Next$247701[ebp]
	cmp	eax, DWORD PTR $T247589[ebp+8]
	je	SHORT $LN63@Buffered_m@2
	jmp	SHORT $LN64@Buffered_m@2
$LN63@Buffered_m@2:
	mov	ecx, DWORD PTR $T247589[ebp]
	mov	DWORD PTR $T247698[ebp], ecx
	mov	edx, DWORD PTR $T247698[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN67@Buffered_m@2:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247713[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T247717[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247722[ebp], al
	movzx	ecx, BYTE PTR $T247722[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T247713[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247717[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
	add	esp, 24					; 00000018H

; 2775 : 		}
; 2776 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	ecx, DWORD PTR __Count2$[ebp]
	cmp	ecx, DWORD PTR __Count1$[ebp]
	jge	SHORT $LN2@Buffered_m@2

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$227574[ebp], eax
	mov	DWORD PTR __Count2n$227575[ebp], 0

; 2784 : 			_Firstn = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$227572[ebp], edx

; 2785 : 			std::advance(_Firstn, _Count1n);

	mov	eax, DWORD PTR __Count1n$227574[ebp]
	mov	ecx, DWORD PTR __Firstn$227572[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Firstn$227572[ebp], edx

; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	mov	eax, DWORD PTR __Firstn$227572[ebp]
	mov	DWORD PTR $T247749[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T247748[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T247749[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247748[ebp]
	push	ecx
	call	??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T247748[ebp], eax
	mov	edx, DWORD PTR $T247748[ebp]
	mov	DWORD PTR __Lastn$227573[ebp], edx

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T247767[ebp], eax
	mov	ecx, DWORD PTR __Lastn$227573[ebp]
	sub	ecx, DWORD PTR $T247767[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count2n$227575[ebp]
	mov	DWORD PTR __Count2n$227575[ebp], ecx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$227574[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$227575[ebp], eax

; 2792 : 			_Lastn = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$227573[ebp], edx

; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Count2n$227575[ebp]
	mov	ecx, DWORD PTR __Lastn$227573[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Lastn$227573[ebp], edx

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	eax, DWORD PTR __Lastn$227573[ebp]
	mov	DWORD PTR $T247845[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247844[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T247845[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247844[ebp]
	push	ecx
	call	??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T247844[ebp], eax
	mov	edx, DWORD PTR $T247844[ebp]
	mov	DWORD PTR __Firstn$227572[ebp], edx

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247863[ebp], eax
	mov	ecx, DWORD PTR __Firstn$227572[ebp]
	sub	ecx, DWORD PTR $T247863[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count1n$227574[ebp]
	mov	DWORD PTR __Count1n$227574[ebp], ecx
$LN1@Buffered_m@2:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$227575[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$227574[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$227573[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$227572[ebp]
	push	ecx
	call	??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$227592[ebp], eax

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$227575[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1n$227574[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$227592[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$227572[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 24					; 00000018H

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$[ebp]
	sub	eax, DWORD PTR __Count2n$227575[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$227574[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$227573[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$227592[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 24					; 00000018H
$LN10@Buffered_m@2:

; 2804 : 		}
; 2805 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__Step$227607 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$227607[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$227607[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$227607[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$227607[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$227607[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$227607[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$227607[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$227607[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$227607[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z
_TEXT	SEGMENT
$T248224 = -20						; size = 4
$T248223 = -16						; size = 4
__Hole$227625 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$227625[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$227625[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$227625[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$227625[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$227625[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T248224[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T248223[ebp], esp
	mov	edx, DWORD PTR $T248223[ebp]
	mov	eax, DWORD PTR $T248224[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T248223[ebp]
	mov	eax, DWORD PTR $T248224[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$227625[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
$T248294 = -52						; size = 4
$T248293 = -48						; size = 4
$T248277 = -42						; size = 1
$T248276 = -41						; size = 1
$T248275 = -40						; size = 4
$T248274 = -36						; size = 4
$T248273 = -32						; size = 4
__Cat$248283 = -24					; size = 1
$T248281 = -23						; size = 1
$T248280 = -22						; size = 1
$T248279 = -21						; size = 1
__First1$227666 = -20					; size = 4
__Val$227656 = -16					; size = 8
__Next1$227655 = -8					; size = 4
__Next$227651 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$227651[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$227651[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$227651[ebp], edx
	mov	eax, DWORD PTR __Next$227651[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$227651[ebp]
	mov	DWORD PTR __Next1$227655[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$227651[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$227656[ebp], eax
	mov	ecx, DWORD PTR __Next$227651[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$227656[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$227656[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$227655[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$227655[ebp], ecx
	mov	edx, DWORD PTR __Next1$227655[ebp]
	mov	DWORD PTR $T248294[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248293[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248279[ebp], cl
	mov	dl, BYTE PTR __Cat$248283[ebp]
	mov	BYTE PTR $T248280[ebp], dl
	mov	al, BYTE PTR $T248279[ebp]
	mov	BYTE PTR $T248277[ebp], al
	mov	cl, BYTE PTR $T248281[ebp]
	mov	BYTE PTR $T248276[ebp], cl
	mov	edx, DWORD PTR $T248294[ebp]
	mov	DWORD PTR $T248275[ebp], edx
	mov	eax, DWORD PTR __Next$227651[ebp]
	mov	DWORD PTR $T248274[ebp], eax
	mov	ecx, DWORD PTR $T248293[ebp]
	mov	DWORD PTR $T248273[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T248273[ebp]
	cmp	edx, DWORD PTR $T248274[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T248274[ebp]
	sub	eax, 8
	mov	DWORD PTR $T248274[ebp], eax
	mov	ecx, DWORD PTR $T248275[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T248275[ebp], ecx
	mov	edx, DWORD PTR $T248274[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T248275[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$227656[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$227656[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$227655[ebp]
	mov	DWORD PTR __First1$227666[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$227666[ebp]
	mov	DWORD PTR __Next1$227655[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$227666[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$227666[ebp], edx
	mov	eax, DWORD PTR __First1$227666[ebp]
	mov	ecx, DWORD PTR __Val$227656[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$227666[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$227655[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$227655[ebp]
	mov	eax, DWORD PTR __Val$227656[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$227656[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z
_TEXT	SEGMENT
__Cat$248305 = -3					; size = 1
$T248301 = -2						; size = 1
$T248300 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T248300[ebp], al
	mov	cl, BYTE PTR __Cat$248305[ebp]
	mov	BYTE PTR $T248301[ebp], cl
	movzx	edx, BYTE PTR $T248300[ebp]
	push	edx
	movzx	eax, BYTE PTR $T248301[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
_TEXT	ENDS
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Odtp
;	COMDAT ??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z
_TEXT	SEGMENT
$T248312 = -20						; size = 4
$T248308 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z PROC ; std::get_temporary_buffer<CvOperationSearchUnit>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T248312[ebp], 0
	lea	eax, DWORD PTR $T248312[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248308[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T248308[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T248308[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvOperationSearchUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z
_TEXT	SEGMENT
$T248380 = -68						; size = 4
$T248376 = -64						; size = 4
$T248371 = -60						; size = 4
$T248370 = -56						; size = 4
$T248354 = -50						; size = 1
$T248353 = -49						; size = 1
$T248352 = -48						; size = 4
$T248351 = -44						; size = 4
$T248350 = -40						; size = 4
__Cat$248360 = -32					; size = 1
$T248358 = -31						; size = 1
$T248357 = -30						; size = 1
$T248356 = -29						; size = 1
$T248326 = -28						; size = 4
$T248322 = -24						; size = 4
__First1$227744 = -20					; size = 4
__Val$227734 = -16					; size = 8
__Next1$227733 = -8					; size = 4
__Next$227729 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z PROC ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$227729[ebp], ecx
$LN7@Insertion_@2:
	mov	edx, DWORD PTR __Next$227729[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$227729[ebp], edx
	mov	eax, DWORD PTR __Next$227729[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$227729[ebp]
	mov	DWORD PTR __Next1$227733[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$227729[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$227734[ebp], eax
	mov	DWORD PTR __Val$227734[ebp+4], ecx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	edx, DWORD PTR __Val$227734[ebp]
	mov	DWORD PTR $T248322[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T248326[ebp], ecx
	mov	edx, DWORD PTR $T248322[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T248326[ebp]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __Next1$227733[ebp]
	add	edx, 8
	mov	DWORD PTR __Next1$227733[ebp], edx
	mov	eax, DWORD PTR __Next1$227733[ebp]
	mov	DWORD PTR $T248371[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248370[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T248356[ebp], dl
	mov	al, BYTE PTR __Cat$248360[ebp]
	mov	BYTE PTR $T248357[ebp], al
	mov	cl, BYTE PTR $T248356[ebp]
	mov	BYTE PTR $T248354[ebp], cl
	mov	dl, BYTE PTR $T248358[ebp]
	mov	BYTE PTR $T248353[ebp], dl
	mov	eax, DWORD PTR $T248371[ebp]
	mov	DWORD PTR $T248352[ebp], eax
	mov	ecx, DWORD PTR __Next$227729[ebp]
	mov	DWORD PTR $T248351[ebp], ecx
	mov	edx, DWORD PTR $T248370[ebp]
	mov	DWORD PTR $T248350[ebp], edx
$LN24@Insertion_@2:
	mov	eax, DWORD PTR $T248350[ebp]
	cmp	eax, DWORD PTR $T248351[ebp]
	je	SHORT $LN17@Insertion_@2
	mov	ecx, DWORD PTR $T248351[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T248351[ebp], ecx
	mov	edx, DWORD PTR $T248352[ebp]
	sub	edx, 8
	mov	DWORD PTR $T248352[ebp], edx
	mov	eax, DWORD PTR $T248351[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T248352[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN24@Insertion_@2
$LN17@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Val$227734[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$227734[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	ecx, DWORD PTR __Next1$227733[ebp]
	mov	DWORD PTR __First1$227744[ebp], ecx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@2
$LN2@Insertion_@2:
	mov	edx, DWORD PTR __First1$227744[ebp]
	mov	DWORD PTR __Next1$227733[ebp], edx
$LN3@Insertion_@2:
	mov	eax, DWORD PTR __First1$227744[ebp]
	sub	eax, 8
	mov	DWORD PTR __First1$227744[ebp], eax
	mov	ecx, DWORD PTR __Val$227734[ebp]
	mov	DWORD PTR $T248376[ebp], ecx
	mov	edx, DWORD PTR __First1$227744[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T248380[ebp], eax
	mov	ecx, DWORD PTR $T248376[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T248380[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_@2

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$227744[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$227733[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_@2
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$227733[ebp]
	mov	eax, DWORD PTR __Val$227734[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$227734[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_@2:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@2
$LN9@Insertion_@2:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ENDP ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z
_TEXT	SEGMENT
tv92 = -164						; size = 4
$T248543 = -160						; size = 4
__Next$248551 = -156					; size = 4
$T248401 = -24						; size = 4
$T248390 = -20						; size = 4
$T248389 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>, COMDAT

; 5252 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T248389[ebp], al
	movzx	ecx, BYTE PTR $T248389[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T248390[ebp], esp
	mov	DWORD PTR $T248401[ebp], ecx
	mov	edx, DWORD PTR $T248401[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T248401[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T248401[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T248401[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T248401[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T248401[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
	add	esp, 40					; 00000028H

; 5254 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$248551[ebp], edx
	jmp	SHORT $LN77@Unchecked_
$LN76@Unchecked_:
	mov	eax, DWORD PTR __Next$248551[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$248551[ebp], eax
$LN77@Unchecked_:
	mov	ecx, DWORD PTR __Next$248551[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN75@Unchecked_
	jmp	SHORT $LN76@Unchecked_
$LN75@Unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T248543[ebp], edx
	mov	eax, DWORD PTR $T248543[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
PUBLIC	??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T248596 = -40						; size = 4
__Next$248604 = -36					; size = 4
$T248588 = -32						; size = 4
__Cat$248575 = -25					; size = 1
$T248570 = -24						; size = 4
$T248566 = -20						; size = 4
$T248565 = -15						; size = 1
$T248564 = -14						; size = 1
$T248563 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z PROC ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T248570[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T248563[ebp], al
	mov	cl, BYTE PTR __Cat$248575[ebp]
	mov	BYTE PTR $T248564[ebp], cl
	movzx	edx, BYTE PTR $T248563[ebp]
	push	edx
	movzx	eax, BYTE PTR $T248564[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T248565[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T248566[ebp], esp
	mov	DWORD PTR $T248588[ebp], edx
	mov	eax, DWORD PTR $T248588[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T248588[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T248588[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T248588[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T248588[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T248588[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T248570[ebp]
	or	ecx, 1
	mov	DWORD PTR $T248570[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$248604[ebp], edx
	jmp	SHORT $LN17@unchecked_
$LN16@unchecked_:
	mov	eax, DWORD PTR __Next$248604[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$248604[ebp], eax
$LN17@unchecked_:
	mov	ecx, DWORD PTR __Next$248604[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_
	jmp	SHORT $LN16@unchecked_
$LN15@unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T248596[ebp], edx
	mov	eax, DWORD PTR $T248596[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ENDP ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
PUBLIC	??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
tv178 = -260						; size = 4
tv177 = -256						; size = 4
tv174 = -252						; size = 4
tv173 = -248						; size = 4
$T248896 = -240						; size = 4
$T248882 = -233						; size = 1
$T248881 = -232						; size = 4
$T248886 = -225						; size = 1
$T248861 = -224						; size = 4
$T248860 = -220						; size = 4
$T248843 = -214						; size = 1
$T248842 = -213						; size = 1
$T248841 = -212						; size = 4
$T248840 = -208						; size = 4
__Cat$248857 = -200					; size = 1
$T248854 = -199						; size = 1
$T248853 = -198						; size = 1
$T248852 = -197						; size = 1
$T248821 = -196						; size = 4
$T248817 = -192						; size = 4
$T248813 = -188						; size = 4
$T248812 = -184						; size = 4
$T248796 = -178						; size = 1
$T248795 = -177						; size = 1
$T248794 = -176						; size = 4
$T248793 = -172						; size = 4
$T248792 = -168						; size = 4
__Cat$248803 = -160					; size = 1
$T248801 = -159						; size = 1
$T248800 = -158						; size = 1
$T248799 = -157						; size = 1
$T248763 = -156						; size = 4
__Next$248766 = -152					; size = 4
$T248755 = -148						; size = 4
$T248742 = -136						; size = 4
$T248741 = -132						; size = 4
$T248725 = -126						; size = 1
$T248724 = -125						; size = 1
$T248723 = -124						; size = 4
$T248722 = -120						; size = 4
$T248721 = -116						; size = 4
__Cat$248732 = -108					; size = 1
$T248730 = -107						; size = 1
$T248729 = -106						; size = 1
$T248728 = -105						; size = 1
$T248703 = -104						; size = 4
$T248699 = -100						; size = 4
$T248695 = -96						; size = 4
$T248694 = -92						; size = 4
$T248677 = -86						; size = 1
$T248676 = -85						; size = 1
$T248675 = -84						; size = 4
$T248674 = -80						; size = 4
__Cat$248683 = -72					; size = 1
$T248681 = -71						; size = 1
$T248680 = -70						; size = 1
$T248679 = -69						; size = 1
$T248644 = -68						; size = 4
__Next$248652 = -64					; size = 4
$T248636 = -60						; size = 4
$T248619 = -48						; size = 20
$T248618 = -28						; size = 4
$T248617 = -24						; size = 20
$T248616 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T248616[ebp], esp
	mov	DWORD PTR $T248636[ebp], eax
	mov	ecx, DWORD PTR $T248636[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T248636[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T248636[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T248636[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T248636[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T248636[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T248617[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv174[ebp], eax
	cmp	DWORD PTR $T248617[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T248617[ebp]
	mov	DWORD PTR __Next$248652[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$248652[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$248652[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$248652[ebp]
	cmp	edx, DWORD PTR $T248617[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T248617[ebp]
	mov	DWORD PTR $T248644[ebp], eax
	mov	ecx, DWORD PTR $T248644[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248695[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T248694[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248679[ebp], cl
	mov	dl, BYTE PTR __Cat$248683[ebp]
	mov	BYTE PTR $T248680[ebp], dl
	mov	al, BYTE PTR $T248679[ebp]
	mov	BYTE PTR $T248677[ebp], al
	mov	cl, BYTE PTR $T248681[ebp]
	mov	BYTE PTR $T248676[ebp], cl
	mov	edx, DWORD PTR $T248695[ebp]
	mov	DWORD PTR $T248675[ebp], edx
	mov	eax, DWORD PTR $T248694[ebp]
	mov	DWORD PTR $T248674[ebp], eax
	jmp	SHORT $LN38@Buffered_r
$LN37@Buffered_r:
	mov	ecx, DWORD PTR $T248675[ebp]
	add	ecx, 8
	mov	DWORD PTR $T248675[ebp], ecx
	mov	edx, DWORD PTR $T248674[ebp]
	add	edx, 8
	mov	DWORD PTR $T248674[ebp], edx
$LN38@Buffered_r:
	mov	eax, DWORD PTR $T248674[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN30@Buffered_r
	mov	ecx, DWORD PTR $T248674[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T248675[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN37@Buffered_r
$LN30@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T248699[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T248703[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T248742[ebp], edx
	mov	eax, DWORD PTR $T248703[ebp]
	mov	DWORD PTR $T248741[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248728[ebp], cl
	mov	dl, BYTE PTR __Cat$248732[ebp]
	mov	BYTE PTR $T248729[ebp], dl
	mov	al, BYTE PTR $T248728[ebp]
	mov	BYTE PTR $T248725[ebp], al
	mov	cl, BYTE PTR $T248730[ebp]
	mov	BYTE PTR $T248724[ebp], cl
	mov	edx, DWORD PTR $T248742[ebp]
	mov	DWORD PTR $T248723[ebp], edx
	mov	eax, DWORD PTR $T248699[ebp]
	mov	DWORD PTR $T248722[ebp], eax
	mov	ecx, DWORD PTR $T248741[ebp]
	mov	DWORD PTR $T248721[ebp], ecx
$LN52@Buffered_r:
	mov	edx, DWORD PTR $T248721[ebp]
	cmp	edx, DWORD PTR $T248722[ebp]
	je	SHORT $LN45@Buffered_r
	mov	eax, DWORD PTR $T248722[ebp]
	sub	eax, 8
	mov	DWORD PTR $T248722[ebp], eax
	mov	ecx, DWORD PTR $T248723[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T248723[ebp], ecx
	mov	edx, DWORD PTR $T248722[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T248723[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN52@Buffered_r
$LN45@Buffered_r:
	mov	eax, DWORD PTR $T248723[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T248618[ebp], esp
	mov	DWORD PTR $T248755[ebp], edx
	mov	eax, DWORD PTR $T248755[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T248755[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T248755[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T248755[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T248755[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T248755[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248619[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv178[ebp], eax
	cmp	DWORD PTR $T248619[ebp], 0
	je	SHORT $LN68@Buffered_r
	mov	edx, DWORD PTR $T248619[ebp]
	mov	DWORD PTR __Next$248766[ebp], edx
	jmp	SHORT $LN66@Buffered_r
$LN65@Buffered_r:
	mov	eax, DWORD PTR __Next$248766[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$248766[ebp], eax
$LN66@Buffered_r:
	mov	ecx, DWORD PTR __Next$248766[ebp]
	cmp	ecx, DWORD PTR $T248619[ebp+8]
	je	SHORT $LN64@Buffered_r
	jmp	SHORT $LN65@Buffered_r
$LN64@Buffered_r:
	mov	edx, DWORD PTR $T248619[ebp]
	mov	DWORD PTR $T248763[ebp], edx
	mov	eax, DWORD PTR $T248763[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T248813[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248812[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T248799[ebp], al
	mov	cl, BYTE PTR __Cat$248803[ebp]
	mov	BYTE PTR $T248800[ebp], cl
	mov	dl, BYTE PTR $T248799[ebp]
	mov	BYTE PTR $T248796[ebp], dl
	mov	al, BYTE PTR $T248801[ebp]
	mov	BYTE PTR $T248795[ebp], al
	mov	ecx, DWORD PTR $T248813[ebp]
	mov	DWORD PTR $T248794[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T248793[ebp], edx
	mov	eax, DWORD PTR $T248812[ebp]
	mov	DWORD PTR $T248792[ebp], eax
$LN81@Buffered_r:
	mov	ecx, DWORD PTR $T248792[ebp]
	cmp	ecx, DWORD PTR $T248793[ebp]
	je	SHORT $LN74@Buffered_r
	mov	edx, DWORD PTR $T248793[ebp]
	sub	edx, 8
	mov	DWORD PTR $T248793[ebp], edx
	mov	eax, DWORD PTR $T248794[ebp]
	sub	eax, 8
	mov	DWORD PTR $T248794[ebp], eax
	mov	ecx, DWORD PTR $T248793[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T248794[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN81@Buffered_r
$LN74@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T248817[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T248821[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248861[ebp], edx
	mov	eax, DWORD PTR $T248821[ebp]
	mov	DWORD PTR $T248860[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T248852[ebp], cl
	mov	dl, BYTE PTR __Cat$248857[ebp]
	mov	BYTE PTR $T248853[ebp], dl
	mov	al, BYTE PTR $T248852[ebp]
	mov	BYTE PTR $T248843[ebp], al
	mov	cl, BYTE PTR $T248854[ebp]
	mov	BYTE PTR $T248842[ebp], cl
	mov	edx, DWORD PTR $T248861[ebp]
	mov	DWORD PTR $T248841[ebp], edx
	mov	eax, DWORD PTR $T248860[ebp]
	mov	DWORD PTR $T248840[ebp], eax
	jmp	SHORT $LN96@Buffered_r
$LN95@Buffered_r:
	mov	ecx, DWORD PTR $T248841[ebp]
	add	ecx, 8
	mov	DWORD PTR $T248841[ebp], ecx
	mov	edx, DWORD PTR $T248840[ebp]
	add	edx, 8
	mov	DWORD PTR $T248840[ebp], edx
$LN96@Buffered_r:
	mov	eax, DWORD PTR $T248840[ebp]
	cmp	eax, DWORD PTR $T248817[ebp]
	je	SHORT $LN88@Buffered_r
	mov	ecx, DWORD PTR $T248840[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T248841[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN95@Buffered_r
$LN88@Buffered_r:
	mov	eax, DWORD PTR $T248841[ebp]
	jmp	SHORT $LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	SHORT $LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T248896[ebp], edx
	mov	eax, DWORD PTR $T248896[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	dl, BYTE PTR $T248886[ebp]
	mov	BYTE PTR $T248882[ebp], dl
	mov	eax, DWORD PTR $T248896[ebp]
	mov	DWORD PTR $T248881[ebp], eax
	push	0
	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T248881[ebp]
	push	eax
	call	??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN112@Buffered_r:
	mov	ecx, DWORD PTR __Count2$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __First$[ebp], eax

; 2701 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__Tmp$248980 = -24					; size = 8
__Tmp$248958 = -16					; size = 8
__Tmp$248936 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$248936[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$248936[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$248936[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$248936[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$248958[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$248958[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$248958[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$248958[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$248980[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$248980[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$248980[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$248980[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z
_TEXT	SEGMENT
$T249005 = -32						; size = 4
$T249004 = -28						; size = 8
__Idx$248997 = -20					; size = 4
$T248991 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T249004[ebp]
	mov	DWORD PTR $T248991[ebp], edx
	mov	eax, DWORD PTR $T248991[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T248991[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T249005[ebp], ecx
	mov	eax, DWORD PTR $T249005[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$248997[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T249005[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$248997[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T249005[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$248997[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T249004[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$248997[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T249005[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$248997[ebp]
	mov	DWORD PTR $T249005[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T249005[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T249004[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T249004[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T249032 = -28						; size = 4
__Vptr$249030 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$249030[ebp], ecx
	mov	edx, DWORD PTR __Vptr$249030[ebp]
	mov	DWORD PTR $T249032[ebp], edx
	cmp	DWORD PTR $T249032[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T249032[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T249032[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
PUBLIC	??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv183 = -180						; size = 4
tv182 = -176						; size = 4
tv179 = -172						; size = 4
tv178 = -168						; size = 4
tv174 = -164						; size = 4
tv173 = -160						; size = 4
$T249216 = -156						; size = 4
__Next$249224 = -152					; size = 4
$T249197 = -148						; size = 4
__Next$249205 = -144					; size = 4
$T249189 = -140						; size = 4
$T249152 = -132						; size = 4
__Next$249160 = -128					; size = 4
$T249144 = -124						; size = 4
$T249124 = -120						; size = 4
__Next$249132 = -116					; size = 4
$T249116 = -112						; size = 4
$T249112 = -108						; size = 4
$T249062 = -100						; size = 20
$T249061 = -80						; size = 4
$T249060 = -76						; size = 20
$T249059 = -56						; size = 4
$T249058 = -52						; size = 20
$T249057 = -32						; size = 4
__Mid$228271 = -28					; size = 4
__Mid2$228254 = -24					; size = 4
__Mid1$228253 = -20					; size = 4
__Chunk2$228249 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$228249[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$228249[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$228249[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$228253[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$228253[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$228253[ebp], eax

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$228253[ebp]
	mov	DWORD PTR __Mid2$228254[ebp], ecx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$228254[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$228254[ebp], ecx

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T249057[ebp], esp
	mov	DWORD PTR $T249112[ebp], edx
	mov	eax, DWORD PTR $T249112[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T249112[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T249112[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T249112[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T249112[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T249112[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR __Mid2$228254[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$228253[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$228253[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T249058[ebp]
	push	edx
	call	??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv174[ebp], eax
	mov	eax, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T249116[ebp], eax
	mov	ecx, DWORD PTR $T249116[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Dest$[ebp+16], edx
	cmp	DWORD PTR $T249058[ebp], 0
	je	SHORT $LN37@Chunked_me
	mov	eax, DWORD PTR $T249058[ebp]
	mov	DWORD PTR __Next$249132[ebp], eax
	jmp	SHORT $LN35@Chunked_me
$LN34@Chunked_me:
	mov	ecx, DWORD PTR __Next$249132[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$249132[ebp], ecx
$LN35@Chunked_me:
	mov	edx, DWORD PTR __Next$249132[ebp]
	cmp	edx, DWORD PTR $T249058[ebp+8]
	je	SHORT $LN33@Chunked_me
	jmp	SHORT $LN34@Chunked_me
$LN33@Chunked_me:
	mov	eax, DWORD PTR $T249058[ebp]
	mov	DWORD PTR $T249124[ebp], eax
	mov	ecx, DWORD PTR $T249124[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me:

; 3297 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$228254[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3298 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T249059[ebp], esp
	mov	DWORD PTR $T249144[ebp], ecx
	mov	edx, DWORD PTR $T249144[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T249144[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T249144[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T249144[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T249144[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T249144[ebp]
	mov	DWORD PTR tv178[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T249060[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR $T249060[ebp], 0
	je	SHORT $LN51@Chunked_me
	mov	eax, DWORD PTR $T249060[ebp]
	mov	DWORD PTR __Next$249160[ebp], eax
	jmp	SHORT $LN49@Chunked_me
$LN48@Chunked_me:
	mov	ecx, DWORD PTR __Next$249160[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$249160[ebp], ecx
$LN49@Chunked_me:
	mov	edx, DWORD PTR __Next$249160[ebp]
	cmp	edx, DWORD PTR $T249060[ebp+8]
	je	SHORT $LN47@Chunked_me
	jmp	SHORT $LN48@Chunked_me
$LN47@Chunked_me:
	mov	eax, DWORD PTR $T249060[ebp]
	mov	DWORD PTR $T249152[ebp], eax
	mov	ecx, DWORD PTR $T249152[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me:

; 3302 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$228271[ebp], edx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	mov	ecx, DWORD PTR __Mid$228271[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$228271[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T249061[ebp], esp
	mov	DWORD PTR $T249189[ebp], eax
	mov	ecx, DWORD PTR $T249189[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T249189[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T249189[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T249189[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T249189[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T249189[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228271[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$228271[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T249062[ebp]
	push	eax
	call	??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR $T249062[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	ecx, DWORD PTR $T249062[ebp]
	mov	DWORD PTR __Next$249205[ebp], ecx
	jmp	SHORT $LN69@Chunked_me
$LN68@Chunked_me:
	mov	edx, DWORD PTR __Next$249205[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$249205[ebp], edx
$LN69@Chunked_me:
	mov	eax, DWORD PTR __Next$249205[ebp]
	cmp	eax, DWORD PTR $T249062[ebp+8]
	je	SHORT $LN67@Chunked_me
	jmp	SHORT $LN68@Chunked_me
$LN67@Chunked_me:
	mov	ecx, DWORD PTR $T249062[ebp]
	mov	DWORD PTR $T249197[ebp], ecx
	mov	edx, DWORD PTR $T249197[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3308 : 		}
; 3309 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$249224[ebp], eax
	jmp	SHORT $LN79@Chunked_me
$LN78@Chunked_me:
	mov	ecx, DWORD PTR __Next$249224[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$249224[ebp], ecx
$LN79@Chunked_me:
	mov	edx, DWORD PTR __Next$249224[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me
	jmp	SHORT $LN78@Chunked_me
$LN77@Chunked_me:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249216[ebp], eax
	mov	ecx, DWORD PTR $T249216[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249525 = -200						; size = 4
$T249524 = -196						; size = 4
$T249523 = -192						; size = 4
$T249522 = -188						; size = 4
$T249517 = -116						; size = 1
$T249516 = -115						; size = 1
$T249394 = -112						; size = 4
$T249393 = -108						; size = 4
$T249376 = -102						; size = 1
$T249375 = -101						; size = 1
$T249374 = -100						; size = 4
$T249373 = -96						; size = 4
__Cat$249382 = -88					; size = 1
$T249380 = -87						; size = 1
$T249379 = -86						; size = 1
$T249378 = -85						; size = 1
$T249354 = -84						; size = 4
$T249353 = -80						; size = 4
$T249352 = -76						; size = 4
$T249351 = -72						; size = 4
$T249350 = -68						; size = 4
$T249345 = -22						; size = 1
$T249344 = -21						; size = 1
__Mid$228283 = -16					; size = 4
__Mid2$228280 = -12					; size = 4
__Mid1$228279 = -8					; size = 4
__Chunk2$228275 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$228275[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$228275[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$228275[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$228279[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$228279[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$228279[ebp], eax

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$228279[ebp]
	mov	DWORD PTR __Mid2$228280[ebp], ecx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$228280[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$228280[ebp], ecx

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249354[ebp], edx
	mov	eax, DWORD PTR __Mid2$228280[ebp]
	mov	DWORD PTR $T249353[ebp], eax
	mov	ecx, DWORD PTR __Mid1$228279[ebp]
	mov	DWORD PTR $T249352[ebp], ecx
	mov	edx, DWORD PTR __Mid1$228279[ebp]
	mov	DWORD PTR $T249351[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249350[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249344[ebp], cl
	movzx	edx, BYTE PTR $T249344[ebp]
	push	edx
	movzx	eax, BYTE PTR $T249345[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249354[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249353[ebp]
	push	edx
	mov	eax, DWORD PTR $T249352[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249351[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249350[ebp]
	push	edx
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], eax

; 3297 : 		_First = _Mid2;

	mov	eax, DWORD PTR __Mid2$228280[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 3298 : 		}

	jmp	$LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249394[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249393[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249378[ebp], cl
	mov	dl, BYTE PTR __Cat$249382[ebp]
	mov	BYTE PTR $T249379[ebp], dl
	mov	al, BYTE PTR $T249378[ebp]
	mov	BYTE PTR $T249376[ebp], al
	mov	cl, BYTE PTR $T249380[ebp]
	mov	BYTE PTR $T249375[ebp], cl
	mov	edx, DWORD PTR $T249394[ebp]
	mov	DWORD PTR $T249374[ebp], edx
	mov	eax, DWORD PTR $T249393[ebp]
	mov	DWORD PTR $T249373[ebp], eax
	jmp	SHORT $LN57@Chunked_me@2
$LN56@Chunked_me@2:
	mov	ecx, DWORD PTR $T249374[ebp]
	add	ecx, 8
	mov	DWORD PTR $T249374[ebp], ecx
	mov	edx, DWORD PTR $T249373[ebp]
	add	edx, 8
	mov	DWORD PTR $T249373[ebp], edx
$LN57@Chunked_me@2:
	mov	eax, DWORD PTR $T249373[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN49@Chunked_me@2
	mov	ecx, DWORD PTR $T249373[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T249374[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN56@Chunked_me@2
$LN49@Chunked_me@2:

; 3302 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$228283[ebp], edx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	mov	ecx, DWORD PTR __Mid$228283[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$228283[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249525[ebp], eax
	mov	ecx, DWORD PTR __Mid$228283[ebp]
	mov	DWORD PTR $T249524[ebp], ecx
	mov	edx, DWORD PTR __Mid$228283[ebp]
	mov	DWORD PTR $T249523[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249522[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249516[ebp], cl
	movzx	edx, BYTE PTR $T249516[ebp]
	push	edx
	movzx	eax, BYTE PTR $T249517[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249525[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T249524[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249523[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249522[ebp]
	push	edx
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN6@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249569 = -36						; size = 4
__Next$249577 = -32					; size = 4
$T249530 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T249530[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T249530[ebp]
	or	eax, 1
	mov	DWORD PTR $T249530[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN31@Copy_opt
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$249577[ebp], ecx
	jmp	SHORT $LN29@Copy_opt
$LN28@Copy_opt:
	mov	edx, DWORD PTR __Next$249577[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$249577[ebp], edx
$LN29@Copy_opt:
	mov	eax, DWORD PTR __Next$249577[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN27@Copy_opt
	jmp	SHORT $LN28@Copy_opt
$LN27@Copy_opt:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249569[ebp], ecx
	mov	edx, DWORD PTR $T249569[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249683 = -64						; size = 4
$T249682 = -60						; size = 4
$T249665 = -54						; size = 1
$T249664 = -53						; size = 1
$T249663 = -52						; size = 4
$T249662 = -48						; size = 4
__Cat$249671 = -40					; size = 1
$T249669 = -39						; size = 1
$T249668 = -38						; size = 1
$T249667 = -37						; size = 1
$T249643 = -36						; size = 4
$T249642 = -32						; size = 4
$T249625 = -26						; size = 1
$T249624 = -25						; size = 1
$T249623 = -24						; size = 4
$T249622 = -20						; size = 4
__Cat$249631 = -12					; size = 1
$T249629 = -11						; size = 1
$T249628 = -10						; size = 1
$T249627 = -9						; size = 1
$T249597 = -8						; size = 4
$T249593 = -4						; size = 4
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249593[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249597[ebp], eax
	mov	ecx, DWORD PTR $T249593[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T249597[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ecx, DWORD PTR __First2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 8
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge:
	jmp	SHORT $LN4@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249643[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T249642[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T249627[ebp], cl
	mov	dl, BYTE PTR __Cat$249631[ebp]
	mov	BYTE PTR $T249628[ebp], dl
	mov	al, BYTE PTR $T249627[ebp]
	mov	BYTE PTR $T249625[ebp], al
	mov	cl, BYTE PTR $T249629[ebp]
	mov	BYTE PTR $T249624[ebp], cl
	mov	edx, DWORD PTR $T249643[ebp]
	mov	DWORD PTR $T249623[ebp], edx
	mov	eax, DWORD PTR $T249642[ebp]
	mov	DWORD PTR $T249622[ebp], eax
	jmp	SHORT $LN22@Merge
$LN21@Merge:
	mov	ecx, DWORD PTR $T249623[ebp]
	add	ecx, 8
	mov	DWORD PTR $T249623[ebp], ecx
	mov	edx, DWORD PTR $T249622[ebp]
	add	edx, 8
	mov	DWORD PTR $T249622[ebp], edx
$LN22@Merge:
	mov	eax, DWORD PTR $T249622[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN14@Merge
	mov	ecx, DWORD PTR $T249622[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T249623[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN21@Merge
$LN14@Merge:
	mov	edx, DWORD PTR $T249623[ebp]
	mov	DWORD PTR __Dest$[ebp], edx

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249683[ebp], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T249682[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T249667[ebp], dl
	mov	al, BYTE PTR __Cat$249671[ebp]
	mov	BYTE PTR $T249668[ebp], al
	mov	cl, BYTE PTR $T249667[ebp]
	mov	BYTE PTR $T249665[ebp], cl
	mov	dl, BYTE PTR $T249669[ebp]
	mov	BYTE PTR $T249664[ebp], dl
	mov	eax, DWORD PTR $T249683[ebp]
	mov	DWORD PTR $T249663[ebp], eax
	mov	ecx, DWORD PTR $T249682[ebp]
	mov	DWORD PTR $T249662[ebp], ecx
	jmp	SHORT $LN33@Merge
$LN32@Merge:
	mov	edx, DWORD PTR $T249663[ebp]
	add	edx, 8
	mov	DWORD PTR $T249663[ebp], edx
	mov	eax, DWORD PTR $T249662[ebp]
	add	eax, 8
	mov	DWORD PTR $T249662[ebp], eax
$LN33@Merge:
	mov	ecx, DWORD PTR $T249662[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN25@Merge
	mov	edx, DWORD PTR $T249662[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T249663[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN32@Merge
$LN25@Merge:
	mov	eax, DWORD PTR $T249663[ebp]

; 2521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T249772 = -72						; size = 4
$T249768 = -68						; size = 4
$T249763 = -64						; size = 4
$T249762 = -60						; size = 4
$T249746 = -54						; size = 1
$T249745 = -53						; size = 1
$T249744 = -52						; size = 4
$T249743 = -48						; size = 4
$T249742 = -44						; size = 4
__Cat$249753 = -36					; size = 1
$T249751 = -35						; size = 1
$T249750 = -34						; size = 1
$T249749 = -33						; size = 1
$T249724 = -32						; size = 4
$T249723 = -28						; size = 4
$T249707 = -22						; size = 1
$T249706 = -21						; size = 1
$T249705 = -20						; size = 4
$T249704 = -16						; size = 4
$T249703 = -12						; size = 4
__Cat$249714 = -4					; size = 1
$T249712 = -3						; size = 1
$T249711 = -2						; size = 1
$T249710 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
$LN8@Merge_back:

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	SHORT $LN6@Merge_back

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249724[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T249723[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T249710[ebp], al
	mov	cl, BYTE PTR __Cat$249714[ebp]
	mov	BYTE PTR $T249711[ebp], cl
	mov	dl, BYTE PTR $T249710[ebp]
	mov	BYTE PTR $T249707[ebp], dl
	mov	al, BYTE PTR $T249712[ebp]
	mov	BYTE PTR $T249706[ebp], al
	mov	ecx, DWORD PTR $T249724[ebp]
	mov	DWORD PTR $T249705[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T249704[ebp], edx
	mov	eax, DWORD PTR $T249723[ebp]
	mov	DWORD PTR $T249703[ebp], eax
$LN18@Merge_back:
	mov	ecx, DWORD PTR $T249703[ebp]
	cmp	ecx, DWORD PTR $T249704[ebp]
	je	SHORT $LN11@Merge_back
	mov	edx, DWORD PTR $T249704[ebp]
	sub	edx, 8
	mov	DWORD PTR $T249704[ebp], edx
	mov	eax, DWORD PTR $T249705[ebp]
	sub	eax, 8
	mov	DWORD PTR $T249705[ebp], eax
	mov	ecx, DWORD PTR $T249704[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T249705[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN18@Merge_back
$LN11@Merge_back:
	mov	eax, DWORD PTR $T249705[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249763[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T249762[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T249749[ebp], dl
	mov	al, BYTE PTR __Cat$249753[ebp]
	mov	BYTE PTR $T249750[ebp], al
	mov	cl, BYTE PTR $T249749[ebp]
	mov	BYTE PTR $T249746[ebp], cl
	mov	dl, BYTE PTR $T249751[ebp]
	mov	BYTE PTR $T249745[ebp], dl
	mov	eax, DWORD PTR $T249763[ebp]
	mov	DWORD PTR $T249744[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T249743[ebp], ecx
	mov	edx, DWORD PTR $T249762[ebp]
	mov	DWORD PTR $T249742[ebp], edx
$LN28@Merge_back:
	mov	eax, DWORD PTR $T249742[ebp]
	cmp	eax, DWORD PTR $T249743[ebp]
	je	SHORT $LN21@Merge_back
	mov	ecx, DWORD PTR $T249743[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T249743[ebp], ecx
	mov	edx, DWORD PTR $T249744[ebp]
	sub	edx, 8
	mov	DWORD PTR $T249744[ebp], edx
	mov	eax, DWORD PTR $T249743[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T249744[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN28@Merge_back
$LN21@Merge_back:
	mov	eax, DWORD PTR $T249744[ebp]
	jmp	$LN9@Merge_back
	jmp	SHORT $LN5@Merge_back
$LN4@Merge_back:

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Last2$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249768[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249772[ebp], eax
	mov	ecx, DWORD PTR $T249768[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T249772[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Merge_back

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Last2$[ebp]
	add	eax, 8
	mov	DWORD PTR __Last2$[ebp], eax

; 2718 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Last1$[ebp]
	add	eax, 8
	mov	DWORD PTR __Last1$[ebp], eax
$LN5@Merge_back:
	jmp	$LN8@Merge_back
$LN9@Merge_back:

; 2720 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T249824 = -32						; size = 4
$T249820 = -28						; size = 4
$T249798 = -20						; size = 4
__Count2$228333 = -12					; size = 4
__Mid$228334 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2255 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249798[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T249798[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$228333[ebp], eax

; 2260 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$228334[ebp], edx

; 2261 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$228333[ebp]
	mov	ecx, DWORD PTR __Mid$228334[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$228334[ebp], edx

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	eax, DWORD PTR __Mid$228334[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249820[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249824[ebp], eax
	mov	ecx, DWORD PTR $T249820[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T249824[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$228334[ebp]
	add	ecx, 8
	mov	DWORD PTR __Mid$228334[ebp], ecx
	mov	edx, DWORD PTR __Mid$228334[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$228333[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$228333[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Lower_boun:

; 2268 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2269 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2270 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T249876 = -32						; size = 4
$T249872 = -28						; size = 4
$T249850 = -20						; size = 4
__Count2$228342 = -12					; size = 4
__Mid$228343 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2327 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T249850[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR $T249850[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN4@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$228342[ebp], eax

; 2331 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$228343[ebp], edx

; 2332 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$228342[ebp]
	mov	ecx, DWORD PTR __Mid$228343[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$228343[ebp], edx

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T249872[ebp], ecx
	mov	edx, DWORD PTR __Mid$228343[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T249876[ebp], eax
	mov	ecx, DWORD PTR $T249872[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T249876[ebp]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	ecx, DWORD PTR __Mid$228343[ebp]
	add	ecx, 8
	mov	DWORD PTR __Mid$228343[ebp], ecx
	mov	edx, DWORD PTR __Mid$228343[ebp]
	mov	DWORD PTR __First$[ebp], edx
	mov	eax, DWORD PTR __Count2$228342[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$[ebp], ecx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	edx, DWORD PTR __Count2$228342[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$LN1@Upper_boun:

; 2339 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2340 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2341 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
$T249928 = -60						; size = 8
$T249899 = -20						; size = 4
$T249893 = -12						; size = 4
$T249892 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T249893[ebp], eax
	lea	ecx, DWORD PTR $T249928[ebp]
	mov	DWORD PTR $T249892[ebp], ecx
	mov	edx, DWORD PTR $T249892[ebp]
	mov	eax, DWORD PTR $T249893[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T249892[ebp]
	mov	eax, DWORD PTR $T249893[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T249899[ebp], esp
	mov	eax, DWORD PTR $T249899[ebp]
	mov	ecx, DWORD PTR $T249928[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T249899[ebp]
	mov	eax, DWORD PTR $T249928[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T249939 = -12						; size = 4
__Vptr$249945 = -8					; size = 4
__Ptr$228433 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z PROC ; std::_Temp_iterator<CvOperationSearchUnit>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@2

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	SHORT $LN1@operator@2
$LN2@operator@2:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$228433[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$228433[ebp]
	mov	DWORD PTR __Vptr$249945[ebp], edx
	mov	eax, DWORD PTR __Vptr$249945[ebp]
	mov	DWORD PTR $T249939[ebp], eax
	cmp	DWORD PTR $T249939[ebp], 0
	je	SHORT $LN7@operator@2
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T249939[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T249939[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator@2
$LN7@operator@2:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator@2:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator@2:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv132 = -44						; size = 4
$T249976 = -40						; size = 4
__Next$249984 = -36					; size = 4
$T249968 = -32						; size = 4
$T249954 = -24						; size = 4
$T249950 = -20						; size = 4
$T249949 = -14						; size = 1
$T249948 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z PROC ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T249954[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T249948[ebp], al
	movzx	ecx, BYTE PTR $T249948[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T249949[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T249950[ebp], esp
	mov	DWORD PTR $T249968[ebp], eax
	mov	ecx, DWORD PTR $T249968[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T249968[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T249968[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T249968[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T249968[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T249968[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR $T249954[ebp]
	or	ecx, 1
	mov	DWORD PTR $T249954[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@2
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$249984[ebp], edx
	jmp	SHORT $LN15@unchecked_@2
$LN14@unchecked_@2:
	mov	eax, DWORD PTR __Next$249984[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$249984[ebp], eax
$LN15@unchecked_@2:
	mov	ecx, DWORD PTR __Next$249984[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@2
	jmp	SHORT $LN14@unchecked_@2
$LN13@unchecked_@2:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T249976[ebp], edx
	mov	eax, DWORD PTR $T249976[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ENDP ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -120						; size = 4
tv163 = -116						; size = 4
tv159 = -112						; size = 4
tv158 = -108						; size = 4
$T250110 = -104						; size = 4
__Next$250118 = -100					; size = 4
$T250102 = -96						; size = 4
$T250082 = -92						; size = 4
__Next$250090 = -88					; size = 4
$T250074 = -84						; size = 4
$T250070 = -80						; size = 4
$T250017 = -52						; size = 4
$T250013 = -48						; size = 4
$T250004 = -44						; size = 4
$T249998 = -40						; size = 4
$T249997 = -36						; size = 20
$T249996 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T250004[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T250013[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T250017[ebp], edx
	mov	eax, DWORD PTR $T250013[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T250017[ebp]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN34@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
	mov	ecx, DWORD PTR __First2$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First2$[ebp], ecx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN34@Merge@2:
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
	mov	eax, DWORD PTR __First1$[ebp]
	add	eax, 8
	mov	DWORD PTR __First1$[ebp], eax
$LN1@Merge@2:
	jmp	SHORT $LN5@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T249996[ebp], esp
	mov	DWORD PTR $T250070[ebp], ecx
	mov	edx, DWORD PTR $T250070[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T250070[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T250070[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T250070[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T250070[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T250070[ebp]
	mov	DWORD PTR tv158[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T249997[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv159[ebp], eax
	mov	eax, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T250074[ebp], eax
	mov	ecx, DWORD PTR $T250074[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Dest$[ebp+16], edx
	cmp	DWORD PTR $T249997[ebp], 0
	je	SHORT $LN56@Merge@2
	mov	eax, DWORD PTR $T249997[ebp]
	mov	DWORD PTR __Next$250090[ebp], eax
	jmp	SHORT $LN54@Merge@2
$LN53@Merge@2:
	mov	ecx, DWORD PTR __Next$250090[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$250090[ebp], ecx
$LN54@Merge@2:
	mov	edx, DWORD PTR __Next$250090[ebp]
	cmp	edx, DWORD PTR $T249997[ebp+8]
	je	SHORT $LN52@Merge@2
	jmp	SHORT $LN53@Merge@2
$LN52@Merge@2:
	mov	eax, DWORD PTR $T249997[ebp]
	mov	DWORD PTR $T250082[ebp], eax
	mov	ecx, DWORD PTR $T250082[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T249998[ebp], esp
	mov	DWORD PTR $T250102[ebp], edx
	mov	eax, DWORD PTR $T250102[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T250102[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T250102[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T250102[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T250102[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T250102[ebp]
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv164[ebp], eax
	mov	ecx, DWORD PTR $T250004[ebp]
	or	ecx, 1
	mov	DWORD PTR $T250004[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN70@Merge@2
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$250118[ebp], edx
	jmp	SHORT $LN68@Merge@2
$LN67@Merge@2:
	mov	eax, DWORD PTR __Next$250118[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$250118[ebp], eax
$LN68@Merge@2:
	mov	ecx, DWORD PTR __Next$250118[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN66@Merge@2
	jmp	SHORT $LN67@Merge@2
$LN66@Merge@2:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T250110[ebp], edx
	mov	eax, DWORD PTR $T250110[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN70@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z
_TEXT	SEGMENT
tv128 = -44						; size = 4
tv83 = -40						; size = 4
__Hole$228556 = -36					; size = 4
__Holeval$228558 = -32					; size = 8
__Next1$228559 = -24					; size = 4
__Next$228557 = -20					; size = 4
__Tmp$228551 = -16					; size = 4
__Factor$228547 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z PROC ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	DWORD PTR __Count$[ebp], ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$228547[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$228547[ebp], 0
	je	SHORT $LN7@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$228547[ebp]
	mov	DWORD PTR __Tmp$228551[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$228547[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$228551[ebp]
	mov	DWORD PTR __Factor$228547[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate
$LN7@Rotate:

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	DWORD PTR __Count$[ebp], edx
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Hole$228556[ebp], eax

; 1695 : 			_RanIt _Next = _Hole;

	mov	ecx, DWORD PTR __Hole$228556[ebp]
	mov	DWORD PTR __Next$228557[ebp], ecx

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	edx, DWORD PTR __Hole$228556[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Holeval$228558[ebp], eax
	mov	DWORD PTR __Holeval$228558[ebp+4], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Next$228557[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN11@Rotate
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	eax, DWORD PTR __Shift$[ebp]
	mov	ecx, DWORD PTR __Next$228557[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv83[ebp], edx
$LN12@Rotate:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR __Next1$228559[ebp], eax
$LN2@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	mov	ecx, DWORD PTR __Next1$228559[ebp]
	cmp	ecx, DWORD PTR __Hole$228556[ebp]
	je	SHORT $LN1@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$228559[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Next$228557[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 1701 : 				_Next = _Next1;

	mov	eax, DWORD PTR __Next1$228559[ebp]
	mov	DWORD PTR __Next$228557[ebp], eax

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __Next1$228559[ebp]
	sar	ecx, 3
	cmp	DWORD PTR __Shift$[ebp], ecx
	jge	SHORT $LN13@Rotate
	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Next1$228559[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Next1$228559[ebp]
	sar	edx, 3
	mov	eax, DWORD PTR __Shift$[ebp]
	sub	eax, edx
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv128[ebp], edx
$LN14@Rotate:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR __Next1$228559[ebp], eax

; 1704 : 				}

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Next$228557[ebp]
	mov	edx, DWORD PTR __Holeval$228558[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Holeval$228558[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ENDP ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T250296 = -92						; size = 4
$T250278 = -88						; size = 4
$T250292 = -12						; size = 8
$T250291 = -4						; size = 4
_iTurn$ = 8						; size = 4
?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z PROC	; CvUnit::SetDeployFromOperationTurn, COMDAT
; _this$ = ecx

; 700  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 701  : 		m_iDeployFromOperationTurn = iTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR $T250296[ebp], eax
	mov	ecx, DWORD PTR $T250296[ebp]
	mov	edx, DWORD PTR _iTurn$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN1@SetDeployF
	mov	eax, DWORD PTR $T250296[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iTurn$[ebp]
	je	SHORT $LN1@SetDeployF
	mov	edx, DWORD PTR $T250296[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T250278[ebp], eax
	mov	ecx, DWORD PTR $T250296[ebp]
	mov	DWORD PTR $T250291[ebp], ecx
	lea	edx, DWORD PTR $T250291[ebp]
	push	edx
	lea	eax, DWORD PTR $T250292[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250278[ebp]
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	ecx, DWORD PTR $T250296[ebp]
	mov	edx, DWORD PTR _iTurn$[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN1@SetDeployF:

; 702  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z ENDP	; CvUnit::SetDeployFromOperationTurn
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperation@@UBEHXZ PROC		; CvAIOperation::GetOperationType, COMDAT
; _this$ = ecx

; 151  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 		return INVALID_AI_OPERATION;

	or	eax, -1

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperation@@UBEHXZ ENDP		; CvAIOperation::GetOperationType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ PROC ; CvAIOperation::CanTacticalAIInterruptOperation, COMDAT
; _this$ = ecx

; 155  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 		return false;

	xor	al, al

; 157  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ ENDP ; CvAIOperation::CanTacticalAIInterruptOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ PROC	; CvAIOperation::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 159  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		return true;

	mov	al, 1

; 161  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ ENDP	; CvAIOperation::NeedToCheckPathToTarget
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperation::GetFormation, COMDAT
; _this$ = ecx

; 164  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		return NO_MUFORMATION;

	or	eax, -1

; 166  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperation::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ PROC ; CvAIOperation::GetMoveType, COMDAT
; _this$ = ecx

; 168  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		return m_eMoveType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+84]

; 170  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ ENDP ; CvAIOperation::GetMoveType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllNavalOperation@CvAIOperation@@UBE_NXZ PROC	; CvAIOperation::IsAllNavalOperation, COMDAT
; _this$ = ecx

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 		return false;

	xor	al, al

; 199  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllNavalOperation@CvAIOperation@@UBE_NXZ ENDP	; CvAIOperation::IsAllNavalOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ PROC	; CvAIOperation::IsMixedLandNavalOperation, COMDAT
; _this$ = ecx

; 201  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 		return false;

	xor	al, al

; 203  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ ENDP	; CvAIOperation::IsMixedLandNavalOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pArmy$ = 8						; size = 4
?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z PROC	; CvAIOperation::ArmyMoved, COMDAT
; _this$ = ecx

; 224  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 		return false;

	xor	al, al

; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ENDP	; CvAIOperation::ArmyMoved
_TEXT	ENDS
PUBLIC	??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@	; `string'
;	COMDAT ??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@ DB 'INVALID_AI_OPERATION', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250321 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ PROC ; CvAIOperation::GetOperationName, COMDAT
; _this$ = ecx

; 267  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250321[ebp], 0

; 268  : 		return CvString("INVALID_AI_OPERATION");

	mov	eax, OFFSET ??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@6
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@
	jmp	SHORT $LN8@GetOperati@6
$LN7@GetOperati@6:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@6:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250321[ebp]
	or	edx, 1
	mov	DWORD PTR $T250321[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ ENDP ; CvAIOperation::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ PROC ; CvAIOperationBasicCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 347  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 348  : 		return AI_OPERATION_BASIC_CITY_ATTACK;

	mov	eax, 2

; 349  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ ENDP ; CvAIOperationBasicCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@ DB 'AI_OPERATION_B'
	DB	'ASIC_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250336 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationBasicCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 351  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250336[ebp], 0

; 352  : 		return CvString("AI_OPERATION_BASIC_CITY_ATTACK");

	mov	eax, OFFSET ??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@7
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@
	jmp	SHORT $LN8@GetOperati@7
$LN7@GetOperati@7:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@7:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250336[ebp]
	or	edx, 1
	mov	DWORD PTR $T250336[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 353  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationBasicCityAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ PROC ; CvAIOperationBasicCityAttack::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 355  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 356  : 		return false;

	xor	al, al

; 357  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ ENDP ; CvAIOperationBasicCityAttack::NeedToCheckPathToTarget
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ PROC ; CvAIOperationSneakCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 377  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 		return AI_OPERATION_SNEAK_CITY_ATTACK;

	mov	eax, 6

; 379  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ ENDP ; CvAIOperationSneakCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@ DB 'AI_OPERATION_S'
	DB	'NEAK_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250353 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationSneakCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 381  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250353[ebp], 0

; 382  : 		return CvString("AI_OPERATION_SNEAK_CITY_ATTACK");

	mov	eax, OFFSET ??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@8
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@
	jmp	SHORT $LN8@GetOperati@8
$LN7@GetOperati@8:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@8:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250353[ebp]
	or	edx, 1
	mov	DWORD PTR $T250353[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationSneakCityAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationQuickSneakCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 392  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 393  : 		return MUFORMATION_EARLY_RUSH;

	mov	eax, 15					; 0000000fH

; 394  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationQuickSneakCityAttack::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ PROC ; CvAIOperationSmallCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 407  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 408  : 		return AI_OPERATION_SMALL_CITY_ATTACK;

	mov	eax, 7

; 409  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ ENDP ; CvAIOperationSmallCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@ DB 'AI_OPERATION_SM'
	DB	'ALL_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250370 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationSmallCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 411  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250370[ebp], 0

; 412  : 		return CvString("AI_OPERATION_SMALL_CITY_ATTACK");

	mov	eax, OFFSET ??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@9
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@
	jmp	SHORT $LN8@GetOperati@9
$LN7@GetOperati@9:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@9:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250370[ebp]
	or	edx, 1
	mov	DWORD PTR $T250370[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 413  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationSmallCityAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T250390 = -12						; size = 4
$T250389 = -8						; size = 4
$T250385 = -4						; size = 4
?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationSmallCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 415  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 		return (GC.getGame().getHandicapInfo().GetID() > 4) ? MUFORMATION_BASIC_CITY_ATTACK_FORCE : MUFORMATION_SMALL_CITY_ATTACK_FORCE;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250385[ebp], eax
	mov	ecx, DWORD PTR $T250385[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T250389[ebp], eax
	mov	ecx, DWORD PTR $T250389[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T250390[ebp], edx
	xor	eax, eax
	cmp	DWORD PTR $T250390[ebp], 4
	setg	al
	sub	eax, 1
	and	eax, 7

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationSmallCityAttack::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ PROC ; CvAIOperationCityStateAttack::GetOperationType, COMDAT
; _this$ = ecx

; 430  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 		return AI_OPERATION_CITY_STATE_ATTACK;

	mov	eax, 15					; 0000000fH

; 432  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ ENDP ; CvAIOperationCityStateAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@ DB 'AI_OPERATION_C'
	DB	'ITY_STATE_ATTACK', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250396 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationCityStateAttack::GetOperationName, COMDAT
; _this$ = ecx

; 434  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250396[ebp], 0

; 435  : 		return CvString("AI_OPERATION_CITY_STATE_ATTACK");

	mov	eax, OFFSET ??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@10
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@
	jmp	SHORT $LN8@GetOperati@10
$LN7@GetOperati@10:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@10:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250396[ebp]
	or	edx, 1
	mov	DWORD PTR $T250396[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 436  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationCityStateAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ PROC ; CvAIOperationDestroyBarbarianCamp::GetOperationType, COMDAT
; _this$ = ecx

; 455  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 456  : 		return AI_OPERATION_DESTROY_BARBARIAN_CAMP;

	mov	eax, 3

; 457  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@ ; `string'
;	COMDAT ??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@ DB 'AI_OPERATION_DES'
	DB	'TROY_BARBARIAN_CAMP', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250411 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ PROC ; CvAIOperationDestroyBarbarianCamp::GetOperationName, COMDAT
; _this$ = ecx

; 459  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250411[ebp], 0

; 460  : 		return CvString("AI_OPERATION_DESTROY_BARBARIAN_CAMP");

	mov	eax, OFFSET ??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@
	test	eax, eax
	je	SHORT $LN7@GetOperati@11
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@
	jmp	SHORT $LN8@GetOperati@11
$LN7@GetOperati@11:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@11:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250411[ebp]
	or	edx, 1
	mov	DWORD PTR $T250411[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 461  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationDestroyBarbarianCamp::GetFormation, COMDAT
; _this$ = ecx

; 463  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 464  : 		return MUFORMATION_ANTI_BARBARIAN_TEAM;

	mov	eax, 3

; 465  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ PROC ; CvAIOperationPillageEnemy::GetOperationType, COMDAT
; _this$ = ecx

; 492  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 493  : 		return AI_OPERATION_PILLAGE_ENEMY;

	mov	eax, 5

; 494  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ ENDP ; CvAIOperationPillageEnemy::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@ ; `string'
;	COMDAT ??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@ DB 'AI_OPERATION_PILLA'
	DB	'GE_ENEMY', 00H				; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250428 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ PROC ; CvAIOperationPillageEnemy::GetOperationName, COMDAT
; _this$ = ecx

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250428[ebp], 0

; 497  : 		return CvString("AI_OPERATION_PILLAGE_ENEMY");

	mov	eax, OFFSET ??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@12
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@
	jmp	SHORT $LN8@GetOperati@12
$LN7@GetOperati@12:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@12:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250428[ebp]
	or	edx, 1
	mov	DWORD PTR $T250428[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 498  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ ENDP ; CvAIOperationPillageEnemy::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ PROC ; CvAIOperationPillageEnemy::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 500  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 501  : 		return false;

	xor	al, al

; 502  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ ENDP ; CvAIOperationPillageEnemy::NeedToCheckPathToTarget
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationPillageEnemy::GetFormation, COMDAT
; _this$ = ecx

; 504  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 		return MUFORMATION_FAST_PILLAGERS;

	mov	eax, 2

; 506  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationPillageEnemy::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationFoundCity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationFoundCity@@UBEHXZ PROC	; CvAIOperationFoundCity::GetOperationType, COMDAT
; _this$ = ecx

; 557  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 558  : 		return AI_OPERATION_FOUND_CITY;

	mov	eax, 4

; 559  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationFoundCity@@UBEHXZ ENDP	; CvAIOperationFoundCity::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@	; `string'
;	COMDAT ??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@ DB 'AI_OPERATION_FOUND_CI'
	DB	'TY', 00H					; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250447 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ PROC ; CvAIOperationFoundCity::GetOperationName, COMDAT
; _this$ = ecx

; 561  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250447[ebp], 0

; 562  : 		return CvString("AI_OPERATION_FOUND_CITY");

	mov	eax, OFFSET ??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@13
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@
	jmp	SHORT $LN8@GetOperati@13
$LN7@GetOperati@13:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@13:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250447[ebp]
	or	edx, 1
	mov	DWORD PTR $T250447[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 563  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ ENDP ; CvAIOperationFoundCity::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationFoundCity::GetFormation, COMDAT
; _this$ = ecx

; 565  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return MUFORMATION_SETTLER_ESCORT;

	mov	eax, 6

; 567  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationFoundCity::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ PROC ; CvAIOperationQuickColonize::GetOperationType, COMDAT
; _this$ = ecx

; 588  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 589  : 		return AI_OPERATION_QUICK_COLONIZE;

	mov	eax, 12					; 0000000cH

; 590  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ ENDP ; CvAIOperationQuickColonize::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@ ; `string'
;	COMDAT ??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@ DB 'AI_OPERATION_QUIC'
	DB	'K_COLONIZE', 00H				; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250464 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ PROC ; CvAIOperationQuickColonize::GetOperationName, COMDAT
; _this$ = ecx

; 592  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250464[ebp], 0

; 593  : 		return CvString("AI_OPERATION_QUICK_COLONIZE");

	mov	eax, OFFSET ??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@14
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@
	jmp	SHORT $LN8@GetOperati@14
$LN7@GetOperati@14:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@14:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250464[ebp]
	or	edx, 1
	mov	DWORD PTR $T250464[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 594  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ ENDP ; CvAIOperationQuickColonize::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationQuickColonize::GetFormation, COMDAT
; _this$ = ecx

; 596  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 597  : 		return MUFORMATION_QUICK_COLONY_SETTLER;

	mov	eax, 11					; 0000000bH

; 598  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationQuickColonize::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ PROC ; CvAIOperationMerchantDelegation::GetOperationType, COMDAT
; _this$ = ecx

; 617  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 618  : 		return AI_OPERATION_MERCHANT_DELEGATION;

	mov	eax, 8

; 619  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ ENDP ; CvAIOperationMerchantDelegation::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@ ; `string'
;	COMDAT ??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@ DB 'AI_OPERATION_MER'
	DB	'CHANT_DELEGATION', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250481 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ PROC ; CvAIOperationMerchantDelegation::GetOperationName, COMDAT
; _this$ = ecx

; 621  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250481[ebp], 0

; 622  : 		return CvString("AI_OPERATION_MERCHANT_DELEGATION");

	mov	eax, OFFSET ??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@
	test	eax, eax
	je	SHORT $LN7@GetOperati@15
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@
	jmp	SHORT $LN8@GetOperati@15
$LN7@GetOperati@15:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@15:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250481[ebp]
	or	edx, 1
	mov	DWORD PTR $T250481[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 623  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ ENDP ; CvAIOperationMerchantDelegation::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationMerchantDelegation::GetFormation, COMDAT
; _this$ = ecx

; 625  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 626  : 		return MUFORMATION_MERCHANT_ESCORT;

	mov	eax, 8

; 627  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationMerchantDelegation::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationConcertTour@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationConcertTour@@UBEHXZ PROC	; CvAIOperationConcertTour::GetOperationType, COMDAT
; _this$ = ecx

; 646  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return AI_OPERATION_CONCERT_TOUR;

	mov	eax, 19					; 00000013H

; 648  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationConcertTour@@UBEHXZ ENDP	; CvAIOperationConcertTour::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@ ; `string'
;	COMDAT ??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@ DB 'AI_OPERATION_CONCER'
	DB	'T_TOUR', 00H				; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250498 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ PROC ; CvAIOperationConcertTour::GetOperationName, COMDAT
; _this$ = ecx

; 650  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250498[ebp], 0

; 651  : 		return CvString("AI_OPERATION_CONCERT_TOUR");

	mov	eax, OFFSET ??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@16
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@
	jmp	SHORT $LN8@GetOperati@16
$LN7@GetOperati@16:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@16:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250498[ebp]
	or	edx, 1
	mov	DWORD PTR $T250498[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ ENDP ; CvAIOperationConcertTour::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationConcertTour::GetFormation, COMDAT
; _this$ = ecx

; 654  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 655  : 		return MUFORMATION_CONCERT_TOUR;

	mov	eax, 19					; 00000013H

; 656  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationConcertTour::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAINavalOperation::GetFormation, COMDAT
; _this$ = ecx

; 679  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 680  : 		return MUFORMATION_NAVAL_SQUADRON;

	mov	eax, 9

; 681  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAINavalOperation::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ PROC	; CvAINavalOperation::IsAllNavalOperation, COMDAT
; _this$ = ecx

; 685  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		return true;

	mov	al, 1

; 687  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ ENDP	; CvAINavalOperation::IsAllNavalOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ PROC	; CvAINavalOperation::GetMaximumRecruitTurns, COMDAT
; _this$ = ecx

; 690  : 	virtual int GetMaximumRecruitTurns() const {return MAX_INT;};   // Let naval units come from afar

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2147483647				; 7fffffffH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ ENDP	; CvAINavalOperation::GetMaximumRecruitTurns
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalBombardment::GetFormation, COMDAT
; _this$ = ecx

; 714  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 715  : 		return MUFORMATION_NAVAL_BOMBARDMENT;

	mov	eax, 16					; 00000010H

; 716  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalBombardment::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ PROC ; CvAIOperationNavalBombardment::GetOperationType, COMDAT
; _this$ = ecx

; 718  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 719  : 		return AI_OPERATION_NAVAL_BOMBARDMENT;

	mov	eax, 9

; 720  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ ENDP ; CvAIOperationNavalBombardment::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@ ; `string'
;	COMDAT ??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@ DB 'AI_OPERATION_N'
	DB	'AVAL_BOMBARDMENT', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250523 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalBombardment::GetOperationName, COMDAT
; _this$ = ecx

; 722  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250523[ebp], 0

; 723  : 		return CvString("AI_OPERATION_NAVAL_BOMBARDMENT");

	mov	eax, OFFSET ??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@17
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@
	jmp	SHORT $LN8@GetOperati@17
$LN7@GetOperati@17:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@17:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250523[ebp]
	or	edx, 1
	mov	DWORD PTR $T250523[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 724  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalBombardment::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ PROC ; CvAIOperationNavalSuperiority::GetOperationType, COMDAT
; _this$ = ecx

; 748  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 749  : 		return AI_OPERATION_NAVAL_SUPERIORITY;

	mov	eax, 10					; 0000000aH

; 750  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ ENDP ; CvAIOperationNavalSuperiority::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@ ; `string'
;	COMDAT ??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@ DB 'AI_OPERATION_N'
	DB	'AVAL_SUPERIORITY', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250538 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalSuperiority::GetOperationName, COMDAT
; _this$ = ecx

; 752  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250538[ebp], 0

; 753  : 		return CvString("AI_OPERATION_NAVAL_SUPERIORITY");

	mov	eax, OFFSET ??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@18
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@
	jmp	SHORT $LN8@GetOperati@18
$LN7@GetOperati@18:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@18:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250538[ebp]
	or	edx, 1
	mov	DWORD PTR $T250538[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 754  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalSuperiority::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ PROC ; CvAIOperationNavalSuperiority::CanTacticalAIInterruptOperation, COMDAT
; _this$ = ecx

; 756  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 757  : 		return true;

	mov	al, 1

; 758  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ ENDP ; CvAIOperationNavalSuperiority::CanTacticalAIInterruptOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationPureNavalCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 781  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 782  : 		return MUFORMATION_PURE_NAVAL_CITY_ATTACK;

	mov	eax, 17					; 00000011H

; 783  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationPureNavalCityAttack::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ PROC ; CvAIOperationPureNavalCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 785  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 786  : 		return AI_OPERATION_PURE_NAVAL_CITY_ATTACK;

	mov	eax, 18					; 00000012H

; 787  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ ENDP ; CvAIOperationPureNavalCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@ ; `string'
;	COMDAT ??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@ DB 'AI_OPERATION_PUR'
	DB	'E_NAVAL_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250557 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationPureNavalCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 789  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250557[ebp], 0

; 790  : 		return CvString("AI_OPERATION_PURE_NAVAL_CITY_ATTACK");

	mov	eax, OFFSET ??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@
	test	eax, eax
	je	SHORT $LN7@GetOperati@19
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@
	jmp	SHORT $LN8@GetOperati@19
$LN7@GetOperati@19:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@19:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250557[ebp]
	or	edx, 1
	mov	DWORD PTR $T250557[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 791  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationPureNavalCityAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ PROC ; CvAIOperationPureNavalCityAttack::CanTacticalAIInterruptOperation, COMDAT
; _this$ = ecx

; 793  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 794  : 		return true;

	mov	al, 1

; 795  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ ENDP ; CvAIOperationPureNavalCityAttack::CanTacticalAIInterruptOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ PROC ; CvAIOperationCityCloseDefense::GetOperationType, COMDAT
; _this$ = ecx

; 821  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 822  : 		return AI_OPERATION_CITY_CLOSE_DEFENSE;

	xor	eax, eax

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ ENDP ; CvAIOperationCityCloseDefense::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@ ; `string'
;	COMDAT ??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@ DB 'AI_OPERATION_C'
	DB	'ITY_CLOSE_DEFENSE', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250574 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ PROC ; CvAIOperationCityCloseDefense::GetOperationName, COMDAT
; _this$ = ecx

; 825  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250574[ebp], 0

; 826  : 		return CvString("AI_OPERATION_CITY_CLOSE_DEFENSE");

	mov	eax, OFFSET ??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@20
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@
	jmp	SHORT $LN8@GetOperati@20
$LN7@GetOperati@20:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@20:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250574[ebp]
	or	edx, 1
	mov	DWORD PTR $T250574[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 827  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ ENDP ; CvAIOperationCityCloseDefense::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationCityCloseDefense::GetFormation, COMDAT
; _this$ = ecx

; 829  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 830  : 		return MUFORMATION_CLOSE_CITY_DEFENSE;

	mov	eax, 5

; 831  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationCityCloseDefense::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ PROC ; CvAIOperationRapidResponse::GetOperationType, COMDAT
; _this$ = ecx

; 853  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 854  : 		return AI_OPERATION_RAPID_RESPONSE;

	mov	eax, 1

; 855  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ ENDP ; CvAIOperationRapidResponse::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@ ; `string'
;	COMDAT ??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@ DB 'AI_OPERATION_RAPI'
	DB	'D_RESPONSE', 00H				; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250591 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ PROC ; CvAIOperationRapidResponse::GetOperationName, COMDAT
; _this$ = ecx

; 857  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250591[ebp], 0

; 858  : 		return CvString("AI_OPERATION_RAPID_RESPONSE");

	mov	eax, OFFSET ??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@21
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@
	jmp	SHORT $LN8@GetOperati@21
$LN7@GetOperati@21:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@21:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250591[ebp]
	or	edx, 1
	mov	DWORD PTR $T250591[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 859  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ ENDP ; CvAIOperationRapidResponse::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationRapidResponse::GetFormation, COMDAT
; _this$ = ecx

; 861  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 862  : 		return MUFORMATION_RAPID_RESPONSE_FORCE;

	mov	eax, 4

; 863  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationRapidResponse::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ PROC ; CvAINavalEscortedOperation::GetOperationType, COMDAT
; _this$ = ecx

; 889  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 890  : 		return AI_OPERATION_COLONIZE;

	mov	eax, 11					; 0000000bH

; 891  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ ENDP ; CvAINavalEscortedOperation::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@	; `string'
;	COMDAT ??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@ DB 'AI_OPERATION_COLONIZE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250608 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ PROC ; CvAINavalEscortedOperation::GetOperationName, COMDAT
; _this$ = ecx

; 893  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250608[ebp], 0

; 894  : 		return CvString("AI_OPERATION_COLONIZE");

	mov	eax, OFFSET ??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@22
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@
	jmp	SHORT $LN8@GetOperati@22
$LN7@GetOperati@22:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@22:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250608[ebp]
	or	edx, 1
	mov	DWORD PTR $T250608[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 895  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ ENDP ; CvAINavalEscortedOperation::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAINavalEscortedOperation::GetFormation, COMDAT
; _this$ = ecx

; 897  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 898  : 		return MUFORMATION_COLONIZATION_PARTY;

	mov	eax, 10					; 0000000aH

; 899  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAINavalEscortedOperation::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ PROC ; CvAINavalEscortedOperation::IsMixedLandNavalOperation, COMDAT
; _this$ = ecx

; 902  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 903  : 		return true;

	mov	al, 1

; 904  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ ENDP ; CvAINavalEscortedOperation::IsMixedLandNavalOperation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ PROC ; CvAINavalEscortedOperation::IsCivilianRequired, COMDAT
; _this$ = ecx

; 906  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 907  : 		return true;

	mov	al, 1

; 908  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ ENDP ; CvAINavalEscortedOperation::IsCivilianRequired
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ PROC	; CvAIOperationNavalAttack::GetOperationType, COMDAT
; _this$ = ecx

; 938  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 939  : 		return AI_OPERATION_NAVAL_ATTACK;

	mov	eax, 13					; 0000000dH

; 940  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ ENDP	; CvAIOperationNavalAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@ DB 'AI_OPERATION_NAVAL_A'
	DB	'TTACK', 00H					; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250629 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalAttack::GetOperationName, COMDAT
; _this$ = ecx

; 942  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250629[ebp], 0

; 943  : 		return CvString("AI_OPERATION_NAVAL_ATTACK");

	mov	eax, OFFSET ??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@23
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@
	jmp	SHORT $LN8@GetOperati@23
$LN7@GetOperati@23:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@23:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250629[ebp]
	or	edx, 1
	mov	DWORD PTR $T250629[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 944  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalAttack::GetFormation, COMDAT
; _this$ = ecx

; 946  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 947  : 		return MUFORMATION_NAVAL_INVASION;

	mov	eax, 12					; 0000000cH

; 948  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalAttack::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ PROC ; CvAIOperationNavalAttack::IsCivilianRequired, COMDAT
; _this$ = ecx

; 951  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 952  : 		return false;

	xor	al, al

; 953  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ ENDP ; CvAIOperationNavalAttack::IsCivilianRequired
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ PROC ; CvAIOperationNavalSneakAttack::GetOperationType, COMDAT
; _this$ = ecx

; 972  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 973  : 		return AI_OPERATION_NAVAL_SNEAK_ATTACK;

	mov	eax, 14					; 0000000eH

; 974  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ ENDP ; CvAIOperationNavalSneakAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@ DB 'AI_OPERATION_'
	DB	'NAVAL_SNEAK_ATTACK', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250648 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalSneakAttack::GetOperationName, COMDAT
; _this$ = ecx

; 976  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250648[ebp], 0

; 977  : 		return CvString("AI_OPERATION_NAVAL_SNEAK_ATTACK");

	mov	eax, OFFSET ??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@24
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@
	jmp	SHORT $LN8@GetOperati@24
$LN7@GetOperati@24:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@24:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250648[ebp]
	or	edx, 1
	mov	DWORD PTR $T250648[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 978  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalSneakAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalSneakAttack::GetFormation, COMDAT
; _this$ = ecx

; 980  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 981  : 		return MUFORMATION_NAVAL_INVASION;

	mov	eax, 12					; 0000000cH

; 982  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalSneakAttack::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ PROC ; CvAIOperationNavalCityStateAttack::GetOperationType, COMDAT
; _this$ = ecx

; 995  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 996  : 		return AI_OPERATION_CITY_STATE_NAVAL_ATTACK;

	mov	eax, 16					; 00000010H

; 997  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ ENDP ; CvAIOperationNavalCityStateAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@ ; `string'
;	COMDAT ??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@ DB 'AI_OPERATION_CIT'
	DB	'Y_STATE_NAVAL_ATTACK', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250665 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalCityStateAttack::GetOperationName, COMDAT
; _this$ = ecx

; 999  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250665[ebp], 0

; 1000 : 		return CvString("AI_OPERATION_CITY_STATE_NAVAL_ATTACK");

	mov	eax, OFFSET ??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@
	test	eax, eax
	je	SHORT $LN7@GetOperati@25
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@
	jmp	SHORT $LN8@GetOperati@25
$LN7@GetOperati@25:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@25:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250665[ebp]
	or	edx, 1
	mov	DWORD PTR $T250665[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1001 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalCityStateAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalCityStateAttack::GetFormation, COMDAT
; _this$ = ecx

; 1003 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1004 : 		return MUFORMATION_CITY_STATE_INVASION;

	mov	eax, 13					; 0000000dH

; 1005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalCityStateAttack::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ PROC	; CvAIOperationNukeAttack::GetOperationType, COMDAT
; _this$ = ecx

; 1024 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1025 : 		return AI_OPERATION_NUKE_ATTACK;

	mov	eax, 17					; 00000011H

; 1026 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ ENDP	; CvAIOperationNukeAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@ DB 'AI_OPERATION_NUKE_AT'
	DB	'TACK', 00H					; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T250682 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNukeAttack::GetOperationName, COMDAT
; _this$ = ecx

; 1028 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T250682[ebp], 0

; 1029 : 		return CvString("AI_OPERATION_NUKE_ATTACK");

	mov	eax, OFFSET ??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@
	test	eax, eax
	je	SHORT $LN7@GetOperati@26
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@
	jmp	SHORT $LN8@GetOperati@26
$LN7@GetOperati@26:
	mov	DWORD PTR tv79[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@GetOperati@26:
	mov	ecx, DWORD PTR tv79[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T250682[ebp]
	or	edx, 1
	mov	DWORD PTR $T250682[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1030 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNukeAttack::GetOperationName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ PROC ; CvAIOperationNukeAttack::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 1032 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1033 : 		return false;

	xor	al, al

; 1034 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ ENDP ; CvAIOperationNukeAttack::NeedToCheckPathToTarget
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNukeAttack::GetFormation, COMDAT
; _this$ = ecx

; 1036 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1037 : 		return MUFORMATION_NUKE_ATTACK;

	mov	eax, 14					; 0000000eH

; 1038 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNukeAttack::GetFormation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ PROC	; CvAIOperationNukeAttack::GetDeployRange, COMDAT
; _this$ = ecx

; 1040 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1041 : 		return 10;

	mov	eax, 10					; 0000000aH

; 1042 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ ENDP	; CvAIOperationNukeAttack::GetDeployRange
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T250703 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250703[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T250703[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T250709 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250709[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T250709[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T250721 = -8						; size = 4
$T250717 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T250717[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T250717[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T250721[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T250721[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T250912 = -148						; size = 4
$T250892 = -144						; size = 4
$T250877 = -140						; size = 4
$T250860 = -136						; size = 4
$T250847 = -132						; size = 4
$T250833 = -128						; size = 4
$T250789 = -45						; size = 1
$T250788 = -44						; size = 4
$T250787 = -37						; size = 1
$T250786 = -36						; size = 4
$T250785 = -29						; size = 1
$T250784 = -28						; size = 4
$T250783 = -24						; size = 4
$T250782 = -17						; size = 1
__Where$198767 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@2:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN9@insert@2

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@2
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@2
$LN33@insert@2:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@2:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@2
$LN9@insert@2:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@2

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T250782[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T250783[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T250833[ebp], eax
	mov	edx, DWORD PTR $T250833[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T250782[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@2

; 644  : 		else

	jmp	$LN11@insert@2
$LN8@insert@2:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$198767[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@2
	jmp	$LN79@insert@2
$LN6@insert@2:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250847[ebp], ecx
	mov	edx, DWORD PTR $T250847[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T250860[ebp], eax
	mov	ecx, DWORD PTR $T250860[ebp]
	mov	DWORD PTR $T250784[ebp], ecx
	mov	edx, DWORD PTR __Where$198767[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T250784[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@2

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T250785[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T250786[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T250877[ebp], eax
	mov	edx, DWORD PTR $T250877[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T250785[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@2

; 651  : 			else

	jmp	SHORT $LN79@insert@2
$LN4@insert@2:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$198767[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@2:
	mov	ecx, DWORD PTR __Where$198767[ebp]
	mov	DWORD PTR $T250892[ebp], ecx
	mov	edx, DWORD PTR $T250892[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@2

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T250787[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T250788[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T250912[ebp], eax
	mov	edx, DWORD PTR $T250912[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T250787[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@2

; 657  : 			else

	jmp	SHORT $LN11@insert@2
$LN2@insert@2:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T250789[ebp], 0
	mov	ecx, DWORD PTR __Where$198767[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T250789[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@2:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$250938 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$250938[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$250938[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$250938[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T251002 = -28						; size = 4
$T251001 = -24						; size = 4
$T250997 = -20						; size = 4
$T250996 = -16						; size = 4
$T250985 = -12						; size = 4
$T250984 = -8						; size = 4
__Cat$250991 = -2					; size = 1
$T250988 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T250997[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T250996[ebp], ecx
	mov	edx, DWORD PTR $T250997[ebp]
	mov	DWORD PTR $T250985[ebp], edx
	mov	eax, DWORD PTR $T250996[ebp]
	mov	DWORD PTR $T250984[ebp], eax
	mov	cl, BYTE PTR __Cat$250991[ebp]
	mov	BYTE PTR $T250988[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T251002[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T251001[ebp], eax
	mov	ecx, DWORD PTR $T251001[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T251539 = -188						; size = 4
$T251451 = -172						; size = 4
$T251366 = -160						; size = 4
$T251350 = -156						; size = 4
$T251331 = -152						; size = 4
$T251327 = -148						; size = 4
$T251242 = -136						; size = 4
$T251141 = -120						; size = 4
$T251119 = -116						; size = 4
$T251112 = -112						; size = 4
$T251108 = -108						; size = 4
$T251069 = -104						; size = 4
$T251060 = -100						; size = 4
$T251040 = -96						; size = 4
__Count$251022 = -92					; size = 4
$T251006 = -88						; size = 28
$T251005 = -60						; size = 40
__Pnode$201484 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$251022[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$251022[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$251022[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T251006[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T251006[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251005[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T251005[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T251005[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T251006[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T251040[ebp], edx
	mov	eax, DWORD PTR $T251040[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T251060[ebp], eax
	mov	ecx, DWORD PTR $T251060[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T251069[ebp], ecx
	mov	edx, DWORD PTR $T251069[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$201484[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+16]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T251108[ebp], edx
	mov	eax, DWORD PTR $T251108[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T251112[ebp], ecx
	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR $T251112[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T251119[ebp], eax
	mov	ecx, DWORD PTR $T251119[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T251141[ebp], ecx
	mov	edx, DWORD PTR $T251141[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$201484[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$201484[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T251242[ebp], ecx
	mov	edx, DWORD PTR $T251242[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T251327[ebp], edx
	mov	eax, DWORD PTR $T251327[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T251331[ebp], ecx
	mov	edx, DWORD PTR $T251331[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T251350[ebp], ecx
	mov	edx, DWORD PTR $T251350[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T251366[ebp], edx
	mov	eax, DWORD PTR $T251366[ebp]
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+16], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T251451[ebp], edx
	mov	eax, DWORD PTR $T251451[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T251539[ebp], eax
	mov	ecx, DWORD PTR $T251539[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+16], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T251006[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ PROC	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ENDP	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$201536 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z PROC ; BaseVector<CvAStarNode *,1>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	xor	eax, eax
	je	SHORT $LN5@Destroy

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$201536[ebp], 0
	jmp	SHORT $LN3@Destroy
$LN2@Destroy:
	mov	ecx, DWORD PTR _i$201536[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$201536[ebp], ecx
$LN3@Destroy:
	mov	edx, DWORD PTR _i$201536[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy

; 223  : 				pVal[i].~T();
; 224  : 			}

	jmp	SHORT $LN2@Destroy
$LN5@Destroy:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z ENDP ; BaseVector<CvAStarNode *,1>::Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T251588 = -80						; size = 28
$T251587 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T251588[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T251587[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T251587[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T251588[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251587[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T251587[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T251587[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T251588[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T251588[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T251587[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T251665 = -12						; size = 4
$T251658 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T251658[ebp], eax
	mov	ecx, DWORD PTR $T251658[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T251665[ebp], ecx
	mov	edx, DWORD PTR $T251665[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T251741 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T251741[ebp], eax
	mov	ecx, DWORD PTR $T251741[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T251751 = -28						; size = 4
$T251750 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T251751[ebp], eax
	cmp	DWORD PTR $T251751[ebp], 0
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR $T251751[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T251751[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T251751[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T251751[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T251751[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+16], dl
	mov	eax, DWORD PTR $T251751[ebp]
	mov	BYTE PTR [eax+17], 0
	mov	ecx, DWORD PTR $T251751[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN5@Buynode
$LN4@Buynode:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T251750[ebp], edx
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T251828 = -16						; size = 4
$T251807 = -12						; size = 4
$T251800 = -8						; size = 4
__Pnode$202260 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T251800[ebp], edx
	mov	eax, DWORD PTR $T251800[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T251807[ebp], ecx
	mov	edx, DWORD PTR $T251807[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T251828[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T251828[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T251828[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T251828[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T251828[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$202260[ebp], ecx
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$202260[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovector.h
_TEXT	ENDS
;	COMDAT ??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z PROC ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[], COMDAT
; _this$ = ecx

; 328  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 	return m_value[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ENDP ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T251852 = -16						; size = 4
$T251848 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T251852[ebp], 0
	lea	eax, DWORD PTR $T251852[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251848[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T251848[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T251848[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T251859 = -16						; size = 4
$T251855 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T251859[ebp], 0
	lea	eax, DWORD PTR $T251859[ebp]
	push	eax
	lea	ecx, DWORD PTR $T251855[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T251855[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T251855[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T251955 = -52						; size = 4
$T251944 = -48						; size = 4
$T251943 = -44						; size = 4
__Cat$251950 = -40					; size = 1
$T251947 = -39						; size = 1
__Ptr$210227 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy<int *,int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$210227[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T251955[ebp], edx
	mov	eax, DWORD PTR $T251955[ebp]
	mov	DWORD PTR $T251944[ebp], eax
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR $T251943[ebp], ecx
	mov	dl, BYTE PTR __Cat$251950[ebp]
	mov	BYTE PTR $T251947[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$210227[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator>><int>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator>><int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T252044 = -72						; size = 8
$T252043 = -64						; size = 4
$T252042 = -60						; size = 4
$T252022 = -56						; size = 4
$T252017 = -52						; size = 4
__ChkFirst$252037 = -48					; size = 4
__ChkLast$252038 = -44					; size = 4
$T251993 = -40						; size = 4
$T251984 = -36						; size = 4
$T251972 = -32						; size = 4
$T251974 = -28						; size = 4
$T251963 = -24						; size = 8
$T251962 = -16						; size = 4
$T251961 = -12						; size = 4
$T251960 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator<<<int>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T251960[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T251960[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T251974[ebp], ecx
	mov	edx, DWORD PTR $T251960[ebp]
	mov	DWORD PTR $T251972[ebp], edx
	lea	eax, DWORD PTR $T251974[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251972[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T251984[ebp], edx
	mov	eax, DWORD PTR $T251984[ebp]
	mov	DWORD PTR $T251961[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T251993[ebp], edx
	mov	eax, DWORD PTR $T251993[ebp]
	mov	DWORD PTR $T251962[ebp], eax
	mov	ecx, DWORD PTR $T251960[ebp]
	mov	DWORD PTR $T252044[ebp], ecx
	mov	edx, DWORD PTR $T251960[ebp+4]
	mov	DWORD PTR $T252044[ebp+4], edx
	mov	eax, DWORD PTR $T251961[ebp]
	mov	DWORD PTR $T252043[ebp], eax
	mov	ecx, DWORD PTR $T251962[ebp]
	mov	DWORD PTR $T252042[ebp], ecx
	mov	edx, DWORD PTR $T252042[ebp]
	mov	DWORD PTR __ChkFirst$252037[ebp], edx
	mov	eax, DWORD PTR $T252043[ebp]
	mov	DWORD PTR __ChkLast$252038[ebp], eax
	jmp	SHORT $LN24@operator@3
$LN18@operator@3:
	mov	ecx, DWORD PTR __ChkFirst$252037[ebp]
	add	ecx, 4
	mov	DWORD PTR __ChkFirst$252037[ebp], ecx
$LN24@operator@3:
	mov	edx, DWORD PTR __ChkFirst$252037[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$252038[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@3
	mov	eax, DWORD PTR __ChkFirst$252037[ebp]
	mov	DWORD PTR $T252022[ebp], eax
	mov	ecx, DWORD PTR $T252044[ebp]
	mov	DWORD PTR $T252017[ebp], ecx
	mov	edx, DWORD PTR $T252022[ebp]
	push	edx
	mov	ecx, DWORD PTR $T252017[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	jmp	SHORT $LN18@operator@3
$LN17@operator@3:
	mov	eax, DWORD PTR $T252044[ebp]
	mov	DWORD PTR $T251963[ebp], eax
	mov	ecx, DWORD PTR $T252044[ebp+4]
	mov	DWORD PTR $T251963[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T252067 = -26						; size = 1
$T252066 = -25						; size = 1
$T252065 = -24						; size = 4
$T252064 = -20						; size = 4
__Off$252060 = -16					; size = 4
__Result$252061 = -12					; size = 4
__Cat$252052 = -4					; size = 1
$T252049 = -3						; size = 1
$T252048 = -2						; size = 1
$T252047 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T252047[ebp], al
	mov	cl, BYTE PTR __Cat$252052[ebp]
	mov	BYTE PTR $T252048[ebp], cl
	mov	dl, BYTE PTR $T252047[ebp]
	mov	BYTE PTR $T252067[ebp], dl
	mov	al, BYTE PTR $T252049[ebp]
	mov	BYTE PTR $T252066[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T252065[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T252064[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T252064[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$252060[ebp], eax
	mov	ecx, DWORD PTR __Off$252060[ebp]
	mov	edx, DWORD PTR $T252065[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$252061[ebp], eax
	cmp	DWORD PTR __Off$252060[ebp], 0
	jle	SHORT $LN8@unchecked_@3
	mov	ecx, DWORD PTR __Off$252060[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T252064[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$252060[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T252065[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@3:
	mov	eax, DWORD PTR __Result$252061[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
_TEXT	ENDS
;	COMDAT ??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T252101 = -40						; size = 4
$T252085 = -36						; size = 4
$T252209 = -32						; size = 4
$T252208 = -28						; size = 4
$T252207 = -24						; size = 4
$T252206 = -20						; size = 4
$T252205 = -16						; size = 4
_v$213750 = -12						; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T252085[ebp], ecx
	mov	edx, DWORD PTR $T252085[ebp]
	mov	DWORD PTR $T252206[ebp], edx
	mov	eax, DWORD PTR $T252206[ebp]
	mov	DWORD PTR $T252205[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T252101[ebp], edx
	mov	eax, DWORD PTR $T252101[ebp]
	mov	DWORD PTR $T252208[ebp], eax
	mov	ecx, DWORD PTR $T252208[ebp]
	mov	DWORD PTR $T252207[ebp], ecx
	mov	edx, DWORD PTR $T252205[ebp]
	push	edx
	mov	eax, DWORD PTR $T252207[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252209[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@2
$LN2@SerializeT@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@2:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@2

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$213750[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	lea	eax, DWORD PTR _v$213750[ebp]
	push	eax
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT@2
$LN4@SerializeT@2:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T252472 = -64						; size = 4
$T252462 = -60						; size = 4
$T252450 = -56						; size = 4
$T252440 = -49						; size = 1
$T252439 = -48						; size = 4
__Cat$252457 = -19					; size = 1
$T252455 = -18						; size = 1
$T252454 = -17						; size = 1
$T252391 = -16						; size = 4
$T252387 = -12						; size = 4
$T252386 = -8						; size = 4
$T252385 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T252391[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@5
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@5
$LN9@push_back@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@5:
	mov	ecx, DWORD PTR $T252391[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T252462[ebp], eax
	mov	ecx, DWORD PTR $T252462[ebp]
	mov	DWORD PTR $T252450[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T252454[ebp], dl
	mov	al, BYTE PTR __Cat$252457[ebp]
	mov	BYTE PTR $T252455[ebp], al
	mov	cl, BYTE PTR $T252454[ebp]
	mov	BYTE PTR $T252440[ebp], cl
	mov	edx, DWORD PTR $T252450[ebp]
	mov	DWORD PTR $T252439[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T252439[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T252462[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@5
$LN2@push_back@5:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T252472[ebp], edx
	mov	eax, DWORD PTR $T252472[ebp]
	mov	DWORD PTR $T252386[ebp], eax
	mov	ecx, DWORD PTR $T252386[ebp]
	mov	DWORD PTR $T252385[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T252385[ebp]
	push	eax
	lea	ecx, DWORD PTR $T252387[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back@5:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$252597 = -24					; size = 4
$T252575 = -20						; size = 4
$T252556 = -16						; size = 4
$T252543 = -12						; size = 4
$T252540 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T252556[ebp], ecx
	mov	edx, DWORD PTR $T252556[ebp]
	mov	DWORD PTR $T252540[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T252540[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T252575[ebp], edx
	mov	eax, DWORD PTR $T252575[ebp]
	mov	DWORD PTR $T252543[ebp], eax
	mov	ecx, DWORD PTR $T252543[ebp]
	mov	DWORD PTR __Tmp$252597[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$252597[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$252597[ebp], ecx
	mov	edx, DWORD PTR __Tmp$252597[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T253151 = -412						; size = 4
$T253099 = -368						; size = 4
$T253087 = -364						; size = 4
$T253077 = -357						; size = 1
$T253076 = -356						; size = 4
__Cat$253094 = -327					; size = 1
$T253091 = -326						; size = 1
$T253090 = -325						; size = 1
$T253048 = -324						; size = 4
$T253040 = -320						; size = 4
$T253032 = -316						; size = 4
$T253021 = -312						; size = 4
$T253020 = -308						; size = 4
__Cat$253027 = -302					; size = 1
$T253024 = -301						; size = 1
$T252949 = -276						; size = 4
$T252930 = -272						; size = 4
$T252913 = -265						; size = 1
$T252912 = -264						; size = 4
$T252902 = -260						; size = 4
$T252901 = -256						; size = 4
__Cat$252931 = -250					; size = 1
$T252947 = -249						; size = 1
$T252946 = -248						; size = 1
__Cat$252940 = -247					; size = 1
$T252938 = -246						; size = 1
$T252937 = -245						; size = 1
$T252877 = -244						; size = 4
$T252876 = -240						; size = 4
$T252872 = -236						; size = 4
$T252871 = -232						; size = 4
$T252860 = -228						; size = 4
$T252859 = -224						; size = 4
__Cat$252867 = -218					; size = 1
$T252865 = -217						; size = 1
$T252824 = -216						; size = 4
$T252823 = -212						; size = 4
__Cat$252831 = -206					; size = 1
$T252829 = -205						; size = 1
$T252794 = -204						; size = 4
$T252793 = -200						; size = 4
__Cat$252801 = -194					; size = 1
$T252799 = -193						; size = 1
$T252774 = -192						; size = 4
$T252762 = -188						; size = 4
$T252752 = -181						; size = 1
$T252751 = -180						; size = 4
__Cat$252770 = -175					; size = 1
$T252767 = -174						; size = 1
$T252766 = -173						; size = 1
$T252739 = -172						; size = 4
$T252727 = -168						; size = 4
$T252717 = -161						; size = 1
$T252716 = -160						; size = 4
__Cat$252735 = -155					; size = 1
$T252732 = -154						; size = 1
$T252731 = -153						; size = 1
$T252704 = -152						; size = 4
$T252692 = -148						; size = 4
$T252682 = -141						; size = 1
$T252681 = -140						; size = 4
__Cat$252700 = -135					; size = 1
$T252698 = -134						; size = 1
$T252697 = -133						; size = 1
__Count$252655 = -120					; size = 4
__Count$252629 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$252629[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$252629[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$252629[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$252655[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$252655[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$252655[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T252704[ebp], edx
	mov	eax, DWORD PTR $T252704[ebp]
	mov	DWORD PTR $T252692[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T252697[ebp], cl
	mov	dl, BYTE PTR __Cat$252700[ebp]
	mov	BYTE PTR $T252698[ebp], dl
	mov	al, BYTE PTR $T252697[ebp]
	mov	BYTE PTR $T252682[ebp], al
	mov	ecx, DWORD PTR $T252692[ebp]
	mov	DWORD PTR $T252681[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252681[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T252739[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T252727[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T252731[ebp], al
	mov	cl, BYTE PTR __Cat$252735[ebp]
	mov	BYTE PTR $T252732[ebp], cl
	mov	dl, BYTE PTR $T252731[ebp]
	mov	BYTE PTR $T252717[ebp], dl
	mov	eax, DWORD PTR $T252727[ebp]
	mov	DWORD PTR $T252716[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252716[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252739[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T252774[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T252762[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T252766[ebp], dl
	mov	al, BYTE PTR __Cat$252770[ebp]
	mov	BYTE PTR $T252767[ebp], al
	mov	cl, BYTE PTR $T252766[ebp]
	mov	BYTE PTR $T252752[ebp], cl
	mov	edx, DWORD PTR $T252762[ebp]
	mov	DWORD PTR $T252751[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252751[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252774[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T252794[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T252793[ebp], ecx
	mov	dl, BYTE PTR __Cat$252801[ebp]
	mov	BYTE PTR $T252799[ebp], dl
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T252824[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T252823[ebp], ecx
	mov	dl, BYTE PTR __Cat$252831[ebp]
	mov	BYTE PTR $T252829[ebp], dl
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T252872[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T252871[ebp], edx
	mov	eax, DWORD PTR $T252872[ebp]
	mov	DWORD PTR $T252860[ebp], eax
	mov	ecx, DWORD PTR $T252871[ebp]
	mov	DWORD PTR $T252859[ebp], ecx
	mov	dl, BYTE PTR __Cat$252867[ebp]
	mov	BYTE PTR $T252865[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T252877[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T252876[ebp], ecx
	mov	edx, DWORD PTR $T252876[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T252949[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T252930[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T252937[ebp], cl
	mov	dl, BYTE PTR __Cat$252940[ebp]
	mov	BYTE PTR $T252938[ebp], dl
	mov	al, BYTE PTR $T252937[ebp]
	mov	BYTE PTR $T252913[ebp], al
	mov	ecx, DWORD PTR $T252930[ebp]
	mov	DWORD PTR $T252912[ebp], ecx
	mov	edx, DWORD PTR $T252912[ebp]
	mov	DWORD PTR $T252902[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T252901[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T252946[ebp], cl
	mov	dl, BYTE PTR __Cat$252931[ebp]
	mov	BYTE PTR $T252947[ebp], dl
	movzx	eax, BYTE PTR $T252946[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T252947[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T252902[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252949[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252901[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T253032[ebp], eax
	mov	ecx, DWORD PTR $T253032[ebp]
	mov	DWORD PTR $T253021[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T253020[ebp], ecx
	mov	dl, BYTE PTR __Cat$253027[ebp]
	mov	BYTE PTR $T253024[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T253048[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253040[ebp], edx
	jmp	SHORT $LN151@Insert_n@2
$LN150@Insert_n@2:
	mov	eax, DWORD PTR $T253040[ebp]
	add	eax, 4
	mov	DWORD PTR $T253040[ebp], eax
$LN151@Insert_n@2:
	mov	ecx, DWORD PTR $T253040[ebp]
	cmp	ecx, DWORD PTR $T253048[ebp]
	je	SHORT $LN147@Insert_n@2
	mov	edx, DWORD PTR $T253040[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@2
$LN147@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T253099[ebp], eax
	mov	ecx, DWORD PTR $T253099[ebp]
	mov	DWORD PTR $T253087[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T253090[ebp], dl
	mov	al, BYTE PTR __Cat$253094[ebp]
	mov	BYTE PTR $T253091[ebp], al
	mov	cl, BYTE PTR $T253090[ebp]
	mov	BYTE PTR $T253077[ebp], cl
	mov	edx, DWORD PTR $T253087[ebp]
	mov	DWORD PTR $T253076[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253076[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T253151[ebp], ecx
	jmp	SHORT $LN186@Insert_n@2
$LN185@Insert_n@2:
	mov	edx, DWORD PTR $T253151[ebp]
	add	edx, 4
	mov	DWORD PTR $T253151[ebp], edx
$LN186@Insert_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T253151[ebp], edx
	je	SHORT $LN16@Insert_n@2
	mov	eax, DWORD PTR $T253151[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T253222 = -40						; size = 4
$T253212 = -33						; size = 1
$T253211 = -32						; size = 4
__Cat$253217 = -3					; size = 1
$T253215 = -2						; size = 1
$T253214 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T253222[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T253214[ebp], cl
	mov	dl, BYTE PTR __Cat$253217[ebp]
	mov	BYTE PTR $T253215[ebp], dl
	mov	al, BYTE PTR $T253214[ebp]
	mov	BYTE PTR $T253212[ebp], al
	mov	ecx, DWORD PTR $T253222[ebp]
	mov	DWORD PTR $T253211[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253211[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T253267 = -38						; size = 1
$T253266 = -37						; size = 1
$T253265 = -36						; size = 4
$T253264 = -32						; size = 4
$T253251 = -25						; size = 1
$T253250 = -24						; size = 4
$T253249 = -20						; size = 4
__Off$253260 = -16					; size = 4
__Result$253261 = -12					; size = 4
__Cat$253256 = -8					; size = 1
$T253254 = -7						; size = 1
$T253253 = -6						; size = 1
__Cat$253231 = -4					; size = 1
$T253227 = -3						; size = 1
$T253226 = -2						; size = 1
$T253225 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T253225[ebp], al
	mov	cl, BYTE PTR __Cat$253231[ebp]
	mov	BYTE PTR $T253226[ebp], cl
	mov	dl, BYTE PTR $T253225[ebp]
	mov	BYTE PTR $T253267[ebp], dl
	mov	al, BYTE PTR $T253227[ebp]
	mov	BYTE PTR $T253266[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T253265[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T253264[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T253253[ebp], al
	mov	cl, BYTE PTR __Cat$253256[ebp]
	mov	BYTE PTR $T253254[ebp], cl
	mov	dl, BYTE PTR $T253253[ebp]
	mov	BYTE PTR $T253251[ebp], dl
	mov	eax, DWORD PTR $T253265[ebp]
	mov	DWORD PTR $T253250[ebp], eax
	mov	ecx, DWORD PTR $T253264[ebp]
	mov	DWORD PTR $T253249[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T253249[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$253260[ebp], edx
	mov	eax, DWORD PTR __Off$253260[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T253250[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$253261[ebp], ecx
	cmp	DWORD PTR __Off$253260[ebp], 0
	jle	SHORT $LN7@Unchecked_@2
	mov	edx, DWORD PTR __Off$253260[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T253249[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$253260[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$253261[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@2:
	mov	eax, DWORD PTR __Result$253261[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T253297 = -22						; size = 1
$T253296 = -21						; size = 1
$T253295 = -20						; size = 4
$T253286 = -13						; size = 1
$T253285 = -12						; size = 4
$T253284 = -8						; size = 4
$T253288 = -4						; size = 1
$T253271 = -2						; size = 1
$T253270 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T253270[ebp], al
	mov	cl, BYTE PTR $T253270[ebp]
	mov	BYTE PTR $T253297[ebp], cl
	mov	dl, BYTE PTR $T253271[ebp]
	mov	BYTE PTR $T253296[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T253295[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T253288[ebp], cl
	mov	dl, BYTE PTR $T253288[ebp]
	mov	BYTE PTR $T253286[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T253285[ebp], eax
	mov	ecx, DWORD PTR $T253295[ebp]
	mov	DWORD PTR $T253284[ebp], ecx
	jmp	SHORT $LN9@unchecked_@4
$LN8@unchecked_@4:
	mov	edx, DWORD PTR $T253285[ebp]
	sub	edx, 1
	mov	DWORD PTR $T253285[ebp], edx
	mov	eax, DWORD PTR $T253284[ebp]
	add	eax, 4
	mov	DWORD PTR $T253284[ebp], eax
$LN9@unchecked_@4:
	cmp	DWORD PTR $T253285[ebp], 0
	jbe	SHORT $LN1@unchecked_@4
	mov	ecx, DWORD PTR $T253284[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@4
$LN1@unchecked_@4:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T253314 = -21						; size = 1
$T253313 = -20						; size = 4
$T253312 = -16						; size = 4
__Result$253310 = -12					; size = 4
__Count$253309 = -8					; size = 4
__Cat$253304 = -3					; size = 1
$T253301 = -2						; size = 1
$T253300 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T253300[ebp], al
	mov	cl, BYTE PTR __Cat$253304[ebp]
	mov	BYTE PTR $T253301[ebp], cl
	mov	dl, BYTE PTR $T253300[ebp]
	mov	BYTE PTR $T253314[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T253313[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T253312[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T253312[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$253309[ebp], edx
	mov	eax, DWORD PTR __Count$253309[ebp]
	mov	ecx, DWORD PTR $T253313[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$253310[ebp], edx
	cmp	DWORD PTR __Count$253309[ebp], 0
	jbe	SHORT $LN6@unchecked_@5
	mov	eax, DWORD PTR __Count$253309[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T253312[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$253309[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T253313[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@5:
	mov	eax, DWORD PTR __Result$253310[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
END
