; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvAStar.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??0CvAStar@@QAE@XZ				; CvAStar::CvAStar
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ??0CvAStar@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvAStar@@QAE@XZ PROC					; CvAStar::CvAStar, COMDAT
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 	udIsPathDest = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 105  : 	udDestValid = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 106  : 	udHeuristic = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 107  : 	udCost = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 108  : 	udValid = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 109  : 	udNotifyChild = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 110  : 	udNotifyList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 111  : 	udNumExtraChildrenFunc = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 112  : 	udGetExtraChildFunc = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 113  : 	udInitializeFunc = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 114  : 	udUninitializeFunc = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 115  : 
; 116  : 	m_pData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 117  : 
; 118  : 	m_pOpen = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 119  : 	m_pOpenTail = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 120  : 	m_pClosed = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0

; 121  : 	m_pBest = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 0

; 122  : 	m_pStackHead = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 123  : 
; 124  : 	m_ppaaNodes = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0

; 125  : 
; 126  : 	m_bIsMPCacheSafe = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+79], 0

; 127  : 	m_bDataChangeInvalidatesCache = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+80], 0

; 128  : #ifdef AUI_WARNING_FIXES
; 129  : #ifdef AUI_ASTAR_TURN_LIMITER
; 130  : 	m_iMaxTurns = 0;
; 131  : #endif
; 132  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 133  : 	m_bIsMultiplayer = false;
; 134  : #endif
; 135  : #endif
; 136  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAStar@@QAE@XZ ENDP					; CvAStar::CvAStar
_TEXT	ENDS
PUBLIC	?DeInit@CvAStar@@QAEXXZ				; CvAStar::DeInit
PUBLIC	??1CvAStar@@QAE@XZ				; CvAStar::~CvAStar
; Function compile flags: /Odtp
;	COMDAT ??1CvAStar@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvAStar@@QAE@XZ PROC					; CvAStar::~CvAStar, COMDAT
; _this$ = ecx

; 141  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 	DeInit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAStar@@QAE@XZ ENDP					; CvAStar::~CvAStar
_TEXT	ENDS
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Odtp
;	COMDAT ?DeInit@CvAStar@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$218927 = -4						; size = 4
?DeInit@CvAStar@@QAEXXZ PROC				; CvAStar::DeInit, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 	if(m_ppaaNodes != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $LN5@DeInit

; 150  : 	{
; 151  : 		for(int iI = 0; iI < m_iColumns; iI++)

	mov	DWORD PTR _iI$218927[ebp], 0
	jmp	SHORT $LN3@DeInit
$LN2@DeInit:
	mov	ecx, DWORD PTR _iI$218927[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$218927[ebp], ecx
$LN3@DeInit:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iI$218927[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jge	SHORT $LN1@DeInit

; 152  : 		{
; 153  : #ifdef AUI_ASTAR_REMOVE_MALLOC
; 154  : 			SAFE_DELETE_ARRAY(m_ppaaNodes[iI]);
; 155  : 		}
; 156  : 
; 157  : 		SAFE_DELETE_ARRAY(m_ppaaNodes);
; 158  : #else
; 159  : 			FFREEALIGNED(m_ppaaNodes[iI]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _iI$218927[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 160  : 		}

	jmp	SHORT $LN2@DeInit
$LN1@DeInit:

; 161  : 
; 162  : 		FFREEALIGNED(m_ppaaNodes);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 163  : 		m_ppaaNodes=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], 0
$LN5@DeInit:

; 164  : #endif
; 165  : 	}
; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeInit@CvAStar@@QAEXXZ ENDP				; CvAStar::DeInit
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0CvAStarNode@@QAE@XZ				; CvAStarNode::CvAStarNode
PUBLIC	??_C@_0M@IAHKHJNC@CvAStar?4cpp?$AA@		; `string'
PUBLIC	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0M@IAHKHJNC@CvAStar?4cpp?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0M@IAHKHJNC@CvAStar?4cpp?$AA@ DB 'CvAStar.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z$0
__ehfuncinfo$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
_TEXT	SEGMENT
tv166 = -44						; size = 4
_this$ = -40						; size = 4
$T221331 = -28						; size = 4
$T221330 = -24						; size = 4
_iJ$ = -20						; size = 4
_iI$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iColumns$ = 8						; size = 4
_iRows$ = 12						; size = 4
_bWrapX$ = 16						; size = 1
_bWrapY$ = 20						; size = 1
_IsPathDestFunc$ = 24					; size = 4
_DestValidFunc$ = 28					; size = 4
_HeuristicFunc$ = 32					; size = 4
_CostFunc$ = 36						; size = 4
_ValidFunc$ = 40					; size = 4
_NotifyChildFunc$ = 44					; size = 4
_NotifyListFunc$ = 48					; size = 4
_NumExtraChildrenFunc$ = 52				; size = 4
_GetExtraChildFunc$ = 56				; size = 4
_InitializeFunc$ = 60					; size = 4
_UninitializeFunc$ = 64					; size = 4
_pData$ = 68						; size = 4
?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z PROC ; CvAStar::Initialize, COMDAT
; _this$ = ecx

; 171  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 	int iI, iJ;
; 173  : 
; 174  : 	DeInit();	// free old memory just in case

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 175  : 
; 176  : 	udIsPathDest = IsPathDestFunc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _IsPathDestFunc$[ebp]
	mov	DWORD PTR [eax], ecx

; 177  : 	udDestValid = DestValidFunc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _DestValidFunc$[ebp]
	mov	DWORD PTR [edx+4], eax

; 178  : 	udHeuristic = HeuristicFunc;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _HeuristicFunc$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 179  : 	udCost = CostFunc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _CostFunc$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 180  : 	udValid = ValidFunc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ValidFunc$[ebp]
	mov	DWORD PTR [edx+16], eax

; 181  : 	udNotifyChild = NotifyChildFunc;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _NotifyChildFunc$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 182  : 	udNotifyList = NotifyListFunc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _NotifyListFunc$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 183  : 	udNumExtraChildrenFunc = NumExtraChildrenFunc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _NumExtraChildrenFunc$[ebp]
	mov	DWORD PTR [edx+28], eax

; 184  : 	udGetExtraChildFunc = GetExtraChildFunc;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _GetExtraChildFunc$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 185  : 	udInitializeFunc = InitializeFunc;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _InitializeFunc$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 186  : 	udUninitializeFunc = UninitializeFunc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _UninitializeFunc$[ebp]
	mov	DWORD PTR [edx+40], eax

; 187  : 
; 188  : 	m_pData = pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 189  : 
; 190  : 	m_iColumns = iColumns;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iColumns$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 191  : 	m_iRows = iRows;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iRows$[ebp]
	mov	DWORD PTR [edx+52], eax

; 192  : 
; 193  : 	m_iXstart = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], -1

; 194  : 	m_iYstart = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], -1

; 195  : 	m_iXdest = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], -1

; 196  : 	m_iYdest = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], -1

; 197  : 	m_iInfo = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], 0

; 198  : 
; 199  : 	m_bWrapX = bWrapX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bWrapX$[ebp]
	mov	BYTE PTR [eax+76], cl

; 200  : 	m_bWrapY = bWrapY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bWrapY$[ebp]
	mov	BYTE PTR [edx+77], al

; 201  : 	m_bForceReset = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+78], 0

; 202  : 
; 203  : 	m_pOpen = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 0

; 204  : 	m_pOpenTail = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0

; 205  : 	m_pClosed = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 206  : 	m_pBest = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0

; 207  : 	m_pStackHead = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 208  : 
; 209  : #ifdef AUI_ASTAR_REMOVE_MALLOC
; 210  : 	m_ppaaNodes = FNEW(CvAStarNode*[m_iColumns], c_eCiv5GameplayDLL, 0);
; 211  : #else
; 212  : 	m_ppaaNodes = reinterpret_cast<CvAStarNode**>(FMALLOCALIGNED(sizeof(CvAStarNode*)*m_iColumns, 64, c_eCiv5GameplayDLL, 0));

	push	212					; 000000d4H
	push	OFFSET ??_C@_0M@IAHKHJNC@CvAStar?4cpp?$AA@
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 213  : #endif
; 214  : 	for(iI = 0; iI < m_iColumns; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@Initialize
$LN5@Initialize:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN6@Initialize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	$LN7@Initialize

; 215  : 	{
; 216  : #ifdef AUI_ASTAR_REMOVE_MALLOC
; 217  : 		m_ppaaNodes[iI] = FNEW(CvAStarNode[m_iRows], c_eCiv5GameplayDLL, 0);
; 218  : #else
; 219  : 		m_ppaaNodes[iI] = reinterpret_cast<CvAStarNode*>(FMALLOCALIGNED(sizeof(CvAStarNode)*m_iRows, 64, c_eCiv5GameplayDLL, 0));

	push	219					; 000000dbH
	push	OFFSET ??_C@_0M@IAHKHJNC@CvAStar?4cpp?$AA@
	push	64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	imul	eax, 96					; 00000060H
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 220  : #endif
; 221  : 		for(iJ = 0; iJ < m_iRows; iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	edx, DWORD PTR _iJ$[ebp]
	add	edx, 1
	mov	DWORD PTR _iJ$[ebp], edx
$LN3@Initialize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iJ$[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jge	SHORT $LN1@Initialize

; 222  : 		{
; 223  : #ifndef AUI_ASTAR_REMOVE_MALLOC
; 224  : 			new(&m_ppaaNodes[iI][iJ]) CvAStarNode();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _iJ$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _iI$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221331[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T221331[ebp], 0
	je	SHORT $LN9@Initialize
	mov	ecx, DWORD PTR $T221331[ebp]
	call	??0CvAStarNode@@QAE@XZ			; CvAStarNode::CvAStarNode
	mov	DWORD PTR tv166[ebp], eax
	jmp	SHORT $LN10@Initialize
$LN9@Initialize:
	mov	DWORD PTR tv166[ebp], 0
$LN10@Initialize:
	mov	eax, DWORD PTR tv166[ebp]
	mov	DWORD PTR $T221330[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 225  : #endif
; 226  : 			m_ppaaNodes[iI][iJ].m_iX = iI;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _iJ$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	cx, WORD PTR _iI$[ebp]
	mov	WORD PTR [edx+eax+80], cx

; 227  : 			m_ppaaNodes[iI][iJ].m_iY = iJ;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _iJ$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	dx, WORD PTR _iJ$[ebp]
	mov	WORD PTR [eax+ecx+82], dx

; 228  : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 229  : 			m_ppaaNodes[iI][iJ].m_pPlot = GC.getMap().plot(iI, iJ);
; 230  : #endif
; 231  : 		}

	jmp	$LN2@Initialize
$LN1@Initialize:

; 232  : 	}

	jmp	$LN5@Initialize
$LN7@Initialize:

; 233  : 
; 234  : #ifdef AUI_ASTAR_PRECALCULATE_NEIGHBORS_ON_INITIALIZE
; 235  : 	for (iI = 0; iI < m_iColumns; iI++)
; 236  : 		for (iJ = 0; iJ < m_iRows; iJ++)
; 237  : 			PrecalcNeighbors(&(m_ppaaNodes[iI][iJ]));
; 238  : #endif
; 239  : 
; 240  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 241  : 	m_bIsMultiplayer = GC.getGame().isNetworkMultiPlayer();
; 242  : #endif
; 243  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z$0:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _iJ$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _iI$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR $T221331[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ENDP ; CvAStar::Initialize
PUBLIC	?Step@CvAStar@@IAEHXZ				; CvAStar::Step
PUBLIC	?clear@CvAStarNode@@QAEXXZ			; CvAStarNode::clear
PUBLIC	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z		; CvAStar::GeneratePath
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z
_TEXT	SEGMENT
tv316 = -116						; size = 4
tv311 = -112						; size = 4
tv309 = -108						; size = 4
tv190 = -104						; size = 4
tv182 = -100						; size = 4
tv155 = -96						; size = 4
tv147 = -92						; size = 4
tv73 = -88						; size = 4
_this$ = -84						; size = 4
$T221455 = -77						; size = 1
$T221454 = -76						; size = 4
$T221453 = -72						; size = 4
$T221445 = -68						; size = 4
$T221444 = -64						; size = 4
$T221436 = -60						; size = 4
$T221435 = -56						; size = 4
$T221427 = -52						; size = 4
$T221426 = -48						; size = 4
$T221425 = -44						; size = 4
$T221377 = -21						; size = 1
_game$ = -20						; size = 4
_discardCacheForMPGame$ = -13				; size = 1
_temp$ = -12						; size = 4
_retval$ = -8						; size = 4
_isMultiplayer$ = -1					; size = 1
_iXstart$ = 8						; size = 4
_iYstart$ = 12						; size = 4
_iXdest$ = 16						; size = 4
_iYdest$ = 20						; size = 4
_iInfo$ = 24						; size = 4
_bReuse$ = 28						; size = 1
?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z PROC		; CvAStar::GeneratePath, COMDAT
; _this$ = ecx

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 249  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 250  : 	bool discardCacheForMPGame = m_bIsMultiplayer && !m_bIsMPCacheSafe;
; 251  : #else
; 252  : 	CvAStarNode* temp;
; 253  : 	int retval;
; 254  : 
; 255  : 	const CvGame& game = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _game$[ebp], eax

; 256  : 	bool isMultiplayer = game.isNetworkMultiPlayer();

	mov	ecx, DWORD PTR _game$[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	mov	BYTE PTR _isMultiplayer$[ebp], al

; 257  : 	bool discardCacheForMPGame = isMultiplayer && !m_bIsMPCacheSafe;

	movzx	ecx, BYTE PTR _isMultiplayer$[ebp]
	test	ecx, ecx
	je	SHORT $LN28@GeneratePa
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+79]
	test	eax, eax
	jne	SHORT $LN28@GeneratePa
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN29@GeneratePa
$LN28@GeneratePa:
	mov	DWORD PTR tv73[ebp], 0
$LN29@GeneratePa:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR _discardCacheForMPGame$[ebp], cl

; 258  : #endif
; 259  : 
; 260  : 	if(m_bForceReset || (m_iXstart != iXstart) || (m_iYstart != iYstart) || (m_iInfo != iInfo) || discardCacheForMPGame)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+78]
	test	eax, eax
	jne	SHORT $LN24@GeneratePa
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	cmp	edx, DWORD PTR _iXstart$[ebp]
	jne	SHORT $LN24@GeneratePa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	cmp	ecx, DWORD PTR _iYstart$[ebp]
	jne	SHORT $LN24@GeneratePa
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	cmp	eax, DWORD PTR _iInfo$[ebp]
	jne	SHORT $LN24@GeneratePa
	movzx	ecx, BYTE PTR _discardCacheForMPGame$[ebp]
	test	ecx, ecx
	je	SHORT $LN25@GeneratePa
$LN24@GeneratePa:

; 261  : 		bReuse = false;

	mov	BYTE PTR _bReuse$[ebp], 0
$LN25@GeneratePa:

; 262  : 
; 263  : 	m_iXdest = iXdest;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iXdest$[ebp]
	mov	DWORD PTR [edx+64], eax

; 264  : 	m_iYdest = iYdest;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iYdest$[ebp]
	mov	DWORD PTR [ecx+68], edx

; 265  : 	m_iXstart = iXstart;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iXstart$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 266  : 	m_iYstart = iYstart;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iYstart$[ebp]
	mov	DWORD PTR [edx+60], eax

; 267  : 	m_iInfo = iInfo;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iInfo$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 268  : 
; 269  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 270  : 	if (udInitializeFunc)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN23@GeneratePa

; 271  : 		udInitializeFunc(m_pData, this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	add	esp, 8
$LN23@GeneratePa:

; 272  : #endif
; 273  : 
; 274  : 	if(!isValid(iXstart, iYstart))

	cmp	DWORD PTR _iXstart$[ebp], 0
	jl	SHORT $LN34@GeneratePa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iXstart$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jl	SHORT $LN35@GeneratePa
$LN34@GeneratePa:
	mov	BYTE PTR $T221377[ebp], 0
	jmp	SHORT $LN36@GeneratePa
$LN35@GeneratePa:
	cmp	DWORD PTR _iYstart$[ebp], 0
	jl	SHORT $LN32@GeneratePa
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iYstart$[ebp]
	cmp	eax, DWORD PTR [edx+52]
	jl	SHORT $LN33@GeneratePa
$LN32@GeneratePa:
	mov	BYTE PTR $T221377[ebp], 0
	jmp	SHORT $LN36@GeneratePa
$LN33@GeneratePa:
	mov	BYTE PTR $T221377[ebp], 1
$LN36@GeneratePa:
	movzx	ecx, BYTE PTR $T221377[ebp]
	test	ecx, ecx
	jne	SHORT $LN22@GeneratePa

; 275  : 	{
; 276  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 277  : 		if (udUninitializeFunc)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN21@GeneratePa

; 278  : 			udUninitializeFunc(m_pData, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	ecx
	add	esp, 8
$LN21@GeneratePa:

; 279  : #endif
; 280  : 		return false;

	xor	al, al
	jmp	$LN26@GeneratePa
$LN22@GeneratePa:

; 281  : 	}
; 282  : 
; 283  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 284  : 	if (udInitializeFunc)
; 285  : 		udInitializeFunc(m_pData, this);
; 286  : 
; 287  : 	CvAStarNode* temp;
; 288  : #else
; 289  : 	PREFETCH_FASTAR_NODE(&(m_ppaaNodes[iXdest][iYdest]));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _iYdest$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _iXdest$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv147[ebp], ecx
	mov	eax, DWORD PTR tv147[ebp]
	prefetcht0 BYTE PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _iYdest$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _iXdest$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	eax, DWORD PTR [edx+eax+64]
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR tv155[ebp]
	prefetcht0 BYTE PTR [ecx]

; 290  : #endif
; 291  : 
; 292  : 	if(!bReuse)

	movzx	edx, BYTE PTR _bReuse$[ebp]
	test	edx, edx
	jne	$LN20@GeneratePa

; 293  : 	{
; 294  : 		// XXX should we just be doing a memset here?
; 295  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 296  : 		for (int iI = 0; iI < m_iColumns; iI++)
; 297  : 			for (int iJ = 0; iJ < m_iRows; iJ++)
; 298  : 				m_ppaaNodes[iI][iJ].clear();
; 299  : 		m_pClosed = NULL;
; 300  : #else
; 301  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 302  : 		if(m_pOpen)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN19@GeneratePa
$LN18@GeneratePa:

; 303  : #endif
; 304  : 		{
; 305  : 			while(m_pOpen)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	je	SHORT $LN19@GeneratePa

; 306  : 			{
; 307  : 				temp = m_pOpen->m_pNext;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _temp$[ebp], ecx

; 308  : 				m_pOpen->clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+84]
	call	?clear@CvAStarNode@@QAEXXZ		; CvAStarNode::clear

; 309  : 				m_pOpen = temp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 310  : 			}

	jmp	SHORT $LN18@GeneratePa
$LN19@GeneratePa:

; 311  : 		}
; 312  : 
; 313  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 314  : 		if(m_pClosed)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN16@GeneratePa
$LN15@GeneratePa:

; 315  : #endif
; 316  : 		{
; 317  : 			while(m_pClosed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN16@GeneratePa

; 318  : 			{
; 319  : 				temp = m_pClosed->m_pNext;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _temp$[ebp], eax

; 320  : 				m_pClosed->clear();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+92]
	call	?clear@CvAStarNode@@QAEXXZ		; CvAStarNode::clear

; 321  : 				m_pClosed = temp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [edx+92], eax

; 322  : 			}

	jmp	SHORT $LN15@GeneratePa
$LN16@GeneratePa:

; 323  : 		}
; 324  : 
; 325  : 		PREFETCH_FASTAR_NODE(&(m_ppaaNodes[iXstart][iYstart]));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _iYstart$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _iXstart$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv182[ebp], eax
	mov	edx, DWORD PTR tv182[ebp]
	prefetcht0 BYTE PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _iYstart$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _iXstart$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx+64]
	mov	DWORD PTR tv190[ebp], edx
	mov	eax, DWORD PTR tv190[ebp]
	prefetcht0 BYTE PTR [eax]

; 326  : #endif
; 327  : 
; 328  : 		m_pBest = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 329  : 		m_pStackHead = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0

; 330  : 
; 331  : 		m_bForceReset = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+78], 0

; 332  : 
; 333  : 		temp = &(m_ppaaNodes[iXstart][iYstart]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _iYstart$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _iXstart$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _temp$[ebp], eax

; 334  : 
; 335  : #ifdef AUI_ASTAR_FIX_POSSIBLE_NULL_POINTERS
; 336  : 		temp->clear();
; 337  : #else
; 338  : 		temp->m_iKnownCost = 0;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [edx+4], 0

; 339  : #endif
; 340  : 		if(udHeuristic == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN13@GeneratePa

; 341  : 		{
; 342  : 			temp->m_iHeuristicCost = 0;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 343  : 		}
; 344  : 		else

	jmp	SHORT $LN12@GeneratePa
$LN13@GeneratePa:

; 345  : 		{
; 346  : 			temp->m_iHeuristicCost = udHeuristic(m_iXstart, m_iYstart, m_iXdest, m_iYdest);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN12@GeneratePa:

; 347  : 		}
; 348  : 		temp->m_iTotalCost = temp->m_iKnownCost + temp->m_iHeuristicCost;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _temp$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [edx], eax

; 349  : 
; 350  : 		m_pOpen = temp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 351  : 		m_pOpenTail = temp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [edx+88], eax

; 352  : 
; 353  : 		udFunc(udNotifyList, NULL, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221427[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T221426[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T221425[ebp], eax
	cmp	DWORD PTR $T221425[ebp], 0
	je	SHORT $LN60@GeneratePa
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221427[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T221426[ebp]
	push	eax
	push	0
	call	DWORD PTR $T221425[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv309[ebp], eax
	jmp	SHORT $LN58@GeneratePa
$LN60@GeneratePa:
	mov	DWORD PTR tv309[ebp], 1
$LN58@GeneratePa:

; 354  : 		udFunc(udValid, NULL, temp, 0, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221436[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T221435[ebp], ecx
	cmp	DWORD PTR $T221435[ebp], 0
	je	SHORT $LN64@GeneratePa
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221436[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	push	0
	call	DWORD PTR $T221435[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv311[ebp], eax
	jmp	SHORT $LN62@GeneratePa
$LN64@GeneratePa:
	mov	DWORD PTR tv311[ebp], 1
$LN62@GeneratePa:

; 355  : 		udFunc(udNotifyChild, NULL, temp, ASNC_INITIALADD, m_pData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221445[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T221444[ebp], edx
	cmp	DWORD PTR $T221444[ebp], 0
	je	SHORT $LN68@GeneratePa
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221445[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	push	0
	call	DWORD PTR $T221444[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv316[ebp], eax
	jmp	SHORT $LN20@GeneratePa
$LN68@GeneratePa:
	mov	DWORD PTR tv316[ebp], 1
$LN20@GeneratePa:

; 356  : 	}
; 357  : 
; 358  : 	if(udDestValid != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN11@GeneratePa

; 359  : 	{
; 360  : 		if(!udDestValid(iXdest, iYdest, m_pData, this))

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _iYdest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iXdest$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	ecx
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN11@GeneratePa

; 361  : 		{
; 362  : 			if (udUninitializeFunc)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN9@GeneratePa

; 363  : 				udUninitializeFunc(m_pData, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	ecx
	add	esp, 8
$LN9@GeneratePa:

; 364  : 			return false;

	xor	al, al
	jmp	$LN26@GeneratePa
$LN11@GeneratePa:

; 365  : 		}
; 366  : 	}
; 367  : 
; 368  : 	if(isValid(m_iXdest, m_iYdest))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR $T221454[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR $T221453[ebp], edx
	cmp	DWORD PTR $T221453[ebp], 0
	jl	SHORT $LN72@GeneratePa
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T221453[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jl	SHORT $LN73@GeneratePa
$LN72@GeneratePa:
	mov	BYTE PTR $T221455[ebp], 0
	jmp	SHORT $LN74@GeneratePa
$LN73@GeneratePa:
	cmp	DWORD PTR $T221454[ebp], 0
	jl	SHORT $LN70@GeneratePa
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T221454[ebp]
	cmp	eax, DWORD PTR [edx+52]
	jl	SHORT $LN71@GeneratePa
$LN70@GeneratePa:
	mov	BYTE PTR $T221455[ebp], 0
	jmp	SHORT $LN74@GeneratePa
$LN71@GeneratePa:
	mov	BYTE PTR $T221455[ebp], 1
$LN74@GeneratePa:
	movzx	ecx, BYTE PTR $T221455[ebp]
	test	ecx, ecx
	je	SHORT $LN8@GeneratePa

; 369  : 	{
; 370  : 		temp = &(m_ppaaNodes[m_iXdest][m_iYdest]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+68]
	imul	ecx, 96					; 00000060H
	add	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _temp$[ebp], ecx

; 371  : 
; 372  : 		if(temp->m_eCvAStarListType == CVASTARLIST_CLOSED)

	mov	edx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [edx+20], 1
	jne	SHORT $LN8@GeneratePa

; 373  : 		{
; 374  : 			m_pBest = temp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [eax+96], ecx

; 375  : 			if (udUninitializeFunc)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN6@GeneratePa

; 376  : 				udUninitializeFunc(m_pData, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	ecx
	add	esp, 8
$LN6@GeneratePa:

; 377  : 			return true;

	mov	al, 1
	jmp	SHORT $LN26@GeneratePa
$LN8@GeneratePa:

; 378  : 		}
; 379  : 	}
; 380  : 
; 381  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 382  : 	int retval = 0;
; 383  : 
; 384  : 	do
; 385  : #else
; 386  : 	retval = 0;

	mov	DWORD PTR _retval$[ebp], 0
$LN5@GeneratePa:

; 387  : 
; 388  : 	while(retval == 0)

	cmp	DWORD PTR _retval$[ebp], 0
	jne	SHORT $LN4@GeneratePa

; 389  : #endif
; 390  : 	{
; 391  : 		retval = Step();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Step@CvAStar@@IAEHXZ			; CvAStar::Step
	mov	DWORD PTR _retval$[ebp], eax

; 392  : 	}

	jmp	SHORT $LN5@GeneratePa
$LN4@GeneratePa:

; 393  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 394  : 	while (retval == 0);
; 395  : 
; 396  : 	if (udUninitializeFunc)
; 397  : 		udUninitializeFunc(m_pData, this);
; 398  : #endif
; 399  : 
; 400  : 	if(retval == -1)

	cmp	DWORD PTR _retval$[ebp], -1
	jne	SHORT $LN3@GeneratePa

; 401  : 	{
; 402  : 		assert(m_pBest == NULL);
; 403  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 404  : 		if (udUninitializeFunc)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN2@GeneratePa

; 405  : 			udUninitializeFunc(m_pData, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	ecx
	add	esp, 8
$LN2@GeneratePa:

; 406  : #endif
; 407  : 		return false;

	xor	al, al
	jmp	SHORT $LN26@GeneratePa
$LN3@GeneratePa:

; 408  : 	}
; 409  : 
; 410  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 411  : 	if (udUninitializeFunc)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN1@GeneratePa

; 412  : 		udUninitializeFunc(m_pData, this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	call	ecx
	add	esp, 8
$LN1@GeneratePa:

; 413  : #endif
; 414  : 	return true;

	mov	al, 1
$LN26@GeneratePa:

; 415  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z ENDP		; CvAStar::GeneratePath
_TEXT	ENDS
PUBLIC	?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z	; CvAStar::CreateChildren
PUBLIC	?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ		; CvAStar::GetBest
; Function compile flags: /Odtp
;	COMDAT ?Step@CvAStar@@IAEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T221464 = -9						; size = 1
$T221463 = -8						; size = 4
$T221462 = -4						; size = 4
?Step@CvAStar@@IAEHXZ PROC				; CvAStar::Step, COMDAT
; _this$ = ecx

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 421  : 	if((m_pBest = GetBest()) == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ	; CvAStar::GetBest
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+96], 0
	jne	SHORT $LN3@Step

; 422  : 	{
; 423  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN4@Step
$LN3@Step:

; 424  : 	}
; 425  : 
; 426  : 	CreateChildren(m_pBest); // needs to be done, even on the last node, to allow for re-use...

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::CreateChildren

; 427  : 
; 428  : 	if (m_pBest == NULL)	// There seems to be a case were this will come back NULL.

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+96], 0
	jne	SHORT $LN2@Step

; 429  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN4@Step
$LN2@Step:

; 430  : 
; 431  : 	if(IsPathDest(m_pBest->m_iX, m_pBest->m_iY))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T221463[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	movsx	edx, WORD PTR [ecx+80]
	mov	DWORD PTR $T221462[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Step
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR $T221463[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221462[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN6@Step
	mov	BYTE PTR $T221464[ebp], 1
	jmp	SHORT $LN7@Step
$LN6@Step:
	mov	BYTE PTR $T221464[ebp], 0
$LN7@Step:
	movzx	edx, BYTE PTR $T221464[ebp]
	test	edx, edx
	je	SHORT $LN1@Step

; 432  : 	{
; 433  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN4@Step
$LN1@Step:

; 434  : 	}
; 435  : 
; 436  : 	return 0;

	xor	eax, eax
$LN4@Step:

; 437  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Step@CvAStar@@IAEHXZ ENDP				; CvAStar::Step
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
tv140 = -36						; size = 4
tv138 = -32						; size = 4
_this$ = -28						; size = 4
$T221485 = -24						; size = 4
$T221484 = -20						; size = 4
$T221483 = -16						; size = 4
$T221475 = -12						; size = 4
$T221474 = -8						; size = 4
_temp$ = -4						; size = 4
?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ PROC		; CvAStar::GetBest, COMDAT
; _this$ = ecx

; 442  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 443  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 444  : 	CvAStarNode* temp;
; 445  : #endif
; 446  : 
; 447  : 	if(!m_pOpen)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	jne	SHORT $LN4@GetBest

; 448  : 	{
; 449  : 		return NULL;

	xor	eax, eax
	jmp	$LN5@GetBest
$LN4@GetBest:

; 450  : 	}
; 451  : 
; 452  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 453  : 	CvAStarNode* temp = m_pOpen;
; 454  : #else
; 455  : 	temp = m_pOpen;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _temp$[ebp], edx

; 456  : #endif
; 457  : 
; 458  : 	m_pOpen = temp->m_pNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+84], edx

; 459  : 	if(m_pOpen != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN3@GetBest

; 460  : 	{
; 461  : 		m_pOpen->m_pPrev = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [edx+32], 0

; 462  : 	}
; 463  : 	else

	jmp	SHORT $LN2@GetBest
$LN3@GetBest:

; 464  : 	{
; 465  : 		m_pOpenTail = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0
$LN2@GetBest:

; 466  : 	}
; 467  : 
; 468  : 	udFunc(udNotifyList, NULL, temp, ASNL_DELETEOPEN, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221475[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T221474[ebp], ecx
	cmp	DWORD PTR $T221474[ebp], 0
	je	SHORT $LN9@GetBest
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221475[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	push	0
	call	DWORD PTR $T221474[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN7@GetBest
$LN9@GetBest:
	mov	DWORD PTR tv138[ebp], 1
$LN7@GetBest:

; 469  : 
; 470  : 	temp->m_eCvAStarListType = CVASTARLIST_CLOSED;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [edx+20], 1

; 471  : 
; 472  : 	temp->m_pNext = m_pClosed;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+28], edx

; 473  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 474  : 	temp->m_pPrev = NULL;
; 475  : #endif
; 476  : 	if(m_pClosed != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $LN1@GetBest

; 477  : 	{
; 478  : 		m_pClosed->m_pPrev = temp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@GetBest:

; 479  : 	}
; 480  : 	m_pClosed = temp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx+92], edx

; 481  : 
; 482  : 	udFunc(udNotifyList, NULL, m_pClosed, ASNL_ADDCLOSED, m_pData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221485[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR $T221484[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR $T221483[ebp], edx
	cmp	DWORD PTR $T221483[ebp], 0
	je	SHORT $LN13@GetBest
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221485[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR $T221484[ebp]
	push	edx
	push	0
	call	DWORD PTR $T221483[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN11@GetBest
$LN13@GetBest:
	mov	DWORD PTR tv140[ebp], 1
$LN11@GetBest:

; 483  : 
; 484  : 	return temp;

	mov	eax, DWORD PTR _temp$[ebp]
$LN5@GetBest:

; 485  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBest@CvAStar@@IAEPAVCvAStarNode@@XZ ENDP		; CvAStar::GetBest
_TEXT	ENDS
PUBLIC	?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z	; CvAStar::LinkChild
;	COMDAT ?s_CvAStarChildHexY@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
_DATA	SEGMENT
?s_CvAStarChildHexY@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA DD 01H ; `CvAStar::CreateChildren'::`2'::s_CvAStarChildHexY
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
_DATA	ENDS
;	COMDAT ?s_CvAStarChildHexX@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA
_DATA	SEGMENT
?s_CvAStarChildHexX@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA DD 00H ; `CvAStar::CreateChildren'::`2'::s_CvAStarChildHexX
	DD	01H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
_DATA	ENDS
;	COMDAT ?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
tv261 = -100						; size = 4
tv201 = -96						; size = 4
tv193 = -92						; size = 4
tv256 = -88						; size = 4
tv146 = -84						; size = 4
tv138 = -80						; size = 4
tv95 = -76						; size = 4
tv78 = -72						; size = 4
_this$ = -68						; size = 4
$T221546 = -64						; size = 4
$T221545 = -60						; size = 4
$T221537 = -53						; size = 1
$T221529 = -52						; size = 4
$T221528 = -48						; size = 4
$T221520 = -41						; size = 1
$T221512 = -40						; size = 4
$T221502 = -36						; size = 4
$T221501 = -32						; size = 4
_i$219051 = -28						; size = 4
_iExtraChildren$219050 = -24				; size = 4
_range$ = -20						; size = 4
_i$ = -16						; size = 4
_x$ = -12						; size = 4
_y$ = -8						; size = 4
_check$ = -4						; size = 4
_node$ = 8						; size = 4
?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC	; CvAStar::CreateChildren, COMDAT
; _this$ = ecx

; 553  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 554  : 	CvAStarNode* check;
; 555  : 	int range = 6;

	mov	DWORD PTR _range$[ebp], 6

; 556  : 	int x, y;
; 557  : 	int i;
; 558  : 
; 559  : 	static int s_CvAStarChildHexX[6] = { 0, 1,  1,  0, -1, -1, };
; 560  : 	static int s_CvAStarChildHexY[6] = { 1, 0, -1, -1,  0,  1, };
; 561  : 
; 562  : 	for(i = 0; i < range; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@CreateChil
$LN10@CreateChil:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@CreateChil:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _range$[ebp]
	jge	$LN9@CreateChil

; 563  : 	{
; 564  : 		x = node->m_iX - ((node->m_iY >= 0) ? (node->m_iY>>1) : ((node->m_iY - 1)/2));

	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	test	eax, eax
	jl	SHORT $LN14@CreateChil
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	sar	edx, 1
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN15@CreateChil
$LN14@CreateChil:
	mov	eax, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [eax+82]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv78[ebp], eax
$LN15@CreateChil:
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	sub	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _x$[ebp], edx

; 565  : 		x += s_CvAStarChildHexX[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR ?s_CvAStarChildHexX@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA[eax*4]
	mov	DWORD PTR _x$[ebp], ecx

; 566  : 		y = yRange(node->m_iY + s_CvAStarChildHexY[i]);

	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	ecx, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR ?s_CvAStarChildHexY@?1??CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z@4PAHA[ecx*4]
	mov	DWORD PTR $T221501[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+77]
	test	eax, eax
	je	SHORT $LN23@CreateChil
	cmp	DWORD PTR $T221501[ebp], 0
	jge	SHORT $LN22@CreateChil
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T221501[ebp]
	cdq
	idiv	DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+52]
	mov	DWORD PTR $T221502[ebp], edx
	jmp	SHORT $LN24@CreateChil
	jmp	SHORT $LN21@CreateChil
$LN22@CreateChil:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T221501[ebp]
	cmp	edx, DWORD PTR [ecx+52]
	jl	SHORT $LN20@CreateChil
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T221501[ebp]
	cdq
	idiv	DWORD PTR [ecx+52]
	mov	DWORD PTR $T221502[ebp], edx
	jmp	SHORT $LN24@CreateChil
	jmp	SHORT $LN21@CreateChil
$LN20@CreateChil:
	mov	edx, DWORD PTR $T221501[ebp]
	mov	DWORD PTR $T221502[ebp], edx
	jmp	SHORT $LN24@CreateChil
$LN21@CreateChil:
	jmp	SHORT $LN24@CreateChil
$LN23@CreateChil:
	mov	eax, DWORD PTR $T221501[ebp]
	mov	DWORD PTR $T221502[ebp], eax
$LN24@CreateChil:
	mov	ecx, DWORD PTR $T221502[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 567  : 		x += ((y >= 0) ? (y>>1) : ((y - 1)/2));

	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN16@CreateChil
	mov	edx, DWORD PTR _y$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv95[ebp], edx
	jmp	SHORT $LN17@CreateChil
$LN16@CreateChil:
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv95[ebp], eax
$LN17@CreateChil:
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 568  : 		x = xRange(x);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	test	edx, edx
	je	SHORT $LN31@CreateChil
	cmp	DWORD PTR _x$[ebp], 0
	jge	SHORT $LN30@CreateChil
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	cdq
	idiv	DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+48]
	mov	DWORD PTR $T221512[ebp], edx
	jmp	SHORT $LN32@CreateChil
	jmp	SHORT $LN29@CreateChil
$LN30@CreateChil:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jl	SHORT $LN28@CreateChil
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	cdq
	idiv	DWORD PTR [ecx+48]
	mov	DWORD PTR $T221512[ebp], edx
	jmp	SHORT $LN32@CreateChil
	jmp	SHORT $LN29@CreateChil
$LN28@CreateChil:
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR $T221512[ebp], edx
	jmp	SHORT $LN32@CreateChil
$LN29@CreateChil:
	jmp	SHORT $LN32@CreateChil
$LN31@CreateChil:
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR $T221512[ebp], eax
$LN32@CreateChil:
	mov	ecx, DWORD PTR $T221512[ebp]
	mov	DWORD PTR _x$[ebp], ecx

; 569  : 
; 570  : 		PREFETCH_FASTAR_NODE(&(m_ppaaNodes[x][y]));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _y$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv138[ebp], ecx
	mov	eax, DWORD PTR tv138[ebp]
	prefetcht0 BYTE PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	eax, DWORD PTR [edx+eax+64]
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR tv146[ebp]
	prefetcht0 BYTE PTR [ecx]

; 571  : 		if(isValid(x, y))

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN36@CreateChil
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jl	SHORT $LN37@CreateChil
$LN36@CreateChil:
	mov	BYTE PTR $T221520[ebp], 0
	jmp	SHORT $LN38@CreateChil
$LN37@CreateChil:
	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN34@CreateChil
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	cmp	edx, DWORD PTR [ecx+52]
	jl	SHORT $LN35@CreateChil
$LN34@CreateChil:
	mov	BYTE PTR $T221520[ebp], 0
	jmp	SHORT $LN38@CreateChil
$LN35@CreateChil:
	mov	BYTE PTR $T221520[ebp], 1
$LN38@CreateChil:
	movzx	eax, BYTE PTR $T221520[ebp]
	test	eax, eax
	je	SHORT $LN8@CreateChil

; 572  : 		{
; 573  : 			check = &(m_ppaaNodes[x][y]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _y$[ebp]
	imul	eax, 96					; 00000060H
	mov	ecx, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _check$[ebp], eax

; 574  : 
; 575  : 			if(udFunc(udValid, node, check, 0, m_pData))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221529[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T221528[ebp], edx
	cmp	DWORD PTR $T221528[ebp], 0
	je	SHORT $LN42@CreateChil
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221529[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _check$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	DWORD PTR $T221528[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN40@CreateChil
$LN42@CreateChil:
	mov	DWORD PTR tv256[ebp], 1
$LN40@CreateChil:
	cmp	DWORD PTR tv256[ebp], 0
	je	SHORT $LN8@CreateChil

; 576  : 			{
; 577  : 				LinkChild(node, check);

	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z ; CvAStar::LinkChild
$LN8@CreateChil:

; 578  : 			}
; 579  : 		}
; 580  : 	}

	jmp	$LN10@CreateChil
$LN9@CreateChil:

; 581  : 
; 582  : 	if(udNumExtraChildrenFunc && udGetExtraChildFunc)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	$LN12@CreateChil
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 0
	je	$LN12@CreateChil

; 583  : 	{
; 584  : 		int iExtraChildren = udNumExtraChildrenFunc(node, this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	call	edx
	add	esp, 8
	mov	DWORD PTR _iExtraChildren$219050[ebp], eax

; 585  : 		for(int i = 0; i < iExtraChildren; i++)

	mov	DWORD PTR _i$219051[ebp], 0
	jmp	SHORT $LN5@CreateChil
$LN4@CreateChil:
	mov	eax, DWORD PTR _i$219051[ebp]
	add	eax, 1
	mov	DWORD PTR _i$219051[ebp], eax
$LN5@CreateChil:
	mov	ecx, DWORD PTR _i$219051[ebp]
	cmp	ecx, DWORD PTR _iExtraChildren$219050[ebp]
	jge	$LN12@CreateChil

; 586  : 		{
; 587  : 			udGetExtraChildFunc(node, i, x, y, this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$219051[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	call	edx
	add	esp, 20					; 00000014H

; 588  : 			PREFETCH_FASTAR_NODE(&(m_ppaaNodes[x][y]));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _y$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv193[ebp], edx
	mov	ecx, DWORD PTR tv193[ebp]
	prefetcht0 BYTE PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _y$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [eax+ecx+64]
	mov	DWORD PTR tv201[ebp], ecx
	mov	edx, DWORD PTR tv201[ebp]
	prefetcht0 BYTE PTR [edx]

; 589  : 
; 590  : 			if(isValid(x, y))

	cmp	DWORD PTR _x$[ebp], 0
	jl	SHORT $LN46@CreateChil
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jl	SHORT $LN47@CreateChil
$LN46@CreateChil:
	mov	BYTE PTR $T221537[ebp], 0
	jmp	SHORT $LN48@CreateChil
$LN47@CreateChil:
	cmp	DWORD PTR _y$[ebp], 0
	jl	SHORT $LN44@CreateChil
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	cmp	eax, DWORD PTR [edx+52]
	jl	SHORT $LN45@CreateChil
$LN44@CreateChil:
	mov	BYTE PTR $T221537[ebp], 0
	jmp	SHORT $LN48@CreateChil
$LN45@CreateChil:
	mov	BYTE PTR $T221537[ebp], 1
$LN48@CreateChil:
	movzx	ecx, BYTE PTR $T221537[ebp]
	test	ecx, ecx
	je	SHORT $LN2@CreateChil

; 591  : 			{
; 592  : 				check = &(m_ppaaNodes[x][y]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _y$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _check$[ebp], ecx

; 593  : 
; 594  : 				if(udFunc(udValid, node, check, 0, m_pData))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221546[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T221545[ebp], eax
	cmp	DWORD PTR $T221545[ebp], 0
	je	SHORT $LN52@CreateChil
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221546[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	DWORD PTR $T221545[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv261[ebp], eax
	jmp	SHORT $LN50@CreateChil
$LN52@CreateChil:
	mov	DWORD PTR tv261[ebp], 1
$LN50@CreateChil:
	cmp	DWORD PTR tv261[ebp], 0
	je	SHORT $LN2@CreateChil

; 595  : 				{
; 596  : 					LinkChild(node, check);

	mov	edx, DWORD PTR _check$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z ; CvAStar::LinkChild
$LN2@CreateChil:

; 597  : 				}
; 598  : 			}
; 599  : 		}

	jmp	$LN4@CreateChil
$LN12@CreateChil:

; 600  : 	}
; 601  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CreateChildren@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP	; CvAStar::CreateChildren
_TEXT	ENDS
PUBLIC	?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z	; CvAStar::AddToOpen
PUBLIC	?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z	; CvAStar::UpdateParents
PUBLIC	?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z	; CvAStar::UpdateOpenNode
PUBLIC	?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back
; Function compile flags: /Odtp
;	COMDAT ?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z
_TEXT	SEGMENT
tv250 = -108						; size = 4
tv256 = -104						; size = 4
tv228 = -100						; size = 4
tv202 = -96						; size = 4
_this$ = -92						; size = 4
$T221602 = -60						; size = 4
$T221601 = -56						; size = 4
$T221600 = -52						; size = 4
$T221592 = -48						; size = 4
$T221591 = -44						; size = 4
$T221590 = -40						; size = 4
$T221575 = -32						; size = 4
$T221574 = -28						; size = 4
$T221573 = -24						; size = 4
$T221558 = -16						; size = 4
$T221557 = -12						; size = 4
$T221556 = -8						; size = 4
_iKnownCost$ = -4					; size = 4
_node$ = 8						; size = 4
_check$ = 12						; size = 4
?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z PROC	; CvAStar::LinkChild, COMDAT
; _this$ = ecx

; 607  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 608  : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 609  : 	int iKnownCost = node->m_iKnownCost + udFunc(udCost, node, check, 0, m_pData);
; 610  : #else
; 611  : 	int iKnownCost;
; 612  : 
; 613  : 	iKnownCost = node->m_iKnownCost + udFunc(udCost, node, check, 0, m_pData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221558[ebp], ecx
	mov	edx, DWORD PTR _check$[ebp]
	mov	DWORD PTR $T221557[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T221556[ebp], ecx
	cmp	DWORD PTR $T221556[ebp], 0
	je	SHORT $LN13@LinkChild
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221558[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR $T221557[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	DWORD PTR $T221556[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv202[ebp], eax
	jmp	SHORT $LN11@LinkChild
$LN13@LinkChild:
	mov	DWORD PTR tv202[ebp], 1
$LN11@LinkChild:
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR tv202[ebp]
	mov	DWORD PTR _iKnownCost$[ebp], ecx

; 614  : #endif
; 615  : 
; 616  : 	if(check->m_eCvAStarListType == CVASTARLIST_OPEN)

	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	$LN8@LinkChild

; 617  : 	{
; 618  : 		node->m_apChildren.push_back(check);

	lea	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 40					; 00000028H
	call	?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back

; 619  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 620  : 		node->m_iNumChildren++;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	dx, WORD PTR [ecx+84]
	add	dx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	WORD PTR [eax+84], dx

; 621  : #endif
; 622  : 
; 623  : 		if(iKnownCost < check->m_iKnownCost)

	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR _iKnownCost$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN7@LinkChild

; 624  : 		{
; 625  : 			FAssert(node->m_pParent != check);
; 626  : 
; 627  : 			check->m_pParent = node;

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 628  : 			check->m_iKnownCost = iKnownCost;

	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR _iKnownCost$[ebp]
	mov	DWORD PTR [edx+4], eax

; 629  : 			check->m_iTotalCost = iKnownCost + check->m_iHeuristicCost;

	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR _iKnownCost$[ebp]
	add	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _check$[ebp]
	mov	DWORD PTR [eax], edx

; 630  : 
; 631  : 			UpdateOpenNode(check);

	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::UpdateOpenNode

; 632  : 			udFunc(udNotifyChild, node, check, ASNC_OPENADD_UP, m_pData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221575[ebp], eax
	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR $T221574[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T221573[ebp], eax
	cmp	DWORD PTR $T221573[ebp], 0
	je	SHORT $LN24@LinkChild
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221575[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T221574[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	push	ecx
	call	DWORD PTR $T221573[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN7@LinkChild
$LN24@LinkChild:
	mov	DWORD PTR tv228[ebp], 1
$LN7@LinkChild:

; 633  : 		}
; 634  : 	}

	jmp	$LN9@LinkChild
$LN8@LinkChild:

; 635  : 	else if(check->m_eCvAStarListType == CVASTARLIST_CLOSED)

	mov	edx, DWORD PTR _check$[ebp]
	cmp	DWORD PTR [edx+20], 1
	jne	$LN5@LinkChild

; 636  : 	{
; 637  : 		node->m_apChildren.push_back(check);

	lea	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 40					; 00000028H
	call	?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back

; 638  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 639  : 		node->m_iNumChildren++;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	dx, WORD PTR [ecx+84]
	add	dx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	WORD PTR [eax+84], dx

; 640  : #endif
; 641  : 
; 642  : 		if(iKnownCost < check->m_iKnownCost)

	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR _iKnownCost$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN4@LinkChild

; 643  : 		{
; 644  : 			FAssert(node->m_pParent != check);
; 645  : 			check->m_pParent = node;

	mov	eax, DWORD PTR _check$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 646  : 			check->m_iKnownCost = iKnownCost;

	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR _iKnownCost$[ebp]
	mov	DWORD PTR [edx+4], eax

; 647  : 			check->m_iTotalCost = iKnownCost + check->m_iHeuristicCost;

	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR _iKnownCost$[ebp]
	add	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _check$[ebp]
	mov	DWORD PTR [eax], edx

; 648  : 			udFunc(udNotifyChild, node, check, ASNC_CLOSEDADD_UP, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221592[ebp], edx
	mov	eax, DWORD PTR _check$[ebp]
	mov	DWORD PTR $T221591[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T221590[ebp], edx
	cmp	DWORD PTR $T221590[ebp], 0
	je	SHORT $LN35@LinkChild
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221592[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR $T221591[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	call	DWORD PTR $T221590[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN33@LinkChild
$LN35@LinkChild:
	mov	DWORD PTR tv256[ebp], 1
$LN33@LinkChild:

; 649  : 
; 650  : 			UpdateParents(check);

	mov	ecx, DWORD PTR _check$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::UpdateParents
$LN4@LinkChild:

; 651  : 		}
; 652  : 	}
; 653  : 	else

	jmp	$LN9@LinkChild
$LN5@LinkChild:

; 654  : 	{
; 655  : 		FAssert(check->m_eCvAStarListType == NO_CVASTARLIST);
; 656  : 		FAssert(node->m_pParent != check);
; 657  : 		check->m_pParent = node;

	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+24], eax

; 658  : 		check->m_iKnownCost = iKnownCost;

	mov	ecx, DWORD PTR _check$[ebp]
	mov	edx, DWORD PTR _iKnownCost$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 659  : 		if(udHeuristic == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@LinkChild

; 660  : 		{
; 661  : 			check->m_iHeuristicCost = 0;

	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 662  : 		}
; 663  : 		else

	jmp	SHORT $LN1@LinkChild
$LN2@LinkChild:

; 664  : 		{
; 665  : 			check->m_iHeuristicCost = udHeuristic(check->m_iX, check->m_iY, m_iXdest, m_iYdest);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _check$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	push	ecx
	mov	edx, DWORD PTR _check$[ebp]
	movsx	eax, WORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@LinkChild:

; 666  : 		}
; 667  : 		check->m_iTotalCost = check->m_iKnownCost + check->m_iHeuristicCost;

	mov	edx, DWORD PTR _check$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _check$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _check$[ebp]
	mov	DWORD PTR [edx], eax

; 668  : 
; 669  : 		udFunc(udNotifyChild, node, check, ASNC_NEWADD, m_pData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221602[ebp], ecx
	mov	edx, DWORD PTR _check$[ebp]
	mov	DWORD PTR $T221601[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T221600[ebp], ecx
	cmp	DWORD PTR $T221600[ebp], 0
	je	SHORT $LN39@LinkChild
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221602[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR $T221601[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	call	DWORD PTR $T221600[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv250[ebp], eax
	jmp	SHORT $LN37@LinkChild
$LN39@LinkChild:
	mov	DWORD PTR tv250[ebp], 1
$LN37@LinkChild:

; 670  : 
; 671  : 		AddToOpen(check);

	mov	eax, DWORD PTR _check$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z ; CvAStar::AddToOpen

; 672  : 
; 673  : 		node->m_apChildren.push_back(check);

	lea	ecx, DWORD PTR _check$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 40					; 00000028H
	call	?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back

; 674  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 675  : 		node->m_iNumChildren++;

	mov	edx, DWORD PTR _node$[ebp]
	mov	ax, WORD PTR [edx+84]
	add	ax, 1
	mov	ecx, DWORD PTR _node$[ebp]
	mov	WORD PTR [ecx+84], ax
$LN9@LinkChild:

; 676  : #endif
; 677  : 	}
; 678  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?LinkChild@CvAStar@@IAEXPAVCvAStarNode@@0@Z ENDP	; CvAStar::LinkChild
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
tv279 = -160						; size = 4
tv277 = -156						; size = 4
tv275 = -152						; size = 4
tv273 = -148						; size = 4
tv271 = -144						; size = 4
tv269 = -140						; size = 4
tv267 = -136						; size = 4
tv265 = -132						; size = 4
tv263 = -128						; size = 4
_this$ = -124						; size = 4
$T221715 = -120						; size = 4
$T221714 = -116						; size = 4
$T221706 = -112						; size = 4
$T221705 = -108						; size = 4
$T221704 = -104						; size = 4
$T221703 = -100						; size = 4
$T221695 = -96						; size = 4
$T221694 = -92						; size = 4
$T221686 = -88						; size = 4
$T221685 = -84						; size = 4
$T221684 = -80						; size = 4
$T221683 = -76						; size = 4
$T221675 = -72						; size = 4
$T221674 = -68						; size = 4
$T221673 = -64						; size = 4
$T221665 = -60						; size = 4
$T221664 = -56						; size = 4
$T221663 = -52						; size = 4
$T221655 = -48						; size = 4
$T221654 = -44						; size = 4
$T221653 = -40						; size = 4
$T221645 = -36						; size = 4
$T221644 = -32						; size = 4
$T221643 = -28						; size = 4
$T221642 = -24						; size = 4
$T221634 = -20						; size = 4
$T221633 = -16						; size = 4
_prev$219094 = -12					; size = 4
_next$219084 = -8					; size = 4
_node$ = -4						; size = 4
_addnode$ = 8						; size = 4
?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z PROC		; CvAStar::AddToOpen, COMDAT
; _this$ = ecx

; 683  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	DWORD PTR _this$[ebp], ecx

; 684  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 685  : 	CvAStarNode* node;
; 686  : #endif
; 687  : 
; 688  : 	addnode->m_eCvAStarListType = CVASTARLIST_OPEN;

	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [eax+20], 0

; 689  : 
; 690  : 	if(!m_pOpen)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	jne	SHORT $LN21@AddToOpen

; 691  : 	{
; 692  : 		m_pOpen = addnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+84], eax

; 693  : 		m_pOpenTail = addnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [ecx+88], edx

; 694  : 		m_pOpen->m_pNext = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR [ecx+28], 0

; 695  : 		m_pOpen->m_pPrev = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [eax+32], 0

; 696  : 
; 697  : 		udFunc(udNotifyList, NULL, addnode, ASNL_STARTOPEN, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221634[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T221633[ebp], ecx
	cmp	DWORD PTR $T221633[ebp], 0
	je	SHORT $LN26@AddToOpen
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221634[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _addnode$[ebp]
	push	ecx
	push	0
	call	DWORD PTR $T221633[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv263[ebp], eax
	jmp	SHORT $LN24@AddToOpen
$LN26@AddToOpen:
	mov	DWORD PTR tv263[ebp], 1
$LN24@AddToOpen:

; 698  : 
; 699  : 		return;

	jmp	$LN22@AddToOpen
$LN21@AddToOpen:

; 700  : 	}
; 701  : #ifdef AUI_ASTAR_FIX_POSSIBLE_NULL_POINTERS
; 702  : 	else if (!m_pOpenTail)
; 703  : 	{
; 704  : 		CvAStarNode* temp = m_pOpen;
; 705  : 		while (temp->m_pNext)
; 706  : 		{
; 707  : 			temp = temp->m_pNext;
; 708  : 		}
; 709  : 		m_pOpenTail = temp;
; 710  : 	}
; 711  : 
; 712  : 	if (addnode->m_iTotalCost < m_pOpen->m_iTotalCost)
; 713  : #else
; 714  : 
; 715  : 	if(addnode->m_iTotalCost <= m_pOpen->m_iTotalCost)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jg	SHORT $LN20@AddToOpen

; 716  : #endif
; 717  : 	{
; 718  : 		addnode->m_pNext = m_pOpen;

	mov	eax, DWORD PTR _addnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+28], edx

; 719  : 		m_pOpen->m_pPrev = addnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 720  : 		m_pOpen = addnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 721  : 
; 722  : 		udFunc(udNotifyList, m_pOpen->m_pNext, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221645[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T221644[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T221643[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T221642[ebp], ecx
	cmp	DWORD PTR $T221642[ebp], 0
	je	SHORT $LN30@AddToOpen
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221645[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T221644[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221643[ebp]
	push	edx
	call	DWORD PTR $T221642[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv265[ebp], eax
	jmp	SHORT $LN28@AddToOpen
$LN30@AddToOpen:
	mov	DWORD PTR tv265[ebp], 1
$LN28@AddToOpen:

; 723  : 	}
; 724  : 	else if(addnode->m_iTotalCost >= m_pOpenTail->m_iTotalCost)

	jmp	$LN22@AddToOpen
$LN20@AddToOpen:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jl	SHORT $LN18@AddToOpen

; 725  : 	{
; 726  : 		addnode->m_pPrev = m_pOpenTail;

	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx+32], eax

; 727  : 		m_pOpenTail->m_pNext = addnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+28], eax

; 728  : 		m_pOpenTail = addnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [ecx+88], edx

; 729  : 
; 730  : 		udFunc(udNotifyList, addnode->m_pPrev, addnode, ASNL_ADDOPEN, m_pData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221655[ebp], ecx
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR $T221654[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR $T221653[ebp], edx
	cmp	DWORD PTR $T221653[ebp], 0
	je	SHORT $LN34@AddToOpen
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221655[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _addnode$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221654[ebp]
	push	eax
	call	DWORD PTR $T221653[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv267[ebp], eax
	jmp	SHORT $LN32@AddToOpen
$LN34@AddToOpen:
	mov	DWORD PTR tv267[ebp], 1
$LN32@AddToOpen:

; 731  : 	}
; 732  : 	else if(abs(addnode->m_iTotalCost-m_pOpenTail->m_iTotalCost) < abs(addnode->m_iTotalCost-m_pOpen->m_iTotalCost))  //(addnode->m_iTotalCost > m_iOpenListAverage) // let's start at the end and work forwards

	jmp	$LN22@AddToOpen
$LN18@AddToOpen:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [edx]
	cdq
	mov	ecx, eax
	xor	ecx, edx
	sub	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	edx, DWORD PTR [edx]
	sub	edx, DWORD PTR [eax]
	mov	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	ecx, eax
	jge	$LN16@AddToOpen

; 733  : 	{
; 734  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 735  : 		CvAStarNode* next = NULL;
; 736  : 		CvAStarNode* node = m_pOpenTail;
; 737  : #else
; 738  : 		CvAStarNode* next;
; 739  : 		node = m_pOpenTail;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _node$[ebp], ecx

; 740  : 		next = NULL;

	mov	DWORD PTR _next$219084[ebp], 0
$LN15@AddToOpen:

; 741  : #endif
; 742  : 
; 743  : 		while(node)

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN14@AddToOpen

; 744  : 		{
; 745  : 			if(addnode->m_iTotalCost < node->m_iTotalCost)

	mov	edx, DWORD PTR _addnode$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN13@AddToOpen

; 746  : 			{
; 747  : 				next = node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _next$219084[ebp], edx

; 748  : 				node = node->m_pPrev;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _node$[ebp], ecx

; 749  : 			}
; 750  : 			else

	jmp	$LN12@AddToOpen
$LN13@AddToOpen:

; 751  : 			{
; 752  : 				if(next)

	cmp	DWORD PTR _next$219084[ebp], 0
	je	$LN11@AddToOpen

; 753  : 				{
; 754  : 					next->m_pPrev = addnode;

	mov	edx, DWORD PTR _next$219084[ebp]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+32], eax

; 755  : 					addnode->m_pNext = next;

	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	edx, DWORD PTR _next$219084[ebp]
	mov	DWORD PTR [ecx+28], edx

; 756  : 					addnode->m_pPrev = node;

	mov	eax, DWORD PTR _addnode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 757  : 					node->m_pNext = addnode;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+28], eax

; 758  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 759  : 					if(node->m_pNext == NULL)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN10@AddToOpen

; 760  : 					{
; 761  : 						m_pOpenTail = node;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+88], eax
$LN10@AddToOpen:

; 762  : 					}
; 763  : #endif
; 764  : 
; 765  : 					udFunc(udNotifyList, addnode->m_pPrev, addnode, ASNL_ADDOPEN, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221665[ebp], edx
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T221664[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T221663[ebp], eax
	cmp	DWORD PTR $T221663[ebp], 0
	je	SHORT $LN38@AddToOpen
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221665[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _addnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221664[ebp]
	push	ecx
	call	DWORD PTR $T221663[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv269[ebp], eax
	jmp	SHORT $LN36@AddToOpen
$LN38@AddToOpen:
	mov	DWORD PTR tv269[ebp], 1
$LN36@AddToOpen:

; 766  : 				}
; 767  : 				else // we should just add it to the end of the list

	jmp	SHORT $LN9@AddToOpen
$LN11@AddToOpen:

; 768  : 				{
; 769  : 					addnode->m_pPrev = m_pOpenTail;

	mov	edx, DWORD PTR _addnode$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR [edx+32], ecx

; 770  : 					m_pOpenTail->m_pNext = addnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 771  : 					m_pOpenTail = addnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+88], eax

; 772  : 
; 773  : 					udFunc(udNotifyList, addnode->m_pPrev, addnode, ASNL_ADDOPEN, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221675[ebp], edx
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T221674[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T221673[ebp], eax
	cmp	DWORD PTR $T221673[ebp], 0
	je	SHORT $LN42@AddToOpen
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221675[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _addnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221674[ebp]
	push	ecx
	call	DWORD PTR $T221673[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv271[ebp], eax
	jmp	SHORT $LN9@AddToOpen
$LN42@AddToOpen:
	mov	DWORD PTR tv271[ebp], 1
$LN9@AddToOpen:

; 774  : 				}
; 775  : 
; 776  : 				return;

	jmp	$LN22@AddToOpen
$LN12@AddToOpen:

; 777  : 			}
; 778  : 		}

	jmp	$LN15@AddToOpen
$LN14@AddToOpen:

; 779  : 
; 780  : 		// we made it to the start of this list - insert it at the beginning - we shouldn't ever get here, but...
; 781  : 		next->m_pPrev = addnode;

	mov	edx, DWORD PTR _next$219084[ebp]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+32], eax

; 782  : 		addnode->m_pNext = next;

	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	edx, DWORD PTR _next$219084[ebp]
	mov	DWORD PTR [ecx+28], edx

; 783  : 		m_pOpen = addnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 784  : 
; 785  : 		udFunc(udNotifyList, m_pOpen->m_pNext, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221686[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T221685[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T221684[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T221683[ebp], ecx
	cmp	DWORD PTR $T221683[ebp], 0
	je	SHORT $LN46@AddToOpen
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221686[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T221685[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221684[ebp]
	push	edx
	call	DWORD PTR $T221683[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv273[ebp], eax
	jmp	SHORT $LN44@AddToOpen
$LN46@AddToOpen:
	mov	DWORD PTR tv273[ebp], 1
$LN44@AddToOpen:

; 786  : 	}
; 787  : 	else // let's start at the beginning as it should be closer

	jmp	$LN22@AddToOpen
$LN16@AddToOpen:

; 788  : 	{
; 789  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 790  : 		CvAStarNode* node = m_pOpen;
; 791  : 		CvAStarNode* prev = NULL;
; 792  : #else
; 793  : 		CvAStarNode* prev;
; 794  : 		node = m_pOpen;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR _node$[ebp], ecx

; 795  : 		prev = NULL;

	mov	DWORD PTR _prev$219094[ebp], 0
$LN7@AddToOpen:

; 796  : #endif
; 797  : 
; 798  : 		while(node)

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN6@AddToOpen

; 799  : 		{
; 800  : #ifdef AUI_ASTAR_FIX_POSSIBLE_NULL_POINTERS
; 801  : 			if (addnode->m_iTotalCost >= node->m_iTotalCost)
; 802  : #else
; 803  : 			if(addnode->m_iTotalCost > node->m_iTotalCost)

	mov	edx, DWORD PTR _addnode$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN5@AddToOpen

; 804  : #endif
; 805  : 			{
; 806  : 				prev = node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _prev$219094[ebp], edx

; 807  : 				node = node->m_pNext;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _node$[ebp], ecx

; 808  : 			}
; 809  : 			else

	jmp	$LN4@AddToOpen
$LN5@AddToOpen:

; 810  : 			{
; 811  : 				if(prev)

	cmp	DWORD PTR _prev$219094[ebp], 0
	je	SHORT $LN3@AddToOpen

; 812  : 				{
; 813  : 					prev->m_pNext = addnode;

	mov	edx, DWORD PTR _prev$219094[ebp]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+28], eax

; 814  : 					addnode->m_pPrev = prev;

	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	edx, DWORD PTR _prev$219094[ebp]
	mov	DWORD PTR [ecx+32], edx

; 815  : 					addnode->m_pNext = node;

	mov	eax, DWORD PTR _addnode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 816  : 					node->m_pPrev = addnode;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [edx+32], eax

; 817  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 818  : 					if(node->m_pNext == NULL)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN2@AddToOpen

; 819  : 					{
; 820  : 						m_pOpenTail = node;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+88], eax
$LN2@AddToOpen:

; 821  : 					}
; 822  : #endif
; 823  : 
; 824  : 					udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221695[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T221694[ebp], ecx
	cmp	DWORD PTR $T221694[ebp], 0
	je	SHORT $LN50@AddToOpen
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221695[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _addnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _prev$219094[ebp]
	push	edx
	call	DWORD PTR $T221694[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv275[ebp], eax
	jmp	SHORT $LN48@AddToOpen
$LN50@AddToOpen:
	mov	DWORD PTR tv275[ebp], 1
$LN48@AddToOpen:

; 825  : 				}
; 826  : 				else

	jmp	SHORT $LN1@AddToOpen
$LN3@AddToOpen:

; 827  : 				{
; 828  : 					addnode->m_pNext = m_pOpen;

	mov	eax, DWORD PTR _addnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [eax+28], edx

; 829  : 					m_pOpen->m_pPrev = addnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 830  : 					m_pOpen = addnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 831  : 
; 832  : 					udFunc(udNotifyList, m_pOpen->m_pNext, m_pOpen, ASNL_STARTOPEN, m_pData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221706[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T221705[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T221704[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T221703[ebp], ecx
	cmp	DWORD PTR $T221703[ebp], 0
	je	SHORT $LN54@AddToOpen
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221706[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T221705[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221704[ebp]
	push	edx
	call	DWORD PTR $T221703[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN1@AddToOpen
$LN54@AddToOpen:
	mov	DWORD PTR tv277[ebp], 1
$LN1@AddToOpen:

; 833  : 				}
; 834  : 
; 835  : 				return;

	jmp	SHORT $LN22@AddToOpen
$LN4@AddToOpen:

; 836  : 			}
; 837  : 		}

	jmp	$LN7@AddToOpen
$LN6@AddToOpen:

; 838  : 
; 839  : 		// we made it to the end of this list - insert it at the end - we shouldn't ever get here, but...
; 840  : 		prev->m_pNext = addnode;

	mov	eax, DWORD PTR _prev$219094[ebp]
	mov	ecx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 841  : 		addnode->m_pPrev = prev;

	mov	edx, DWORD PTR _addnode$[ebp]
	mov	eax, DWORD PTR _prev$219094[ebp]
	mov	DWORD PTR [edx+32], eax

; 842  : 		m_pOpenTail = addnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _addnode$[ebp]
	mov	DWORD PTR [ecx+88], edx

; 843  : 
; 844  : 		udFunc(udNotifyList, prev, addnode, ASNL_ADDOPEN, m_pData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221715[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T221714[ebp], eax
	cmp	DWORD PTR $T221714[ebp], 0
	je	SHORT $LN58@AddToOpen
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221715[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _addnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _prev$219094[ebp]
	push	ecx
	call	DWORD PTR $T221714[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv279[ebp], eax
	jmp	SHORT $LN22@AddToOpen
$LN58@AddToOpen:
	mov	DWORD PTR tv279[ebp], 1
$LN22@AddToOpen:

; 845  : 	}
; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z ENDP		; CvAStar::AddToOpen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
_TEXT	ENDS
;	COMDAT ?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_temp$ = -4						; size = 4
_node$ = 8						; size = 4
?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC	; CvAStar::UpdateOpenNode, COMDAT
; _this$ = ecx

; 851  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 852  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 853  : 	CvAStarNode* temp = node->m_pPrev;
; 854  : #else
; 855  : 	CvAStarNode* temp;
; 856  : #endif
; 857  : 
; 858  : 	FAssert(node->m_eCvAStarListType == CVASTARLIST_OPEN);
; 859  : 
; 860  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 861  : 	if (temp && (node->m_iTotalCost < temp->m_iTotalCost))
; 862  : 	{
; 863  : 		// have node free float for now
; 864  : 		temp->m_pNext = node->m_pNext;
; 865  : 		if (node->m_pNext)
; 866  : 		{
; 867  : 			node->m_pNext->m_pPrev = temp;
; 868  : 		}
; 869  : 		else
; 870  : 		{
; 871  : 			m_pOpenTail = temp;
; 872  : 		}
; 873  : #else
; 874  : 	if((node->m_pPrev != NULL) && (node->m_iTotalCost < node->m_pPrev->m_iTotalCost))

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	$LN10@UpdateOpen
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edx]
	jge	$LN10@UpdateOpen

; 875  : 	{
; 876  : 		// have node free float for now
; 877  : 		node->m_pPrev->m_pNext = node->m_pNext;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 878  : 		if(node->m_pNext)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN8@UpdateOpen

; 879  : 		{
; 880  : 			node->m_pNext->m_pPrev = node->m_pPrev;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx

; 881  : 		}
; 882  : 		else

	jmp	SHORT $LN7@UpdateOpen
$LN8@UpdateOpen:

; 883  : 		{
; 884  : 			m_pOpenTail = node->m_pPrev;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+88], ecx
$LN7@UpdateOpen:

; 885  : 		}
; 886  : #endif
; 887  : 		// scoot down the list till we find where node goes (without connecting up as we go)
; 888  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 889  : 		temp = node->m_pPrev;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _temp$[ebp], eax
$LN6@UpdateOpen:

; 890  : #endif
; 891  : 		while((temp != NULL) && (node->m_iTotalCost < temp->m_iTotalCost))

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN5@UpdateOpen
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN5@UpdateOpen

; 892  : 		{
; 893  : 			temp = temp->m_pPrev;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _temp$[ebp], edx

; 894  : 		}

	jmp	SHORT $LN6@UpdateOpen
$LN5@UpdateOpen:

; 895  : 		// connect node up
; 896  : 		if(temp != NULL)

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN4@UpdateOpen

; 897  : 		{
; 898  : 			node->m_pNext = temp->m_pNext;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 899  : 			node->m_pPrev = temp;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 900  : 			if(temp->m_pNext)

	mov	edx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN3@UpdateOpen

; 901  : 			{
; 902  : 				temp->m_pNext->m_pPrev = node;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+32], edx
$LN3@UpdateOpen:

; 903  : 			}
; 904  : 			temp->m_pNext = node;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 905  : 		}
; 906  : 		else

	jmp	SHORT $LN10@UpdateOpen
$LN4@UpdateOpen:

; 907  : 		{
; 908  : 			node->m_pNext = m_pOpen;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR [edx+28], ecx

; 909  : 			node->m_pPrev = NULL;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+32], 0

; 910  : 			if(node->m_pNext)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN1@UpdateOpen

; 911  : 			{
; 912  : 				node->m_pNext->m_pPrev = node;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@UpdateOpen:

; 913  : 			}
; 914  : 			m_pOpen = node;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+84], edx
$LN10@UpdateOpen:

; 915  : 		}
; 916  : 	}
; 917  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP	; CvAStar::UpdateOpenNode
_TEXT	ENDS
PUBLIC	?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ		; CvAStar::Pop
PUBLIC	?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z		; CvAStar::Push
; Function compile flags: /Odtp
;	COMDAT ?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
tv152 = -48						; size = 4
tv150 = -44						; size = 4
_this$ = -40						; size = 4
$T221742 = -36						; size = 4
$T221741 = -32						; size = 4
$T221733 = -28						; size = 4
$T221732 = -24						; size = 4
_iNumChildren$ = -20					; size = 4
_kid$ = -16						; size = 4
_parent$ = -12						; size = 4
_i$ = -8						; size = 4
_iKnownCost$ = -4					; size = 4
_node$ = 8						; size = 4
?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC	; CvAStar::UpdateParents, COMDAT
; _this$ = ecx

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 923  : 	CvAStarNode* kid;
; 924  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 925  : 	CvAStarNode* parent;
; 926  : #endif
; 927  : 	int iKnownCost;
; 928  : 	int iNumChildren;
; 929  : 	int i;
; 930  : 
; 931  : 	FAssert(m_pStackHead == NULL);
; 932  : 
; 933  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 934  : 	CvAStarNode* parent = node;
; 935  : #else
; 936  : 	parent = node;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _parent$[ebp], eax
$LN7@UpdatePare:

; 937  : #endif
; 938  : 
; 939  : 	while(parent != NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	je	$LN8@UpdatePare

; 940  : 	{
; 941  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 942  : 		iNumChildren = parent->m_apChildren.size();
; 943  : #else
; 944  : 		iNumChildren = parent->m_iNumChildren;

	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+84]
	mov	DWORD PTR _iNumChildren$[ebp], edx

; 945  : #endif
; 946  : 
; 947  : 		for(i = 0; i < iNumChildren; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@UpdatePare
$LN4@UpdatePare:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@UpdatePare:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iNumChildren$[ebp]
	jge	$LN3@UpdatePare

; 948  : 		{
; 949  : 			kid = parent->m_apChildren[i];

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _kid$[ebp], edx

; 950  : 
; 951  : 			iKnownCost = (parent->m_iKnownCost + udFunc(udCost, parent, kid, 0, m_pData));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T221733[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T221732[ebp], eax
	cmp	DWORD PTR $T221732[ebp], 0
	je	SHORT $LN14@UpdatePare
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221733[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _kid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	DWORD PTR $T221732[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN12@UpdatePare
$LN14@UpdatePare:
	mov	DWORD PTR tv150[ebp], 1
$LN12@UpdatePare:
	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR _iKnownCost$[ebp], eax

; 952  : 
; 953  : 			if(iKnownCost < kid->m_iKnownCost)

	mov	ecx, DWORD PTR _kid$[ebp]
	mov	edx, DWORD PTR _iKnownCost$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	$LN2@UpdatePare

; 954  : 			{
; 955  : 				kid->m_iKnownCost = iKnownCost;

	mov	eax, DWORD PTR _kid$[ebp]
	mov	ecx, DWORD PTR _iKnownCost$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 956  : 				kid->m_iTotalCost = kid->m_iKnownCost + kid->m_iHeuristicCost;

	mov	edx, DWORD PTR _kid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _kid$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _kid$[ebp]
	mov	DWORD PTR [edx], eax

; 957  : 				FAssert(parent->m_pParent != kid);
; 958  : 				kid->m_pParent = parent;

	mov	eax, DWORD PTR _kid$[ebp]
	mov	ecx, DWORD PTR _parent$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 959  : 				if(kid->m_eCvAStarListType == CVASTARLIST_OPEN)

	mov	edx, DWORD PTR _kid$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN1@UpdatePare

; 960  : 				{
; 961  : 					UpdateOpenNode(kid);

	mov	eax, DWORD PTR _kid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateOpenNode@CvAStar@@IAEXPAVCvAStarNode@@@Z ; CvAStar::UpdateOpenNode
$LN1@UpdatePare:

; 962  : 				}
; 963  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 964  : 				else
; 965  : 				{
; 966  : 					Push(kid); // Kid cannot be a parent if it's in the open list, since adding children goes through GetBest(), which adds the node to the closed list
; 967  : 				}
; 968  : #endif
; 969  : 				udFunc(udNotifyChild, parent, kid, ASNC_PARENTADD_UP, m_pData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221742[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T221741[ebp], ecx
	cmp	DWORD PTR $T221741[ebp], 0
	je	SHORT $LN18@UpdatePare
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T221742[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _kid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	DWORD PTR $T221741[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN16@UpdatePare
$LN18@UpdatePare:
	mov	DWORD PTR tv152[ebp], 1
$LN16@UpdatePare:

; 970  : 
; 971  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 972  : 				Push(kid);

	mov	eax, DWORD PTR _kid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z	; CvAStar::Push
$LN2@UpdatePare:

; 973  : #endif
; 974  : 			}
; 975  : 		}

	jmp	$LN4@UpdatePare
$LN3@UpdatePare:

; 976  : 
; 977  : 		parent = Pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ	; CvAStar::Pop
	mov	DWORD PTR _parent$[ebp], eax

; 978  : 	}

	jmp	$LN7@UpdatePare
$LN8@UpdatePare:

; 979  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateParents@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP	; CvAStar::UpdateParents
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_node$ = 8						; size = 4
?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z PROC		; CvAStar::Push, COMDAT
; _this$ = ecx

; 984  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 985  : 	if(node->m_bOnStack)

	mov	eax, DWORD PTR _node$[ebp]
	movzx	ecx, BYTE PTR [eax+86]
	test	ecx, ecx
	je	SHORT $LN3@Push

; 986  : 	{
; 987  : 		return;

	jmp	SHORT $LN4@Push
$LN3@Push:

; 988  : 	}
; 989  : 
; 990  : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 991  : 	if(m_pStackHead == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+100], 0
	jne	SHORT $LN2@Push

; 992  : 	{
; 993  : 		m_pStackHead = &(m_ppaaNodes[node->m_iX][node->m_iY]);

	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [edx+82]
	imul	edx, 96					; 00000060H
	add	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], edx

; 994  : 	}
; 995  : 	else

	jmp	SHORT $LN1@Push
$LN2@Push:

; 996  : #endif
; 997  : 	{
; 998  : 		FAssert(node->m_pStack == NULL);
; 999  : 		node->m_pStack = m_pStackHead;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR [ecx+36], eax

; 1000 : 		m_pStackHead = node;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+100], edx
$LN1@Push:

; 1001 : 	}
; 1002 : 
; 1003 : 	node->m_bOnStack = true;

	mov	eax, DWORD PTR _node$[ebp]
	mov	BYTE PTR [eax+86], 1
$LN4@Push:

; 1004 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Push@CvAStar@@IAEXPAVCvAStarNode@@@Z ENDP		; CvAStar::Push
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_node$ = -4						; size = 4
?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ PROC		; CvAStar::Pop, COMDAT
; _this$ = ecx

; 1009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 1011 : 	CvAStarNode* node;
; 1012 : #endif
; 1013 : 
; 1014 : 	if(m_pStackHead == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	jne	SHORT $LN1@Pop

; 1015 : 	{
; 1016 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN2@Pop
$LN1@Pop:

; 1017 : 	}
; 1018 : 
; 1019 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1020 : 	CvAStarNode* node = m_pStackHead;
; 1021 : #else
; 1022 : 	node = m_pStackHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _node$[ebp], edx

; 1023 : #endif
; 1024 : 	m_pStackHead = m_pStackHead->m_pStack;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR [edx+100], eax

; 1025 : 	node->m_pStack = NULL;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 1026 : 
; 1027 : 	node->m_bOnStack = false;

	mov	edx, DWORD PTR _node$[ebp]
	mov	BYTE PTR [edx+86], 0

; 1028 : 
; 1029 : 	return node;

	mov	eax, DWORD PTR _node$[ebp]
$LN2@Pop:

; 1030 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@CvAStar@@IAEPAVCvAStarNode@@XZ ENDP		; CvAStar::Pop
_TEXT	ENDS
PUBLIC	?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z	; UnitPathInitialize
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?isNoRevealMap@CvUnit@@QBE_NXZ:PROC		; CvUnit::isNoRevealMap
EXTRN	?IsImmobile@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsImmobile
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
; Function compile flags: /Odtp
;	COMDAT ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T221769 = -17						; size = 1
$T221760 = -16						; size = 4
_i$219211 = -12						; size = 4
_pUnit$ = -8						; size = 4
_pCacheData$ = -4					; size = 4
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z PROC		; UnitPathInitialize, COMDAT

; 1072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1073 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 1074 : 
; 1075 : 	UnitPathCacheData* pCacheData = reinterpret_cast<UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[ebp]
	add	ecx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], ecx

; 1076 : 
; 1077 : 	for (int i = 0; i < NUM_DOMAIN_TYPES; ++i)

	mov	DWORD PTR _i$219211[ebp], 0
	jmp	SHORT $LN3@UnitPathIn
$LN2@UnitPathIn:
	mov	edx, DWORD PTR _i$219211[ebp]
	add	edx, 1
	mov	DWORD PTR _i$219211[ebp], edx
$LN3@UnitPathIn:
	cmp	DWORD PTR _i$219211[ebp], 5
	jge	SHORT $LN1@UnitPathIn

; 1078 : 	{
; 1079 : 		pCacheData->m_aBaseMoves[i] = pUnit->baseMoves((DomainTypes)i);

	mov	eax, DWORD PTR _i$219211[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	mov	ecx, DWORD PTR _i$219211[ebp]
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1080 : 	}

	jmp	SHORT $LN2@UnitPathIn
$LN1@UnitPathIn:

; 1081 : 
; 1082 : 	pCacheData->m_iMaxMoves = pUnit->maxMoves();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1083 : 
; 1084 : 	pCacheData->m_ePlayerID = pUnit->getOwner();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T221760[ebp], eax
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR $T221760[ebp]
	mov	DWORD PTR [ecx+24], edx

; 1085 : 	pCacheData->m_eTeamID = pUnit->getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1086 : 	pCacheData->m_eDomainType = pUnit->getDomainType();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	DWORD PTR [edx+32], eax

; 1087 : 	pCacheData->m_bIsHuman = pUnit->isHuman();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [ecx+36], al

; 1088 : 	pCacheData->m_bIsAutomated = pUnit->IsAutomated();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [edx+37], al

; 1089 : 	pCacheData->m_bIsImmobile = pUnit->IsImmobile();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsImmobile@CvUnit@@QBE_NXZ		; CvUnit::IsImmobile
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [ecx+38], al

; 1090 : 	pCacheData->m_bIsNoRevealMap = pUnit->isNoRevealMap();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isNoRevealMap@CvUnit@@QBE_NXZ		; CvUnit::isNoRevealMap
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [edx+39], al

; 1091 : 	pCacheData->m_bCanEverEmbark = pUnit->CanEverEmbark();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [ecx+40], al

; 1092 : 	pCacheData->m_bIsEmbarked = pUnit->isEmbarked();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	al, BYTE PTR [edx+1652]
	mov	BYTE PTR $T221769[ebp], al
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR $T221769[ebp]
	mov	BYTE PTR [ecx+41], dl

; 1093 : 	pCacheData->m_bCanAttack = pUnit->IsCanAttack();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [ecx+42], al

; 1094 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 1095 : 	pCacheData->m_iBaseCombatStrengthConsideringDamage = 0;
; 1096 : 	if (!pCacheData->m_bIsHuman || pCacheData->m_bIsAutomated)
; 1097 : 		pCacheData->m_iBaseCombatStrengthConsideringDamage = pUnit->GetBaseCombatStrengthConsideringDamage();
; 1098 : #endif
; 1099 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ENDP		; UnitPathInitialize
_TEXT	ENDS
PUBLIC	?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z	; UnitPathUninitialize
; Function compile flags: /Odtp
;	COMDAT ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z PROC	; UnitPathUninitialize, COMDAT

; 1103 : {

	push	ebp
	mov	ebp, esp

; 1104 : 
; 1105 : }

	pop	ebp
	ret	0
?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ENDP	; UnitPathUninitialize
_TEXT	ENDS
PUBLIC	?PathDest@@YAHHHPBXPAVCvAStar@@@Z		; PathDest
; Function compile flags: /Odtp
;	COMDAT ?PathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T221781 = -8						; size = 4
$T221777 = -4						; size = 4
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?PathDest@@YAHHHPBXPAVCvAStar@@@Z PROC			; PathDest, COMDAT

; 1113 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1114 : 	if(iToX == finder->GetDestX() && iToY == finder->GetDestY())

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR $T221777[ebp], ecx
	mov	edx, DWORD PTR _iToX$[ebp]
	cmp	edx, DWORD PTR $T221777[ebp]
	jne	SHORT $LN2@PathDest
	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T221781[ebp], ecx
	mov	edx, DWORD PTR _iToY$[ebp]
	cmp	edx, DWORD PTR $T221781[ebp]
	jne	SHORT $LN2@PathDest

; 1115 : 	{
; 1116 : #ifdef AUI_WARNING_FIXES
; 1117 : 		return TRUE;
; 1118 : #else
; 1119 : 		return true;

	mov	eax, 1
	jmp	SHORT $LN3@PathDest

; 1120 : #endif
; 1121 : 	}
; 1122 : 	else

	jmp	SHORT $LN3@PathDest
$LN2@PathDest:

; 1123 : 	{
; 1124 : #ifdef AUI_WARNING_FIXES
; 1125 : 		return FALSE;
; 1126 : #else
; 1127 : 		return false;

	xor	eax, eax
$LN3@PathDest:

; 1128 : #endif
; 1129 : 	}
; 1130 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP			; PathDest
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z		; PathDestValid
EXTRN	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canMoveOrAttackInto
EXTRN	?IsDeclareWar@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsDeclareWar
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?IsAllowsWalkWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsAllowsWalkWater
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Odtp
;	COMDAT ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T221870 = -84						; size = 4
$T221866 = -80						; size = 4
$T221862 = -76						; size = 4
$T221858 = -72						; size = 4
$T221854 = -68						; size = 4
$T221845 = -64						; size = 4
$T221836 = -53						; size = 1
_uiOffset$221831 = -52					; size = 4
$T221816 = -48						; size = 4
$T221812 = -41						; size = 1
$T221793 = -40						; size = 4
$T221787 = -36						; size = 4
_bMoveFlags$219254 = -29				; size = 1
_pCity$219250 = -28					; size = 4
_pUnit$ = -24						; size = 4
_pCacheData$ = -16					; size = 4
_eTeam$ = -12						; size = 4
_pToPlot$ = -8						; size = 4
_bToPlotRevealed$ = -1					; size = 1
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC		; PathDestValid, COMDAT

; 1140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 1141 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1142 : 	CvPlot* pToPlot = GC.getMap().plotCheckInvalid(iToX, iToY);
; 1143 : #else
; 1144 : 	CvUnit* pUnit;
; 1145 : 	CvPlot* pToPlot;
; 1146 : 	bool bAIControl;
; 1147 : 
; 1148 : 	pToPlot = GC.getMap().plotCheckInvalid(iToX, iToY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T221787[ebp], eax
	cmp	DWORD PTR _iToX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN20@PathDestVa
	cmp	DWORD PTR _iToY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN21@PathDestVa
$LN20@PathDestVa:
	mov	DWORD PTR _pToPlot$[ebp], 0
	jmp	SHORT $LN22@PathDestVa
$LN21@PathDestVa:
	mov	ecx, DWORD PTR $T221787[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T221793[ebp], edx
	mov	eax, DWORD PTR _iToY$[ebp]
	imul	eax, DWORD PTR $T221793[ebp]
	add	eax, DWORD PTR _iToX$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T221787[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$[ebp], eax
$LN22@PathDestVa:

; 1149 : #endif
; 1150 : 	FAssert(pToPlot != NULL);
; 1151 : 
; 1152 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1153 : 	CvUnit* pUnit = (CvUnit*)pointer;
; 1154 : #else
; 1155 : 	pUnit = ((CvUnit*)pointer);

	mov	edx, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], edx

; 1156 : #endif
; 1157 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	eax, DWORD PTR _finder$[ebp]
	add	eax, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], eax

; 1158 : 
; 1159 : 	if(pToPlot == NULL || pUnit == NULL)

	cmp	DWORD PTR _pToPlot$[ebp], 0
	je	SHORT $LN14@PathDestVa
	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN15@PathDestVa
$LN14@PathDestVa:

; 1160 : 		return FALSE;

	xor	eax, eax
	jmp	$LN16@PathDestVa
$LN15@PathDestVa:

; 1161 : 
; 1162 : 	if(pUnit->plot() == pToPlot)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, DWORD PTR _pToPlot$[ebp]
	jne	SHORT $LN13@PathDestVa

; 1163 : 	{
; 1164 : 		return TRUE;

	mov	eax, 1
	jmp	$LN16@PathDestVa
$LN13@PathDestVa:

; 1165 : 	}
; 1166 : 
; 1167 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 1168 : 	if(pToPlot->isMountain() && (!pCacheData->isHuman() || pCacheData->IsAutomated()))
; 1169 : 	{
; 1170 : 		return FALSE;
; 1171 : 	}
; 1172 : #endif
; 1173 : 
; 1174 : 	if(pCacheData->IsImmobile())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+38]
	mov	BYTE PTR $T221812[ebp], dl
	movzx	eax, BYTE PTR $T221812[ebp]
	test	eax, eax
	je	SHORT $LN12@PathDestVa

; 1175 : 	{
; 1176 : 		return FALSE;

	xor	eax, eax
	jmp	$LN16@PathDestVa
$LN12@PathDestVa:

; 1177 : 	}
; 1178 : 
; 1179 : 	if ((finder->GetInfo() & CvUnit::MOVEFLAG_STAY_ON_LAND) && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()))

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T221816[ebp], edx
	mov	eax, DWORD PTR $T221816[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN11@PathDestVa
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@PathDestVa
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@PathDestVa

; 1180 : 	{
; 1181 : 		return FALSE;

	xor	eax, eax
	jmp	$LN16@PathDestVa
$LN11@PathDestVa:

; 1182 : 	}
; 1183 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 1184 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1185 : 	bool bAIControl = pCacheData->IsAutomated();
; 1186 : #else
; 1187 : 	bAIControl = pCacheData->IsAutomated();
; 1188 : #endif
; 1189 : 
; 1190 : 	if(bAIControl)
; 1191 : 	{
; 1192 : #ifndef AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_PATH
; 1193 : 		if(!(finder->GetInfo() & MOVE_UNITS_IGNORE_DANGER))
; 1194 : 		{
; 1195 : 			if(!pUnit->IsCombatUnit() || pUnit->getArmyID() == FFreeList::INVALID_INDEX)
; 1196 : 			{
; 1197 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 1198 : 				if (GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 1199 : #else
; 1200 : 				if(GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > 0)
; 1201 : #endif
; 1202 : 				{
; 1203 : 					return FALSE;
; 1204 : 				}
; 1205 : 			}
; 1206 : 		}
; 1207 : #endif
; 1208 : 
; 1209 : 		if(pCacheData->getDomainType() == DOMAIN_LAND)
; 1210 : 		{
; 1211 : 			int iGroupAreaID = pUnit->area()->GetID();
; 1212 : 			if(pToPlot->getArea() != iGroupAreaID)
; 1213 : 			{
; 1214 : 				if(!(pToPlot->isAdjacentToArea(iGroupAreaID)) && !pUnit->CanEverEmbark())
; 1215 : 				{
; 1216 : 					return FALSE;
; 1217 : 				}
; 1218 : 			}
; 1219 : 		}
; 1220 : 	}
; 1221 : #endif
; 1222 : 	TeamTypes eTeam = pCacheData->getTeam();

	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _eTeam$[ebp], ecx

; 1223 : 	bool bToPlotRevealed = pToPlot->isRevealed(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$221831[ebp], edx
	mov	eax, DWORD PTR _uiOffset$221831[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$221831[ebp]
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	mov	BYTE PTR _bToPlotRevealed$[ebp], dl

; 1224 : 	if(!bToPlotRevealed)

	movzx	eax, BYTE PTR _bToPlotRevealed$[ebp]
	test	eax, eax
	jne	SHORT $LN10@PathDestVa

; 1225 : 	{
; 1226 : 		if(pCacheData->isNoRevealMap())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+39]
	mov	BYTE PTR $T221836[ebp], dl
	movzx	eax, BYTE PTR $T221836[ebp]
	test	eax, eax
	je	SHORT $LN10@PathDestVa

; 1227 : 		{
; 1228 : 			return FALSE;

	xor	eax, eax
	jmp	$LN16@PathDestVa
$LN10@PathDestVa:

; 1229 : 		}
; 1230 : 	}
; 1231 : 
; 1232 : 	if(bToPlotRevealed)

	movzx	ecx, BYTE PTR _bToPlotRevealed$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@PathDestVa

; 1233 : 	{
; 1234 : 		CvCity* pCity = pToPlot->getPlotCity();

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$219250[ebp], eax

; 1235 : 		if(pCity)

	cmp	DWORD PTR _pCity$219250[ebp], 0
	je	SHORT $LN8@PathDestVa

; 1236 : 		{
; 1237 : 			if(pCacheData->getOwner() != pCity->getOwner() && !GET_TEAM(eTeam).isAtWar(pCity->getTeam()) && !(finder->GetInfo() & MOVE_IGNORE_STACKING))

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T221845[ebp], eax
	mov	ecx, DWORD PTR _pCity$219250[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T221854[ebp], edx
	mov	eax, DWORD PTR $T221845[ebp]
	cmp	eax, DWORD PTR $T221854[ebp]
	je	SHORT $LN8@PathDestVa
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T221858[ebp], ecx
	mov	ecx, DWORD PTR _pCity$219250[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR $T221858[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@PathDestVa
	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T221862[ebp], ecx
	mov	edx, DWORD PTR $T221862[ebp]
	and	edx, 4
	jne	SHORT $LN8@PathDestVa

; 1238 : 			{
; 1239 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN16@PathDestVa
$LN8@PathDestVa:

; 1240 : 			}
; 1241 : 		}
; 1242 : 	}
; 1243 : 
; 1244 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 1245 : 	if(bToPlotRevealed)

	movzx	eax, BYTE PTR _bToPlotRevealed$[ebp]
	test	eax, eax
	je	SHORT $LN5@PathDestVa

; 1246 : #else
; 1247 : 	if(bAIControl || bToPlotRevealed)
; 1248 : #endif
; 1249 : 	{
; 1250 : 		// assume that we can change our embarking state
; 1251 : 		byte bMoveFlags = CvUnit::MOVEFLAG_DESTINATION | CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE;

	mov	BYTE PTR _bMoveFlags$219254[ebp], 132	; 00000084H

; 1252 : 
; 1253 : 		if((pUnit->IsDeclareWar() || (finder->GetInfo() & MOVE_DECLARE_WAR)))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsDeclareWar@CvUnit@@QBE_NXZ		; CvUnit::IsDeclareWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@PathDestVa
	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR $T221866[ebp], eax
	mov	ecx, DWORD PTR $T221866[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN4@PathDestVa
$LN3@PathDestVa:

; 1254 : 		{
; 1255 : 			bMoveFlags |= CvUnit::MOVEFLAG_ATTACK;

	movzx	edx, BYTE PTR _bMoveFlags$219254[ebp]
	or	edx, 1
	mov	BYTE PTR _bMoveFlags$219254[ebp], dl
$LN4@PathDestVa:

; 1256 : 		}
; 1257 : 
; 1258 : 		if(finder->GetInfo() & MOVE_IGNORE_STACKING)

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T221870[ebp], ecx
	mov	edx, DWORD PTR $T221870[ebp]
	and	edx, 4
	je	SHORT $LN2@PathDestVa

; 1259 : 		{
; 1260 : 			bMoveFlags |= CvUnit::MOVEFLAG_IGNORE_STACKING;

	movzx	eax, BYTE PTR _bMoveFlags$219254[ebp]
	or	eax, 16					; 00000010H
	mov	BYTE PTR _bMoveFlags$219254[ebp], al
$LN2@PathDestVa:

; 1261 : 		}
; 1262 : 
; 1263 : 		if(!(pUnit->canMoveOrAttackInto(*pToPlot, bMoveFlags)))

	movzx	ecx, BYTE PTR _bMoveFlags$219254[ebp]
	push	ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@PathDestVa

; 1264 : 		{
; 1265 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN16@PathDestVa
$LN5@PathDestVa:

; 1266 : 		}
; 1267 : 	}
; 1268 : 	return TRUE;

	mov	eax, 1
$LN16@PathDestVa:

; 1269 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP		; PathDestValid
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?PathHeuristic@@YAHHHHH@Z			; PathHeuristic
; Function compile flags: /Odtp
;	COMDAT ?PathHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?PathHeuristic@@YAHHHHH@Z PROC				; PathHeuristic, COMDAT

; 1275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 1276 : 	return (plotDistance(iFromX, iFromY, iToX, iToY) * PATH_MOVEMENT_WEIGHT);

	mov	eax, DWORD PTR _iToY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iToX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFromY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFromX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	imul	eax, 1000				; 000003e8H

; 1277 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathHeuristic@@YAHHHHH@Z ENDP				; PathHeuristic
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T222041 = -80						; size = 4
$T222014 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T222014[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T222014[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T222014[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T222041[ebp], edx
	mov	eax, DWORD PTR $T222041[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T222064 = -16						; size = 4
$T222056 = -12						; size = 4
$T222052 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T222052[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T222056[ebp], ecx
	movzx	edx, BYTE PTR $T222052[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T222056[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T222056[ebp]
	mov	DWORD PTR $T222064[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T222056[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T222056[ebp]
	mov	DWORD PTR $T222064[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T222064[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T222064[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T222085 = -16						; size = 4
$T222077 = -12						; size = 4
$T222073 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T222073[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T222077[ebp], ecx
	movzx	edx, BYTE PTR $T222073[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T222077[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T222077[ebp]
	mov	DWORD PTR $T222085[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T222077[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T222077[ebp]
	mov	DWORD PTR $T222085[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T222085[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T222085[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
PUBLIC	?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
EXTRN	?isRiverCrossingNoPenalty@CvUnit@@QBE_NXZ:PROC	; CvUnit::isRiverCrossingNoPenalty
EXTRN	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossing
EXTRN	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyDefender
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
EXTRN	?noDefensiveBonus@CvUnit@@QBE_NXZ:PROC		; CvUnit::noDefensiveBonus
EXTRN	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::getNumAdjacentNonrevealed
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z:PROC ; CvUnit::isHasPromotion
EXTRN	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z:PROC ; CvPlot::getNumFriendlyUnitsOfType
EXTRN	?getExtraMovePathCost@CvPlot@@QBEHXZ:PROC	; CvPlot::getExtraMovePathCost
EXTRN	?getTurnDamage@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getTurnDamage
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z:PROC ; CvUnit::canEmbarkOnto
EXTRN	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCost
EXTRN	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z:PROC ; CvUnitMovement::IsSlowedByZOC
EXTRN	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z:PROC ; CvUnitMovement::ConsumesAllMoves
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv407 = -352						; size = 4
tv425 = -348						; size = 4
tv354 = -344						; size = 4
tv390 = -340						; size = 4
tv313 = -336						; size = 4
tv513 = -332						; size = 4
tv94 = -328						; size = 4
$T222482 = -324						; size = 4
$T222420 = -272						; size = 4
$T222414 = -267						; size = 1
$T222409 = -266						; size = 1
$T222405 = -265						; size = 1
$T222398 = -264						; size = 4
$T222384 = -258						; size = 1
$T222380 = -257						; size = 1
_uiOffset$222375 = -256					; size = 4
$T222366 = -252						; size = 4
_playerID$222363 = -248					; size = 4
$T222349 = -244						; size = 4
$T222345 = -240						; size = 4
$T222341 = -236						; size = 4
$T222337 = -232						; size = 4
_playerID$222331 = -228					; size = 4
$T222314 = -224						; size = 4
$T222301 = -220						; size = 4
$T222295 = -216						; size = 4
$T222291 = -212						; size = 4
$T222287 = -208						; size = 4
$T222283 = -204						; size = 4
$T222276 = -198						; size = 1
$T222272 = -197						; size = 1
$T222268 = -196						; size = 4
$T222264 = -190						; size = 1
$T222260 = -189						; size = 1
$T222253 = -188						; size = 4
$T222249 = -184						; size = 4
$T222245 = -180						; size = 4
$T222241 = -176						; size = 4
$T222234 = -172						; size = 4
$T222228 = -168						; size = 4
_f$222224 = -162					; size = 1
_f$222214 = -161					; size = 1
$T222206 = -160						; size = 4
$T222196 = -156						; size = 4
$T222189 = -152						; size = 4
$T222188 = -148						; size = 4
$T222184 = -144						; size = 4
$T222180 = -140						; size = 4
$T222176 = -133						; size = 1
$T222169 = -132						; size = 4
$T222165 = -128						; size = 4
$T222161 = -124						; size = 4
$T222157 = -120						; size = 4
$T222156 = -116						; size = 4
$T222130 = -112						; size = 4
$T222114 = -108						; size = 4
$T222105 = -104						; size = 4
$T222102 = -100						; size = 4
$T222101 = -96						; size = 4
$T222098 = -92						; size = 4
$T222095 = -88						; size = 4
$T222094 = -84						; size = 4
_iUnseenPlots$219324 = -80				; size = 4
_ePlotTeam$219318 = -76					; size = 4
_pDestPlot$219315 = -72					; size = 4
_ePlotOwner$219314 = -68				; size = 4
_kMap$ = -64						; size = 4
_pUnit$ = -60						; size = 4
_bMaximizeExplore$ = -53				; size = 1
_iMovesLeft$ = -52					; size = 4
_iFromPlotX$ = -48					; size = 4
_iFromPlotY$ = -44					; size = 4
_pCacheData$ = -40					; size = 4
_eUnitDomain$ = -36					; size = 4
_iMax$ = -32						; size = 4
_iToPlotX$ = -28					; size = 4
_eUnitTeam$ = -24					; size = 4
_pFromPlot$ = -20					; size = 4
_iToPlotY$ = -16					; size = 4
_iCost$ = -12						; size = 4
_bToPlotIsWater$ = -5					; size = 1
_pToPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; PathCost, COMDAT

; 1282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H

; 1283 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 1284 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1285 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 1286 : 	const CvPlot* pToPlot = node->m_pPlot;
; 1287 : 
; 1288 : 	const int iFromPlotX = parent->m_iX;
; 1289 : 	const int iFromPlotY = parent->m_iY;
; 1290 : 	const int iToPlotX = node->m_iX;
; 1291 : 	const int iToPlotY = node->m_iY;
; 1292 : #else
; 1293 : 	int iFromPlotX = parent->m_iX;

	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	DWORD PTR _iFromPlotX$[ebp], edx

; 1294 : 	int iFromPlotY = parent->m_iY;

	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR _iFromPlotY$[ebp], ecx

; 1295 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T222114[ebp], eax
	mov	ecx, DWORD PTR _iFromPlotY$[ebp]
	imul	ecx, DWORD PTR $T222114[ebp]
	add	ecx, DWORD PTR _iFromPlotX$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], ecx

; 1296 : 
; 1297 : 	int iToPlotX = node->m_iX;

	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR _iToPlotX$[ebp], ecx

; 1298 : 	int iToPlotY = node->m_iY;

	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	DWORD PTR _iToPlotY$[ebp], eax

; 1299 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T222130[ebp], edx
	mov	eax, DWORD PTR _iToPlotY$[ebp]
	imul	eax, DWORD PTR $T222130[ebp]
	add	eax, DWORD PTR _iToPlotX$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$[ebp], eax

; 1300 : #endif
; 1301 : 
; 1302 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	edx, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], edx

; 1303 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	eax, DWORD PTR _finder$[ebp]
	add	eax, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], eax

; 1304 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1305 : 	bool bIsAIControl = !pCacheData->isHuman() || pCacheData->IsAutomated();
; 1306 : #endif
; 1307 : 
; 1308 : 	DomainTypes eUnitDomain = pCacheData->getDomainType();

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _eUnitDomain$[ebp], edx

; 1309 : 
; 1310 : 	CvAssertMsg(eUnitDomain != DOMAIN_AIR, "pUnit->getDomainType() is not expected to be equal with DOMAIN_AIR");
; 1311 : 
; 1312 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION) || defined (AUI_UNIT_FIX_HOVERING_EMBARK) || defined(AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK)
; 1313 : 	bool bToPlotIsWater = !pToPlot->IsAllowsWalkWater();
; 1314 : 	bool bFromPlotIsWater = !pFromPlot->IsAllowsWalkWater();
; 1315 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1316 : 	if (pUnit->IsHoveringUnit())
; 1317 : 	{
; 1318 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1319 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1320 : 	}
; 1321 : 	else
; 1322 : #endif
; 1323 : 	{
; 1324 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->isWater();
; 1325 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->isWater();
; 1326 : 	}
; 1327 : 	int iBaseMoves = pCacheData->baseMoves(bFromPlotIsWater || pCacheData->isEmbarked() ? DOMAIN_SEA : pCacheData->getDomainType());
; 1328 : 	int iMaxMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 1329 : #else
; 1330 : 	bool bToPlotIsWater = pToPlot->isWater() && !pToPlot->IsAllowsWalkWater();

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN42@PathCost
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN42@PathCost
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN43@PathCost
$LN42@PathCost:
	mov	DWORD PTR tv94[ebp], 0
$LN43@PathCost:
	mov	dl, BYTE PTR tv94[ebp]
	mov	BYTE PTR _bToPlotIsWater$[ebp], dl

; 1331 : #endif
; 1332 : 	int iMax;
; 1333 : 	if(parent->m_iData1 > 0)

	mov	eax, DWORD PTR _parent$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN39@PathCost

; 1334 : 	{
; 1335 : 		iMax = parent->m_iData1;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _iMax$[ebp], edx

; 1336 : 	}
; 1337 : 	else

	jmp	$LN84@PathCost
$LN39@PathCost:

; 1338 : 	{
; 1339 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1340 : 		iMax = iMaxMoves;
; 1341 : #else
; 1342 : 		if (CvUnitMovement::ConsumesAllMoves(pUnit, pFromPlot, pToPlot) || CvUnitMovement::IsSlowedByZOC(pUnit, pFromPlot, pToPlot))

	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN74@PathCost
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN37@PathCost

; 1343 : 		{
; 1344 : 			// The movement would consume all moves, get the moves we will forfeit based on the source plot, rather than
; 1345 : 			// the destination plot.  This fixes issues where a land unit that has more movement points on water than on land
; 1346 : 			// would have a very high cost to move onto water if their first move of the turn was at the edge of the water.
; 1347 : 			iMax = pCacheData->baseMoves((pFromPlot->isWater() && !pFromPlot->IsAllowsWalkWater())?DOMAIN_SEA:DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

$LN74@PathCost:
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN44@PathCost
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN44@PathCost
	mov	DWORD PTR $T222156[ebp], 0
	jmp	SHORT $LN45@PathCost
$LN44@PathCost:
	mov	DWORD PTR $T222156[ebp], 2
$LN45@PathCost:
	mov	ecx, DWORD PTR $T222156[ebp]
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T222157[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T222161[ebp], ecx
	mov	edx, DWORD PTR $T222157[ebp]
	imul	edx, DWORD PTR $T222161[ebp]
	mov	DWORD PTR _iMax$[ebp], edx

; 1348 : 		}
; 1349 : 		else

	jmp	SHORT $LN84@PathCost
$LN37@PathCost:

; 1350 : 			iMax = pCacheData->baseMoves(bToPlotIsWater?DOMAIN_SEA:DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	movzx	eax, BYTE PTR _bToPlotIsWater$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 2
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T222165[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T222169[ebp], eax
	mov	ecx, DWORD PTR $T222165[ebp]
	imul	ecx, DWORD PTR $T222169[ebp]
	mov	DWORD PTR _iMax$[ebp], ecx

; 1351 : #endif
; 1352 : 	}
; 1353 : 
; 1354 : 	// Get the cost of moving to the new plot, passing in our max moves or the moves we have left, in case the movementCost 
; 1355 : 	// method wants to burn all our remaining moves.  This is needed because our remaining moves for this segment of the path
; 1356 : 	// may be larger or smaller than the baseMoves if some moves have already been used or if the starting domain (LAND/SEA)
; 1357 : 	// of the path segment is different from the destination plot.
; 1358 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1359 : 	int iCost = CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, iBaseMoves, iMaxMoves, iMax);
; 1360 : #else
; 1361 : 	int iCost = CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves(), iMax);

$LN84@PathCost:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN46@PathCost
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+41]
	mov	BYTE PTR $T222176[ebp], cl
	movzx	edx, BYTE PTR $T222176[ebp]
	test	edx, edx
	jne	SHORT $LN46@PathCost
	mov	eax, DWORD PTR $T222180[ebp]
	mov	DWORD PTR $T222188[ebp], eax
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR $T222188[ebp], edx
	jmp	SHORT $LN47@PathCost
$LN46@PathCost:
	mov	DWORD PTR $T222188[ebp], 0
$LN47@PathCost:
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T222184[ebp], ecx
	mov	edx, DWORD PTR $T222188[ebp]
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T222189[ebp], ecx
	mov	edx, DWORD PTR _iMax$[ebp]
	push	edx
	mov	eax, DWORD PTR $T222184[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222189[ebp]
	push	ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	call	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost
	add	esp, 24					; 00000018H
	mov	DWORD PTR _iCost$[ebp], eax

; 1362 : #endif
; 1363 : 
; 1364 : 	TeamTypes eUnitTeam = pCacheData->getTeam();

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 1365 : #ifdef AUI_ASTAR_EXPLORE_UNITAITYPE_ALWAYS_MAXIMIZES_EXPLORE
; 1366 : 	bool bMaximizeExplore = finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA;
; 1367 : #else
; 1368 : 	bool bMaximizeExplore = finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE;

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T222196[ebp], edx
	mov	eax, DWORD PTR $T222196[ebp]
	and	eax, 128				; 00000080H
	setne	cl
	mov	BYTE PTR _bMaximizeExplore$[ebp], cl

; 1369 : #endif
; 1370 : 
; 1371 : 	int iMovesLeft = iMax - iCost;

	mov	edx, DWORD PTR _iMax$[ebp]
	sub	edx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iMovesLeft$[ebp], edx

; 1372 : 	// Is the cost greater than our max?
; 1373 : 	if (iMovesLeft < 0)

	jns	SHORT $LN34@PathCost

; 1374 : 	{
; 1375 : 		// Yes, we will still let the move happen, but that is the end of the turn.
; 1376 : 		iCost = iMax;

	mov	eax, DWORD PTR _iMax$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 1377 : 		iMovesLeft = 0;

	mov	DWORD PTR _iMovesLeft$[ebp], 0
$LN34@PathCost:

; 1378 : 	}
; 1379 : 
; 1380 : 	if(iMovesLeft == 0)

	cmp	DWORD PTR _iMovesLeft$[ebp], 0
	jne	$LN33@PathCost

; 1381 : 	{
; 1382 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	mov	ecx, DWORD PTR _iCost$[ebp]
	imul	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], ecx

; 1383 : 
; 1384 : #ifdef AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK
; 1385 : 		if (eUnitDomain == DOMAIN_LAND && !bFromPlotIsWater && bToPlotIsWater && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))
; 1386 : #else
; 1387 : 		if(eUnitDomain == DOMAIN_LAND && !pFromPlot->isWater() && bToPlotIsWater && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	cmp	DWORD PTR _eUnitDomain$[ebp], 2
	jne	SHORT $LN32@PathCost
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN32@PathCost
	movzx	eax, BYTE PTR _bToPlotIsWater$[ebp]
	test	eax, eax
	je	SHORT $LN32@PathCost
	push	0
	push	1
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN32@PathCost

; 1388 : #endif
; 1389 : 		{
; 1390 : 			iCost += PATH_INCORRECT_EMBARKING_WEIGHT;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 1000000				; 000f4240H
	mov	DWORD PTR _iCost$[ebp], ecx
$LN32@PathCost:

; 1391 : 		}
; 1392 : 
; 1393 : 		if(bMaximizeExplore)

	movzx	edx, BYTE PTR _bMaximizeExplore$[ebp]
	test	edx, edx
	je	SHORT $LN31@PathCost

; 1394 : 		{
; 1395 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_UNHARDCODE_HILL_PREFERENCE
; 1396 : 			iCost += PATH_EXPLORE_NON_HILL_WEIGHT * (2 - pToPlot->seeFromLevel(eUnitTeam));
; 1397 : #else
; 1398 : 			if(!pToPlot->isHills())

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN31@PathCost

; 1399 : 			{
; 1400 : 				iCost += PATH_EXPLORE_NON_HILL_WEIGHT;

	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, 300				; 0000012cH
	mov	DWORD PTR _iCost$[ebp], eax
$LN31@PathCost:

; 1401 : 			}
; 1402 : #endif
; 1403 : 		}
; 1404 : 
; 1405 : 		// Damage caused by features (mods)
; 1406 : 		if(0 != GC.getPATH_DAMAGE_WEIGHT())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944
	mov	DWORD PTR $T222206[ebp], ecx
	cmp	DWORD PTR $T222206[ebp], 0
	je	$LN29@PathCost

; 1407 : 		{
; 1408 : 			if(pToPlot->getFeatureType() != NO_FEATURE)

	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$222214[ebp], al
	movsx	ecx, BYTE PTR _f$222214[ebp]
	cmp	ecx, -1
	je	$LN28@PathCost

; 1409 : 			{
; 1410 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1411 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * MAX(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();
; 1412 : #else
; 1413 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * std::max(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();

	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$222224[ebp], al
	movsx	ecx, BYTE PTR _f$222224[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getTurnDamage@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getTurnDamage
	mov	DWORD PTR $T222094[ebp], eax
	mov	DWORD PTR $T222095[ebp], 0
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944
	mov	DWORD PTR $T222228[ebp], edx
	mov	eax, DWORD PTR $T222095[ebp]
	cmp	eax, DWORD PTR $T222094[ebp]
	jge	SHORT $LN116@PathCost
	lea	ecx, DWORD PTR $T222094[ebp]
	mov	DWORD PTR tv513[ebp], ecx
	jmp	SHORT $LN117@PathCost
$LN116@PathCost:
	lea	edx, DWORD PTR $T222095[ebp]
	mov	DWORD PTR tv513[ebp], edx
$LN117@PathCost:
	mov	eax, DWORD PTR tv513[ebp]
	mov	DWORD PTR $T222234[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T222241[ebp], ecx
	mov	edx, DWORD PTR $T222234[ebp]
	mov	eax, DWORD PTR $T222228[ebp]
	imul	eax, DWORD PTR [edx]
	cdq
	idiv	DWORD PTR $T222241[ebp]
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN28@PathCost:

; 1414 : #endif
; 1415 : 			}
; 1416 : 
; 1417 : 			if(pToPlot->getExtraMovePathCost() > 0)

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	test	eax, eax
	jle	SHORT $LN29@PathCost

; 1418 : 			{
; 1419 : 				iCost += (PATH_MOVEMENT_WEIGHT * pToPlot->getExtraMovePathCost());

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	imul	eax, 1000				; 000003e8H
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN29@PathCost:

; 1420 : 			}
; 1421 : 		}
; 1422 : 
; 1423 : 		// Penalty for stacking
; 1424 : 		if(GC.getPLOT_UNIT_LIMIT() > 0 && !(finder->GetInfo() & MOVE_IGNORE_STACKING))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR $T222245[ebp], eax
	cmp	DWORD PTR $T222245[ebp], 0
	jle	SHORT $LN126@PathCost
	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T222249[ebp], edx
	mov	eax, DWORD PTR $T222249[ebp]
	and	eax, 4
	jne	SHORT $LN126@PathCost

; 1425 : 		{
; 1426 : 			// Check to see if any units are present at this full-turn move plot... if the player can see what's there
; 1427 : 			if(pToPlot->getNumFriendlyUnitsOfType(pUnit) >= GC.getPLOT_UNIT_LIMIT())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR $T222253[ebp], ecx
	push	1
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR $T222253[ebp]
	jl	SHORT $LN126@PathCost

; 1428 : 			{
; 1429 : 				iCost += PATH_STACKING_WEIGHT;

	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, 1000000				; 000f4240H
	mov	DWORD PTR _iCost$[ebp], eax

; 1430 : 			}
; 1431 : 		}
; 1432 : 
; 1433 : 		// Penalty for ending a turn on a mountain
; 1434 : 		if(pToPlot->isMountain())

$LN126@PathCost:
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@PathCost

; 1435 : 		{
; 1436 : 			// We want to discourage AIs and automated units from exhausting their movement on a mountain, but if the unit is manually controlled by the human, let them do what they want.
; 1437 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1438 : 			if (bIsAIControl)
; 1439 : #else
; 1440 : 			if (!pCacheData->isHuman() || pCacheData->IsAutomated())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+36]
	mov	BYTE PTR $T222260[ebp], dl
	movzx	eax, BYTE PTR $T222260[ebp]
	test	eax, eax
	je	SHORT $LN22@PathCost
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+37]
	mov	BYTE PTR $T222264[ebp], dl
	movzx	eax, BYTE PTR $T222264[ebp]
	test	eax, eax
	je	SHORT $LN24@PathCost
$LN22@PathCost:

; 1441 : #endif
; 1442 : 			{
; 1443 : 				iCost += PATH_END_TURN_MOUNTAIN_WEIGHT;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 1000000				; 000f4240H
	mov	DWORD PTR _iCost$[ebp], ecx
$LN24@PathCost:

; 1444 : 			}
; 1445 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1446 : 			else
; 1447 : 			{
; 1448 : 				iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 1449 : 			}
; 1450 : #endif
; 1451 : 		}
; 1452 : 
; 1453 : 		if (pUnit->isHasPromotion((PromotionTypes)GC.getPROMOTION_UNWELCOME_EVANGELIST()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8560
	mov	DWORD PTR $T222268[ebp], edx
	mov	eax, DWORD PTR $T222268[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isHasPromotion@CvUnit@@QBE_NW4PromotionTypes@@@Z ; CvUnit::isHasPromotion
	movzx	ecx, al
	test	ecx, ecx
	je	$LN178@PathCost

; 1454 : 		{
; 1455 : 			// Avoid being in a territory that we are not welcome in, unless the human is manually controlling the unit.
; 1456 : #ifndef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1457 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1458 : 			if (bIsAIControl)
; 1459 : #else
; 1460 : 			if (!pCacheData->isHuman() || pCacheData->IsAutomated())

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR $T222272[ebp], al
	movzx	ecx, BYTE PTR $T222272[ebp]
	test	ecx, ecx
	je	SHORT $LN138@PathCost
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+37]
	mov	BYTE PTR $T222276[ebp], al
	movzx	ecx, BYTE PTR $T222276[ebp]
	test	ecx, ecx
	je	$LN20@PathCost

; 1461 : #endif
; 1462 : #endif
; 1463 : 			{
; 1464 : 				// Also, ignore the penalty if the destination of the path is in the same team's territory, no sense in avoiding a place we want to get to.				
; 1465 : 				PlayerTypes ePlotOwner = pToPlot->getOwner();

$LN138@PathCost:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _ePlotOwner$219314[ebp], eax

; 1466 : 				CvPlot* pDestPlot = (finder->GetDestX() >= 0 && finder->GetDestY() >= 0)?kMap.plotCheckInvalid(finder->GetDestX(), finder->GetDestY()):NULL;

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR $T222283[ebp], edx
	cmp	DWORD PTR $T222283[ebp], 0
	jl	$LN48@PathCost
	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T222287[ebp], ecx
	cmp	DWORD PTR $T222287[ebp], 0
	jl	$LN48@PathCost
	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR $T222291[ebp], eax
	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR $T222295[ebp], edx
	mov	eax, DWORD PTR $T222314[ebp]
	mov	DWORD PTR tv313[ebp], eax
	cmp	DWORD PTR $T222295[ebp], -2147483647	; 80000001H
	je	SHORT $LN148@PathCost
	cmp	DWORD PTR $T222291[ebp], -2147483647	; 80000001H
	jne	SHORT $LN149@PathCost
$LN148@PathCost:
	mov	DWORD PTR tv313[ebp], 0
	jmp	SHORT $LN150@PathCost
$LN149@PathCost:
	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T222301[ebp], edx
	mov	eax, DWORD PTR $T222291[ebp]
	imul	eax, DWORD PTR $T222301[ebp]
	add	eax, DWORD PTR $T222295[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv313[ebp], eax
$LN150@PathCost:
	jmp	SHORT $LN49@PathCost
$LN48@PathCost:
	mov	DWORD PTR tv313[ebp], 0
$LN49@PathCost:
	mov	edx, DWORD PTR tv313[ebp]
	mov	DWORD PTR _pDestPlot$219315[ebp], edx

; 1467 : 				if (!pDestPlot || pDestPlot->getOwner() != ePlotOwner)

	cmp	DWORD PTR _pDestPlot$219315[ebp], 0
	je	SHORT $LN162@PathCost
	mov	eax, DWORD PTR _pDestPlot$219315[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR _ePlotOwner$219314[ebp]
	je	$LN20@PathCost

; 1468 : 				{
; 1469 : 					TeamTypes ePlotTeam = pToPlot->getTeam();

$LN162@PathCost:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$222331[ebp], eax
	cmp	DWORD PTR _playerID$222331[ebp], -1
	je	SHORT $LN159@PathCost
	mov	ecx, DWORD PTR _playerID$222331[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlotTeam$219318[ebp], eax
	jmp	SHORT $LN160@PathCost
	jmp	SHORT $LN160@PathCost
$LN159@PathCost:
	mov	DWORD PTR _ePlotTeam$219318[ebp], -1
$LN160@PathCost:

; 1470 : 					if (ePlotOwner != NO_PLAYER && !GET_PLAYER(ePlotOwner).isMinorCiv() && ePlotTeam != pCacheData->getTeam() && !GET_TEAM(ePlotTeam).IsAllowsOpenBordersToTeam(pCacheData->getTeam()))

	cmp	DWORD PTR _ePlotOwner$219314[ebp], -1
	je	$LN20@PathCost
	mov	edx, DWORD PTR _ePlotOwner$219314[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T222337[ebp], edx
	mov	ecx, DWORD PTR $T222337[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN20@PathCost
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T222341[ebp], edx
	mov	eax, DWORD PTR _ePlotTeam$219318[ebp]
	cmp	eax, DWORD PTR $T222341[ebp]
	je	SHORT $LN20@PathCost
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T222345[ebp], edx
	mov	eax, DWORD PTR _ePlotTeam$219318[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T222349[ebp], eax
	mov	ecx, DWORD PTR $T222345[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222349[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@PathCost

; 1471 : 					{
; 1472 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1473 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1474 : 						if (bIsAIControl)
; 1475 : #else
; 1476 : 						if (!pCacheData->isHuman() || pCacheData->IsAutomated())
; 1477 : #endif
; 1478 : 						{
; 1479 : 							iCost += PATH_END_TURN_MISSIONARY_OTHER_TERRITORY;
; 1480 : 						}
; 1481 : 						else
; 1482 : 						{
; 1483 : 							iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 1484 : 						}
; 1485 : #else
; 1486 : 						iCost += PATH_END_TURN_MISSIONARY_OTHER_TERRITORY;

	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, 150000				; 000249f0H
	mov	DWORD PTR _iCost$[ebp], eax
$LN20@PathCost:

; 1487 : #endif
; 1488 : 					}
; 1489 : 				}
; 1490 : 			}
; 1491 : 		}
; 1492 : 		else

	jmp	SHORT $LN15@PathCost

; 1493 : 		{
; 1494 : 			if(pToPlot->getTeam() != eUnitTeam)

$LN178@PathCost:
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$222363[ebp], edx
	cmp	DWORD PTR _playerID$222363[ebp], -1
	je	SHORT $LN175@PathCost
	mov	eax, DWORD PTR _playerID$222363[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T222366[ebp], eax
	jmp	SHORT $LN176@PathCost
	jmp	SHORT $LN176@PathCost
$LN175@PathCost:
	mov	DWORD PTR $T222366[ebp], -1
$LN176@PathCost:
	mov	ecx, DWORD PTR $T222366[ebp]
	cmp	ecx, DWORD PTR _eUnitTeam$[ebp]
	je	SHORT $LN15@PathCost

; 1495 : 			{
; 1496 : 				iCost += PATH_TERRITORY_WEIGHT;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, 3
	mov	DWORD PTR _iCost$[ebp], edx
$LN15@PathCost:

; 1497 : 			}
; 1498 : 		}
; 1499 : 
; 1500 : #if PATH_CITY_AVOID_WEIGHT != 0
; 1501 : 		if(pToPlot->getPlotCity() && !(pToPlot->getX() == finder->GetDestX() && pToPlot->getY() == finder->GetDestY()))
; 1502 : 		{
; 1503 : 			iCost += PATH_CITY_AVOID_WEIGHT; // slewis - this should be zeroed out currently
; 1504 : 		}
; 1505 : #endif
; 1506 : 	}
; 1507 : 	else

	jmp	SHORT $LN13@PathCost
$LN33@PathCost:

; 1508 : 	{
; 1509 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	mov	eax, DWORD PTR _iCost$[ebp]
	imul	eax, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], eax
$LN13@PathCost:

; 1510 : 	}
; 1511 : 
; 1512 : 	if(bMaximizeExplore)

	movzx	ecx, BYTE PTR _bMaximizeExplore$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@PathCost

; 1513 : 	{
; 1514 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 1515 : 		int iUnseenPlots = pToPlot->getNumNonrevealedInRange(eUnitTeam, pToPlot->seeFromLevel(eUnitTeam));
; 1516 : #else
; 1517 : 		int iUnseenPlots = pToPlot->getNumAdjacentNonrevealed(eUnitTeam);

	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonrevealed
	mov	DWORD PTR _iUnseenPlots$219324[ebp], eax

; 1518 : #endif
; 1519 : 		if(!pToPlot->isRevealed(eUnitTeam))

	mov	eax, DWORD PTR _eUnitTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$222375[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$222375[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$222375[ebp]
	mov	edx, DWORD PTR _pToPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@PathCost

; 1520 : 		{
; 1521 : 			iUnseenPlots += 1;

	mov	edx, DWORD PTR _iUnseenPlots$219324[ebp]
	add	edx, 1
	mov	DWORD PTR _iUnseenPlots$219324[ebp], edx
$LN11@PathCost:

; 1522 : 		}
; 1523 : 
; 1524 : 		iCost += (7 - iUnseenPlots) * PATH_EXPLORE_NON_REVEAL_WEIGHT;

	mov	eax, 7
	sub	eax, DWORD PTR _iUnseenPlots$219324[ebp]
	imul	eax, 10					; 0000000aH
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN12@PathCost:

; 1525 : 	}
; 1526 : 
; 1527 : 	// If we are a land unit and we are moving through the water, make the cost a little higher so that
; 1528 : 	// we favor staying on land or getting back to land as quickly as possible because it is dangerous to
; 1529 : 	// be on the water.  Don't add this penalty if the unit is human controlled however, we will assume they want
; 1530 : 	// the best path, rather than the safest.
; 1531 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 1532 : 	if (eUnitDomain == DOMAIN_LAND && bToPlotIsWater)
; 1533 : 	{
; 1534 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1535 : 		if (bIsAIControl)
; 1536 : #else
; 1537 : 		if (!pCacheData->isHuman() || pCacheData->IsAutomated())
; 1538 : #endif
; 1539 : 		{
; 1540 : 			iCost += PATH_THROUGH_WATER;
; 1541 : 		}
; 1542 : 		else
; 1543 : 		{
; 1544 : 			iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 1545 : 		}
; 1546 : 	}
; 1547 : #else
; 1548 : 	if(eUnitDomain == DOMAIN_LAND && bToPlotIsWater && (!pCacheData->isHuman() || pCacheData->IsAutomated()))

	cmp	DWORD PTR _eUnitDomain$[ebp], 2
	jne	SHORT $LN190@PathCost
	movzx	ecx, BYTE PTR _bToPlotIsWater$[ebp]
	test	ecx, ecx
	je	SHORT $LN190@PathCost
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR $T222380[ebp], al
	movzx	ecx, BYTE PTR $T222380[ebp]
	test	ecx, ecx
	je	SHORT $LN9@PathCost
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+37]
	mov	BYTE PTR $T222384[ebp], al
	movzx	ecx, BYTE PTR $T222384[ebp]
	test	ecx, ecx
	je	SHORT $LN190@PathCost
$LN9@PathCost:

; 1549 : 	{
; 1550 : 		iCost += PATH_THROUGH_WATER;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], edx

; 1551 : 	}
; 1552 : #endif
; 1553 : 
; 1554 : 	if(pUnit->IsCombatUnit())

$LN190@PathCost:
	mov	eax, DWORD PTR _pUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN8@PathCost

; 1555 : 	{
; 1556 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 1557 : 		bool bToPlotHasEnemy = pToPlot->isVisibleEnemyDefender(pUnit) || pToPlot->isEnemyCity(*pUnit);
; 1558 : 		if (iMovesLeft == 0 && !bToPlotHasEnemy)
; 1559 : #else
; 1560 : 		if(iMovesLeft == 0)

	cmp	DWORD PTR _iMovesLeft$[ebp], 0
	jne	SHORT $LN7@PathCost

; 1561 : #endif
; 1562 : 		{
; 1563 : #ifdef AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS
; 1564 : 			int iDefenseBonus = pToPlot->defenseModifier(eUnitTeam, false);
; 1565 : 			if (iDefenseBonus > 0)
; 1566 : 			{
; 1567 : 				if (pUnit->noDefensiveBonus())
; 1568 : 					iDefenseBonus = 0;
; 1569 : 				else if (iDefenseBonus > 200)
; 1570 : 					iDefenseBonus = 200;
; 1571 : 			}
; 1572 : 			iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 1573 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 1574 : 			iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));
; 1575 : #else
; 1576 : 			iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN50@PathCost
	mov	DWORD PTR tv390[ebp], 0
	jmp	SHORT $LN51@PathCost
$LN50@PathCost:
	push	0
	push	0
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	mov	DWORD PTR tv390[ebp], eax
$LN51@PathCost:
	mov	edx, 200				; 000000c8H
	sub	edx, DWORD PTR tv390[ebp]
	mov	DWORD PTR $T222098[ebp], edx
	mov	DWORD PTR $T222101[ebp], 0
	mov	eax, DWORD PTR $T222101[ebp]
	cmp	eax, DWORD PTR $T222098[ebp]
	jge	SHORT $LN196@PathCost
	lea	ecx, DWORD PTR $T222098[ebp]
	mov	DWORD PTR tv354[ebp], ecx
	jmp	SHORT $LN197@PathCost
$LN196@PathCost:
	lea	edx, DWORD PTR $T222101[ebp]
	mov	DWORD PTR tv354[ebp], edx
$LN197@PathCost:
	mov	eax, DWORD PTR tv354[ebp]
	mov	DWORD PTR $T222398[ebp], eax
	mov	ecx, DWORD PTR $T222398[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 10					; 0000000aH
	add	edx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], edx
$LN7@PathCost:

; 1577 : #endif
; 1578 : 		}
; 1579 : 
; 1580 : #if !defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) && !defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 1581 : 		if(pCacheData->IsAutomated())

	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+37]
	mov	BYTE PTR $T222405[ebp], cl
	movzx	edx, BYTE PTR $T222405[ebp]
	test	edx, edx
	je	$LN8@PathCost

; 1582 : #endif
; 1583 : 		{
; 1584 : 			if(pCacheData->IsCanAttack())

	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+42]
	mov	BYTE PTR $T222409[ebp], cl
	movzx	edx, BYTE PTR $T222409[ebp]
	test	edx, edx
	je	$LN8@PathCost

; 1585 : 			{
; 1586 : 				if(finder->IsPathDest(iToPlotX, iToPlotY))

	mov	eax, DWORD PTR _finder$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN202@PathCost
	mov	ecx, DWORD PTR _finder$[ebp]
	push	ecx
	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _iToPlotY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iToPlotX$[ebp]
	push	edx
	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN202@PathCost
	mov	BYTE PTR $T222414[ebp], 1
	jmp	SHORT $LN203@PathCost
$LN202@PathCost:
	mov	BYTE PTR $T222414[ebp], 0
$LN203@PathCost:
	movzx	edx, BYTE PTR $T222414[ebp]
	test	edx, edx
	je	$LN8@PathCost

; 1587 : 				{
; 1588 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 1589 : 					if (bToPlotHasEnemy)
; 1590 : #else
; 1591 : 					if(pToPlot->isVisibleEnemyDefender(pUnit))

	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
	movzx	ecx, al
	test	ecx, ecx
	je	$LN8@PathCost

; 1592 : #endif
; 1593 : 					{
; 1594 : #ifdef AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING
; 1595 : 						int iDealtDamage = 0;
; 1596 : 						int iSelfDamage = 0;
; 1597 : 						CvCity* pCity = pToPlot->getPlotCity();
; 1598 : 						if (pCity)
; 1599 : 						{
; 1600 : 							int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, NULL);
; 1601 : 							int iDefenderStrength = pCity->getStrengthValue();
; 1602 : 
; 1603 : 							iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);
; 1604 : 							iSelfDamage = pUnit->getCombatDamage(iDefenderStrength, iAttackerStrength, pCity->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ true, /*bDefenderIsCity*/ false);
; 1605 : 
; 1606 : 							// Will both the attacker die, and the city fall? If so, the unit wins
; 1607 : 							if (iDealtDamage + pCity->getDamage() >= pCity->GetMaxHitPoints())
; 1608 : 							{
; 1609 : 								if (pUnit->isNoCapture())
; 1610 : 									iDealtDamage = pCity->GetMaxHitPoints() - pCity->getDamage() - 1;
; 1611 : 								if (iSelfDamage >= pUnit->GetCurrHitPoints())
; 1612 : 									iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 1613 : 							}
; 1614 : 					}
; 1615 : 						else
; 1616 : 						{
; 1617 : 							CvUnit* pDefender = pToPlot->getVisibleEnemyDefender(pUnit);
; 1618 : 							if (pDefender && pDefender->IsCanDefend())
; 1619 : 							{
; 1620 : 								// handle the Zulu special thrown spear first attack
; 1621 : 								if (pUnit->isRangedSupportFire() && pUnit->canEverRangeStrikeAt(pToPlot->getX(), pToPlot->getY()))
; 1622 : 									iDealtDamage = pUnit->GetRangeCombatDamage(pDefender, /*pCity*/ NULL, /*bIncludeRand*/ false);
; 1623 : 
; 1624 : 								if (iDealtDamage < pDefender->GetCurrHitPoints())
; 1625 : 								{
; 1626 : 									int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, pDefender);
; 1627 : 									int iDefenderStrength = pDefender->GetMaxDefenseStrength(pToPlot, pUnit);
; 1628 : 
; 1629 : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 1630 : 									bool isAttackingFromHigherElevation = 
; 1631 : 										((pUnit->plot()->isMountain() && !pDefender->plot()->isMountain()) || // attacking from mountain to non-mountain
; 1632 : 										(pUnit->plot()->isHills() && pDefender->plot()->isFlatlands())); // attacking from hills to flatlands
; 1633 : 									if ((pUnit->IsCanHeavyCharge() || (pUnit->GetHeavyChargeDownhill() > 0 && isAttackingFromHigherElevation))
; 1634 : 										&& !pDefender->CanFallBackFromMelee(*pUnit))
; 1635 : #else
; 1636 : 									if (pUnit->IsCanHeavyCharge() && !pDefender->CanFallBackFromMelee(*pUnit))
; 1637 : #endif
; 1638 : 										iAttackerStrength = (iAttackerStrength * 150) / 100;
; 1639 : 
; 1640 : 									iSelfDamage = pDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, pDefender->getDamage() + iDealtDamage, /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 1641 : 									iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 1642 : 
; 1643 : 									// Will both units be killed by this? :o If so, take drastic corrective measures
; 1644 : 									if (iDealtDamage >= pDefender->GetCurrHitPoints() && iSelfDamage >= pUnit->GetCurrHitPoints())
; 1645 : 									{
; 1646 : 										// He who hath the least amount of damage survives with 1 HP left
; 1647 : 										if (iDealtDamage + pDefender->getDamage() > iSelfDamage + pUnit->getDamage())
; 1648 : 											iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 1649 : 										else
; 1650 : 											iDealtDamage = pDefender->GetCurrHitPoints() - 1;
; 1651 : 									}
; 1652 : 								}
; 1653 : 							}
; 1654 : 						}
; 1655 : 						if (iSelfDamage > pUnit->GetCurrHitPoints())
; 1656 : 							iSelfDamage = pUnit->GetMaxHitPoints();
; 1657 : 						if (iDealtDamage > GC.getMAX_HIT_POINTS())
; 1658 : 							iDealtDamage = GC.getMAX_HIT_POINTS();
; 1659 : 						iCost += iSelfDamage * PATH_DAMAGE_WEIGHT * pUnit->GetMaxHitPoints() / 100 + (GC.getMAX_HIT_POINTS() - iDealtDamage) * PATH_DAMAGE_WEIGHT / 10;
; 1660 : #elif defined(AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS)
; 1661 : 						int iDefenseBonus = pFromPlot->defenseModifier(eUnitTeam, false);
; 1662 : 						if (iDefenseBonus > 0)
; 1663 : 						{
; 1664 : 							if (pUnit->noDefensiveBonus())
; 1665 : 								iDefenseBonus = 0;
; 1666 : 							else if (iDefenseBonus > 200)
; 1667 : 								iDefenseBonus = 200;
; 1668 : 						}
; 1669 : 						iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 1670 : #else
; 1671 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 1672 : 						iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));
; 1673 : #else
; 1674 : 						iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN52@PathCost
	mov	DWORD PTR tv425[ebp], 0
	jmp	SHORT $LN53@PathCost
$LN52@PathCost:
	push	0
	push	0
	mov	eax, DWORD PTR _eUnitTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	mov	DWORD PTR tv425[ebp], eax
$LN53@PathCost:
	mov	ecx, 200				; 000000c8H
	sub	ecx, DWORD PTR tv425[ebp]
	mov	DWORD PTR $T222102[ebp], ecx
	mov	DWORD PTR $T222105[ebp], 0
	mov	edx, DWORD PTR $T222105[ebp]
	cmp	edx, DWORD PTR $T222102[ebp]
	jge	SHORT $LN207@PathCost
	lea	eax, DWORD PTR $T222102[ebp]
	mov	DWORD PTR tv407[ebp], eax
	jmp	SHORT $LN208@PathCost
$LN207@PathCost:
	lea	ecx, DWORD PTR $T222105[ebp]
	mov	DWORD PTR tv407[ebp], ecx
$LN208@PathCost:
	mov	edx, DWORD PTR tv407[ebp]
	mov	DWORD PTR $T222420[ebp], edx
	mov	eax, DWORD PTR $T222420[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 10					; 0000000aH
	add	ecx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], ecx

; 1675 : #endif
; 1676 : 
; 1677 : 						// I guess we may as well be the garrison
; 1678 : #if PATH_CITY_WEIGHT != 0
; 1679 : 						if(!(pFromPlot->isCity()))
; 1680 : 						{
; 1681 : 							iCost += PATH_CITY_WEIGHT;
; 1682 : 						}
; 1683 : #endif
; 1684 : 
; 1685 : 						if(pFromPlot->isRiverCrossing(directionXY(iFromPlotX, iFromPlotY, iToPlotX, iToPlotY)))

	mov	edx, DWORD PTR _iToPlotY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iToPlotX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFromPlotY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFromPlotX$[ebp]
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@PathCost

; 1686 : 						{
; 1687 : 							if(!(pUnit->isRiverCrossingNoPenalty()))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isRiverCrossingNoPenalty@CvUnit@@QBE_NXZ ; CvUnit::isRiverCrossingNoPenalty
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@PathCost

; 1688 : 							{
; 1689 : 								iCost += (PATH_RIVER_WEIGHT * -(GC.getRIVER_ATTACK_MODIFIER()));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7388
	mov	DWORD PTR $T222482[ebp], edx
	mov	eax, DWORD PTR $T222482[ebp]
	neg	eax
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 1690 : 								iCost += (PATH_MOVEMENT_WEIGHT * iMovesLeft);

	mov	ecx, DWORD PTR _iMovesLeft$[ebp]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], ecx
$LN8@PathCost:

; 1691 : 							}
; 1692 : 						}
; 1693 : #endif
; 1694 : 					}
; 1695 : 				}
; 1696 : 			}
; 1697 : 		}
; 1698 : 	}
; 1699 : 
; 1700 : 	FAssert(iCost != MAX_INT);
; 1701 : 
; 1702 : 	iCost += PATH_STEP_WEIGHT;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, 2
	mov	DWORD PTR _iCost$[ebp], edx

; 1703 : 
; 1704 : 	FAssert(iCost > 0);
; 1705 : 
; 1706 : 	return iCost;

	mov	eax, DWORD PTR _iCost$[ebp]

; 1707 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; PathCost
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
tv90 = -56						; size = 4
tv86 = -52						; size = 4
_iDestHexX$ = -16					; size = 4
_iWrappedXOffset$ = -12					; size = 4
_iSourceHexX$ = -8					; size = 4
_iWrappedYOffset$ = -4					; size = 4
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	cmp	DWORD PTR _iSourceY$[ebp], 0
	jl	SHORT $LN17@directionX
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN15@directionX
$LN17@directionX:
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN15@directionX:
	mov	ecx, DWORD PTR _iSourceX$[ebp]
	sub	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iSourceHexX$[ebp], ecx

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	cmp	DWORD PTR _iDestY$[ebp], 0
	jl	SHORT $LN21@directionX
	mov	edx, DWORD PTR _iDestY$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN19@directionX
$LN21@directionX:
	mov	eax, DWORD PTR _iDestY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv90[ebp], eax
$LN19@directionX:
	mov	eax, DWORD PTR _iDestX$[ebp]
	sub	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR _iDestHexX$[ebp], eax

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestHexX$[ebp]
	sub	ecx, DWORD PTR _iSourceHexX$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedXOffset$[ebp], eax

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	mov	edx, DWORD PTR _iDestY$[ebp]
	sub	edx, DWORD PTR _iSourceY$[ebp]
	push	edx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedYOffset$[ebp], eax

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jle	SHORT $LN12@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jl	SHORT $LN11@directionX

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;

	xor	eax, eax
	jmp	SHORT $LN13@directionX

; 276  : 		}
; 277  : 		else

	jmp	SHORT $LN10@directionX
$LN11@directionX:

; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;

	mov	eax, 5
	jmp	SHORT $LN13@directionX
$LN10@directionX:

; 280  : 		}

	jmp	SHORT $LN13@directionX
$LN12@directionX:

; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1
	jmp	SHORT $LN13@directionX
	jmp	SHORT $LN6@directionX
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jne	SHORT $LN5@directionX

; 289  : 		{
; 290  : 			return NO_DIRECTION;

	or	eax, -1
	jmp	SHORT $LN13@directionX

; 291  : 		}
; 292  : 		else

	jmp	SHORT $LN6@directionX
$LN5@directionX:

; 293  : 		{
; 294  : 			return DIRECTION_WEST;

	mov	eax, 4
	jmp	SHORT $LN13@directionX
$LN6@directionX:

; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)

	jmp	SHORT $LN13@directionX
$LN8@directionX:

; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN2@directionX

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;

	mov	eax, 2
	jmp	SHORT $LN13@directionX

; 302  : 		}
; 303  : 		else

	jmp	SHORT $LN13@directionX
$LN2@directionX:

; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;

	mov	eax, 3
$LN13@directionX:

; 306  : 		}
; 307  : 	}
; 308  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
_TEXT	ENDS
PUBLIC	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
EXTRN	?canMoveThrough@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canMoveThrough
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?isAdjacent@CvPlot@@QBE_NPBV1@@Z:PROC		; CvPlot::isAdjacent
EXTRN	?canMoveAllTerrain@CvUnit@@QBE_NXZ:PROC		; CvUnit::canMoveAllTerrain
EXTRN	?IsHoveringUnit@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsHoveringUnit
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canEnterTerrain
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv285 = -240						; size = 4
tv281 = -236						; size = 4
tv240 = -232						; size = 4
tv237 = -228						; size = 4
tv222 = -224						; size = 4
tv200 = -219						; size = 1
tv192 = -218						; size = 1
tv169 = -217						; size = 1
tv161 = -216						; size = 1
tv152 = -215						; size = 1
tv139 = -214						; size = 1
tv128 = -213						; size = 1
tv78 = -212						; size = 4
tv75 = -208						; size = 4
$T222725 = -201						; size = 1
_playerID$222713 = -200					; size = 4
$T222650 = -196						; size = 4
$T222635 = -192						; size = 4
$T222634 = -188						; size = 4
$T222630 = -181						; size = 1
_pCity$222628 = -176					; size = 4
$T222619 = -172						; size = 4
_uiOffset$222604 = -164					; size = 4
$T222589 = -157						; size = 1
$T222576 = -156						; size = 4
$T222553 = -152						; size = 4
$T222543 = -148						; size = 8
_kNodeCacheData$219403 = -140				; size = 4
_pUnit$ = -136						; size = 4
_iFinderInfo$ = -132					; size = 4
_bAIControl$ = -126					; size = 1
_bUnitIsCombat$ = -125					; size = 1
_iDestX$ = -124						; size = 4
_iNodeX$ = -120						; size = 4
_bIsHuman$ = -113					; size = 1
_pUnitPlot$ = -112					; size = 4
_iUnitPlotLimit$ = -108					; size = 4
_pCacheData$ = -104					; size = 4
_pPlot$ = -100						; size = 4
_eUnitTeam$ = -96					; size = 4
_kToNodeCacheData$ = -92				; size = 4
_iFinderIgnoreStacking$ = -88				; size = 4
_iDestY$ = -84						; size = 4
_theMap$ = -80						; size = 4
_pCity$ = -76						; size = 4
_iUnitY$ = -72						; size = 4
_pNode$ = -68						; size = 4
_unit_domain_type$ = -64				; size = 4
_eFromPlotTeam$ = -60					; size = 4
_bPreviousNodeHostile$ = -53				; size = 1
_kUnitTeam$ = -52					; size = 4
_iUnitX$ = -48						; size = 4
_pFromPlot$ = -44					; size = 4
_bFromPlotOwned$ = -37					; size = 1
_iNumTurns$ = -36					; size = 4
_bFirstRun$ = -29					; size = 1
_kFromNodeCacheData$ = -28				; size = 4
_unit_owner$ = -24					; size = 4
_iNodeY$ = -20						; size = 4
_iStartMoves$ = -16					; size = 4
_pToPlot$ = -12						; size = 4
_bPreviousVisibleToTeam$ = -5				; size = 1
_iOldNumTurns$ = -4					; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; PathValid, COMDAT

; 1712 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H

; 1713 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1714 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1715 : 	CvPlot* pToPlot = node->m_pPlot;
; 1716 : 	if (!pToPlot)
; 1717 : 		return FALSE;
; 1718 : #else
; 1719 : 	CvMap& theMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _theMap$[ebp], eax

; 1720 : 
; 1721 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _theMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T222553[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T222553[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _theMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$[ebp], eax

; 1722 : #endif
; 1723 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pToPlot));

	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR tv75[ebp]
	prefetcht0 BYTE PTR [eax]
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR tv78[ebp]
	prefetcht0 BYTE PTR [edx]

; 1724 : #endif
; 1725 : 
; 1726 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 1727 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[ebp]
	add	ecx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], ecx

; 1728 : 	TeamTypes eUnitTeam = pCacheData->getTeam();

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 1729 : 	PlayerTypes unit_owner = pCacheData->getOwner();

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _unit_owner$[ebp], edx

; 1730 : 
; 1731 : 	CvAssertMsg(eUnitTeam != NO_TEAM, "The unit's team should be a vaild value");
; 1732 : 	if (eUnitTeam == NO_TEAM)

	cmp	DWORD PTR _eUnitTeam$[ebp], -1
	jne	SHORT $LN70@PathValid

; 1733 : 	{
; 1734 : 		eUnitTeam = GC.getGame().getActiveTeam();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T222576[ebp], eax
	mov	ecx, DWORD PTR $T222576[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 1735 : 	}
; 1736 : 
; 1737 : 	CvTeam& kUnitTeam = GET_TEAM(eUnitTeam);

$LN70@PathValid:
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kUnitTeam$[ebp], ecx

; 1738 : 
; 1739 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1740 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1741 : 	CvPlot* pToPlot = node->m_pPlot;
; 1742 : 	if (!pToPlot)
; 1743 : 		return FALSE;
; 1744 : #else
; 1745 : 	CvMap& theMap = GC.getMap();
; 1746 : 
; 1747 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);
; 1748 : #endif
; 1749 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pToPlot));
; 1750 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1751 : 	CvAStarNode& kToNodeCacheData = *node;
; 1752 : #else
; 1753 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 1754 : #endif
; 1755 : #endif
; 1756 : 
; 1757 : #ifdef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 1758 : 	// If this is the first node in the path, it is always valid (starting location)
; 1759 : 	if (parent == NULL)
; 1760 : 	{
; 1761 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1762 : 		// Cache values for this node that we will use in the loop
; 1763 : 		if (!kToNodeCacheData.bIsCalculated)
; 1764 : 		{
; 1765 : 			kToNodeCacheData.bIsCalculated = true;
; 1766 : 			kToNodeCacheData.bPlotVisibleToTeam = true;
; 1767 : 			kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 1768 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1769 : 			kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 1770 : 			if (pUnit->IsHoveringUnit())
; 1771 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1772 : 			else
; 1773 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 1774 : #else
; 1775 : 			kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 1776 : #endif
; 1777 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 1778 : 			kToNodeCacheData.bIsRevealedToTeam = true;
; 1779 : 			kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 1780 : 			CvCity* pCity = pToPlot->getPlotCity();
; 1781 : 			if (pCity)
; 1782 : 			{
; 1783 : 				if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 1784 : 					kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 1785 : 			}
; 1786 : 			kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);
; 1787 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 1788 : 			kToNodeCacheData.bContainsVisibleEnemy = pToPlot->isVisibleEnemyUnit(pUnit);
; 1789 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 1790 : 		}
; 1791 : #endif
; 1792 : 		return TRUE;
; 1793 : 	}
; 1794 : #endif
; 1795 : 
; 1796 : 	// Cache values for this node that we will use in the loop
; 1797 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1798 : 	if (!kToNodeCacheData.bIsCalculated)
; 1799 : 	{
; 1800 : 		kToNodeCacheData.bPlotVisibleToTeam = pToPlot->isVisible(eUnitTeam);
; 1801 : 		kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 1802 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1803 : 		kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 1804 : 		if (pUnit->IsHoveringUnit())
; 1805 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1806 : 		else
; 1807 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 1808 : #else
; 1809 : 		kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 1810 : #endif
; 1811 : 		kToNodeCacheData.bIsRevealedToTeam = pToPlot->isRevealed(eUnitTeam);
; 1812 : 		kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 1813 : 		CvCity* pCity = pToPlot->getPlotCity();
; 1814 : 		if (pCity)
; 1815 : 		{
; 1816 : 			if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 1817 : 				kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 1818 : 		}
; 1819 : 		kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);
; 1820 : 		if (kToNodeCacheData.bPlotVisibleToTeam)
; 1821 : 		{
; 1822 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 1823 : 			kToNodeCacheData.bContainsVisibleEnemy = pToPlot->isVisibleEnemyUnit(pUnit);
; 1824 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 1825 : 		}
; 1826 : 		else
; 1827 : 		{
; 1828 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = 0;
; 1829 : 			kToNodeCacheData.bContainsVisibleEnemy = false;
; 1830 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = false;
; 1831 : 		}
; 1832 : 	}
; 1833 : #else
; 1834 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1835 : 	CvAStarNode& kToNodeCacheData = *node;
; 1836 : #else
; 1837 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;

	mov	edx, DWORD PTR _node$[ebp]
	add	edx, 88					; 00000058H
	mov	DWORD PTR _kToNodeCacheData$[ebp], edx

; 1838 : #endif
; 1839 : 	kToNodeCacheData.bPlotVisibleToTeam = pToPlot->isVisible(eUnitTeam);

	cmp	DWORD PTR _eUnitTeam$[ebp], -1
	jne	SHORT $LN75@PathValid
	mov	BYTE PTR $T222589[ebp], 0
	jmp	SHORT $LN73@PathValid
$LN75@PathValid:
	mov	eax, DWORD PTR _pToPlot$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T222589[ebp], cl
$LN73@PathValid:
	mov	dl, BYTE PTR $T222589[ebp]
	mov	BYTE PTR tv128[ebp], dl
	mov	al, BYTE PTR tv128[ebp]
	and	al, 1
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 254					; 000000feH
	or	dl, al
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 1840 : 	kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);

	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1841 : 	kToNodeCacheData.bIsMountain = pToPlot->isMountain();

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	mov	BYTE PTR tv139[ebp], cl
	mov	dl, BYTE PTR tv139[ebp]
	and	dl, 1
	shl	dl, 1
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 253					; 000000fdH
	or	cl, dl
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [edx], cl

; 1842 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 1843 : 	kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 1844 : 	if (pUnit->IsHoveringUnit())
; 1845 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 1846 : 	else
; 1847 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 1848 : #else
; 1849 : 	kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN51@PathValid
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN51@PathValid
	mov	BYTE PTR tv152[ebp], 1
	jmp	SHORT $LN52@PathValid
$LN51@PathValid:
	mov	BYTE PTR tv152[ebp], 0
$LN52@PathValid:
	mov	dl, BYTE PTR tv152[ebp]
	and	dl, 1
	shl	dl, 2
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 251					; 000000fbH
	or	cl, dl
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [edx], cl

; 1850 : #endif
; 1851 : 	kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);

	push	128					; 00000080H
	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	mov	BYTE PTR tv161[ebp], al
	mov	cl, BYTE PTR tv161[ebp]
	and	cl, 1
	shl	cl, 3
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	and	al, 247					; 000000f7H
	or	al, cl
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [ecx], al

; 1852 : 	kToNodeCacheData.bIsRevealedToTeam = pToPlot->isRevealed(eUnitTeam);

	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$222604[ebp], edx
	mov	eax, DWORD PTR _uiOffset$222604[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$222604[ebp]
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	mov	BYTE PTR tv169[ebp], dl
	mov	al, BYTE PTR tv169[ebp]
	and	al, 1
	shl	al, 4
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 239					; 000000efH
	or	dl, al
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 1853 : 	kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;

	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 223					; 000000dfH
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 1854 : 	CvCity* pCity = pToPlot->getPlotCity();

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 1855 : 	if(pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN47@PathValid

; 1856 : 	{
; 1857 : 		if(unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T222619[ebp], edx
	mov	eax, DWORD PTR _unit_owner$[ebp]
	cmp	eax, DWORD PTR $T222619[ebp]
	je	SHORT $LN47@PathValid
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _kUnitTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN47@PathValid

; 1858 : 			kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;

	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [ecx], al
$LN47@PathValid:

; 1859 : 	}
; 1860 : 	kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$222628[ebp], eax
	cmp	DWORD PTR _pCity$222628[ebp], 0
	je	SHORT $LN94@PathValid
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$222628[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	mov	BYTE PTR $T222630[ebp], al
	jmp	SHORT $LN95@PathValid
$LN94@PathValid:
	mov	BYTE PTR $T222630[ebp], 0
$LN95@PathValid:
	mov	al, BYTE PTR $T222630[ebp]
	mov	BYTE PTR tv192[ebp], al
	mov	cl, BYTE PTR tv192[ebp]
	and	cl, 1
	shl	cl, 6
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	and	al, 191					; 000000bfH
	or	al, cl
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [ecx], al

; 1861 : 	kToNodeCacheData.bContainsVisibleEnemy = pToPlot->isVisibleEnemyUnit(pUnit);

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	mov	BYTE PTR tv200[ebp], al
	mov	al, BYTE PTR tv200[ebp]
	and	al, 1
	shl	al, 7
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 127					; 0000007fH
	or	dl, al
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 1862 : 	kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _unit_owner$[ebp]
	push	edx
	push	-1
	lea	eax, DWORD PTR $T222543[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR $T222634[ebp], eax
	mov	ecx, DWORD PTR $T222634[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T222635[ebp], edx
	mov	eax, DWORD PTR $T222635[ebp]
	mov	DWORD PTR tv222[ebp], eax
	cmp	DWORD PTR tv222[ebp], 0
	setne	cl
	and	cl, 1
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx+1]
	and	al, 254					; 000000feH
	or	al, cl
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [ecx+1], al
	cmp	DWORD PTR $T222543[ebp], 0
	je	SHORT $LN105@PathValid
	mov	ecx, DWORD PTR $T222543[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN105@PathValid:

; 1863 : #endif
; 1864 : 
; 1865 : #ifndef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 1866 : 	// If this is the first node in the path, it is always valid (starting location)
; 1867 : 	if (parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN45@PathValid

; 1868 : 	{
; 1869 : 		return TRUE;

	mov	eax, 1
	jmp	$LN49@PathValid
$LN45@PathValid:

; 1870 : 	}
; 1871 : #endif
; 1872 : 
; 1873 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 1874 : 	CvPlot* pFromPlot = parent->m_pPlot;
; 1875 : 	if (!pFromPlot)
; 1876 : 		return FALSE;
; 1877 : #else
; 1878 : 	CvPlot* pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	edx, DWORD PTR _theMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T222650[ebp], eax
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T222650[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _theMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], ecx

; 1879 : #endif
; 1880 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pFromPlot));

	mov	eax, DWORD PTR _pFromPlot$[ebp]
	mov	DWORD PTR tv237[ebp], eax
	mov	ecx, DWORD PTR tv237[ebp]
	prefetcht0 BYTE PTR [ecx]
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR tv240[ebp], edx
	mov	eax, DWORD PTR tv240[ebp]
	prefetcht0 BYTE PTR [eax]

; 1881 : 
; 1882 : 	// pulling invariants out of the loop
; 1883 : 	bool bAIControl = pCacheData->IsAutomated();

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+37]
	mov	BYTE PTR _bAIControl$[ebp], dl

; 1884 : 	int iUnitX = pUnit->getX();

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _iUnitX$[ebp], ecx

; 1885 : 	int iUnitY = pUnit->getY();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR _iUnitY$[ebp], eax

; 1886 : 	DomainTypes unit_domain_type = pCacheData->getDomainType();

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _unit_domain_type$[ebp], edx

; 1887 : 	bool bUnitIsCombat           = pUnit->IsCombatUnit();

	mov	eax, DWORD PTR _pUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	mov	BYTE PTR _bUnitIsCombat$[ebp], cl

; 1888 : 	bool bIsHuman				 = pCacheData->isHuman();

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR _bIsHuman$[ebp], al

; 1889 : 	int iFinderInfo              = finder->GetInfo();

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR _iFinderInfo$[ebp], edx

; 1890 : 	CvPlot* pUnitPlot            = pUnit->plot();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pUnitPlot$[ebp], eax

; 1891 : 	int iFinderIgnoreStacking    = iFinderInfo & MOVE_IGNORE_STACKING;

	mov	eax, DWORD PTR _iFinderInfo$[ebp]
	and	eax, 4
	mov	DWORD PTR _iFinderIgnoreStacking$[ebp], eax

; 1892 : 	int iUnitPlotLimit           = GC.getPLOT_UNIT_LIMIT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR _iUnitPlotLimit$[ebp], ecx

; 1893 : 	bool bFromPlotOwned          = pFromPlot->isOwned();

	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	mov	BYTE PTR _bFromPlotOwned$[ebp], al

; 1894 : 	TeamTypes eFromPlotTeam      = pFromPlot->getTeam();

	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$222713[ebp], eax
	cmp	DWORD PTR _playerID$222713[ebp], -1
	je	SHORT $LN138@PathValid
	mov	ecx, DWORD PTR _playerID$222713[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eFromPlotTeam$[ebp], eax
	jmp	SHORT $LN139@PathValid
	jmp	SHORT $LN139@PathValid
$LN138@PathValid:
	mov	DWORD PTR _eFromPlotTeam$[ebp], -1
$LN139@PathValid:

; 1895 : 
; 1896 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1897 : 	if (!kToNodeCacheData.bIsCalculated)
; 1898 : 	{
; 1899 : 		if (bAIControl || kToNodeCacheData.bIsRevealedToTeam || !bIsHuman)
; 1900 : 			kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);
; 1901 : 		else
; 1902 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 1903 : 		kToNodeCacheData.bIsCalculated = true;
; 1904 : 	}
; 1905 : #endif
; 1906 : 
; 1907 : 	// We have determined that this node is not the origin above (parent == NULL)
; 1908 : 	CvAStarNode* pNode = node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _pNode$[ebp], edx

; 1909 : 	bool bPreviousNodeHostile = false;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 0

; 1910 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1911 : 	bool bPreviousVisibleToTeam = kToNodeCacheData.bPlotVisibleToTeam;

	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 1
	mov	BYTE PTR _bPreviousVisibleToTeam$[ebp], cl

; 1912 : #endif
; 1913 : 	int iDestX = finder->GetDestX();

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR _iDestX$[ebp], eax

; 1914 : 	int iDestY = finder->GetDestY();

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR _iDestY$[ebp], edx

; 1915 : 	int iNodeX = node->m_iX;

	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR _iNodeX$[ebp], ecx

; 1916 : 	int iNodeY = node->m_iY;

	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	DWORD PTR _iNodeY$[ebp], eax

; 1917 : 	int iOldNumTurns = -1;

	mov	DWORD PTR _iOldNumTurns$[ebp], -1

; 1918 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 1919 : 	int iNumTurns;
; 1920 : #endif
; 1921 : 
; 1922 : 	// First run special case for checking "node" since it doesn't have a parent set yet
; 1923 : 	bool bFirstRun = true;

	mov	BYTE PTR _bFirstRun$[ebp], 1

; 1924 : 
; 1925 : 	// Have to calculate this specially because the node passed into this function doesn't yet have data stored it in (hasn't reached pathAdd yet)
; 1926 : 	int iStartMoves = parent->m_iData1;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _iStartMoves$[ebp], edx

; 1927 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1928 : 	int iNumTurns = parent->m_iData2;
; 1929 : #else
; 1930 : 	iNumTurns = parent->m_iData2;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _iNumTurns$[ebp], ecx

; 1931 : #endif
; 1932 : #if defined(AUI_ASTAR_TURN_LIMITER)
; 1933 : 	int iMaxTurns = finder->GetMaxTurns();
; 1934 : #endif
; 1935 : 
; 1936 : 	if(iStartMoves == 0)

	cmp	DWORD PTR _iStartMoves$[ebp], 0
	jne	SHORT $LN44@PathValid

; 1937 : 	{
; 1938 : 		iNumTurns++;

	mov	edx, DWORD PTR _iNumTurns$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumTurns$[ebp], edx
$LN44@PathValid:

; 1939 : 	}
; 1940 : 
; 1941 : 	iOldNumTurns = -1;

	mov	DWORD PTR _iOldNumTurns$[ebp], -1

; 1942 : 
; 1943 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 1944 : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 1945 : #endif
; 1946 : 
; 1947 : 	// Get a reference to the parent node cache data
; 1948 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1949 : 	CvAStarNode& kFromNodeCacheData = *parent;
; 1950 : #else
; 1951 : 	CvPathNodeCacheData& kFromNodeCacheData = parent->m_kCostCacheData;

	mov	eax, DWORD PTR _parent$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _kFromNodeCacheData$[ebp], eax
$LN43@PathValid:

; 1952 : #endif
; 1953 : 
; 1954 : 	// Loop through the current path until we find the path origin.
; 1955 : 	// This validates the path with the inclusion of the new path node.  We must do this because of the rules of where a unit can finish a turn.
; 1956 : 	// Please note that this can be an expensive loop as the path gets longer and longer, do as little work as possible in validating each node.  
; 1957 : 	// If there is an invariant value that needs to be fetched from the plot or unit for the node, please do the calculation and put it in the node's data cache.
; 1958 : 	while(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN42@PathValid

; 1959 : 	{
; 1960 : #ifdef AUI_ASTAR_TURN_LIMITER
; 1961 : 		if (iNumTurns > iMaxTurns)
; 1962 : 		{
; 1963 : 			return FALSE;  // Path is too long, terminate now
; 1964 : 		}
; 1965 : #endif
; 1966 : 		PREFETCH_FASTAR_NODE(pNode->m_pParent);

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR tv281[ebp], edx
	mov	eax, DWORD PTR tv281[ebp]
	prefetcht0 BYTE PTR [eax]
	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 64					; 00000040H
	mov	DWORD PTR tv285[ebp], edx
	mov	eax, DWORD PTR tv285[ebp]
	prefetcht0 BYTE PTR [eax]

; 1967 : 
; 1968 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1969 : 		CvAStarNode& kNodeCacheData = *node;
; 1970 : #else
; 1971 : 		CvPathNodeCacheData& kNodeCacheData = pNode->m_kCostCacheData;

	mov	ecx, DWORD PTR _pNode$[ebp]
	add	ecx, 88					; 00000058H
	mov	DWORD PTR _kNodeCacheData$219403[ebp], ecx

; 1972 : #endif
; 1973 : 		// This is a safeguard against the algorithm believing a plot to be impassable before actually knowing it (mid-search)
; 1974 : 		if(iOldNumTurns != -1 || (iDestX == iNodeX && iDestY == iNodeY))

	cmp	DWORD PTR _iOldNumTurns$[ebp], -1
	jne	SHORT $LN40@PathValid
	mov	edx, DWORD PTR _iDestX$[ebp]
	cmp	edx, DWORD PTR _iNodeX$[ebp]
	jne	$LN41@PathValid
	mov	eax, DWORD PTR _iDestY$[ebp]
	cmp	eax, DWORD PTR _iNodeY$[ebp]
	jne	$LN41@PathValid
$LN40@PathValid:

; 1975 : 		{
; 1976 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1977 : 			if (!kNodeCacheData.bCanEnterTerrain)
; 1978 : 			{
; 1979 : 				return FALSE;
; 1980 : 			}
; 1981 : #endif
; 1982 : 			// This plot is of greater distance than previously, so we know the unit is ending its turn here (pNode), or it's trying to attack through a unit (and might end up on this tile if an attack fails to kill the enemy)
; 1983 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1984 : 			if (iNumTurns != iOldNumTurns || bPreviousNodeHostile)
; 1985 : #else
; 1986 : 			if(iNumTurns != iOldNumTurns || bPreviousNodeHostile || !bPreviousVisibleToTeam)

	mov	ecx, DWORD PTR _iNumTurns$[ebp]
	cmp	ecx, DWORD PTR _iOldNumTurns$[ebp]
	jne	SHORT $LN38@PathValid
	movzx	edx, BYTE PTR _bPreviousNodeHostile$[ebp]
	test	edx, edx
	jne	SHORT $LN38@PathValid
	movzx	eax, BYTE PTR _bPreviousVisibleToTeam$[ebp]
	test	eax, eax
	jne	$LN41@PathValid
$LN38@PathValid:

; 1987 : #endif
; 1988 : 			{
; 1989 : 				// Don't count origin, or else a unit will block its own movement!
; 1990 : 				if(iNodeX != iUnitX || iNodeY != iUnitY)

	mov	ecx, DWORD PTR _iNodeX$[ebp]
	cmp	ecx, DWORD PTR _iUnitX$[ebp]
	jne	SHORT $LN36@PathValid
	mov	edx, DWORD PTR _iNodeY$[ebp]
	cmp	edx, DWORD PTR _iUnitY$[ebp]
	je	$LN41@PathValid
$LN36@PathValid:

; 1991 : 				{
; 1992 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 1993 : 					if (kNodeCacheData.bIsRevealedToTeam)
; 1994 : #else
; 1995 : 					if(kNodeCacheData.bPlotVisibleToTeam)

	mov	eax, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN35@PathValid

; 1996 : #endif
; 1997 : 					{
; 1998 : 						// Check to see if any units are present at this full-turn move plot... if the player can see what's there
; 1999 : 						if(kNodeCacheData.iNumFriendlyUnitsOfType >= iUnitPlotLimit && !(iFinderIgnoreStacking))

	mov	eax, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iUnitPlotLimit$[ebp]
	jl	SHORT $LN34@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN34@PathValid

; 2000 : 						{
; 2001 : 							return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN34@PathValid:

; 2002 : 						}
; 2003 : 
; 2004 : #ifndef AUI_ASTAR_FIX_PATH_VALID_PATH_PEAKS_FOR_NONHUMAN
; 2005 : 						if (kNodeCacheData.bIsMountain && !(iFinderIgnoreStacking) && (!bIsHuman || bAIControl))

	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 1
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN33@PathValid
	movzx	edx, BYTE PTR _bIsHuman$[ebp]
	test	edx, edx
	je	SHORT $LN32@PathValid
	movzx	eax, BYTE PTR _bAIControl$[ebp]
	test	eax, eax
	je	SHORT $LN33@PathValid
$LN32@PathValid:

; 2006 : 						{
; 2007 : 							return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN33@PathValid:

; 2008 : 						}
; 2009 : #endif
; 2010 : 
; 2011 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2012 : 						if(kNodeCacheData.bIsMountain && !kNodeCacheData.bCanEnterTerrain)

	mov	ecx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 1
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@PathValid
	mov	ecx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN31@PathValid

; 2013 : 						{
; 2014 : 							return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN31@PathValid:

; 2015 : 						}
; 2016 : #endif
; 2017 : 
; 2018 : 						if ((iFinderInfo & CvUnit::MOVEFLAG_STAY_ON_LAND) && kNodeCacheData.bIsWater)

	mov	ecx, DWORD PTR _iFinderInfo$[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN35@PathValid
	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 2
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@PathValid

; 2019 : 						{
; 2020 : 							return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN35@PathValid:

; 2021 : 						}
; 2022 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2023 : 					}
; 2024 : 
; 2025 : 					if(kNodeCacheData.bIsRevealedToTeam)

	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN41@PathValid

; 2026 : 					{
; 2027 : #endif
; 2028 : 						if (kNodeCacheData.bContainsOtherFriendlyTeamCity && !(iFinderIgnoreStacking))

	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN41@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN41@PathValid

; 2029 : 							return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN41@PathValid:

; 2030 : 					}
; 2031 : 				}
; 2032 : 			}
; 2033 : 		}
; 2034 : 
; 2035 : 		bPreviousNodeHostile = false;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 0

; 2036 : 		if(kNodeCacheData.bContainsEnemyCity)

	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 6
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN27@PathValid

; 2037 : 		{
; 2038 : 			bPreviousNodeHostile = true;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 1
	jmp	SHORT $LN26@PathValid
$LN27@PathValid:

; 2039 : 		}
; 2040 : 		// Prevents units from passing through one another on its way to attack another unit
; 2041 : 		else if(kNodeCacheData.bContainsVisibleEnemy)

	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@PathValid

; 2042 : 		{
; 2043 : 			// except when attacking an unguarded civilian unit
; 2044 : 			if(kNodeCacheData.bContainsVisibleEnemyDefender)

	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx+1]
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@PathValid

; 2045 : 			{
; 2046 : 				bPreviousNodeHostile = true;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 1
$LN26@PathValid:

; 2047 : 			}
; 2048 : 		}
; 2049 : 
; 2050 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2051 : 		bPreviousVisibleToTeam = kNodeCacheData.bPlotVisibleToTeam;

	mov	edx, DWORD PTR _kNodeCacheData$219403[ebp]
	mov	al, BYTE PTR [edx]
	and	al, 1
	mov	BYTE PTR _bPreviousVisibleToTeam$[ebp], al

; 2052 : #endif
; 2053 : 		// JON - Special case for the original node passed into this function because it's not yet linked to any parent
; 2054 : 		if(pNode == node && bFirstRun)

	mov	ecx, DWORD PTR _pNode$[ebp]
	cmp	ecx, DWORD PTR _node$[ebp]
	jne	SHORT $LN23@PathValid
	movzx	edx, BYTE PTR _bFirstRun$[ebp]
	test	edx, edx
	je	SHORT $LN23@PathValid

; 2055 : 		{
; 2056 : 			pNode = parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	DWORD PTR _pNode$[ebp], eax

; 2057 : 			bFirstRun = false;

	mov	BYTE PTR _bFirstRun$[ebp], 0

; 2058 : 		}
; 2059 : 		else

	jmp	SHORT $LN22@PathValid
$LN23@PathValid:

; 2060 : 		{
; 2061 : 			pNode = pNode->m_pParent;

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _pNode$[ebp], edx
$LN22@PathValid:

; 2062 : 		}
; 2063 : 
; 2064 : 		if(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN21@PathValid

; 2065 : 		{
; 2066 : 			iNodeX = pNode->m_iX;

	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR _iNodeX$[ebp], ecx

; 2067 : 			iNodeY = pNode->m_iY;

	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	DWORD PTR _iNodeY$[ebp], eax

; 2068 : 			iOldNumTurns = iNumTurns;

	mov	ecx, DWORD PTR _iNumTurns$[ebp]
	mov	DWORD PTR _iOldNumTurns$[ebp], ecx

; 2069 : 			iNumTurns = pNode->m_iData2;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iNumTurns$[ebp], eax
$LN21@PathValid:

; 2070 : 		}
; 2071 : 	}

	jmp	$LN43@PathValid
$LN42@PathValid:

; 2072 : 
; 2073 : 	// slewis - moved this up so units can't move directly into the water. Not 100% sure this is the right solution.
; 2074 : 	if(unit_domain_type == DOMAIN_LAND)

	cmp	DWORD PTR _unit_domain_type$[ebp], 2
	jne	$LN20@PathValid

; 2075 : 	{
; 2076 : 		if(!kFromNodeCacheData.bIsWater && kToNodeCacheData.bIsWater && kToNodeCacheData.bIsRevealedToTeam && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	mov	ecx, DWORD PTR _kFromNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 2
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN20@PathValid
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 2
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN20@PathValid
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 4
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN20@PathValid
	push	0
	push	1
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN20@PathValid

; 2077 : 		{
; 2078 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2079 : 			if (!pUnit->canMoveAllTerrain())
; 2080 : #else
; 2081 : 			if(!pUnit->IsHoveringUnit() && !pUnit->canMoveAllTerrain() && !pToPlot->IsAllowsWalkWater())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@PathValid
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@PathValid
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN20@PathValid

; 2082 : #endif
; 2083 : 			{
; 2084 : 				return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN20@PathValid:

; 2085 : 			}
; 2086 : 		}
; 2087 : 	}
; 2088 : 
; 2089 : #ifndef AUI_ASTAR_FIX_RADAR
; 2090 : 	if(!bUnitIsCombat && unit_domain_type != DOMAIN_AIR)
; 2091 : 	{
; 2092 : 		const PlayerTypes eUnitPlayer = unit_owner;
; 2093 : 		const int iUnitCount = pToPlot->getNumUnits();
; 2094 : 		for(int iUnit = 0; iUnit < iUnitCount; ++iUnit)
; 2095 : 		{
; 2096 : 			const CvUnit* pToPlotUnit = pToPlot->getUnitByIndex(iUnit);
; 2097 : 			if(pToPlotUnit != NULL && pToPlotUnit->getOwner() != eUnitPlayer)
; 2098 : 			{
; 2099 : 				return FALSE; // Plot occupied by another player
; 2100 : 			}
; 2101 : 		}
; 2102 : 	}
; 2103 : #endif
; 2104 : 
; 2105 : 	// slewis - Added to catch when the unit is adjacent to an enemy unit while it is stacked with a friendly unit.
; 2106 : 	//          The logic above (with bPreviousNodeHostile) catches this problem with a path that's longer than one step
; 2107 : 	//          but does not catch when the path is only one step.
; 2108 : #ifdef AUI_ASTAR_FIX_RADAR
; 2109 : 	if (unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))

	cmp	DWORD PTR _unit_domain_type$[ebp], 1
	je	SHORT $LN17@PathValid
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	call	?isAdjacent@CvPlot@@QBE_NPBV1@@Z	; CvPlot::isAdjacent
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@PathValid
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@PathValid
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN17@PathValid

; 2110 : #else
; 2111 : 	if(bUnitIsCombat && unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))
; 2112 : #endif
; 2113 : 	{
; 2114 : 		if(kToNodeCacheData.bContainsVisibleEnemyDefender)

	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax+1]
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@PathValid

; 2115 : 		{
; 2116 : 			if(pUnitPlot->getNumFriendlyUnitsOfType(pUnit) > iUnitPlotLimit)

	push	1
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR _iUnitPlotLimit$[ebp]
	jle	SHORT $LN17@PathValid

; 2117 : 			{
; 2118 : 				return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN17@PathValid:

; 2119 : 			}
; 2120 : 		}
; 2121 : 	}
; 2122 : 
; 2123 : 	if(pUnitPlot == pFromPlot)

	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	cmp	ecx, DWORD PTR _pFromPlot$[ebp]
	jne	SHORT $LN14@PathValid

; 2124 : 	{
; 2125 : 		return TRUE;

	mov	eax, 1
	jmp	$LN49@PathValid
$LN14@PathValid:

; 2126 : 	}
; 2127 : 
; 2128 : 	if(iFinderInfo & MOVE_TERRITORY_NO_UNEXPLORED)

	mov	edx, DWORD PTR _iFinderInfo$[ebp]
	and	edx, 1
	je	SHORT $LN13@PathValid

; 2129 : 	{
; 2130 : 		if(!(kFromNodeCacheData.bIsRevealedToTeam))

	mov	eax, DWORD PTR _kFromNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN12@PathValid

; 2131 : 		{
; 2132 : 			return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN12@PathValid:

; 2133 : 		}
; 2134 : 
; 2135 : 		if(bFromPlotOwned)

	movzx	eax, BYTE PTR _bFromPlotOwned$[ebp]
	test	eax, eax
	je	SHORT $LN13@PathValid

; 2136 : 		{
; 2137 : 			if(eFromPlotTeam != eUnitTeam)

	mov	ecx, DWORD PTR _eFromPlotTeam$[ebp]
	cmp	ecx, DWORD PTR _eUnitTeam$[ebp]
	je	SHORT $LN13@PathValid

; 2138 : 			{
; 2139 : 				return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN13@PathValid:

; 2140 : 			}
; 2141 : 		}
; 2142 : 	}
; 2143 : 
; 2144 : 	if(iFinderInfo & MOVE_TERRITORY_NO_ENEMY)

	mov	edx, DWORD PTR _iFinderInfo$[ebp]
	and	edx, 2
	je	SHORT $LN9@PathValid

; 2145 : 	{
; 2146 : 		if(bFromPlotOwned)

	movzx	eax, BYTE PTR _bFromPlotOwned$[ebp]
	test	eax, eax
	je	SHORT $LN9@PathValid

; 2147 : 		{
; 2148 : 			if(atWar(eFromPlotTeam, eUnitTeam))

	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eFromPlotTeam$[ebp]
	push	edx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@PathValid

; 2149 : 			{
; 2150 : 				return FALSE;

	xor	eax, eax
	jmp	$LN49@PathValid
$LN9@PathValid:

; 2151 : 			}
; 2152 : 		}
; 2153 : 	}
; 2154 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 2155 : 	if(bAIControl)
; 2156 : 	{
; 2157 : 		if((parent->m_iData2 > 1) || (parent->m_iData1 == 0))
; 2158 : 		{
; 2159 : 			if(!(iFinderInfo & MOVE_UNITS_IGNORE_DANGER))
; 2160 : 			{
; 2161 : 				if(!bUnitIsCombat || pUnit->getArmyID() == FFreeList::INVALID_INDEX)
; 2162 : 				{
; 2163 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_TO_PLOT_NOT_FROM_PLOT
; 2164 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 2165 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA
; 2166 : 					if (GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH &&
; 2167 : 						GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pFromPlot) <= pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2168 : #else
; 2169 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2170 : #endif
; 2171 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA)
; 2172 : 					if (GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pToPlot) > 0 && GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pFromPlot) <= 0)
; 2173 : #else
; 2174 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > 0)
; 2175 : #endif
; 2176 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2177 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 2178 : #else
; 2179 : 					if(GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > 0)
; 2180 : #endif
; 2181 : 					{
; 2182 : 						return FALSE;
; 2183 : 					}
; 2184 : 				}
; 2185 : 			}
; 2186 : 		}
; 2187 : 	}
; 2188 : #endif
; 2189 : 	// slewis - added AI check and embark check to prevent units from moving into unexplored areas
; 2190 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 2191 : 	if(kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked() || !bIsHuman)

	mov	ecx, DWORD PTR _kFromNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 4
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN5@PathValid
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+41]
	mov	BYTE PTR $T222725[ebp], dl
	movzx	eax, BYTE PTR $T222725[ebp]
	test	eax, eax
	jne	SHORT $LN5@PathValid
	movzx	ecx, BYTE PTR _bIsHuman$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@PathValid
$LN5@PathValid:

; 2192 : #else
; 2193 : 	if(bAIControl || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked() || !bIsHuman)
; 2194 : #endif
; 2195 : 	{
; 2196 : 		if(iFinderInfo & MOVE_UNITS_THROUGH_ENEMY)

	mov	edx, DWORD PTR _iFinderInfo$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN4@PathValid

; 2197 : 		{
; 2198 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2199 : 			if (!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 2200 : #else
; 2201 : 			if(!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	push	128					; 00000080H
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@PathValid

; 2202 : #endif
; 2203 : 			{
; 2204 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN49@PathValid
$LN3@PathValid:

; 2205 : 			}
; 2206 : 		}
; 2207 : 		else

	jmp	SHORT $LN6@PathValid
$LN4@PathValid:

; 2208 : 		{
; 2209 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2210 : 			if (!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 2211 : #else
; 2212 : 			if(!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	push	128					; 00000080H
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveThrough@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveThrough
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@PathValid

; 2213 : #endif
; 2214 : 			{
; 2215 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN49@PathValid
$LN6@PathValid:

; 2216 : 			}
; 2217 : 		}
; 2218 : 	}
; 2219 : 
; 2220 : 	return TRUE;

	mov	eax, 1
$LN49@PathValid:

; 2221 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; PathValid
_TEXT	ENDS
PUBLIC	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
EXTRN	?movesLeft@CvUnit@@QBEHXZ:PROC			; CvUnit::movesLeft
; Function compile flags: /Odtp
;	COMDAT ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv180 = -108						; size = 4
tv160 = -104						; size = 4
tv187 = -100						; size = 4
$T222828 = -96						; size = 4
$T222819 = -92						; size = 4
$T222813 = -88						; size = 4
$T222812 = -84						; size = 4
$T222808 = -80						; size = 4
$T222804 = -76						; size = 4
$T222800 = -69						; size = 1
$T222793 = -68						; size = 4
$T222789 = -64						; size = 4
$T222788 = -60						; size = 4
$T222771 = -56						; size = 4
$T222755 = -52						; size = 4
$T222743 = -48						; size = 4
$T222734 = -44						; size = 4
$T222731 = -40						; size = 4
$T222728 = -36						; size = 4
_kMap$219466 = -32					; size = 4
_pFromPlot$219467 = -28					; size = 4
_iStartMoves$219469 = -24				; size = 4
_pToPlot$219468 = -20					; size = 4
_pUnit$ = -16						; size = 4
_pCacheData$ = -12					; size = 4
_iMoves$ = -8						; size = 4
_iTurns$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; PathAdd, COMDAT

; 2228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 2229 : 	int iMoves = MAX_INT;

	mov	DWORD PTR _iMoves$[ebp], 2147483647	; 7fffffffH

; 2230 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 2231 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[ebp]
	add	ecx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], ecx

; 2232 : 
; 2233 : 	int iTurns;
; 2234 : 
; 2235 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN6@PathAdd

; 2236 : 	{
; 2237 : 		iTurns = 1;

	mov	DWORD PTR _iTurns$[ebp], 1

; 2238 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2239 : 		iMoves = pUnit->movesLeft();
; 2240 : #else
; 2241 : 		iMoves = std::min(iMoves, pUnit->movesLeft());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	mov	DWORD PTR $T222728[ebp], eax
	mov	edx, DWORD PTR $T222728[ebp]
	cmp	edx, DWORD PTR _iMoves$[ebp]
	jge	SHORT $LN17@PathAdd
	lea	eax, DWORD PTR $T222728[ebp]
	mov	DWORD PTR tv187[ebp], eax
	jmp	SHORT $LN18@PathAdd
$LN17@PathAdd:
	lea	ecx, DWORD PTR _iMoves$[ebp]
	mov	DWORD PTR tv187[ebp], ecx
$LN18@PathAdd:
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T222743[ebp], edx
	mov	eax, DWORD PTR $T222743[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iMoves$[ebp], ecx

; 2242 : #endif
; 2243 : 	}
; 2244 : 	else

	jmp	$LN5@PathAdd
$LN6@PathAdd:

; 2245 : 	{
; 2246 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2247 : 		const CvPlot* pFromPlot = parent->m_pPlot;
; 2248 : 		const CvPlot* pToPlot = node->m_pPlot;
; 2249 : #else
; 2250 : 		CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$219466[ebp], edx

; 2251 : 		CvPlot* pFromPlot = kMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	eax, DWORD PTR _kMap$219466[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T222755[ebp], ecx
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T222755[ebp]
	add	edx, eax
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$219466[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pFromPlot$219467[ebp], edx

; 2252 : 		CvPlot* pToPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _kMap$219466[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T222771[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T222771[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$219466[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$219468[ebp], eax

; 2253 : #endif
; 2254 : 
; 2255 : 		int iStartMoves = parent->m_iData1;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _iStartMoves$219469[ebp], eax

; 2256 : 		iTurns = parent->m_iData2;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _iTurns$[ebp], edx

; 2257 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2258 : 		int iBaseMoves = pCacheData->baseMoves(((pFromPlot->isWater() && !pFromPlot->IsAllowsWalkWater()) || pCacheData->isEmbarked()) ? DOMAIN_SEA : pCacheData->getDomainType());
; 2259 : #endif
; 2260 : 
; 2261 : 		if(iStartMoves == 0)

	cmp	DWORD PTR _iStartMoves$219469[ebp], 0
	jne	SHORT $LN4@PathAdd

; 2262 : 		{
; 2263 : 			iTurns++;

	mov	eax, DWORD PTR _iTurns$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTurns$[ebp], eax

; 2264 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2265 : 			iStartMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 2266 : #else
; 2267 : 			iStartMoves = pCacheData->baseMoves((pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) ? DOMAIN_SEA : DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	mov	ecx, DWORD PTR _pToPlot$219468[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@PathAdd
	mov	ecx, DWORD PTR _pToPlot$219468[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@PathAdd
	mov	DWORD PTR $T222788[ebp], 0
	jmp	SHORT $LN10@PathAdd
$LN9@PathAdd:
	mov	DWORD PTR $T222788[ebp], 2
$LN10@PathAdd:
	mov	eax, DWORD PTR $T222788[ebp]
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T222789[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T222793[ebp], eax
	mov	ecx, DWORD PTR $T222789[ebp]
	imul	ecx, DWORD PTR $T222793[ebp]
	mov	DWORD PTR _iStartMoves$219469[ebp], ecx
$LN4@PathAdd:

; 2268 : #endif
; 2269 : 		}
; 2270 : 
; 2271 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2272 : 		// We can just set maxMoves to the maximum integer value and use it for increased portability and no redundant checks, iMoves gets set to 0 anyway if it's negative
; 2273 : 		iMoves = iStartMoves - CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, iBaseMoves, MAX_INT, iStartMoves);
; 2274 : 		if (iMoves < 0)
; 2275 : 			iMoves = 0;
; 2276 : #else
; 2277 : 		// We can't use maxMoves, because that checks where the unit is currently, and we're plotting a path so we have to see
; 2278 : 		// what the max moves would be like if the unit was already at the desired location.
; 2279 : 		if (CvUnitMovement::ConsumesAllMoves(pUnit, pFromPlot, pToPlot) || CvUnitMovement::IsSlowedByZOC(pUnit, pFromPlot, pToPlot))

	mov	edx, DWORD PTR _pToPlot$219468[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$219467[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	call	?ConsumesAllMoves@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::ConsumesAllMoves
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@PathAdd
	mov	eax, DWORD PTR _pToPlot$219468[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$219467[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	call	?IsSlowedByZOC@CvUnitMovement@@SA_NPBVCvUnit@@PBVCvPlot@@1@Z ; CvUnitMovement::IsSlowedByZOC
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN39@PathAdd
$LN2@PathAdd:

; 2280 : 		{
; 2281 : 			iMoves = 0;

	mov	DWORD PTR _iMoves$[ebp], 0

; 2282 : 		}
; 2283 : 		else

	jmp	$LN5@PathAdd

; 2284 : 		{
; 2285 : 			iMoves = std::min(iMoves, std::max(0, iStartMoves - CvUnitMovement::MovementCost(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves(), iStartMoves)));

$LN39@PathAdd:
	mov	ecx, DWORD PTR _pToPlot$219468[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@PathAdd
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+41]
	mov	BYTE PTR $T222800[ebp], al
	movzx	ecx, BYTE PTR $T222800[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@PathAdd
	mov	edx, DWORD PTR $T222804[ebp]
	mov	DWORD PTR $T222812[ebp], edx
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T222812[ebp], ecx
	jmp	SHORT $LN12@PathAdd
$LN11@PathAdd:
	mov	DWORD PTR $T222812[ebp], 0
$LN12@PathAdd:
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T222808[ebp], eax
	mov	ecx, DWORD PTR $T222812[ebp]
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T222813[ebp], eax
	mov	ecx, DWORD PTR _iStartMoves$219469[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222808[ebp]
	push	edx
	mov	eax, DWORD PTR $T222813[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$219468[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$219467[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _iStartMoves$219469[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T222731[ebp], ecx
	mov	DWORD PTR $T222734[ebp], 0
	mov	edx, DWORD PTR $T222734[ebp]
	cmp	edx, DWORD PTR $T222731[ebp]
	jge	SHORT $LN51@PathAdd
	lea	eax, DWORD PTR $T222731[ebp]
	mov	DWORD PTR tv160[ebp], eax
	jmp	SHORT $LN52@PathAdd
$LN51@PathAdd:
	lea	ecx, DWORD PTR $T222734[ebp]
	mov	DWORD PTR tv160[ebp], ecx
$LN52@PathAdd:
	mov	edx, DWORD PTR tv160[ebp]
	mov	DWORD PTR $T222819[ebp], edx
	mov	eax, DWORD PTR $T222819[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _iMoves$[ebp]
	jge	SHORT $LN55@PathAdd
	mov	edx, DWORD PTR $T222819[ebp]
	mov	DWORD PTR tv180[ebp], edx
	jmp	SHORT $LN56@PathAdd
$LN55@PathAdd:
	lea	eax, DWORD PTR _iMoves$[ebp]
	mov	DWORD PTR tv180[ebp], eax
$LN56@PathAdd:
	mov	ecx, DWORD PTR tv180[ebp]
	mov	DWORD PTR $T222828[ebp], ecx
	mov	edx, DWORD PTR $T222828[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iMoves$[ebp], eax
$LN5@PathAdd:

; 2286 : 		}
; 2287 : #endif
; 2288 : 	}
; 2289 : 
; 2290 : 	FAssertMsg(iMoves >= 0, "iMoves is expected to be non-negative (invalid Index)");
; 2291 : 
; 2292 : 	node->m_iData1 = iMoves;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _iMoves$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 2293 : 	node->m_iData2 = iTurns;

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR _iTurns$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 2294 : 
; 2295 : 	return 1;

	mov	eax, 1

; 2296 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; PathAdd
_TEXT	ENDS
PUBLIC	?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z ; CvTwoLayerPathFinder::GetPartialMoveNode
PUBLIC	?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
; Function compile flags: /Odtp
;	COMDAT ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T222865 = -36						; size = 4
$T222854 = -32						; size = 4
$T222848 = -28						; size = 4
$T222844 = -24						; size = 4
$T222840 = -17						; size = 1
$T222839 = -16						; size = 4
$T222838 = -12						; size = 4
_twoLayerFinder$219488 = -8				; size = 4
_pNode$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; PathNodeAdd, COMDAT

; 2301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2302 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 2303 : 	CvAStarNode* pNode;
; 2304 : #endif
; 2305 : 
; 2306 : 	if(data == ASNL_ADDOPEN || data == ASNL_STARTOPEN)

	cmp	DWORD PTR _data$[ebp], 0
	je	SHORT $LN3@PathNodeAd
	cmp	DWORD PTR _data$[ebp], 1
	jne	$LN4@PathNodeAd
$LN3@PathNodeAd:

; 2307 : 	{
; 2308 : 		// Are there movement points left and we're worried about stacking or mountains?
; 2309 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 2310 : 		if (node->m_iData1 > 0 && !finder->IsPathDest(node->m_iX, node->m_iY) && (!(finder->GetInfo() & MOVE_IGNORE_STACKING) || node->m_pPlot->isMountain()))
; 2311 : #else
; 2312 : 		if(node->m_iData1 > 0 && !finder->IsPathDest(node->m_iX, node->m_iY) && (!(finder->GetInfo() & MOVE_IGNORE_STACKING) || GC.getMap().plotUnchecked(node->m_iX, node->m_iY)->isMountain()))

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jle	$LN4@PathNodeAd
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T222839[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T222838[ebp], ecx
	mov	edx, DWORD PTR _finder$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN7@PathNodeAd
	mov	eax, DWORD PTR _finder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR $T222839[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222838[ebp]
	push	ecx
	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN7@PathNodeAd
	mov	BYTE PTR $T222840[ebp], 1
	jmp	SHORT $LN8@PathNodeAd
$LN7@PathNodeAd:
	mov	BYTE PTR $T222840[ebp], 0
$LN8@PathNodeAd:
	movzx	ecx, BYTE PTR $T222840[ebp]
	test	ecx, ecx
	jne	$LN4@PathNodeAd
	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR $T222844[ebp], eax
	mov	ecx, DWORD PTR $T222844[ebp]
	and	ecx, 4
	je	SHORT $LN1@PathNodeAd
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222848[ebp], edx
	mov	eax, DWORD PTR $T222848[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T222854[ebp], ecx
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T222854[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	add	eax, edx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T222848[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR $T222865[ebp], eax
	mov	edx, DWORD PTR $T222865[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@PathNodeAd
$LN1@PathNodeAd:

; 2313 : #endif
; 2314 : 		{
; 2315 : 			// Retrieve another node
; 2316 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 2317 : 			CvTwoLayerPathFinder* twoLayerFinder = static_cast<CvTwoLayerPathFinder*>(finder);
; 2318 : 			CvAStarNode* pNode = twoLayerFinder->GetPartialMoveNode(node->m_iX, node->m_iY);
; 2319 : #else
; 2320 : 			CvTwoLayerPathFinder* twoLayerFinder = static_cast<CvTwoLayerPathFinder*>(finder);

	mov	edx, DWORD PTR _finder$[ebp]
	mov	DWORD PTR _twoLayerFinder$219488[ebp], edx

; 2321 : 			pNode = twoLayerFinder->GetPartialMoveNode(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _twoLayerFinder$219488[ebp]
	call	?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z ; CvTwoLayerPathFinder::GetPartialMoveNode
	mov	DWORD PTR _pNode$[ebp], eax

; 2322 : #endif
; 2323 : 			pNode->m_iData1 = 0;   // Zero out movement

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 2324 : 			pNode->m_iData2 = node->m_iData2;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 2325 : 			pNode->m_iHeuristicCost = node->m_iHeuristicCost;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx

; 2326 : 			pNode->m_iKnownCost = node->m_iKnownCost + (PATH_MOVEMENT_WEIGHT * node->m_iData1);

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _node$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _pNode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2327 : 			pNode->m_iTotalCost = node->m_iTotalCost;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2328 : 			pNode->m_iX = node->m_iX;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	dx, WORD PTR [ecx+80]
	mov	WORD PTR [eax+80], dx

; 2329 : 			pNode->m_iY = node->m_iY;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	dx, WORD PTR [ecx+82]
	mov	WORD PTR [eax+82], dx

; 2330 : 			pNode->m_pParent = node->m_pParent;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 2331 : 			pNode->m_eCvAStarListType = CVASTARLIST_OPEN;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	DWORD PTR [eax+20], 0

; 2332 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2333 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2334 : 			pNode->bIsCalculated = node->bIsCalculated;
; 2335 : #endif
; 2336 : 			pNode->bPlotVisibleToTeam = node->bPlotVisibleToTeam;
; 2337 : 			pNode->bIsMountain = node->bIsMountain;
; 2338 : 			pNode->bIsWater = node->bIsWater;
; 2339 : 			pNode->bCanEnterTerrain = node->bCanEnterTerrain;
; 2340 : 			pNode->bIsRevealedToTeam = node->bIsRevealedToTeam;
; 2341 : 			pNode->bContainsOtherFriendlyTeamCity = node->bContainsOtherFriendlyTeamCity;
; 2342 : 			pNode->bContainsEnemyCity = node->bContainsEnemyCity;
; 2343 : 			pNode->bContainsVisibleEnemy = node->bContainsVisibleEnemy;
; 2344 : 			pNode->bContainsVisibleEnemyDefender = node->bContainsVisibleEnemyDefender;
; 2345 : #else
; 2346 : 			pNode->m_kCostCacheData = node->m_kCostCacheData;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	DWORD PTR [ecx+88], edx
	mov	DWORD PTR [ecx+92], eax

; 2347 : #endif
; 2348 : 			finder->AddToOpen(pNode);

	mov	edx, DWORD PTR _pNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _finder$[ebp]
	call	?AddToOpen@CvAStar@@QAEXPAVCvAStarNode@@@Z ; CvAStar::AddToOpen
$LN4@PathNodeAd:

; 2349 : 		}
; 2350 : 	}
; 2351 : 
; 2352 : 	return 1;

	mov	eax, 1

; 2353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; PathNodeAdd
_TEXT	ENDS
PUBLIC	?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z	; IgnoreUnitsDestValid
EXTRN	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z:PROC ; CvUnit::canEnterTerritory
; Function compile flags: /Odtp
;	COMDAT ?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_uiOffset$222963 = -64					; size = 4
$T222954 = -57						; size = 1
_uiOffset$222949 = -56					; size = 4
$T222934 = -52						; size = 4
$T222930 = -45						; size = 1
$T222916 = -44						; size = 4
$T222910 = -40						; size = 4
$T222901 = -36						; size = 4
$T222879 = -32						; size = 4
_pUnit$ = -28						; size = 4
_kMap$ = -24						; size = 4
_bAIControl$ = -17					; size = 1
_pUnitPlot$ = -16					; size = 4
_pCacheData$ = -12					; size = 4
_eUnitTeam$ = -8					; size = 4
_pToPlot$ = -4						; size = 4
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC	; IgnoreUnitsDestValid, COMDAT

; 2362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 2363 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2364 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(iToX, iToY);
; 2365 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 2366 : #else
; 2367 : 	CvUnit* pUnit;
; 2368 : 	CvPlot* pToPlot;
; 2369 : 	bool bAIControl;
; 2370 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 2371 : 
; 2372 : 	pToPlot = kMap.plotUnchecked(iToX, iToY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T222879[ebp], edx
	mov	eax, DWORD PTR _iToY$[ebp]
	imul	eax, DWORD PTR $T222879[ebp]
	add	eax, DWORD PTR _iToX$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$[ebp], eax

; 2373 : 
; 2374 : 	pUnit = ((CvUnit*)pointer);

	mov	edx, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], edx

; 2375 : #endif
; 2376 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	eax, DWORD PTR _finder$[ebp]
	add	eax, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], eax

; 2377 : 
; 2378 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2379 : 	CvPlot* pUnitPlot = pUnit->plot();
; 2380 : #else
; 2381 : 	CvPlot* pUnitPlot = kMap.plotUnchecked(pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T222901[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T222910[ebp], ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T222916[ebp], eax
	mov	ecx, DWORD PTR $T222901[ebp]
	imul	ecx, DWORD PTR $T222916[ebp]
	add	ecx, DWORD PTR $T222910[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pUnitPlot$[ebp], ecx

; 2382 : #endif
; 2383 : 	if(pUnitPlot == pToPlot)

	mov	eax, DWORD PTR _pUnitPlot$[ebp]
	cmp	eax, DWORD PTR _pToPlot$[ebp]
	jne	SHORT $LN8@IgnoreUnit

; 2384 : 	{
; 2385 : 		return TRUE;

	mov	eax, 1
	jmp	$LN9@IgnoreUnit
$LN8@IgnoreUnit:

; 2386 : 	}
; 2387 : 
; 2388 : 	if(pCacheData->IsImmobile())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+38]
	mov	BYTE PTR $T222930[ebp], dl
	movzx	eax, BYTE PTR $T222930[ebp]
	test	eax, eax
	je	SHORT $LN7@IgnoreUnit

; 2389 : 	{
; 2390 : 		return FALSE;

	xor	eax, eax
	jmp	$LN9@IgnoreUnit
$LN7@IgnoreUnit:

; 2391 : 	}
; 2392 : 
; 2393 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 2394 : 	if(pToPlot->isMountain() && (!pCacheData->isHuman() || pCacheData->IsAutomated()))
; 2395 : 	{
; 2396 : 		return FALSE;
; 2397 : 	}
; 2398 : #endif
; 2399 : 
; 2400 : 	if ((finder->GetInfo() & CvUnit::MOVEFLAG_STAY_ON_LAND) && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()))

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T222934[ebp], edx
	mov	eax, DWORD PTR $T222934[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN6@IgnoreUnit
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@IgnoreUnit
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@IgnoreUnit

; 2401 : 	{
; 2402 : 		return FALSE;

	xor	eax, eax
	jmp	$LN9@IgnoreUnit
$LN6@IgnoreUnit:

; 2403 : 	}
; 2404 : 
; 2405 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2406 : 	bool bAIControl = pCacheData->IsAutomated();
; 2407 : #else
; 2408 : 	bAIControl = pCacheData->IsAutomated();

	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+37]
	mov	BYTE PTR _bAIControl$[ebp], cl

; 2409 : #endif
; 2410 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 2411 : 	if(bAIControl)
; 2412 : 	{
; 2413 : 		if(pCacheData->getDomainType() == DOMAIN_LAND)
; 2414 : 		{
; 2415 : 			int iGroupAreaID = pUnit->area()->GetID();
; 2416 : 			if(pToPlot->getArea() != iGroupAreaID)
; 2417 : 			{
; 2418 : 				if(!(pToPlot->isAdjacentToArea(iGroupAreaID)))
; 2419 : 				{
; 2420 : 					return FALSE;
; 2421 : 				}
; 2422 : 			}
; 2423 : 		}
; 2424 : 	}
; 2425 : #endif
; 2426 : 
; 2427 : 	TeamTypes eUnitTeam = pUnit->getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 2428 : 
; 2429 : 	if(!pToPlot->isRevealed(eUnitTeam))

	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$222949[ebp], edx
	mov	eax, DWORD PTR _uiOffset$222949[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$222949[ebp]
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN5@IgnoreUnit

; 2430 : 	{
; 2431 : 		if(pCacheData->isNoRevealMap())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+39]
	mov	BYTE PTR $T222954[ebp], dl
	movzx	eax, BYTE PTR $T222954[ebp]
	test	eax, eax
	je	SHORT $LN5@IgnoreUnit

; 2432 : 		{
; 2433 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN9@IgnoreUnit
$LN5@IgnoreUnit:

; 2434 : 		}
; 2435 : 	}
; 2436 : 
; 2437 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 2438 : 	if(pToPlot->isRevealed(eUnitTeam))

	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$222963[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$222963[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$222963[ebp]
	mov	edx, DWORD PTR _pToPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@IgnoreUnit

; 2439 : #else
; 2440 : 	if(bAIControl || pToPlot->isRevealed(eUnitTeam))
; 2441 : #endif
; 2442 : 	{
; 2443 : #ifdef AUI_ASTAR_FIX_IGNORE_UNITS_PATHFINDER_TERRITORY_CHECK
; 2444 : 		if (!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(pToPlot->getTeam(), false, false, pUnit->IsDeclareWar() || (finder->GetInfo() & MOVE_DECLARE_WAR)))
; 2445 : #else
; 2446 : 		if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(eUnitTeam))

	push	128					; 00000080H
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IgnoreUnit
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z ; CvUnit::canEnterTerritory
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@IgnoreUnit
$LN1@IgnoreUnit:

; 2447 : #endif
; 2448 : 		{
; 2449 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN9@IgnoreUnit
$LN3@IgnoreUnit:

; 2450 : 		}
; 2451 : 	}
; 2452 : 	return TRUE;

	mov	eax, 1
$LN9@IgnoreUnit:

; 2453 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP	; IgnoreUnitsDestValid
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
PUBLIC	?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsCost
EXTRN	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCostNoZOC
; Function compile flags: /Odtp
;	COMDAT ?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv309 = -300						; size = 4
tv327 = -296						; size = 4
tv450 = -292						; size = 4
tv288 = -288						; size = 4
tv421 = -284						; size = 4
$T223288 = -280						; size = 4
$T223210 = -212						; size = 4
$T223203 = -205						; size = 1
$T223198 = -204						; size = 4
$T223194 = -200						; size = 4
$T223190 = -194						; size = 1
$T223186 = -193						; size = 1
$T223180 = -192						; size = 4
$T223165 = -185						; size = 1
$T223158 = -184						; size = 4
_uiOffset$223153 = -180					; size = 4
$T223144 = -176						; size = 4
$T223140 = -172						; size = 4
$T223136 = -168						; size = 4
$T223132 = -164						; size = 4
$T223128 = -160						; size = 4
$T223119 = -152						; size = 4
$T223113 = -148						; size = 4
$T223106 = -144						; size = 4
_f$223099 = -138					; size = 1
_f$223090 = -137					; size = 1
$T223084 = -136						; size = 4
$T223077 = -132						; size = 4
$T223073 = -128						; size = 4
_playerID$223065 = -124					; size = 4
$T223050 = -120						; size = 4
$T223049 = -116						; size = 4
$T223045 = -112						; size = 4
$T223041 = -108						; size = 4
$T223037 = -101						; size = 1
$T223030 = -100						; size = 4
$T223026 = -96						; size = 4
$T223025 = -92						; size = 4
$T223005 = -88						; size = 4
$T222989 = -84						; size = 4
$T222980 = -80						; size = 4
$T222977 = -76						; size = 4
$T222976 = -72						; size = 4
$T222973 = -68						; size = 4
$T222972 = -64						; size = 4
$T222971 = -60						; size = 4
_iUnseenPlots$219552 = -56				; size = 4
_pUnit$ = -52						; size = 4
_kMap$ = -48						; size = 4
_iMovesLeft$ = -44					; size = 4
_iFromPlotX$ = -40					; size = 4
_iFromPlotY$ = -36					; size = 4
_pCacheData$ = -32					; size = 4
_iMax$ = -28						; size = 4
_iToPlotX$ = -24					; size = 4
_eUnitTeam$ = -20					; size = 4
_pFromPlot$ = -16					; size = 4
_iToPlotY$ = -12					; size = 4
_iCost$ = -8						; size = 4
_pToPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; IgnoreUnitsCost, COMDAT

; 2459 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH

; 2460 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 2461 : 	CvUnit* pUnit;
; 2462 : 	int iCost;
; 2463 : #endif
; 2464 : 	int iMax;
; 2465 : 
; 2466 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2467 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 2468 : 	const CvPlot* pToPlot = node->m_pPlot;
; 2469 : #else
; 2470 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 2471 : 	int iFromPlotX = parent->m_iX;

	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	DWORD PTR _iFromPlotX$[ebp], edx

; 2472 : 	int iFromPlotY = parent->m_iY;

	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR _iFromPlotY$[ebp], ecx

; 2473 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T222989[ebp], eax
	mov	ecx, DWORD PTR _iFromPlotY$[ebp]
	imul	ecx, DWORD PTR $T222989[ebp]
	add	ecx, DWORD PTR _iFromPlotX$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], ecx

; 2474 : 
; 2475 : 	int iToPlotX = node->m_iX;

	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR _iToPlotX$[ebp], ecx

; 2476 : 	int iToPlotY = node->m_iY;

	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	DWORD PTR _iToPlotY$[ebp], eax

; 2477 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223005[ebp], edx
	mov	eax, DWORD PTR _iToPlotY$[ebp]
	imul	eax, DWORD PTR $T223005[ebp]
	add	eax, DWORD PTR _iToPlotX$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$[ebp], eax

; 2478 : #endif
; 2479 : 
; 2480 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2481 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 2482 : #else
; 2483 : 	pUnit = ((CvUnit*)pointer);

	mov	edx, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], edx

; 2484 : #endif
; 2485 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	eax, DWORD PTR _finder$[ebp]
	add	eax, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], eax

; 2486 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2487 : 	bool bIsAIControl = !pCacheData->isHuman() || pCacheData->IsAutomated();
; 2488 : #endif
; 2489 : 
; 2490 : 	CvAssertMsg(pUnit->getDomainType() != DOMAIN_AIR, "pUnit->getDomainType() is not expected to be equal with DOMAIN_AIR");
; 2491 : 
; 2492 : #if defined(AUI_ASTAR_MINOR_OPTIMIZATION) || defined (AUI_UNIT_FIX_HOVERING_EMBARK) || defined(AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK)
; 2493 : 	bool bToPlotIsWater = !pToPlot->IsAllowsWalkWater();
; 2494 : 	bool bFromPlotIsWater = !pFromPlot->IsAllowsWalkWater();
; 2495 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2496 : 	if (pUnit->IsHoveringUnit())
; 2497 : 	{
; 2498 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2499 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2500 : 	}
; 2501 : 	else
; 2502 : #endif
; 2503 : 	{
; 2504 : 		bToPlotIsWater = bToPlotIsWater && pToPlot->isWater();
; 2505 : 		bFromPlotIsWater = bFromPlotIsWater && pFromPlot->isWater();
; 2506 : 	}
; 2507 : 	int iBaseMoves = pCacheData->baseMoves(bFromPlotIsWater || pCacheData->isEmbarked() ? DOMAIN_SEA : pCacheData->getDomainType());
; 2508 : 	int iMaxMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 2509 : #endif
; 2510 : 
; 2511 : 	if(parent->m_iData1 > 0)

	mov	ecx, DWORD PTR _parent$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN53@IgnoreUnit@2

; 2512 : 	{
; 2513 : 		iMax = parent->m_iData1;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _iMax$[ebp], eax

; 2514 : 	}
; 2515 : 	else

	jmp	SHORT $LN59@IgnoreUnit@2

; 2516 : 	{
; 2517 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2518 : 		iMax = iMaxMoves;
; 2519 : #else
; 2520 : 		iMax = pCacheData->baseMoves((pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) ? DOMAIN_SEA : DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

$LN53@IgnoreUnit@2:
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN29@IgnoreUnit@2
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN29@IgnoreUnit@2
	mov	DWORD PTR $T223025[ebp], 0
	jmp	SHORT $LN30@IgnoreUnit@2
$LN29@IgnoreUnit@2:
	mov	DWORD PTR $T223025[ebp], 2
$LN30@IgnoreUnit@2:
	mov	eax, DWORD PTR $T223025[ebp]
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T223026[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T223030[ebp], eax
	mov	ecx, DWORD PTR $T223026[ebp]
	imul	ecx, DWORD PTR $T223030[ebp]
	mov	DWORD PTR _iMax$[ebp], ecx

; 2521 : #endif
; 2522 : 	}
; 2523 : 
; 2524 : 	// Get the cost of moving to the new plot, passing in our max moves or the moves we have left, in case the movementCost 
; 2525 : 	// method wants to burn all our remaining moves.  This is needed because our remaining moves for this segment of the path
; 2526 : 	// may be larger or smaller than the baseMoves if some moves have already been used or if the starting domain (LAND/SEA)
; 2527 : 	// of the path segment is different from the destination plot.
; 2528 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2529 : 	int iCost = CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, iBaseMoves, iMaxMoves, iMax);
; 2530 : #else
; 2531 : 	iCost = CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves(), iMax);

$LN59@IgnoreUnit@2:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN31@IgnoreUnit@2
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+41]
	mov	BYTE PTR $T223037[ebp], cl
	movzx	edx, BYTE PTR $T223037[ebp]
	test	edx, edx
	jne	SHORT $LN31@IgnoreUnit@2
	mov	eax, DWORD PTR $T223041[ebp]
	mov	DWORD PTR $T223049[ebp], eax
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR $T223049[ebp], edx
	jmp	SHORT $LN32@IgnoreUnit@2
$LN31@IgnoreUnit@2:
	mov	DWORD PTR $T223049[ebp], 0
$LN32@IgnoreUnit@2:
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T223045[ebp], ecx
	mov	edx, DWORD PTR $T223049[ebp]
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T223050[ebp], ecx
	mov	edx, DWORD PTR _iMax$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223045[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223050[ebp]
	push	ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	call	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC
	add	esp, 24					; 00000018H
	mov	DWORD PTR _iCost$[ebp], eax

; 2532 : #endif
; 2533 : 
; 2534 : 	TeamTypes eUnitTeam = pUnit->getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 2535 : 
; 2536 : 	int iMovesLeft = iMax - iCost;

	mov	edx, DWORD PTR _iMax$[ebp]
	sub	edx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iMovesLeft$[ebp], edx

; 2537 : 	// Is the cost greater than our max?
; 2538 : 	if (iMovesLeft < 0)

	jns	SHORT $LN24@IgnoreUnit@2

; 2539 : 	{
; 2540 : 		// Yes, we will still let the move happen, but that is the end of the turn.
; 2541 : 		iCost = iMax;

	mov	eax, DWORD PTR _iMax$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 2542 : 		iMovesLeft = 0;

	mov	DWORD PTR _iMovesLeft$[ebp], 0
$LN24@IgnoreUnit@2:

; 2543 : 	}
; 2544 : 
; 2545 : 	if(iMovesLeft == 0)

	cmp	DWORD PTR _iMovesLeft$[ebp], 0
	jne	$LN23@IgnoreUnit@2

; 2546 : 	{
; 2547 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	mov	ecx, DWORD PTR _iCost$[ebp]
	imul	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], ecx

; 2548 : 
; 2549 : #ifdef AUI_UNIT_MOVEMENT_FIX_BAD_ALLOWS_WATER_WALK_CHECK
; 2550 : 		if (pUnit->getDomainType() == DOMAIN_LAND && !bFromPlotIsWater && bToPlotIsWater && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))
; 2551 : #else
; 2552 : 		if(!pFromPlot->isWater() && pToPlot->isWater() && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN77@IgnoreUnit@2
	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN77@IgnoreUnit@2
	push	0
	push	1
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN77@IgnoreUnit@2

; 2553 : #endif
; 2554 : 		{
; 2555 : 			iCost += PATH_INCORRECT_EMBARKING_WEIGHT;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 1000000				; 000f4240H
	mov	DWORD PTR _iCost$[ebp], ecx

; 2556 : 		}
; 2557 : 
; 2558 : 		if(pToPlot->getTeam() != eUnitTeam)

$LN77@IgnoreUnit@2:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$223065[ebp], eax
	cmp	DWORD PTR _playerID$223065[ebp], -1
	je	SHORT $LN74@IgnoreUnit@2
	mov	ecx, DWORD PTR _playerID$223065[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223073[ebp], eax
	jmp	SHORT $LN75@IgnoreUnit@2
	jmp	SHORT $LN75@IgnoreUnit@2
$LN74@IgnoreUnit@2:
	mov	DWORD PTR $T223073[ebp], -1
$LN75@IgnoreUnit@2:
	mov	edx, DWORD PTR $T223073[ebp]
	cmp	edx, DWORD PTR _eUnitTeam$[ebp]
	je	SHORT $LN21@IgnoreUnit@2

; 2559 : 		{
; 2560 : 			iCost += PATH_TERRITORY_WEIGHT;

	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, 3
	mov	DWORD PTR _iCost$[ebp], eax
$LN21@IgnoreUnit@2:

; 2561 : 		}
; 2562 : 
; 2563 : #ifdef AUI_ASTAR_EXPLORE_UNITAITYPE_ALWAYS_MAXIMIZES_EXPLORE
; 2564 : 		if (finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)
; 2565 : #else
; 2566 : 		if(finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE)

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T223077[ebp], edx
	mov	eax, DWORD PTR $T223077[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN20@IgnoreUnit@2

; 2567 : #endif
; 2568 : 		{
; 2569 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_UNHARDCODE_HILL_PREFERENCE
; 2570 : 			iCost += PATH_EXPLORE_NON_HILL_WEIGHT * pToPlot->seeFromLevel(eUnitTeam);
; 2571 : #else
; 2572 : 			if(!pToPlot->isHills())

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	sub	edx, 1
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN20@IgnoreUnit@2

; 2573 : 			{
; 2574 : 				iCost += PATH_EXPLORE_NON_HILL_WEIGHT;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 300				; 0000012cH
	mov	DWORD PTR _iCost$[ebp], ecx
$LN20@IgnoreUnit@2:

; 2575 : 			}
; 2576 : #endif
; 2577 : 		}
; 2578 : 
; 2579 : 		// Damage caused by features (mods)
; 2580 : 		if(0 != GC.getPATH_DAMAGE_WEIGHT())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944
	mov	DWORD PTR $T223084[ebp], edx
	cmp	DWORD PTR $T223084[ebp], 0
	je	$LN18@IgnoreUnit@2

; 2581 : 		{
; 2582 : 			if(pToPlot->getFeatureType() != NO_FEATURE)

	mov	eax, DWORD PTR _pToPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$223090[ebp], cl
	movsx	edx, BYTE PTR _f$223090[ebp]
	cmp	edx, -1
	je	$LN17@IgnoreUnit@2

; 2583 : 			{
; 2584 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2585 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * MAX(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();
; 2586 : #else
; 2587 : 				iCost += (GC.getPATH_DAMAGE_WEIGHT() * std::max(0, GC.getFeatureInfo(pToPlot->getFeatureType())->getTurnDamage())) / GC.getMAX_HIT_POINTS();

	mov	eax, DWORD PTR _pToPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$223099[ebp], cl
	movsx	edx, BYTE PTR _f$223099[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getTurnDamage@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getTurnDamage
	mov	DWORD PTR $T222971[ebp], eax
	mov	DWORD PTR $T222972[ebp], 0
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6944
	mov	DWORD PTR $T223106[ebp], eax
	mov	ecx, DWORD PTR $T222972[ebp]
	cmp	ecx, DWORD PTR $T222971[ebp]
	jge	SHORT $LN99@IgnoreUnit@2
	lea	edx, DWORD PTR $T222971[ebp]
	mov	DWORD PTR tv421[ebp], edx
	jmp	SHORT $LN100@IgnoreUnit@2
$LN99@IgnoreUnit@2:
	lea	eax, DWORD PTR $T222972[ebp]
	mov	DWORD PTR tv421[ebp], eax
$LN100@IgnoreUnit@2:
	mov	ecx, DWORD PTR tv421[ebp]
	mov	DWORD PTR $T223113[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7368
	mov	DWORD PTR $T223119[ebp], edx
	mov	eax, DWORD PTR $T223113[ebp]
	mov	ecx, DWORD PTR $T223106[ebp]
	imul	ecx, DWORD PTR [eax]
	mov	eax, ecx
	cdq
	idiv	DWORD PTR $T223119[ebp]
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN17@IgnoreUnit@2:

; 2588 : #endif
; 2589 : 			}
; 2590 : 
; 2591 : 			if(pToPlot->getExtraMovePathCost() > 0)

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	test	eax, eax
	jle	SHORT $LN18@IgnoreUnit@2

; 2592 : 			{
; 2593 : 				iCost += (PATH_MOVEMENT_WEIGHT * pToPlot->getExtraMovePathCost());

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getExtraMovePathCost@CvPlot@@QBEHXZ	; CvPlot::getExtraMovePathCost
	imul	eax, 1000				; 000003e8H
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN18@IgnoreUnit@2:

; 2594 : 			}
; 2595 : 		}
; 2596 : 
; 2597 : 		if(pToPlot->getPlotCity() && !(pToPlot->getX() == finder->GetDestX() && pToPlot->getY() == finder->GetDestY()))

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	je	SHORT $LN15@IgnoreUnit@2
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T223128[ebp], eax
	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR $T223132[ebp], edx
	mov	eax, DWORD PTR $T223128[ebp]
	cmp	eax, DWORD PTR $T223132[ebp]
	jne	SHORT $LN14@IgnoreUnit@2
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T223136[ebp], edx
	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T223140[ebp], ecx
	mov	edx, DWORD PTR $T223136[ebp]
	cmp	edx, DWORD PTR $T223140[ebp]
	je	SHORT $LN15@IgnoreUnit@2
$LN14@IgnoreUnit@2:

; 2598 : 		{
; 2599 : 			iCost += PATH_CITY_AVOID_WEIGHT; // slewis - this should be zeroed out currently

	mov	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN15@IgnoreUnit@2:

; 2600 : 		}
; 2601 : 	}
; 2602 : 	else

	jmp	SHORT $LN13@IgnoreUnit@2
$LN23@IgnoreUnit@2:

; 2603 : 	{
; 2604 : 		iCost = (PATH_MOVEMENT_WEIGHT * iCost);

	mov	ecx, DWORD PTR _iCost$[ebp]
	imul	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], ecx
$LN13@IgnoreUnit@2:

; 2605 : 	}
; 2606 : 
; 2607 : #ifdef AUI_ASTAR_EXPLORE_UNITAITYPE_ALWAYS_MAXIMIZES_EXPLORE
; 2608 : 	if (finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE || pUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)
; 2609 : #else
; 2610 : 	if(finder->GetInfo() & MOVE_MAXIMIZE_EXPLORE)

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR $T223144[ebp], eax
	mov	ecx, DWORD PTR $T223144[ebp]
	and	ecx, 128				; 00000080H
	je	SHORT $LN12@IgnoreUnit@2

; 2611 : #endif
; 2612 : 	{
; 2613 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 2614 : 		int iUnseenPlots = pToPlot->getNumNonrevealedInRange(eUnitTeam, pToPlot->seeFromLevel(eUnitTeam));
; 2615 : #else
; 2616 : 		int iUnseenPlots = pToPlot->getNumAdjacentNonrevealed(eUnitTeam);

	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonrevealed
	mov	DWORD PTR _iUnseenPlots$219552[ebp], eax

; 2617 : #endif
; 2618 : 		if(!pToPlot->isRevealed(eUnitTeam))

	mov	eax, DWORD PTR _eUnitTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$223153[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$223153[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$223153[ebp]
	mov	edx, DWORD PTR _pToPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@IgnoreUnit@2

; 2619 : 		{
; 2620 : 			iUnseenPlots += 1;

	mov	edx, DWORD PTR _iUnseenPlots$219552[ebp]
	add	edx, 1
	mov	DWORD PTR _iUnseenPlots$219552[ebp], edx
$LN11@IgnoreUnit@2:

; 2621 : 		}
; 2622 : 
; 2623 : 		iCost += (7 - iUnseenPlots) * PATH_EXPLORE_NON_REVEAL_WEIGHT;

	mov	eax, 7
	sub	eax, DWORD PTR _iUnseenPlots$219552[ebp]
	imul	eax, 10					; 0000000aH
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN12@IgnoreUnit@2:

; 2624 : 	}
; 2625 : 
; 2626 : 	// If we are a land unit and we are moving through the water, make the cost a little higher so that
; 2627 : 	// we favor staying on land or getting back to land as quickly as possible because it is dangerous to
; 2628 : 	// be on the water.  Don't add this penalty if the unit is human controlled however, we will assume they want
; 2629 : 	// the best path, rather than the safest.
; 2630 : #ifdef AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT
; 2631 : 	if (pCacheData->getDomainType() == DOMAIN_LAND && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()))
; 2632 : 	{
; 2633 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2634 : 		if (bIsAIControl)
; 2635 : #else
; 2636 : 		if (!pCacheData->isHuman() || pCacheData->IsAutomated())
; 2637 : #endif
; 2638 : 		{
; 2639 : 			iCost += PATH_THROUGH_WATER;
; 2640 : 		}
; 2641 : 		else
; 2642 : 		{
; 2643 : 			iCost += AUI_ASTAR_HUMAN_UNITS_GET_DIMINISHED_AVOID_WEIGHT + PATH_TERRITORY_WEIGHT;
; 2644 : 		}
; 2645 : 	}
; 2646 : #else
; 2647 : 	if(pCacheData->getDomainType() == DOMAIN_LAND && (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) && (!pCacheData->isHuman() || pUnit->IsAutomated()))

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR $T223158[ebp], edx
	cmp	DWORD PTR $T223158[ebp], 2
	jne	SHORT $LN128@IgnoreUnit@2
	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN128@IgnoreUnit@2
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN128@IgnoreUnit@2
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR $T223165[ebp], al
	movzx	ecx, BYTE PTR $T223165[ebp]
	test	ecx, ecx
	je	SHORT $LN9@IgnoreUnit@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN128@IgnoreUnit@2
$LN9@IgnoreUnit@2:

; 2648 : 	{
; 2649 : 		iCost += PATH_THROUGH_WATER;

	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], eax

; 2650 : 	}
; 2651 : #endif
; 2652 : 
; 2653 : 	if(pUnit->IsCombatUnit())

$LN128@IgnoreUnit@2:
	mov	ecx, DWORD PTR _pUnit$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN8@IgnoreUnit@2

; 2654 : 	{
; 2655 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 2656 : 		bool bToPlotHasEnemy = pToPlot->isVisibleEnemyDefender(pUnit) || pToPlot->isEnemyCity(*pUnit);
; 2657 : 		if (iMovesLeft == 0 && !bToPlotHasEnemy)
; 2658 : #else
; 2659 : 		if(iMovesLeft == 0)

	cmp	DWORD PTR _iMovesLeft$[ebp], 0
	jne	SHORT $LN7@IgnoreUnit@2

; 2660 : #endif
; 2661 : 		{
; 2662 : #ifdef AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS
; 2663 : 			int iDefenseBonus = pToPlot->defenseModifier(eUnitTeam, false);
; 2664 : 			if (iDefenseBonus > 0)
; 2665 : 			{
; 2666 : 				if (pUnit->noDefensiveBonus())
; 2667 : 					iDefenseBonus = 0;
; 2668 : 				else if (iDefenseBonus > 200)
; 2669 : 					iDefenseBonus = 200;
; 2670 : 			}
; 2671 : 			iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 2672 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 2673 : 			iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));
; 2674 : #else
; 2675 : 			iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pToPlot->defenseModifier(eUnitTeam, false)))));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@IgnoreUnit@2
	mov	DWORD PTR tv288[ebp], 0
	jmp	SHORT $LN34@IgnoreUnit@2
$LN33@IgnoreUnit@2:
	push	0
	push	0
	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	mov	DWORD PTR tv288[ebp], eax
$LN34@IgnoreUnit@2:
	mov	eax, 200				; 000000c8H
	sub	eax, DWORD PTR tv288[ebp]
	mov	DWORD PTR $T222973[ebp], eax
	mov	DWORD PTR $T222976[ebp], 0
	mov	ecx, DWORD PTR $T222976[ebp]
	cmp	ecx, DWORD PTR $T222973[ebp]
	jge	SHORT $LN134@IgnoreUnit@2
	lea	edx, DWORD PTR $T222973[ebp]
	mov	DWORD PTR tv450[ebp], edx
	jmp	SHORT $LN135@IgnoreUnit@2
$LN134@IgnoreUnit@2:
	lea	eax, DWORD PTR $T222976[ebp]
	mov	DWORD PTR tv450[ebp], eax
$LN135@IgnoreUnit@2:
	mov	ecx, DWORD PTR tv450[ebp]
	mov	DWORD PTR $T223180[ebp], ecx
	mov	edx, DWORD PTR $T223180[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 10					; 0000000aH
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax
$LN7@IgnoreUnit@2:

; 2676 : #endif
; 2677 : 		}
; 2678 : 
; 2679 : #if !defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) && !defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 2680 : 		if(pCacheData->IsAutomated())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+37]
	mov	BYTE PTR $T223186[ebp], dl
	movzx	eax, BYTE PTR $T223186[ebp]
	test	eax, eax
	je	$LN8@IgnoreUnit@2

; 2681 : #endif
; 2682 : 		{
; 2683 : 			if(pCacheData->IsCanAttack())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+42]
	mov	BYTE PTR $T223190[ebp], dl
	movzx	eax, BYTE PTR $T223190[ebp]
	test	eax, eax
	je	$LN8@IgnoreUnit@2

; 2684 : 			{
; 2685 : 				if(finder->IsPathDest(pToPlot->getX(), pToPlot->getY()))

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T223194[ebp], edx
	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T223198[ebp], ecx
	mov	edx, DWORD PTR _finder$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN144@IgnoreUnit@2
	mov	eax, DWORD PTR _finder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR $T223194[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223198[ebp]
	push	ecx
	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN144@IgnoreUnit@2
	mov	BYTE PTR $T223203[ebp], 1
	jmp	SHORT $LN145@IgnoreUnit@2
$LN144@IgnoreUnit@2:
	mov	BYTE PTR $T223203[ebp], 0
$LN145@IgnoreUnit@2:
	movzx	ecx, BYTE PTR $T223203[ebp]
	test	ecx, ecx
	je	$LN8@IgnoreUnit@2

; 2686 : 				{
; 2687 : #if defined(AUI_ASTAR_AVOID_RIVER_CROSSING_WHEN_ATTACKING) || defined(AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING)
; 2688 : 					if (bToPlotHasEnemy)
; 2689 : #else
; 2690 : 					if(pToPlot->isVisibleEnemyDefender(pUnit))

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
	movzx	eax, al
	test	eax, eax
	je	$LN8@IgnoreUnit@2

; 2691 : #endif
; 2692 : 					{
; 2693 : #ifdef AUI_ASTAR_CONSIDER_DAMAGE_WHEN_ATTACKING
; 2694 : 						int iDealtDamage = 0;
; 2695 : 						int iSelfDamage = 0;
; 2696 : 						CvCity* pCity = pToPlot->getPlotCity();
; 2697 : 						if (pCity)
; 2698 : 						{
; 2699 : 							int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, NULL);
; 2700 : 							int iDefenderStrength = pCity->getStrengthValue();
; 2701 : 
; 2702 : 							iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ true);
; 2703 : 							iSelfDamage = pUnit->getCombatDamage(iDefenderStrength, iAttackerStrength, pCity->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ true, /*bDefenderIsCity*/ false);
; 2704 : 
; 2705 : 							// Will both the attacker die, and the city fall? If so, the unit wins
; 2706 : 							if (iDealtDamage + pCity->getDamage() >= pCity->GetMaxHitPoints())
; 2707 : 							{
; 2708 : 								if (pUnit->isNoCapture())
; 2709 : 									iDealtDamage = pCity->GetMaxHitPoints() - pCity->getDamage() - 1;
; 2710 : 								if (iSelfDamage >= pUnit->GetCurrHitPoints())
; 2711 : 									iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 2712 : 							}
; 2713 : 						}
; 2714 : 						else
; 2715 : 						{
; 2716 : 							CvUnit* pDefender = pToPlot->getVisibleEnemyDefender(pUnit);
; 2717 : 							if (pDefender && pDefender->IsCanDefend())
; 2718 : 							{
; 2719 : 								// handle the Zulu special thrown spear first attack
; 2720 : 								if (pUnit->isRangedSupportFire() && pUnit->canEverRangeStrikeAt(pToPlot->getX(), pToPlot->getY()))
; 2721 : 									iDealtDamage = pUnit->GetRangeCombatDamage(pDefender, /*pCity*/ NULL, /*bIncludeRand*/ false);
; 2722 : 
; 2723 : 								if (iDealtDamage < pDefender->GetCurrHitPoints())
; 2724 : 								{
; 2725 : 									int iAttackerStrength = pUnit->GetMaxAttackStrength(pFromPlot, pToPlot, pDefender);
; 2726 : 									int iDefenderStrength = pDefender->GetMaxDefenseStrength(pToPlot, pUnit);
; 2727 : 
; 2728 : #ifdef NQ_HEAVY_CHARGE_DOWNHILL
; 2729 : 									bool isAttackingFromHigherElevation = 
; 2730 : 										((pUnit->plot()->isMountain() && !pDefender->plot()->isMountain()) || // attacking from mountain to non-mountain
; 2731 : 										(pUnit->plot()->isHills() && pDefender->plot()->isFlatlands())); // attacking from hills to flatlands
; 2732 : 									if ((pUnit->IsCanHeavyCharge() || (pUnit->GetHeavyChargeDownhill() > 0 && isAttackingFromHigherElevation))
; 2733 : 										&& !pDefender->CanFallBackFromMelee(*pUnit))
; 2734 : #else
; 2735 : 									if (pUnit->IsCanHeavyCharge() && !pDefender->CanFallBackFromMelee(*pUnit))
; 2736 : #endif
; 2737 : 										iAttackerStrength = (iAttackerStrength * 150) / 100;
; 2738 : 									iSelfDamage = pDefender->getCombatDamage(iDefenderStrength, iAttackerStrength, pDefender->getDamage() + iDealtDamage, /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 2739 : 									iDealtDamage = pUnit->getCombatDamage(iAttackerStrength, iDefenderStrength, pUnit->getDamage(), /*bIncludeRand*/ false, /*bAttackerIsCity*/ false, /*bDefenderIsCity*/ false);
; 2740 : 
; 2741 : 									// Will both units be killed by this? :o If so, take drastic corrective measures
; 2742 : 									if (iDealtDamage >= pDefender->GetCurrHitPoints() && iSelfDamage >= pUnit->GetCurrHitPoints())
; 2743 : 									{
; 2744 : 										// He who hath the least amount of damage survives with 1 HP left
; 2745 : 										if (iDealtDamage + pDefender->getDamage() > iSelfDamage + pUnit->getDamage())
; 2746 : 											iSelfDamage = pUnit->GetCurrHitPoints() - 1;
; 2747 : 										else
; 2748 : 											iDealtDamage = pDefender->GetCurrHitPoints() - 1;
; 2749 : 									}
; 2750 : 								}
; 2751 : 							}
; 2752 : 						}
; 2753 : 						if (iSelfDamage > pUnit->GetCurrHitPoints())
; 2754 : 							iSelfDamage = pUnit->GetMaxHitPoints();
; 2755 : 						if (iDealtDamage > GC.getMAX_HIT_POINTS())
; 2756 : 							iDealtDamage = GC.getMAX_HIT_POINTS();
; 2757 : 						iCost += iSelfDamage * PATH_DAMAGE_WEIGHT * pUnit->GetMaxHitPoints() / 100 + (GC.getMAX_HIT_POINTS() - iDealtDamage) * PATH_DAMAGE_WEIGHT / 10;
; 2758 : #else
; 2759 : #ifdef AUI_ASTAR_FIX_DEFENSE_PENALTIES_CONSIDERED_FOR_UNITS_WITHOUT_DEFENSE_BONUS
; 2760 : 						int iDefenseBonus = pFromPlot->defenseModifier(eUnitTeam, false);
; 2761 : 						if (iDefenseBonus > 0)
; 2762 : 						{
; 2763 : 							if (pUnit->noDefensiveBonus())
; 2764 : 								iDefenseBonus = 0;
; 2765 : 							else if (iDefenseBonus > 200)
; 2766 : 								iDefenseBonus = 200;
; 2767 : 						}
; 2768 : 						iCost += PATH_DEFENSE_WEIGHT * (200 - iDefenseBonus);
; 2769 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 2770 : 						iCost += (PATH_DEFENSE_WEIGHT * MAX(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));
; 2771 : #else
; 2772 : 						iCost += (PATH_DEFENSE_WEIGHT * std::max(0, (200 - ((pUnit->noDefensiveBonus()) ? 0 : pFromPlot->defenseModifier(eUnitTeam, false)))));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?noDefensiveBonus@CvUnit@@QBE_NXZ	; CvUnit::noDefensiveBonus
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@IgnoreUnit@2
	mov	DWORD PTR tv327[ebp], 0
	jmp	SHORT $LN36@IgnoreUnit@2
$LN35@IgnoreUnit@2:
	push	0
	push	0
	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	mov	DWORD PTR tv327[ebp], eax
$LN36@IgnoreUnit@2:
	mov	eax, 200				; 000000c8H
	sub	eax, DWORD PTR tv327[ebp]
	mov	DWORD PTR $T222977[ebp], eax
	mov	DWORD PTR $T222980[ebp], 0
	mov	ecx, DWORD PTR $T222980[ebp]
	cmp	ecx, DWORD PTR $T222977[ebp]
	jge	SHORT $LN149@IgnoreUnit@2
	lea	edx, DWORD PTR $T222977[ebp]
	mov	DWORD PTR tv309[ebp], edx
	jmp	SHORT $LN150@IgnoreUnit@2
$LN149@IgnoreUnit@2:
	lea	eax, DWORD PTR $T222980[ebp]
	mov	DWORD PTR tv309[ebp], eax
$LN150@IgnoreUnit@2:
	mov	ecx, DWORD PTR tv309[ebp]
	mov	DWORD PTR $T223210[ebp], ecx
	mov	edx, DWORD PTR $T223210[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 10					; 0000000aH
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 2773 : #endif
; 2774 : 
; 2775 : 						// I guess we may as well be the garrison
; 2776 : #if PATH_CITY_WEIGHT != 0
; 2777 : 						if(!(pFromPlot->isCity()))
; 2778 : 						{
; 2779 : 							iCost += PATH_CITY_WEIGHT;
; 2780 : 						}
; 2781 : #endif
; 2782 : 
; 2783 : 						if(!(pUnit->isRiverCrossingNoPenalty()))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isRiverCrossingNoPenalty@CvUnit@@QBE_NXZ ; CvUnit::isRiverCrossingNoPenalty
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@IgnoreUnit@2

; 2784 : 						{
; 2785 : 							if(pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot)))

	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@IgnoreUnit@2

; 2786 : 							{
; 2787 : 								iCost += (PATH_RIVER_WEIGHT * -(GC.getRIVER_ATTACK_MODIFIER()));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7388
	mov	DWORD PTR $T223288[ebp], edx
	mov	eax, DWORD PTR $T223288[ebp]
	neg	eax
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 2788 : 								iCost += (PATH_MOVEMENT_WEIGHT * iMovesLeft);

	mov	ecx, DWORD PTR _iMovesLeft$[ebp]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], ecx
$LN8@IgnoreUnit@2:

; 2789 : 							}
; 2790 : 						}
; 2791 : #endif
; 2792 : 					}
; 2793 : 				}
; 2794 : 			}
; 2795 : 		}
; 2796 : 	}
; 2797 : 
; 2798 : 	FAssert(iCost != MAX_INT);
; 2799 : 
; 2800 : 	iCost += PATH_STEP_WEIGHT;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, 2
	mov	DWORD PTR _iCost$[ebp], edx

; 2801 : 
; 2802 : 	FAssert(iCost > 0);
; 2803 : 
; 2804 : 	return iCost;

	mov	eax, DWORD PTR _iCost$[ebp]

; 2805 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; IgnoreUnitsCost
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
$T223306 = -16						; size = 4
$T223302 = -12						; size = 4
$T223298 = -8						; size = 4
$T223294 = -4						; size = 4
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T223294[ebp], ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T223298[ebp], eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T223302[ebp], edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T223306[ebp], ecx
	mov	edx, DWORD PTR $T223294[ebp]
	push	edx
	mov	eax, DWORD PTR $T223298[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223302[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223306[ebp]
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsValid
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
;	COMDAT ?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T223528 = -94						; size = 1
$T223524 = -93						; size = 1
_uiOffset$223519 = -92					; size = 4
$T223510 = -88						; size = 4
_playerID$223507 = -84					; size = 4
$T223493 = -80						; size = 4
$T223489 = -76						; size = 4
_playerID$223486 = -72					; size = 4
_uiOffset$223471 = -68					; size = 4
$T223462 = -64						; size = 4
_uiOffset$223457 = -60					; size = 4
$T223442 = -56						; size = 4
$T223428 = -52						; size = 4
$T223422 = -48						; size = 4
$T223413 = -44						; size = 4
$T223388 = -40						; size = 4
$T223372 = -36						; size = 4
_pUnit$ = -32						; size = 4
_bAIControl$ = -25					; size = 1
_pUnitPlot$ = -24					; size = 4
_pCacheData$ = -20					; size = 4
_eUnitTeam$ = -16					; size = 4
_theMap$ = -12						; size = 4
_pFromPlot$ = -8					; size = 4
_pToPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; IgnoreUnitsValid, COMDAT

; 2811 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 2812 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2813 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());
; 2814 : 	CvUnit* pUnit = ((CvUnit*)pointer);
; 2815 : 	TeamTypes eUnitTeam = pCacheData->getTeam();
; 2816 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2817 : 	CvPlot* pToPlot = node->m_pPlot;
; 2818 : 	if (!pToPlot)
; 2819 : 		return FALSE;
; 2820 : #else
; 2821 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);
; 2822 : #endif
; 2823 : 	bool bIsAIControl = !pCacheData->isHuman() || pCacheData->IsAutomated();
; 2824 : #else
; 2825 : 	CvUnit* pUnit;
; 2826 : 	CvPlot* pFromPlot;
; 2827 : 	CvPlot* pToPlot;
; 2828 : 	bool bAIControl;
; 2829 : #endif
; 2830 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2831 : 	PlayerTypes unit_owner = pUnit->getOwner();
; 2832 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2833 : 	CvAStarNode& kToNodeCacheData = *node;
; 2834 : #else
; 2835 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 2836 : #endif
; 2837 : #endif
; 2838 : 
; 2839 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN15@IgnoreUnit@3

; 2840 : 	{
; 2841 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2842 : 		// Cache values for this node that we will use when the node is checked again in the future
; 2843 : 		if (!kToNodeCacheData.bIsCalculated)
; 2844 : 		{
; 2845 : 			kToNodeCacheData.bIsCalculated = true;
; 2846 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2847 : 			kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 2848 : 			if (pUnit->IsHoveringUnit())
; 2849 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2850 : 			else
; 2851 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 2852 : #else
; 2853 : 			kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 2854 : #endif
; 2855 : 			kToNodeCacheData.bIsMountain = true;
; 2856 : 			kToNodeCacheData.bIsRevealedToTeam = true;
; 2857 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 2858 : 		}
; 2859 : #endif
; 2860 : 		return TRUE;

	mov	eax, 1
	jmp	$LN16@IgnoreUnit@3
$LN15@IgnoreUnit@3:

; 2861 : 	}
; 2862 : 
; 2863 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2864 : 	// Cache values for this node that we will use when the node is checked again in the future
; 2865 : 	if (!kToNodeCacheData.bIsCalculated)
; 2866 : 	{
; 2867 : 		kToNodeCacheData.bIsCalculated = true;
; 2868 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 2869 : 		kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 2870 : 		if (pUnit->IsHoveringUnit())
; 2871 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 2872 : 		else
; 2873 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 2874 : #else
; 2875 : 		kToNodeCacheData.bIsWater = (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater());
; 2876 : #endif
; 2877 : 		// Recycling bIsMountain for Borders check (only for IgnoreUnits Pathfinder!)
; 2878 : #ifdef AUI_ASTAR_FIX_IGNORE_UNITS_PATHFINDER_TERRITORY_CHECK
; 2879 : 		kToNodeCacheData.bIsMountain = pUnit->canEnterTerritory(pToPlot->getTeam(), false, false, pUnit->IsDeclareWar() || (finder->GetInfo() & MOVE_DECLARE_WAR));
; 2880 : #else
; 2881 : 		kToNodeCacheData.bIsMountain = pUnit->canEnterTerritory(eUnitTeam);
; 2882 : #endif
; 2883 : 		kToNodeCacheData.bIsRevealedToTeam = pToPlot->isRevealed(eUnitTeam);
; 2884 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2885 : 		if (bIsAIControl || kToNodeCacheData.bIsRevealedToTeam)
; 2886 : #else
; 2887 : 		if (bAIControl || kToNodeCacheData.bIsRevealedToTeam || !bIsHuman)
; 2888 : #endif
; 2889 : 			kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);
; 2890 : 		else
; 2891 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 2892 : 	}
; 2893 : 
; 2894 : #endif
; 2895 : 
; 2896 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2897 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2898 : 	CvPlot* pFromPlot = parent->m_pPlot;
; 2899 : 	if (!pFromPlot)
; 2900 : 		return FALSE;
; 2901 : #else
; 2902 : 	CvPlot* pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);
; 2903 : #endif
; 2904 : 	CvPlot* pUnitPlot = pUnit->plot();
; 2905 : #else
; 2906 : 	CvMap& theMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _theMap$[ebp], eax

; 2907 : 
; 2908 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 2909 : 	pFromPlot = parent->m_pPlot;
; 2910 : 	pToPlot = node->m_pPlot;
; 2911 : #else
; 2912 : 	pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	ecx, DWORD PTR _theMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223372[ebp], edx
	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T223372[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _theMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], eax

; 2913 : 	pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	edx, DWORD PTR _theMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223388[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T223388[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _theMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pToPlot$[ebp], ecx

; 2914 : #endif
; 2915 : 
; 2916 : 	pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 2917 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[ebp]
	add	ecx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], ecx

; 2918 : 
; 2919 : 	TeamTypes eUnitTeam = pCacheData->getTeam();

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 2920 : 
; 2921 : 	CvPlot* pUnitPlot = theMap.plotUnchecked(pUnit->getX(), pUnit->getY());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T223413[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T223422[ebp], ecx
	mov	edx, DWORD PTR _theMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223428[ebp], eax
	mov	ecx, DWORD PTR $T223413[ebp]
	imul	ecx, DWORD PTR $T223428[ebp]
	add	ecx, DWORD PTR $T223422[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _theMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pUnitPlot$[ebp], ecx

; 2922 : #endif
; 2923 : 
; 2924 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2925 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2926 : 	CvAStarNode& kFromNodeCacheData = *parent;
; 2927 : #else
; 2928 : 	CvPathNodeCacheData& kFromNodeCacheData = parent->m_kCostCacheData;
; 2929 : #endif
; 2930 : #endif
; 2931 : 
; 2932 : 	// slewis - moved this up so units can't move directly into the water. Not 100% sure this is the right solution.
; 2933 : 	if(pCacheData->getDomainType() == DOMAIN_LAND)

	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T223442[ebp], ecx
	cmp	DWORD PTR $T223442[ebp], 2
	jne	SHORT $LN14@IgnoreUnit@3

; 2934 : 	{
; 2935 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2936 : 		if (!kFromNodeCacheData.bIsWater && kToNodeCacheData.bIsWater && kToNodeCacheData.bIsRevealedToTeam && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))
; 2937 : #else
; 2938 : 		if(!pFromPlot->isWater() && pToPlot->isWater() && pToPlot->isRevealed(eUnitTeam) && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN14@IgnoreUnit@3
	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN14@IgnoreUnit@3
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$223457[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$223457[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$223457[ebp]
	mov	edx, DWORD PTR _pToPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@IgnoreUnit@3
	push	0
	push	1
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN14@IgnoreUnit@3

; 2939 : #endif
; 2940 : 		{
; 2941 : 			return FALSE;

	xor	eax, eax
	jmp	$LN16@IgnoreUnit@3
$LN14@IgnoreUnit@3:

; 2942 : 		}
; 2943 : 	}
; 2944 : 
; 2945 : 	if(pUnitPlot == pFromPlot)

	mov	edx, DWORD PTR _pUnitPlot$[ebp]
	cmp	edx, DWORD PTR _pFromPlot$[ebp]
	jne	SHORT $LN12@IgnoreUnit@3

; 2946 : 	{
; 2947 : 		return TRUE;

	mov	eax, 1
	jmp	$LN16@IgnoreUnit@3
$LN12@IgnoreUnit@3:

; 2948 : 	}
; 2949 : 
; 2950 : 	if(finder->GetInfo() & MOVE_TERRITORY_NO_UNEXPLORED)

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T223462[ebp], ecx
	mov	edx, DWORD PTR $T223462[ebp]
	and	edx, 1
	je	$LN11@IgnoreUnit@3

; 2951 : 	{
; 2952 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2953 : 		if (!kFromNodeCacheData.bIsRevealedToTeam)
; 2954 : #else
; 2955 : 		if(!(pFromPlot->isRevealed(eUnitTeam)))

	mov	eax, DWORD PTR _eUnitTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$223471[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$223471[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$223471[ebp]
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@IgnoreUnit@3

; 2956 : #endif
; 2957 : 		{
; 2958 : 			return FALSE;

	xor	eax, eax
	jmp	$LN16@IgnoreUnit@3
$LN10@IgnoreUnit@3:

; 2959 : 		}
; 2960 : 
; 2961 : 		if(pFromPlot->isOwned())

	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@IgnoreUnit@3

; 2962 : 		{
; 2963 : 			if(pFromPlot->getTeam() != eUnitTeam)

	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$223486[ebp], ecx
	cmp	DWORD PTR _playerID$223486[ebp], -1
	je	SHORT $LN67@IgnoreUnit@3
	mov	edx, DWORD PTR _playerID$223486[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223489[ebp], eax
	jmp	SHORT $LN68@IgnoreUnit@3
	jmp	SHORT $LN68@IgnoreUnit@3
$LN67@IgnoreUnit@3:
	mov	DWORD PTR $T223489[ebp], -1
$LN68@IgnoreUnit@3:
	mov	eax, DWORD PTR $T223489[ebp]
	cmp	eax, DWORD PTR _eUnitTeam$[ebp]
	je	SHORT $LN11@IgnoreUnit@3

; 2964 : 			{
; 2965 : 				return FALSE;

	xor	eax, eax
	jmp	$LN16@IgnoreUnit@3
$LN11@IgnoreUnit@3:

; 2966 : 			}
; 2967 : 		}
; 2968 : 	}
; 2969 : 
; 2970 : 	if(finder->GetInfo() & MOVE_TERRITORY_NO_ENEMY)

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T223493[ebp], edx
	mov	eax, DWORD PTR $T223493[ebp]
	and	eax, 2
	je	SHORT $LN7@IgnoreUnit@3

; 2971 : 	{
; 2972 : 		if(pFromPlot->isOwned())

	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@IgnoreUnit@3

; 2973 : 		{
; 2974 : 			if(atWar(pFromPlot->getTeam(), eUnitTeam))

	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$223507[ebp], eax
	cmp	DWORD PTR _playerID$223507[ebp], -1
	je	SHORT $LN77@IgnoreUnit@3
	mov	ecx, DWORD PTR _playerID$223507[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223510[ebp], eax
	jmp	SHORT $LN78@IgnoreUnit@3
	jmp	SHORT $LN78@IgnoreUnit@3
$LN77@IgnoreUnit@3:
	mov	DWORD PTR $T223510[ebp], -1
$LN78@IgnoreUnit@3:
	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223510[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@IgnoreUnit@3

; 2975 : 			{
; 2976 : 				return FALSE;

	xor	eax, eax
	jmp	$LN16@IgnoreUnit@3
$LN7@IgnoreUnit@3:

; 2977 : 			}
; 2978 : 		}
; 2979 : 	}
; 2980 : 
; 2981 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 2982 : 	bAIControl = pUnit->IsAutomated();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	mov	BYTE PTR _bAIControl$[ebp], al

; 2983 : #endif
; 2984 : 
; 2985 : 	// slewis - added AI check and embark check to prevent units from moving into unexplored areas
; 2986 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 2987 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 2988 : 	if (bIsAIControl || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())
; 2989 : #else
; 2990 : 	if (bAIControl || !bIsHuman || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())
; 2991 : #endif
; 2992 : 	{
; 2993 : 		if (!kToNodeCacheData.bCanEnterTerrain || !kToNodeCacheData.bIsMountain) // Recycling bIsMountain for Borders check (only for IgnoreUnits Pathfinder!)
; 2994 : #else
; 2995 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 2996 : 	if((pFromPlot->isRevealed(eUnitTeam) || pCacheData->isEmbarked()) || !pCacheData->isHuman())

	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$223519[ebp], edx
	mov	eax, DWORD PTR _uiOffset$223519[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$223519[ebp]
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@IgnoreUnit@3
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+41]
	mov	BYTE PTR $T223524[ebp], dl
	movzx	eax, BYTE PTR $T223524[ebp]
	test	eax, eax
	jne	SHORT $LN3@IgnoreUnit@3
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+36]
	mov	BYTE PTR $T223528[ebp], dl
	movzx	eax, BYTE PTR $T223528[ebp]
	test	eax, eax
	jne	SHORT $LN4@IgnoreUnit@3
$LN3@IgnoreUnit@3:

; 2997 : #else
; 2998 : 	if(bAIControl || (pFromPlot->isRevealed(eUnitTeam) || pCacheData->isEmbarked()) || !pCacheData->isHuman())
; 2999 : #endif
; 3000 : 	{
; 3001 : #ifdef AUI_ASTAR_FIX_IGNORE_UNITS_PATHFINDER_TERRITORY_CHECK
; 3002 : 		if (!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(pToPlot->getTeam(), false, false, pUnit->IsDeclareWar() || (GetInfo() & MOVE_DECLARE_WAR)))
; 3003 : #else
; 3004 : 		if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE) || !pUnit->canEnterTerritory(eUnitTeam))

	push	128					; 00000080H
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@IgnoreUnit@3
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _eUnitTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z ; CvUnit::canEnterTerritory
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@IgnoreUnit@3
$LN1@IgnoreUnit@3:

; 3005 : #endif
; 3006 : #endif
; 3007 : 		{
; 3008 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN16@IgnoreUnit@3
$LN4@IgnoreUnit@3:

; 3009 : 		}
; 3010 : 	}
; 3011 : 
; 3012 : 	return TRUE;

	mov	eax, 1
$LN16@IgnoreUnit@3:

; 3013 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; IgnoreUnitsValid
_TEXT	ENDS
PUBLIC	?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsPathAdd
; Function compile flags: /Odtp
;	COMDAT ?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv170 = -112						; size = 4
tv150 = -108						; size = 4
tv177 = -104						; size = 4
$T223636 = -100						; size = 4
$T223627 = -96						; size = 4
$T223621 = -92						; size = 4
$T223620 = -88						; size = 4
$T223616 = -84						; size = 4
$T223612 = -80						; size = 4
$T223608 = -73						; size = 1
$T223601 = -72						; size = 4
$T223597 = -68						; size = 4
$T223596 = -64						; size = 4
$T223579 = -60						; size = 4
$T223573 = -56						; size = 4
$T223559 = -52						; size = 4
$T223553 = -48						; size = 4
$T223546 = -44						; size = 4
$T223537 = -40						; size = 4
$T223534 = -36						; size = 4
$T223531 = -32						; size = 4
_pFromPlot$219616 = -28					; size = 4
_iStartMoves$219618 = -24				; size = 4
_pToPlot$219617 = -20					; size = 4
_pUnit$ = -16						; size = 4
_pCacheData$ = -12					; size = 4
_iTurns$ = -8						; size = 4
_iMoves$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; IgnoreUnitsPathAdd, COMDAT

; 3018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H

; 3019 : 	int iTurns;
; 3020 : 
; 3021 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 3022 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[ebp]
	add	ecx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], ecx

; 3023 : 	int iMoves = MAX_INT;

	mov	DWORD PTR _iMoves$[ebp], 2147483647	; 7fffffffH

; 3024 : 
; 3025 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN3@IgnoreUnit@4

; 3026 : 	{
; 3027 : 		iTurns = 1;

	mov	DWORD PTR _iTurns$[ebp], 1

; 3028 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3029 : 		iMoves = pUnit->movesLeft();
; 3030 : #else
; 3031 : 		iMoves = std::min(iMoves, pUnit->movesLeft());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?movesLeft@CvUnit@@QBEHXZ		; CvUnit::movesLeft
	mov	DWORD PTR $T223531[ebp], eax
	mov	edx, DWORD PTR $T223531[ebp]
	cmp	edx, DWORD PTR _iMoves$[ebp]
	jge	SHORT $LN14@IgnoreUnit@4
	lea	eax, DWORD PTR $T223531[ebp]
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN15@IgnoreUnit@4
$LN14@IgnoreUnit@4:
	lea	ecx, DWORD PTR _iMoves$[ebp]
	mov	DWORD PTR tv177[ebp], ecx
$LN15@IgnoreUnit@4:
	mov	edx, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T223546[ebp], edx
	mov	eax, DWORD PTR $T223546[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iMoves$[ebp], ecx

; 3032 : #endif
; 3033 : 	}
; 3034 : 	else

	jmp	$LN2@IgnoreUnit@4
$LN3@IgnoreUnit@4:

; 3035 : 	{
; 3036 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3037 : 		CvPlot* pFromPlot = parent->m_pPlot;
; 3038 : 		CvPlot* pToPlot = node->m_pPlot;
; 3039 : #else
; 3040 : 		CvPlot* pFromPlot = GC.getMap().plotUnchecked(parent->m_iX, parent->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223553[ebp], edx
	mov	eax, DWORD PTR $T223553[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223559[ebp], ecx
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T223559[ebp]
	add	edx, eax
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T223553[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pFromPlot$219616[ebp], edx

; 3041 : 		CvPlot* pToPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223573[ebp], ecx
	mov	edx, DWORD PTR $T223573[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223579[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T223579[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T223573[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pToPlot$219617[ebp], ecx

; 3042 : #endif
; 3043 : 
; 3044 : 		int iStartMoves = parent->m_iData1;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iStartMoves$219618[ebp], ecx

; 3045 : 		iTurns = parent->m_iData2;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iTurns$[ebp], eax

; 3046 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3047 : 		int iBaseMoves = pCacheData->baseMoves(((pFromPlot->isWater() && !pFromPlot->IsAllowsWalkWater()) || pCacheData->isEmbarked()) ? DOMAIN_SEA : pCacheData->getDomainType());
; 3048 : #endif
; 3049 : 
; 3050 : 		if(iStartMoves == 0)

	cmp	DWORD PTR _iStartMoves$219618[ebp], 0
	jne	SHORT $LN38@IgnoreUnit@4

; 3051 : 		{
; 3052 : 			iTurns++;

	mov	ecx, DWORD PTR _iTurns$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTurns$[ebp], ecx

; 3053 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3054 : 			iStartMoves = iBaseMoves * GC.getMOVE_DENOMINATOR();
; 3055 : #else
; 3056 : 			iStartMoves = pCacheData->baseMoves((pToPlot->isWater() && !pToPlot->IsAllowsWalkWater()) ? DOMAIN_SEA : DOMAIN_LAND) * GC.getMOVE_DENOMINATOR();

	mov	edx, DWORD PTR _pToPlot$219617[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN6@IgnoreUnit@4
	mov	ecx, DWORD PTR _pToPlot$219617[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@IgnoreUnit@4
	mov	DWORD PTR $T223596[ebp], 0
	jmp	SHORT $LN7@IgnoreUnit@4
$LN6@IgnoreUnit@4:
	mov	DWORD PTR $T223596[ebp], 2
$LN7@IgnoreUnit@4:
	mov	ecx, DWORD PTR $T223596[ebp]
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T223597[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T223601[ebp], ecx
	mov	edx, DWORD PTR $T223597[ebp]
	imul	edx, DWORD PTR $T223601[ebp]
	mov	DWORD PTR _iStartMoves$219618[ebp], edx

; 3057 : #endif
; 3058 : 		}
; 3059 : 
; 3060 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3061 : 		// We can just set maxMoves to the maximum integer value and use it for increased portability and no redundant checks, iMoves gets set to 0 anyway if it's negative
; 3062 : 		iMoves = iStartMoves - CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, iBaseMoves, MAX_INT, iStartMoves);
; 3063 : 		if (iMoves < 0)
; 3064 : 			iMoves = 0;
; 3065 : #else
; 3066 : 		// We can't use maxMoves, because that checks where the unit is currently, and we're plotting a path so we have to see
; 3067 : 		// what the max moves would be like if the unit was already at the desired location.
; 3068 : 		iMoves = std::min(iMoves, std::max(0, iStartMoves - CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, pToPlot, pCacheData->baseMoves((pToPlot->isWater() || pCacheData->isEmbarked())?DOMAIN_SEA:pCacheData->getDomainType()), pCacheData->maxMoves())));

$LN38@IgnoreUnit@4:
	mov	eax, DWORD PTR _pToPlot$219617[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN8@IgnoreUnit@4
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+41]
	mov	BYTE PTR $T223608[ebp], dl
	movzx	eax, BYTE PTR $T223608[ebp]
	test	eax, eax
	jne	SHORT $LN8@IgnoreUnit@4
	mov	ecx, DWORD PTR $T223612[ebp]
	mov	DWORD PTR $T223620[ebp], ecx
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR $T223620[ebp], eax
	jmp	SHORT $LN9@IgnoreUnit@4
$LN8@IgnoreUnit@4:
	mov	DWORD PTR $T223620[ebp], 0
$LN9@IgnoreUnit@4:
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T223616[ebp], edx
	mov	eax, DWORD PTR $T223620[ebp]
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T223621[ebp], edx
	push	0
	mov	eax, DWORD PTR $T223616[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223621[ebp]
	push	ecx
	mov	edx, DWORD PTR _pToPlot$219617[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$219616[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	call	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _iStartMoves$219618[ebp]
	sub	edx, eax
	mov	DWORD PTR $T223534[ebp], edx
	mov	DWORD PTR $T223537[ebp], 0
	mov	eax, DWORD PTR $T223537[ebp]
	cmp	eax, DWORD PTR $T223534[ebp]
	jge	SHORT $LN50@IgnoreUnit@4
	lea	ecx, DWORD PTR $T223534[ebp]
	mov	DWORD PTR tv150[ebp], ecx
	jmp	SHORT $LN51@IgnoreUnit@4
$LN50@IgnoreUnit@4:
	lea	edx, DWORD PTR $T223537[ebp]
	mov	DWORD PTR tv150[ebp], edx
$LN51@IgnoreUnit@4:
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR $T223627[ebp], eax
	mov	ecx, DWORD PTR $T223627[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _iMoves$[ebp]
	jge	SHORT $LN54@IgnoreUnit@4
	mov	eax, DWORD PTR $T223627[ebp]
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $LN55@IgnoreUnit@4
$LN54@IgnoreUnit@4:
	lea	ecx, DWORD PTR _iMoves$[ebp]
	mov	DWORD PTR tv170[ebp], ecx
$LN55@IgnoreUnit@4:
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR $T223636[ebp], edx
	mov	eax, DWORD PTR $T223636[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iMoves$[ebp], ecx
$LN2@IgnoreUnit@4:

; 3069 : #endif
; 3070 : 	}
; 3071 : 
; 3072 : 	FAssertMsg(iMoves >= 0, "iMoves is expected to be non-negative (invalid Index)");
; 3073 : 
; 3074 : 	node->m_iData1 = iMoves;

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR _iMoves$[ebp]
	mov	DWORD PTR [edx+12], eax

; 3075 : 	node->m_iData2 = iTurns;

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR _iTurns$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 3076 : 
; 3077 : 	return 1;

	mov	eax, 1

; 3078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; IgnoreUnitsPathAdd
_TEXT	ENDS
PUBLIC	?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z		; StepDestValid
; Function compile flags: /Odtp
;	COMDAT ?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T223692 = -36						; size = 4
$T223688 = -32						; size = 4
$T223674 = -28						; size = 4
$T223658 = -24						; size = 4
$T223652 = -20						; size = 4
$T223648 = -16						; size = 4
_kMap$ = -12						; size = 4
_pFromPlot$ = -8					; size = 4
_pToPlot$ = -4						; size = 4
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC		; StepDestValid, COMDAT

; 3088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3089 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3090 : 	CvPlot* pFromPlot;
; 3091 : 	CvPlot* pToPlot;
; 3092 : #endif
; 3093 : 
; 3094 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 3095 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3096 : 	CvPlot* pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());
; 3097 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToX, iToY);
; 3098 : #else
; 3099 : 	pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR $T223648[ebp], edx
	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR $T223652[ebp], ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223658[ebp], eax
	mov	ecx, DWORD PTR $T223648[ebp]
	imul	ecx, DWORD PTR $T223658[ebp]
	add	ecx, DWORD PTR $T223652[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], ecx

; 3100 : 	pToPlot = kMap.plotUnchecked(iToX, iToY);

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223674[ebp], ecx
	mov	edx, DWORD PTR _iToY$[ebp]
	imul	edx, DWORD PTR $T223674[ebp]
	add	edx, DWORD PTR _iToX$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pToPlot$[ebp], edx

; 3101 : #endif
; 3102 : 
; 3103 : 	if(pFromPlot->getArea() != pToPlot->getArea())

	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T223688[ebp], edx
	mov	eax, DWORD PTR _pToPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T223692[ebp], ecx
	mov	edx, DWORD PTR $T223688[ebp]
	cmp	edx, DWORD PTR $T223692[ebp]
	je	SHORT $LN1@StepDestVa

; 3104 : 	{
; 3105 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN2@StepDestVa
$LN1@StepDestVa:

; 3106 : 	}
; 3107 : 
; 3108 : 	return TRUE;

	mov	eax, 1
$LN2@StepDestVa:

; 3109 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP		; StepDestValid
_TEXT	ENDS
PUBLIC	?StepHeuristic@@YAHHHHH@Z			; StepHeuristic
; Function compile flags: /Odtp
;	COMDAT ?StepHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?StepHeuristic@@YAHHHHH@Z PROC				; StepHeuristic, COMDAT

; 3115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 3116 : 	return plotDistance(iFromX, iFromY, iToX, iToY);

	mov	eax, DWORD PTR _iToY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iToX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFromY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFromX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 3117 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepHeuristic@@YAHHHHH@Z ENDP				; StepHeuristic
_TEXT	ENDS
PUBLIC	?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepCost
; Function compile flags: /Odtp
;	COMDAT ?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; StepCost, COMDAT

; 3123 : {

	push	ebp
	mov	ebp, esp

; 3124 : 	return 1;

	mov	eax, 1

; 3125 : }

	pop	ebp
	ret	0
?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; StepCost
_TEXT	ENDS
PUBLIC	?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValid
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
EXTRN	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ:PROC	; CvTeam::getEmbarkedAllWaterPassage
; Function compile flags: /Odtp
;	COMDAT ?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T223852 = -72						; size = 4
$T223848 = -68						; size = 4
$T223833 = -64						; size = 4
$T223829 = -60						; size = 4
$T223825 = -56						; size = 4
$T223814 = -52						; size = 4
$T223798 = -48						; size = 4
_eMyTeam$219671 = -44					; size = 4
_ePlotOwnerTeam$219672 = -40				; size = 4
_plotOwnerPlayer$219668 = -36				; size = 4
_bPlotOwnerIsMinor$219669 = -29				; size = 1
_kMap$ = -28						; size = 4
_ePlayer$ = -24						; size = 4
_thisPlayer$ = -20					; size = 4
_iFlags$ = -16						; size = 4
_ePlotOwnerPlayer$ = -12				; size = 4
_eEnemy$ = -8						; size = 4
_pNewPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; StepValid, COMDAT

; 3131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 3132 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN9@StepValid

; 3133 : 	{
; 3134 : 		return TRUE;

	mov	eax, 1
	jmp	$LN10@StepValid
$LN9@StepValid:

; 3135 : 	}
; 3136 : 
; 3137 : 	int iFlags = finder->GetInfo();

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _iFlags$[ebp], ecx

; 3138 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _ePlayer$[ebp], edx

; 3139 : 
; 3140 : 	PlayerTypes eEnemy = *(PlayerTypes*)pointer;

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _eEnemy$[ebp], ecx

; 3141 : 
; 3142 : 	CvPlayer& thisPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[ebp], edx

; 3143 : 
; 3144 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3145 : 	CvPlot* pNewPlot = node->m_pPlot;
; 3146 : 	if (!pNewPlot)
; 3147 : 		return FALSE;
; 3148 : 	if (parent->m_pPlot && parent->m_pPlot->getArea() != pNewPlot->getArea())
; 3149 : #else
; 3150 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 3151 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223798[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T223798[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pNewPlot$[ebp], eax

; 3152 : 
; 3153 : 	if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->getArea() != pNewPlot->getArea())

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223814[ebp], eax
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T223814[ebp]
	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR $T223825[ebp], edx
	mov	ecx, DWORD PTR $T223825[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T223829[ebp], edx
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T223833[ebp], ecx
	mov	edx, DWORD PTR $T223829[ebp]
	cmp	edx, DWORD PTR $T223833[ebp]
	je	SHORT $LN34@StepValid

; 3154 : #endif
; 3155 : 	{
; 3156 : 		return FALSE;

	xor	eax, eax
	jmp	$LN10@StepValid

; 3157 : 	}
; 3158 : 
; 3159 : #ifdef AUI_ASTAR_FIX_STEP_VALID_CONSIDERS_MOUNTAINS
; 3160 : 	if (pNewPlot->isImpassable())
; 3161 : #else
; 3162 : 	if(pNewPlot->isImpassable() || pNewPlot->isMountain())

$LN34@StepValid:
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN6@StepValid
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN40@StepValid
$LN6@StepValid:

; 3163 : #endif
; 3164 : 	{
; 3165 : 		return FALSE;

	xor	eax, eax
	jmp	$LN10@StepValid

; 3166 : 	}
; 3167 : 
; 3168 : 	// Ocean hex and team can't navigate on oceans?
; 3169 : 	if (!GET_TEAM(thisPlayer.getTeam()).getEmbarkedAllWaterPassage())

$LN40@StepValid:
	mov	eax, DWORD PTR _thisPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223848[ebp], eax
	mov	edx, DWORD PTR $T223848[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223852[ebp], edx
	mov	ecx, DWORD PTR $T223852[ebp]
	call	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ ; CvTeam::getEmbarkedAllWaterPassage
	test	eax, eax
	jne	SHORT $LN46@StepValid

; 3170 : 	{
; 3171 : 		if (pNewPlot->getTerrainType() == TERRAIN_OCEAN)

	mov	eax, DWORD PTR _pNewPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	cmp	ecx, 6
	jne	SHORT $LN46@StepValid

; 3172 : 		{
; 3173 : 			return FALSE;

	xor	eax, eax
	jmp	$LN10@StepValid

; 3174 : 		}
; 3175 : 	}
; 3176 : 
; 3177 : 	PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

$LN46@StepValid:
	mov	edx, DWORD PTR _pNewPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _ePlotOwnerPlayer$[ebp], eax

; 3178 : 	if (ePlotOwnerPlayer != NO_PLAYER && ePlotOwnerPlayer != eEnemy && !pNewPlot->IsFriendlyTerritory(ePlayer))

	cmp	DWORD PTR _ePlotOwnerPlayer$[ebp], -1
	je	SHORT $LN3@StepValid
	mov	ecx, DWORD PTR _ePlotOwnerPlayer$[ebp]
	cmp	ecx, DWORD PTR _eEnemy$[ebp]
	je	SHORT $LN3@StepValid
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@StepValid

; 3179 : 	{
; 3180 : 		CvPlayer& plotOwnerPlayer = GET_PLAYER(ePlotOwnerPlayer);

	mov	ecx, DWORD PTR _ePlotOwnerPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _plotOwnerPlayer$219668[ebp], ecx

; 3181 : 		bool bPlotOwnerIsMinor = plotOwnerPlayer.isMinorCiv();

	mov	ecx, DWORD PTR _plotOwnerPlayer$219668[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bPlotOwnerIsMinor$219669[ebp], al

; 3182 : 
; 3183 : 		if(!bPlotOwnerIsMinor)

	movzx	edx, BYTE PTR _bPlotOwnerIsMinor$219669[ebp]
	test	edx, edx
	jne	SHORT $LN3@StepValid

; 3184 : 		{
; 3185 : 			TeamTypes eMyTeam = thisPlayer.getTeam();

	mov	eax, DWORD PTR _thisPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMyTeam$219671[ebp], eax

; 3186 : 			TeamTypes ePlotOwnerTeam = plotOwnerPlayer.getTeam();

	mov	edx, DWORD PTR _plotOwnerPlayer$219668[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlotOwnerTeam$219672[ebp], eax

; 3187 : 
; 3188 : 			if(!atWar(eMyTeam, ePlotOwnerTeam))

	mov	ecx, DWORD PTR _ePlotOwnerTeam$219672[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMyTeam$219671[ebp]
	push	edx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@StepValid

; 3189 : 			{
; 3190 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN10@StepValid
$LN3@StepValid:

; 3191 : 			}
; 3192 : 		}
; 3193 : 	}
; 3194 : 
; 3195 : 	return TRUE;

	mov	eax, 1
$LN10@StepValid:

; 3196 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; StepValid
_TEXT	ENDS
PUBLIC	?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValidAnyArea
; Function compile flags: /Odtp
;	COMDAT ?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T223920 = -56						; size = 4
$T223916 = -52						; size = 4
$T223894 = -48						; size = 4
_eMyTeam$219698 = -44					; size = 4
_ePlotOwnerTeam$219699 = -40				; size = 4
_plotOwnerPlayer$219695 = -36				; size = 4
_bPlotOwnerIsMinor$219696 = -29				; size = 1
_kMap$ = -28						; size = 4
_ePlayer$ = -24						; size = 4
_thisPlayer$ = -20					; size = 4
_iFlags$ = -16						; size = 4
_ePlotOwnerPlayer$ = -12				; size = 4
_eEnemy$ = -8						; size = 4
_pNewPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; StepValidAnyArea, COMDAT

; 3202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 3203 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN7@StepValidA

; 3204 : 	{
; 3205 : 		return TRUE;

	mov	eax, 1
	jmp	$LN8@StepValidA
$LN7@StepValidA:

; 3206 : 	}
; 3207 : 
; 3208 : 	int iFlags = finder->GetInfo();

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _iFlags$[ebp], ecx

; 3209 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _ePlayer$[ebp], edx

; 3210 : 
; 3211 : 	PlayerTypes eEnemy = *(PlayerTypes*)pointer;

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _eEnemy$[ebp], ecx

; 3212 : 
; 3213 : 	CvPlayer& thisPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[ebp], edx

; 3214 : 
; 3215 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3216 : 	CvPlot* pNewPlot = node->m_pPlot;
; 3217 : 	if (!pNewPlot)
; 3218 : 		return FALSE;
; 3219 : #else
; 3220 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 3221 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223894[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T223894[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pNewPlot$[ebp], eax

; 3222 : #endif
; 3223 : 
; 3224 : 	//if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->getArea() != pNewPlot->getArea())
; 3225 : 	//{
; 3226 : 	//	return FALSE;
; 3227 : 	//}
; 3228 : 
; 3229 : 	if(pNewPlot->isImpassable())

	mov	edx, DWORD PTR _pNewPlot$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@StepValidA

; 3230 : 	{
; 3231 : 		return FALSE;

	xor	eax, eax
	jmp	$LN8@StepValidA

; 3232 : 	}
; 3233 : 
; 3234 : 	// Ocean hex and team can't navigate on oceans?
; 3235 : 	if (!GET_TEAM(thisPlayer.getTeam()).getEmbarkedAllWaterPassage())

$LN26@StepValidA:
	mov	edx, DWORD PTR _thisPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223916[ebp], eax
	mov	ecx, DWORD PTR $T223916[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223920[ebp], ecx
	mov	ecx, DWORD PTR $T223920[ebp]
	call	?getEmbarkedAllWaterPassage@CvTeam@@QBEHXZ ; CvTeam::getEmbarkedAllWaterPassage
	test	eax, eax
	jne	SHORT $LN32@StepValidA

; 3236 : 	{
; 3237 : 		if (pNewPlot->getTerrainType() == TERRAIN_OCEAN)

	mov	edx, DWORD PTR _pNewPlot$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	cmp	eax, 6
	jne	SHORT $LN32@StepValidA

; 3238 : 		{
; 3239 : 			return FALSE;

	xor	eax, eax
	jmp	$LN8@StepValidA

; 3240 : 		}
; 3241 : 	}
; 3242 : 
; 3243 : 	PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

$LN32@StepValidA:
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _ePlotOwnerPlayer$[ebp], edx

; 3244 : 	if (ePlotOwnerPlayer != NO_PLAYER && ePlotOwnerPlayer != eEnemy && !pNewPlot->IsFriendlyTerritory(ePlayer))

	cmp	DWORD PTR _ePlotOwnerPlayer$[ebp], -1
	je	SHORT $LN3@StepValidA
	mov	eax, DWORD PTR _ePlotOwnerPlayer$[ebp]
	cmp	eax, DWORD PTR _eEnemy$[ebp]
	je	SHORT $LN3@StepValidA
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@StepValidA

; 3245 : 	{
; 3246 : 		CvPlayer& plotOwnerPlayer = GET_PLAYER(ePlotOwnerPlayer);

	mov	eax, DWORD PTR _ePlotOwnerPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _plotOwnerPlayer$219695[ebp], eax

; 3247 : 		bool bPlotOwnerIsMinor = plotOwnerPlayer.isMinorCiv();

	mov	ecx, DWORD PTR _plotOwnerPlayer$219695[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bPlotOwnerIsMinor$219696[ebp], al

; 3248 : 
; 3249 : 		if(!bPlotOwnerIsMinor)

	movzx	ecx, BYTE PTR _bPlotOwnerIsMinor$219696[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@StepValidA

; 3250 : 		{
; 3251 : 			TeamTypes eMyTeam = thisPlayer.getTeam();

	mov	edx, DWORD PTR _thisPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMyTeam$219698[ebp], eax

; 3252 : 			TeamTypes ePlotOwnerTeam = plotOwnerPlayer.getTeam();

	mov	ecx, DWORD PTR _plotOwnerPlayer$219695[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlotOwnerTeam$219699[ebp], eax

; 3253 : 
; 3254 : 			if(!atWar(eMyTeam, ePlotOwnerTeam))

	mov	eax, DWORD PTR _ePlotOwnerTeam$219699[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMyTeam$219698[ebp]
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@StepValidA

; 3255 : 			{
; 3256 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN8@StepValidA
$LN3@StepValidA:

; 3257 : 			}
; 3258 : 		}
; 3259 : 	}
; 3260 : 
; 3261 : 	return TRUE;

	mov	eax, 1
$LN8@StepValidA:

; 3262 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; StepValidAnyArea
_TEXT	ENDS
PUBLIC	?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepAdd
; Function compile flags: /Odtp
;	COMDAT ?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; StepAdd, COMDAT

; 3268 : {

	push	ebp
	mov	ebp, esp

; 3269 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@StepAdd

; 3270 : 	{
; 3271 : 		node->m_iData1 = 0;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+12], 0

; 3272 : 	}
; 3273 : 	else

	jmp	SHORT $LN1@StepAdd
$LN2@StepAdd:

; 3274 : 	{
; 3275 : 		node->m_iData1 = (parent->m_iData1 + 1);

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN1@StepAdd:

; 3276 : 	}
; 3277 : 
; 3278 : 	FAssertMsg(node->m_iData1 >= 0, "node->m_iData1 is expected to be non-negative (invalid Index)");
; 3279 : 
; 3280 : 	return 1;

	mov	eax, 1

; 3281 : }

	pop	ebp
	ret	0
?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; StepAdd
_TEXT	ENDS
PUBLIC	?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z	; InfluenceDestValid
; Function compile flags: /Odtp
;	COMDAT ?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224008 = -48						; size = 4
$T224004 = -44						; size = 4
$T224000 = -40						; size = 4
$T223996 = -36						; size = 4
$T223982 = -32						; size = 4
$T223966 = -28						; size = 4
$T223960 = -24						; size = 4
$T223956 = -20						; size = 4
_iRange$219720 = -16					; size = 4
_kMap$ = -12						; size = 4
_pFromPlot$ = -8					; size = 4
_pToPlot$ = -4						; size = 4
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z PROC	; InfluenceDestValid, COMDAT

; 3291 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H

; 3292 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3293 : 	CvPlot* pFromPlot;
; 3294 : 	CvPlot* pToPlot;
; 3295 : #endif
; 3296 : 
; 3297 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 3298 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3299 : 	CvPlot* pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());
; 3300 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToX, iToY);
; 3301 : #else
; 3302 : 	pFromPlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR $T223956[ebp], edx
	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR $T223960[ebp], ecx
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223966[ebp], eax
	mov	ecx, DWORD PTR $T223956[ebp]
	imul	ecx, DWORD PTR $T223966[ebp]
	add	ecx, DWORD PTR $T223960[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], ecx

; 3303 : 	pToPlot = kMap.plotUnchecked(iToX, iToY);

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223982[ebp], ecx
	mov	edx, DWORD PTR _iToY$[ebp]
	imul	edx, DWORD PTR $T223982[ebp]
	add	edx, DWORD PTR _iToX$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pToPlot$[ebp], edx

; 3304 : #endif
; 3305 : 
; 3306 : 	if(pointer)

	cmp	DWORD PTR _pointer$[ebp], 0
	je	SHORT $LN2@InfluenceD

; 3307 : 	{
; 3308 : 		int iRange = abs(*(int*)pointer);

	mov	ecx, DWORD PTR _pointer$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iRange$219720[ebp], eax

; 3309 : 		if(plotDistance(pFromPlot->getX(),pFromPlot->getY(),pToPlot->getX(),pToPlot->getY()) > iRange)

	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T223996[ebp], eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T224000[ebp], edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224004[ebp], ecx
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224008[ebp], eax
	mov	ecx, DWORD PTR $T223996[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224000[ebp]
	push	edx
	mov	eax, DWORD PTR $T224004[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224008[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$219720[ebp]
	jle	SHORT $LN2@InfluenceD

; 3310 : 		{
; 3311 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@InfluenceD
$LN2@InfluenceD:

; 3312 : 		}
; 3313 : 	}
; 3314 : 
; 3315 : 	return TRUE;

	mov	eax, 1
$LN3@InfluenceD:

; 3316 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z ENDP	; InfluenceDestValid
_TEXT	ENDS
PUBLIC	?InfluenceHeuristic@@YAHHHHH@Z			; InfluenceHeuristic
; Function compile flags: /Odtp
;	COMDAT ?InfluenceHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?InfluenceHeuristic@@YAHHHHH@Z PROC			; InfluenceHeuristic, COMDAT

; 3322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 3323 : 	return plotDistance(iFromX, iFromY, iToX, iToY);

	mov	eax, DWORD PTR _iToY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iToX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFromY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFromX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 3324 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InfluenceHeuristic@@YAHHHHH@Z ENDP			; InfluenceHeuristic
_TEXT	ENDS
PUBLIC	?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceCost
EXTRN	?getInfluenceCost@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getInfluenceCost
EXTRN	?getInfluenceCost@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getInfluenceCost
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
; Function compile flags: /Odtp
;	COMDAT ?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv187 = -120						; size = 4
tv225 = -116						; size = 4
tv183 = -112						; size = 4
$T224334 = -108						; size = 4
$T224325 = -104						; size = 4
_f$224319 = -98						; size = 1
_f$224310 = -97						; size = 1
$T224301 = -96						; size = 4
$T224297 = -92						; size = 4
$T224290 = -88						; size = 4
$T224283 = -84						; size = 4
$T224259 = -64						; size = 4
$T224239 = -60						; size = 4
$T224233 = -56						; size = 4
$T224229 = -52						; size = 4
$T224215 = -48						; size = 4
$T224199 = -44						; size = 4
$T224190 = -40						; size = 4
$T224186 = -36						; size = 4
$T224185 = -32						; size = 4
_kMap$219740 = -28					; size = 4
_iRange$219744 = -24					; size = 4
_pFromPlot$219741 = -20					; size = 4
_pSourcePlot$219743 = -16				; size = 4
_pToPlot$219742 = -12					; size = 4
_iCost$ = -8						; size = 4
_bDifferentOwner$ = -1					; size = 1
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; InfluenceCost, COMDAT

; 3329 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 3330 : 	int iCost = 0;

	mov	DWORD PTR _iCost$[ebp], 0

; 3331 : 	bool bDifferentOwner = false;

	mov	BYTE PTR _bDifferentOwner$[ebp], 0

; 3332 : 	if(parent->m_pParent || GC.getUSE_FIRST_RING_INFLUENCE_TERRAIN_COST())

	mov	eax, DWORD PTR _parent$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN10@InfluenceC
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7012
	mov	DWORD PTR $T224190[ebp], ecx
	cmp	DWORD PTR $T224190[ebp], 0
	je	$LN11@InfluenceC
$LN10@InfluenceC:

; 3333 : 	{
; 3334 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3335 : 		const CvPlot* pFromPlot = parent->m_pPlot;
; 3336 : 		const CvPlot* pToPlot = node->m_pPlot;
; 3337 : 		const CvPlot* pSourcePlot = GC.getMap().plotUnchecked(finder->GetStartX(), finder->GetStartY());
; 3338 : #else
; 3339 : 		CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$219740[ebp], edx

; 3340 : 		CvPlot* pFromPlot = kMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	eax, DWORD PTR _kMap$219740[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224199[ebp], ecx
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T224199[ebp]
	add	edx, eax
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$219740[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pFromPlot$219741[ebp], edx

; 3341 : 		CvPlot* pToPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _kMap$219740[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T224215[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T224215[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$219740[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$219742[ebp], eax

; 3342 : 		CvPlot* pSourcePlot = kMap.plotUnchecked(finder->GetStartX(), finder->GetStartY());

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR $T224229[ebp], eax
	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR $T224233[ebp], edx
	mov	eax, DWORD PTR _kMap$219740[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224239[ebp], ecx
	mov	edx, DWORD PTR $T224229[ebp]
	imul	edx, DWORD PTR $T224239[ebp]
	add	edx, DWORD PTR $T224233[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$219740[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pSourcePlot$219743[ebp], edx

; 3343 : #endif
; 3344 : 
; 3345 : 		int iRange = 0;

	mov	DWORD PTR _iRange$219744[ebp], 0

; 3346 : 		if(pointer)

	cmp	DWORD PTR _pointer$[ebp], 0
	je	SHORT $LN9@InfluenceC

; 3347 : 		{
; 3348 : 			iRange = *(int*)pointer;

	mov	ecx, DWORD PTR _pointer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iRange$219744[ebp], edx
$LN9@InfluenceC:

; 3349 : 		}
; 3350 : 		if(iRange >= 0)

	cmp	DWORD PTR _iRange$219744[ebp], 0
	jl	SHORT $LN8@InfluenceC

; 3351 : 		{
; 3352 : 			if(pToPlot->getOwner() != NO_PLAYER && pSourcePlot->getOwner() != NO_PLAYER && pToPlot->getOwner() != pSourcePlot->getOwner())

	mov	eax, DWORD PTR _pToPlot$219742[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -1
	je	SHORT $LN8@InfluenceC
	mov	edx, DWORD PTR _pSourcePlot$219743[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, -1
	je	SHORT $LN8@InfluenceC
	mov	ecx, DWORD PTR _pToPlot$219742[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T224259[ebp], edx
	mov	eax, DWORD PTR _pSourcePlot$219743[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T224259[ebp], ecx
	je	SHORT $LN8@InfluenceC

; 3353 : 				bDifferentOwner = true;

	mov	BYTE PTR _bDifferentOwner$[ebp], 1
$LN8@InfluenceC:

; 3354 : 		}
; 3355 : 
; 3356 : 		if(pFromPlot->isRiverCrossing(directionXY(pFromPlot, pToPlot)))

	mov	edx, DWORD PTR _pToPlot$219742[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$219741[ebp]
	push	eax
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pFromPlot$219741[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN62@InfluenceC

; 3357 : 			iCost += GC.getINFLUENCE_RIVER_COST();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7008
	mov	DWORD PTR $T224283[ebp], edx
	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, DWORD PTR $T224283[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 3358 : 
; 3359 : 		// Mountain Cost
; 3360 : 		if(pToPlot->isMountain())

$LN62@InfluenceC:
	mov	ecx, DWORD PTR _pToPlot$219742[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN66@InfluenceC

; 3361 : 			iCost += GC.getINFLUENCE_MOUNTAIN_COST();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7000
	mov	DWORD PTR $T224290[ebp], ecx
	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, DWORD PTR $T224290[ebp]
	mov	DWORD PTR _iCost$[ebp], edx

; 3362 : 		// Not a mountain - use the terrain cost
; 3363 : 		else

	jmp	$LN4@InfluenceC

; 3364 : 		{
; 3365 : 			// Hill cost
; 3366 : 			if(pToPlot->isHills())

$LN66@InfluenceC:
	mov	eax, DWORD PTR _pToPlot$219742[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@InfluenceC

; 3367 : 				iCost += GC.getINFLUENCE_HILL_COST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7004
	mov	DWORD PTR $T224297[ebp], eax
	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, DWORD PTR $T224297[ebp]
	mov	DWORD PTR _iCost$[ebp], ecx
$LN3@InfluenceC:

; 3368 : 			iCost += GC.getTerrainInfo(pToPlot->getTerrainType())->getInfluenceCost();

	mov	edx, DWORD PTR _pToPlot$219742[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T224301[ebp], eax
	mov	ecx, DWORD PTR $T224301[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getInfluenceCost@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getInfluenceCost
	add	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 3369 : 			iCost += ((pToPlot->getFeatureType() == NO_FEATURE) ? 0 : GC.getFeatureInfo(pToPlot->getFeatureType())->getInfluenceCost());

	mov	edx, DWORD PTR _pToPlot$219742[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$224310[ebp], al
	movsx	ecx, BYTE PTR _f$224310[ebp]
	cmp	ecx, -1
	jne	SHORT $LN78@InfluenceC
	mov	DWORD PTR tv183[ebp], 0
	jmp	SHORT $LN15@InfluenceC
$LN78@InfluenceC:
	mov	edx, DWORD PTR _pToPlot$219742[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$224319[ebp], al
	movsx	ecx, BYTE PTR _f$224319[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getInfluenceCost@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getInfluenceCost
	mov	DWORD PTR tv183[ebp], eax
$LN15@InfluenceC:
	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, DWORD PTR tv183[ebp]
	mov	DWORD PTR _iCost$[ebp], edx
$LN4@InfluenceC:

; 3370 : 		}
; 3371 : 	}
; 3372 : 	else

	jmp	SHORT $LN2@InfluenceC
$LN11@InfluenceC:

; 3373 : 	{
; 3374 : 		iCost = 1;

	mov	DWORD PTR _iCost$[ebp], 1
$LN2@InfluenceC:

; 3375 : 	}
; 3376 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3377 : 	iCost = MAX(1, iCost);
; 3378 : 	iCost = MIN(3, iCost);
; 3379 : #else
; 3380 : 	iCost = std::max(1,iCost);

	mov	DWORD PTR $T224185[ebp], 1
	mov	eax, DWORD PTR $T224185[ebp]
	cmp	eax, DWORD PTR _iCost$[ebp]
	jge	SHORT $LN82@InfluenceC
	lea	ecx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR tv225[ebp], ecx
	jmp	SHORT $LN83@InfluenceC
$LN82@InfluenceC:
	lea	edx, DWORD PTR $T224185[ebp]
	mov	DWORD PTR tv225[ebp], edx
$LN83@InfluenceC:
	mov	eax, DWORD PTR tv225[ebp]
	mov	DWORD PTR $T224325[ebp], eax
	mov	ecx, DWORD PTR $T224325[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iCost$[ebp], edx

; 3381 : 	iCost = std::min(3,iCost);

	mov	DWORD PTR $T224186[ebp], 3
	mov	eax, DWORD PTR _iCost$[ebp]
	cmp	eax, DWORD PTR $T224186[ebp]
	jge	SHORT $LN86@InfluenceC
	lea	ecx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR tv187[ebp], ecx
	jmp	SHORT $LN87@InfluenceC
$LN86@InfluenceC:
	lea	edx, DWORD PTR $T224186[ebp]
	mov	DWORD PTR tv187[ebp], edx
$LN87@InfluenceC:
	mov	eax, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T224334[ebp], eax
	mov	ecx, DWORD PTR $T224334[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iCost$[ebp], edx

; 3382 : #endif
; 3383 : 	if (bDifferentOwner)

	movzx	eax, BYTE PTR _bDifferentOwner$[ebp]
	test	eax, eax
	je	SHORT $LN1@InfluenceC

; 3384 : 	{
; 3385 : 		iCost += 15;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 15					; 0000000fH
	mov	DWORD PTR _iCost$[ebp], ecx
$LN1@InfluenceC:

; 3386 : 	}
; 3387 : 	return iCost;

	mov	eax, DWORD PTR _iCost$[ebp]

; 3388 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; InfluenceCost
_TEXT	ENDS
PUBLIC	?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceValid
; Function compile flags: /Odtp
;	COMDAT ?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224363 = -20						; size = 4
$T224362 = -16						; size = 4
$T224349 = -12						; size = 4
$T224343 = -8						; size = 4
_pNewPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; InfluenceValid, COMDAT

; 3394 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3395 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3396 : 	CvPlot* pNewPlot;
; 3397 : #endif
; 3398 : 
; 3399 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN2@InfluenceV

; 3400 : 	{
; 3401 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN3@InfluenceV
$LN2@InfluenceV:

; 3402 : 	}
; 3403 : 
; 3404 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3405 : 	if (!node->m_pPlot)
; 3406 : 	{
; 3407 : 		return FALSE;
; 3408 : 	}
; 3409 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3410 : 	if (!GC.getMap().isPlot(node->m_iX, node->m_iY))
; 3411 : 	{
; 3412 : 		return FALSE;
; 3413 : 	}
; 3414 : #else
; 3415 : 	pNewPlot = GC.getMap().plotCheckInvalid(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224343[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T224363[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T224362[ebp], ecx
	cmp	DWORD PTR $T224362[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@InfluenceV
	cmp	DWORD PTR $T224363[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@InfluenceV
$LN7@InfluenceV:
	mov	DWORD PTR _pNewPlot$[ebp], 0
	jmp	SHORT $LN9@InfluenceV
$LN8@InfluenceV:
	mov	edx, DWORD PTR $T224343[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T224349[ebp], eax
	mov	ecx, DWORD PTR $T224363[ebp]
	imul	ecx, DWORD PTR $T224349[ebp]
	add	ecx, DWORD PTR $T224362[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T224343[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pNewPlot$[ebp], ecx
$LN9@InfluenceV:

; 3416 : 
; 3417 : 	if(pNewPlot == NULL)

	cmp	DWORD PTR _pNewPlot$[ebp], 0
	jne	SHORT $LN1@InfluenceV

; 3418 : 	{
; 3419 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@InfluenceV
$LN1@InfluenceV:

; 3420 : 	}
; 3421 : #endif
; 3422 : 
; 3423 : 	// todo: a check to see if we are within the theoretical influence range would be great
; 3424 : 
; 3425 : 	return TRUE;

	mov	eax, 1
$LN3@InfluenceV:

; 3426 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; InfluenceValid
_TEXT	ENDS
PUBLIC	?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceAdd
; Function compile flags: /Odtp
;	COMDAT ?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; InfluenceAdd, COMDAT

; 3432 : {

	push	ebp
	mov	ebp, esp

; 3433 : 	if(data == ASNC_INITIALADD)

	cmp	DWORD PTR _data$[ebp], 0
	jne	SHORT $LN2@InfluenceA

; 3434 : 	{
; 3435 : 		node->m_iData1 = 0;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+12], 0

; 3436 : 	}
; 3437 : 	else

	jmp	SHORT $LN1@InfluenceA
$LN2@InfluenceA:

; 3438 : 	{
; 3439 : 		node->m_iData1 = (parent->m_iData1 + 1/*influenceCost(parent,node,data,pointer,finder)*/);

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN1@InfluenceA:

; 3440 : 	}
; 3441 : 
; 3442 : 	FAssertMsg(node->m_iData1 >= 0, "node->m_iData1 is expected to be non-negative (invalid Index)");
; 3443 : 
; 3444 : 	return 1;

	mov	eax, 1

; 3445 : }

	pop	ebp
	ret	0
?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; InfluenceAdd
_TEXT	ENDS
PUBLIC	?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z ; RouteGetExtraChild
EXTRN	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z:PROC ; CvCityConnections::GetCityFromIndex
EXTRN	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z:PROC ; CvCityConnections::GetRouteInfo
EXTRN	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z:PROC ; CvCityConnections::GetIndexFromCity
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Odtp
;	COMDAT ?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z
_TEXT	SEGMENT
$T224433 = -84						; size = 4
$T224424 = -80						; size = 4
$T224415 = -76						; size = 4
$T224406 = -68						; size = 4
$T224405 = -64						; size = 4
$T224392 = -60						; size = 4
$T224386 = -56						; size = 4
$T224371 = -52						; size = 4
_pRouteInfo$219800 = -48				; size = 4
_pFirstCity$219802 = -44				; size = 4
_pSecondCity$219803 = -40				; size = 4
_uiSecondCityIndex$219795 = -36				; size = 4
_ePlayer$ = -32						; size = 4
_uiFirstCityIndex$ = -28				; size = 4
_pPlot$ = -24						; size = 4
_iValidCount$ = -20					; size = 4
_pCity$ = -16						; size = 4
_eTeam$ = -12						; size = 4
_pCityConnections$ = -8					; size = 4
_kPlayer$ = -4						; size = 4
_node$ = 8						; size = 4
_iIndex$ = 12						; size = 4
_iX$ = 16						; size = 4
_iY$ = 20						; size = 4
_finder$ = 24						; size = 4
?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z PROC ; RouteGetExtraChild, COMDAT

; 3451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 3452 : 	iX = -1;

	mov	eax, DWORD PTR _iX$[ebp]
	mov	DWORD PTR [eax], -1

; 3453 : 	iY = -1;

	mov	ecx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR [ecx], -1

; 3454 : 
; 3455 : 	PlayerTypes ePlayer = ((PlayerTypes)(finder->GetInfo() & 0xFF));

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR $T224371[ebp], eax
	mov	ecx, DWORD PTR $T224371[ebp]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 3456 : 	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 3457 : 	TeamTypes eTeam = kPlayer.getTeam();

	mov	eax, DWORD PTR _kPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 3458 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3459 : 	const CvPlot* pPlot = node->m_pPlot;
; 3460 : #else
; 3461 : 	CvPlot* pPlot = GC.getMap().plotCheckInvalid(node->m_iX, node->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224386[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR $T224406[ebp], ecx
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR $T224405[ebp], eax
	cmp	DWORD PTR $T224405[ebp], -2147483647	; 80000001H
	je	SHORT $LN25@RouteGetEx
	cmp	DWORD PTR $T224406[ebp], -2147483647	; 80000001H
	jne	SHORT $LN26@RouteGetEx
$LN25@RouteGetEx:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	SHORT $LN27@RouteGetEx
$LN26@RouteGetEx:
	mov	ecx, DWORD PTR $T224386[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T224392[ebp], edx
	mov	eax, DWORD PTR $T224406[ebp]
	imul	eax, DWORD PTR $T224392[ebp]
	add	eax, DWORD PTR $T224405[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T224386[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pPlot$[ebp], eax
$LN27@RouteGetEx:

; 3462 : #endif
; 3463 : 
; 3464 : 	if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN12@RouteGetEx

; 3465 : 	{
; 3466 : 		return 0;

	xor	eax, eax
	jmp	$LN13@RouteGetEx
$LN12@RouteGetEx:

; 3467 : 	}
; 3468 : 
; 3469 : 	CvCity* pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 3470 : 
; 3471 : 	// if there isn't a city there or the city isn't on our team
; 3472 : 	if(!pCity || pCity->getTeam() != eTeam)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN10@RouteGetEx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN11@RouteGetEx
$LN10@RouteGetEx:

; 3473 : 	{
; 3474 : 		return 0;

	xor	eax, eax
	jmp	$LN13@RouteGetEx
$LN11@RouteGetEx:

; 3475 : 	}
; 3476 : 
; 3477 : 	int iValidCount = 0;

	mov	DWORD PTR _iValidCount$[ebp], 0

; 3478 : 	CvCityConnections* pCityConnections = kPlayer.GetCityConnections();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	DWORD PTR _pCityConnections$[ebp], eax

; 3479 : 
; 3480 : 	uint uiFirstCityIndex = pCityConnections->GetIndexFromCity(pCity);

	mov	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ; CvCityConnections::GetIndexFromCity
	mov	DWORD PTR _uiFirstCityIndex$[ebp], eax

; 3481 : 	for(uint uiSecondCityIndex = 0; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	mov	DWORD PTR _uiSecondCityIndex$219795[ebp], 0
	jmp	SHORT $LN9@RouteGetEx
$LN8@RouteGetEx:
	mov	eax, DWORD PTR _uiSecondCityIndex$219795[ebp]
	add	eax, 1
	mov	DWORD PTR _uiSecondCityIndex$219795[ebp], eax
$LN9@RouteGetEx:
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T224415[ebp], edx
	mov	eax, DWORD PTR _uiSecondCityIndex$219795[ebp]
	cmp	eax, DWORD PTR $T224415[ebp]
	jae	$LN7@RouteGetEx

; 3482 : 	{
; 3483 : 		if(uiFirstCityIndex == uiSecondCityIndex)

	mov	ecx, DWORD PTR _uiFirstCityIndex$[ebp]
	cmp	ecx, DWORD PTR _uiSecondCityIndex$219795[ebp]
	jne	SHORT $LN6@RouteGetEx

; 3484 : 		{
; 3485 : 			continue;

	jmp	SHORT $LN8@RouteGetEx
$LN6@RouteGetEx:

; 3486 : 		}
; 3487 : 
; 3488 : 		CvCityConnections::RouteInfo* pRouteInfo = pCityConnections->GetRouteInfo(uiFirstCityIndex, uiSecondCityIndex);

	mov	edx, DWORD PTR _uiSecondCityIndex$219795[ebp]
	push	edx
	mov	eax, DWORD PTR _uiFirstCityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pRouteInfo$219800[ebp], eax

; 3489 : 		if(!pRouteInfo)

	cmp	DWORD PTR _pRouteInfo$219800[ebp], 0
	jne	SHORT $LN5@RouteGetEx

; 3490 : 		{
; 3491 : 			continue;

	jmp	SHORT $LN8@RouteGetEx
$LN5@RouteGetEx:

; 3492 : 		}
; 3493 : 
; 3494 : 		// get the two cities
; 3495 : 		CvCity* pFirstCity  = pCityConnections->GetCityFromIndex(uiFirstCityIndex);

	mov	ecx, DWORD PTR _uiFirstCityIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
	mov	DWORD PTR _pFirstCity$219802[ebp], eax

; 3496 : 		CvCity* pSecondCity = pCityConnections->GetCityFromIndex(uiSecondCityIndex);

	mov	edx, DWORD PTR _uiSecondCityIndex$219795[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
	mov	DWORD PTR _pSecondCity$219803[ebp], eax

; 3497 : 
; 3498 : 		if(!pFirstCity || !pSecondCity)

	cmp	DWORD PTR _pFirstCity$219802[ebp], 0
	je	SHORT $LN3@RouteGetEx
	cmp	DWORD PTR _pSecondCity$219803[ebp], 0
	jne	SHORT $LN4@RouteGetEx
$LN3@RouteGetEx:

; 3499 : 		{
; 3500 : 			continue;

	jmp	SHORT $LN8@RouteGetEx
$LN4@RouteGetEx:

; 3501 : 		}
; 3502 : 
; 3503 : 		if(pRouteInfo->m_cRouteState & CvCityConnections::HAS_WATER_ROUTE)

	mov	eax, DWORD PTR _pRouteInfo$219800[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 2
	je	SHORT $LN2@RouteGetEx

; 3504 : 		{
; 3505 : 			if(iValidCount == iIndex)

	mov	edx, DWORD PTR _iValidCount$[ebp]
	cmp	edx, DWORD PTR _iIndex$[ebp]
	jne	SHORT $LN1@RouteGetEx

; 3506 : 			{
; 3507 : 				iX = pSecondCity->getX();

	mov	eax, DWORD PTR _pSecondCity$219803[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T224424[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	mov	eax, DWORD PTR $T224424[ebp]
	mov	DWORD PTR [edx], eax

; 3508 : 				iY = pSecondCity->getY();

	mov	ecx, DWORD PTR _pSecondCity$219803[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T224433[ebp], edx
	mov	eax, DWORD PTR _iY$[ebp]
	mov	ecx, DWORD PTR $T224433[ebp]
	mov	DWORD PTR [eax], ecx

; 3509 : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN13@RouteGetEx
$LN1@RouteGetEx:

; 3510 : 			}
; 3511 : 			iValidCount++;

	mov	edx, DWORD PTR _iValidCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iValidCount$[ebp], edx
$LN2@RouteGetEx:

; 3512 : 		}
; 3513 : 	}

	jmp	$LN8@RouteGetEx
$LN7@RouteGetEx:

; 3514 : 
; 3515 : 	return 0;

	xor	eax, eax
$LN13@RouteGetEx:

; 3516 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z ENDP ; RouteGetExtraChild
_TEXT	ENDS
PUBLIC	?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; RouteValid
EXTRN	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::getBestRoute
EXTRN	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z:PROC ; CvMinorCivAI::IsActiveQuestForPlayer
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?IsRoutePillaged@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsRoutePillaged
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
; Function compile flags: /Odtp
;	COMDAT ?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224520 = -76						; size = 4
$T224516 = -72						; size = 4
_f$224506 = -67						; size = 1
_f$224497 = -66						; size = 1
$T224485 = -65						; size = 1
$T224484 = -64						; size = 4
_uiOffset$224479 = -60					; size = 4
$T224470 = -56						; size = 4
$T224448 = -52						; size = 4
$T224442 = -48						; size = 4
_eRequiredRoute$219845 = -44				; size = 4
_iRoute$219844 = -40					; size = 4
_eMajorPlayer$219832 = -36				; size = 4
_kPlotOwner$219834 = -32				; size = 4
_eMinorPlayer$219833 = -28				; size = 4
_ePlotOwnerPlayer$219830 = -24				; size = 4
_ePlayer$ = -20						; size = 4
_iFlags$ = -16						; size = 4
_pNewPlot$ = -12					; size = 4
_kPlayer$ = -8						; size = 4
_eRouteType$ = -4					; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; RouteValid, COMDAT

; 3522 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 3523 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3524 : 	CvPlot* pNewPlot;
; 3525 : #endif
; 3526 : 
; 3527 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN20@RouteValid

; 3528 : 	{
; 3529 : 		return TRUE;

	mov	eax, 1
	jmp	$LN21@RouteValid
$LN20@RouteValid:

; 3530 : 	}
; 3531 : 
; 3532 : 	int iFlags = finder->GetInfo();

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _iFlags$[ebp], ecx

; 3533 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _ePlayer$[ebp], edx

; 3534 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3535 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3536 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3537 : #else
; 3538 : 	pNewPlot = node->m_pPlot;
; 3539 : #endif
; 3540 : 	if (!pNewPlot)
; 3541 : 		return FALSE;
; 3542 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3543 : 	CvPlot* pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);
; 3544 : #else
; 3545 : 	pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224442[ebp], eax
	mov	ecx, DWORD PTR $T224442[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T224448[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T224448[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T224442[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pNewPlot$[ebp], eax

; 3546 : #endif
; 3547 : 
; 3548 : 	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], edx

; 3549 : 	if((iFlags & MOVE_ROUTE_ALLOW_UNEXPLORED) == 0 && !(pNewPlot->isRevealed(kPlayer.getTeam())))

	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, 1073741824				; 40000000H
	jne	SHORT $LN19@RouteValid
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224470[ebp], eax
	mov	eax, DWORD PTR $T224470[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$224479[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$224479[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T224470[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$224479[ebp]
	mov	edx, DWORD PTR _pNewPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@RouteValid

; 3550 : 	{
; 3551 : 		return FALSE;

	xor	eax, eax
	jmp	$LN21@RouteValid
$LN19@RouteValid:

; 3552 : 	}
; 3553 : 
; 3554 : 	if(kPlayer.GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad())

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T224484[ebp], eax
	mov	edx, DWORD PTR $T224484[ebp]
	mov	al, BYTE PTR [edx+333]
	mov	BYTE PTR $T224485[ebp], al
	movzx	ecx, BYTE PTR $T224485[ebp]
	test	ecx, ecx
	je	SHORT $LN18@RouteValid

; 3555 : 	{
; 3556 : 		if(pNewPlot->getOwner() == ePlayer)

	mov	edx, DWORD PTR _pNewPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN18@RouteValid

; 3557 : 		{
; 3558 : 			if(pNewPlot->getFeatureType() == FEATURE_FOREST || pNewPlot->getFeatureType() == FEATURE_JUNGLE)

	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$224497[ebp], dl
	movsx	eax, BYTE PTR _f$224497[ebp]
	cmp	eax, 5
	je	SHORT $LN15@RouteValid
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$224506[ebp], dl
	movsx	eax, BYTE PTR _f$224506[ebp]
	cmp	eax, 1
	jne	SHORT $LN18@RouteValid
$LN15@RouteValid:

; 3559 : 			{
; 3560 : 				return TRUE;

	mov	eax, 1
	jmp	$LN21@RouteValid
$LN18@RouteValid:

; 3561 : 			}
; 3562 : 		}
; 3563 : 	}
; 3564 : 
; 3565 : 	RouteTypes eRouteType = pNewPlot->getRouteType();

	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eRouteType$[ebp], eax

; 3566 : 	if(eRouteType == NO_ROUTE)

	cmp	DWORD PTR _eRouteType$[ebp], -1
	jne	SHORT $LN14@RouteValid

; 3567 : 	{
; 3568 : 		return FALSE;

	xor	eax, eax
	jmp	$LN21@RouteValid
$LN14@RouteValid:

; 3569 : 	}
; 3570 : 
; 3571 : 	if(pNewPlot->IsRoutePillaged())

	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@RouteValid

; 3572 : 	{
; 3573 : 		return FALSE;

	xor	eax, eax
	jmp	$LN21@RouteValid
$LN13@RouteValid:

; 3574 : 	}
; 3575 : 
; 3576 : 	if(!pNewPlot->IsFriendlyTerritory(ePlayer))

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	movzx	eax, al
	test	eax, eax
	jne	$LN12@RouteValid

; 3577 : 	{
; 3578 : 		PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _ePlotOwnerPlayer$219830[ebp], edx

; 3579 : 		if(ePlotOwnerPlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlotOwnerPlayer$219830[ebp], -1
	je	$LN12@RouteValid

; 3580 : 		{
; 3581 : 			PlayerTypes eMajorPlayer = NO_PLAYER;

	mov	DWORD PTR _eMajorPlayer$219832[ebp], -1

; 3582 : 			PlayerTypes eMinorPlayer = NO_PLAYER;

	mov	DWORD PTR _eMinorPlayer$219833[ebp], -1

; 3583 : 			CvPlayer& kPlotOwner = GET_PLAYER(ePlotOwnerPlayer);

	mov	eax, DWORD PTR _ePlotOwnerPlayer$219830[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlotOwner$219834[ebp], eax

; 3584 : 			if(kPlayer.isMinorCiv() && !kPlotOwner.isMinorCiv())

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@RouteValid
	mov	ecx, DWORD PTR _kPlotOwner$219834[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@RouteValid

; 3585 : 			{
; 3586 : 				eMajorPlayer = ePlotOwnerPlayer;

	mov	eax, DWORD PTR _ePlotOwnerPlayer$219830[ebp]
	mov	DWORD PTR _eMajorPlayer$219832[ebp], eax

; 3587 : 				eMinorPlayer = ePlayer;

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR _eMinorPlayer$219833[ebp], ecx
	jmp	SHORT $LN9@RouteValid
$LN10@RouteValid:

; 3588 : 			}
; 3589 : 			else if(kPlotOwner.isMinorCiv() && !kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _kPlotOwner$219834[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@RouteValid
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@RouteValid

; 3590 : 			{
; 3591 : 				eMajorPlayer = ePlayer;

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR _eMajorPlayer$219832[ebp], ecx

; 3592 : 				eMinorPlayer = ePlotOwnerPlayer;

	mov	edx, DWORD PTR _ePlotOwnerPlayer$219830[ebp]
	mov	DWORD PTR _eMinorPlayer$219833[ebp], edx

; 3593 : 			}
; 3594 : 			else

	jmp	SHORT $LN9@RouteValid
$LN8@RouteValid:

; 3595 : 			{
; 3596 : 				return FALSE;

	xor	eax, eax
	jmp	$LN21@RouteValid
$LN9@RouteValid:

; 3597 : 			}
; 3598 : 
; 3599 : 			if(!GET_PLAYER(eMinorPlayer).GetMinorCivAI()->IsActiveQuestForPlayer(eMajorPlayer, MINOR_CIV_QUEST_ROUTE))

	mov	eax, DWORD PTR _eMinorPlayer$219833[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224516[ebp], eax
	push	0
	mov	ecx, DWORD PTR _eMajorPlayer$219832[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T224516[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@RouteValid

; 3600 : 			{
; 3601 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN21@RouteValid
$LN12@RouteValid:

; 3602 : 			}
; 3603 : 		}
; 3604 : 	}
; 3605 : 
; 3606 : 	if(finder->GetInfo() & MOVE_ANY_ROUTE)

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T224520[ebp], ecx
	mov	edx, DWORD PTR $T224520[ebp]
	and	edx, -2147483648			; 80000000H
	je	SHORT $LN5@RouteValid

; 3607 : 	{
; 3608 : 		// if the player can't build
; 3609 : 		if(kPlayer.getBestRoute() == NO_ROUTE)

	push	0
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	cmp	eax, -1
	jne	SHORT $LN4@RouteValid

; 3610 : 		{
; 3611 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN21@RouteValid
$LN4@RouteValid:

; 3612 : 		}
; 3613 : 
; 3614 : 		if(eRouteType != NO_ROUTE)

	cmp	DWORD PTR _eRouteType$[ebp], -1
	je	SHORT $LN3@RouteValid

; 3615 : 		{
; 3616 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN21@RouteValid
$LN3@RouteValid:

; 3617 : 		}
; 3618 : 	}
; 3619 : 	else

	jmp	SHORT $LN2@RouteValid
$LN5@RouteValid:

; 3620 : 	{
; 3621 : 		int iRoute = iFlags & 0xFF00;

	mov	eax, DWORD PTR _iFlags$[ebp]
	and	eax, 65280				; 0000ff00H
	mov	DWORD PTR _iRoute$219844[ebp], eax

; 3622 : 		iRoute = iRoute >> 8;

	mov	ecx, DWORD PTR _iRoute$219844[ebp]
	sar	ecx, 8
	mov	DWORD PTR _iRoute$219844[ebp], ecx

; 3623 : 		iRoute = iRoute - 1;

	mov	edx, DWORD PTR _iRoute$219844[ebp]
	sub	edx, 1
	mov	DWORD PTR _iRoute$219844[ebp], edx

; 3624 : 		RouteTypes eRequiredRoute = (RouteTypes)(iRoute);

	mov	eax, DWORD PTR _iRoute$219844[ebp]
	mov	DWORD PTR _eRequiredRoute$219845[ebp], eax

; 3625 : 		if(eRouteType == eRequiredRoute)

	mov	ecx, DWORD PTR _eRouteType$[ebp]
	cmp	ecx, DWORD PTR _eRequiredRoute$219845[ebp]
	jne	SHORT $LN2@RouteValid

; 3626 : 		{
; 3627 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN21@RouteValid
$LN2@RouteValid:

; 3628 : 		}
; 3629 : 	}
; 3630 : 
; 3631 : 	return FALSE;

	xor	eax, eax
$LN21@RouteValid:

; 3632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; RouteValid
_TEXT	ENDS
PUBLIC	?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z ; RouteGetNumExtraChildren
EXTRN	?IsEmpty@CvCityConnections@@QAE_NXZ:PROC	; CvCityConnections::IsEmpty
; Function compile flags: /Odtp
;	COMDAT ?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z
_TEXT	SEGMENT
$T224574 = -80						; size = 4
$T224570 = -76						; size = 4
$T224561 = -68						; size = 4
$T224560 = -64						; size = 4
$T224547 = -60						; size = 4
$T224541 = -56						; size = 4
$T224526 = -52						; size = 4
_pRouteInfo$219872 = -48				; size = 4
_pFirstCity$219874 = -44				; size = 4
_pSecondCity$219875 = -40				; size = 4
_uiSecondCityIndex$219867 = -36				; size = 4
_ePlayer$ = -32						; size = 4
_uiFirstCityIndex$ = -28				; size = 4
_pPlot$ = -24						; size = 4
_pCity$ = -20						; size = 4
_eTeam$ = -16						; size = 4
_pCityConnections$ = -12				; size = 4
_kPlayer$ = -8						; size = 4
_iResultNum$ = -4					; size = 4
_node$ = 8						; size = 4
_finder$ = 12						; size = 4
?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z PROC ; RouteGetNumExtraChildren, COMDAT

; 3638 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 3639 : 	PlayerTypes ePlayer = ((PlayerTypes)(finder->GetInfo() & 0xFF));

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T224526[ebp], ecx
	mov	edx, DWORD PTR $T224526[ebp]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _ePlayer$[ebp], edx

; 3640 : 	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], eax

; 3641 : 	TeamTypes eTeam = kPlayer.getTeam();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 3642 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3643 : 	const CvPlot* pPlot = node->m_pPlot;
; 3644 : #else
; 3645 : 	CvPlot* pPlot = GC.getMap().plotCheckInvalid(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224541[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T224561[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T224560[ebp], ecx
	cmp	DWORD PTR $T224560[ebp], -2147483647	; 80000001H
	je	SHORT $LN27@RouteGetNu
	cmp	DWORD PTR $T224561[ebp], -2147483647	; 80000001H
	jne	SHORT $LN28@RouteGetNu
$LN27@RouteGetNu:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	SHORT $LN29@RouteGetNu
$LN28@RouteGetNu:
	mov	edx, DWORD PTR $T224541[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T224547[ebp], eax
	mov	ecx, DWORD PTR $T224561[ebp]
	imul	ecx, DWORD PTR $T224547[ebp]
	add	ecx, DWORD PTR $T224560[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T224541[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$[ebp], ecx
$LN29@RouteGetNu:

; 3646 : #endif
; 3647 : 
; 3648 : 	if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN14@RouteGetNu

; 3649 : 	{
; 3650 : 		return 0;

	xor	eax, eax
	jmp	$LN15@RouteGetNu
$LN14@RouteGetNu:

; 3651 : 	}
; 3652 : 
; 3653 : 	// slewis - don't allow the minor civ to use harbors
; 3654 : 	if(kPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@RouteGetNu

; 3655 : 	{
; 3656 : 		return 0;

	xor	eax, eax
	jmp	$LN15@RouteGetNu
$LN13@RouteGetNu:

; 3657 : 	}
; 3658 : 
; 3659 : 	CvCityConnections* pCityConnections = kPlayer.GetCityConnections();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	DWORD PTR _pCityConnections$[ebp], eax

; 3660 : 	if(pCityConnections->IsEmpty())

	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?IsEmpty@CvCityConnections@@QAE_NXZ	; CvCityConnections::IsEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@RouteGetNu

; 3661 : 	{
; 3662 : 		return 0;

	xor	eax, eax
	jmp	$LN15@RouteGetNu
$LN12@RouteGetNu:

; 3663 : 	}
; 3664 : 
; 3665 : 	int iResultNum = 0;

	mov	DWORD PTR _iResultNum$[ebp], 0

; 3666 : 
; 3667 : 	CvCity* pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 3668 : 
; 3669 : 	// if there isn't a city there or the city isn't on our team
; 3670 : 	if(!pCity || pCity->getTeam() != eTeam)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN10@RouteGetNu
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN11@RouteGetNu
$LN10@RouteGetNu:

; 3671 : 	{
; 3672 : 		return 0;

	xor	eax, eax
	jmp	$LN15@RouteGetNu
$LN11@RouteGetNu:

; 3673 : 	}
; 3674 : 
; 3675 : 	uint uiFirstCityIndex = pCityConnections->GetIndexFromCity(pCity);

	mov	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetIndexFromCity@CvCityConnections@@QAEIPAVCvCity@@@Z ; CvCityConnections::GetIndexFromCity
	mov	DWORD PTR _uiFirstCityIndex$[ebp], eax

; 3676 : 	if(uiFirstCityIndex >= pCityConnections->m_aiCityPlotIDs.size())

	mov	eax, DWORD PTR _pCityConnections$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T224570[ebp], ecx
	mov	edx, DWORD PTR _uiFirstCityIndex$[ebp]
	cmp	edx, DWORD PTR $T224570[ebp]
	jb	SHORT $LN9@RouteGetNu

; 3677 : 	{
; 3678 : 		CvAssertMsg(false, "City index out of bounds");
; 3679 : 		return 0;

	xor	eax, eax
	jmp	$LN15@RouteGetNu
$LN9@RouteGetNu:

; 3680 : 	}
; 3681 : 
; 3682 : 	for(uint uiSecondCityIndex = 0; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	mov	DWORD PTR _uiSecondCityIndex$219867[ebp], 0
	jmp	SHORT $LN8@RouteGetNu
$LN7@RouteGetNu:
	mov	eax, DWORD PTR _uiSecondCityIndex$219867[ebp]
	add	eax, 1
	mov	DWORD PTR _uiSecondCityIndex$219867[ebp], eax
$LN8@RouteGetNu:
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T224574[ebp], edx
	mov	eax, DWORD PTR _uiSecondCityIndex$219867[ebp]
	cmp	eax, DWORD PTR $T224574[ebp]
	jae	SHORT $LN6@RouteGetNu

; 3683 : 	{
; 3684 : 		if(uiFirstCityIndex == uiSecondCityIndex)

	mov	ecx, DWORD PTR _uiFirstCityIndex$[ebp]
	cmp	ecx, DWORD PTR _uiSecondCityIndex$219867[ebp]
	jne	SHORT $LN5@RouteGetNu

; 3685 : 		{
; 3686 : 			continue;

	jmp	SHORT $LN7@RouteGetNu
$LN5@RouteGetNu:

; 3687 : 		}
; 3688 : 
; 3689 : 		CvCityConnections::RouteInfo* pRouteInfo = pCityConnections->GetRouteInfo(uiFirstCityIndex, uiSecondCityIndex);

	mov	edx, DWORD PTR _uiSecondCityIndex$219867[ebp]
	push	edx
	mov	eax, DWORD PTR _uiFirstCityIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetRouteInfo@CvCityConnections@@QAEPAURouteInfo@1@II@Z ; CvCityConnections::GetRouteInfo
	mov	DWORD PTR _pRouteInfo$219872[ebp], eax

; 3690 : 		if(!pRouteInfo)

	cmp	DWORD PTR _pRouteInfo$219872[ebp], 0
	jne	SHORT $LN4@RouteGetNu

; 3691 : 		{
; 3692 : 			continue;

	jmp	SHORT $LN7@RouteGetNu
$LN4@RouteGetNu:

; 3693 : 		}
; 3694 : 
; 3695 : 		// get the two cities
; 3696 : 		CvCity* pFirstCity  = pCityConnections->GetCityFromIndex(uiFirstCityIndex);

	mov	ecx, DWORD PTR _uiFirstCityIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
	mov	DWORD PTR _pFirstCity$219874[ebp], eax

; 3697 : 		CvCity* pSecondCity = pCityConnections->GetCityFromIndex(uiSecondCityIndex);

	mov	edx, DWORD PTR _uiSecondCityIndex$219867[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
	mov	DWORD PTR _pSecondCity$219875[ebp], eax

; 3698 : 
; 3699 : 		if(!pFirstCity || !pSecondCity)

	cmp	DWORD PTR _pFirstCity$219874[ebp], 0
	je	SHORT $LN2@RouteGetNu
	cmp	DWORD PTR _pSecondCity$219875[ebp], 0
	jne	SHORT $LN3@RouteGetNu
$LN2@RouteGetNu:

; 3700 : 		{
; 3701 : 			continue;

	jmp	SHORT $LN7@RouteGetNu
$LN3@RouteGetNu:

; 3702 : 		}
; 3703 : 
; 3704 : 		if(pRouteInfo->m_cRouteState & CvCityConnections::HAS_WATER_ROUTE)

	mov	eax, DWORD PTR _pRouteInfo$219872[ebp]
	movsx	ecx, BYTE PTR [eax]
	and	ecx, 2
	je	SHORT $LN1@RouteGetNu

; 3705 : 		{
; 3706 : 			iResultNum++;

	mov	edx, DWORD PTR _iResultNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _iResultNum$[ebp], edx
$LN1@RouteGetNu:

; 3707 : 		}
; 3708 : 	}

	jmp	$LN7@RouteGetNu
$LN6@RouteGetNu:

; 3709 : 
; 3710 : 	return iResultNum;

	mov	eax, DWORD PTR _iResultNum$[ebp]
$LN15@RouteGetNu:

; 3711 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z ENDP ; RouteGetNumExtraChildren
_TEXT	ENDS
PUBLIC	?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; WaterRouteValid
; Function compile flags: /Odtp
;	COMDAT ?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_uiOffset$224620 = -32					; size = 4
$T224601 = -28						; size = 4
$T224595 = -24						; size = 4
$T224583 = -20						; size = 4
_ePlayer$ = -16						; size = 4
_pCity$ = -12						; size = 4
_pNewPlot$ = -8						; size = 4
_eTeam$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; WaterRouteValid, COMDAT

; 3716 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3717 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3718 : 	CvPlot* pNewPlot;
; 3719 : #endif
; 3720 : 
; 3721 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN4@WaterRoute

; 3722 : 	{
; 3723 : 		return TRUE;

	mov	eax, 1
	jmp	$LN5@WaterRoute
$LN4@WaterRoute:

; 3724 : 	}
; 3725 : 
; 3726 : 	PlayerTypes ePlayer = (PlayerTypes)(finder->GetInfo());

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 3727 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224583[ebp], edx
	mov	eax, DWORD PTR $T224583[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 3728 : 
; 3729 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3730 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3731 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3732 : #else
; 3733 : 	pNewPlot = node->m_pPlot;
; 3734 : #endif
; 3735 : 	if (!pNewPlot)
; 3736 : 		return FALSE;
; 3737 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3738 : 	CvPlot* pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);
; 3739 : #else
; 3740 : 	pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224595[ebp], edx
	mov	eax, DWORD PTR $T224595[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224601[ebp], ecx
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T224601[ebp]
	add	edx, eax
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T224595[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pNewPlot$[ebp], edx

; 3741 : #endif
; 3742 : 
; 3743 : 	if(!(pNewPlot->isRevealed(eTeam)))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$224620[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$224620[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$224620[ebp]
	mov	edx, DWORD PTR _pNewPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@WaterRoute

; 3744 : 	{
; 3745 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN5@WaterRoute
$LN3@WaterRoute:

; 3746 : 	}
; 3747 : 
; 3748 : 	CvCity* pCity = pNewPlot->getPlotCity();

	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 3749 : 	if(pCity && pCity->getTeam() == eTeam)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN32@WaterRoute
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN32@WaterRoute

; 3750 : 	{
; 3751 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN5@WaterRoute

; 3752 : 	}
; 3753 : 
; 3754 : 	if(pNewPlot->isWater())

$LN32@WaterRoute:
	mov	edx, DWORD PTR _pNewPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@WaterRoute

; 3755 : 	{
; 3756 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN5@WaterRoute
$LN1@WaterRoute:

; 3757 : 	}
; 3758 : 
; 3759 : 	return FALSE;

	xor	eax, eax
$LN5@WaterRoute:

; 3760 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; WaterRouteValid
_TEXT	ENDS
PUBLIC	__real@3f000000
PUBLIC	?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteCost
EXTRN	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlot::GetBuilderAIScratchPadPlayer
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ:PROC	; CvPlot::GetBuilderAIScratchPadTurn
EXTRN	?getMovementCost@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getMovementCost
EXTRN	?getMovementCost@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getMovementCost
EXTRN	__fltused:DWORD
;	COMDAT __real@3f000000
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
CONST	ENDS
;	COMDAT ?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv143 = -68						; size = 4
$T224694 = -64						; size = 4
_f$224690 = -57						; size = 1
$T224681 = -56						; size = 4
_f$224677 = -49						; size = 1
$T224660 = -48						; size = 4
$T224643 = -44						; size = 4
$T224637 = -40						; size = 4
_iReturnValue$219911 = -36				; size = 4
_ePlayer$ = -32						; size = 4
_pPlot$ = -28						; size = 4
_eRoute$ = -24						; size = 4
_iMovementCost$ = -20					; size = 4
_iFlags$ = -16						; size = 4
_eTeam$ = -12						; size = 4
_iRoute$ = -8						; size = 4
_iMaxValue$ = -4					; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; BuildRouteCost, COMDAT

; 3765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi

; 3766 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3767 : 	const CvPlot* pPlot = node->m_pPlot;
; 3768 : #else
; 3769 : 	CvPlot* pPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224637[ebp], eax
	mov	ecx, DWORD PTR $T224637[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T224643[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T224643[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T224637[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pPlot$[ebp], eax

; 3770 : #endif
; 3771 : 	int iFlags = finder->GetInfo();

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR _iFlags$[ebp], eax

; 3772 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	ecx, DWORD PTR _iFlags$[ebp]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 3773 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224660[ebp], edx
	mov	eax, DWORD PTR $T224660[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 3774 : 
; 3775 : 	int iRoute = iFlags & 0xFF00;

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 65280				; 0000ff00H
	mov	DWORD PTR _iRoute$[ebp], edx

; 3776 : 	iRoute = iRoute >> 8;

	mov	eax, DWORD PTR _iRoute$[ebp]
	sar	eax, 8
	mov	DWORD PTR _iRoute$[ebp], eax

; 3777 : 	iRoute = iRoute - 1;

	mov	ecx, DWORD PTR _iRoute$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iRoute$[ebp], ecx

; 3778 : 	RouteTypes eRoute = (RouteTypes)(iRoute);

	mov	edx, DWORD PTR _iRoute$[ebp]
	mov	DWORD PTR _eRoute$[ebp], edx

; 3779 : 
; 3780 : 	if(pPlot->getRouteType() != NO_ROUTE)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN4@BuildRoute

; 3781 : 	{
; 3782 : 		int iReturnValue = PATH_BUILD_ROUTE_EXISTING_ROUTE_WEIGHT;

	mov	DWORD PTR _iReturnValue$219911[ebp], 10	; 0000000aH

; 3783 : 		if(pPlot->getRouteType() == eRoute)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, DWORD PTR _eRoute$[ebp]
	jne	SHORT $LN3@BuildRoute

; 3784 : 		{
; 3785 : 			iReturnValue = 1;

	mov	DWORD PTR _iReturnValue$219911[ebp], 1
$LN3@BuildRoute:

; 3786 : 		}
; 3787 : 		return iReturnValue;

	mov	eax, DWORD PTR _iReturnValue$219911[ebp]
	jmp	$LN5@BuildRoute
$LN4@BuildRoute:

; 3788 : 	}
; 3789 : 
; 3790 : 	int iMaxValue = 1500;

	mov	DWORD PTR _iMaxValue$[ebp], 1500	; 000005dcH

; 3791 : 
; 3792 : 	// if the plot is on a removable feature, it tends to be a good idea to build a road here
; 3793 : 	int iMovementCost = ((pPlot->getFeatureType() == NO_FEATURE) ? GC.getTerrainInfo(pPlot->getTerrainType())->getMovementCost() : GC.getFeatureInfo(pPlot->getFeatureType())->getMovementCost());

	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$224677[ebp], cl
	movsx	edx, BYTE PTR _f$224677[ebp]
	cmp	edx, -1
	jne	SHORT $LN7@BuildRoute
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR $T224681[ebp], ecx
	mov	edx, DWORD PTR $T224681[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getMovementCost@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getMovementCost
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN8@BuildRoute
$LN7@BuildRoute:
	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$224690[ebp], cl
	movsx	edx, BYTE PTR _f$224690[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getMovementCost@CvFeatureInfo@@QBEHXZ	; CvFeatureInfo::getMovementCost
	mov	DWORD PTR tv143[ebp], eax
$LN8@BuildRoute:
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR _iMovementCost$[ebp], eax

; 3794 : 
; 3795 : #ifdef AUI_ASTAR_FIX_BUILD_ROUTE_COST_CONSIDER_HILLS_MOVEMENT
; 3796 : 	// Hill cost, except for when a City is present here, then it just counts as flat land
; 3797 : 	if ((PlotTypes)pPlot->getPlotType() == PLOT_HILLS && !pPlot->isCity())
; 3798 : 	{
; 3799 : 		iMovementCost += GC.getHILLS_EXTRA_MOVEMENT();
; 3800 : 	}
; 3801 : #endif
; 3802 : 
; 3803 : 	// calculate the max value based on how much of a movement increase we get
; 3804 : 	if(iMovementCost + 1 != 0)

	mov	ecx, DWORD PTR _iMovementCost$[ebp]
	add	ecx, 1
	je	SHORT $LN2@BuildRoute

; 3805 : 	{
; 3806 : 		iMaxValue = iMaxValue / 2 + iMaxValue / (iMovementCost + 1);

	mov	eax, DWORD PTR _iMaxValue$[ebp]
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	mov	esi, DWORD PTR _iMovementCost$[ebp]
	add	esi, 1
	mov	eax, DWORD PTR _iMaxValue$[ebp]
	cdq
	idiv	esi
	add	ecx, eax
	mov	DWORD PTR _iMaxValue$[ebp], ecx
$LN2@BuildRoute:

; 3807 : 	}
; 3808 : 
; 3809 : 	// if the tile already been tagged for building a road, then provide a discount
; 3810 : 	if(pPlot->GetBuilderAIScratchPadTurn() == GC.getGame().getGameTurn() && pPlot->GetBuilderAIScratchPadPlayer() == ePlayer)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224694[ebp], edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	movsx	esi, ax
	mov	ecx, DWORD PTR $T224694[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jne	SHORT $LN1@BuildRoute
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN1@BuildRoute

; 3811 : 	{
; 3812 : 		iMaxValue = (int)(iMaxValue * PATH_BUILD_ROUTE_ALREADY_FLAGGED_DISCOUNT);

	cvtsi2ss xmm0, DWORD PTR _iMaxValue$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR _iMaxValue$[ebp], eax
$LN1@BuildRoute:

; 3813 : 	}
; 3814 : 
; 3815 : #ifdef AUI_WORKER_INCA_HILLS
; 3816 : 	if (GET_PLAYER(ePlayer).GetPlayerTraits()->IsNoHillsImprovementMaintenance() && pPlot->isHills())
; 3817 : 	{
; 3818 : 		iMaxValue /= 2;
; 3819 : 	}
; 3820 : #endif
; 3821 : 
; 3822 : 	return iMaxValue;

	mov	eax, DWORD PTR _iMaxValue$[ebp]
$LN5@BuildRoute:

; 3823 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; BuildRouteCost
_TEXT	ENDS
PUBLIC	?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteValid
; Function compile flags: /Odtp
;	COMDAT ?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224764 = -60						; size = 4
$T224760 = -56						; size = 4
_uiOffset$224743 = -52					; size = 4
$T224734 = -48						; size = 4
$T224715 = -44						; size = 4
$T224709 = -40						; size = 4
_eMajorPlayer$219938 = -36				; size = 4
_bPlotOwnerIsMinor$219940 = -29				; size = 1
_eMinorPlayer$219939 = -28				; size = 4
_ePlayer$ = -24						; size = 4
_bThisPlayerIsMinor$ = -17				; size = 1
_thisPlayer$ = -16					; size = 4
_iFlags$ = -12						; size = 4
_ePlotOwnerPlayer$ = -8					; size = 4
_pNewPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; BuildRouteValid, COMDAT

; 3828 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 3829 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 3830 : 	CvPlot* pNewPlot;
; 3831 : #endif
; 3832 : 
; 3833 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN11@BuildRoute@2

; 3834 : 	{
; 3835 : 		return TRUE;

	mov	eax, 1
	jmp	$LN12@BuildRoute@2
$LN11@BuildRoute@2:

; 3836 : 	}
; 3837 : 
; 3838 : 	int iFlags = finder->GetInfo();

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _iFlags$[ebp], ecx

; 3839 : 	PlayerTypes ePlayer = (PlayerTypes)(iFlags & 0xFF);

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR _ePlayer$[ebp], edx

; 3840 : 
; 3841 : 	CvPlayer& thisPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[ebp], eax

; 3842 : 	bool bThisPlayerIsMinor = thisPlayer.isMinorCiv();

	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bThisPlayerIsMinor$[ebp], al

; 3843 : 
; 3844 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3845 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 3846 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3847 : #else
; 3848 : 	pNewPlot = node->m_pPlot;
; 3849 : #endif
; 3850 : 	if (!pNewPlot)
; 3851 : 		return FALSE;
; 3852 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 3853 : 	CvPlot* pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);
; 3854 : #else
; 3855 : 	pNewPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224709[ebp], ecx
	mov	edx, DWORD PTR $T224709[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T224715[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T224715[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T224709[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pNewPlot$[ebp], ecx

; 3856 : #endif
; 3857 : 	if(!bThisPlayerIsMinor && !(pNewPlot->isRevealed(thisPlayer.getTeam())))

	movzx	eax, BYTE PTR _bThisPlayerIsMinor$[ebp]
	test	eax, eax
	jne	SHORT $LN34@BuildRoute@2
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224734[ebp], eax
	mov	eax, DWORD PTR $T224734[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$224743[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$224743[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T224734[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$224743[ebp]
	mov	edx, DWORD PTR _pNewPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN34@BuildRoute@2

; 3858 : 	{
; 3859 : 		return FALSE;

	xor	eax, eax
	jmp	$LN12@BuildRoute@2

; 3860 : 	}
; 3861 : 
; 3862 : 	if(pNewPlot->isWater())

$LN34@BuildRoute@2:
	mov	edx, DWORD PTR _pNewPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN36@BuildRoute@2

; 3863 : 	{
; 3864 : 		return FALSE;

	xor	eax, eax
	jmp	$LN12@BuildRoute@2

; 3865 : 	}
; 3866 : 
; 3867 : #ifdef AUI_ASTAR_FIX_STEP_VALID_CONSIDERS_MOUNTAINS
; 3868 : 	if (pNewPlot->isImpassable())
; 3869 : #else
; 3870 : 	if(pNewPlot->isImpassable() || pNewPlot->isMountain())

$LN36@BuildRoute@2:
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN7@BuildRoute@2
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN40@BuildRoute@2
$LN7@BuildRoute@2:

; 3871 : #endif
; 3872 : 	{
; 3873 : 		return FALSE;

	xor	eax, eax
	jmp	$LN12@BuildRoute@2

; 3874 : 	}
; 3875 : 
; 3876 : 	PlayerTypes ePlotOwnerPlayer = pNewPlot->getOwner();

$LN40@BuildRoute@2:
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _ePlotOwnerPlayer$[ebp], ecx

; 3877 : 	if(ePlotOwnerPlayer != NO_PLAYER && !pNewPlot->IsFriendlyTerritory(ePlayer))

	cmp	DWORD PTR _ePlotOwnerPlayer$[ebp], -1
	je	$LN6@BuildRoute@2
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	movzx	eax, al
	test	eax, eax
	jne	$LN6@BuildRoute@2

; 3878 : 	{
; 3879 : 		PlayerTypes eMajorPlayer = NO_PLAYER;

	mov	DWORD PTR _eMajorPlayer$219938[ebp], -1

; 3880 : 		PlayerTypes eMinorPlayer = NO_PLAYER;

	mov	DWORD PTR _eMinorPlayer$219939[ebp], -1

; 3881 : 		bool bPlotOwnerIsMinor = GET_PLAYER(ePlotOwnerPlayer).isMinorCiv();

	mov	ecx, DWORD PTR _ePlotOwnerPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224760[ebp], ecx
	mov	ecx, DWORD PTR $T224760[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bPlotOwnerIsMinor$219940[ebp], al

; 3882 : 		if(bThisPlayerIsMinor && !bPlotOwnerIsMinor)

	movzx	edx, BYTE PTR _bThisPlayerIsMinor$[ebp]
	test	edx, edx
	je	SHORT $LN5@BuildRoute@2
	movzx	eax, BYTE PTR _bPlotOwnerIsMinor$219940[ebp]
	test	eax, eax
	jne	SHORT $LN5@BuildRoute@2

; 3883 : 		{
; 3884 : 			eMajorPlayer = ePlotOwnerPlayer;

	mov	ecx, DWORD PTR _ePlotOwnerPlayer$[ebp]
	mov	DWORD PTR _eMajorPlayer$219938[ebp], ecx

; 3885 : 			eMinorPlayer = ePlayer;

	mov	edx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR _eMinorPlayer$219939[ebp], edx
	jmp	SHORT $LN4@BuildRoute@2
$LN5@BuildRoute@2:

; 3886 : 		}
; 3887 : 		else if(bPlotOwnerIsMinor && !bThisPlayerIsMinor)

	movzx	eax, BYTE PTR _bPlotOwnerIsMinor$219940[ebp]
	test	eax, eax
	je	SHORT $LN3@BuildRoute@2
	movzx	ecx, BYTE PTR _bThisPlayerIsMinor$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@BuildRoute@2

; 3888 : 		{
; 3889 : 			eMajorPlayer = ePlayer;

	mov	edx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR _eMajorPlayer$219938[ebp], edx

; 3890 : 			eMinorPlayer = ePlotOwnerPlayer;

	mov	eax, DWORD PTR _ePlotOwnerPlayer$[ebp]
	mov	DWORD PTR _eMinorPlayer$219939[ebp], eax

; 3891 : 		}
; 3892 : 		else

	jmp	SHORT $LN4@BuildRoute@2
$LN3@BuildRoute@2:

; 3893 : 		{
; 3894 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN12@BuildRoute@2
$LN4@BuildRoute@2:

; 3895 : 		}
; 3896 : 
; 3897 : 		if(!GET_PLAYER(eMinorPlayer).GetMinorCivAI()->IsActiveQuestForPlayer(eMajorPlayer, MINOR_CIV_QUEST_ROUTE))

	mov	ecx, DWORD PTR _eMinorPlayer$219939[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224764[ebp], ecx
	push	0
	mov	edx, DWORD PTR _eMajorPlayer$219938[ebp]
	push	edx
	mov	ecx, DWORD PTR $T224764[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsActiveQuestForPlayer@CvMinorCivAI@@QAE_NW4PlayerTypes@@W4MinorCivQuestTypes@@@Z ; CvMinorCivAI::IsActiveQuestForPlayer
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@BuildRoute@2

; 3898 : 		{
; 3899 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN12@BuildRoute@2
$LN6@BuildRoute@2:

; 3900 : 		}
; 3901 : 	}
; 3902 : 
; 3903 : 	return TRUE;

	mov	eax, 1
$LN12@BuildRoute@2:

; 3904 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; BuildRouteValid
_TEXT	ENDS
PUBLIC	?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AreaValid
; Function compile flags: /Odtp
;	COMDAT ?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224848 = -44						; size = 4
$T224837 = -40						; size = 4
$T224831 = -33						; size = 1
$T224827 = -32						; size = 4
$T224816 = -28						; size = 4
$T224807 = -24						; size = 4
$T224796 = -20						; size = 4
$T224790 = -13						; size = 1
$T224786 = -12						; size = 4
$T224775 = -8						; size = 4
_kMap$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; AreaValid, COMDAT

; 3910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 3911 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN2@AreaValid

; 3912 : 	{
; 3913 : 		return TRUE;

	mov	eax, 1
	jmp	$LN3@AreaValid
$LN2@AreaValid:

; 3914 : 	}
; 3915 : 
; 3916 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3917 : 	const CvPlot* pOldPlot = parent->m_pPlot;
; 3918 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 3919 : 	if (!pOldPlot || !pNewPlot)
; 3920 : 	{
; 3921 : 		return FALSE;
; 3922 : 	}
; 3923 : 	if (pOldPlot->isImpassable() != pNewPlot->isImpassable())
; 3924 : 	{
; 3925 : 		return FALSE;
; 3926 : 	}
; 3927 : 
; 3928 : 	return (pOldPlot->isWater() == pNewPlot->isWater() ? TRUE : FALSE);
; 3929 : #else
; 3930 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 3931 : 	if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->isImpassable() != kMap.plotUnchecked(node->m_iX, node->m_iY)->isImpassable())

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T224775[ebp], edx
	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T224775[ebp]
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+80]
	add	ecx, eax
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR $T224786[ebp], ecx
	mov	eax, DWORD PTR $T224786[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	mov	BYTE PTR $T224790[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T224796[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T224796[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR $T224807[ebp], edx
	movzx	ecx, BYTE PTR $T224790[ebp]
	mov	edx, DWORD PTR $T224807[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	edx, al
	cmp	ecx, edx
	je	SHORT $LN1@AreaValid

; 3932 : 	{
; 3933 : 		return FALSE;

	xor	eax, eax
	jmp	$LN3@AreaValid
$LN1@AreaValid:

; 3934 : 	}
; 3935 : 
; 3936 : 	return ((kMap.plotUnchecked(parent->m_iX, parent->m_iY)->isWater() == kMap.plotUnchecked(node->m_iX, node->m_iY)->isWater()) ? TRUE : FALSE);

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224816[ebp], ecx
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T224816[ebp]
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	add	eax, edx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR $T224827[ebp], eax
	mov	edx, DWORD PTR $T224827[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR $T224831[ebp], cl
	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T224837[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T224837[ebp]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR $T224848[ebp], edx
	movzx	ecx, BYTE PTR $T224831[ebp]
	mov	edx, DWORD PTR $T224848[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	edx, edx
	cmp	eax, 3
	sete	dl
	movzx	eax, dl
	xor	edx, edx
	cmp	ecx, eax
	sete	dl
	mov	eax, edx
$LN3@AreaValid:

; 3937 : #endif
; 3938 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; AreaValid
_TEXT	ENDS
PUBLIC	?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinArea
EXTRN	?setArea@CvPlot@@QAEXH@Z:PROC			; CvPlot::setArea
; Function compile flags: /Odtp
;	COMDAT ?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224867 = -12						; size = 4
$T224861 = -8						; size = 4
$T224857 = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; JoinArea, COMDAT

; 3944 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3945 : 	if(data == ASNL_ADDCLOSED)

	cmp	DWORD PTR _data$[ebp], 3
	jne	SHORT $LN1@JoinArea

; 3946 : 	{
; 3947 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 3948 : 		node->m_pPlot->setArea(finder->GetInfo());
; 3949 : #else
; 3950 : 		GC.getMap().plotUnchecked(node->m_iX, node->m_iY)->setArea(finder->GetInfo());

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T224857[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224861[ebp], edx
	mov	eax, DWORD PTR $T224861[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224867[ebp], ecx
	mov	edx, DWORD PTR $T224857[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T224867[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T224861[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	ecx, eax
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea
$LN1@JoinArea:

; 3951 : #endif
; 3952 : 	}
; 3953 : 
; 3954 : 	return 1;

	mov	eax, 1

; 3955 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; JoinArea
_TEXT	ENDS
PUBLIC	?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; LandmassValid
; Function compile flags: /Odtp
;	COMDAT ?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224920 = -24						; size = 4
$T224909 = -20						; size = 4
$T224903 = -13						; size = 1
$T224899 = -12						; size = 4
$T224888 = -8						; size = 4
_kMap$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; LandmassValid, COMDAT

; 3961 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3962 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN1@LandmassVa

; 3963 : 	{
; 3964 : 		return TRUE;

	mov	eax, 1
	jmp	$LN2@LandmassVa
$LN1@LandmassVa:

; 3965 : 	}
; 3966 : 
; 3967 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 3968 : 	return (parent->m_pPlot && node->m_pPlot && parent->m_pPlot->isWater() == node->m_pPlot->isWater() ? TRUE : FALSE);
; 3969 : #else
; 3970 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 3971 : 	return ((kMap.plotUnchecked(parent->m_iX, parent->m_iY)->isWater() == kMap.plotUnchecked(node->m_iX, node->m_iY)->isWater()) ? TRUE : FALSE);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T224888[ebp], edx
	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T224888[ebp]
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+80]
	add	ecx, eax
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR $T224899[ebp], ecx
	mov	eax, DWORD PTR $T224899[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	mov	BYTE PTR $T224903[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224909[ebp], ecx
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T224909[ebp]
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	add	eax, edx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR $T224920[ebp], eax
	movzx	edx, BYTE PTR $T224903[ebp]
	mov	eax, DWORD PTR $T224920[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	eax, eax
	cmp	ecx, 3
	sete	al
	movzx	ecx, al
	xor	eax, eax
	cmp	edx, ecx
	sete	al
$LN2@LandmassVa:

; 3972 : #endif
; 3973 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; LandmassValid
_TEXT	ENDS
PUBLIC	?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinLandmass
EXTRN	?setLandmass@CvPlot@@QAEXH@Z:PROC		; CvPlot::setLandmass
; Function compile flags: /Odtp
;	COMDAT ?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T224939 = -12						; size = 4
$T224933 = -8						; size = 4
$T224929 = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; JoinLandmass, COMDAT

; 3979 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3980 : 	if(data == ASNL_ADDCLOSED)

	cmp	DWORD PTR _data$[ebp], 3
	jne	SHORT $LN1@JoinLandma

; 3981 : 	{
; 3982 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 3983 : 		node->m_pPlot->setLandmass(finder->GetInfo());
; 3984 : #else
; 3985 : 		GC.getMap().plotUnchecked(node->m_iX, node->m_iY)->setLandmass(finder->GetInfo());

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T224929[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224933[ebp], edx
	mov	eax, DWORD PTR $T224933[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224939[ebp], ecx
	mov	edx, DWORD PTR $T224929[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T224939[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T224933[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	ecx, eax
	call	?setLandmass@CvPlot@@QAEXH@Z		; CvPlot::setLandmass
$LN1@JoinLandma:

; 3986 : #endif
; 3987 : 	}
; 3988 : 
; 3989 : 	return 1;

	mov	eax, 1

; 3990 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; JoinLandmass
_TEXT	ENDS
PUBLIC	??0CvTwoLayerPathFinder@@QAE@XZ			; CvTwoLayerPathFinder::CvTwoLayerPathFinder
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvTwoLayerPathFinder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTwoLayerPathFinder@@QAE@XZ$0
__ehfuncinfo$??0CvTwoLayerPathFinder@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTwoLayerPathFinder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0CvTwoLayerPathFinder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -644						; size = 4
$T224952 = -640						; size = 628
__$EHRec$ = -12						; size = 12
??0CvTwoLayerPathFinder@@QAE@XZ PROC			; CvTwoLayerPathFinder::CvTwoLayerPathFinder, COMDAT
; _this$ = ecx

; 3998 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTwoLayerPathFinder@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 632				; 00000278H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3999 : #ifdef AUI_WARNING_FIXES
; 4000 : 	this->CvAStar::CvAStar();
; 4001 : #else
; 4002 : 	CvAStar::CvAStar();

	lea	ecx, DWORD PTR $T224952[ebp]
	call	??0CvAStar@@QAE@XZ			; CvAStar::CvAStar
	lea	ecx, DWORD PTR $T224952[ebp]
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar

; 4003 : #endif
; 4004 : 	m_ppaaPartialMoveNodes = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+628], 0

; 4005 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTwoLayerPathFinder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
__ehhandler$??0CvTwoLayerPathFinder@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-636]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTwoLayerPathFinder@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTwoLayerPathFinder@@QAE@XZ ENDP			; CvTwoLayerPathFinder::CvTwoLayerPathFinder
PUBLIC	?DeInit@CvTwoLayerPathFinder@@QAEXXZ		; CvTwoLayerPathFinder::DeInit
PUBLIC	??1CvTwoLayerPathFinder@@QAE@XZ			; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvTwoLayerPathFinder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTwoLayerPathFinder@@QAE@XZ$0
__ehfuncinfo$??1CvTwoLayerPathFinder@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTwoLayerPathFinder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvTwoLayerPathFinder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTwoLayerPathFinder@@QAE@XZ PROC			; CvTwoLayerPathFinder::~CvTwoLayerPathFinder, COMDAT
; _this$ = ecx

; 4010 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTwoLayerPathFinder@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4011 : 	CvAStar::DeInit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 4012 : 
; 4013 : 	DeInit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeInit@CvTwoLayerPathFinder@@QAEXXZ	; CvTwoLayerPathFinder::DeInit

; 4014 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTwoLayerPathFinder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvAStar@@QAE@XZ			; CvAStar::~CvAStar
__ehhandler$??1CvTwoLayerPathFinder@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTwoLayerPathFinder@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTwoLayerPathFinder@@QAE@XZ ENDP			; CvTwoLayerPathFinder::~CvTwoLayerPathFinder
PUBLIC	??1CvAStarNode@@QAE@XZ				; CvAStarNode::~CvAStarNode
PUBLIC	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z$0
__ehfuncinfo$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
_TEXT	SEGMENT
tv168 = -44						; size = 4
_this$ = -40						; size = 4
$T224975 = -36						; size = 4
$T224974 = -32						; size = 4
$T224973 = -28						; size = 4
$T224972 = -24						; size = 4
_iJ$ = -20						; size = 4
_iI$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iColumns$ = 8						; size = 4
_iRows$ = 12						; size = 4
_bWrapX$ = 16						; size = 1
_bWrapY$ = 20						; size = 1
_IsPathDestFunc$ = 24					; size = 4
_DestValidFunc$ = 28					; size = 4
_HeuristicFunc$ = 32					; size = 4
_CostFunc$ = 36						; size = 4
_ValidFunc$ = 40					; size = 4
_NotifyChildFunc$ = 44					; size = 4
_NotifyListFunc$ = 48					; size = 4
_InitializeFunc$ = 52					; size = 4
_UninitializeFunc$ = 56					; size = 4
_pData$ = 60						; size = 4
?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z PROC ; CvTwoLayerPathFinder::Initialize, COMDAT
; _this$ = ecx

; 4019 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4020 : 	int iI, iJ;
; 4021 : 
; 4022 : 	DeInit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeInit@CvTwoLayerPathFinder@@QAEXXZ	; CvTwoLayerPathFinder::DeInit

; 4023 : 
; 4024 : 	CvAStar::Initialize(iColumns, iRows, bWrapX, bWrapY, IsPathDestFunc, DestValidFunc, HeuristicFunc, CostFunc, ValidFunc, NotifyChildFunc, NotifyListFunc, NULL, NULL, InitializeFunc, UninitializeFunc, pData);

	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _UninitializeFunc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _InitializeFunc$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _NotifyListFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _NotifyChildFunc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ValidFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _CostFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _HeuristicFunc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestValidFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _IsPathDestFunc$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bWrapY$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bWrapX$[ebp]
	push	edx
	mov	eax, DWORD PTR _iRows$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iColumns$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 4025 : 
; 4026 : 	m_ppaaPartialMoveNodes = FNEW(CvAStarNode*[m_iColumns], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T224972[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T224972[ebp]
	mov	DWORD PTR [eax+628], ecx

; 4027 : 	for(iI = 0; iI < m_iColumns; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@Initialize@2
$LN5@Initialize@2:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN6@Initialize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR [eax+48]
	jge	$LN7@Initialize@2

; 4028 : 	{
; 4029 : 		m_ppaaPartialMoveNodes[iI] = FNEW(CvAStarNode[m_iRows], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR $T224973[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T224973[ebp]
	mov	edx, 96					; 00000060H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T224975[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T224975[ebp], 0
	je	SHORT $LN9@Initialize@2
	mov	ecx, DWORD PTR $T224975[ebp]
	mov	edx, DWORD PTR $T224973[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1CvAStarNode@@QAE@XZ
	push	OFFSET ??0CvAStarNode@@QAE@XZ		; CvAStarNode::CvAStarNode
	mov	eax, DWORD PTR $T224973[ebp]
	push	eax
	push	96					; 00000060H
	mov	ecx, DWORD PTR $T224975[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T224975[ebp]
	add	edx, 4
	mov	DWORD PTR tv168[ebp], edx
	jmp	SHORT $LN10@Initialize@2
$LN9@Initialize@2:
	mov	DWORD PTR tv168[ebp], 0
$LN10@Initialize@2:
	mov	eax, DWORD PTR tv168[ebp]
	mov	DWORD PTR $T224974[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR $T224974[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 4030 : 		for(iJ = 0; iJ < m_iRows; iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN3@Initialize@2
$LN2@Initialize@2:
	mov	edx, DWORD PTR _iJ$[ebp]
	add	edx, 1
	mov	DWORD PTR _iJ$[ebp], edx
$LN3@Initialize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iJ$[ebp]
	cmp	ecx, DWORD PTR [eax+52]
	jge	SHORT $LN1@Initialize@2

; 4031 : 		{
; 4032 : 			m_ppaaPartialMoveNodes[iI][iJ].m_iX = iI;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+628]
	mov	ecx, DWORD PTR _iJ$[ebp]
	imul	ecx, 96					; 00000060H
	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	dx, WORD PTR _iI$[ebp]
	mov	WORD PTR [eax+ecx+80], dx

; 4033 : 			m_ppaaPartialMoveNodes[iI][iJ].m_iY = iJ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+628]
	mov	edx, DWORD PTR _iJ$[ebp]
	imul	edx, 96					; 00000060H
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	ax, WORD PTR _iJ$[ebp]
	mov	WORD PTR [ecx+edx+82], ax

; 4034 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4035 : 			m_ppaaPartialMoveNodes[iI][iJ].m_pPlot = GC.getMap().plot(iI, iJ);
; 4036 : #endif
; 4037 : 		}

	jmp	SHORT $LN2@Initialize@2
$LN1@Initialize@2:

; 4038 : 	}

	jmp	$LN5@Initialize@2
$LN7@Initialize@2:

; 4039 : };

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z$0:
	mov	eax, DWORD PTR $T224975[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ENDP ; CvTwoLayerPathFinder::Initialize
PUBLIC	??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>
PUBLIC	??_ECvAStarNode@@QAEPAXI@Z			; CvAStarNode::`vector deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_ECvAStarNode@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
___flags$ = 8						; size = 4
??_ECvAStarNode@@QAEPAXI@Z PROC				; CvAStarNode::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN6@vector
	push	OFFSET ??1CvAStarNode@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	96					; 00000060H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN6@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECvAStarNode@@QAEPAXI@Z ENDP				; CvAStarNode::`vector deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvAStarNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1CvAStarNode@@QAE@XZ PROC				; CvAStarNode::~CvAStarNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvAStarNode@@QAE@XZ ENDP				; CvAStarNode::~CvAStarNode
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DeInit@CvTwoLayerPathFinder@@QAEXXZ
_TEXT	SEGMENT
tv88 = -44						; size = 4
_this$ = -40						; size = 4
$T225099 = -36						; size = 4
$T225098 = -32						; size = 4
$T225093 = -28						; size = 4
$T225090 = -12						; size = 4
$T225089 = -8						; size = 4
_iI$220035 = -4						; size = 4
?DeInit@CvTwoLayerPathFinder@@QAEXXZ PROC		; CvTwoLayerPathFinder::DeInit, COMDAT
; _this$ = ecx

; 4044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 4045 : 	CvAStar::DeInit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeInit@CvAStar@@QAEXXZ			; CvAStar::DeInit

; 4046 : 
; 4047 : 	if(m_ppaaPartialMoveNodes != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+628], 0
	je	$LN5@DeInit@2

; 4048 : 	{
; 4049 : 		for(int iI = 0; iI < m_iColumns; iI++)

	mov	DWORD PTR _iI$220035[ebp], 0
	jmp	SHORT $LN3@DeInit@2
$LN2@DeInit@2:
	mov	ecx, DWORD PTR _iI$220035[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$220035[ebp], ecx
$LN3@DeInit@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iI$220035[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jge	SHORT $LN1@DeInit@2

; 4050 : 		{
; 4051 : 			SAFE_DELETE_ARRAY(m_ppaaPartialMoveNodes[iI]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	mov	eax, DWORD PTR _iI$220035[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T225093[ebp], ecx
	mov	edx, DWORD PTR $T225093[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225090[ebp], eax
	mov	ecx, DWORD PTR $T225090[ebp]
	mov	DWORD PTR $T225089[ebp], ecx
	cmp	DWORD PTR $T225089[ebp], 0
	je	SHORT $LN9@DeInit@2
	push	3
	mov	ecx, DWORD PTR $T225089[ebp]
	call	??_ECvAStarNode@@QAEPAXI@Z
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN10@DeInit@2
$LN9@DeInit@2:
	mov	DWORD PTR tv88[ebp], 0
$LN10@DeInit@2:
	mov	edx, DWORD PTR $T225093[ebp]
	mov	DWORD PTR [edx], 0

; 4052 : 		}

	jmp	SHORT $LN2@DeInit@2
$LN1@DeInit@2:

; 4053 : 
; 4054 : 		SAFE_DELETE_ARRAY(m_ppaaPartialMoveNodes);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 628				; 00000274H
	mov	DWORD PTR $T225099[ebp], eax
	mov	ecx, DWORD PTR $T225099[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225098[ebp], edx
	mov	eax, DWORD PTR $T225098[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T225099[ebp]
	mov	DWORD PTR [ecx], 0
$LN5@DeInit@2:

; 4055 : 	}
; 4056 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeInit@CvTwoLayerPathFinder@@QAEXXZ ENDP		; CvTwoLayerPathFinder::DeInit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iCol$ = 8						; size = 4
_iRow$ = 12						; size = 4
?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z PROC ; CvTwoLayerPathFinder::GetPartialMoveNode, COMDAT
; _this$ = ecx

; 4065 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4066 : 	return &(m_ppaaPartialMoveNodes[iCol][iRow]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+628]
	mov	eax, DWORD PTR _iRow$[ebp]
	imul	eax, 96					; 00000060H
	mov	edx, DWORD PTR _iCol$[ebp]
	add	eax, DWORD PTR [ecx+edx*4]

; 4067 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetPartialMoveNode@CvTwoLayerPathFinder@@QAEPAVCvAStarNode@@HH@Z ENDP ; CvTwoLayerPathFinder::GetPartialMoveNode
_TEXT	ENDS
PUBLIC	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
; Function compile flags: /Odtp
;	COMDAT ?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T225133 = -20						; size = 4
$T225127 = -16						; size = 4
$T225113 = -12						; size = 4
$T225107 = -8						; size = 4
_pNode$ = -4						; size = 4
?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ PROC ; CvTwoLayerPathFinder::GetPathEndTurnPlot, COMDAT
; _this$ = ecx

; 4072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4073 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4074 : 	CvAStarNode* pNode = m_pBest;
; 4075 : #else
; 4076 : 	CvAStarNode* pNode;
; 4077 : 
; 4078 : 	pNode = m_pBest;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[ebp], ecx

; 4079 : #endif
; 4080 : 
; 4081 : 	if(NULL != pNode)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN6@GetPathEnd

; 4082 : 	{
; 4083 : 		if((pNode->m_pParent == NULL) || (pNode->m_iData2 == 1))

	mov	edx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN4@GetPathEnd
	mov	eax, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [eax+16], 1
	jne	SHORT $LN3@GetPathEnd
$LN4@GetPathEnd:

; 4084 : 		{
; 4085 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4086 : 			return pNode->m_pPlot;
; 4087 : #else
; 4088 : 			return GC.getMap().plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225107[ebp], ecx
	mov	edx, DWORD PTR $T225107[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T225113[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [eax+82]
	imul	eax, DWORD PTR $T225113[ebp]
	add	eax, edx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T225107[ebp]
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN7@GetPathEnd
$LN3@GetPathEnd:

; 4089 : #endif
; 4090 : 		}
; 4091 : 
; 4092 : 		while(pNode->m_pParent != NULL)

	mov	edx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN6@GetPathEnd

; 4093 : 		{
; 4094 : 			if(pNode->m_pParent->m_iData2 == 1)

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+16], 1
	jne	SHORT $LN1@GetPathEnd

; 4095 : 			{
; 4096 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4097 : 				return pNode->m_pParent->m_pPlot;
; 4098 : #else
; 4099 : 				return GC.getMap().plotUnchecked(pNode->m_pParent->m_iX, pNode->m_pParent->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225127[ebp], edx
	mov	eax, DWORD PTR $T225127[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225133[ebp], ecx
	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	movsx	eax, WORD PTR [eax+82]
	imul	eax, DWORD PTR $T225133[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T225127[ebp]
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN7@GetPathEnd
$LN1@GetPathEnd:

; 4100 : #endif
; 4101 : 			}
; 4102 : 
; 4103 : 			pNode = pNode->m_pParent;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pNode$[ebp], eax

; 4104 : 		}

	jmp	SHORT $LN3@GetPathEnd
$LN6@GetPathEnd:

; 4105 : 	}
; 4106 : 
; 4107 : 	FAssert(false);
; 4108 : 
; 4109 : 	return NULL;

	xor	eax, eax
$LN7@GetPathEnd:

; 4110 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ENDP ; CvTwoLayerPathFinder::GetPathEndTurnPlot
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0BI@IPFJIOE@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CF8x?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?Calc@FCRC@@QBEKPBXHK@Z:PROC			; FCRC::Calc
EXTRN	?g_CRC32@@3VFCRC@@A:BYTE			; g_CRC32
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0BI@IPFJIOE@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CF8x?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BI@IPFJIOE@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CF8x?$AA@ DB '%'
	DB	'd, %d, %d, %d, %d, %8x', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z$0
__ehfuncinfo$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_pNode$220095 = -56					; size = 4
_uiChecksum$220093 = -52				; size = 4
_strLogString$220092 = -48				; size = 28
__$ArrayPad$ = -20					; size = 4
_bResult$220090 = -13					; size = 1
__$EHRec$ = -12						; size = 12
_pkUnit$ = 8						; size = 4
_iXstart$ = 12						; size = 4
_iYstart$ = 16						; size = 4
_iXdest$ = 20						; size = 4
_iYdest$ = 24						; size = 4
_iInfo$ = 28						; size = 4
_bReuse$ = 32						; size = 1
?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z PROC ; CvTwoLayerPathFinder::GenerateUnitPath, COMDAT
; _this$ = ecx

; 4139 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4140 : 	if (pkUnit)

	cmp	DWORD PTR _pkUnit$[ebp], 0
	je	$LN4@GenerateUn

; 4141 : 	{
; 4142 : 		CvAssert(gDLL->IsGameCoreThread() || !gDLL->IsGameCoreExecuting());
; 4143 : #ifdef AUI_ASTAR_TURN_LIMITER
; 4144 : 		SetData(pkUnit, iTargetTurns);
; 4145 : #else
; 4146 : 		SetData(pkUnit);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN8@GenerateUn
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR _pkUnit$[ebp]
	je	SHORT $LN8@GenerateUn
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+78], 1
$LN8@GenerateUn:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pkUnit$[ebp]
	mov	DWORD PTR [edx+44], eax

; 4147 : #endif
; 4148 : 		bool bResult = GeneratePath(iXstart, iYstart, iXdest, iYdest, iInfo, bReuse);

	movzx	ecx, BYTE PTR _bReuse$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _iYdest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iXdest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iYstart$[ebp]
	push	edx
	mov	eax, DWORD PTR _iXstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bResult$220090[ebp], al

; 4149 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@GenerateUn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	edx, al
	test	edx, edx
	je	$LN3@GenerateUn

; 4150 : 		{
; 4151 : 			CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$220092[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4152 : 			uint uiChecksum = CRC_INIT;

	mov	DWORD PTR _uiChecksum$220093[ebp], -1

; 4153 : 			// Loop through the nodes and make a checksum
; 4154 : 			CvAStarNode* pNode = GetLastNode();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$220095[ebp], ecx
$LN2@GenerateUn:

; 4155 : 
; 4156 : 			// Starting at the end, loop until we find a plot from this owner
; 4157 : 			while(pNode != NULL)

	cmp	DWORD PTR _pNode$220095[ebp], 0
	je	SHORT $LN1@GenerateUn

; 4158 : 			{
; 4159 : 				// Just do the X/Y for now
; 4160 : 				uiChecksum = g_CRC32.Calc( &pNode->m_iX, sizeof( pNode->m_iX ), uiChecksum );

	mov	edx, DWORD PTR _uiChecksum$220093[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _pNode$220095[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	mov	DWORD PTR _uiChecksum$220093[ebp], eax

; 4161 : 				uiChecksum = g_CRC32.Calc( &pNode->m_iY, sizeof( pNode->m_iY ), uiChecksum );

	mov	ecx, DWORD PTR _uiChecksum$220093[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _pNode$220095[ebp]
	add	edx, 82					; 00000052H
	push	edx
	mov	ecx, OFFSET ?g_CRC32@@3VFCRC@@A		; g_CRC32
	call	?Calc@FCRC@@QBEKPBXHK@Z			; FCRC::Calc
	mov	DWORD PTR _uiChecksum$220093[ebp], eax

; 4162 : 		
; 4163 : 				pNode = pNode->m_pParent;

	mov	eax, DWORD PTR _pNode$220095[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pNode$220095[ebp], ecx

; 4164 : 			}

	jmp	SHORT $LN2@GenerateUn
$LN1@GenerateUn:

; 4165 : 
; 4166 : 			strLogString.Format("%d, %d, %d, %d, %d, %8x", iXstart, iYstart, iXdest, iYdest, iInfo, uiChecksum);

	mov	edx, DWORD PTR _uiChecksum$220093[ebp]
	push	edx
	mov	eax, DWORD PTR _iInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iYdest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iXdest$[ebp]
	push	edx
	mov	eax, DWORD PTR _iYstart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iXstart$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BI@IPFJIOE@?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CF8x?$AA@
	lea	edx, DWORD PTR _strLogString$220092[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H

; 4167 : 			LogPathGeneration(pkUnit, strLogString);

	lea	eax, DWORD PTR _strLogString$220092[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkUnit$[ebp]
	push	ecx
	call	?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z ; LogPathGeneration
	add	esp, 8

; 4168 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$220092[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@GenerateUn:

; 4169 : 		return bResult;

	mov	al, BYTE PTR _bResult$220090[ebp]
	jmp	SHORT $LN5@GenerateUn
$LN4@GenerateUn:

; 4170 : 	}
; 4171 : 	return false;

	xor	al, al
$LN5@GenerateUn:

; 4172 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z$0:
	lea	ecx, DWORD PTR _strLogString$220092[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ENDP ; CvTwoLayerPathFinder::GenerateUnitPath
PUBLIC	??_C@_0BH@IIMIGJEF@?$CF03d?0?5?$CFs?0?5UnitID?3?5?$CFd?0?5?$AA@ ; `string'
PUBLIC	??_C@_01OGPIMHDM@?$DP?$AA@			; `string'
PUBLIC	??_C@_0EE@LJNPEBDG@Game?5Turn?0?5Player?0?5Unit?0?5From?5X?0@ ; `string'
PUBLIC	??_C@_0O@DKJGIOB@AStar_APP?4log?$AA@		; `string'
PUBLIC	??_C@_0N@JHKOKGDP@AStar_GC?4log?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
;	COMDAT ??_C@_0BH@IIMIGJEF@?$CF03d?0?5?$CFs?0?5UnitID?3?5?$CFd?0?5?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BH@IIMIGJEF@?$CF03d?0?5?$CFs?0?5UnitID?3?5?$CFd?0?5?$AA@ DB '%03d,'
	DB	' %s, UnitID: %d, ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OGPIMHDM@?$DP?$AA@
CONST	SEGMENT
??_C@_01OGPIMHDM@?$DP?$AA@ DB '?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LJNPEBDG@Game?5Turn?0?5Player?0?5Unit?0?5From?5X?0@
CONST	SEGMENT
??_C@_0EE@LJNPEBDG@Game?5Turn?0?5Player?0?5Unit?0?5From?5X?0@ DB 'Game Tu'
	DB	'rn, Player, Unit, From X, From Y, To X, To Y, Info, Checksum', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DKJGIOB@AStar_APP?4log?$AA@
CONST	SEGMENT
??_C@_0O@DKJGIOB@AStar_APP?4log?$AA@ DB 'AStar_APP.log', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JHKOKGDP@AStar_GC?4log?$AA@
CONST	SEGMENT
??_C@_0N@JHKOKGDP@AStar_GC?4log?$AA@ DB 'AStar_GC.log', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$2
__ehfuncinfo$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
_TEXT	SEGMENT
tv199 = -156						; size = 4
tv149 = -152						; size = 4
tv91 = -148						; size = 4
tv142 = -144						; size = 4
tv136 = -140						; size = 4
$T225224 = -136						; size = 4
$T225220 = -132						; size = 4
$T225216 = -128						; size = 4
$T225212 = -124						; size = 4
$T225203 = -120						; size = 4
$T225196 = -116						; size = 4
$T225176 = -112						; size = 28
_strOutBuf$220068 = -84					; size = 28
_pszPlayerName$220071 = -56				; size = 4
_pLog$220072 = -52					; size = 4
_strBaseString$220069 = -48				; size = 28
__$ArrayPad$ = -20					; size = 4
_kPlayer$220070 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pkUnit$ = 8						; size = 4
_strMsg$ = 12						; size = 4
?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z PROC	; LogPathGeneration, COMDAT

; 4115 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4116 : 	if(GC.getLogging() && GC.getAILogging() && pkUnit)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogPathGen
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogPathGen
	cmp	DWORD PTR _pkUnit$[ebp], 0
	je	$LN2@LogPathGen

; 4117 : 	{
; 4118 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$220068[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4119 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$220069[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 4120 : 
; 4121 : 		CvPlayer& kPlayer = GET_PLAYER(pkUnit->getOwner());

	mov	edx, DWORD PTR _pkUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T225196[ebp], eax
	mov	ecx, DWORD PTR $T225196[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$220070[ebp], ecx

; 4122 : 		const char* pszPlayerName = kPlayer.getCivilizationShortDescription();

	mov	ecx, DWORD PTR _kPlayer$220070[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR _pszPlayerName$220071[ebp], eax

; 4123 : 		FILogFile* pLog = LOGFILEMGR.GetLog((gDLL->IsGameCoreThread())?"AStar_GC.log":"AStar_APP.log", FILogFile::kDontTimeStamp, "Game Turn, Player, Unit, From X, From Y, To X, To Y, Info, Checksum");

	mov	edx, DWORD PTR $T225203[ebp]
	mov	DWORD PTR tv136[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv136[ebp], eax
	mov	ecx, DWORD PTR tv136[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv136[ebp]
	mov	eax, DWORD PTR [edx+928]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@LogPathGen
	mov	DWORD PTR tv142[ebp], OFFSET ??_C@_0N@JHKOKGDP@AStar_GC?4log?$AA@
	jmp	SHORT $LN5@LogPathGen
$LN4@LogPathGen:
	mov	DWORD PTR tv142[ebp], OFFSET ??_C@_0O@DKJGIOB@AStar_APP?4log?$AA@
$LN5@LogPathGen:
	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv91[ebp], eax
	push	OFFSET ??_C@_0EE@LJNPEBDG@Game?5Turn?0?5Player?0?5Unit?0?5From?5X?0@
	push	1
	mov	edx, DWORD PTR tv142[ebp]
	push	edx
	mov	eax, DWORD PTR tv91[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$220072[ebp], eax

; 4124 : 
; 4125 : 		// Get the leading info for this line
; 4126 : 		strBaseString.Format("%03d, %s, UnitID: %d, ", GC.getGame().getElapsedGameTurns(), (pszPlayerName)?pszPlayerName:"?", pkUnit->GetID());

	cmp	DWORD PTR _pszPlayerName$220071[ebp], 0
	je	SHORT $LN6@LogPathGen
	mov	ecx, DWORD PTR _pszPlayerName$220071[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	jmp	SHORT $LN27@LogPathGen
$LN6@LogPathGen:
	mov	DWORD PTR tv149[ebp], OFFSET ??_C@_01OGPIMHDM@?$DP?$AA@
$LN27@LogPathGen:
	mov	edx, DWORD PTR _pkUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T225212[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T225216[ebp], ecx
	mov	edx, DWORD PTR $T225212[ebp]
	push	edx
	mov	eax, DWORD PTR tv149[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225216[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_0BH@IIMIGJEF@?$CF03d?0?5?$CFs?0?5UnitID?3?5?$CFd?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$220069[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 4127 : 		strOutBuf = strBaseString + strMsg;

	mov	edx, DWORD PTR _strMsg$[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$220069[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225176[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv199[ebp], eax
	mov	edx, DWORD PTR tv199[ebp]
	mov	DWORD PTR $T225220[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T225220[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$220068[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T225176[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 4128 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$220068[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T225224[ebp], eax
	mov	eax, DWORD PTR $T225224[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$220072[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$220072[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 4129 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$220069[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$220068[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogPathGen:

; 4130 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$220068[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$220069[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z$2:
	lea	ecx, DWORD PTR $T225176[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPathGeneration@@YAXPBVCvUnit@@AAVCvString@@@Z ENDP	; LogPathGeneration
PUBLIC	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
; Function compile flags: /Odtp
;	COMDAT ?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T225268 = -32						; size = 4
$T225264 = -28						; size = 4
$T225260 = -24						; size = 4
$T225256 = -20						; size = 4
$T225248 = -16						; size = 4
$T225244 = -12						; size = 4
_bPathfinderSuccess$ = -5				; size = 1
_pPathfinderNode$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_pEndPlot$ = 20						; size = 4
?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z PROC ; CvStepPathFinder::GetStepDistanceBetweenPoints, COMDAT
; _this$ = ecx

; 4181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 4182 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4183 : 	CvAStarNode* pPathfinderNode;
; 4184 : #endif
; 4185 : 
; 4186 : 	if(pStartPlot == NULL || pEndPlot == NULL || pStartPlot->getArea() != pEndPlot->getArea())

	cmp	DWORD PTR _pStartPlot$[ebp], 0
	je	SHORT $LN3@GetStepDis
	cmp	DWORD PTR _pEndPlot$[ebp], 0
	je	SHORT $LN3@GetStepDis
	mov	eax, DWORD PTR _pStartPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T225244[ebp], ecx
	mov	edx, DWORD PTR _pEndPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T225248[ebp], eax
	mov	ecx, DWORD PTR $T225244[ebp]
	cmp	ecx, DWORD PTR $T225248[ebp]
	je	SHORT $LN4@GetStepDis
$LN3@GetStepDis:

; 4187 : 	{
; 4188 : 		return -1;

	or	eax, -1
	jmp	$LN5@GetStepDis
$LN4@GetStepDis:

; 4189 : 	}
; 4190 : 
; 4191 : 	SetData(&eEnemy);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+80]
	test	eax, eax
	je	SHORT $LN11@GetStepDis
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR _eEnemy$[ebp]
	cmp	edx, eax
	je	SHORT $LN11@GetStepDis
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+78], 1
$LN11@GetStepDis:
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [edx+44], eax

; 4192 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4193 : 	if (GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), ePlayer, false))
; 4194 : 	{
; 4195 : 		CvAStarNode* pPathfinderNode = GetLastNode();
; 4196 : #else
; 4197 : 	bool bPathfinderSuccess = GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), ePlayer, false);

	mov	ecx, DWORD PTR _pEndPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T225256[ebp], edx
	mov	eax, DWORD PTR _pEndPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T225260[ebp], ecx
	mov	edx, DWORD PTR _pStartPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T225264[ebp], eax
	mov	ecx, DWORD PTR _pStartPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T225268[ebp], edx
	push	0
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225256[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225260[ebp]
	push	edx
	mov	eax, DWORD PTR $T225264[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225268[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bPathfinderSuccess$[ebp], al

; 4198 : 	if(bPathfinderSuccess)

	movzx	edx, BYTE PTR _bPathfinderSuccess$[ebp]
	test	edx, edx
	je	SHORT $LN2@GetStepDis

; 4199 : 	{
; 4200 : 		pPathfinderNode = GetLastNode();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pPathfinderNode$[ebp], ecx

; 4201 : #endif
; 4202 : 
; 4203 : 		if(pPathfinderNode != NULL)

	cmp	DWORD PTR _pPathfinderNode$[ebp], 0
	je	SHORT $LN2@GetStepDis

; 4204 : 		{
; 4205 : 			return pPathfinderNode->m_iData1;

	mov	edx, DWORD PTR _pPathfinderNode$[ebp]
	mov	eax, DWORD PTR [edx+12]
	jmp	SHORT $LN5@GetStepDis
$LN2@GetStepDis:

; 4206 : 		}
; 4207 : 	}
; 4208 : 
; 4209 : 	return -1;

	or	eax, -1
$LN5@GetStepDis:

; 4210 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ENDP ; CvStepPathFinder::GetStepDistanceBetweenPoints
_TEXT	ENDS
PUBLIC	?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::DoesPathExist
; Function compile flags: /Odtp
;	COMDAT ?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T225301 = -24						; size = 4
$T225297 = -20						; size = 4
$T225293 = -16						; size = 4
$T225289 = -12						; size = 4
$T225281 = -8						; size = 4
$T225277 = -4						; size = 4
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_pEndPlot$ = 20						; size = 4
?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z PROC ; CvStepPathFinder::DoesPathExist, COMDAT
; _this$ = ecx

; 4215 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4216 : 	if(pStartPlot == NULL || pEndPlot == NULL || pStartPlot->getArea() != pEndPlot->getArea())

	cmp	DWORD PTR _pStartPlot$[ebp], 0
	je	SHORT $LN1@DoesPathEx
	cmp	DWORD PTR _pEndPlot$[ebp], 0
	je	SHORT $LN1@DoesPathEx
	mov	eax, DWORD PTR _pStartPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T225277[ebp], ecx
	mov	edx, DWORD PTR _pEndPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T225281[ebp], eax
	mov	ecx, DWORD PTR $T225277[ebp]
	cmp	ecx, DWORD PTR $T225281[ebp]
	je	SHORT $LN2@DoesPathEx
$LN1@DoesPathEx:

; 4217 : 	{
; 4218 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@DoesPathEx
$LN2@DoesPathEx:

; 4219 : 	}
; 4220 : 
; 4221 : 	SetData(&eEnemy);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+80]
	test	eax, eax
	je	SHORT $LN9@DoesPathEx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR _eEnemy$[ebp]
	cmp	edx, eax
	je	SHORT $LN9@DoesPathEx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+78], 1
$LN9@DoesPathEx:
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR _eEnemy$[ebp]
	mov	DWORD PTR [edx+44], eax

; 4222 : 	return GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), ePlayer, false);

	mov	ecx, DWORD PTR _pEndPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T225289[ebp], edx
	mov	eax, DWORD PTR _pEndPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T225293[ebp], ecx
	mov	edx, DWORD PTR _pStartPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T225297[ebp], eax
	mov	ecx, DWORD PTR _pStartPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T225301[ebp], edx
	push	0
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225289[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225293[ebp]
	push	edx
	mov	eax, DWORD PTR $T225297[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225301[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
$LN3@DoesPathEx:

; 4223 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DoesPathExist@CvStepPathFinder@@QAE_NW4PlayerTypes@@0PAVCvPlot@@1@Z ENDP ; CvStepPathFinder::DoesPathExist
_TEXT	ENDS
PUBLIC	?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z ; CvStepPathFinder::GetLastOwnedPlot
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
; Function compile flags: /Odtp
;	COMDAT ?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T225316 = -24						; size = 4
$T225307 = -20						; size = 4
_currentPlot$220136 = -16				; size = 4
_kMap$220132 = -12					; size = 4
_iNumSteps$ = -8					; size = 4
_pNode$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_pEndPlot$ = 20						; size = 4
?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z PROC ; CvStepPathFinder::GetLastOwnedPlot, COMDAT
; _this$ = ecx

; 4228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4229 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4230 : 	if (GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot) != -1)
; 4231 : #else
; 4232 : 	CvAStarNode* pNode;
; 4233 : 	int iNumSteps;
; 4234 : 
; 4235 : 	// Generate step path
; 4236 : 	iNumSteps = GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot);

	mov	eax, DWORD PTR _pEndPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStartPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eEnemy$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	DWORD PTR _iNumSteps$[ebp], eax

; 4237 : 	if(iNumSteps != -1)

	cmp	DWORD PTR _iNumSteps$[ebp], -1
	je	SHORT $LN4@GetLastOwn

; 4238 : #endif
; 4239 : 	{
; 4240 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4241 : 		CvAStarNode* pNode = GetLastNode();
; 4242 : #else
; 4243 : 		pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T225307[ebp], eax
	mov	ecx, DWORD PTR $T225307[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$[ebp], edx

; 4244 : #endif
; 4245 : 
; 4246 : 		// Starting at the end, loop until we find a plot from this owner
; 4247 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4248 : 		CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$220132[ebp], eax
$LN3@GetLastOwn:

; 4249 : #endif
; 4250 : 		while(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN4@GetLastOwn

; 4251 : 		{
; 4252 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4253 : 			CvPlot* currentPlot = pNode->m_pPlot;
; 4254 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4255 : 			CvPlot* currentPlot;
; 4256 : 			currentPlot = pNode->m_pPlot;
; 4257 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4258 : 			CvPlot* currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);
; 4259 : #else
; 4260 : 			CvPlot* currentPlot;
; 4261 : 			currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	ecx, DWORD PTR _kMap$220132[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T225316[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T225316[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$220132[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _currentPlot$220136[ebp], eax

; 4262 : #endif
; 4263 : 
; 4264 : 			// Check and see if this plot has the right owner
; 4265 : 			if(currentPlot->getOwner() == ePlayer)

	mov	edx, DWORD PTR _currentPlot$220136[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN1@GetLastOwn

; 4266 : 			{
; 4267 : 				return currentPlot;

	mov	eax, DWORD PTR _currentPlot$220136[ebp]
	jmp	SHORT $LN5@GetLastOwn
$LN1@GetLastOwn:

; 4268 : 			}
; 4269 : 
; 4270 : 			// Move to the previous plot on the path
; 4271 : 			pNode = pNode->m_pParent;

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _pNode$[ebp], edx

; 4272 : 		}

	jmp	SHORT $LN3@GetLastOwn
$LN4@GetLastOwn:

; 4273 : 	}
; 4274 : 
; 4275 : 	return NULL;

	xor	eax, eax
$LN5@GetLastOwn:

; 4276 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z ENDP ; CvStepPathFinder::GetLastOwnedPlot
_TEXT	ENDS
PUBLIC	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
; Function compile flags: /Odtp
;	COMDAT ?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z
_TEXT	SEGMENT
tv153 = -52						; size = 4
_this$ = -48						; size = 4
$T225372 = -44						; size = 4
$T225353 = -40						; size = 4
$T225344 = -36						; size = 4
$T225337 = -32						; size = 4
_i$220160 = -28						; size = 4
_i$220153 = -24						; size = 4
_kMap$220158 = -20					; size = 4
_iNumSteps$ = -16					; size = 4
_iPathLen$ = -12					; size = 4
_pNode$ = -8						; size = 4
_currentPlot$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
_eEnemy$ = 12						; size = 4
_pStartPlot$ = 16					; size = 4
_pEndPlot$ = 20						; size = 4
_iPlotsFromEnd$ = 24					; size = 4
_bLeaveEnemyTerritory$ = 28				; size = 1
?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z PROC ; CvStepPathFinder::GetXPlotsFromEnd, COMDAT
; _this$ = ecx

; 4281 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 4282 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4283 : 	CvAStarNode* pNode;
; 4284 : #endif
; 4285 : 	CvPlot* currentPlot = NULL;

	mov	DWORD PTR _currentPlot$[ebp], 0

; 4286 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4287 : 	// Generate step path
; 4288 : 	int iPathLen = GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot);
; 4289 : 	int iNumSteps = MIN(iPlotsFromEnd, iPathLen);
; 4290 : #else
; 4291 : 	int iNumSteps;
; 4292 : 	int iPathLen;
; 4293 : 
; 4294 : 	// Generate step path
; 4295 : 	iPathLen = GC.getStepFinder().GetStepDistanceBetweenPoints(ePlayer, eEnemy, pStartPlot, pEndPlot);

	mov	eax, DWORD PTR _pEndPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStartPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eEnemy$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	DWORD PTR _iPathLen$[ebp], eax

; 4296 : 	iNumSteps = ::min(iPlotsFromEnd, iPathLen);

	mov	ecx, DWORD PTR _iPathLen$[ebp]
	cmp	ecx, DWORD PTR _iPlotsFromEnd$[ebp]
	jge	SHORT $LN17@GetXPlotsF
	lea	edx, DWORD PTR _iPathLen$[ebp]
	mov	DWORD PTR tv153[ebp], edx
	jmp	SHORT $LN18@GetXPlotsF
$LN17@GetXPlotsF:
	lea	eax, DWORD PTR _iPlotsFromEnd$[ebp]
	mov	DWORD PTR tv153[ebp], eax
$LN18@GetXPlotsF:
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR $T225337[ebp], ecx
	mov	edx, DWORD PTR $T225337[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iNumSteps$[ebp], eax

; 4297 : #endif
; 4298 : 
; 4299 : 	if(iNumSteps != -1)

	cmp	DWORD PTR _iNumSteps$[ebp], -1
	je	$LN12@GetXPlotsF

; 4300 : 	{
; 4301 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4302 : 		CvAStarNode* pNode = GetLastNode();
; 4303 : #else
; 4304 : 		pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T225344[ebp], eax
	mov	ecx, DWORD PTR $T225344[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$[ebp], edx

; 4305 : #endif
; 4306 : 
; 4307 : 		if(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN12@GetXPlotsF

; 4308 : 		{
; 4309 : 			// Starting at the end, loop the correct number of times back
; 4310 : 			for(int i = 0; i < iNumSteps; i++)

	mov	DWORD PTR _i$220153[ebp], 0
	jmp	SHORT $LN10@GetXPlotsF
$LN9@GetXPlotsF:
	mov	eax, DWORD PTR _i$220153[ebp]
	add	eax, 1
	mov	DWORD PTR _i$220153[ebp], eax
$LN10@GetXPlotsF:
	mov	ecx, DWORD PTR _i$220153[ebp]
	cmp	ecx, DWORD PTR _iNumSteps$[ebp]
	jge	SHORT $LN8@GetXPlotsF

; 4311 : 			{
; 4312 : 				if(pNode->m_pParent != NULL)

	mov	edx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN7@GetXPlotsF

; 4313 : 				{
; 4314 : 					// Move to the previous plot on the path
; 4315 : 					pNode = pNode->m_pParent;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pNode$[ebp], ecx
$LN7@GetXPlotsF:

; 4316 : 				}
; 4317 : 			}

	jmp	SHORT $LN9@GetXPlotsF
$LN8@GetXPlotsF:

; 4318 : 
; 4319 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4320 : 			currentPlot = pNode->m_pPlot;
; 4321 : #else
; 4322 : 			CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$220158[ebp], edx

; 4323 : 			currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	eax, DWORD PTR _kMap$220158[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225353[ebp], ecx
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _pNode$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T225353[ebp]
	add	edx, eax
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$220158[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _currentPlot$[ebp], edx

; 4324 : #endif
; 4325 : 
; 4326 : 			// Was an enemy specified and we don't want this plot to be in enemy territory?
; 4327 : 			if (eEnemy != NO_PLAYER && bLeaveEnemyTerritory)

	cmp	DWORD PTR _eEnemy$[ebp], -1
	je	SHORT $LN12@GetXPlotsF
	movzx	ecx, BYTE PTR _bLeaveEnemyTerritory$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@GetXPlotsF

; 4328 : 			{
; 4329 : 				// Loop until we leave enemy territory
; 4330 : 				for (int i = 0; i < (iPathLen - iNumSteps) && currentPlot->getOwner() == eEnemy; i++)

	mov	DWORD PTR _i$220160[ebp], 0
	jmp	SHORT $LN5@GetXPlotsF
$LN4@GetXPlotsF:
	mov	edx, DWORD PTR _i$220160[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220160[ebp], edx
$LN5@GetXPlotsF:
	mov	eax, DWORD PTR _iPathLen$[ebp]
	sub	eax, DWORD PTR _iNumSteps$[ebp]
	cmp	DWORD PTR _i$220160[ebp], eax
	jge	SHORT $LN12@GetXPlotsF
	mov	ecx, DWORD PTR _currentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, DWORD PTR _eEnemy$[ebp]
	jne	SHORT $LN12@GetXPlotsF

; 4331 : 				{
; 4332 : 					if (pNode->m_pParent != NULL)

	mov	eax, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN2@GetXPlotsF

; 4333 : 					{
; 4334 : 						// Move to the previous plot on the path
; 4335 : 						pNode = pNode->m_pParent;

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _pNode$[ebp], edx

; 4336 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4337 : 						currentPlot = pNode->m_pPlot;
; 4338 : #else
; 4339 : 						currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	eax, DWORD PTR _kMap$220158[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225372[ebp], ecx
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _pNode$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T225372[ebp]
	add	edx, eax
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$220158[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _currentPlot$[ebp], edx

; 4340 : #endif
; 4341 : 					}
; 4342 : 					else

	jmp	SHORT $LN1@GetXPlotsF
$LN2@GetXPlotsF:

; 4343 : 					{
; 4344 : 						break;

	jmp	SHORT $LN12@GetXPlotsF
$LN1@GetXPlotsF:

; 4345 : 					}
; 4346 : 				}

	jmp	SHORT $LN4@GetXPlotsF
$LN12@GetXPlotsF:

; 4347 : 			}
; 4348 : 		}
; 4349 : 	}
; 4350 : 
; 4351 : 	return currentPlot;

	mov	eax, DWORD PTR _currentPlot$[ebp]

; 4352 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ENDP ; CvStepPathFinder::GetXPlotsFromEnd
_TEXT	ENDS
PUBLIC	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
; Function compile flags: /Odtp
;	COMDAT ?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T225404 = -16						; size = 4
$T225400 = -12						; size = 4
$T225396 = -8						; size = 4
$T225392 = -4						; size = 4
_unit$ = 8						; size = 4
_pStartPlot$ = 12					; size = 4
_pEndPlot$ = 16						; size = 4
?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z PROC ; CvIgnoreUnitsPathFinder::DoesPathExist, COMDAT
; _this$ = ecx

; 4365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4366 : 	m_pCurNode = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+628], 0

; 4367 : 
; 4368 : 	if(pStartPlot == NULL || pEndPlot == NULL)

	cmp	DWORD PTR _pStartPlot$[ebp], 0
	je	SHORT $LN1@DoesPathEx@2
	cmp	DWORD PTR _pEndPlot$[ebp], 0
	jne	SHORT $LN2@DoesPathEx@2
$LN1@DoesPathEx@2:

; 4369 : 	{
; 4370 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@DoesPathEx@2
$LN2@DoesPathEx@2:

; 4371 : 	}
; 4372 : 
; 4373 : #if defined(AUI_ASTAR_TURN_LIMITER) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4374 : 	SetData(pUnit, iMaxTurns);
; 4375 : #elif defined(AUI_ASTAR_TURN_LIMITER)
; 4376 : 	SetData(&unit, iMaxTurns);
; 4377 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4378 : 	SetData(pUnit);
; 4379 : #else
; 4380 : 	SetData(&unit);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+80]
	test	edx, edx
	je	SHORT $LN5@DoesPathEx@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	cmp	ecx, DWORD PTR _unit$[ebp]
	je	SHORT $LN5@DoesPathEx@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+78], 1
$LN5@DoesPathEx@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 4381 : #endif
; 4382 : 	return GeneratePath(pStartPlot->getX(), pStartPlot->getY(), pEndPlot->getX(), pEndPlot->getY(), 0, true /*bReuse*/);

	mov	edx, DWORD PTR _pEndPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T225392[ebp], eax
	mov	ecx, DWORD PTR _pEndPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T225396[ebp], edx
	mov	eax, DWORD PTR _pStartPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T225400[ebp], ecx
	mov	edx, DWORD PTR _pStartPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T225404[ebp], eax
	push	1
	push	0
	mov	ecx, DWORD PTR $T225392[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225396[ebp]
	push	edx
	mov	eax, DWORD PTR $T225400[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225404[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
$LN3@DoesPathEx@2:

; 4383 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ENDP ; CvIgnoreUnitsPathFinder::DoesPathExist
_TEXT	ENDS
PUBLIC	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ	; CvIgnoreUnitsPathFinder::GetPathLength
; Function compile flags: /Odtp
;	COMDAT ?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iPathDistance$ = -8					; size = 4
_pNode$ = -4						; size = 4
?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ PROC	; CvIgnoreUnitsPathFinder::GetPathLength, COMDAT
; _this$ = ecx

; 4392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4393 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4394 : 	CvAStarNode* pNode = GetLastNode();
; 4395 : 	if (pNode != NULL)
; 4396 : 	{
; 4397 : 		return pNode->m_iData2;
; 4398 : 	}
; 4399 : 
; 4400 : 	return MAX_INT;
; 4401 : #else
; 4402 : 	int iPathDistance = MAX_INT;

	mov	DWORD PTR _iPathDistance$[ebp], 2147483647 ; 7fffffffH

; 4403 : 
; 4404 : 	CvAStarNode* pNode = GetLastNode();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[ebp], ecx

; 4405 : 	if(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN1@GetPathLen

; 4406 : 	{
; 4407 : 		iPathDistance = pNode->m_iData2;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iPathDistance$[ebp], eax
$LN1@GetPathLen:

; 4408 : 	}
; 4409 : 
; 4410 : 	return iPathDistance;

	mov	eax, DWORD PTR _iPathDistance$[ebp]

; 4411 : #endif
; 4412 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ ENDP	; CvIgnoreUnitsPathFinder::GetPathLength
_TEXT	ENDS
PUBLIC	?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z ; CvIgnoreUnitsPathFinder::GetLastOwnedPlot
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
; Function compile flags: /Odtp
;	COMDAT ?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T225440 = -36						; size = 4
$T225431 = -32						; size = 4
$T225427 = -28						; size = 4
$T225423 = -24						; size = 4
$T225419 = -20						; size = 4
$T225415 = -16						; size = 4
_currentPlot$220192 = -12				; size = 4
_kMap$220188 = -8					; size = 4
_pNode$ = -4						; size = 4
_pStartPlot$ = 8					; size = 4
_pEndPlot$ = 12						; size = 4
_iOwner$ = 16						; size = 4
?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z PROC ; CvIgnoreUnitsPathFinder::GetLastOwnedPlot, COMDAT
; _this$ = ecx

; 4417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 4418 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4419 : 	// Generate path
; 4420 : 	if (GC.getIgnoreUnitsPathFinder().GeneratePath(pStartPlot->getX(), pStartPlot->getX(), pEndPlot->getX(), pEndPlot->getX(), 0, false))
; 4421 : 	{
; 4422 : 		CvAStarNode* pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();
; 4423 : #else
; 4424 : 	CvAStarNode* pNode;
; 4425 : 
; 4426 : 	// Generate path
; 4427 : 	if(GC.getIgnoreUnitsPathFinder().GeneratePath(pStartPlot->getX(), pStartPlot->getX(), pEndPlot->getX(), pEndPlot->getX(), 0, false))

	mov	eax, DWORD PTR _pEndPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T225415[ebp], ecx
	mov	edx, DWORD PTR _pEndPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T225419[ebp], eax
	mov	ecx, DWORD PTR _pStartPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T225423[ebp], edx
	mov	eax, DWORD PTR _pStartPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T225427[ebp], ecx
	push	0
	push	0
	mov	edx, DWORD PTR $T225415[ebp]
	push	edx
	mov	eax, DWORD PTR $T225419[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225423[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225427[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetLastOwn@2

; 4428 : 	{
; 4429 : 		pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T225431[ebp], eax
	mov	ecx, DWORD PTR $T225431[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$[ebp], edx

; 4430 : #endif
; 4431 : 
; 4432 : 		// Starting at the end, loop until we find a plot from this owner
; 4433 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4434 : 		CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$220188[ebp], eax
$LN3@GetLastOwn@2:

; 4435 : #endif
; 4436 : 		while(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN4@GetLastOwn@2

; 4437 : 		{
; 4438 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4439 : 			CvPlot* currentPlot = pNode->m_pPlot;
; 4440 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4441 : 			CvPlot* currentPlot;
; 4442 : 			currentPlot = pNode->m_pPlot;
; 4443 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4444 : 			CvPlot* currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);
; 4445 : #else
; 4446 : 			CvPlot* currentPlot;
; 4447 : 			currentPlot = kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	ecx, DWORD PTR _kMap$220188[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T225440[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T225440[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$220188[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _currentPlot$220192[ebp], eax

; 4448 : #endif
; 4449 : 
; 4450 : 			// Check and see if this plot has the right owner
; 4451 : 			if(currentPlot->getOwner() == iOwner)

	mov	edx, DWORD PTR _currentPlot$220192[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, DWORD PTR _iOwner$[ebp]
	jne	SHORT $LN1@GetLastOwn@2

; 4452 : 			{
; 4453 : 				return currentPlot;

	mov	eax, DWORD PTR _currentPlot$220192[ebp]
	jmp	SHORT $LN5@GetLastOwn@2
$LN1@GetLastOwn@2:

; 4454 : 			}
; 4455 : 
; 4456 : 			// Move to the previous plot on the path
; 4457 : 			pNode = pNode->m_pParent;

	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _pNode$[ebp], edx

; 4458 : 		}

	jmp	SHORT $LN3@GetLastOwn@2
$LN4@GetLastOwn@2:

; 4459 : 	}
; 4460 : 
; 4461 : 	return NULL;

	xor	eax, eax
$LN5@GetLastOwn@2:

; 4462 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetLastOwnedPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@PAV2@0W4PlayerTypes@@@Z ENDP ; CvIgnoreUnitsPathFinder::GetLastOwnedPlot
_TEXT	ENDS
PUBLIC	?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetPathFirstPlot
; Function compile flags: /Odtp
;	COMDAT ?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T225484 = -20						; size = 4
$T225468 = -16						; size = 4
$T225459 = -12						; size = 4
_kMap$ = -8						; size = 4
_pNode$ = -4						; size = 4
?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetPathFirstPlot, COMDAT
; _this$ = ecx

; 4467 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4468 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4469 : 	CvAStarNode* pNode = GetLastNode();
; 4470 : #else
; 4471 : 	CvAStarNode* pNode;
; 4472 : 
; 4473 : 	pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T225459[ebp], eax
	mov	eax, DWORD PTR $T225459[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[ebp], ecx

; 4474 : #endif
; 4475 : 
; 4476 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4477 : 	CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], edx

; 4478 : #endif
; 4479 : 	if(pNode->m_pParent == NULL)

	mov	eax, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@GetPathFir

; 4480 : 	{
; 4481 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4482 : 		return pNode->m_pPlot;
; 4483 : #else
; 4484 : 		return kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T225468[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T225468[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN5@GetPathFir
$LN3@GetPathFir:

; 4485 : #endif
; 4486 : 	}
; 4487 : 
; 4488 : 	while(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN2@GetPathFir

; 4489 : 	{
; 4490 : 		if(pNode->m_pParent->m_pParent == NULL)

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN1@GetPathFir

; 4491 : 		{
; 4492 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4493 : 			return pNode->m_pPlot;
; 4494 : #else
; 4495 : 			return kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T225484[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T225484[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN5@GetPathFir
$LN1@GetPathFir:

; 4496 : #endif
; 4497 : 		}
; 4498 : 
; 4499 : 		pNode = pNode->m_pParent;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pNode$[ebp], eax

; 4500 : 	}

	jmp	SHORT $LN3@GetPathFir
$LN2@GetPathFir:

; 4501 : 
; 4502 : 	FAssert(false);
; 4503 : 
; 4504 : 	return NULL;

	xor	eax, eax
$LN5@GetPathFir:

; 4505 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPathFirstPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetPathFirstPlot
_TEXT	ENDS
PUBLIC	?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetPathEndTurnPlot
; Function compile flags: /Odtp
;	COMDAT ?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T225525 = -20						; size = 4
$T225509 = -16						; size = 4
$T225500 = -12						; size = 4
_kMap$220209 = -8					; size = 4
_pNode$ = -4						; size = 4
?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetPathEndTurnPlot, COMDAT
; _this$ = ecx

; 4510 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4511 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4512 : 	CvAStarNode* pNode = GetLastNode();
; 4513 : #else
; 4514 : 	CvAStarNode* pNode;
; 4515 : 
; 4516 : 	pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T225500[ebp], eax
	mov	eax, DWORD PTR $T225500[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[ebp], ecx

; 4517 : #endif
; 4518 : 
; 4519 : 	if(NULL != pNode)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN6@GetPathEnd@2

; 4520 : 	{
; 4521 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4522 : 		CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$220209[ebp], edx

; 4523 : #endif
; 4524 : 		if((pNode->m_pParent == NULL) || (pNode->m_iData2 == 1))

	mov	eax, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN4@GetPathEnd@2
	mov	ecx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [ecx+16], 1
	jne	SHORT $LN3@GetPathEnd@2
$LN4@GetPathEnd@2:

; 4525 : 		{
; 4526 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4527 : 			return pNode->m_pPlot;
; 4528 : #else
; 4529 : 			return kMap.plotUnchecked(pNode->m_iX, pNode->m_iY);

	mov	edx, DWORD PTR _kMap$220209[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T225509[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [eax+82]
	imul	eax, DWORD PTR $T225509[ebp]
	add	eax, edx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$220209[ebp]
	add	eax, DWORD PTR [ecx+4068]
	jmp	SHORT $LN7@GetPathEnd@2
$LN3@GetPathEnd@2:

; 4530 : #endif
; 4531 : 		}
; 4532 : 
; 4533 : 		while(pNode->m_pParent != NULL)

	mov	edx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN6@GetPathEnd@2

; 4534 : 		{
; 4535 : 			if(pNode->m_pParent->m_iData2 == 1)

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+16], 1
	jne	SHORT $LN1@GetPathEnd@2

; 4536 : 			{
; 4537 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4538 : 				return pNode->m_pParent->m_pPlot;
; 4539 : #else
; 4540 : 				return kMap.plotUnchecked(pNode->m_pParent->m_iX, pNode->m_pParent->m_iY);

	mov	edx, DWORD PTR _kMap$220209[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T225525[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _pNode$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movsx	ecx, WORD PTR [edx+82]
	imul	ecx, DWORD PTR $T225525[ebp]
	add	ecx, eax
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$220209[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	eax, ecx
	jmp	SHORT $LN7@GetPathEnd@2
$LN1@GetPathEnd@2:

; 4541 : #endif
; 4542 : 			}
; 4543 : 
; 4544 : 			pNode = pNode->m_pParent;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pNode$[ebp], ecx

; 4545 : 		}

	jmp	SHORT $LN3@GetPathEnd@2
$LN6@GetPathEnd@2:

; 4546 : 	}
; 4547 : 
; 4548 : 	FAssert(false);
; 4549 : 
; 4550 : 	return NULL;

	xor	eax, eax
$LN7@GetPathEnd@2:

; 4551 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPathEndTurnPlot@CvIgnoreUnitsPathFinder@@QBEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetPathEndTurnPlot
_TEXT	ENDS
PUBLIC	?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetLastPlot
; Function compile flags: /Odtp
;	COMDAT ?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ
_TEXT	SEGMENT
tv145 = -72						; size = 4
tv160 = -68						; size = 4
_this$ = -64						; size = 4
$T225648 = -60						; size = 4
$T225647 = -56						; size = 4
$T225602 = -52						; size = 4
$T225589 = -48						; size = 4
$T225585 = -44						; size = 4
$T225571 = -40						; size = 4
$T225567 = -33						; size = 1
$T225556 = -32						; size = 4
$T225552 = -25						; size = 1
_iMapY$225646 = -24					; size = 4
_iMapX$225645 = -20					; size = 4
$T225545 = -16						; size = 4
$T225541 = -12						; size = 4
_pPlot$ = -8						; size = 4
_pNode$ = -4						; size = 4
?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetLastPlot, COMDAT
; _this$ = ecx

; 4556 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 4557 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4558 : 	CvAStarNode* pNode = GetLastNode();
; 4559 : 	if (pNode != NULL)
; 4560 : 	{
; 4561 : 		// Save off node for future calls to GetPreviousPlot()
; 4562 : 		m_pCurNode = pNode;
; 4563 : 
; 4564 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4565 : 		return pNode->m_pPlot;
; 4566 : #else
; 4567 : 		return GC.getMap().plot(pNode->m_iX, pNode->m_iY);
; 4568 : #endif
; 4569 : 	}
; 4570 : 
; 4571 : 	return NULL;
; 4572 : #else
; 4573 : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 4574 : 
; 4575 : 	CvAStarNode* pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T225541[ebp], eax
	mov	eax, DWORD PTR $T225541[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[ebp], ecx

; 4576 : 	if(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN1@GetLastPlo

; 4577 : 	{
; 4578 : 		pPlot = GC.getMap().plot(pNode->m_iX, pNode->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225545[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR $T225648[ebp], ecx
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR $T225647[ebp], eax
	cmp	DWORD PTR $T225647[ebp], -2147483647	; 80000001H
	je	SHORT $LN8@GetLastPlo
	cmp	DWORD PTR $T225648[ebp], -2147483647	; 80000001H
	jne	SHORT $LN9@GetLastPlo
$LN8@GetLastPlo:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN10@GetLastPlo
$LN9@GetLastPlo:
	mov	ecx, DWORD PTR $T225545[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T225552[ebp], dl
	mov	eax, DWORD PTR $T225545[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225556[ebp], ecx
	movzx	edx, BYTE PTR $T225552[ebp]
	test	edx, edx
	je	SHORT $LN21@GetLastPlo
	cmp	DWORD PTR $T225647[ebp], 0
	jge	SHORT $LN20@GetLastPlo
	mov	eax, DWORD PTR $T225647[ebp]
	cdq
	idiv	DWORD PTR $T225556[ebp]
	add	edx, DWORD PTR $T225556[ebp]
	mov	DWORD PTR _iMapX$225645[ebp], edx
	jmp	SHORT $LN22@GetLastPlo
	jmp	SHORT $LN21@GetLastPlo
$LN20@GetLastPlo:
	mov	eax, DWORD PTR $T225647[ebp]
	cmp	eax, DWORD PTR $T225556[ebp]
	jl	SHORT $LN21@GetLastPlo
	mov	eax, DWORD PTR $T225647[ebp]
	cdq
	idiv	DWORD PTR $T225556[ebp]
	mov	DWORD PTR _iMapX$225645[ebp], edx
	jmp	SHORT $LN22@GetLastPlo
$LN21@GetLastPlo:
	mov	ecx, DWORD PTR $T225647[ebp]
	mov	DWORD PTR _iMapX$225645[ebp], ecx
$LN22@GetLastPlo:
	mov	edx, DWORD PTR $T225545[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T225567[ebp], al
	mov	ecx, DWORD PTR $T225545[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T225571[ebp], edx
	movzx	eax, BYTE PTR $T225567[ebp]
	test	eax, eax
	je	SHORT $LN31@GetLastPlo
	cmp	DWORD PTR $T225648[ebp], 0
	jge	SHORT $LN30@GetLastPlo
	mov	eax, DWORD PTR $T225648[ebp]
	cdq
	idiv	DWORD PTR $T225571[ebp]
	add	edx, DWORD PTR $T225571[ebp]
	mov	DWORD PTR _iMapY$225646[ebp], edx
	jmp	SHORT $LN32@GetLastPlo
	jmp	SHORT $LN31@GetLastPlo
$LN30@GetLastPlo:
	mov	ecx, DWORD PTR $T225648[ebp]
	cmp	ecx, DWORD PTR $T225571[ebp]
	jl	SHORT $LN31@GetLastPlo
	mov	eax, DWORD PTR $T225648[ebp]
	cdq
	idiv	DWORD PTR $T225571[ebp]
	mov	DWORD PTR _iMapY$225646[ebp], edx
	jmp	SHORT $LN32@GetLastPlo
$LN31@GetLastPlo:
	mov	edx, DWORD PTR $T225648[ebp]
	mov	DWORD PTR _iMapY$225646[ebp], edx
$LN32@GetLastPlo:
	cmp	DWORD PTR _iMapX$225645[ebp], 0
	jl	SHORT $LN36@GetLastPlo
	mov	eax, DWORD PTR $T225545[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225585[ebp], ecx
	mov	edx, DWORD PTR _iMapX$225645[ebp]
	cmp	edx, DWORD PTR $T225585[ebp]
	jge	SHORT $LN36@GetLastPlo
	cmp	DWORD PTR _iMapY$225646[ebp], 0
	jl	SHORT $LN36@GetLastPlo
	mov	eax, DWORD PTR $T225545[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T225589[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225646[ebp]
	cmp	edx, DWORD PTR $T225589[ebp]
	jge	SHORT $LN36@GetLastPlo
	mov	DWORD PTR tv160[ebp], 1
	jmp	SHORT $LN34@GetLastPlo
$LN36@GetLastPlo:
	mov	DWORD PTR tv160[ebp], 0
$LN34@GetLastPlo:
	cmp	DWORD PTR tv160[ebp], 0
	je	SHORT $LN12@GetLastPlo
	mov	eax, DWORD PTR $T225545[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225602[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225646[ebp]
	imul	edx, DWORD PTR $T225602[ebp]
	add	edx, DWORD PTR _iMapX$225645[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T225545[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv145[ebp], edx
	jmp	SHORT $LN13@GetLastPlo
$LN12@GetLastPlo:
	mov	DWORD PTR tv145[ebp], 0
$LN13@GetLastPlo:
	mov	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx
$LN10@GetLastPlo:

; 4579 : 
; 4580 : 		// Save off node for future calls to GetPreviousPlot()
; 4581 : 		m_pCurNode = pNode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pNode$[ebp]
	mov	DWORD PTR [edx+628], eax
$LN1@GetLastPlo:

; 4582 : 	}
; 4583 : 
; 4584 : 	return pPlot;

	mov	eax, DWORD PTR _pPlot$[ebp]

; 4585 : #endif
; 4586 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetLastPlot
_TEXT	ENDS
PUBLIC	?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ; CvIgnoreUnitsPathFinder::GetPreviousPlot
; Function compile flags: /Odtp
;	COMDAT ?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ
_TEXT	SEGMENT
tv145 = -64						; size = 4
tv160 = -60						; size = 4
_this$ = -56						; size = 4
$T225757 = -52						; size = 4
$T225756 = -48						; size = 4
$T225711 = -44						; size = 4
$T225698 = -40						; size = 4
$T225694 = -36						; size = 4
$T225680 = -32						; size = 4
$T225676 = -25						; size = 1
$T225665 = -24						; size = 4
$T225661 = -17						; size = 1
_iMapY$225755 = -16					; size = 4
_iMapX$225754 = -12					; size = 4
$T225654 = -8						; size = 4
_pPlot$ = -4						; size = 4
?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ PROC ; CvIgnoreUnitsPathFinder::GetPreviousPlot, COMDAT
; _this$ = ecx

; 4591 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 4592 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4593 : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 4594 : #endif
; 4595 : 
; 4596 : 	if(m_pCurNode != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+628], 0
	je	$LN2@GetPreviou

; 4597 : 	{
; 4598 : 		m_pCurNode = m_pCurNode->m_pParent;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR [eax+628], ecx

; 4599 : 
; 4600 : 		if(m_pCurNode != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+628], 0
	je	$LN2@GetPreviou

; 4601 : 		{
; 4602 : #if defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES) && defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4603 : 			return m_pCurNode->m_pPlot;
; 4604 : #elif defined(AUI_ASTAR_CACHE_PLOTS_AT_NODES)
; 4605 : 			pPlot = m_pCurNode->m_pPlot;
; 4606 : #elif defined(AUI_ASTAR_MINOR_OPTIMIZATION)
; 4607 : 			return GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);
; 4608 : #else
; 4609 : 			pPlot = GC.getMap().plot(m_pCurNode->m_iX, m_pCurNode->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225654[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	movsx	eax, WORD PTR [edx+82]
	mov	DWORD PTR $T225757[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR $T225756[ebp], eax
	cmp	DWORD PTR $T225756[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@GetPreviou
	cmp	DWORD PTR $T225757[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@GetPreviou
$LN7@GetPreviou:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN2@GetPreviou
$LN8@GetPreviou:
	mov	ecx, DWORD PTR $T225654[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T225661[ebp], dl
	mov	eax, DWORD PTR $T225654[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225665[ebp], ecx
	movzx	edx, BYTE PTR $T225661[ebp]
	test	edx, edx
	je	SHORT $LN20@GetPreviou
	cmp	DWORD PTR $T225756[ebp], 0
	jge	SHORT $LN19@GetPreviou
	mov	eax, DWORD PTR $T225756[ebp]
	cdq
	idiv	DWORD PTR $T225665[ebp]
	add	edx, DWORD PTR $T225665[ebp]
	mov	DWORD PTR _iMapX$225754[ebp], edx
	jmp	SHORT $LN21@GetPreviou
	jmp	SHORT $LN20@GetPreviou
$LN19@GetPreviou:
	mov	eax, DWORD PTR $T225756[ebp]
	cmp	eax, DWORD PTR $T225665[ebp]
	jl	SHORT $LN20@GetPreviou
	mov	eax, DWORD PTR $T225756[ebp]
	cdq
	idiv	DWORD PTR $T225665[ebp]
	mov	DWORD PTR _iMapX$225754[ebp], edx
	jmp	SHORT $LN21@GetPreviou
$LN20@GetPreviou:
	mov	ecx, DWORD PTR $T225756[ebp]
	mov	DWORD PTR _iMapX$225754[ebp], ecx
$LN21@GetPreviou:
	mov	edx, DWORD PTR $T225654[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T225676[ebp], al
	mov	ecx, DWORD PTR $T225654[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T225680[ebp], edx
	movzx	eax, BYTE PTR $T225676[ebp]
	test	eax, eax
	je	SHORT $LN30@GetPreviou
	cmp	DWORD PTR $T225757[ebp], 0
	jge	SHORT $LN29@GetPreviou
	mov	eax, DWORD PTR $T225757[ebp]
	cdq
	idiv	DWORD PTR $T225680[ebp]
	add	edx, DWORD PTR $T225680[ebp]
	mov	DWORD PTR _iMapY$225755[ebp], edx
	jmp	SHORT $LN31@GetPreviou
	jmp	SHORT $LN30@GetPreviou
$LN29@GetPreviou:
	mov	ecx, DWORD PTR $T225757[ebp]
	cmp	ecx, DWORD PTR $T225680[ebp]
	jl	SHORT $LN30@GetPreviou
	mov	eax, DWORD PTR $T225757[ebp]
	cdq
	idiv	DWORD PTR $T225680[ebp]
	mov	DWORD PTR _iMapY$225755[ebp], edx
	jmp	SHORT $LN31@GetPreviou
$LN30@GetPreviou:
	mov	edx, DWORD PTR $T225757[ebp]
	mov	DWORD PTR _iMapY$225755[ebp], edx
$LN31@GetPreviou:
	cmp	DWORD PTR _iMapX$225754[ebp], 0
	jl	SHORT $LN35@GetPreviou
	mov	eax, DWORD PTR $T225654[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225694[ebp], ecx
	mov	edx, DWORD PTR _iMapX$225754[ebp]
	cmp	edx, DWORD PTR $T225694[ebp]
	jge	SHORT $LN35@GetPreviou
	cmp	DWORD PTR _iMapY$225755[ebp], 0
	jl	SHORT $LN35@GetPreviou
	mov	eax, DWORD PTR $T225654[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T225698[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225755[ebp]
	cmp	edx, DWORD PTR $T225698[ebp]
	jge	SHORT $LN35@GetPreviou
	mov	DWORD PTR tv160[ebp], 1
	jmp	SHORT $LN33@GetPreviou
$LN35@GetPreviou:
	mov	DWORD PTR tv160[ebp], 0
$LN33@GetPreviou:
	cmp	DWORD PTR tv160[ebp], 0
	je	SHORT $LN11@GetPreviou
	mov	eax, DWORD PTR $T225654[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225711[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225755[ebp]
	imul	edx, DWORD PTR $T225711[ebp]
	add	edx, DWORD PTR _iMapX$225754[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T225654[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv145[ebp], edx
	jmp	SHORT $LN12@GetPreviou
$LN11@GetPreviou:
	mov	DWORD PTR tv145[ebp], 0
$LN12@GetPreviou:
	mov	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx
$LN2@GetPreviou:

; 4610 : #endif
; 4611 : 		}
; 4612 : 	}
; 4613 : 
; 4614 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4615 : 	return NULL;
; 4616 : #else
; 4617 : 	return pPlot;

	mov	eax, DWORD PTR _pPlot$[ebp]

; 4618 : #endif
; 4619 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPreviousPlot@CvIgnoreUnitsPathFinder@@QAEPAVCvPlot@@XZ ENDP ; CvIgnoreUnitsPathFinder::GetPreviousPlot
_TEXT	ENDS
PUBLIC	?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; UIPathValid
EXTRN	?isAdjacentToArea@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isAdjacentToArea
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
EXTRN	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC	; CvUnit::canMoveInto
EXTRN	?getNoRevealMapCount@CvUnit@@QBEHXZ:PROC	; CvUnit::getNoRevealMapCount
; Function compile flags: /Odtp
;	COMDAT ?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T225805 = -40						; size = 4
$T225801 = -33						; size = 1
$T225800 = -32						; size = 4
$T225790 = -28						; size = 4
_uiOffset$225788 = -24					; size = 4
$T225769 = -20						; size = 4
$T225763 = -16						; size = 4
_iGroupAreaID$220245 = -12				; size = 4
_pUnit$ = -8						; size = 4
_pToPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; UIPathValid, COMDAT

; 4624 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 4625 : 	if (parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN12@UIPathVali

; 4626 : 	{
; 4627 : 		return TRUE;

	mov	eax, 1
	jmp	$LN13@UIPathVali
$LN12@UIPathVali:

; 4628 : 	}
; 4629 : 
; 4630 : 	if(node->m_iData2 > 3)

	mov	eax, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [eax+16], 3
	jle	SHORT $LN11@UIPathVali

; 4631 : 	{
; 4632 : 		return FALSE;

	xor	eax, eax
	jmp	$LN13@UIPathVali
$LN11@UIPathVali:

; 4633 : 	}
; 4634 : 
; 4635 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4636 : 	const CvPlot* pToPlot = node->m_pPlot;
; 4637 : #else
; 4638 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225763[ebp], ecx
	mov	edx, DWORD PTR $T225763[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T225769[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T225769[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T225763[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pToPlot$[ebp], ecx

; 4639 : #endif
; 4640 : 
; 4641 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 4642 : 
; 4643 : 	if(!pToPlot->isRevealed(pUnit->getTeam()))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T225790[ebp], eax
	mov	ecx, DWORD PTR $T225790[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$225788[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$225788[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T225790[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$225788[ebp]
	mov	edx, DWORD PTR _pToPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@UIPathVali

; 4644 : 	{
; 4645 : 		if(pUnit->getNoRevealMapCount() > 0)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getNoRevealMapCount@CvUnit@@QBEHXZ	; CvUnit::getNoRevealMapCount
	test	eax, eax
	jle	SHORT $LN10@UIPathVali

; 4646 : 		{
; 4647 : 			return FALSE;

	xor	eax, eax
	jmp	$LN13@UIPathVali
$LN10@UIPathVali:

; 4648 : 		}
; 4649 : 	}
; 4650 : 
; 4651 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4652 : 	if(pToPlot->isVisible(pUnit->getTeam()) && pToPlot->isVisibleEnemyUnit(pUnit))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T225800[ebp], eax
	cmp	DWORD PTR $T225800[ebp], -1
	jne	SHORT $LN30@UIPathVali
	mov	BYTE PTR $T225801[ebp], 0
	jmp	SHORT $LN28@UIPathVali
$LN30@UIPathVali:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR $T225800[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T225801[ebp], al
$LN28@UIPathVali:
	movzx	ecx, BYTE PTR $T225801[ebp]
	test	ecx, ecx
	je	SHORT $LN8@UIPathVali
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@UIPathVali

; 4653 : 	{
; 4654 : 		if (!pUnit->canMoveInto(*pToPlot, CvUnit::MOVEFLAG_ATTACK))

	push	1
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@UIPathVali

; 4655 : 			return FALSE;

	xor	eax, eax
	jmp	$LN13@UIPathVali
$LN8@UIPathVali:

; 4656 : 	}
; 4657 : #endif
; 4658 : 
; 4659 : 	if(pUnit->getDomainType() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN6@UIPathVali

; 4660 : 	{
; 4661 : 		int iGroupAreaID = pUnit->getArea();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	mov	DWORD PTR _iGroupAreaID$220245[ebp], eax

; 4662 : 		if(pToPlot->getArea() != iGroupAreaID)

	mov	eax, DWORD PTR _pToPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T225805[ebp], ecx
	mov	edx, DWORD PTR $T225805[ebp]
	cmp	edx, DWORD PTR _iGroupAreaID$220245[ebp]
	je	SHORT $LN6@UIPathVali

; 4663 : 		{
; 4664 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4665 : 			if (!pUnit->canMoveAllTerrain() && !pUnit->IsHoveringUnit() && !pToPlot->isAdjacentToArea(iGroupAreaID))
; 4666 : #else
; 4667 : 			if(!(pToPlot->isAdjacentToArea(iGroupAreaID)))

	mov	eax, DWORD PTR _iGroupAreaID$220245[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isAdjacentToArea@CvPlot@@QBE_NH@Z	; CvPlot::isAdjacentToArea
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@UIPathVali

; 4668 : #endif
; 4669 : 			{
; 4670 : 				// antonjs: Added for Smoky Skies scenario. Allows move range to show correctly for airships,
; 4671 : 				// which move over land and sea plots equally (canMoveAllTerrain)
; 4672 : #ifndef AUI_UNIT_FIX_HOVERING_EMBARK		
; 4673 : 				if (!pUnit->canMoveAllTerrain())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@UIPathVali

; 4674 : #endif
; 4675 : 				{
; 4676 : 					return FALSE;

	xor	eax, eax
	jmp	SHORT $LN13@UIPathVali
$LN6@UIPathVali:

; 4677 : 				}
; 4678 : 			}
; 4679 : 		}
; 4680 : 	}
; 4681 : 
; 4682 : 	if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_ATTACK))

	push	1
	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@UIPathVali

; 4683 : 	{
; 4684 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN13@UIPathVali
$LN2@UIPathVali:

; 4685 : 	}
; 4686 : 
; 4687 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4688 : 	if (pToPlot->isVisible(pUnit->getTeam()) && pToPlot->isVisibleEnemyUnit(pUnit))
; 4689 : 	{
; 4690 : 		if (!pUnit->canMoveInto(*pToPlot, CvUnit::MOVEFLAG_ATTACK, true, true))
; 4691 : 			return FALSE;
; 4692 : 	}
; 4693 : #endif
; 4694 : 
; 4695 : 	if(!PathValid(parent,node,data,pointer,finder))

	mov	edx, DWORD PTR _finder$[ebp]
	push	edx
	mov	eax, DWORD PTR _pointer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN1@UIPathVali

; 4696 : 	{
; 4697 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN13@UIPathVali
$LN1@UIPathVali:

; 4698 : 	}
; 4699 : 
; 4700 : 	return TRUE;

	mov	eax, 1
$LN13@UIPathVali:

; 4701 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UIPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; UIPathValid
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; UIPathAdd
EXTRN	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z:PROC ; CvGlobals::WrapPlotPointer
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$1
__ehfuncinfo$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv135 = -116						; size = 4
tv174 = -112						; size = 4
_inst$225941 = -108					; size = 4
$T225937 = -104						; size = 4
$T225925 = -100						; size = 4
_inst$225920 = -96					; size = 4
$T225916 = -92						; size = 4
$T225907 = -88						; size = 4
__Ptr$225906 = -84					; size = 4
$T225902 = -80						; size = 4
__Cvtptr$225900 = -76					; size = 4
__Ans$225901 = -72					; size = 4
$T225891 = -68						; size = 4
$T225890 = -64						; size = 4
$T225853 = -60						; size = 4
$T225841 = -56						; size = 4
$T225837 = -49						; size = 1
$T225826 = -48						; size = 4
$T225822 = -41						; size = 1
_iMapY$225889 = -40					; size = 4
_iMapX$225888 = -36					; size = 4
$T225815 = -32						; size = 4
$T225809 = -28						; size = 4
$T225808 = -24						; size = 4
_pDllPlot$220309 = -20					; size = 4
_pPlot$220260 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC	; UIPathAdd, COMDAT

; 4706 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4707 : 	PathAdd(parent, node, data, pointer, finder);

	mov	eax, DWORD PTR _finder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pointer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	add	esp, 20					; 00000014H

; 4708 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 4709 : 	if(node)

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN3@UIPathAdd

; 4710 : #endif
; 4711 : 	{
; 4712 : 		if(node->m_iData2 < 2 /*&& node->m_eCvAStarListType == NO_CVASTARLIST*/)

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+16], 2
	jge	$LN3@UIPathAdd

; 4713 : 		{
; 4714 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4715 : 			CvPlot* pPlot = node->m_pPlot;
; 4716 : #else
; 4717 : 			CvPlot* pPlot = GC.getMap().plot(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225815[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T225891[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T225890[ebp], ecx
	cmp	DWORD PTR $T225890[ebp], -2147483647	; 80000001H
	je	SHORT $LN10@UIPathAdd
	cmp	DWORD PTR $T225891[ebp], -2147483647	; 80000001H
	jne	SHORT $LN11@UIPathAdd
$LN10@UIPathAdd:
	mov	DWORD PTR _pPlot$220260[ebp], 0
	jmp	$LN12@UIPathAdd
$LN11@UIPathAdd:
	mov	edx, DWORD PTR $T225815[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T225822[ebp], al
	mov	ecx, DWORD PTR $T225815[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T225826[ebp], edx
	movzx	eax, BYTE PTR $T225822[ebp]
	test	eax, eax
	je	SHORT $LN23@UIPathAdd
	cmp	DWORD PTR $T225890[ebp], 0
	jge	SHORT $LN22@UIPathAdd
	mov	eax, DWORD PTR $T225890[ebp]
	cdq
	idiv	DWORD PTR $T225826[ebp]
	add	edx, DWORD PTR $T225826[ebp]
	mov	DWORD PTR _iMapX$225888[ebp], edx
	jmp	SHORT $LN24@UIPathAdd
	jmp	SHORT $LN23@UIPathAdd
$LN22@UIPathAdd:
	mov	ecx, DWORD PTR $T225890[ebp]
	cmp	ecx, DWORD PTR $T225826[ebp]
	jl	SHORT $LN23@UIPathAdd
	mov	eax, DWORD PTR $T225890[ebp]
	cdq
	idiv	DWORD PTR $T225826[ebp]
	mov	DWORD PTR _iMapX$225888[ebp], edx
	jmp	SHORT $LN24@UIPathAdd
$LN23@UIPathAdd:
	mov	edx, DWORD PTR $T225890[ebp]
	mov	DWORD PTR _iMapX$225888[ebp], edx
$LN24@UIPathAdd:
	mov	eax, DWORD PTR $T225815[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T225837[ebp], cl
	mov	edx, DWORD PTR $T225815[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T225841[ebp], eax
	movzx	ecx, BYTE PTR $T225837[ebp]
	test	ecx, ecx
	je	SHORT $LN33@UIPathAdd
	cmp	DWORD PTR $T225891[ebp], 0
	jge	SHORT $LN32@UIPathAdd
	mov	eax, DWORD PTR $T225891[ebp]
	cdq
	idiv	DWORD PTR $T225841[ebp]
	add	edx, DWORD PTR $T225841[ebp]
	mov	DWORD PTR _iMapY$225889[ebp], edx
	jmp	SHORT $LN34@UIPathAdd
	jmp	SHORT $LN33@UIPathAdd
$LN32@UIPathAdd:
	mov	edx, DWORD PTR $T225891[ebp]
	cmp	edx, DWORD PTR $T225841[ebp]
	jl	SHORT $LN33@UIPathAdd
	mov	eax, DWORD PTR $T225891[ebp]
	cdq
	idiv	DWORD PTR $T225841[ebp]
	mov	DWORD PTR _iMapY$225889[ebp], edx
	jmp	SHORT $LN34@UIPathAdd
$LN33@UIPathAdd:
	mov	eax, DWORD PTR $T225891[ebp]
	mov	DWORD PTR _iMapY$225889[ebp], eax
$LN34@UIPathAdd:
	mov	ecx, DWORD PTR _iMapY$225889[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$225888[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225815[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN14@UIPathAdd
	mov	eax, DWORD PTR $T225815[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225853[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225889[ebp]
	imul	edx, DWORD PTR $T225853[ebp]
	add	edx, DWORD PTR _iMapX$225888[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T225815[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv174[ebp], edx
	jmp	SHORT $LN15@UIPathAdd
$LN14@UIPathAdd:
	mov	DWORD PTR tv174[ebp], 0
$LN15@UIPathAdd:
	mov	ecx, DWORD PTR tv174[ebp]
	mov	DWORD PTR _pPlot$220260[ebp], ecx
$LN12@UIPathAdd:

; 4718 : #endif
; 4719 : 			if(pPlot)

	cmp	DWORD PTR _pPlot$220260[ebp], 0
	je	$LN3@UIPathAdd

; 4720 : 			{
; 4721 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);

	mov	edx, DWORD PTR _pPlot$220260[ebp]
	push	edx
	lea	eax, DWORD PTR $T225808[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	DWORD PTR $T225902[ebp], eax
	mov	ecx, DWORD PTR $T225902[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Cvtptr$225900[ebp], edx
	mov	eax, DWORD PTR __Cvtptr$225900[ebp]
	mov	DWORD PTR __Ans$225901[ebp], eax
	mov	ecx, DWORD PTR $T225902[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR __Ans$225901[ebp]
	mov	DWORD PTR $T225809[ebp], edx
	mov	eax, DWORD PTR $T225809[ebp]
	mov	DWORD PTR $T225907[ebp], eax
	mov	ecx, DWORD PTR $T225907[ebp]
	mov	DWORD PTR __Ptr$225906[ebp], ecx
	mov	DWORD PTR $T225907[ebp], 0
	mov	edx, DWORD PTR __Ptr$225906[ebp]
	mov	DWORD PTR _pDllPlot$220309[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T225808[ebp]
	mov	DWORD PTR $T225916[ebp], eax
	cmp	DWORD PTR $T225916[ebp], 0
	je	SHORT $LN46@UIPathAdd
	mov	ecx, DWORD PTR $T225916[ebp]
	mov	DWORD PTR _inst$225920[ebp], ecx
	mov	edx, DWORD PTR _inst$225920[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$225920[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN46@UIPathAdd:

; 4722 : 				GC.GetEngineUserInterface()->AddHexToUIRange(pDllPlot.get());

	mov	eax, DWORD PTR $T225925[ebp]
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv135[ebp], ecx
	mov	edx, DWORD PTR _pDllPlot$220309[ebp]
	push	edx
	mov	eax, DWORD PTR tv135[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv135[ebp]
	mov	eax, DWORD PTR [edx+444]
	call	eax

; 4723 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllPlot$220309[ebp]
	mov	DWORD PTR $T225937[ebp], ecx
	cmp	DWORD PTR $T225937[ebp], 0
	je	SHORT $LN3@UIPathAdd
	mov	edx, DWORD PTR $T225937[ebp]
	mov	DWORD PTR _inst$225941[ebp], edx
	mov	eax, DWORD PTR _inst$225941[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$225941[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN3@UIPathAdd:

; 4724 : 		}
; 4725 : 	}
; 4726 : 
; 4727 : 	return 1;

	mov	eax, 1

; 4728 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$220309[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UIPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP	; UIPathAdd
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AttackPathAdd
EXTRN	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z:PROC ; CvGlobals::UnwrapUnitPointer
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$2
__ehfuncinfo$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv173 = -168						; size = 4
tv91 = -164						; size = 4
tv213 = -160						; size = 4
_inst$226121 = -156					; size = 4
$T226117 = -152						; size = 4
_inst$226107 = -148					; size = 4
$T226103 = -144						; size = 4
$T226090 = -140						; size = 4
_inst$226086 = -136					; size = 4
$T226082 = -132						; size = 4
$T226072 = -128						; size = 4
__Ptr$226070 = -124					; size = 4
$T226067 = -120						; size = 4
__Cvtptr$226064 = -116					; size = 4
__Ans$226066 = -112					; size = 4
$T226056 = -105						; size = 1
_pCity$226053 = -100					; size = 4
$T226045 = -93						; size = 1
$T226044 = -92						; size = 4
$T226034 = -88						; size = 4
$T226030 = -84						; size = 4
$T226026 = -80						; size = 4
$T226022 = -76						; size = 4
$T226021 = -72						; size = 4
$T225990 = -68						; size = 4
$T225985 = -64						; size = 4
$T225981 = -57						; size = 1
$T225970 = -56						; size = 4
$T225966 = -49						; size = 1
_iMapY$226020 = -48					; size = 4
_iMapX$226019 = -44					; size = 4
$T225959 = -40						; size = 4
$T225952 = -36						; size = 4
$T225951 = -32						; size = 4
_pDllPlot$220400 = -28					; size = 4
_pUnit$220395 = -24					; size = 4
_pPlot$220337 = -20					; size = 4
_pDllUnit$220385 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; AttackPathAdd, COMDAT

; 4732 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4733 : 	PathAdd(parent, node, data, pointer, finder);

	mov	eax, DWORD PTR _finder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pointer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	mov	eax, DWORD PTR _node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	add	esp, 20					; 00000014H

; 4734 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4735 : 	if (node->m_iData2 < 2)
; 4736 : #else
; 4737 : 	if(node && node->m_iData2 < 2)

	cmp	DWORD PTR _node$[ebp], 0
	je	$LN4@AttackPath
	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx+16], 2
	jge	$LN4@AttackPath

; 4738 : #endif
; 4739 : 	{
; 4740 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4741 : 		CvPlot* pPlot = node->m_pPlot;
; 4742 : #else
; 4743 : 		CvPlot* pPlot = GC.getMap().plot(node->m_iX, node->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225959[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T226022[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T226021[ebp], ecx
	cmp	DWORD PTR $T226021[ebp], -2147483647	; 80000001H
	je	SHORT $LN12@AttackPath
	cmp	DWORD PTR $T226022[ebp], -2147483647	; 80000001H
	jne	SHORT $LN13@AttackPath
$LN12@AttackPath:
	mov	DWORD PTR _pPlot$220337[ebp], 0
	jmp	$LN14@AttackPath
$LN13@AttackPath:
	mov	edx, DWORD PTR $T225959[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T225966[ebp], al
	mov	ecx, DWORD PTR $T225959[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T225970[ebp], edx
	movzx	eax, BYTE PTR $T225966[ebp]
	test	eax, eax
	je	SHORT $LN25@AttackPath
	cmp	DWORD PTR $T226021[ebp], 0
	jge	SHORT $LN24@AttackPath
	mov	eax, DWORD PTR $T226021[ebp]
	cdq
	idiv	DWORD PTR $T225970[ebp]
	add	edx, DWORD PTR $T225970[ebp]
	mov	DWORD PTR _iMapX$226019[ebp], edx
	jmp	SHORT $LN26@AttackPath
	jmp	SHORT $LN25@AttackPath
$LN24@AttackPath:
	mov	ecx, DWORD PTR $T226021[ebp]
	cmp	ecx, DWORD PTR $T225970[ebp]
	jl	SHORT $LN25@AttackPath
	mov	eax, DWORD PTR $T226021[ebp]
	cdq
	idiv	DWORD PTR $T225970[ebp]
	mov	DWORD PTR _iMapX$226019[ebp], edx
	jmp	SHORT $LN26@AttackPath
$LN25@AttackPath:
	mov	edx, DWORD PTR $T226021[ebp]
	mov	DWORD PTR _iMapX$226019[ebp], edx
$LN26@AttackPath:
	mov	eax, DWORD PTR $T225959[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T225981[ebp], cl
	mov	edx, DWORD PTR $T225959[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T225985[ebp], eax
	movzx	ecx, BYTE PTR $T225981[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225985[ebp]
	push	edx
	mov	eax, DWORD PTR $T226022[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$226020[ebp], eax
	mov	ecx, DWORD PTR _iMapY$226020[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$226019[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225959[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN16@AttackPath
	mov	eax, DWORD PTR $T225959[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225990[ebp], ecx
	mov	edx, DWORD PTR _iMapY$226020[ebp]
	imul	edx, DWORD PTR $T225990[ebp]
	add	edx, DWORD PTR _iMapX$226019[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T225959[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv213[ebp], edx
	jmp	SHORT $LN17@AttackPath
$LN16@AttackPath:
	mov	DWORD PTR tv213[ebp], 0
$LN17@AttackPath:
	mov	ecx, DWORD PTR tv213[ebp]
	mov	DWORD PTR _pPlot$220337[ebp], ecx
$LN14@AttackPath:

; 4744 : #endif
; 4745 : 
; 4746 : 		auto_ptr<ICvUnit1> pDllUnit(GC.GetEngineUserInterface()->GetHeadSelectedUnit());

	mov	edx, DWORD PTR $T226026[ebp]
	mov	DWORD PTR tv91[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR tv91[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	DWORD PTR $T226030[ebp], eax
	mov	ecx, DWORD PTR $T226030[ebp]
	mov	DWORD PTR _pDllUnit$220385[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4747 : 		CvUnit* pUnit = GC.UnwrapUnitPointer(pDllUnit.get());

	mov	edx, DWORD PTR _pDllUnit$220385[ebp]
	mov	DWORD PTR $T226034[ebp], edx
	mov	eax, DWORD PTR $T226034[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?UnwrapUnitPointer@CvGlobals@@QAEPAVCvUnit@@PAVICvUnit1@@@Z ; CvGlobals::UnwrapUnitPointer
	mov	DWORD PTR _pUnit$220395[ebp], eax

; 4748 : 		CvAssertMsg(pUnit, "pUnit should be a value");
; 4749 : 
; 4750 : 		if(pUnit && pPlot)

	cmp	DWORD PTR _pUnit$220395[ebp], 0
	je	$LN3@AttackPath
	cmp	DWORD PTR _pPlot$220337[ebp], 0
	je	$LN3@AttackPath

; 4751 : 		{
; 4752 : 			if(pPlot->isVisible(pUnit->getTeam()) && (pPlot->isVisibleEnemyUnit(pUnit) || pPlot->isEnemyCity(*pUnit)))

	mov	ecx, DWORD PTR _pUnit$220395[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T226044[ebp], eax
	cmp	DWORD PTR $T226044[ebp], -1
	jne	SHORT $LN45@AttackPath
	mov	BYTE PTR $T226045[ebp], 0
	jmp	SHORT $LN43@AttackPath
$LN45@AttackPath:
	mov	ecx, DWORD PTR _pPlot$220337[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR $T226044[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T226045[ebp], dl
$LN43@AttackPath:
	movzx	eax, BYTE PTR $T226045[ebp]
	test	eax, eax
	je	$LN3@AttackPath
	mov	ecx, DWORD PTR _pUnit$220395[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$220337[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@AttackPath
	mov	ecx, DWORD PTR _pPlot$220337[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$226053[ebp], eax
	cmp	DWORD PTR _pCity$226053[ebp], 0
	je	SHORT $LN47@AttackPath
	mov	eax, DWORD PTR _pPlot$220337[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$226053[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _pUnit$220395[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	mov	BYTE PTR $T226056[ebp], al
	jmp	SHORT $LN48@AttackPath
$LN47@AttackPath:
	mov	BYTE PTR $T226056[ebp], 0
$LN48@AttackPath:
	movzx	ecx, BYTE PTR $T226056[ebp]
	test	ecx, ecx
	je	$LN3@AttackPath
$LN1@AttackPath:

; 4753 : 			{
; 4754 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pPlot);

	mov	edx, DWORD PTR _pPlot$220337[ebp]
	push	edx
	lea	eax, DWORD PTR $T225951[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	DWORD PTR $T226067[ebp], eax
	mov	ecx, DWORD PTR $T226067[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Cvtptr$226064[ebp], edx
	mov	eax, DWORD PTR __Cvtptr$226064[ebp]
	mov	DWORD PTR __Ans$226066[ebp], eax
	mov	ecx, DWORD PTR $T226067[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR __Ans$226066[ebp]
	mov	DWORD PTR $T225952[ebp], edx
	mov	eax, DWORD PTR $T225952[ebp]
	mov	DWORD PTR $T226072[ebp], eax
	mov	ecx, DWORD PTR $T226072[ebp]
	mov	DWORD PTR __Ptr$226070[ebp], ecx
	mov	DWORD PTR $T226072[ebp], 0
	mov	edx, DWORD PTR __Ptr$226070[ebp]
	mov	DWORD PTR _pDllPlot$220400[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T225951[ebp]
	mov	DWORD PTR $T226082[ebp], eax
	cmp	DWORD PTR $T226082[ebp], 0
	je	SHORT $LN61@AttackPath
	mov	ecx, DWORD PTR $T226082[ebp]
	mov	DWORD PTR _inst$226086[ebp], ecx
	mov	edx, DWORD PTR _inst$226086[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$226086[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN61@AttackPath:

; 4755 : 				GC.GetEngineUserInterface()->AddHexToUIRange(pDllPlot.get());

	mov	eax, DWORD PTR $T226090[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR _pDllPlot$220400[ebp]
	push	edx
	mov	eax, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx+444]
	call	eax

; 4756 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _pDllPlot$220400[ebp]
	mov	DWORD PTR $T226103[ebp], ecx
	cmp	DWORD PTR $T226103[ebp], 0
	je	SHORT $LN3@AttackPath
	mov	edx, DWORD PTR $T226103[ebp]
	mov	DWORD PTR _inst$226107[ebp], edx
	mov	eax, DWORD PTR _inst$226107[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$226107[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN3@AttackPath:

; 4757 : 		}
; 4758 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllUnit$220385[ebp]
	mov	DWORD PTR $T226117[ebp], ecx
	cmp	DWORD PTR $T226117[ebp], 0
	je	SHORT $LN4@AttackPath
	mov	edx, DWORD PTR $T226117[ebp]
	mov	DWORD PTR _inst$226121[ebp], edx
	mov	eax, DWORD PTR _inst$226121[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$226121[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN4@AttackPath:

; 4759 : 
; 4760 : 	return 1;

	mov	eax, 1

; 4761 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$0:
	lea	ecx, DWORD PTR _pDllUnit$220385[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z$2:
	lea	ecx, DWORD PTR _pDllPlot$220400[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AttackPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; AttackPathAdd
PUBLIC	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z	; AttackPathDestEval
EXTRN	?IsFortifiedThisTurn@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsFortifiedThisTurn
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
; Function compile flags: /Odtp
;	COMDAT ?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z
_TEXT	SEGMENT
tv179 = -88						; size = 4
$T226252 = -81						; size = 1
_pCity$226249 = -76					; size = 4
$T226241 = -72						; size = 4
$T226232 = -65						; size = 1
_pCity$226229 = -60					; size = 4
$T226221 = -53						; size = 1
$T226220 = -52						; size = 4
$T226171 = -48						; size = 4
$T226159 = -44						; size = 4
$T226155 = -37						; size = 1
$T226144 = -36						; size = 4
$T226140 = -29						; size = 1
_iMapY$226180 = -28					; size = 4
_iMapX$226179 = -24					; size = 4
$T226133 = -20						; size = 4
_pEnemyUnit$220419 = -16				; size = 4
_pUnit$ = -12						; size = 4
_pPlot$ = -8						; size = 4
_pNode$ = -4						; size = 4
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
_bOnlyFortified$ = 24					; size = 1
_bOnlyCity$ = 28					; size = 1
?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z PROC	; AttackPathDestEval, COMDAT

; 4769 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 4770 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 4771 : 	CvAssertMsg(pUnit, "pUnit should be a value");
; 4772 : 	CvPlot* pPlot = GC.getMap().plot(iToX, iToY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226133[ebp], ecx
	cmp	DWORD PTR _iToX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN14@AttackPath@2
	cmp	DWORD PTR _iToY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN15@AttackPath@2
$LN14@AttackPath@2:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	$LN16@AttackPath@2
$LN15@AttackPath@2:
	mov	edx, DWORD PTR $T226133[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T226140[ebp], al
	mov	ecx, DWORD PTR $T226133[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T226144[ebp], edx
	movzx	eax, BYTE PTR $T226140[ebp]
	test	eax, eax
	je	SHORT $LN27@AttackPath@2
	cmp	DWORD PTR _iToX$[ebp], 0
	jge	SHORT $LN26@AttackPath@2
	mov	eax, DWORD PTR _iToX$[ebp]
	cdq
	idiv	DWORD PTR $T226144[ebp]
	add	edx, DWORD PTR $T226144[ebp]
	mov	DWORD PTR _iMapX$226179[ebp], edx
	jmp	SHORT $LN28@AttackPath@2
	jmp	SHORT $LN27@AttackPath@2
$LN26@AttackPath@2:
	mov	ecx, DWORD PTR _iToX$[ebp]
	cmp	ecx, DWORD PTR $T226144[ebp]
	jl	SHORT $LN27@AttackPath@2
	mov	eax, DWORD PTR _iToX$[ebp]
	cdq
	idiv	DWORD PTR $T226144[ebp]
	mov	DWORD PTR _iMapX$226179[ebp], edx
	jmp	SHORT $LN28@AttackPath@2
$LN27@AttackPath@2:
	mov	edx, DWORD PTR _iToX$[ebp]
	mov	DWORD PTR _iMapX$226179[ebp], edx
$LN28@AttackPath@2:
	mov	eax, DWORD PTR $T226133[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T226155[ebp], cl
	mov	edx, DWORD PTR $T226133[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T226159[ebp], eax
	movzx	ecx, BYTE PTR $T226155[ebp]
	test	ecx, ecx
	je	SHORT $LN37@AttackPath@2
	cmp	DWORD PTR _iToY$[ebp], 0
	jge	SHORT $LN36@AttackPath@2
	mov	eax, DWORD PTR _iToY$[ebp]
	cdq
	idiv	DWORD PTR $T226159[ebp]
	add	edx, DWORD PTR $T226159[ebp]
	mov	DWORD PTR _iMapY$226180[ebp], edx
	jmp	SHORT $LN38@AttackPath@2
	jmp	SHORT $LN37@AttackPath@2
$LN36@AttackPath@2:
	mov	edx, DWORD PTR _iToY$[ebp]
	cmp	edx, DWORD PTR $T226159[ebp]
	jl	SHORT $LN37@AttackPath@2
	mov	eax, DWORD PTR _iToY$[ebp]
	cdq
	idiv	DWORD PTR $T226159[ebp]
	mov	DWORD PTR _iMapY$226180[ebp], edx
	jmp	SHORT $LN38@AttackPath@2
$LN37@AttackPath@2:
	mov	eax, DWORD PTR _iToY$[ebp]
	mov	DWORD PTR _iMapY$226180[ebp], eax
$LN38@AttackPath@2:
	mov	ecx, DWORD PTR _iMapY$226180[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$226179[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226133[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN18@AttackPath@2
	mov	eax, DWORD PTR $T226133[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226171[ebp], ecx
	mov	edx, DWORD PTR _iMapY$226180[ebp]
	imul	edx, DWORD PTR $T226171[ebp]
	add	edx, DWORD PTR _iMapX$226179[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T226133[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN19@AttackPath@2
$LN18@AttackPath@2:
	mov	DWORD PTR tv179[ebp], 0
$LN19@AttackPath@2:
	mov	ecx, DWORD PTR tv179[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx
$LN16@AttackPath@2:

; 4773 : 	CvAStarNode* pNode = finder->GetLastNode();

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pNode$[ebp], eax

; 4774 : 
; 4775 : 	if(pPlot->isVisible(pUnit->getTeam()) && (pPlot->isVisibleEnemyUnit(pUnit) || pPlot->isEnemyCity(*pUnit)) && pNode && pNode->m_iData2 < 2)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T226220[ebp], eax
	cmp	DWORD PTR $T226220[ebp], -1
	jne	SHORT $LN49@AttackPath@2
	mov	BYTE PTR $T226221[ebp], 0
	jmp	SHORT $LN47@AttackPath@2
$LN49@AttackPath@2:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR $T226220[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T226221[ebp], dl
$LN47@AttackPath@2:
	movzx	eax, BYTE PTR $T226221[ebp]
	test	eax, eax
	je	$LN9@AttackPath@2
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@AttackPath@2
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$226229[ebp], eax
	cmp	DWORD PTR _pCity$226229[ebp], 0
	je	SHORT $LN51@AttackPath@2
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$226229[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	mov	BYTE PTR $T226232[ebp], al
	jmp	SHORT $LN52@AttackPath@2
$LN51@AttackPath@2:
	mov	BYTE PTR $T226232[ebp], 0
$LN52@AttackPath@2:
	movzx	ecx, BYTE PTR $T226232[ebp]
	test	ecx, ecx
	je	$LN9@AttackPath@2
$LN8@AttackPath@2:
	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN9@AttackPath@2
	mov	edx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [edx+16], 2
	jge	$LN9@AttackPath@2

; 4776 : 	{
; 4777 : 		if (pUnit->canMoveInto(*pPlot, CvUnit::MOVEFLAG_ATTACK))

	push	1
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveInto
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@AttackPath@2

; 4778 : 		{
; 4779 : 			if(bOnlyFortified)

	movzx	edx, BYTE PTR _bOnlyFortified$[ebp]
	test	edx, edx
	je	SHORT $LN6@AttackPath@2

; 4780 : 			{
; 4781 : 				CvUnit* pEnemyUnit = pPlot->getVisibleEnemyDefender(pUnit->getOwner());

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T226241[ebp], ecx
	mov	edx, DWORD PTR $T226241[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
	mov	DWORD PTR _pEnemyUnit$220419[ebp], eax

; 4782 : 				if(pEnemyUnit && pEnemyUnit->IsFortifiedThisTurn())

	cmp	DWORD PTR _pEnemyUnit$220419[ebp], 0
	je	SHORT $LN5@AttackPath@2
	mov	ecx, DWORD PTR _pEnemyUnit$220419[ebp]
	call	?IsFortifiedThisTurn@CvUnit@@QBE_NXZ	; CvUnit::IsFortifiedThisTurn
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@AttackPath@2

; 4783 : 				{
; 4784 : 					return TRUE;

	mov	eax, 1
	jmp	SHORT $LN10@AttackPath@2
$LN5@AttackPath@2:

; 4785 : 				}
; 4786 : 			}

	jmp	SHORT $LN9@AttackPath@2
$LN6@AttackPath@2:

; 4787 : 			else if(bOnlyCity)

	movzx	ecx, BYTE PTR _bOnlyCity$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@AttackPath@2

; 4788 : 			{
; 4789 : 				if(pPlot->isEnemyCity(*pUnit))

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$226249[ebp], eax
	cmp	DWORD PTR _pCity$226249[ebp], 0
	je	SHORT $LN63@AttackPath@2
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$226249[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	mov	BYTE PTR $T226252[ebp], al
	jmp	SHORT $LN64@AttackPath@2
$LN63@AttackPath@2:
	mov	BYTE PTR $T226252[ebp], 0
$LN64@AttackPath@2:
	movzx	eax, BYTE PTR $T226252[ebp]
	test	eax, eax
	je	SHORT $LN2@AttackPath@2

; 4790 : 				{
; 4791 : 					return TRUE;

	mov	eax, 1
	jmp	SHORT $LN10@AttackPath@2
$LN2@AttackPath@2:

; 4792 : 				}
; 4793 : 			}
; 4794 : 			else

	jmp	SHORT $LN9@AttackPath@2
$LN3@AttackPath@2:

; 4795 : 			{
; 4796 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $LN10@AttackPath@2
$LN9@AttackPath@2:

; 4797 : 			}
; 4798 : 		}
; 4799 : 	}
; 4800 : 
; 4801 : 	return FALSE;

	xor	eax, eax
$LN10@AttackPath@2:

; 4802 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ENDP	; AttackPathDestEval
_TEXT	ENDS
PUBLIC	?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z		; AttackPathDest
; Function compile flags: /Odtp
;	COMDAT ?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z PROC		; AttackPathDest, COMDAT

; 4811 : {

	push	ebp
	mov	ebp, esp

; 4812 : 	return AttackPathDestEval(iToX, iToY, pointer, finder, false, false);

	push	0
	push	0
	mov	eax, DWORD PTR _finder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pointer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iToY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iToX$[ebp]
	push	eax
	call	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ; AttackPathDestEval
	add	esp, 24					; 00000018H

; 4813 : }

	pop	ebp
	ret	0
?AttackPathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP		; AttackPathDest
_TEXT	ENDS
PUBLIC	?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z ; AttackFortifiedPathDest
; Function compile flags: /Odtp
;	COMDAT ?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z PROC	; AttackFortifiedPathDest, COMDAT

; 4822 : {

	push	ebp
	mov	ebp, esp

; 4823 : 	return AttackPathDestEval(iToX, iToY, pointer, finder, true, false);

	push	0
	push	1
	mov	eax, DWORD PTR _finder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pointer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iToY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iToX$[ebp]
	push	eax
	call	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ; AttackPathDestEval
	add	esp, 24					; 00000018H

; 4824 : }

	pop	ebp
	ret	0
?AttackFortifiedPathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP	; AttackFortifiedPathDest
_TEXT	ENDS
PUBLIC	?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z	; AttackCityPathDest
; Function compile flags: /Odtp
;	COMDAT ?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z PROC	; AttackCityPathDest, COMDAT

; 4833 : {

	push	ebp
	mov	ebp, esp

; 4834 : 	return AttackPathDestEval(iToX, iToY, pointer, finder, false, true);

	push	1
	push	0
	mov	eax, DWORD PTR _finder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pointer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iToY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iToX$[ebp]
	push	eax
	call	?AttackPathDestEval@@YAHHHPBXPAVCvAStar@@_N2@Z ; AttackPathDestEval
	add	esp, 24					; 00000018H

; 4835 : }

	pop	ebp
	ret	0
?AttackCityPathDest@@YAHHHPBXPAVCvAStar@@@Z ENDP	; AttackCityPathDest
_TEXT	ENDS
PUBLIC	?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TacticalAnalysisMapPathValid
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
; Function compile flags: /Odtp
;	COMDAT ?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv330 = -264						; size = 4
tv326 = -260						; size = 4
tv245 = -256						; size = 4
tv242 = -252						; size = 4
tv227 = -248						; size = 4
tv205 = -244						; size = 4
tv196 = -237						; size = 1
tv533 = -236						; size = 4
tv170 = -229						; size = 1
tv163 = -228						; size = 1
tv154 = -227						; size = 1
tv147 = -226						; size = 1
tv136 = -225						; size = 1
tv78 = -224						; size = 4
tv75 = -220						; size = 4
$T226509 = -213						; size = 1
$T226505 = -212						; size = 4
_playerID$226493 = -208					; size = 4
$T226435 = -204						; size = 4
$T226421 = -200						; size = 4
$T226406 = -196						; size = 4
$T226405 = -192						; size = 4
$T226401 = -188						; size = 4
$T226389 = -184						; size = 4
$T226305 = -176						; size = 4
$T226301 = -172						; size = 4
$T226294 = -168						; size = 4
$T226271 = -164						; size = 4
$T226261 = -160						; size = 8
_kNodeCacheData$220510 = -152				; size = 4
_pCity$220468 = -148					; size = 4
_pUnit$ = -144						; size = 4
_iFinderInfo$ = -140					; size = 4
_pTAMap$ = -136						; size = 4
_bAIControl$ = -130					; size = 1
_bUnitIsCombat$ = -129					; size = 1
_iDestX$ = -128						; size = 4
_iNodeX$ = -124						; size = 4
_pFromPlotCell$ = -120					; size = 4
_bIsHuman$ = -113					; size = 1
_pUnitPlot$ = -112					; size = 4
_iUnitPlotLimit$ = -108					; size = 4
_pCacheData$ = -104					; size = 4
_pPlot$ = -100						; size = 4
_eUnitTeam$ = -96					; size = 4
_kToNodeCacheData$ = -92				; size = 4
_iFinderIgnoreStacking$ = -88				; size = 4
_iDestY$ = -84						; size = 4
_theMap$ = -80						; size = 4
_pToPlotCell$ = -76					; size = 4
_iUnitY$ = -72						; size = 4
_pNode$ = -68						; size = 4
_unit_domain_type$ = -64				; size = 4
_eFromPlotTeam$ = -60					; size = 4
_bPreviousNodeHostile$ = -53				; size = 1
_kUnitTeam$ = -52					; size = 4
_iUnitX$ = -48						; size = 4
_pFromPlot$ = -44					; size = 4
_bFromPlotOwned$ = -37					; size = 1
_iNumTurns$ = -36					; size = 4
_bFirstRun$ = -29					; size = 1
_eTeam$ = -28						; size = 4
_kFromNodeCacheData$ = -24				; size = 4
_unit_owner$ = -20					; size = 4
_iNodeY$ = -16						; size = 4
_iStartMoves$ = -12					; size = 4
_pToPlot$ = -8						; size = 4
_iOldNumTurns$ = -4					; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TacticalAnalysisMapPathValid, COMDAT

; 4839 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H

; 4840 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 4841 : 	CvPlot* pToPlot = node->m_pPlot;
; 4842 : 	if (!pToPlot)
; 4843 : 		return FALSE;
; 4844 : #else
; 4845 : 	CvMap& theMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _theMap$[ebp], eax

; 4846 : 
; 4847 : 	CvPlot* pToPlot = theMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _theMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T226271[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T226271[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _theMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pToPlot$[ebp], eax

; 4848 : #endif
; 4849 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pToPlot));

	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	DWORD PTR tv75[ebp], edx
	mov	eax, DWORD PTR tv75[ebp]
	prefetcht0 BYTE PTR [eax]
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR tv78[ebp], ecx
	mov	edx, DWORD PTR tv78[ebp]
	prefetcht0 BYTE PTR [edx]

; 4850 : 
; 4851 : 	CvUnit* pUnit = ((CvUnit *)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 4852 : 	const UnitPathCacheData* pCacheData = reinterpret_cast<const UnitPathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[ebp]
	add	ecx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], ecx

; 4853 : 
; 4854 : 	TeamTypes eUnitTeam = pCacheData->getTeam();

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 4855 : 	PlayerTypes unit_owner = pCacheData->getOwner();

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _unit_owner$[ebp], edx

; 4856 : 	CvAssertMsg(eUnitTeam != NO_TEAM, "The unit's team should be a vaild value");
; 4857 : 	if (eUnitTeam == NO_TEAM)

	cmp	DWORD PTR _eUnitTeam$[ebp], -1
	jne	SHORT $LN69@TacticalAn

; 4858 : 	{
; 4859 : 		eUnitTeam = GC.getGame().getActiveTeam();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226294[ebp], eax
	mov	ecx, DWORD PTR $T226294[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eUnitTeam$[ebp], eax

; 4860 : 	}
; 4861 : 
; 4862 : 	CvTeam& kUnitTeam = GET_TEAM(eUnitTeam);

$LN69@TacticalAn:
	mov	ecx, DWORD PTR _eUnitTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kUnitTeam$[ebp], ecx

; 4863 : 
; 4864 : 	CvTacticalAnalysisMap* pTAMap = GC.getGame().GetTacticalAnalysisMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T226301[ebp], edx
	mov	ecx, DWORD PTR $T226301[ebp]
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap
	mov	DWORD PTR _pTAMap$[ebp], eax

; 4865 : 	FAssert(pTAMap != NULL);
; 4866 : 	CvTacticalAnalysisCell* pToPlotCell = pTAMap->GetCell(pToPlot->GetPlotIndex());

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR $T226305[ebp], eax
	mov	eax, DWORD PTR $T226305[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _pTAMap$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _pToPlotCell$[ebp], eax

; 4867 : 	FAssert(pToPlotCell != NULL);
; 4868 : 
; 4869 : #ifdef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 4870 : 	// If this is the first node in the path, it is always valid (starting location)
; 4871 : 	if (parent == NULL)
; 4872 : 	{
; 4873 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4874 : 		// Cache values for this node that we will use in the loop
; 4875 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4876 : 		CvAStarNode& kToNodeCacheData = *node;
; 4877 : #else
; 4878 : 		CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;
; 4879 : #endif
; 4880 : 		if (!kToNodeCacheData.bIsCalculated)
; 4881 : 		{
; 4882 : 			kToNodeCacheData.bIsCalculated = true;
; 4883 : 			kToNodeCacheData.bPlotVisibleToTeam = true;
; 4884 : 			kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 4885 : 			kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 4886 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4887 : 			kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 4888 : 			if (pUnit->IsHoveringUnit())
; 4889 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 4890 : 			else
; 4891 : 				kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 4892 : #else
; 4893 : 			kToNodeCacheData.bIsWater = pToPlotCell->IsWater();
; 4894 : #endif
; 4895 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 4896 : 			kToNodeCacheData.bIsRevealedToTeam = true;
; 4897 : 			kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 4898 : 			CvCity* pCity = pToPlot->getPlotCity();
; 4899 : 			if (pCity)
; 4900 : 			{
; 4901 : 				if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 4902 : 					kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 4903 : 			}
; 4904 : 			kToNodeCacheData.bContainsEnemyCity = pToPlot->isEnemyCity(*pUnit);
; 4905 : 			if (kToNodeCacheData.bPlotVisibleToTeam)
; 4906 : 			{
; 4907 : 				kToNodeCacheData.bContainsVisibleEnemy = pToPlotCell->GetEnemyMilitaryUnit() != NULL;
; 4908 : 				kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 4909 : 			}
; 4910 : 			else
; 4911 : 			{
; 4912 : 				kToNodeCacheData.bContainsVisibleEnemy = false;
; 4913 : 				kToNodeCacheData.bContainsVisibleEnemyDefender = false;
; 4914 : 			}
; 4915 : 		}
; 4916 : #endif
; 4917 : 		return TRUE;
; 4918 : 	}
; 4919 : #endif
; 4920 : 
; 4921 : 	// Cache the data for the node
; 4922 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 4923 : 	CvAStarNode& kToNodeCacheData = *node;
; 4924 : #else
; 4925 : 	CvPathNodeCacheData& kToNodeCacheData = node->m_kCostCacheData;

	mov	edx, DWORD PTR _node$[ebp]
	add	edx, 88					; 00000058H
	mov	DWORD PTR _kToNodeCacheData$[ebp], edx

; 4926 : #endif
; 4927 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 4928 : 	if (!kToNodeCacheData.bIsCalculated)
; 4929 : 	{
; 4930 : 		kToNodeCacheData.bPlotVisibleToTeam = pToPlotCell->IsVisible();
; 4931 : 		kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);
; 4932 : 		kToNodeCacheData.bIsMountain = pToPlot->isMountain();
; 4933 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4934 : 		kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 4935 : 		if (pUnit->IsHoveringUnit())
; 4936 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 4937 : 		else
; 4938 : 			kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 4939 : #else
; 4940 : 		kToNodeCacheData.bIsWater = pToPlotCell->IsWater();
; 4941 : #endif
; 4942 : 		kToNodeCacheData.bIsRevealedToTeam = pToPlotCell->IsRevealed();
; 4943 : 		kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;
; 4944 : 		if (pToPlotCell->IsCity())
; 4945 : 		{
; 4946 : 			CvCity* pCity = pToPlot->getPlotCity();
; 4947 : 			if (pCity)
; 4948 : 			{
; 4949 : 				if (unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))
; 4950 : 					kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;
; 4951 : 			}
; 4952 : 		}
; 4953 : 		kToNodeCacheData.bContainsEnemyCity = pToPlotCell->IsEnemyCity();
; 4954 : 		if (kToNodeCacheData.bPlotVisibleToTeam)
; 4955 : 		{
; 4956 : 			kToNodeCacheData.bContainsVisibleEnemy = pToPlotCell->GetEnemyMilitaryUnit() != NULL;
; 4957 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;
; 4958 : 		}
; 4959 : 		else
; 4960 : 		{
; 4961 : 			kToNodeCacheData.bContainsVisibleEnemy = false;
; 4962 : 			kToNodeCacheData.bContainsVisibleEnemyDefender = false;
; 4963 : 		}
; 4964 : 	}
; 4965 : #else
; 4966 : 	kToNodeCacheData.bPlotVisibleToTeam = pToPlotCell->IsVisible();

	mov	eax, DWORD PTR _pToPlotCell$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 2
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR tv136[ebp], cl
	mov	dl, BYTE PTR tv136[ebp]
	and	dl, 1
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 254					; 000000feH
	or	cl, dl
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [edx], cl

; 4967 : 	kToNodeCacheData.iNumFriendlyUnitsOfType = pToPlot->getNumFriendlyUnitsOfType(pUnit);

	push	1
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 4968 : 	kToNodeCacheData.bIsMountain = pToPlot->isMountain();

	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	mov	BYTE PTR tv147[ebp], al
	mov	cl, BYTE PTR tv147[ebp]
	and	cl, 1
	shl	cl, 1
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	and	al, 253					; 000000fdH
	or	al, cl
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [ecx], al

; 4969 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 4970 : 	kToNodeCacheData.bIsWater = !pToPlot->IsAllowsWalkWater();
; 4971 : 	if (pUnit->IsHoveringUnit())
; 4972 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->getTerrainType() == GC.getDEEP_WATER_TERRAIN();
; 4973 : 	else
; 4974 : 		kToNodeCacheData.bIsWater = kToNodeCacheData.bIsWater && pToPlot->isWater();
; 4975 : #else
; 4976 : 	kToNodeCacheData.bIsWater = pToPlotCell->IsWater();

	mov	edx, DWORD PTR _pToPlotCell$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 2048				; 00000800H
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR tv154[ebp], al
	mov	cl, BYTE PTR tv154[ebp]
	and	cl, 1
	shl	cl, 2
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	and	al, 251					; 000000fbH
	or	al, cl
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [ecx], al

; 4977 : #endif
; 4978 : 	kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);

	push	128					; 00000080H
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	mov	BYTE PTR tv163[ebp], al
	mov	al, BYTE PTR tv163[ebp]
	and	al, 1
	shl	al, 3
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 247					; 000000f7H
	or	dl, al
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 4979 : 	kToNodeCacheData.bIsRevealedToTeam = pToPlotCell->IsRevealed();

	mov	ecx, DWORD PTR _pToPlotCell$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR tv170[ebp], dl
	mov	al, BYTE PTR tv170[ebp]
	and	al, 1
	shl	al, 4
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 239					; 000000efH
	or	dl, al
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 4980 : 	kToNodeCacheData.bContainsOtherFriendlyTeamCity = false;

	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 223					; 000000dfH
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 4981 : 	if(pToPlotCell->IsCity())

	mov	ecx, DWORD PTR _pToPlotCell$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 256				; 00000100H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN91@TacticalAn
	mov	ecx, DWORD PTR _pToPlotCell$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 512				; 00000200H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN91@TacticalAn
	mov	ecx, DWORD PTR _pToPlotCell$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 1024				; 00000400H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN91@TacticalAn
	mov	DWORD PTR tv533[ebp], 0
	jmp	SHORT $LN89@TacticalAn
$LN91@TacticalAn:
	mov	DWORD PTR tv533[ebp], 1
$LN89@TacticalAn:
	movzx	ecx, BYTE PTR tv533[ebp]
	test	ecx, ecx
	je	SHORT $LN114@TacticalAn

; 4982 : 	{
; 4983 : 		CvCity* pCity = pToPlot->getPlotCity();

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$220468[ebp], eax

; 4984 : 		if(pCity)

	cmp	DWORD PTR _pCity$220468[ebp], 0
	je	SHORT $LN114@TacticalAn

; 4985 : 		{
; 4986 : 			if(unit_owner != pCity->getOwner() && !kUnitTeam.isAtWar(pCity->getTeam()))

	mov	edx, DWORD PTR _pCity$220468[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T226389[ebp], eax
	mov	ecx, DWORD PTR _unit_owner$[ebp]
	cmp	ecx, DWORD PTR $T226389[ebp]
	je	SHORT $LN114@TacticalAn
	mov	ecx, DWORD PTR _pCity$220468[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _kUnitTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN114@TacticalAn

; 4987 : 				kToNodeCacheData.bContainsOtherFriendlyTeamCity = true;

	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	or	cl, 32					; 00000020H
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [edx], cl

; 4988 : 		}
; 4989 : 	}
; 4990 : 	kToNodeCacheData.bContainsEnemyCity = pToPlotCell->IsEnemyCity();

$LN114@TacticalAn:
	mov	eax, DWORD PTR _pToPlotCell$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 512				; 00000200H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	BYTE PTR tv196[ebp], cl
	mov	dl, BYTE PTR tv196[ebp]
	and	dl, 1
	shl	dl, 6
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	and	cl, 191					; 000000bfH
	or	cl, dl
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [edx], cl

; 4991 : 	kToNodeCacheData.bContainsVisibleEnemy = pToPlotCell->GetEnemyMilitaryUnit() != NULL;

	mov	eax, DWORD PTR _pToPlotCell$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226401[ebp], ecx
	mov	edx, DWORD PTR $T226401[ebp]
	mov	DWORD PTR tv205[ebp], edx
	cmp	DWORD PTR tv205[ebp], 0
	setne	al
	and	al, 1
	shl	al, 7
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 127					; 0000007fH
	or	dl, al
	mov	eax, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [eax], dl

; 4992 : 	kToNodeCacheData.bContainsVisibleEnemyDefender = pToPlot->getBestDefender(NO_PLAYER, unit_owner, pUnit).pointer() != NULL;

	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _unit_owner$[ebp]
	push	edx
	push	-1
	lea	eax, DWORD PTR $T226261[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR $T226405[ebp], eax
	mov	ecx, DWORD PTR $T226405[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226406[ebp], edx
	mov	eax, DWORD PTR $T226406[ebp]
	mov	DWORD PTR tv227[ebp], eax
	cmp	DWORD PTR tv227[ebp], 0
	setne	cl
	and	cl, 1
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx+1]
	and	al, 254					; 000000feH
	or	al, cl
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	BYTE PTR [ecx+1], al
	cmp	DWORD PTR $T226261[ebp], 0
	je	SHORT $LN123@TacticalAn
	mov	ecx, DWORD PTR $T226261[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN123@TacticalAn:

; 4993 : #endif
; 4994 : 
; 4995 : #ifndef AUI_ASTAR_FIX_PARENT_NODE_ALWAYS_VALID_OPTIMIZATION
; 4996 : 	// If this is the first node in the path, it is always valid (starting location)
; 4997 : 	if (parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN45@TacticalAn

; 4998 : 	{
; 4999 : 		return TRUE;

	mov	eax, 1
	jmp	$LN50@TacticalAn
$LN45@TacticalAn:

; 5000 : 	}
; 5001 : #endif
; 5002 : 
; 5003 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5004 : 	CvPlot* pFromPlot = parent->m_pPlot;
; 5005 : 	if (!pFromPlot)
; 5006 : 		return FALSE;
; 5007 : #else
; 5008 : 	CvPlot* pFromPlot = theMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	edx, DWORD PTR _theMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T226421[ebp], eax
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T226421[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _theMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], ecx

; 5009 : #endif
; 5010 : 	PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pFromPlot));

	mov	eax, DWORD PTR _pFromPlot$[ebp]
	mov	DWORD PTR tv242[ebp], eax
	mov	ecx, DWORD PTR tv242[ebp]
	prefetcht0 BYTE PTR [ecx]
	mov	edx, DWORD PTR _pFromPlot$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR tv245[ebp], edx
	mov	eax, DWORD PTR tv245[ebp]
	prefetcht0 BYTE PTR [eax]

; 5011 : 
; 5012 : 	CvTacticalAnalysisCell* pFromPlotCell = pTAMap->GetCell(pFromPlot->GetPlotIndex());

	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR $T226435[ebp], eax
	mov	ecx, DWORD PTR $T226435[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _pTAMap$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _pFromPlotCell$[ebp], ecx

; 5013 : 	FAssert(pFromPlotCell != NULL);
; 5014 : 
; 5015 : 	bool bAIControl = pUnit->IsAutomated();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	mov	BYTE PTR _bAIControl$[ebp], al

; 5016 : 
; 5017 : 	// pulling invariants out of the loop
; 5018 : 	int iUnitX = pUnit->getX();

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR _iUnitX$[ebp], ecx

; 5019 : 	int iUnitY = pUnit->getY();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR _iUnitY$[ebp], eax

; 5020 : 	DomainTypes unit_domain_type = pCacheData->getDomainType();

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _unit_domain_type$[ebp], edx

; 5021 : 	bool bUnitIsCombat           = pUnit->IsCombatUnit();

	mov	eax, DWORD PTR _pUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	mov	BYTE PTR _bUnitIsCombat$[ebp], cl

; 5022 : 	bool bIsHuman				 = pCacheData->isHuman();

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+36]
	mov	BYTE PTR _bIsHuman$[ebp], al

; 5023 : 	int iFinderInfo              = finder->GetInfo();

	mov	ecx, DWORD PTR _finder$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR _iFinderInfo$[ebp], edx

; 5024 : 	CvPlot* pUnitPlot            = pUnit->plot();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pUnitPlot$[ebp], eax

; 5025 : 	int iFinderIgnoreStacking    = iFinderInfo & MOVE_IGNORE_STACKING;

	mov	eax, DWORD PTR _iFinderInfo$[ebp]
	and	eax, 4
	mov	DWORD PTR _iFinderIgnoreStacking$[ebp], eax

; 5026 : 	int iUnitPlotLimit           = GC.getPLOT_UNIT_LIMIT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR _iUnitPlotLimit$[ebp], ecx

; 5027 : 	bool bFromPlotOwned          = !pFromPlotCell->IsUnclaimedTerritory();

	mov	edx, DWORD PTR _pFromPlotCell$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65536				; 00010000H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	mov	BYTE PTR _bFromPlotOwned$[ebp], cl

; 5028 : 	TeamTypes eFromPlotTeam      = pFromPlot->getTeam();

	mov	edx, DWORD PTR _pFromPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$226493[ebp], eax
	cmp	DWORD PTR _playerID$226493[ebp], -1
	je	SHORT $LN160@TacticalAn
	mov	ecx, DWORD PTR _playerID$226493[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eFromPlotTeam$[ebp], eax
	jmp	SHORT $LN161@TacticalAn
	jmp	SHORT $LN161@TacticalAn
$LN160@TacticalAn:
	mov	DWORD PTR _eFromPlotTeam$[ebp], -1
$LN161@TacticalAn:

; 5029 : 
; 5030 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5031 : 	if (!kToNodeCacheData.bIsCalculated)
; 5032 : 	{
; 5033 : 		if (bAIControl || !bIsHuman || kToNodeCacheData.bIsRevealedToTeam)
; 5034 : 			kToNodeCacheData.bCanEnterTerrain = pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE);
; 5035 : 		else
; 5036 : 			kToNodeCacheData.bCanEnterTerrain = true;
; 5037 : 		kToNodeCacheData.bIsCalculated = true;
; 5038 : 	}
; 5039 : #endif
; 5040 : 
; 5041 : 	// We have determined that this node is not the origin above (parent == NULL)
; 5042 : 	CvAStarNode* pNode = node;

	mov	edx, DWORD PTR _node$[ebp]
	mov	DWORD PTR _pNode$[ebp], edx

; 5043 : 	bool bPreviousNodeHostile = false;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 0

; 5044 : 	int iDestX = finder->GetDestX();

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR _iDestX$[ebp], ecx

; 5045 : 	int iDestY = finder->GetDestY();

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR _iDestY$[ebp], eax

; 5046 : 	int iNodeX = node->m_iX;

	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	DWORD PTR _iNodeX$[ebp], edx

; 5047 : 	int iNodeY = node->m_iY;

	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR _iNodeY$[ebp], ecx

; 5048 : 	int iOldNumTurns = -1;

	mov	DWORD PTR _iOldNumTurns$[ebp], -1

; 5049 : #ifndef AUI_ASTAR_MINOR_OPTIMIZATION
; 5050 : 	int iNumTurns;
; 5051 : #endif
; 5052 : 	TeamTypes eTeam = eUnitTeam; // this may get modified later is eTEam == NO_TEAM

	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	mov	DWORD PTR _eTeam$[ebp], edx

; 5053 : 
; 5054 : 	// First run special case for checking "node" since it doesn't have a parent set yet
; 5055 : 	bool bFirstRun = true;

	mov	BYTE PTR _bFirstRun$[ebp], 1

; 5056 : 
; 5057 : 	// Have to calculate this specially because the node passed into this function doesn't yet have data stored it in (hasn't reached pathAdd yet)
; 5058 : 	int iStartMoves = parent->m_iData1;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _iStartMoves$[ebp], ecx

; 5059 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5060 : 	int iNumTurns = parent->m_iData2;
; 5061 : #else
; 5062 : 	iNumTurns = parent->m_iData2;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iNumTurns$[ebp], eax

; 5063 : #endif
; 5064 : #if defined(AUI_ASTAR_TURN_LIMITER)
; 5065 : 	int iMaxTurns = finder->GetMaxTurns();
; 5066 : #endif
; 5067 : 
; 5068 : 	if(iStartMoves == 0)

	cmp	DWORD PTR _iStartMoves$[ebp], 0
	jne	SHORT $LN44@TacticalAn

; 5069 : 	{
; 5070 : 		iNumTurns++;

	mov	ecx, DWORD PTR _iNumTurns$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumTurns$[ebp], ecx
$LN44@TacticalAn:

; 5071 : 	}
; 5072 : 
; 5073 : 	iOldNumTurns = -1;

	mov	DWORD PTR _iOldNumTurns$[ebp], -1

; 5074 : 
; 5075 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5076 : 	CvAStarNode& kFromNodeCacheData = *parent;
; 5077 : #else
; 5078 : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 5079 : 
; 5080 : 	// Get a reference to the parent node cache data
; 5081 : 	CvPathNodeCacheData& kFromNodeCacheData = parent->m_kCostCacheData;

	mov	edx, DWORD PTR _parent$[ebp]
	add	edx, 88					; 00000058H
	mov	DWORD PTR _kFromNodeCacheData$[ebp], edx
$LN43@TacticalAn:

; 5082 : #endif
; 5083 : 
; 5084 : 	// Loop through the current path until we find the path origin.
; 5085 : 	// This validates the path with the inclusion of the new path node.  We must do this because of the rules of where a unit can finish a turn.
; 5086 : 	// Please note that this can be an expensive loop as the path gets longer and longer, do as little work as possible in validating each node.  
; 5087 : 	// If there is an invariant value that needs to be fetched from the plot or unit for the node, please do the calculation and put it in the node's data cache.
; 5088 : 	while(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN42@TacticalAn

; 5089 : 	{
; 5090 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5091 : 		if (iNumTurns > iMaxTurns)
; 5092 : 		{
; 5093 : 			return FALSE; // Path is too long, terminate now
; 5094 : 		}
; 5095 : #endif
; 5096 : 
; 5097 : 		PREFETCH_FASTAR_NODE(pNode->m_pParent);

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv326[ebp], ecx
	mov	edx, DWORD PTR tv326[ebp]
	prefetcht0 BYTE PTR [edx]
	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR tv330[ebp], ecx
	mov	edx, DWORD PTR tv330[ebp]
	prefetcht0 BYTE PTR [edx]

; 5098 : 
; 5099 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5100 : 		CvAStarNode& kNodeCacheData = *pNode;
; 5101 : #else
; 5102 : 		CvPathNodeCacheData& kNodeCacheData = pNode->m_kCostCacheData;

	mov	eax, DWORD PTR _pNode$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR _kNodeCacheData$220510[ebp], eax

; 5103 : #endif
; 5104 : 		// This is a safeguard against the algorithm believing a plot to be impassable before actually knowing it (mid-search)
; 5105 : 		if(iOldNumTurns != -1 || (iDestX == iNodeX && iDestY == iNodeY))

	cmp	DWORD PTR _iOldNumTurns$[ebp], -1
	jne	SHORT $LN40@TacticalAn
	mov	ecx, DWORD PTR _iDestX$[ebp]
	cmp	ecx, DWORD PTR _iNodeX$[ebp]
	jne	$LN41@TacticalAn
	mov	edx, DWORD PTR _iDestY$[ebp]
	cmp	edx, DWORD PTR _iNodeY$[ebp]
	jne	$LN41@TacticalAn
$LN40@TacticalAn:

; 5106 : 		{
; 5107 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5108 : 			if (!kNodeCacheData.bCanEnterTerrain)	// since this gets cached for each node anyway during buildup, it should be used whereever possible
; 5109 : 			{
; 5110 : 				return FALSE;
; 5111 : 			}
; 5112 : #endif
; 5113 : 			// This plot is of greater distance than previously, so we know the unit is ending its turn here (pNode), or it's trying to attack through a unit (and might end up on this tile if an attack fails to kill the enemy)
; 5114 : 			if(iNumTurns != iOldNumTurns || bPreviousNodeHostile)

	mov	eax, DWORD PTR _iNumTurns$[ebp]
	cmp	eax, DWORD PTR _iOldNumTurns$[ebp]
	jne	SHORT $LN38@TacticalAn
	movzx	ecx, BYTE PTR _bPreviousNodeHostile$[ebp]
	test	ecx, ecx
	je	$LN41@TacticalAn
$LN38@TacticalAn:

; 5115 : 			{
; 5116 : 				// Don't count origin, or else a unit will block its own movement!
; 5117 : 				if(iNodeX != iUnitX || iNodeY != iUnitY)

	mov	edx, DWORD PTR _iNodeX$[ebp]
	cmp	edx, DWORD PTR _iUnitX$[ebp]
	jne	SHORT $LN36@TacticalAn
	mov	eax, DWORD PTR _iNodeY$[ebp]
	cmp	eax, DWORD PTR _iUnitY$[ebp]
	je	$LN41@TacticalAn
$LN36@TacticalAn:

; 5118 : 				{
; 5119 : 					// PREFETCH_FASTAR_CVPLOT(reinterpret_cast<char*>(pPlot));
; 5120 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5121 : 					if (kNodeCacheData.bIsRevealedToTeam)
; 5122 : #else
; 5123 : 					if(kNodeCacheData.bPlotVisibleToTeam)

	mov	ecx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	dl, BYTE PTR [ecx]
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN35@TacticalAn

; 5124 : #endif
; 5125 : 					{
; 5126 : 						// Check to see if any units are present at this full-turn move plot... if the player can see what's there
; 5127 : 						if(kNodeCacheData.iNumFriendlyUnitsOfType >= iUnitPlotLimit && !(iFinderIgnoreStacking))

	mov	ecx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _iUnitPlotLimit$[ebp]
	jl	SHORT $LN34@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN34@TacticalAn

; 5128 : 						{
; 5129 : 							return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN34@TacticalAn:

; 5130 : 						}
; 5131 : 
; 5132 : #ifndef AUI_ASTAR_FIX_PATH_VALID_PATH_PEAKS_FOR_NONHUMAN
; 5133 : 						if (kNodeCacheData.bIsMountain && !(iFinderIgnoreStacking) && (!bIsHuman || bAIControl))

	mov	eax, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	cl, BYTE PTR [eax]
	shr	cl, 1
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN33@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN33@TacticalAn
	movzx	eax, BYTE PTR _bIsHuman$[ebp]
	test	eax, eax
	je	SHORT $LN32@TacticalAn
	movzx	ecx, BYTE PTR _bAIControl$[ebp]
	test	ecx, ecx
	je	SHORT $LN33@TacticalAn
$LN32@TacticalAn:

; 5134 : 						{
; 5135 : 							return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN33@TacticalAn:

; 5136 : 						}
; 5137 : #endif
; 5138 : 
; 5139 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5140 : 						if(kNodeCacheData.bIsMountain && !kNodeCacheData.bCanEnterTerrain)	// only doing canEnterTerrain on mountain plots because it is expensive, though it probably should always be called and some other checks in this loop could be removed.

	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 1
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN31@TacticalAn
	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 3
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN31@TacticalAn

; 5141 : 						{
; 5142 : 							return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN31@TacticalAn:

; 5143 : 						}
; 5144 : #endif
; 5145 : 
; 5146 : 						if ((finder->GetInfo() & CvUnit::MOVEFLAG_STAY_ON_LAND) && kNodeCacheData.bIsWater)

	mov	edx, DWORD PTR _finder$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR $T226505[ebp], eax
	mov	ecx, DWORD PTR $T226505[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN35@TacticalAn
	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 2
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@TacticalAn

; 5147 : 						{
; 5148 : 							return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN35@TacticalAn:

; 5149 : 						}
; 5150 : #ifndef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5151 : 					}
; 5152 : 
; 5153 : 					if(kNodeCacheData.bIsRevealedToTeam)

	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN41@TacticalAn

; 5154 : 					{
; 5155 : #endif
; 5156 : 						if (kNodeCacheData.bContainsOtherFriendlyTeamCity && !(iFinderIgnoreStacking))

	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 5
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN41@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN41@TacticalAn

; 5157 : 							return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN41@TacticalAn:

; 5158 : 					}
; 5159 : 				}
; 5160 : 			}
; 5161 : 		}
; 5162 : 
; 5163 : 		bPreviousNodeHostile = false;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 0

; 5164 : 		if(kNodeCacheData.bContainsEnemyCity)

	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 6
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN27@TacticalAn

; 5165 : 		{
; 5166 : 			bPreviousNodeHostile = true;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 1
	jmp	SHORT $LN26@TacticalAn
$LN27@TacticalAn:

; 5167 : 		}
; 5168 : 		// Prevents units from passing through one another on its way to attack another unit
; 5169 : 		else if(kNodeCacheData.bContainsVisibleEnemy)

	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@TacticalAn

; 5170 : 		{
; 5171 : 			// except when attacking an unguarded civilian unit
; 5172 : 			if(kNodeCacheData.bContainsVisibleEnemyDefender)

	mov	edx, DWORD PTR _kNodeCacheData$220510[ebp]
	mov	al, BYTE PTR [edx+1]
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@TacticalAn

; 5173 : 			{
; 5174 : 				bPreviousNodeHostile = true;

	mov	BYTE PTR _bPreviousNodeHostile$[ebp], 1
$LN26@TacticalAn:

; 5175 : 			}
; 5176 : 		}
; 5177 : 
; 5178 : 		// JON - Special case for the original node passed into this function because it's not yet linked to any parent
; 5179 : 		if(pNode == node && bFirstRun)

	mov	edx, DWORD PTR _pNode$[ebp]
	cmp	edx, DWORD PTR _node$[ebp]
	jne	SHORT $LN23@TacticalAn
	movzx	eax, BYTE PTR _bFirstRun$[ebp]
	test	eax, eax
	je	SHORT $LN23@TacticalAn

; 5180 : 		{
; 5181 : 			pNode = parent;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	DWORD PTR _pNode$[ebp], ecx

; 5182 : 			bFirstRun = false;

	mov	BYTE PTR _bFirstRun$[ebp], 0

; 5183 : 		}
; 5184 : 		else

	jmp	SHORT $LN22@TacticalAn
$LN23@TacticalAn:

; 5185 : 		{
; 5186 : 			pNode = pNode->m_pParent;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pNode$[ebp], eax
$LN22@TacticalAn:

; 5187 : 		}
; 5188 : 
; 5189 : 		if(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN21@TacticalAn

; 5190 : 		{
; 5191 : 
; 5192 : 			iNodeX = pNode->m_iX;

	mov	ecx, DWORD PTR _pNode$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	DWORD PTR _iNodeX$[ebp], edx

; 5193 : 			iNodeY = pNode->m_iY;

	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR _iNodeY$[ebp], ecx

; 5194 : 			iOldNumTurns = iNumTurns;

	mov	edx, DWORD PTR _iNumTurns$[ebp]
	mov	DWORD PTR _iOldNumTurns$[ebp], edx

; 5195 : 			iNumTurns = pNode->m_iData2;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _iNumTurns$[ebp], ecx
$LN21@TacticalAn:

; 5196 : 		}
; 5197 : 	}

	jmp	$LN43@TacticalAn
$LN42@TacticalAn:

; 5198 : 
; 5199 : 	// slewis - moved this up so units can't move directly into the water. Not 100% sure this is the right solution.
; 5200 : 	if(unit_domain_type == DOMAIN_LAND)

	cmp	DWORD PTR _unit_domain_type$[ebp], 2
	jne	$LN20@TacticalAn

; 5201 : 	{
; 5202 : 		if(!kFromNodeCacheData.bIsWater && kToNodeCacheData.bIsWater && kToNodeCacheData.bIsRevealedToTeam && !pUnit->canEmbarkOnto(*pFromPlot, *pToPlot, true))

	mov	edx, DWORD PTR _kFromNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 2
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@TacticalAn
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 2
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@TacticalAn
	mov	edx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	al, BYTE PTR [edx]
	shr	al, 4
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@TacticalAn
	push	0
	push	1
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@TacticalAn

; 5203 : 		{
; 5204 : #ifdef AUI_UNIT_FIX_HOVERING_EMBARK
; 5205 : 			if (!pUnit->canMoveAllTerrain())
; 5206 : #else
; 5207 : 			if(!pUnit->IsHoveringUnit() && !pUnit->canMoveAllTerrain() && !pToPlot->IsAllowsWalkWater())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@TacticalAn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN20@TacticalAn
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@TacticalAn

; 5208 : #endif
; 5209 : 			{
; 5210 : 				return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN20@TacticalAn:

; 5211 : 			}
; 5212 : 		}
; 5213 : 	}
; 5214 : 
; 5215 : #ifndef AUI_ASTAR_FIX_RADAR
; 5216 : 	if(!bUnitIsCombat && unit_domain_type != DOMAIN_AIR)
; 5217 : 	{
; 5218 : 		const PlayerTypes eUnitPlayer = unit_owner;
; 5219 : 		const int iUnitCount = pToPlot->getNumUnits();
; 5220 : 		for(int iUnit = 0; iUnit < iUnitCount; ++iUnit)
; 5221 : 		{
; 5222 : 			const CvUnit* pToPlotUnit = pToPlot->getUnitByIndex(iUnit);
; 5223 : 			if(pToPlotUnit != NULL && pToPlotUnit->getOwner() != eUnitPlayer)
; 5224 : 			{
; 5225 : 				return FALSE; // Plot occupied by another player
; 5226 : 			}
; 5227 : 		}
; 5228 : 	}
; 5229 : #endif
; 5230 : 
; 5231 : 	// slewis - Added to catch when the unit is adjacent to an enemy unit while it is stacked with a friendly unit.
; 5232 : 	//          The logic above (with bPreviousNodeHostile) catches this problem with a path that's longer than one step
; 5233 : 	//          but does not catch when the path is only one step.
; 5234 : #ifdef AUI_ASTAR_FIX_RADAR
; 5235 : 	if (unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))

	cmp	DWORD PTR _unit_domain_type$[ebp], 1
	je	SHORT $LN17@TacticalAn
	mov	edx, DWORD PTR _pToPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	call	?isAdjacent@CvPlot@@QBE_NPBV1@@Z	; CvPlot::isAdjacent
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@TacticalAn
	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN17@TacticalAn
	cmp	DWORD PTR _iFinderIgnoreStacking$[ebp], 0
	jne	SHORT $LN17@TacticalAn

; 5236 : #else
; 5237 : 	if(bUnitIsCombat && unit_domain_type != DOMAIN_AIR && pUnitPlot->isAdjacent(pToPlot) && kToNodeCacheData.bContainsVisibleEnemy && !(iFinderIgnoreStacking))
; 5238 : #endif
; 5239 : 	{
; 5240 : 		if(kToNodeCacheData.bContainsVisibleEnemyDefender)

	mov	ecx, DWORD PTR _kToNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN17@TacticalAn

; 5241 : 		{
; 5242 : 			if(pUnitPlot->getNumFriendlyUnitsOfType(pUnit) > iUnitPlotLimit)

	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnitPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR _iUnitPlotLimit$[ebp]
	jle	SHORT $LN17@TacticalAn

; 5243 : 			{
; 5244 : 				return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN17@TacticalAn:

; 5245 : 			}
; 5246 : 		}
; 5247 : 	}
; 5248 : 
; 5249 : 	if(pUnitPlot == pFromPlot)

	mov	edx, DWORD PTR _pUnitPlot$[ebp]
	cmp	edx, DWORD PTR _pFromPlot$[ebp]
	jne	SHORT $LN14@TacticalAn

; 5250 : 	{
; 5251 : 		return TRUE;

	mov	eax, 1
	jmp	$LN50@TacticalAn
$LN14@TacticalAn:

; 5252 : 	}
; 5253 : 
; 5254 : 	if(iFinderInfo & MOVE_TERRITORY_NO_UNEXPLORED)

	mov	eax, DWORD PTR _iFinderInfo$[ebp]
	and	eax, 1
	je	SHORT $LN13@TacticalAn

; 5255 : 	{
; 5256 : 		if(!kFromNodeCacheData.bIsRevealedToTeam)

	mov	ecx, DWORD PTR _kFromNodeCacheData$[ebp]
	mov	dl, BYTE PTR [ecx]
	shr	dl, 4
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN12@TacticalAn

; 5257 : 		{
; 5258 : 			return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN12@TacticalAn:

; 5259 : 		}
; 5260 : 
; 5261 : 		if(bFromPlotOwned)

	movzx	ecx, BYTE PTR _bFromPlotOwned$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@TacticalAn

; 5262 : 		{
; 5263 : 			if(eFromPlotTeam != eUnitTeam)

	mov	edx, DWORD PTR _eFromPlotTeam$[ebp]
	cmp	edx, DWORD PTR _eUnitTeam$[ebp]
	je	SHORT $LN13@TacticalAn

; 5264 : 			{
; 5265 : 				return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN13@TacticalAn:

; 5266 : 			}
; 5267 : 		}
; 5268 : 	}
; 5269 : 
; 5270 : 	if(iFinderInfo & MOVE_TERRITORY_NO_ENEMY)

	mov	eax, DWORD PTR _iFinderInfo$[ebp]
	and	eax, 2
	je	SHORT $LN9@TacticalAn

; 5271 : 	{
; 5272 : 		if(bFromPlotOwned)

	movzx	ecx, BYTE PTR _bFromPlotOwned$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@TacticalAn

; 5273 : 		{
; 5274 : 			if(atWar(eFromPlotTeam, eUnitTeam))

	mov	edx, DWORD PTR _eUnitTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR _eFromPlotTeam$[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@TacticalAn

; 5275 : 			{
; 5276 : 				return FALSE;

	xor	eax, eax
	jmp	$LN50@TacticalAn
$LN9@TacticalAn:

; 5277 : 			}
; 5278 : 		}
; 5279 : 	}
; 5280 : #ifndef ASTAR_AI_CONTROL_FIX_RADAR
; 5281 : 	if(bAIControl)
; 5282 : 	{
; 5283 : 		if((parent->m_iData2 > 1) || (parent->m_iData1 == 0))
; 5284 : 		{
; 5285 : 			if(!(iFinderInfo & MOVE_UNITS_IGNORE_DANGER))
; 5286 : 			{
; 5287 : 				if(!bUnitIsCombat || pUnit->getArmyID() == FFreeList::INVALID_INDEX)
; 5288 : 				{
; 5289 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_TO_PLOT_NOT_FROM_PLOT
; 5290 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH
; 5291 : #ifdef AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA
; 5292 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH &&
; 5293 : 						GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) <= pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5294 : #else
; 5295 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5296 : #endif
; 5297 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_ONLY_POSITIVE_DANGER_DELTA)
; 5298 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > 0 && GET_PLAYER(pUnit->getOwner()).GetPlotDanger(*pFromPlot) <= 0)
; 5299 : #else
; 5300 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pToPlot) > 0)
; 5301 : #endif
; 5302 : #elif defined(AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5303 : 					if (GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > pCacheData->baseCombatStrengthConsideringDamage() * AUI_ASTAR_FIX_CONSIDER_DANGER_USES_COMBAT_STRENGTH)
; 5304 : #else
; 5305 : 					if(GET_PLAYER(unit_owner).GetPlotDanger(*pFromPlot) > 0)
; 5306 : #endif
; 5307 : 					{
; 5308 : 						return FALSE;
; 5309 : 					}
; 5310 : 				}
; 5311 : 			}
; 5312 : 		}
; 5313 : 	}
; 5314 : #endif
; 5315 : 	// slewis - added AI check and embark check to prevent units from moving into unexplored areas
; 5316 : #ifdef ASTAR_AI_CONTROL_FIX_RADAR
; 5317 : 	if(!bIsHuman || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())

	movzx	edx, BYTE PTR _bIsHuman$[ebp]
	test	edx, edx
	je	SHORT $LN5@TacticalAn
	mov	eax, DWORD PTR _kFromNodeCacheData$[ebp]
	mov	cl, BYTE PTR [eax]
	shr	cl, 4
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN5@TacticalAn
	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+41]
	mov	BYTE PTR $T226509[ebp], cl
	movzx	edx, BYTE PTR $T226509[ebp]
	test	edx, edx
	je	SHORT $LN6@TacticalAn
$LN5@TacticalAn:

; 5318 : #else
; 5319 : 	if(bAIControl || !bIsHuman || kFromNodeCacheData.bIsRevealedToTeam || pCacheData->isEmbarked())
; 5320 : #endif
; 5321 : 	{
; 5322 : 		if(iFinderInfo & MOVE_UNITS_THROUGH_ENEMY)

	mov	eax, DWORD PTR _iFinderInfo$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN4@TacticalAn

; 5323 : 		{
; 5324 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5325 : 			if (!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 5326 : #else
; 5327 : 			if(!(pUnit->canMoveOrAttackInto(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	push	128					; 00000080H
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@TacticalAn

; 5328 : #endif
; 5329 : 			{
; 5330 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN50@TacticalAn
$LN3@TacticalAn:

; 5331 : 			}
; 5332 : 		}
; 5333 : 		else

	jmp	SHORT $LN6@TacticalAn
$LN4@TacticalAn:

; 5334 : 		{
; 5335 : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 5336 : 			if (!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE, kFromNodeCacheData.bCanEnterTerrain, true)))
; 5337 : #else
; 5338 : 			if(!(pUnit->canMoveThrough(*pFromPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE)))

	push	128					; 00000080H
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canMoveThrough@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveThrough
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@TacticalAn

; 5339 : #endif
; 5340 : 			{
; 5341 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN50@TacticalAn
$LN6@TacticalAn:

; 5342 : 			}
; 5343 : 		}
; 5344 : 	}
; 5345 : 
; 5346 : 	return TRUE;

	mov	eax, 1
$LN50@TacticalAn:

; 5347 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TacticalAnalysisMapPathValid
_TEXT	ENDS
PUBLIC	?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z ; FindValidDestinationDest
EXTRN	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z:PROC ; CvPlot::getNumVisibleEnemyDefenders
; Function compile flags: /Odtp
;	COMDAT ?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T226535 = -20						; size = 4
$T226521 = -16						; size = 4
$T226515 = -12						; size = 4
_pUnit$ = -8						; size = 4
_pToPlot$ = -4						; size = 4
_iToX$ = 8						; size = 4
_iToY$ = 12						; size = 4
_pointer$ = 16						; size = 4
_finder$ = 20						; size = 4
?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z PROC	; FindValidDestinationDest, COMDAT

; 5355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 5356 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 5357 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(iToX, iToY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226515[ebp], ecx
	mov	edx, DWORD PTR $T226515[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T226521[ebp], eax
	mov	ecx, DWORD PTR _iToY$[ebp]
	imul	ecx, DWORD PTR $T226521[ebp]
	add	ecx, DWORD PTR _iToX$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T226515[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pToPlot$[ebp], ecx

; 5358 : 
; 5359 : 	if(pToPlot->getNumFriendlyUnitsOfType(pUnit) >= GC.getPLOT_UNIT_LIMIT())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR $T226535[ebp], eax
	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR $T226535[ebp]
	jl	SHORT $LN3@FindValidD

; 5360 : 	{
; 5361 : #ifdef AUI_WARNING_FIXES
; 5362 : 		return FALSE;
; 5363 : #else
; 5364 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN4@FindValidD
$LN3@FindValidD:

; 5365 : #endif
; 5366 : 	}
; 5367 : 
; 5368 : 	if(pToPlot->getNumVisibleEnemyDefenders(pUnit) > 0)

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	test	eax, eax
	jle	SHORT $LN16@FindValidD

; 5369 : 	{
; 5370 : #ifdef AUI_WARNING_FIXES
; 5371 : 		return FALSE;
; 5372 : #else
; 5373 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN4@FindValidD

; 5374 : #endif
; 5375 : 	}
; 5376 : 
; 5377 : 	// can't capture the unit with a non-combat unit
; 5378 : 	if(!pUnit->IsCombatUnit() && pToPlot->isVisibleEnemyUnit(pUnit))

$LN16@FindValidD:
	mov	eax, DWORD PTR _pUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@FindValidD
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@FindValidD

; 5379 : 	{
; 5380 : #ifdef AUI_WARNING_FIXES
; 5381 : 		return FALSE;
; 5382 : 	}
; 5383 : 
; 5384 : 	return TRUE;
; 5385 : #else
; 5386 : 		return false;

	xor	eax, eax
	jmp	SHORT $LN4@FindValidD
$LN1@FindValidD:

; 5387 : 	}
; 5388 : 
; 5389 : 	return true;

	mov	eax, 1
$LN4@FindValidD:

; 5390 : #endif
; 5391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindValidDestinationDest@@YAHHHPBXPAVCvAStar@@@Z ENDP	; FindValidDestinationDest
_TEXT	ENDS
PUBLIC	?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; FindValidDestinationPathValid
; Function compile flags: /Odtp
;	COMDAT ?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T226555 = -16						; size = 4
$T226549 = -12						; size = 4
_pUnit$ = -8						; size = 4
_pToPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; FindValidDestinationPathValid, COMDAT

; 5395 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5396 : 	CvUnit* pUnit = ((CvUnit*)pointer);

	mov	eax, DWORD PTR _pointer$[ebp]
	mov	DWORD PTR _pUnit$[ebp], eax

; 5397 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5398 : 	const CvPlot* pToPlot = node->m_pPlot;
; 5399 : 	if (!pToPlot)
; 5400 : 		return FALSE;
; 5401 : #else
; 5402 : 	CvPlot* pToPlot = GC.getMap().plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226549[ebp], ecx
	mov	edx, DWORD PTR $T226549[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T226555[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T226555[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T226549[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pToPlot$[ebp], ecx

; 5403 : #endif
; 5404 : 
; 5405 : #ifdef AUI_ASTAR_FIX_FASTER_CHECKS
; 5406 : 	if (node->m_iData2 > 3)
; 5407 : 	{
; 5408 : 		return FALSE;
; 5409 : 	}
; 5410 : #endif
; 5411 : 
; 5412 : 	if(!pUnit->canEnterTerrain(*pToPlot, CvUnit::MOVEFLAG_PRETEND_CORRECT_EMBARK_STATE))

	push	128					; 00000080H
	mov	eax, DWORD PTR _pToPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEnterTerrain@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canEnterTerrain
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@FindValidD@2

; 5413 : 	{
; 5414 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN4@FindValidD@2
$LN3@FindValidD@2:

; 5415 : 	}
; 5416 : 
; 5417 : 	if(!PathValid(parent,node,data,pointer,finder))

	mov	edx, DWORD PTR _finder$[ebp]
	push	edx
	mov	eax, DWORD PTR _pointer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN2@FindValidD@2

; 5418 : 	{
; 5419 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN4@FindValidD@2
$LN2@FindValidD@2:

; 5420 : 	}
; 5421 : 
; 5422 : #ifndef AUI_ASTAR_FIX_FASTER_CHECKS
; 5423 : 	if(node->m_iData2 > 3)

	mov	ecx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [ecx+16], 3
	jle	SHORT $LN1@FindValidD@2

; 5424 : 	{
; 5425 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN4@FindValidD@2
$LN1@FindValidD@2:

; 5426 : 	}
; 5427 : #endif
; 5428 : 
; 5429 : 	return TRUE;

	mov	eax, 1
$LN4@FindValidD@2:

; 5430 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindValidDestinationPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; FindValidDestinationPathValid
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
PUBLIC	?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ; CanReachInXTurns
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z$0
__ehfuncinfo$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
_TEXT	SEGMENT
tv163 = -132						; size = 4
tv162 = -128						; size = 4
$T226702 = -124						; size = 4
$T226683 = -120						; size = 4
$T226670 = -116						; size = 4
$T226617 = -56						; size = 4
$T226608 = -52						; size = 4
$T226604 = -48						; size = 4
$T226595 = -44						; size = 4
$T226591 = -40						; size = 4
$T226587 = -36						; size = 4
$T226572 = -29						; size = 1
$T226571 = -28						; size = 4
$T226570 = -23						; size = 1
$T226569 = -22						; size = 1
$T226568 = -21						; size = 1
_iTurnsCalculated$220593 = -20				; size = 4
_iDistance$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_pTarget$ = 16						; size = 4
_iTurns$ = 20						; size = 4
_bIgnoreUnits$ = 24					; size = 1
_piTurns$ = 28						; size = 4
?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z PROC ; CanReachInXTurns, COMDAT

; 5499 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5500 : 	int iDistance;
; 5501 : 
; 5502 : 	if(!pTarget)

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $LN6@CanReachIn

; 5503 : 	{
; 5504 : 		return false;

	mov	BYTE PTR $T226568[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN12@CanReachIn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@CanReachIn:
	mov	al, BYTE PTR $T226568[ebp]
	jmp	$LN7@CanReachIn
$LN6@CanReachIn:

; 5505 : 	}
; 5506 : 
; 5507 : 	// Compare distance to movement rate
; 5508 : 	iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY());

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T226587[ebp], ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T226591[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226595[ebp], ecx
	mov	edx, DWORD PTR $T226595[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T226604[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226608[ebp], ecx
	mov	edx, DWORD PTR $T226608[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T226617[ebp], eax
	mov	ecx, DWORD PTR $T226587[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226591[ebp]
	push	edx
	mov	eax, DWORD PTR $T226604[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226617[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$[ebp], eax

; 5509 : 	// KWG: If the unit is a land unit that can embark, baseMoves() is only going to give correct value if the starting and ending locations
; 5510 : 	//		are in the same domain (LAND vs. SEA) and no transition occurs.
; 5511 : #ifdef AUI_ASTAR_TWEAKED_OPTIMIZED_BUT_CAN_STILL_USE_ROADS
; 5512 : 	int iBaseMoves = GetIncreasedMoveRangeForRoads(pUnit.pointer(), pUnit->baseMoves());
; 5513 : 	if (iTurns == 0 && iDistance >= iBaseMoves)
; 5514 : 	{
; 5515 : 		return false;
; 5516 : 	}
; 5517 : 
; 5518 : 	else if (iTurns > 0 && iDistance > (iBaseMoves * iTurns))
; 5519 : #else
; 5520 : 	if(iTurns == 0 && iDistance >= pUnit->baseMoves())

	cmp	DWORD PTR _iTurns$[ebp], 0
	jne	SHORT $LN5@CanReachIn
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226670[ebp], edx
	push	-1
	mov	ecx, DWORD PTR $T226670[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	cmp	DWORD PTR _iDistance$[ebp], eax
	jl	SHORT $LN5@CanReachIn

; 5521 : 	{
; 5522 : 		return false;

	mov	BYTE PTR $T226569[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN67@CanReachIn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@CanReachIn:
	mov	al, BYTE PTR $T226569[ebp]
	jmp	$LN7@CanReachIn
	jmp	$LN4@CanReachIn
$LN5@CanReachIn:

; 5523 : 	}
; 5524 : 
; 5525 : 	else if(iTurns > 0 && iDistance > (pUnit->baseMoves() * iTurns))

	cmp	DWORD PTR _iTurns$[ebp], 0
	jle	SHORT $LN3@CanReachIn
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226683[ebp], eax
	push	-1
	mov	ecx, DWORD PTR $T226683[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	imul	eax, DWORD PTR _iTurns$[ebp]
	cmp	DWORD PTR _iDistance$[ebp], eax
	jle	SHORT $LN3@CanReachIn

; 5526 : #endif
; 5527 : 	{
; 5528 : 		return false;

	mov	BYTE PTR $T226570[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN74@CanReachIn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN74@CanReachIn:
	mov	al, BYTE PTR $T226570[ebp]
	jmp	$LN7@CanReachIn

; 5529 : 	}
; 5530 : 
; 5531 : 	// Distance not too far, now use pathfinder
; 5532 : 	else

	jmp	$LN4@CanReachIn
$LN3@CanReachIn:

; 5533 : 	{
; 5534 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5535 : 		int iTurnsCalculated = TurnsToReachTarget(pUnit, pTarget, true /*bReusePaths*/, bIgnoreUnits, false, iTurns);
; 5536 : #else
; 5537 : 		int iTurnsCalculated = TurnsToReachTarget(pUnit, pTarget, false /*bReusePaths*/, bIgnoreUnits);

	push	0
	movzx	ecx, BYTE PTR _bIgnoreUnits$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T226571[ebp], esp
	mov	DWORD PTR $T226702[ebp], eax
	mov	ecx, DWORD PTR $T226702[ebp]
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T226702[ebp]
	mov	cl, BYTE PTR _pUnit$[ebp+4]
	mov	BYTE PTR [eax+4], cl
	mov	edx, DWORD PTR $T226702[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN79@CanReachIn
	mov	eax, DWORD PTR $T226702[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN79@CanReachIn:
	mov	ecx, DWORD PTR $T226702[ebp]
	mov	DWORD PTR tv162[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv163[ebp], eax
	mov	edx, DWORD PTR tv163[ebp]
	mov	DWORD PTR _iTurnsCalculated$220593[ebp], edx

; 5538 : #endif
; 5539 : 		if (piTurns)

	cmp	DWORD PTR _piTurns$[ebp], 0
	je	SHORT $LN1@CanReachIn

; 5540 : 			*piTurns = iTurnsCalculated;

	mov	eax, DWORD PTR _piTurns$[ebp]
	mov	ecx, DWORD PTR _iTurnsCalculated$220593[ebp]
	mov	DWORD PTR [eax], ecx
$LN1@CanReachIn:

; 5541 : 		return (iTurnsCalculated <= iTurns);

	mov	edx, DWORD PTR _iTurnsCalculated$220593[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _iTurns$[ebp]
	setle	al
	mov	BYTE PTR $T226572[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN84@CanReachIn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN84@CanReachIn:
	mov	al, BYTE PTR $T226572[ebp]
	jmp	SHORT $LN7@CanReachIn
$LN4@CanReachIn:

; 5542 : 	}
; 5543 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN7@CanReachIn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN7@CanReachIn:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanReachInXTurns@@YA_NV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@H_NPAH@Z ENDP ; CanReachInXTurns
EXTRN	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::GetTacticalAnalysisMapFinder
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z$0
__ehfuncinfo$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastar.cpp
xdata$x	ENDS
;	COMDAT ?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
_TEXT	SEGMENT
$T226851 = -116						; size = 4
$T226847 = -112						; size = 4
$T226838 = -108						; size = 4
$T226834 = -104						; size = 4
$T226825 = -100						; size = 4
$T226821 = -96						; size = 4
$T226817 = -92						; size = 4
$T226813 = -88						; size = 4
$T226808 = -84						; size = 4
$T226795 = -80						; size = 4
$T226791 = -76						; size = 4
$T226782 = -72						; size = 4
$T226778 = -68						; size = 4
$T226769 = -64						; size = 4
$T226765 = -60						; size = 4
$T226761 = -56						; size = 4
$T226757 = -52						; size = 4
$T226752 = -48						; size = 4
$T226736 = -44						; size = 4
$T226731 = -40						; size = 4
$T226730 = -36						; size = 4
$T226729 = -32						; size = 4
_iFlags$220612 = -28					; size = 4
_bSuccess$220616 = -21					; size = 1
_rtnValue$ = -20					; size = 4
_pNode$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_pTarget$ = 16						; size = 4
_bReusePaths$ = 20					; size = 1
_bIgnoreUnits$ = 24					; size = 1
_bIgnoreStacking$ = 28					; size = 1
?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z PROC ; TurnsToReachTarget, COMDAT

; 5563 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5564 : 	int rtnValue = MAX_INT;

	mov	DWORD PTR _rtnValue$[ebp], 2147483647	; 7fffffffH

; 5565 : 	CvAStarNode* pNode = NULL;

	mov	DWORD PTR _pNode$[ebp], 0

; 5566 : 
; 5567 : 	if(pTarget == pUnit->plot())

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226736[ebp], eax
	mov	ecx, DWORD PTR $T226736[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	DWORD PTR _pTarget$[ebp], eax
	jne	SHORT $LN22@TurnsToRea

; 5568 : 	{
; 5569 : 		return 0;

	mov	DWORD PTR $T226729[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN18@TurnsToRea
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN18@TurnsToRea:
	mov	eax, DWORD PTR $T226729[ebp]
	jmp	$LN12@TurnsToRea

; 5570 : 	}
; 5571 : 
; 5572 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5573 : 	if (pUnit && pTarget)
; 5574 : #else
; 5575 : 	if(pUnit)

$LN22@TurnsToRea:
	xor	ecx, ecx
	cmp	DWORD PTR _pUnit$[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN10@TurnsToRea

; 5576 : #endif
; 5577 : 	{
; 5578 : #ifdef PATH_FINDER_LOGGING
; 5579 : 		CvString strBaseString;
; 5580 : 		cvStopWatch kTimer(strBaseString, "Pathfinder.csv");
; 5581 : #endif
; 5582 : 
; 5583 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 5584 : 		int iFlags = 0;
; 5585 : 		if (bIgnoreStacking)
; 5586 : 		{
; 5587 : 			iFlags |= MOVE_IGNORE_STACKING;
; 5588 : 		}
; 5589 : 
; 5590 : 		CvAStar* pPathfinder = &GC.GetTacticalAnalysisMapFinder();
; 5591 : 		if (bIgnoreUnits)
; 5592 : 		{
; 5593 : 			pPathfinder = &GC.getIgnoreUnitsPathFinder();
; 5594 : 			iFlags |= MOVE_UNITS_IGNORE_DANGER;
; 5595 : 		}
; 5596 : #ifdef AUI_DANGER_PLOTS_REMADE
; 5597 : 		if (bForDanger)
; 5598 : 		{
; 5599 : 			pPathfinder = &GC.getDangerPathFinder();
; 5600 : 			iFlags |= MOVE_UNITS_IGNORE_DANGER;
; 5601 : 		}
; 5602 : #endif
; 5603 : 
; 5604 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5605 : 		if (!pFromPlot)
; 5606 : 			pFromPlot = pUnit->plot();
; 5607 : 		pPathfinder->SetData(pUnit.pointer(), iTargetTurns);
; 5608 : #else
; 5609 : 		pPathfinder->SetData(pUnit.pointer());
; 5610 : #endif
; 5611 : 		if (pPathfinder->GeneratePath(pFromPlot->getX(), pFromPlot->getY(), pTarget->getX(), pTarget->getY(), iFlags, bReusePaths))
; 5612 : 		{
; 5613 : 			pNode = pPathfinder->GetLastNode();
; 5614 : 		}
; 5615 : #else
; 5616 : 		if(bIgnoreUnits)

	movzx	eax, BYTE PTR _bIgnoreUnits$[ebp]
	test	eax, eax
	je	$LN9@TurnsToRea

; 5617 : 		{
; 5618 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5619 : 			if (!pFromPlot)
; 5620 : 				pFromPlot = pUnit->plot();
; 5621 : 			GC.getIgnoreUnitsPathFinder().SetData(pUnit.pointer(), iTargetTurns);
; 5622 : 			if (GC.getIgnoreUnitsPathFinder().GeneratePath(pFromPlot->getX(), pFromPlot->getY(), pTarget->getX(), pTarget->getY(), 0, bReusePaths))
; 5623 : #else
; 5624 : 			GC.getIgnoreUnitsPathFinder().SetData(pUnit.pointer());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226752[ebp], ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T226757[ebp], eax
	mov	edx, DWORD PTR $T226757[ebp]
	movzx	eax, BYTE PTR [edx+80]
	test	eax, eax
	je	SHORT $LN26@TurnsToRea
	mov	ecx, DWORD PTR $T226757[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR $T226752[ebp]
	je	SHORT $LN26@TurnsToRea
	mov	eax, DWORD PTR $T226757[ebp]
	mov	BYTE PTR [eax+78], 1
$LN26@TurnsToRea:
	mov	ecx, DWORD PTR $T226757[ebp]
	mov	edx, DWORD PTR $T226752[ebp]
	mov	DWORD PTR [ecx+44], edx

; 5625 : 			if (GC.getIgnoreUnitsPathFinder().GeneratePath(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY(), 0, bReusePaths))

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T226761[ebp], ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T226765[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226769[ebp], ecx
	mov	edx, DWORD PTR $T226769[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T226778[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226782[ebp], ecx
	mov	edx, DWORD PTR $T226782[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T226791[ebp], eax
	movzx	ecx, BYTE PTR _bReusePaths$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR $T226761[ebp]
	push	edx
	mov	eax, DWORD PTR $T226765[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226778[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226791[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@TurnsToRea

; 5626 : #endif
; 5627 : 			{
; 5628 : 				pNode = GC.getIgnoreUnitsPathFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T226795[ebp], eax
	mov	ecx, DWORD PTR $T226795[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$[ebp], edx
$LN8@TurnsToRea:

; 5629 : 			}
; 5630 : 		}
; 5631 : 		else

	jmp	$LN7@TurnsToRea
$LN9@TurnsToRea:

; 5632 : 		{
; 5633 : 			int iFlags = MOVE_UNITS_IGNORE_DANGER;

	mov	DWORD PTR _iFlags$220612[ebp], 8

; 5634 : 			if(bIgnoreStacking)

	movzx	eax, BYTE PTR _bIgnoreStacking$[ebp]
	test	eax, eax
	je	SHORT $LN6@TurnsToRea

; 5635 : 			{
; 5636 : 				iFlags |= MOVE_IGNORE_STACKING;

	mov	ecx, DWORD PTR _iFlags$220612[ebp]
	or	ecx, 4
	mov	DWORD PTR _iFlags$220612[ebp], ecx
$LN6@TurnsToRea:

; 5637 : 			}
; 5638 : 
; 5639 : 			CvAssertMsg(pTarget != NULL, "Passed in a NULL destination to GeneratePath");
; 5640 : 			if(pTarget == NULL)

	cmp	DWORD PTR _pTarget$[ebp], 0
	jne	SHORT $LN5@TurnsToRea

; 5641 : 			{
; 5642 : 				return false;

	mov	DWORD PTR $T226730[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN48@TurnsToRea
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN48@TurnsToRea:
	mov	eax, DWORD PTR $T226730[ebp]
	jmp	$LN12@TurnsToRea
$LN5@TurnsToRea:

; 5643 : 			}
; 5644 : 
; 5645 : 			bool bSuccess;
; 5646 : 
; 5647 : #ifdef AUI_ASTAR_TURN_LIMITER
; 5648 : 			if (!pFromPlot)
; 5649 : 				pFromPlot = pUnit->plot();
; 5650 : 			GC.GetTacticalAnalysisMapFinder().SetData(pUnit.pointer(), iTargetTurns);
; 5651 : 			bSuccess = GC.GetTacticalAnalysisMapFinder().GeneratePath(pFromPlot->getX(), pFromPlot->getY(), pTarget->getX(), pTarget->getY(), iFlags, bReusePaths);
; 5652 : #else
; 5653 : 			GC.GetTacticalAnalysisMapFinder().SetData(pUnit.pointer());

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226808[ebp], edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	DWORD PTR $T226813[ebp], eax
	mov	eax, DWORD PTR $T226813[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN54@TurnsToRea
	mov	edx, DWORD PTR $T226813[ebp]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, DWORD PTR $T226808[ebp]
	je	SHORT $LN54@TurnsToRea
	mov	ecx, DWORD PTR $T226813[ebp]
	mov	BYTE PTR [ecx+78], 1
$LN54@TurnsToRea:
	mov	edx, DWORD PTR $T226813[ebp]
	mov	eax, DWORD PTR $T226808[ebp]
	mov	DWORD PTR [edx+44], eax

; 5654 : 			bSuccess = GC.GetTacticalAnalysisMapFinder().GeneratePath(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY(), iFlags, bReusePaths);

	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T226817[ebp], edx
	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T226821[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226825[ebp], edx
	mov	eax, DWORD PTR $T226825[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T226834[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T226838[ebp], edx
	mov	eax, DWORD PTR $T226838[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T226847[ebp], ecx
	movzx	edx, BYTE PTR _bReusePaths$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlags$220612[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226817[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226821[ebp]
	push	edx
	mov	eax, DWORD PTR $T226834[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226847[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bSuccess$220616[ebp], al

; 5655 : #endif
; 5656 : 			if(bSuccess)

	movzx	edx, BYTE PTR _bSuccess$220616[ebp]
	test	edx, edx
	je	SHORT $LN7@TurnsToRea

; 5657 : 			{
; 5658 : 				pNode = GC.GetTacticalAnalysisMapFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	DWORD PTR $T226851[ebp], eax
	mov	eax, DWORD PTR $T226851[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[ebp], ecx
$LN7@TurnsToRea:

; 5659 : 			}
; 5660 : 		}
; 5661 : #endif
; 5662 : 
; 5663 : 		if(pNode)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN10@TurnsToRea

; 5664 : 		{
; 5665 : 			rtnValue = pNode->m_iData2;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 5666 : 			if(rtnValue == 1)

	cmp	DWORD PTR _rtnValue$[ebp], 1
	jne	SHORT $LN10@TurnsToRea

; 5667 : 			{
; 5668 : 				if(pNode->m_iData1 > 0)

	mov	ecx, DWORD PTR _pNode$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN10@TurnsToRea

; 5669 : 				{
; 5670 : 					rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0
$LN10@TurnsToRea:

; 5671 : 				}
; 5672 : 			}
; 5673 : 		}
; 5674 : 
; 5675 : #ifdef PATH_FINDER_LOGGING
; 5676 : 		// NOTE: because I'm creating the string after the cvStopWatch, the time it takes to create the string will be in the timer.
; 5677 : 		strBaseString.Format("TurnsToReachTarget, Turn %03d, Player: %d, Unit: %d, From X: %d, Y: %d, To X: %d, Y: %d, reuse=%d, ignoreUnits=%d, ignoreStacking=%d, turns=%d", GC.getGame().getElapsedGameTurns(), (int)pUnit->getOwner(), pUnit->GetID(), pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY(), bReusePaths?1:0, bIgnoreUnits?1:0, bIgnoreStacking?1:0, rtnValue);
; 5678 : 		kTimer.SetText(strBaseString);
; 5679 : #endif
; 5680 : 	}
; 5681 : 
; 5682 : 	return rtnValue;

	mov	edx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR $T226731[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN76@TurnsToRea
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN76@TurnsToRea:
	mov	eax, DWORD PTR $T226731[ebp]
$LN12@TurnsToRea:

; 5683 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ENDP ; TurnsToReachTarget
PUBLIC	?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z	; TradePathInitialize
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
; Function compile flags: /Odtp
;	COMDAT ?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T226896 = -22						; size = 1
$T226892 = -21						; size = 1
_ePlayer$ = -20						; size = 4
_pCacheData$ = -16					; size = 4
_pPlayerTraits$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_kPlayer$ = -4						; size = 4
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z PROC		; TradePathInitialize, COMDAT

; 5708 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 5709 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 5710 : 	PlayerTypes ePlayer = PlayerTypes(finder->GetInfo() & 0x7f);
; 5711 : 	PlayerTypes eToPlayer = (PlayerTypes)(finder->GetInfo() >> 8);
; 5712 : #else
; 5713 : 	PlayerTypes ePlayer = (PlayerTypes)finder->GetInfo();

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 5714 : #endif
; 5715 : 
; 5716 : 	TradePathCacheData* pCacheData = reinterpret_cast<TradePathCacheData*>(finder->GetScratchBuffer());

	mov	edx, DWORD PTR _finder$[ebp]
	add	edx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], edx

; 5717 : 
; 5718 : 	CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], eax

; 5719 : 	TeamTypes eTeam = kPlayer.getTeam();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 5720 : 	pCacheData->m_pTeam = &GET_TEAM(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	DWORD PTR [ecx], eax

; 5721 : 	pCacheData->m_bCanEmbarkAllWaterPassage = pCacheData->m_pTeam->canEmbarkAllWaterPassage();

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [ecx+4], al

; 5722 : 
; 5723 : 	CvPlayerTraits* pPlayerTraits = kPlayer.GetPlayerTraits();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR _pPlayerTraits$[ebp], eax

; 5724 : 	if (pPlayerTraits)

	cmp	DWORD PTR _pPlayerTraits$[ebp], 0
	je	SHORT $LN2@TradePathI

; 5725 : 	{
; 5726 : 		pCacheData->m_bIsRiverTradeRoad = pPlayerTraits->IsRiverTradeRoad();

	mov	edx, DWORD PTR _pPlayerTraits$[ebp]
	mov	al, BYTE PTR [edx+354]
	mov	BYTE PTR $T226892[ebp], al
	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR $T226892[ebp]
	mov	BYTE PTR [ecx+5], dl

; 5727 : 		pCacheData->m_bIsMoveFriendlyWoodsAsRoad = pPlayerTraits->IsMoveFriendlyWoodsAsRoad();

	mov	eax, DWORD PTR _pPlayerTraits$[ebp]
	mov	cl, BYTE PTR [eax+333]
	mov	BYTE PTR $T226896[ebp], cl
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR $T226896[ebp]
	mov	BYTE PTR [edx+6], al

; 5728 : 	}
; 5729 : 	else

	jmp	SHORT $LN3@TradePathI
$LN2@TradePathI:

; 5730 : 	{
; 5731 : 		pCacheData->m_bIsRiverTradeRoad = false;

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [ecx+5], 0

; 5732 : 		pCacheData->m_bIsMoveFriendlyWoodsAsRoad = false;

	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	BYTE PTR [edx+6], 0
$LN3@TradePathI:

; 5733 : 	}
; 5734 : 
; 5735 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 5736 : 	pCacheData->m_pToPlayer = &GET_PLAYER(eToPlayer);
; 5737 : #endif
; 5738 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z ENDP		; TradePathInitialize
_TEXT	ENDS
PUBLIC	?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z	; TradePathUninitialize
; Function compile flags: /Odtp
;	COMDAT ?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_finder$ = 12						; size = 4
?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z PROC	; TradePathUninitialize, COMDAT

; 5742 : {

	push	ebp
	mov	ebp, esp

; 5743 : 
; 5744 : }

	pop	ebp
	ret	0
?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z ENDP	; TradePathUninitialize
_TEXT	ENDS
PUBLIC	?TradeRouteHeuristic@@YAHHHHH@Z			; TradeRouteHeuristic
; Function compile flags: /Odtp
;	COMDAT ?TradeRouteHeuristic@@YAHHHHH@Z
_TEXT	SEGMENT
_iFromX$ = 8						; size = 4
_iFromY$ = 12						; size = 4
_iToX$ = 16						; size = 4
_iToY$ = 20						; size = 4
?TradeRouteHeuristic@@YAHHHHH@Z PROC			; TradeRouteHeuristic, COMDAT

; 5748 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 5749 : 	return plotDistance(iFromX, iFromY, iToX, iToY) * 100;

	mov	eax, DWORD PTR _iToY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iToX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFromY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFromX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	imul	eax, 100				; 00000064H

; 5750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TradeRouteHeuristic@@YAHHHHH@Z ENDP			; TradeRouteHeuristic
_TEXT	ENDS
PUBLIC	?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandPathCost
; Function compile flags: /Odtp
;	COMDAT ?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T227051 = -63						; size = 1
$T227041 = -62						; size = 1
_f$227034 = -61						; size = 1
$T227015 = -60						; size = 4
$T226999 = -56						; size = 4
_bFeaturePenalty$220696 = -49				; size = 1
_kMap$ = -48						; size = 4
_ePlayer$ = -44						; size = 4
_iFromPlotX$ = -40					; size = 4
_iFromPlotY$ = -36					; size = 4
_pCacheData$ = -32					; size = 4
_iToPlotX$ = -28					; size = 4
_iBaseCost$ = -24					; size = 4
_pFromPlot$ = -20					; size = 4
_iToPlotY$ = -16					; size = 4
_iCost$ = -12						; size = 4
_eFeature$ = -8						; size = 4
_pToPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteLandPathCost, COMDAT

; 5754 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 5755 : 	PlayerTypes ePlayer = (PlayerTypes)finder->GetInfo();

	mov	eax, DWORD PTR _finder$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR _ePlayer$[ebp], ecx

; 5756 : 
; 5757 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5758 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 5759 : 	const CvPlot* pToPlot = node->m_pPlot;
; 5760 : #else
; 5761 : 	CvMap& kMap = GC.getMap();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], edx

; 5762 : 	int iFromPlotX = parent->m_iX;

	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR _iFromPlotX$[ebp], ecx

; 5763 : 	int iFromPlotY = parent->m_iY;

	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+82]
	mov	DWORD PTR _iFromPlotY$[ebp], eax

; 5764 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T226999[ebp], edx
	mov	eax, DWORD PTR _iFromPlotY$[ebp]
	imul	eax, DWORD PTR $T226999[ebp]
	add	eax, DWORD PTR _iFromPlotX$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pFromPlot$[ebp], eax

; 5765 : 
; 5766 : 	int iToPlotX = node->m_iX;

	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR _iToPlotX$[ebp], eax

; 5767 : 	int iToPlotY = node->m_iY;

	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR _iToPlotY$[ebp], edx

; 5768 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227015[ebp], ecx
	mov	edx, DWORD PTR _iToPlotY$[ebp]
	imul	edx, DWORD PTR $T227015[ebp]
	add	edx, DWORD PTR _iToPlotX$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pToPlot$[ebp], edx

; 5769 : #endif
; 5770 : 
; 5771 : 	int iBaseCost = 100;

	mov	DWORD PTR _iBaseCost$[ebp], 100		; 00000064H

; 5772 : 	int iCost = iBaseCost;

	mov	ecx, DWORD PTR _iBaseCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], ecx

; 5773 : 
; 5774 : 	const TradePathCacheData* pCacheData = reinterpret_cast<const TradePathCacheData*>(finder->GetScratchBuffer());

	mov	edx, DWORD PTR _finder$[ebp]
	add	edx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], edx

; 5775 : 	FeatureTypes eFeature = pToPlot->getFeatureType();

	mov	eax, DWORD PTR _pToPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$227034[ebp], cl
	movsx	edx, BYTE PTR _f$227034[ebp]
	mov	DWORD PTR _eFeature$[ebp], edx

; 5776 : 
; 5777 : 	// super duper low costs for moving along routes
; 5778 : 	if (pFromPlot->getRouteType() != NO_ROUTE && pToPlot->getRouteType() != NO_ROUTE)

	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN15@TradeRoute
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN15@TradeRoute

; 5779 : 	{
; 5780 : 		iCost = iCost / 2;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iCost$[ebp], eax
	jmp	$LN50@TradeRoute
$LN15@TradeRoute:

; 5781 : 	}
; 5782 : 	//// super low costs for moving along rivers
; 5783 : 	else if (pCacheData->IsRiverTradeRoad() && pFromPlot->isRiver() && pToPlot->isRiver())

	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+5]
	mov	BYTE PTR $T227041[ebp], cl
	movzx	edx, BYTE PTR $T227041[ebp]
	test	edx, edx
	je	SHORT $LN13@TradeRoute
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN13@TradeRoute
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+457]
	xor	eax, eax
	test	edx, edx
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@TradeRoute

; 5784 : 	{
; 5785 : 		iCost = iCost / 2;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iCost$[ebp], eax
	jmp	SHORT $LN50@TradeRoute
$LN13@TradeRoute:

; 5786 : 	}
; 5787 : 	// Iroquios ability
; 5788 : 	else if ((eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE) && pCacheData->IsMoveFriendlyWoodsAsRoad())

	cmp	DWORD PTR _eFeature$[ebp], 5
	je	SHORT $LN10@TradeRoute
	cmp	DWORD PTR _eFeature$[ebp], 1
	jne	SHORT $LN11@TradeRoute
$LN10@TradeRoute:
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	al, BYTE PTR [edx+6]
	mov	BYTE PTR $T227051[ebp], al
	movzx	ecx, BYTE PTR $T227051[ebp]
	test	ecx, ecx
	je	SHORT $LN11@TradeRoute

; 5789 : 	{
; 5790 : 		iCost = iCost / 2;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iCost$[ebp], eax

; 5791 : 	}
; 5792 : 	else

	jmp	SHORT $LN50@TradeRoute
$LN11@TradeRoute:

; 5793 : 	{
; 5794 : 		bool bFeaturePenalty = false;

	mov	BYTE PTR _bFeaturePenalty$220696[ebp], 0

; 5795 : 		if (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE || eFeature == FEATURE_ICE)

	cmp	DWORD PTR _eFeature$[ebp], 5
	je	SHORT $LN7@TradeRoute
	cmp	DWORD PTR _eFeature$[ebp], 1
	je	SHORT $LN7@TradeRoute
	cmp	DWORD PTR _eFeature$[ebp], 0
	jne	SHORT $LN48@TradeRoute
$LN7@TradeRoute:

; 5796 : 		{
; 5797 : 			bFeaturePenalty = true;

	mov	BYTE PTR _bFeaturePenalty$220696[ebp], 1

; 5798 : 		}
; 5799 : 
; 5800 : 		if (pToPlot->isHills() || bFeaturePenalty)

$LN48@TradeRoute:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@TradeRoute
	movzx	edx, BYTE PTR _bFeaturePenalty$220696[ebp]
	test	edx, edx
	je	SHORT $LN6@TradeRoute
$LN5@TradeRoute:

; 5801 : 		{
; 5802 : 			iCost += 1;

	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCost$[ebp], eax
$LN6@TradeRoute:

; 5803 : 		}
; 5804 : 
; 5805 : 		// extra cost for not going to an oasis! (this encourages routes to go through oasis)
; 5806 : 		if (eFeature != FEATURE_OASIS)

	cmp	DWORD PTR _eFeature$[ebp], 3
	je	SHORT $LN50@TradeRoute

; 5807 : 		{
; 5808 : 			iCost += 1;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCost$[ebp], ecx

; 5809 : 		}
; 5810 : 	}
; 5811 : 
; 5812 : #ifdef AUI_ASTAR_TRADE_ROUTE_COST_TILE_OWNERSHIP_PREFS
; 5813 : 	if (pToPlot->isOwned())
; 5814 : 	{
; 5815 : 		if (pToPlot->getTeam() == pCacheData->getToPlayer().getTeam() || pToPlot->getTeam() == pCacheData->getTeam().GetID())
; 5816 : 		{
; 5817 : 			iCost /= 2;
; 5818 : 		}
; 5819 : 		else
; 5820 : 		{
; 5821 : 			iCost *= 2;
; 5822 : 			iCost += 1;
; 5823 : 		}
; 5824 : 	}
; 5825 : #endif
; 5826 : 
; 5827 : 	if (pToPlot->isWater() && !pToPlot->IsAllowsWalkWater())

$LN50@TradeRoute:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN52@TradeRoute
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN52@TradeRoute

; 5828 : 	{
; 5829 : 		iCost += 1000;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], ecx

; 5830 : 	}
; 5831 : 	
; 5832 : 	// Penalty for ending a turn on a mountain
; 5833 : 	if(pToPlot->isImpassable() || pToPlot->isMountain())

$LN52@TradeRoute:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@TradeRoute
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@TradeRoute
$LN1@TradeRoute:

; 5834 : 	{
; 5835 : 		iCost += 1000;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], edx
$LN2@TradeRoute:

; 5836 : 	}
; 5837 : 
; 5838 : 	FAssert(iCost != MAX_INT);
; 5839 : 	FAssert(iCost > 0);
; 5840 : 
; 5841 : 	return iCost;

	mov	eax, DWORD PTR _iCost$[ebp]

; 5842 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteLandPathCost
_TEXT	ENDS
PUBLIC	?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandValid
; Function compile flags: /Odtp
;	COMDAT ?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T227109 = -28						; size = 4
$T227105 = -24						; size = 4
$T227101 = -20						; size = 4
$T227090 = -16						; size = 4
$T227074 = -12						; size = 4
_kMap$ = -8						; size = 4
_pNewPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteLandValid, COMDAT

; 5846 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 5847 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN5@TradeRoute@2

; 5848 : 	{
; 5849 : 		return TRUE;

	mov	eax, 1
	jmp	$LN6@TradeRoute@2
$LN5@TradeRoute@2:

; 5850 : 	}
; 5851 : 
; 5852 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5853 : 	const CvPlot* pOldPlot = parent->m_pPlot;
; 5854 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 5855 : 	if (!pOldPlot || !pNewPlot)
; 5856 : 		return FALSE;
; 5857 : 
; 5858 : 	if (pOldPlot->getArea() != pNewPlot->getArea())
; 5859 : #else
; 5860 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 5861 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T227074[ebp], edx
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	edx, DWORD PTR _node$[ebp]
	movsx	eax, WORD PTR [edx+82]
	imul	eax, DWORD PTR $T227074[ebp]
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _kMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pNewPlot$[ebp], eax

; 5862 : 
; 5863 : 	if(kMap.plotUnchecked(parent->m_iX, parent->m_iY)->getArea() != pNewPlot->getArea())

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T227090[ebp], eax
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T227090[ebp]
	mov	eax, DWORD PTR _parent$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	add	edx, ecx
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR $T227101[ebp], edx
	mov	ecx, DWORD PTR $T227101[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T227105[ebp], edx
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T227109[ebp], ecx
	mov	edx, DWORD PTR $T227105[ebp]
	cmp	edx, DWORD PTR $T227109[ebp]
	je	SHORT $LN26@TradeRoute@2

; 5864 : #endif
; 5865 : 	{
; 5866 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@TradeRoute@2

; 5867 : 	}
; 5868 : 
; 5869 : 	if (pNewPlot->isWater())

$LN26@TradeRoute@2:
	mov	eax, DWORD PTR _pNewPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN28@TradeRoute@2

; 5870 : 	{
; 5871 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@TradeRoute@2

; 5872 : 	}
; 5873 : 
; 5874 : #ifdef AUI_ASTAR_FIX_STEP_VALID_CONSIDERS_MOUNTAINS
; 5875 : 	if (pNewPlot->isImpassable())
; 5876 : #else
; 5877 : 	if(pNewPlot->isMountain() || pNewPlot->isImpassable())

$LN28@TradeRoute@2:
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN1@TradeRoute@2
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@TradeRoute@2
$LN1@TradeRoute@2:

; 5878 : #endif
; 5879 : 	{
; 5880 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN6@TradeRoute@2
$LN2@TradeRoute@2:

; 5881 : 	}
; 5882 : 
; 5883 : 	return TRUE;

	mov	eax, 1
$LN6@TradeRoute@2:

; 5884 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteLandValid
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterPathCost
; Function compile flags: /Odtp
;	COMDAT ?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
tv128 = -84						; size = 4
$T227206 = -77						; size = 1
$T227202 = -76						; size = 4
$T227198 = -72						; size = 4
$T227191 = -68						; size = 4
_playerID$227180 = -64					; size = 4
$T227150 = -56						; size = 4
$T227134 = -52						; size = 4
_eToPlotTeam$220740 = -48				; size = 4
_bIsAdjacentToLand$220738 = -41				; size = 1
_kMap$ = -40						; size = 4
_iFromPlotX$ = -36					; size = 4
_pCacheData$ = -32					; size = 4
_iFromPlotY$ = -28					; size = 4
_iToPlotX$ = -24					; size = 4
_iBaseCost$ = -20					; size = 4
_pFromPlot$ = -16					; size = 4
_iToPlotY$ = -12					; size = 4
_iCost$ = -8						; size = 4
_pToPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteWaterPathCost, COMDAT

; 5889 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 5890 : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5891 : 	CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 5892 : #endif
; 5893 : 	const TradePathCacheData* pCacheData = reinterpret_cast<const TradePathCacheData*>(finder->GetScratchBuffer());

	mov	ecx, DWORD PTR _finder$[ebp]
	add	ecx, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], ecx

; 5894 : 
; 5895 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5896 : 	const CvPlot* pFromPlot = parent->m_pPlot;
; 5897 : 	const CvPlot* pToPlot = node->m_pPlot;
; 5898 : #else
; 5899 : 	int iFromPlotX = parent->m_iX;

	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR _iFromPlotX$[ebp], eax

; 5900 : 	int iFromPlotY = parent->m_iY;

	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR _iFromPlotY$[ebp], edx

; 5901 : 	CvPlot* pFromPlot = kMap.plotUnchecked(iFromPlotX, iFromPlotY);

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227134[ebp], ecx
	mov	edx, DWORD PTR _iFromPlotY$[ebp]
	imul	edx, DWORD PTR $T227134[ebp]
	add	edx, DWORD PTR _iFromPlotX$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pFromPlot$[ebp], edx

; 5902 : 
; 5903 : 	int iToPlotX = node->m_iX;

	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	DWORD PTR _iToPlotX$[ebp], edx

; 5904 : 	int iToPlotY = node->m_iY;

	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR _iToPlotY$[ebp], ecx

; 5905 : 	CvPlot* pToPlot = kMap.plotUnchecked(iToPlotX, iToPlotY);

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T227150[ebp], eax
	mov	ecx, DWORD PTR _iToPlotY$[ebp]
	imul	ecx, DWORD PTR $T227150[ebp]
	add	ecx, DWORD PTR _iToPlotX$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pToPlot$[ebp], ecx

; 5906 : #endif
; 5907 : 
; 5908 : 	int iBaseCost = 100;

	mov	DWORD PTR _iBaseCost$[ebp], 100		; 00000064H

; 5909 : 	int iCost = iBaseCost;

	mov	eax, DWORD PTR _iBaseCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 5910 : 
; 5911 : 	if (!pToPlot->isCity())

	mov	ecx, DWORD PTR _pToPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN8@TradeRoute@3

; 5912 : 	{
; 5913 : 		bool bIsAdjacentToLand = pFromPlot->isAdjacentToLand_Cached() && pToPlot->isAdjacentToLand_Cached();

	mov	edx, DWORD PTR _pFromPlot$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 6
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@TradeRoute@3
	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 6
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@TradeRoute@3
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN12@TradeRoute@3
$LN11@TradeRoute@3:
	mov	DWORD PTR tv128[ebp], 0
$LN12@TradeRoute@3:
	mov	dl, BYTE PTR tv128[ebp]
	mov	BYTE PTR _bIsAdjacentToLand$220738[ebp], dl

; 5914 : 		if (!bIsAdjacentToLand)

	movzx	eax, BYTE PTR _bIsAdjacentToLand$220738[ebp]
	test	eax, eax
	jne	SHORT $LN42@TradeRoute@3

; 5915 : 		{
; 5916 : 			iCost += 1;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCost$[ebp], ecx

; 5917 : 		}
; 5918 : 
; 5919 : 		// if is enemy tile, avoid
; 5920 : 		TeamTypes eToPlotTeam = pToPlot->getTeam();

$LN42@TradeRoute@3:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$227180[ebp], eax
	cmp	DWORD PTR _playerID$227180[ebp], -1
	je	SHORT $LN39@TradeRoute@3
	mov	ecx, DWORD PTR _playerID$227180[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eToPlotTeam$220740[ebp], eax
	jmp	SHORT $LN40@TradeRoute@3
	jmp	SHORT $LN40@TradeRoute@3
$LN39@TradeRoute@3:
	mov	DWORD PTR _eToPlotTeam$220740[ebp], -1
$LN40@TradeRoute@3:

; 5921 : 		if (eToPlotTeam != NO_TEAM && pCacheData->getTeam().isAtWar(eToPlotTeam))

	cmp	DWORD PTR _eToPlotTeam$220740[ebp], -1
	je	SHORT $LN48@TradeRoute@3
	mov	edx, DWORD PTR _pCacheData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227191[ebp], eax
	mov	ecx, DWORD PTR _eToPlotTeam$220740[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227191[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN48@TradeRoute@3

; 5922 : 		{
; 5923 : 			iCost += 1000; // slewis - is this too prohibitive? Too cheap?

	mov	eax, DWORD PTR _iCost$[ebp]
	add	eax, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], eax

; 5924 : 		}
; 5925 : 
; 5926 : 		if (!pToPlot->isWater())

$LN48@TradeRoute@3:
	mov	ecx, DWORD PTR _pToPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@TradeRoute@3

; 5927 : 		{
; 5928 : 			iCost += 1000;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], edx

; 5929 : 		}
; 5930 : 		else

	jmp	SHORT $LN56@TradeRoute@3
$LN5@TradeRoute@3:

; 5931 : 		{
; 5932 : 			if (pToPlot->getTerrainType() != (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN())	// Quicker isShallowWater test, since we already know the plot is water

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR $T227198[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR $T227202[ebp], edx
	mov	eax, DWORD PTR $T227198[ebp]
	cmp	eax, DWORD PTR $T227202[ebp]
	je	SHORT $LN56@TradeRoute@3

; 5933 : 			{
; 5934 : 				if (!pCacheData->CanEmbarkAllWaterPassage())

	mov	ecx, DWORD PTR _pCacheData$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR $T227206[ebp], dl
	movzx	eax, BYTE PTR $T227206[ebp]
	test	eax, eax
	jne	SHORT $LN56@TradeRoute@3

; 5935 : 				{
; 5936 : 					iCost += 1000;

	mov	ecx, DWORD PTR _iCost$[ebp]
	add	ecx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], ecx

; 5937 : 				}
; 5938 : 			}
; 5939 : 		}
; 5940 : 
; 5941 : 		if(pToPlot->isImpassable())

$LN56@TradeRoute@3:
	mov	edx, DWORD PTR _pToPlot$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@TradeRoute@3

; 5942 : 		{
; 5943 : 			iCost += 1000;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, 1000				; 000003e8H
	mov	DWORD PTR _iCost$[ebp], edx
$LN8@TradeRoute@3:

; 5944 : 		}
; 5945 : 	}
; 5946 : 
; 5947 : 	FAssert(iCost != MAX_INT);
; 5948 : 	FAssert(iCost > 0);
; 5949 : 
; 5950 : 	return iCost;

	mov	eax, DWORD PTR _iCost$[ebp]

; 5951 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteWaterPathCost
_TEXT	ENDS
PUBLIC	?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterValid
; Function compile flags: /Odtp
;	COMDAT ?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z
_TEXT	SEGMENT
$T227282 = -52						; size = 4
$T227278 = -48						; size = 4
$T227259 = -40						; size = 4
$T227253 = -33						; size = 1
$T227249 = -32						; size = 4
$T227245 = -28						; size = 4
$T227223 = -20						; size = 4
_pParentPlot$220765 = -16				; size = 4
_kMap$ = -12						; size = 4
_pCacheData$ = -8					; size = 4
_pNewPlot$ = -4						; size = 4
_parent$ = 8						; size = 4
_node$ = 12						; size = 4
_data$ = 16						; size = 4
_pointer$ = 20						; size = 4
_finder$ = 24						; size = 4
?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z PROC ; TradeRouteWaterValid, COMDAT

; 5955 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 5956 : 	if(parent == NULL)

	cmp	DWORD PTR _parent$[ebp], 0
	jne	SHORT $LN11@TradeRoute@4

; 5957 : 	{
; 5958 : 		return TRUE;

	mov	eax, 1
	jmp	$LN9@TradeRoute@4

; 5959 : 	}
; 5960 : 
; 5961 : 	const TradePathCacheData* pCacheData = reinterpret_cast<const TradePathCacheData*>(finder->GetScratchBuffer());

$LN11@TradeRoute@4:
	mov	eax, DWORD PTR _finder$[ebp]
	add	eax, 116				; 00000074H
	mov	DWORD PTR _pCacheData$[ebp], eax

; 5962 : 
; 5963 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5964 : 	const CvPlot* pNewPlot = node->m_pPlot;
; 5965 : 	if (!pNewPlot)
; 5966 : 		return FALSE;
; 5967 : #else
; 5968 : 	CvMap& kMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], ecx

; 5969 : 	CvPlot* pNewPlot = kMap.plotUnchecked(node->m_iX, node->m_iY);

	mov	edx, DWORD PTR _kMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T227223[ebp], eax
	mov	ecx, DWORD PTR _node$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	mov	eax, DWORD PTR _node$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	imul	ecx, DWORD PTR $T227223[ebp]
	add	ecx, edx
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pNewPlot$[ebp], ecx

; 5970 : #endif
; 5971 : 
; 5972 : 	if (!pNewPlot->isCity())

	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	jne	$LN7@TradeRoute@4

; 5973 : 	{
; 5974 : 		if (!pNewPlot->isWater())

	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@TradeRoute@4

; 5975 : 		{
; 5976 : 			return FALSE;

	xor	eax, eax
	jmp	$LN9@TradeRoute@4
$LN6@TradeRoute@4:

; 5977 : 		}
; 5978 : 
; 5979 : 		if (pNewPlot->getTerrainType() != (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN())	// Quicker shallow water test since we know that the plot is water already

	mov	edx, DWORD PTR _pNewPlot$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T227245[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR $T227249[ebp], ecx
	mov	edx, DWORD PTR $T227245[ebp]
	cmp	edx, DWORD PTR $T227249[ebp]
	je	SHORT $LN5@TradeRoute@4

; 5980 : 		{
; 5981 : 			if (!pCacheData->CanEmbarkAllWaterPassage())

	mov	eax, DWORD PTR _pCacheData$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR $T227253[ebp], cl
	movzx	edx, BYTE PTR $T227253[ebp]
	test	edx, edx
	jne	SHORT $LN5@TradeRoute@4

; 5982 : 			{
; 5983 : 				return FALSE;

	xor	eax, eax
	jmp	$LN9@TradeRoute@4
$LN5@TradeRoute@4:

; 5984 : 			}
; 5985 : 		}
; 5986 : 
; 5987 : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 5988 : 		const CvPlot* pParentPlot = parent->m_pPlot;
; 5989 : 		if (!pParentPlot)
; 5990 : 			return FALSE;
; 5991 : #else
; 5992 : 		CvPlot* pParentPlot = kMap.plotUnchecked(parent->m_iX, parent->m_iY);

	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227259[ebp], ecx
	mov	edx, DWORD PTR _parent$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	ecx, DWORD PTR _parent$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	imul	edx, DWORD PTR $T227259[ebp]
	add	edx, eax
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _kMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pParentPlot$220765[ebp], edx

; 5993 : #endif
; 5994 : 		if (!pParentPlot->isCity())

	mov	ecx, DWORD PTR _pParentPlot$220765[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN49@TradeRoute@4

; 5995 : 		{
; 5996 : 			if(pParentPlot->getArea() != pNewPlot->getArea())

	mov	edx, DWORD PTR _pParentPlot$220765[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T227278[ebp], eax
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T227282[ebp], edx
	mov	eax, DWORD PTR $T227278[ebp]
	cmp	eax, DWORD PTR $T227282[ebp]
	je	SHORT $LN49@TradeRoute@4

; 5997 : 			{
; 5998 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $LN9@TradeRoute@4

; 5999 : 			}
; 6000 : 		}
; 6001 : 
; 6002 : 		if(pNewPlot->isImpassable())

$LN49@TradeRoute@4:
	mov	ecx, DWORD PTR _pNewPlot$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN7@TradeRoute@4

; 6003 : 		{
; 6004 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN9@TradeRoute@4
$LN7@TradeRoute@4:

; 6005 : 		}
; 6006 : 	}
; 6007 : 
; 6008 : 	return TRUE;

	mov	eax, 1
$LN9@TradeRoute@4:

; 6009 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ENDP ; TradeRouteWaterValid
_TEXT	ENDS
PUBLIC	?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
PUBLIC	?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z ; CvAStar::CopyPath
; Function compile flags: /Odtp
;	COMDAT ?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z
_TEXT	SEGMENT
tv284 = -96						; size = 4
tv153 = -92						; size = 4
$T227393 = -88						; size = 4
$T227385 = -84						; size = 4
$T227387 = -80						; size = 4
$T227321 = -36						; size = 4
$T227317 = -32						; size = 4
$T227313 = -28						; size = 4
$T227306 = -24						; size = 4
$T227298 = -20						; size = 4
$T227303 = -16						; size = 4
_pkNode$220774 = -12					; size = 4
_uiNodeCount$220775 = -8				; size = 4
_uiIndex$220779 = -4					; size = 4
_pkEndNode$ = 8						; size = 4
_kPathArray$ = 12					; size = 4
?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z PROC ; CvAStar::CopyPath, COMDAT

; 6016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 6017 : 	if(pkEndNode != NULL)

	cmp	DWORD PTR _pkEndNode$[ebp], 0
	je	$LN6@CopyPath

; 6018 : 	{
; 6019 : 		const CvAStarNode* pkNode = pkEndNode;

	mov	eax, DWORD PTR _pkEndNode$[ebp]
	mov	DWORD PTR _pkNode$220774[ebp], eax

; 6020 : 
; 6021 : 		// Count the number of nodes
; 6022 : 		uint uiNodeCount = 1;

	mov	DWORD PTR _uiNodeCount$220775[ebp], 1
$LN5@CopyPath:

; 6023 : 
; 6024 : 		while(pkNode->m_pParent != NULL)

	mov	ecx, DWORD PTR _pkNode$220774[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN4@CopyPath

; 6025 : 		{
; 6026 : 			++uiNodeCount;

	mov	edx, DWORD PTR _uiNodeCount$220775[ebp]
	add	edx, 1
	mov	DWORD PTR _uiNodeCount$220775[ebp], edx

; 6027 : 			pkNode = pkNode->m_pParent;

	mov	eax, DWORD PTR _pkNode$220774[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pkNode$220774[ebp], ecx

; 6028 : 		}

	jmp	SHORT $LN5@CopyPath
$LN4@CopyPath:

; 6029 : 
; 6030 : 		kPathArray.setsize(uiNodeCount);

	mov	edx, DWORD PTR _uiNodeCount$220775[ebp]
	mov	DWORD PTR $T227306[ebp], edx
	mov	eax, DWORD PTR $T227306[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPathArray$[ebp]
	call	?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
	mov	ecx, DWORD PTR _kPathArray$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T227298[ebp], ecx
	mov	edx, DWORD PTR $T227298[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR $T227306[ebp]
	jae	SHORT $LN13@CopyPath
	mov	ecx, DWORD PTR $T227298[ebp]
	mov	DWORD PTR tv153[ebp], ecx
	jmp	SHORT $LN14@CopyPath
$LN13@CopyPath:
	lea	edx, DWORD PTR $T227306[ebp]
	mov	DWORD PTR tv153[ebp], edx
$LN14@CopyPath:
	mov	eax, DWORD PTR tv153[ebp]
	mov	DWORD PTR $T227303[ebp], eax
	mov	ecx, DWORD PTR _kPathArray$[ebp]
	mov	edx, DWORD PTR $T227303[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 6031 : 
; 6032 : 		pkNode = pkEndNode;

	mov	ecx, DWORD PTR _pkEndNode$[ebp]
	mov	DWORD PTR _pkNode$220774[ebp], ecx

; 6033 : 		kPathArray[0] = *pkNode;

	xor	edx, edx
	shl	edx, 4
	mov	eax, DWORD PTR _kPathArray$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR $T227313[ebp], edx
	mov	ecx, DWORD PTR $T227313[ebp]
	mov	edx, DWORD PTR _pkNode$220774[ebp]
	mov	ax, WORD PTR [edx+80]
	mov	WORD PTR [ecx+12], ax
	mov	ecx, DWORD PTR $T227313[ebp]
	mov	edx, DWORD PTR _pkNode$220774[ebp]
	mov	ax, WORD PTR [edx+82]
	mov	WORD PTR [ecx+14], ax
	mov	ecx, DWORD PTR $T227313[ebp]
	mov	edx, DWORD PTR _pkNode$220774[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T227313[ebp]
	mov	edx, DWORD PTR _pkNode$220774[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR $T227313[ebp]
	mov	DWORD PTR [ecx+8], 0

; 6034 : 
; 6035 : 		uint uiIndex = 1;

	mov	DWORD PTR _uiIndex$220779[ebp], 1
$LN3@CopyPath:

; 6036 : 		while(pkNode->m_pParent != NULL)

	mov	edx, DWORD PTR _pkNode$220774[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN2@CopyPath

; 6037 : 		{
; 6038 : 			pkNode = pkNode->m_pParent;

	mov	eax, DWORD PTR _pkNode$220774[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pkNode$220774[ebp], ecx

; 6039 : 			kPathArray[uiIndex++] = *pkNode;

	mov	edx, DWORD PTR _uiIndex$220779[ebp]
	mov	DWORD PTR $T227317[ebp], edx
	mov	eax, DWORD PTR $T227317[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _kPathArray$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T227321[ebp], eax
	mov	edx, DWORD PTR _uiIndex$220779[ebp]
	add	edx, 1
	mov	DWORD PTR _uiIndex$220779[ebp], edx
	mov	eax, DWORD PTR $T227321[ebp]
	mov	ecx, DWORD PTR _pkNode$220774[ebp]
	mov	dx, WORD PTR [ecx+80]
	mov	WORD PTR [eax+12], dx
	mov	eax, DWORD PTR $T227321[ebp]
	mov	ecx, DWORD PTR _pkNode$220774[ebp]
	mov	dx, WORD PTR [ecx+82]
	mov	WORD PTR [eax+14], dx
	mov	eax, DWORD PTR $T227321[ebp]
	mov	ecx, DWORD PTR _pkNode$220774[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T227321[ebp]
	mov	ecx, DWORD PTR _pkNode$220774[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T227321[ebp]
	mov	DWORD PTR [eax+8], 0

; 6040 : 		}

	jmp	SHORT $LN3@CopyPath
$LN2@CopyPath:

; 6041 : 	}
; 6042 : 	else

	jmp	SHORT $LN7@CopyPath
$LN6@CopyPath:

; 6043 : 		kPathArray.setsize(0);	// Setting the size to 0 rather than clearing so that the array data is not deleted.  Helps with memory thrashing.

	mov	DWORD PTR $T227393[ebp], 0
	mov	ecx, DWORD PTR $T227393[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPathArray$[ebp]
	call	?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
	mov	edx, DWORD PTR _kPathArray$[ebp]
	add	edx, 8
	mov	DWORD PTR $T227385[ebp], edx
	mov	eax, DWORD PTR $T227385[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T227393[ebp]
	jae	SHORT $LN62@CopyPath
	mov	edx, DWORD PTR $T227385[ebp]
	mov	DWORD PTR tv284[ebp], edx
	jmp	SHORT $LN63@CopyPath
$LN62@CopyPath:
	lea	eax, DWORD PTR $T227393[ebp]
	mov	DWORD PTR tv284[ebp], eax
$LN63@CopyPath:
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR $T227387[ebp], ecx
	mov	edx, DWORD PTR _kPathArray$[ebp]
	mov	eax, DWORD PTR $T227387[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx
$LN7@CopyPath:

; 6044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CopyPath@CvAStar@@SAXPBVCvAStarNode@@AAVCvPathNodeArray@@@Z ENDP ; CvAStar::CopyPath
_TEXT	ENDS
PUBLIC	?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z ; CvPathNodeArray::GetTurnDest
; Function compile flags: /Odtp
;	COMDAT ?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_kNode$220792 = -8					; size = 4
_i$220788 = -4						; size = 4
_iTurn$ = 8						; size = 4
?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z PROC ; CvPathNodeArray::GetTurnDest, COMDAT
; _this$ = ecx

; 6048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 6049 : 	for (uint i = size(); i--; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$220788[ebp], ecx
$LN6@GetTurnDes:
	mov	edx, DWORD PTR _i$220788[ebp]
	mov	eax, DWORD PTR _i$220788[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$220788[ebp], eax
	test	edx, edx
	je	SHORT $LN5@GetTurnDes

; 6050 : 	{
; 6051 : 		const CvPathNode& kNode = at(i);

	mov	ecx, DWORD PTR _i$220788[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _kNode$220792[ebp], ecx

; 6052 : 		if (i == 0)

	cmp	DWORD PTR _i$220788[ebp], 0
	jne	SHORT $LN4@GetTurnDes

; 6053 : 		{
; 6054 : 			// Last node, only return it if it is the desired turn
; 6055 : 			if (kNode.m_iData2 == iTurn)

	mov	eax, DWORD PTR _kNode$220792[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _iTurn$[ebp]
	jne	SHORT $LN3@GetTurnDes

; 6056 : 				return &kNode;

	mov	eax, DWORD PTR _kNode$220792[ebp]
	jmp	SHORT $LN7@GetTurnDes
$LN3@GetTurnDes:

; 6057 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN7@GetTurnDes

; 6058 : 		}
; 6059 : 		else

	jmp	SHORT $LN2@GetTurnDes
$LN4@GetTurnDes:

; 6060 : 		{
; 6061 : 			// Is this node the correct turn and the next node is a turn after it?
; 6062 : 			if (kNode.m_iData2 == iTurn && at(i-1).m_iData2 > iTurn)

	mov	edx, DWORD PTR _kNode$220792[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _iTurn$[ebp]
	jne	SHORT $LN2@GetTurnDes
	mov	ecx, DWORD PTR _i$220788[ebp]
	sub	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+ecx+4]
	cmp	ecx, DWORD PTR _iTurn$[ebp]
	jle	SHORT $LN2@GetTurnDes

; 6063 : 				return &kNode;

	mov	eax, DWORD PTR _kNode$220792[ebp]
	jmp	SHORT $LN7@GetTurnDes
$LN2@GetTurnDes:

; 6064 : 		}
; 6065 : 	}

	jmp	SHORT $LN6@GetTurnDes
$LN5@GetTurnDes:

; 6066 : 
; 6067 : 	return NULL;

	xor	eax, eax
$LN7@GetTurnDes:

; 6068 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurnDest@CvPathNodeArray@@QAEPBVCvPathNode@@H@Z ENDP ; CvPathNodeArray::GetTurnDest
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T227407 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+36], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T227407[ebp], ecx
	cmp	DWORD PTR $T227407[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T227407[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T227407[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$227461 = -8					; size = 4
$T227456 = -4						; size = 4
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T227456[ebp], ecx
	cmp	DWORD PTR $T227456[ebp], 0
	je	SHORT $LN1@auto_ptr
	mov	edx, DWORD PTR $T227456[ebp]
	mov	DWORD PTR _inst$227461[ebp], edx
	mov	eax, DWORD PTR _inst$227461[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$227461[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$227469 = -8					; size = 4
$T227464 = -4						; size = 4
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T227464[ebp], ecx
	cmp	DWORD PTR $T227464[ebp], 0
	je	SHORT $LN1@auto_ptr@2
	mov	edx, DWORD PTR $T227464[ebp]
	mov	DWORD PTR _inst$227469[ebp], edx
	mov	eax, DWORD PTR _inst$227469[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$227469[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
_TEXT	ENDS
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T227506 = -36						; size = 4
$T227505 = -32						; size = 4
_i$227498 = -28						; size = 4
$T227481 = -24						; size = 4
_pRet$227478 = -20					; size = 4
$T227472 = -16						; size = 4
_i$220861 = -12						; size = 4
_uiNewSize$220853 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$220853[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$220853[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$220853[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T227481[ebp], ecx
	cmp	DWORD PTR $T227481[ebp], 6
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T227481[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227478[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T227481[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$227478[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 6
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$227478[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$220861[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$220861[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220861[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$220861[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$220861[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T227472[ebp], ecx
	cmp	DWORD PTR $T227472[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T227472[ebp]
	mov	edx, DWORD PTR _i$220861[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T227472[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227506[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T227505[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$227498[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	edx, DWORD PTR _i$227498[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227498[ebp], edx
$LN26@GrowSize:
	mov	eax, DWORD PTR _i$227498[ebp]
	cmp	eax, DWORD PTR $T227506[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T227505[ebp], ecx
	je	SHORT $LN22@GrowSize
	mov	edx, DWORD PTR $T227505[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+36], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z
_TEXT	SEGMENT
tv155 = -52						; size = 4
tv185 = -48						; size = 4
_this$ = -44						; size = 4
$T227561 = -40						; size = 4
_i$227553 = -36						; size = 4
$T227533 = -32						; size = 4
_pRet$227532 = -28					; size = 4
$T227522 = -24						; size = 4
$T227518 = -20						; size = 4
$T227510 = -16						; size = 4
_i$220879 = -12						; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z PROC ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize, COMDAT
; _this$ = ecx

; 468  : 	void SetSize(unsigned int uiFit){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 469  : 
; 470  : 		unsigned int nOld = m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOld$[ebp], ecx

; 471  : 
; 472  : 		m_uiCurrSize = MIN( m_uiCurrSize, uiFit );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T227522[ebp], edx
	mov	eax, DWORD PTR $T227522[ebp]
	mov	ecx, DWORD PTR _uiFit$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN16@SetSize
	lea	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $LN17@SetSize
$LN16@SetSize:
	mov	eax, DWORD PTR $T227522[ebp]
	mov	DWORD PTR tv185[ebp], eax
$LN17@SetSize:
	mov	ecx, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T227518[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T227518[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 473  : 
; 474  : 		T* pTemp = NULL;

	mov	DWORD PTR _pTemp$[ebp], 0

; 475  : 		if( uiFit > 0 ){

	cmp	DWORD PTR _uiFit$[ebp], 0
	jbe	$LN9@SetSize

; 476  : 			pTemp = Alloc(uiFit);

	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR $T227533[ebp], edx
	cmp	DWORD PTR $T227533[ebp], 0
	jbe	SHORT $LN18@SetSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T227533[ebp]
	shl	eax, 4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227532[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T227533[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$227532[ebp]
	mov	DWORD PTR _pTemp$[ebp], eax
	jmp	SHORT $LN19@SetSize
$LN18@SetSize:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN19@SetSize:

; 477  : 			if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN8@SetSize

; 478  : 			{
; 479  : 				if( bPODType ){

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@SetSize

; 480  : 					memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pTemp$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 481  : 				}else{

	jmp	SHORT $LN6@SetSize
$LN7@SetSize:

; 482  : 					for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$220879[ebp], 0
	jmp	SHORT $LN5@SetSize
$LN4@SetSize:
	mov	ecx, DWORD PTR _i$220879[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$220879[ebp], ecx
$LN5@SetSize:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$220879[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@SetSize

; 483  : 						new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	ecx, DWORD PTR _i$220879[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T227510[ebp], ecx
	je	SHORT $LN12@SetSize
	mov	edx, DWORD PTR _i$220879[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR $T227510[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T227510[ebp]
	mov	DWORD PTR tv155[ebp], edx
	jmp	SHORT $LN13@SetSize
$LN12@SetSize:
	mov	DWORD PTR tv155[ebp], 0
$LN13@SetSize:
	jmp	SHORT $LN4@SetSize
$LN6@SetSize:

; 484  : 				}
; 485  : 				m_uiCurrMaxSize = uiFit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 486  : 			}
; 487  : 			else

	jmp	SHORT $LN2@SetSize
$LN8@SetSize:

; 488  : 			{
; 489  : 				FAssertMsg2(0, "Failed to set array size from %u to %u", nOld, uiFit);
; 490  : 				m_uiCurrSize = nOld;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [edx+4], eax

; 491  : 				return;

	jmp	SHORT $LN10@SetSize
$LN2@SetSize:

; 492  : 			}
; 493  : 		}
; 494  : 		else

	jmp	SHORT $LN1@SetSize
$LN9@SetSize:

; 495  : 		{
; 496  : 			m_uiCurrMaxSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN1@SetSize:

; 497  : 		}
; 498  : 		Free(m_pData, nOld);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227561[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN25@SetSize
	xor	edx, edx
	je	SHORT $LN25@SetSize
	mov	DWORD PTR _i$227553[ebp], 0
	jmp	SHORT $LN30@SetSize
$LN29@SetSize:
	mov	eax, DWORD PTR _i$227553[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227553[ebp], eax
$LN30@SetSize:
	mov	ecx, DWORD PTR _i$227553[ebp]
	cmp	ecx, DWORD PTR _nOld$[ebp]
	jae	SHORT $LN25@SetSize
	jmp	SHORT $LN29@SetSize
$LN25@SetSize:
	mov	edx, DWORD PTR $T227561[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 499  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@SetSize:

; 500  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$FFastVector@VCvPathNode@@$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@VCvPathNode@@$00@@@@IAEXI@Z ENDP ; FFastVector<CvPathNode,1,0,0,BaseVector<CvPathNode,1>::FDefaultFastVectorAllocator>::SetSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T227592 = -2092					; size = 4
$T227591 = -2088					; size = 4
$T227590 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T227590[ebp], eax
	mov	ecx, DWORD PTR $T227590[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T227591[ebp], eax
	mov	eax, DWORD PTR $T227591[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T227592[ebp], eax
	mov	ecx, DWORD PTR $T227592[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,6,1,297,0>::FStaticVector<CvAStarNode *,6,1,297,0>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvastarnode.h
;	COMDAT ??0CvAStarNode@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
??0CvAStarNode@@QAE@XZ PROC				; CvAStarNode::CvAStarNode, COMDAT
; _this$ = ecx

; 83   : 	CvAStarNode()

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,6,1,297,0>::FStaticVector<CvAStarNode *,6,1,297,0>

; 84   : 	{
; 85   : 		m_iX = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+80], ax

; 86   : 		m_iY = -1;

	or	edx, -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+82], dx

; 87   : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 88   : 		m_pPlot = NULL;
; 89   : #endif
; 90   : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 91   : 		clear();
; 92   : #else
; 93   : 		m_iTotalCost = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 94   : 		m_iKnownCost = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 95   : 		m_iHeuristicCost = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 96   : 		m_iNumChildren = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+84], cx

; 97   : 		m_iData1 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 98   : 		m_iData2 = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 99   : 
; 100  : 		m_bOnStack = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+86], 0

; 101  : 
; 102  : 		m_eCvAStarListType = NO_CVASTARLIST;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], -1

; 103  : 
; 104  : 		m_pParent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 105  : 		m_pNext = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 106  : 		m_pPrev = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 107  : 		m_pStack = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 108  : #endif
; 109  : #ifdef AUI_ASTAR_PRECALCULATE_NEIGHBORS_ON_INITIALIZE
; 110  : 		for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
; 111  : 		{
; 112  : 			m_apNeighbors[iI] = NULL;
; 113  : 		}
; 114  : #endif
; 115  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvAStarNode@@QAE@XZ ENDP				; CvAStarNode::CvAStarNode
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?clear@CvAStarNode@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T227628 = -8						; size = 4
_i$227624 = -4						; size = 4
?clear@CvAStarNode@@QAEXXZ PROC				; CvAStarNode::clear, COMDAT
; _this$ = ecx

; 118  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 		m_iTotalCost = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 120  : 		m_iKnownCost = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 121  : 		m_iHeuristicCost = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 122  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 123  : 		bPlotVisibleToTeam = false;
; 124  : 		bIsMountain = false;
; 125  : 		bIsWater = false;
; 126  : 		bCanEnterTerrain = false;
; 127  : 		bIsRevealedToTeam = false;
; 128  : 		bContainsOtherFriendlyTeamCity = false;
; 129  : 		bContainsEnemyCity = false;
; 130  : 		bContainsVisibleEnemy = false;
; 131  : 		bContainsVisibleEnemyDefender = false;
; 132  : #else
; 133  : 		m_iNumChildren = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+84], ax

; 134  : #endif
; 135  : 		m_iData1 = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 136  : 		m_iData2 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 137  : 
; 138  : 		m_bOnStack = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+86], 0

; 139  : 
; 140  : 		m_eCvAStarListType = NO_CVASTARLIST;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], -1

; 141  : 
; 142  : 		m_pParent = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 143  : 		m_pNext = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 144  : 		m_pPrev = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 145  : 		m_pStack = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 146  : 
; 147  : #ifdef AUI_ASTAR_FIX_CAN_ENTER_TERRAIN_NO_DUPLICATE_CALLS
; 148  : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 149  : 		bIsCalculated = false;
; 150  : #else
; 151  : 		m_kCostCacheData.bIsCalculated = false;
; 152  : #endif
; 153  : #endif
; 154  : 
; 155  : 		m_apChildren.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR $T227628[ebp], ecx
	xor	edx, edx
	je	SHORT $LN9@clear
	mov	DWORD PTR _i$227624[ebp], 0
	jmp	SHORT $LN7@clear
$LN6@clear:
	mov	eax, DWORD PTR _i$227624[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227624[ebp], eax
$LN7@clear:
	mov	ecx, DWORD PTR $T227628[ebp]
	mov	edx, DWORD PTR _i$227624[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN9@clear
	jmp	SHORT $LN6@clear
$LN9@clear:
	mov	eax, DWORD PTR $T227628[ebp]
	mov	DWORD PTR [eax+4], 0

; 156  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@CvAStarNode@@QAEXXZ ENDP				; CvAStarNode::clear
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227639 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227639[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T227639[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227645 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T227645[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T227645[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T227659 = -8						; size = 4
$T227655 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227655[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T227655[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T227659[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T227659[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T227672 = -20						; size = 4
_pRet$227669 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::FStaticVector<CvAStarNode *,6,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 6

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227672[ebp], edx
	cmp	DWORD PTR $T227672[ebp], 6
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T227672[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227669[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T227672[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$227669[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 6
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$227669[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
__ehhandler$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::FStaticVector<CvAStarNode *,6,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T227703 = -24						; size = 4
$T227702 = -20						; size = 4
_i$227695 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227703[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227702[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$227695[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$227695[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227695[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$227695[ebp]
	cmp	ecx, DWORD PTR $T227703[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T227702[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T227702[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
__ehhandler$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@PAVCvAStarNode@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,6,1,297,0>::~FStaticVector<CvAStarNode *,6,1,297,0>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ PROC	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ENDP	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
_TEXT	ENDS
END
