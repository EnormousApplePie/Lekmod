; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvStartPositioner.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
PUBLIC	??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >
PUBLIC	??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::~_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >
PUBLIC	??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >
PUBLIC	??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::~_Vector_val<CvContinent,std::allocator<CvContinent> >
PUBLIC	?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Buy
PUBLIC	?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Buy
PUBLIC	?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Buy
PUBLIC	??_7CvStartPositioner@@6B@			; CvStartPositioner::`vftable'
PUBLIC	??0CvStartPositioner@@QAE@XZ			; CvStartPositioner::CvStartPositioner
PUBLIC	?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z ; CvStartPositioner::Init
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_7CvStartPositioner@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_7CvStartPositioner@@6B@ DD FLAT:?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z ; CvStartPositioner::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvStartPositioner@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CvStartPositioner@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvStartPositioner@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvStartPositioner@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvStartPositioner@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvStartPositioner@@QAE@XZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvStartPositioner@@QAE@XZ$1
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvStartPositioner@@QAE@XZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ??0CvStartPositioner@@QAE@XZ
_TEXT	SEGMENT
tv253 = -124						; size = 4
tv278 = -120						; size = 4
tv199 = -116						; size = 4
tv224 = -112						; size = 4
tv145 = -108						; size = 4
tv170 = -104						; size = 4
_this$ = -100						; size = 4
$T223943 = -96						; size = 4
$T223934 = -92						; size = 4
$T223919 = -86						; size = 1
$T223906 = -85						; size = 1
$T223902 = -84						; size = 4
$T223895 = -76						; size = 4
$T223888 = -68						; size = 4
$T223853 = -58						; size = 1
$T223840 = -57						; size = 1
$T223836 = -56						; size = 4
$T223829 = -48						; size = 4
$T223822 = -40						; size = 4
$T223787 = -30						; size = 1
$T223774 = -29						; size = 1
$T223770 = -28						; size = 4
$T223763 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvStartPositioner@@QAE@XZ PROC			; CvStartPositioner::CvStartPositioner, COMDAT
; _this$ = ecx

; 21   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvStartPositioner@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvStartPositioner@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T223822[ebp], ecx
	lea	edx, DWORD PTR $T223787[ebp]
	mov	DWORD PTR $T223763[ebp], edx
	lea	eax, DWORD PTR $T223774[ebp]
	mov	DWORD PTR $T223770[ebp], eax
	mov	ecx, DWORD PTR $T223822[ebp]
	mov	DWORD PTR tv170[ebp], ecx
	mov	edx, DWORD PTR $T223822[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR $T223822[ebp]
	call	?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T223888[ebp], eax
	lea	ecx, DWORD PTR $T223853[ebp]
	mov	DWORD PTR $T223829[ebp], ecx
	lea	edx, DWORD PTR $T223840[ebp]
	mov	DWORD PTR $T223836[ebp], edx
	mov	eax, DWORD PTR $T223888[ebp]
	mov	DWORD PTR tv224[ebp], eax
	mov	ecx, DWORD PTR $T223888[ebp]
	mov	DWORD PTR tv199[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	0
	mov	ecx, DWORD PTR $T223888[ebp]
	call	?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	DWORD PTR $T223934[ebp], edx
	lea	eax, DWORD PTR $T223919[ebp]
	mov	DWORD PTR $T223895[ebp], eax
	lea	ecx, DWORD PTR $T223906[ebp]
	mov	DWORD PTR $T223902[ebp], ecx
	mov	edx, DWORD PTR $T223934[ebp]
	mov	DWORD PTR tv278[ebp], edx
	mov	eax, DWORD PTR $T223934[ebp]
	mov	DWORD PTR tv253[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	0
	mov	ecx, DWORD PTR $T223934[ebp]
	call	?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR $T223943[ebp], ecx
	mov	edx, DWORD PTR $T223943[ebp]
	mov	DWORD PTR [edx], 0

; 22   : #ifdef AUI_WARNING_FIXES
; 23   : 	m_pSiteEvaluator = NULL;
; 24   : #endif
; 25   : 	m_iRequiredSeparation = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 26   : 	m_iBestFoundValueOnMap = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 27   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvStartPositioner@@QAE@XZ$3:
	mov	ecx, DWORD PTR $T223822[ebp]
	jmp	??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvStartPositioner@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >
__unwindfunclet$??0CvStartPositioner@@QAE@XZ$5:
	mov	ecx, DWORD PTR $T223888[ebp]
	jmp	??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvStartPositioner@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >
__unwindfunclet$??0CvStartPositioner@@QAE@XZ$7:
	mov	ecx, DWORD PTR $T223934[ebp]
	jmp	??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
__ehhandler$??0CvStartPositioner@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvStartPositioner@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvStartPositioner@@QAE@XZ ENDP			; CvStartPositioner::CvStartPositioner
PUBLIC	?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy
PUBLIC	?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy
PUBLIC	?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Tidy
PUBLIC	??1CvStartPositioner@@QAE@XZ			; CvStartPositioner::~CvStartPositioner
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1CvStartPositioner@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1CvStartPositioner@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvStartPositioner@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvStartPositioner@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvStartPositioner@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvStartPositioner@@QAE@XZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvStartPositioner@@QAE@XZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvStartPositioner@@QAE@XZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ??1CvStartPositioner@@QAE@XZ
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T224217 = -120						; size = 4
$T224131 = -84						; size = 4
$T224045 = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1CvStartPositioner@@QAE@XZ PROC			; CvStartPositioner::~CvStartPositioner, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvStartPositioner@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvStartPositioner@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 32   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR $T224045[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T224045[ebp]
	call	?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T224131[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T224131[ebp]
	call	?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T224217[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T224217[ebp]
	call	?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvStartPositioner@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >
__unwindfunclet$??1CvStartPositioner@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >
__unwindfunclet$??1CvStartPositioner@@QAE@XZ$3:
	mov	ecx, DWORD PTR $T224045[ebp]
	jmp	??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvStartPositioner@@QAE@XZ$5:
	mov	ecx, DWORD PTR $T224131[ebp]
	jmp	??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvStartPositioner@@QAE@XZ$7:
	mov	ecx, DWORD PTR $T224217[ebp]
	jmp	??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
__ehhandler$??1CvStartPositioner@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvStartPositioner@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvStartPositioner@@QAE@XZ ENDP			; CvStartPositioner::~CvStartPositioner
; Function compile flags: /Odtp
;	COMDAT ?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSiteEvaluator$ = 8					; size = 4
?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z PROC ; CvStartPositioner::Init, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 37   : 	CvAssert(pSiteEvaluator);
; 38   : 	if(!pSiteEvaluator)

	cmp	DWORD PTR _pSiteEvaluator$[ebp], 0
	jne	SHORT $LN1@Init

; 39   : 		return;

	jmp	SHORT $LN2@Init
$LN1@Init:

; 40   : 
; 41   : 	m_pSiteEvaluator = pSiteEvaluator;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSiteEvaluator$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 42   : 	m_pSiteEvaluator->ComputeFlavorMultipliers(NULL);  // Ignore flavors; this sets them to 1

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN2@Init:

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvStartPositioner@@UAEXPAVCvSiteEvaluatorForStart@@@Z ENDP ; CvStartPositioner::Init
_TEXT	ENDS
PUBLIC	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
PUBLIC	?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z ; CvStartPositioner::DivideContinentIntoRegions
PUBLIC	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
PUBLIC	?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back
PUBLIC	?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ ; CvStartPositioner::ComputeTileFertilityValues
PUBLIC	?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase
PUBLIC	?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::erase
PUBLIC	?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z ; CvStartPositioner::DivideMapIntoRegions
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?getTotalFoundValue@CvArea@@QBEHXZ:PROC		; CvArea::getTotalFoundValue
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -356						; size = 4
$T224828 = -352						; size = 4
$T224827 = -348						; size = 4
$T224507 = -204						; size = 4
$T224491 = -200						; size = 4
$T224481 = -196						; size = 4
$T224477 = -192						; size = 4
$T224473 = -188						; size = 4
$T224469 = -184						; size = 4
$T224462 = -180						; size = 4
$T224461 = -176						; size = 4
$T224439 = -172						; size = 4
$T224423 = -168						; size = 4
$T224413 = -164						; size = 4
$T224371 = -136						; size = 4
$T224367 = -132						; size = 4
$T224360 = -128						; size = 4
$T224356 = -124						; size = 4
$T224352 = -120						; size = 4
$T224348 = -116						; size = 4
$T224322 = -112						; size = 4
$T224306 = -108						; size = 4
$T224335 = -104						; size = 4
$T224334 = -100						; size = 4
$T224333 = -96						; size = 4
$T224332 = -92						; size = 4
$T224331 = -88						; size = 4
$T224290 = -84						; size = 4
$T224264 = -80						; size = 4
$T224248 = -76						; size = 4
$T224283 = -72						; size = 4
$T224282 = -68						; size = 4
$T224281 = -64						; size = 4
$T224280 = -60						; size = 4
$T224279 = -56						; size = 4
$T224232 = -52						; size = 4
$T224231 = -48						; size = 4
$T224229 = -40						; size = 4
$T224228 = -36						; size = 4
_iI$219601 = -32					; size = 4
_continent$219442 = -28					; size = 16
_pLoopArea$ = -12					; size = 4
_iLoop$ = -8						; size = 4
_iNumRegionsPlaced$ = -4				; size = 4
_iNumRegions$ = 8					; size = 4
?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z PROC	; CvStartPositioner::DivideMapIntoRegions, COMDAT
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 	CvArea* pLoopArea(NULL);

	mov	DWORD PTR _pLoopArea$[ebp], 0

; 49   : 	int iLoop;
; 50   : 	int iNumRegionsPlaced = 0;

	mov	DWORD PTR _iNumRegionsPlaced$[ebp], 0

; 51   : 
; 52   : 	// Initialize
; 53   : 	m_ContinentVector.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T224290[ebp], eax
	mov	ecx, DWORD PTR $T224290[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T224248[ebp], edx
	mov	eax, DWORD PTR $T224248[ebp]
	mov	DWORD PTR $T224280[ebp], eax
	mov	ecx, DWORD PTR $T224280[ebp]
	mov	DWORD PTR $T224279[ebp], ecx
	mov	edx, DWORD PTR $T224290[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224264[ebp], eax
	mov	ecx, DWORD PTR $T224264[ebp]
	mov	DWORD PTR $T224282[ebp], ecx
	mov	edx, DWORD PTR $T224282[ebp]
	mov	DWORD PTR $T224281[ebp], edx
	mov	eax, DWORD PTR $T224279[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224281[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224283[ebp]
	push	edx
	mov	ecx, DWORD PTR $T224290[ebp]
	call	?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::erase

; 54   : 	m_StartRegionVector.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T224348[ebp], eax
	mov	ecx, DWORD PTR $T224348[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T224306[ebp], edx
	mov	eax, DWORD PTR $T224306[ebp]
	mov	DWORD PTR $T224332[ebp], eax
	mov	ecx, DWORD PTR $T224332[ebp]
	mov	DWORD PTR $T224331[ebp], ecx
	mov	edx, DWORD PTR $T224348[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224322[ebp], eax
	mov	ecx, DWORD PTR $T224322[ebp]
	mov	DWORD PTR $T224334[ebp], ecx
	mov	edx, DWORD PTR $T224334[ebp]
	mov	DWORD PTR $T224333[ebp], edx
	mov	eax, DWORD PTR $T224331[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224333[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224335[ebp]
	push	edx
	mov	ecx, DWORD PTR $T224348[ebp]
	call	?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase

; 55   : 
; 56   : 	// Compute fertility for each plot
; 57   : 	ComputeTileFertilityValues();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ ; CvStartPositioner::ComputeTileFertilityValues

; 58   : 
; 59   : 	// Loop through each continent adding it to our list
; 60   : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224352[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T224352[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
	jmp	SHORT $LN10@DivideMapI
$LN9@DivideMapI:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224356[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224356[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
$LN10@DivideMapI:
	cmp	DWORD PTR _pLoopArea$[ebp], 0
	je	$LN8@DivideMapI

; 61   : 	{
; 62   : 		// Throw out oceans and desert islands
; 63   : 		if(pLoopArea->getTotalFoundValue() > 0 && pLoopArea->getNumTiles() >= GC.getMIN_START_AREA_TILES())

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	test	eax, eax
	jle	SHORT $LN7@DivideMapI
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7140
	mov	DWORD PTR $T224360[ebp], ecx
	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, DWORD PTR $T224360[ebp]
	jl	SHORT $LN7@DivideMapI

; 64   : 		{
; 65   : 			CvContinent continent;

	mov	DWORD PTR _continent$219442[ebp], 0
	mov	DWORD PTR _continent$219442[ebp+8], 0
	mov	DWORD PTR _continent$219442[ebp+4], 0
	mov	DWORD PTR _continent$219442[ebp+12], -1

; 66   : 			continent.SetFertility(pLoopArea->getTotalFoundValue());

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	mov	DWORD PTR $T224367[ebp], eax
	mov	edx, DWORD PTR $T224367[ebp]
	mov	DWORD PTR _continent$219442[ebp], edx
	mov	eax, DWORD PTR $T224367[ebp]
	mov	DWORD PTR _continent$219442[ebp+4], eax

; 67   : 			continent.SetArea(pLoopArea->GetID());

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T224371[ebp], edx
	mov	eax, DWORD PTR $T224371[ebp]
	mov	DWORD PTR _continent$219442[ebp+12], eax

; 68   : 			m_ContinentVector.push_back(continent);

	lea	ecx, DWORD PTR _continent$219442[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back
$LN7@DivideMapI:

; 69   : 		}
; 70   : 	}

	jmp	$LN9@DivideMapI
$LN8@DivideMapI:

; 71   : 
; 72   : 	if(m_ContinentVector.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T224413[ebp], edx
	mov	eax, DWORD PTR $T224413[ebp]
	mov	ecx, DWORD PTR $T224413[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	test	edx, edx
	jbe	$LN6@DivideMapI
$LN5@DivideMapI:

; 73   : 	{
; 74   : 		// Assign all the regions to continents
; 75   : 		while(iNumRegionsPlaced < iNumRegions)

	mov	eax, DWORD PTR _iNumRegionsPlaced$[ebp]
	cmp	eax, DWORD PTR _iNumRegions$[ebp]
	jge	$LN6@DivideMapI

; 76   : 		{
; 77   : 			std::sort(m_ContinentVector.begin(), m_ContinentVector.end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T224423[ebp], edx
	mov	eax, DWORD PTR $T224423[ebp]
	mov	DWORD PTR $T224228[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T224439[ebp], edx
	mov	eax, DWORD PTR $T224439[ebp]
	mov	DWORD PTR $T224229[ebp], eax
	mov	ecx, DWORD PTR $T224228[ebp]
	mov	DWORD PTR $T224462[ebp], ecx
	mov	edx, DWORD PTR $T224229[ebp]
	mov	DWORD PTR $T224461[ebp], edx
	mov	eax, DWORD PTR $T224462[ebp]
	sub	eax, DWORD PTR $T224461[ebp]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR $T224462[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224461[ebp]
	push	edx
	call	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
	add	esp, 12					; 0000000cH

; 78   : 
; 79   : 			// Add a region to the first in our list
; 80   : 			m_ContinentVector[0].AddRegion();

	xor	eax, eax
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T224469[ebp], eax
	mov	edx, DWORD PTR $T224469[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR $T224469[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR $T224469[ebp]
	mov	ecx, DWORD PTR [edx+8]
	add	ecx, 1
	mov	edx, DWORD PTR $T224469[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR $T224469[ebp]
	mov	DWORD PTR [ecx+4], eax

; 81   : 			iNumRegionsPlaced++;

	mov	edx, DWORD PTR _iNumRegionsPlaced$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumRegionsPlaced$[ebp], edx

; 82   : 		}

	jmp	$LN5@DivideMapI
$LN6@DivideMapI:

; 83   : 	}
; 84   : 
; 85   : 	// Divide the continents according to our algorithm
; 86   : 	for(unsigned int iI=0; iI < m_ContinentVector.size(); iI++)

	mov	DWORD PTR _iI$219601[ebp], 0
	jmp	SHORT $LN3@DivideMapI
$LN2@DivideMapI:
	mov	eax, DWORD PTR _iI$219601[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$219601[ebp], eax
$LN3@DivideMapI:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T224473[ebp], ecx
	mov	edx, DWORD PTR $T224473[ebp]
	mov	eax, DWORD PTR $T224473[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	cmp	DWORD PTR _iI$219601[ebp], ecx
	jae	SHORT $LN1@DivideMapI

; 87   : 	{
; 88   : 		DivideContinentIntoRegions(m_ContinentVector[iI]);

	mov	edx, DWORD PTR _iI$219601[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T224477[ebp], edx
	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T224481[ebp], esp
	mov	ecx, DWORD PTR $T224481[ebp]
	mov	edx, DWORD PTR $T224477[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T224481[ebp]
	mov	edx, DWORD PTR $T224477[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T224481[ebp]
	mov	edx, DWORD PTR $T224477[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR $T224481[ebp]
	mov	edx, DWORD PTR $T224477[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z ; CvStartPositioner::DivideContinentIntoRegions

; 89   : 	}

	jmp	$LN2@DivideMapI
$LN1@DivideMapI:

; 90   : 
; 91   : 	// Sort the regions by fertility
; 92   : 	std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR $T224491[ebp], edx
	mov	eax, DWORD PTR $T224491[ebp]
	mov	DWORD PTR $T224231[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T224507[ebp], edx
	mov	eax, DWORD PTR $T224507[ebp]
	mov	DWORD PTR $T224232[ebp], eax
	mov	ecx, DWORD PTR $T224231[ebp]
	mov	DWORD PTR $T224828[ebp], ecx
	mov	edx, DWORD PTR $T224232[ebp]
	mov	DWORD PTR $T224827[ebp], edx
	mov	eax, DWORD PTR $T224828[ebp]
	sub	eax, DWORD PTR $T224827[ebp]
	sar	eax, 5
	push	eax
	mov	ecx, DWORD PTR $T224828[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224827[ebp]
	push	edx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DivideMapIntoRegions@CvStartPositioner@@QAEXH@Z ENDP	; CvStartPositioner::DivideMapIntoRegions
_TEXT	ENDS
PUBLIC	?ComputeFoundValues@CvStartPositioner@@QAEXXZ	; CvStartPositioner::ComputeFoundValues
EXTRN	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlot::setFoundValue
; Function compile flags: /Odtp
;	COMDAT ?ComputeFoundValues@CvStartPositioner@@QAEXXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T224842 = -24						; size = 4
$T224838 = -20						; size = 4
$T224834 = -16						; size = 4
_iValue$219769 = -12					; size = 4
_iI$219764 = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
?ComputeFoundValues@CvStartPositioner@@QAEXXZ PROC	; CvStartPositioner::ComputeFoundValues, COMDAT
; _this$ = ecx

; 97   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	CvPlot* pLoopPlot(NULL);

	mov	DWORD PTR _pLoopPlot$[ebp], 0

; 99   : 
; 100  : 	// Progress through entire map
; 101  : #ifdef AUI_WARNING_FIXES
; 102  : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 103  : #else
; 104  : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$219764[ebp], 0
	jmp	SHORT $LN5@ComputeFou
$LN4@ComputeFou:
	mov	eax, DWORD PTR _iI$219764[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$219764[ebp], eax
$LN5@ComputeFou:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224834[ebp], ecx
	mov	edx, DWORD PTR $T224834[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T224838[ebp], eax
	mov	ecx, DWORD PTR _iI$219764[ebp]
	cmp	ecx, DWORD PTR $T224838[ebp]
	jge	SHORT $LN6@ComputeFou

; 105  : #endif
; 106  : 	{
; 107  : #ifdef AUI_STARTPOSITIONER_FLAVORED_STARTS
; 108  : 		// Since found values are now computed for each player when they're being positioned, there's no point in storing stuff in CvPlot
; 109  : #else
; 110  : 		// Store in player 1 slot for now
; 111  : 		//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 112  : 		//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 113  : #endif
; 114  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224842[ebp], edx
	mov	eax, DWORD PTR _iI$219764[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T224842[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 115  : 		CvAssert(pLoopPlot);
; 116  : 		if(!pLoopPlot) continue;

	jne	SHORT $LN2@ComputeFou
	jmp	SHORT $LN4@ComputeFou
$LN2@ComputeFou:

; 117  : 		int iValue = m_pSiteEvaluator->PlotFoundValue(pLoopPlot, NULL);

	push	1
	push	-1
	push	0
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _iValue$219769[ebp], eax

; 118  : #ifndef AUI_STARTPOSITIONER_FLAVORED_STARTS
; 119  : 		pLoopPlot->setFoundValue((PlayerTypes)1, iValue);

	mov	ecx, DWORD PTR _iValue$219769[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue

; 120  : #endif
; 121  : 
; 122  : 		if(iValue > m_iBestFoundValueOnMap)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iValue$219769[ebp]
	cmp	eax, DWORD PTR [edx+64]
	jle	SHORT $LN1@ComputeFou

; 123  : 		{
; 124  : 			m_iBestFoundValueOnMap = iValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iValue$219769[ebp]
	mov	DWORD PTR [ecx+64], edx
$LN1@ComputeFou:

; 125  : 		}

	jmp	$LN4@ComputeFou
$LN6@ComputeFou:

; 126  : 	}
; 127  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ComputeFoundValues@CvStartPositioner@@QAEXXZ ENDP	; CvStartPositioner::ComputeFoundValues
_TEXT	ENDS
PUBLIC	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
PUBLIC	?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back
PUBLIC	??_C@_0BO@EIHFKBKD@Player?5Start?5Plot?5Draft?5Order?$AA@ ; `string'
PUBLIC	?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::erase
PUBLIC	?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ	; CvStartPositioner::RankPlayerStartOrder
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::getStartingLocationPercent
EXTRN	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvPlayer::getHandicapInfo
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
;	COMDAT ??_C@_0BO@EIHFKBKD@Player?5Start?5Plot?5Draft?5Order?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_C@_0BO@EIHFKBKD@Player?5Start?5Plot?5Draft?5Order?$AA@ DB 'Player Star'
	DB	't Plot Draft Order', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
CONST	ENDS
;	COMDAT ?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ
_TEXT	SEGMENT
_this$ = -312						; size = 4
$T225497 = -308						; size = 4
$T225496 = -304						; size = 4
$T225046 = -120						; size = 4
$T225030 = -116						; size = 4
$T224926 = -64						; size = 4
$T224919 = -57						; size = 1
$T224907 = -56						; size = 4
$T224881 = -52						; size = 4
$T224865 = -48						; size = 4
$T224894 = -44						; size = 4
$T224893 = -40						; size = 4
$T224892 = -36						; size = 4
$T224891 = -32						; size = 4
$T224890 = -28						; size = 4
$T224849 = -24						; size = 4
$T224848 = -20						; size = 4
_playerRank$219783 = -16				; size = 8
_player$219779 = -8					; size = 4
_iI$219775 = -4						; size = 4
?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ PROC	; CvStartPositioner::RankPlayerStartOrder, COMDAT
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 	// Clear rankings
; 133  : 	m_PlayerOrder.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR $T224907[ebp], eax
	mov	ecx, DWORD PTR $T224907[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T224865[ebp], edx
	mov	eax, DWORD PTR $T224865[ebp]
	mov	DWORD PTR $T224891[ebp], eax
	mov	ecx, DWORD PTR $T224891[ebp]
	mov	DWORD PTR $T224890[ebp], ecx
	mov	edx, DWORD PTR $T224907[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224881[ebp], eax
	mov	ecx, DWORD PTR $T224881[ebp]
	mov	DWORD PTR $T224893[ebp], ecx
	mov	edx, DWORD PTR $T224893[ebp]
	mov	DWORD PTR $T224892[ebp], edx
	mov	eax, DWORD PTR $T224890[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224892[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224894[ebp]
	push	edx
	mov	ecx, DWORD PTR $T224907[ebp]
	call	?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::erase

; 134  : 
; 135  : 	// Add each player
; 136  : 	for(int iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	mov	DWORD PTR _iI$219775[ebp], 0
	jmp	SHORT $LN6@RankPlayer
$LN5@RankPlayer:
	mov	eax, DWORD PTR _iI$219775[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$219775[ebp], eax
$LN6@RankPlayer:
	cmp	DWORD PTR _iI$219775[ebp], 63		; 0000003fH
	jge	$LN4@RankPlayer

; 137  : 	{
; 138  : 		CvPlayerAI& player = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$219775[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _player$219779[ebp], ecx

; 139  : 
; 140  : 		if(player.isAlive())

	mov	edx, DWORD PTR _player$219779[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T224919[ebp], al
	movzx	ecx, BYTE PTR $T224919[ebp]
	test	ecx, ecx
	je	SHORT $LN3@RankPlayer

; 141  : 		{
; 142  : 			if(player.getStartingPlot() == NULL)

	mov	ecx, DWORD PTR _player$219779[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	jne	SHORT $LN3@RankPlayer

; 143  : 			{
; 144  : 				CvPlayerStartRank playerRank;

	mov	DWORD PTR _playerRank$219783[ebp], -1
	mov	DWORD PTR _playerRank$219783[ebp+4], 0

; 145  : 				playerRank.m_iPlayerID = iI;

	mov	edx, DWORD PTR _iI$219775[ebp]
	mov	DWORD PTR _playerRank$219783[ebp], edx

; 146  : 
; 147  : 				// Following assumes that StartingLocationPercent in Handicap XML rises in increments of 10!
; 148  : 				//    We put all the major civs first (values 1 to 100), using a random number to rank players at the same handicap
; 149  : 				//    Then we put all the minor civs in next (values 100 to 1000).
; 150  : 				playerRank.m_iRank = player.getHandicapInfo().getStartingLocationPercent();

	mov	ecx, DWORD PTR _player$219779[ebp]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	ecx, eax
	call	?getStartingLocationPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getStartingLocationPercent
	mov	DWORD PTR _playerRank$219783[ebp+4], eax

; 151  : 				if(player.isMinorCiv())

	mov	ecx, DWORD PTR _player$219779[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@RankPlayer

; 152  : 				{
; 153  : 					playerRank.m_iRank *= 10;

	mov	ecx, DWORD PTR _playerRank$219783[ebp+4]
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR _playerRank$219783[ebp+4], ecx
$LN1@RankPlayer:

; 154  : 				}
; 155  : 				playerRank.m_iRank += GC.getGame().getJonRandNum(10, "Player Start Plot Draft Order");

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224926[ebp], edx
	push	OFFSET ??_C@_0BO@EIHFKBKD@Player?5Start?5Plot?5Draft?5Order?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T224926[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, DWORD PTR _playerRank$219783[ebp+4]
	mov	DWORD PTR _playerRank$219783[ebp+4], eax

; 156  : 				m_PlayerOrder.push_back(playerRank);

	lea	eax, DWORD PTR _playerRank$219783[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back
$LN3@RankPlayer:

; 157  : 			}
; 158  : 		}
; 159  : 	}

	jmp	$LN5@RankPlayer
$LN4@RankPlayer:

; 160  : 
; 161  : 	// Sort by rank
; 162  : 	std::sort(m_PlayerOrder.begin(), m_PlayerOrder.end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T225030[ebp], edx
	mov	eax, DWORD PTR $T225030[ebp]
	mov	DWORD PTR $T224848[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T225046[ebp], edx
	mov	eax, DWORD PTR $T225046[ebp]
	mov	DWORD PTR $T224849[ebp], eax
	mov	ecx, DWORD PTR $T224848[ebp]
	mov	DWORD PTR $T225497[ebp], ecx
	mov	edx, DWORD PTR $T224849[ebp]
	mov	DWORD PTR $T225496[ebp], edx
	mov	eax, DWORD PTR $T225497[ebp]
	sub	eax, DWORD PTR $T225496[ebp]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR $T225497[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225496[ebp]
	push	edx
	call	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
	add	esp, 12					; 0000000cH

; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RankPlayerStartOrder@CvStartPositioner@@QAEXXZ ENDP	; CvStartPositioner::RankPlayerStartOrder
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_0DI@KFOMOJOG@Trying?5to?5place?5minor?5civ?5with?5r@ ; `string'
PUBLIC	??_C@_0DF@CDCCJHJP@Trying?5to?5place?5minor?5civ?5with?5f@ ; `string'
PUBLIC	??_C@_0DI@OHIHEDCG@Trying?5to?5place?5major?5civ?5with?5r@ ; `string'
PUBLIC	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion
PUBLIC	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0DF@NLBIHFBD@Trying?5to?5place?5major?5civ?5with?5f@ ; `string'
PUBLIC	?StartingPlotRange@CvStartPositioner@@ABEHXZ	; CvStartPositioner::StartingPlotRange
PUBLIC	__$ArrayPad$
PUBLIC	?AssignStartingLocations@CvStartPositioner@@QAEXXZ ; CvStartPositioner::AssignStartingLocations
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ:PROC ; CvMap::getWorldSize
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT ??_C@_0DI@KFOMOJOG@Trying?5to?5place?5minor?5civ?5with?5r@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DI@KFOMOJOG@Trying?5to?5place?5minor?5civ?5with?5r@ DB 'Trying to '
	DB	'place minor civ with reduced separation of %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CDCCJHJP@Trying?5to?5place?5minor?5civ?5with?5f@
CONST	SEGMENT
??_C@_0DF@CDCCJHJP@Trying?5to?5place?5minor?5civ?5with?5f@ DB 'Trying to '
	DB	'place minor civ with full separation of %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OHIHEDCG@Trying?5to?5place?5major?5civ?5with?5r@
CONST	SEGMENT
??_C@_0DI@OHIHEDCG@Trying?5to?5place?5major?5civ?5with?5r@ DB 'Trying to '
	DB	'place major civ with reduced separation of %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NLBIHFBD@Trying?5to?5place?5major?5civ?5with?5f@
CONST	SEGMENT
??_C@_0DF@NLBIHFBD@Trying?5to?5place?5major?5civ?5with?5f@ DB 'Trying to '
	DB	'place major civ with full separation of %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AssignStartingLocations@CvStartPositioner@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignStartingLocations@CvStartPositioner@@QAEXXZ$0
__ehfuncinfo$?AssignStartingLocations@CvStartPositioner@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AssignStartingLocations@CvStartPositioner@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ?AssignStartingLocations@CvStartPositioner@@QAEXXZ
_TEXT	SEGMENT
tv443 = -560						; size = 4
tv413 = -553						; size = 1
tv464 = -552						; size = 4
tv352 = -548						; size = 4
tv322 = -541						; size = 1
tv462 = -540						; size = 4
tv278 = -536						; size = 4
tv245 = -529						; size = 1
tv460 = -528						; size = 4
tv190 = -524						; size = 4
tv160 = -517						; size = 1
tv458 = -516						; size = 4
_this$ = -512						; size = 4
$T226325 = -508						; size = 4
$T226324 = -504						; size = 4
$T225903 = -324						; size = 4
$T225887 = -320						; size = 4
$T225874 = -316						; size = 4
$T225870 = -312						; size = 4
$T225861 = -308						; size = 4
$T225857 = -304						; size = 4
$T225852 = -300						; size = 4
$T225848 = -296						; size = 4
$T225844 = -292						; size = 4
$T225843 = -288						; size = 4
$T225821 = -284						; size = 4
$T225805 = -280						; size = 4
$T225795 = -276						; size = 4
$T225791 = -272						; size = 4
$T225790 = -268						; size = 4
$T225768 = -264						; size = 4
$T225752 = -260						; size = 4
$T225739 = -256						; size = 4
$T225735 = -252						; size = 4
$T225726 = -248						; size = 4
$T225722 = -244						; size = 4
$T225717 = -240						; size = 4
$T225713 = -236						; size = 4
$T225709 = -232						; size = 4
$T225708 = -228						; size = 4
$T225686 = -224						; size = 4
$T225670 = -220						; size = 4
$T225657 = -216						; size = 4
$T225653 = -212						; size = 4
$T225644 = -208						; size = 4
$T225640 = -204						; size = 4
$T225632 = -200						; size = 4
$T225628 = -196						; size = 4
$T225627 = -192						; size = 4
$T225605 = -188						; size = 4
$T225589 = -184						; size = 4
$T225579 = -180						; size = 4
$T225572 = -176						; size = 4
$T225568 = -172						; size = 4
$T225559 = -168						; size = 4
$T225555 = -164						; size = 4
$T225547 = -160						; size = 4
$T225543 = -156						; size = 4
$T225539 = -152						; size = 4
$T225535 = -148						; size = 4
$T225531 = -144						; size = 4
$T225518 = -140						; size = 4
$T225517 = -136						; size = 4
$T225516 = -132						; size = 4
$T225515 = -128						; size = 4
$T225514 = -124						; size = 4
$T225513 = -120						; size = 4
$T225512 = -116						; size = 4
$T225511 = -112						; size = 4
$T225510 = -108						; size = 4
$T225509 = -104						; size = 4
$T225508 = -100						; size = 4
$T225507 = -96						; size = 4
$T225506 = -92						; size = 4
$T225505 = -88						; size = 4
$T225504 = -84						; size = 4
$T225503 = -80						; size = 4
$T225502 = -76						; size = 4
$T225501 = -72						; size = 4
_success$219857 = -68					; size = 1
_success$219839 = -67					; size = 1
_success$219828 = -66					; size = 1
_success$219813 = -65					; size = 1
_i$219800 = -64						; size = 4
_iPlayersPlaced$ = -60					; size = 4
_iMajorCivs$ = -56					; size = 4
_iHalfMinimumDist$ = -52				; size = 4
_iNextRegion$ = -48					; size = 4
_strString$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?AssignStartingLocations@CvStartPositioner@@QAEXXZ PROC	; CvStartPositioner::AssignStartingLocations, COMDAT
; _this$ = ecx

; 167  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AssignStartingLocations@CvStartPositioner@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 548				; 00000224H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 	CvString strString;

	lea	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 169  : 	unsigned int iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[ebp], 0

; 170  : 	int iPlayersPlaced = 0;

	mov	DWORD PTR _iPlayersPlaced$[ebp], 0

; 171  : 	int iMajorCivs = 0;

	mov	DWORD PTR _iMajorCivs$[ebp], 0

; 172  : 	for(size_t i = 0; i < m_PlayerOrder.size(); ++i)

	mov	DWORD PTR _i$219800[ebp], 0
	jmp	SHORT $LN25@AssignStar
$LN24@AssignStar:
	mov	eax, DWORD PTR _i$219800[ebp]
	add	eax, 1
	mov	DWORD PTR _i$219800[ebp], eax
$LN25@AssignStar:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR $T225531[ebp], ecx
	mov	edx, DWORD PTR $T225531[ebp]
	mov	eax, DWORD PTR $T225531[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	cmp	DWORD PTR _i$219800[ebp], ecx
	jae	SHORT $LN23@AssignStar

; 173  : 	{
; 174  : 		if(!GET_PLAYER((PlayerTypes)m_PlayerOrder[i].m_iPlayerID).isMinorCiv())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _i$219800[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T225535[ebp], edx
	mov	eax, DWORD PTR $T225535[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T225539[ebp], ecx
	mov	ecx, DWORD PTR $T225539[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN22@AssignStar

; 175  : 			iMajorCivs++;

	mov	eax, DWORD PTR _iMajorCivs$[ebp]
	add	eax, 1
	mov	DWORD PTR _iMajorCivs$[ebp], eax
$LN22@AssignStar:

; 176  : 	}

	jmp	SHORT $LN24@AssignStar
$LN23@AssignStar:

; 177  : 
; 178  : 	// MAJOR CIVS
; 179  : 	m_iRequiredSeparation = StartingPlotRange();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartingPlotRange@CvStartPositioner@@ABEHXZ ; CvStartPositioner::StartingPlotRange
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 180  : 
; 181  : 	// ***** Debug *****
; 182  : 	if(GC.getMap().getWorldSize() == WORLDSIZE_DEBUG)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225543[ebp], edx
	mov	ecx, DWORD PTR $T225543[ebp]
	call	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ; CvMap::getWorldSize
	cmp	eax, 6
	jne	SHORT $LN20@AssignStar

; 183  : 	{
; 184  : 		m_iRequiredSeparation = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 1
$LN20@AssignStar:

; 185  : 	}
; 186  : 
; 187  : 	while(iPlayersPlaced < iMajorCivs && iNextRegion < m_StartRegionVector.size())

	mov	ecx, DWORD PTR _iPlayersPlaced$[ebp]
	cmp	ecx, DWORD PTR _iMajorCivs$[ebp]
	jge	$LN19@AssignStar
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T225547[ebp], edx
	mov	eax, DWORD PTR $T225547[ebp]
	mov	ecx, DWORD PTR $T225547[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	cmp	DWORD PTR _iNextRegion$[ebp], edx
	jae	$LN19@AssignStar

; 188  : 	{
; 189  : 		if(m_StartRegionVector[iNextRegion].m_bLargeEnoughForMajorCiv)

	mov	eax, DWORD PTR _iNextRegion$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movzx	eax, BYTE PTR [edx+eax+24]
	test	eax, eax
	je	$LN18@AssignStar

; 190  : 		{
; 191  : 			strString.Format("Trying to place major civ with full separation of %d", m_iRequiredSeparation);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	push	OFFSET ??_C@_0DF@NLBIHFBD@Trying?5to?5place?5major?5civ?5with?5f@
	lea	eax, DWORD PTR _strString$[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 192  : 			LogStartPositionMessage(strString);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T225501[ebp], esp
	mov	DWORD PTR $T225555[ebp], ecx
	lea	edx, DWORD PTR _strString$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225555[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T225555[ebp]
	mov	DWORD PTR tv458[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 193  : 			bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], false);

	mov	ecx, DWORD PTR _iNextRegion$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR $T225559[ebp], ecx
	push	0
	sub	esp, 32					; 00000020H
	mov	eax, esp
	mov	DWORD PTR $T225502[ebp], esp
	mov	DWORD PTR $T225568[ebp], eax
	mov	ecx, DWORD PTR $T225568[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T225568[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T225568[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T225568[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T225559[ebp]
	mov	eax, DWORD PTR $T225568[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T225568[ebp]
	mov	ecx, DWORD PTR $T225559[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T225568[ebp]
	mov	ecx, DWORD PTR $T225559[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T225568[ebp]
	mov	ecx, DWORD PTR $T225559[ebp]
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR [eax+24], dl
	mov	eax, DWORD PTR $T225568[ebp]
	mov	ecx, DWORD PTR $T225559[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iPlayersPlaced$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T225572[ebp], eax
	mov	ecx, DWORD PTR $T225572[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion
	mov	BYTE PTR tv160[ebp], al
	mov	al, BYTE PTR tv160[ebp]
	mov	BYTE PTR _success$219813[ebp], al

; 194  : 			if(success)

	movzx	ecx, BYTE PTR _success$219813[ebp]
	test	ecx, ecx
	je	SHORT $LN18@AssignStar

; 195  : 			{
; 196  : 				iPlayersPlaced++;

	mov	edx, DWORD PTR _iPlayersPlaced$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayersPlaced$[ebp], edx

; 197  : 				m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	eax, DWORD PTR _iNextRegion$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	lea	eax, DWORD PTR [edx+eax+28]
	mov	DWORD PTR tv190[ebp], eax
	mov	ecx, DWORD PTR tv190[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR tv190[ebp]
	mov	DWORD PTR [eax], edx
$LN18@AssignStar:

; 198  : 			}
; 199  : 		}
; 200  : 		iNextRegion++;

	mov	ecx, DWORD PTR _iNextRegion$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNextRegion$[ebp], ecx

; 201  : 	}

	jmp	$LN20@AssignStar
$LN19@AssignStar:

; 202  : 
; 203  : 	// MAJOR CIVS AGAIN (those that couldn't be placed normal start distance apart)
; 204  : 
; 205  : 	int iHalfMinimumDist = GC.getMIN_CIV_STARTING_DISTANCE() / 2;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6244
	mov	DWORD PTR $T225579[ebp], edx
	mov	eax, DWORD PTR $T225579[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iHalfMinimumDist$[ebp], eax
$LN16@AssignStar:

; 206  : 	while(iPlayersPlaced < iMajorCivs && m_iRequiredSeparation >= 0)

	mov	eax, DWORD PTR _iPlayersPlaced$[ebp]
	cmp	eax, DWORD PTR _iMajorCivs$[ebp]
	jge	$LN15@AssignStar
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	jl	$LN15@AssignStar

; 207  : 	{
; 208  : 		// Resort by fertility (based on the fact that some of these regions are filling up)
; 209  : 		std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR $T225589[ebp], eax
	mov	ecx, DWORD PTR $T225589[ebp]
	mov	DWORD PTR $T225503[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T225605[ebp], eax
	mov	ecx, DWORD PTR $T225605[ebp]
	mov	DWORD PTR $T225504[ebp], ecx
	mov	edx, DWORD PTR $T225503[ebp]
	mov	DWORD PTR $T225628[ebp], edx
	mov	eax, DWORD PTR $T225504[ebp]
	mov	DWORD PTR $T225627[ebp], eax
	mov	ecx, DWORD PTR $T225628[ebp]
	sub	ecx, DWORD PTR $T225627[ebp]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR $T225628[ebp]
	push	edx
	mov	eax, DWORD PTR $T225627[ebp]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 210  : 
; 211  : 		// Reduce start distance by 1 (the previous condition could get stuck)
; 212  : 		m_iRequiredSeparation--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], edx

; 213  : 		iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[ebp], 0
$LN14@AssignStar:

; 214  : 
; 215  : 		while(iPlayersPlaced < iMajorCivs && iNextRegion < m_StartRegionVector.size())

	mov	ecx, DWORD PTR _iPlayersPlaced$[ebp]
	cmp	ecx, DWORD PTR _iMajorCivs$[ebp]
	jge	$LN13@AssignStar
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T225632[ebp], edx
	mov	eax, DWORD PTR $T225632[ebp]
	mov	ecx, DWORD PTR $T225632[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	cmp	DWORD PTR _iNextRegion$[ebp], edx
	jae	$LN13@AssignStar

; 216  : 		{
; 217  : 			if(m_StartRegionVector[iNextRegion].m_bLargeEnoughForMajorCiv)

	mov	eax, DWORD PTR _iNextRegion$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	movzx	eax, BYTE PTR [edx+eax+24]
	test	eax, eax
	je	$LN12@AssignStar

; 218  : 			{
; 219  : 				strString.Format("Trying to place major civ with reduced separation of %d", m_iRequiredSeparation);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	push	OFFSET ??_C@_0DI@OHIHEDCG@Trying?5to?5place?5major?5civ?5with?5r@
	lea	eax, DWORD PTR _strString$[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 220  : 				LogStartPositionMessage(strString);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T225505[ebp], esp
	mov	DWORD PTR $T225640[ebp], ecx
	lea	edx, DWORD PTR _strString$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225640[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T225640[ebp]
	mov	DWORD PTR tv460[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 221  : 				bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], m_iRequiredSeparation < iHalfMinimumDist);

	mov	ecx, DWORD PTR _iNextRegion$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR $T225644[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	cmp	ecx, DWORD PTR _iHalfMinimumDist$[ebp]
	setl	dl
	movzx	eax, dl
	push	eax
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	mov	DWORD PTR $T225506[ebp], esp
	mov	DWORD PTR $T225653[ebp], ecx
	mov	edx, DWORD PTR $T225653[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T225653[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T225653[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T225653[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T225644[ebp]
	mov	ecx, DWORD PTR $T225653[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T225653[ebp]
	mov	edx, DWORD PTR $T225644[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T225653[ebp]
	mov	edx, DWORD PTR $T225644[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR $T225653[ebp]
	mov	edx, DWORD PTR $T225644[ebp]
	mov	al, BYTE PTR [edx+24]
	mov	BYTE PTR [ecx+24], al
	mov	ecx, DWORD PTR $T225653[ebp]
	mov	edx, DWORD PTR $T225644[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _iPlayersPlaced$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T225657[ebp], ecx
	mov	edx, DWORD PTR $T225657[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion
	mov	BYTE PTR tv245[ebp], al
	mov	cl, BYTE PTR tv245[ebp]
	mov	BYTE PTR _success$219828[ebp], cl

; 222  : 				if(success)

	movzx	edx, BYTE PTR _success$219828[ebp]
	test	edx, edx
	je	SHORT $LN12@AssignStar

; 223  : 				{
; 224  : 					iPlayersPlaced++;

	mov	eax, DWORD PTR _iPlayersPlaced$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayersPlaced$[ebp], eax

; 225  : 					m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	ecx, DWORD PTR _iNextRegion$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	lea	ecx, DWORD PTR [eax+ecx+28]
	mov	DWORD PTR tv278[ebp], ecx
	mov	edx, DWORD PTR tv278[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR tv278[ebp]
	mov	DWORD PTR [ecx], eax
$LN12@AssignStar:

; 226  : 				}
; 227  : 			}
; 228  : 			iNextRegion++;

	mov	edx, DWORD PTR _iNextRegion$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNextRegion$[ebp], edx

; 229  : 		}

	jmp	$LN14@AssignStar
$LN13@AssignStar:

; 230  : 	}

	jmp	$LN16@AssignStar
$LN15@AssignStar:

; 231  : 
; 232  : 	CvAssertMsg(iPlayersPlaced == iMajorCivs, "AssignStartingLocations() can't find enough starting locations for major civs");
; 233  : 
; 234  : 	// MINOR CIVS
; 235  : 	m_iRequiredSeparation = StartingPlotRange();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartingPlotRange@CvStartPositioner@@ABEHXZ ; CvStartPositioner::StartingPlotRange
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 236  : 
; 237  : 	// Resort by fertility (based on the fact that some of these regions are filling up)
; 238  : 	std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR $T225670[ebp], eax
	mov	ecx, DWORD PTR $T225670[ebp]
	mov	DWORD PTR $T225507[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T225686[ebp], eax
	mov	ecx, DWORD PTR $T225686[ebp]
	mov	DWORD PTR $T225508[ebp], ecx
	mov	edx, DWORD PTR $T225507[ebp]
	mov	DWORD PTR $T225709[ebp], edx
	mov	eax, DWORD PTR $T225508[ebp]
	mov	DWORD PTR $T225708[ebp], eax
	mov	ecx, DWORD PTR $T225709[ebp]
	sub	ecx, DWORD PTR $T225708[ebp]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR $T225709[ebp]
	push	edx
	mov	eax, DWORD PTR $T225708[ebp]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH
$LN10@AssignStar:

; 239  : 	while(iPlayersPlaced < (int)m_PlayerOrder.size() && iNextRegion < m_StartRegionVector.size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR $T225713[ebp], ecx
	mov	edx, DWORD PTR $T225713[ebp]
	mov	eax, DWORD PTR $T225713[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	cmp	DWORD PTR _iPlayersPlaced$[ebp], ecx
	jge	$LN6@AssignStar
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T225717[ebp], edx
	mov	eax, DWORD PTR $T225717[ebp]
	mov	ecx, DWORD PTR $T225717[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	cmp	DWORD PTR _iNextRegion$[ebp], edx
	jae	$LN6@AssignStar

; 240  : 	{
; 241  : 		strString.Format("Trying to place minor civ with full separation of %d", m_iRequiredSeparation);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	push	OFFSET ??_C@_0DF@CDCCJHJP@Trying?5to?5place?5minor?5civ?5with?5f@
	lea	edx, DWORD PTR _strString$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 242  : 		LogStartPositionMessage(strString);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T225509[ebp], esp
	mov	DWORD PTR $T225722[ebp], eax
	lea	ecx, DWORD PTR _strString$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225722[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T225722[ebp]
	mov	DWORD PTR tv462[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 243  : 		bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], false);

	mov	eax, DWORD PTR _iNextRegion$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR $T225726[ebp], eax
	push	0
	sub	esp, 32					; 00000020H
	mov	edx, esp
	mov	DWORD PTR $T225510[ebp], esp
	mov	DWORD PTR $T225735[ebp], edx
	mov	eax, DWORD PTR $T225735[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T225735[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T225735[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T225735[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T225726[ebp]
	mov	edx, DWORD PTR $T225735[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T225735[ebp]
	mov	eax, DWORD PTR $T225726[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T225735[ebp]
	mov	eax, DWORD PTR $T225726[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR $T225735[ebp]
	mov	eax, DWORD PTR $T225726[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	edx, DWORD PTR $T225735[ebp]
	mov	eax, DWORD PTR $T225726[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _iPlayersPlaced$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T225739[ebp], edx
	mov	eax, DWORD PTR $T225739[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion
	mov	BYTE PTR tv322[ebp], al
	mov	dl, BYTE PTR tv322[ebp]
	mov	BYTE PTR _success$219839[ebp], dl

; 244  : 		if(success)

	movzx	eax, BYTE PTR _success$219839[ebp]
	test	eax, eax
	je	$LN8@AssignStar

; 245  : 		{
; 246  : 			iPlayersPlaced++;

	mov	ecx, DWORD PTR _iPlayersPlaced$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayersPlaced$[ebp], ecx

; 247  : 			m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	edx, DWORD PTR _iNextRegion$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	lea	edx, DWORD PTR [ecx+edx+28]
	mov	DWORD PTR tv352[ebp], edx
	mov	eax, DWORD PTR tv352[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv352[ebp]
	mov	DWORD PTR [edx], ecx

; 248  : 
; 249  : 			// Sort again, now that the region in slot 0 has another civ placed there
; 250  : 			std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T225752[ebp], ecx
	mov	edx, DWORD PTR $T225752[ebp]
	mov	DWORD PTR $T225511[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T225768[ebp], ecx
	mov	edx, DWORD PTR $T225768[ebp]
	mov	DWORD PTR $T225512[ebp], edx
	mov	eax, DWORD PTR $T225511[ebp]
	mov	DWORD PTR $T225791[ebp], eax
	mov	ecx, DWORD PTR $T225512[ebp]
	mov	DWORD PTR $T225790[ebp], ecx
	mov	edx, DWORD PTR $T225791[ebp]
	sub	edx, DWORD PTR $T225790[ebp]
	sar	edx, 5
	push	edx
	mov	eax, DWORD PTR $T225791[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225790[ebp]
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 251  : 			iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[ebp], 0

; 252  : 		}
; 253  : 
; 254  : 		// Failed, proceed through list of regions
; 255  : 		else

	jmp	SHORT $LN7@AssignStar
$LN8@AssignStar:

; 256  : 		{
; 257  : 			iNextRegion++;

	mov	edx, DWORD PTR _iNextRegion$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNextRegion$[ebp], edx
$LN7@AssignStar:

; 258  : 		}
; 259  : 	}

	jmp	$LN10@AssignStar
$LN6@AssignStar:

; 260  : 
; 261  : 	// MINOR CIVS AGAIN (those that couldn't be placed normal start distance apart)
; 262  : 	while(iPlayersPlaced < (int)m_PlayerOrder.size() && m_iRequiredSeparation >= 0)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR $T225795[ebp], eax
	mov	ecx, DWORD PTR $T225795[ebp]
	mov	edx, DWORD PTR $T225795[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	cmp	DWORD PTR _iPlayersPlaced$[ebp], eax
	jge	$LN5@AssignStar
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	jl	$LN5@AssignStar

; 263  : 	{
; 264  : 		// Resort by fertility (based on the fact that some of these regions are filling up)
; 265  : 		std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR $T225805[ebp], eax
	mov	ecx, DWORD PTR $T225805[ebp]
	mov	DWORD PTR $T225513[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T225821[ebp], eax
	mov	ecx, DWORD PTR $T225821[ebp]
	mov	DWORD PTR $T225514[ebp], ecx
	mov	edx, DWORD PTR $T225513[ebp]
	mov	DWORD PTR $T225844[ebp], edx
	mov	eax, DWORD PTR $T225514[ebp]
	mov	DWORD PTR $T225843[ebp], eax
	mov	ecx, DWORD PTR $T225844[ebp]
	sub	ecx, DWORD PTR $T225843[ebp]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR $T225844[ebp]
	push	edx
	mov	eax, DWORD PTR $T225843[ebp]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 266  : 
; 267  : 		// Reduce start distance by 10%
; 268  : 		m_iRequiredSeparation--;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], edx

; 269  : 		iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[ebp], 0
$LN4@AssignStar:

; 270  : 
; 271  : 		while(iPlayersPlaced < (int)m_PlayerOrder.size() && iNextRegion < m_StartRegionVector.size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR $T225848[ebp], ecx
	mov	edx, DWORD PTR $T225848[ebp]
	mov	eax, DWORD PTR $T225848[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	cmp	DWORD PTR _iPlayersPlaced$[ebp], ecx
	jge	$LN3@AssignStar
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T225852[ebp], edx
	mov	eax, DWORD PTR $T225852[ebp]
	mov	ecx, DWORD PTR $T225852[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	cmp	DWORD PTR _iNextRegion$[ebp], edx
	jae	$LN3@AssignStar

; 272  : 		{
; 273  : 			strString.Format("Trying to place minor civ with reduced separation of %d", m_iRequiredSeparation);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	push	OFFSET ??_C@_0DI@KFOMOJOG@Trying?5to?5place?5minor?5civ?5with?5r@
	lea	edx, DWORD PTR _strString$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 274  : 			LogStartPositionMessage(strString);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T225515[ebp], esp
	mov	DWORD PTR $T225857[ebp], eax
	lea	ecx, DWORD PTR _strString$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225857[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T225857[ebp]
	mov	DWORD PTR tv464[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 275  : 			bool success = AddCivToRegion(m_PlayerOrder[iPlayersPlaced].m_iPlayerID, m_StartRegionVector[iNextRegion], false);

	mov	eax, DWORD PTR _iNextRegion$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR $T225861[ebp], eax
	push	0
	sub	esp, 32					; 00000020H
	mov	edx, esp
	mov	DWORD PTR $T225516[ebp], esp
	mov	DWORD PTR $T225870[ebp], edx
	mov	eax, DWORD PTR $T225870[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T225870[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T225870[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T225870[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T225861[ebp]
	mov	edx, DWORD PTR $T225870[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T225870[ebp]
	mov	eax, DWORD PTR $T225861[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T225870[ebp]
	mov	eax, DWORD PTR $T225861[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR $T225870[ebp]
	mov	eax, DWORD PTR $T225861[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	edx, DWORD PTR $T225870[ebp]
	mov	eax, DWORD PTR $T225861[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _iPlayersPlaced$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T225874[ebp], edx
	mov	eax, DWORD PTR $T225874[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ; CvStartPositioner::AddCivToRegion
	mov	BYTE PTR tv413[ebp], al
	mov	dl, BYTE PTR tv413[ebp]
	mov	BYTE PTR _success$219857[ebp], dl

; 276  : 			if(success)

	movzx	eax, BYTE PTR _success$219857[ebp]
	test	eax, eax
	je	$LN2@AssignStar

; 277  : 			{
; 278  : 				iPlayersPlaced++;

	mov	ecx, DWORD PTR _iPlayersPlaced$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlayersPlaced$[ebp], ecx

; 279  : 				m_StartRegionVector[iNextRegion].m_iNumCivsPlaced++;

	mov	edx, DWORD PTR _iNextRegion$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	lea	edx, DWORD PTR [ecx+edx+28]
	mov	DWORD PTR tv443[ebp], edx
	mov	eax, DWORD PTR tv443[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR tv443[ebp]
	mov	DWORD PTR [edx], ecx

; 280  : 
; 281  : 				// Sort again, now that the region in slot 0 has another civ placed there
; 282  : 				std::sort(m_StartRegionVector.begin(), m_StartRegionVector.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T225887[ebp], ecx
	mov	edx, DWORD PTR $T225887[ebp]
	mov	DWORD PTR $T225517[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T225903[ebp], ecx
	mov	edx, DWORD PTR $T225903[ebp]
	mov	DWORD PTR $T225518[ebp], edx
	mov	eax, DWORD PTR $T225517[ebp]
	mov	DWORD PTR $T226325[ebp], eax
	mov	ecx, DWORD PTR $T225518[ebp]
	mov	DWORD PTR $T226324[ebp], ecx
	mov	edx, DWORD PTR $T226325[ebp]
	sub	edx, DWORD PTR $T226324[ebp]
	sar	edx, 5
	push	edx
	mov	eax, DWORD PTR $T226325[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226324[ebp]
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 283  : 				iNextRegion = 0;

	mov	DWORD PTR _iNextRegion$[ebp], 0

; 284  : 			}
; 285  : 
; 286  : 			// Failed, proceed through list of regions
; 287  : 			else

	jmp	SHORT $LN1@AssignStar
$LN2@AssignStar:

; 288  : 			{
; 289  : 				iNextRegion++;

	mov	edx, DWORD PTR _iNextRegion$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNextRegion$[ebp], edx
$LN1@AssignStar:

; 290  : 			}
; 291  : 		}

	jmp	$LN4@AssignStar
$LN3@AssignStar:

; 292  : 	}

	jmp	$LN6@AssignStar
$LN5@AssignStar:

; 293  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AssignStartingLocations@CvStartPositioner@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AssignStartingLocations@CvStartPositioner@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-552]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AssignStartingLocations@CvStartPositioner@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AssignStartingLocations@CvStartPositioner@@QAEXXZ ENDP	; CvStartPositioner::AssignStartingLocations
PUBLIC	?GetRegion@CvStartPositioner@@QAEHHH@Z		; CvStartPositioner::GetRegion
; Function compile flags: /Odtp
;	COMDAT ?GetRegion@CvStartPositioner@@QAEHHH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T226351 = -13						; size = 1
$T226345 = -12						; size = 4
$T226341 = -8						; size = 4
_iRegion$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?GetRegion@CvStartPositioner@@QAEHHH@Z PROC		; CvStartPositioner::GetRegion, COMDAT
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	int iRegion = 0;

	mov	DWORD PTR _iRegion$[ebp], 0
$LN3@GetRegion:

; 299  : 
; 300  : 	while(iRegion < (int)m_StartRegionVector.size())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T226341[ebp], eax
	mov	ecx, DWORD PTR $T226341[ebp]
	mov	edx, DWORD PTR $T226341[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 5
	cmp	DWORD PTR _iRegion$[ebp], eax
	jge	SHORT $LN2@GetRegion

; 301  : 	{
; 302  : 		if(m_StartRegionVector[iRegion].Contains(iX, iY))

	mov	ecx, DWORD PTR _iRegion$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR $T226345[ebp], ecx
	mov	eax, DWORD PTR $T226345[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jg	SHORT $LN10@GetRegion
	mov	edx, DWORD PTR $T226345[ebp]
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jl	SHORT $LN10@GetRegion
	mov	ecx, DWORD PTR $T226345[ebp]
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jg	SHORT $LN10@GetRegion
	mov	eax, DWORD PTR $T226345[ebp]
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN11@GetRegion
$LN10@GetRegion:
	mov	BYTE PTR $T226351[ebp], 0
	jmp	SHORT $LN12@GetRegion
$LN11@GetRegion:
	mov	BYTE PTR $T226351[ebp], 1
$LN12@GetRegion:
	movzx	edx, BYTE PTR $T226351[ebp]
	test	edx, edx
	je	SHORT $LN1@GetRegion

; 303  : 		{
; 304  : 			return iRegion;

	mov	eax, DWORD PTR _iRegion$[ebp]
	jmp	SHORT $LN4@GetRegion
$LN1@GetRegion:

; 305  : 		}
; 306  : 		iRegion++;

	mov	eax, DWORD PTR _iRegion$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRegion$[ebp], eax

; 307  : 	}

	jmp	SHORT $LN3@GetRegion
$LN2@GetRegion:

; 308  : 
; 309  : 	return -1;

	or	eax, -1
$LN4@GetRegion:

; 310  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetRegion@CvStartPositioner@@QAEHHH@Z ENDP		; CvStartPositioner::GetRegion
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back
PUBLIC	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion
PUBLIC	??0CvStartRegion@@QAE@ABV0@@Z			; CvStartRegion::CvStartRegion
PUBLIC	??0CvStartRegion@@QAE@XZ			; CvStartRegion::CvStartRegion
EXTRN	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ:PROC ; CvArea::getAreaBoundaries
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
; Function compile flags: /Odtp
;	COMDAT ?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T226382 = -72						; size = 4
$T226378 = -68						; size = 4
$T226374 = -64						; size = 4
$T226370 = -60						; size = 4
$T226366 = -56						; size = 4
$T226354 = -48						; size = 16
_region$ = -32						; size = 32
_continent$ = 8						; size = 16
?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z PROC ; CvStartPositioner::DivideContinentIntoRegions, COMDAT
; _this$ = ecx

; 316  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 317  : 	// Create a start region out of the entire continent
; 318  : 	CvStartRegion region;

	lea	ecx, DWORD PTR _region$[ebp]
	call	??0CvStartRegion@@QAE@XZ		; CvStartRegion::CvStartRegion

; 319  : 	region.m_uiFertility = continent.GetFertility();

	mov	eax, DWORD PTR _continent$[ebp]
	mov	DWORD PTR _region$[ebp+16], eax

; 320  : 	region.m_iAreaID = continent.GetArea();

	mov	ecx, DWORD PTR _continent$[ebp+12]
	mov	DWORD PTR $T226366[ebp], ecx
	mov	edx, DWORD PTR $T226366[ebp]
	mov	DWORD PTR _region$[ebp+20], edx

; 321  : 	region.m_Boundaries = GC.getMap().getArea(continent.GetArea())->getAreaBoundaries();

	mov	eax, DWORD PTR _continent$[ebp+12]
	mov	DWORD PTR $T226370[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226374[ebp], ecx
	lea	edx, DWORD PTR $T226354[ebp]
	push	edx
	mov	eax, DWORD PTR $T226370[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226374[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _region$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _region$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _region$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _region$[ebp+12], edx

; 322  : 
; 323  : 	// Make sure this is a continent that is getting a start region
; 324  : 	if(continent.GetNumRegions() > 0)

	mov	eax, DWORD PTR _continent$[ebp+8]
	mov	DWORD PTR $T226378[ebp], eax
	cmp	DWORD PTR $T226378[ebp], 0
	jle	SHORT $LN2@DivideCont

; 325  : 	{
; 326  : 		// If so, call recursive routine to subdivide it appropriately
; 327  : 		SubdivideRegion(region, continent.GetNumRegions());

	mov	ecx, DWORD PTR _continent$[ebp+8]
	mov	DWORD PTR $T226382[ebp], ecx
	mov	edx, DWORD PTR $T226382[ebp]
	push	edx
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	eax, DWORD PTR _region$[ebp]
	push	eax
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 328  : 	}
; 329  : 
; 330  : 	// If the continent is too small for a major civ, it still could be useful for a minor
; 331  : 	else

	jmp	SHORT $LN3@DivideCont
$LN2@DivideCont:

; 332  : 	{
; 333  : 		region.m_bLargeEnoughForMajorCiv = false;

	mov	BYTE PTR _region$[ebp+24], 0

; 334  : 		m_StartRegionVector.push_back(region);

	lea	ecx, DWORD PTR _region$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back
$LN3@DivideCont:

; 335  : 	}
; 336  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DivideContinentIntoRegions@CvStartPositioner@@AAEXVCvContinent@@@Z ENDP ; CvStartPositioner::DivideContinentIntoRegions
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.h
_TEXT	ENDS
;	COMDAT ??0CvStartRegion@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvStartRegion@@QAE@XZ PROC				; CvStartRegion::CvStartRegion, COMDAT
; _this$ = ecx

; 98   : 	CvStartRegion()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 99   : 	{
; 100  : 		m_uiFertility = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 101  : 		m_iAreaID = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], -1

; 102  : 		m_bLargeEnoughForMajorCiv = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1

; 103  : 		m_iNumCivsPlaced = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 104  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvStartRegion@@QAE@XZ ENDP				; CvStartRegion::CvStartRegion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CvStartRegion@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
??0CvStartRegion@@QAE@ABV0@@Z PROC			; CvStartRegion::CvStartRegion, COMDAT
; _this$ = ecx

; 106  : 	CvStartRegion(const CvStartRegion& source)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 107  : 	{
; 108  : 		m_Boundaries = source.m_Boundaries;

	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 109  : 		m_uiFertility = source.m_uiFertility;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx

; 110  : 		m_iAreaID = source.m_iAreaID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx

; 111  : 		m_bLargeEnoughForMajorCiv = source.m_bLargeEnoughForMajorCiv;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl

; 112  : 		m_iNumCivsPlaced = source.m_iNumCivsPlaced;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx

; 113  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CvStartRegion@@QAE@ABV0@@Z ENDP			; CvStartRegion::CvStartRegion
_TEXT	ENDS
EXTRN	?setTotalFoundValue@CvArea@@QAEXH@Z:PROC	; CvArea::setTotalFoundValue
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T226545 = -52						; size = 4
$T226541 = -48						; size = 4
$T226534 = -44						; size = 4
$T226530 = -40						; size = 4
$T226526 = -36						; size = 4
$T226522 = -32						; size = 4
$T226518 = -28						; size = 4
_pArea$219900 = -24					; size = 4
_pLoopArea$ = -20					; size = 4
_uiFertility$ = -16					; size = 4
_iI$ = -12						; size = 4
_pLoopPlot$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ PROC ; CvStartPositioner::ComputeTileFertilityValues, COMDAT
; _this$ = ecx

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 	CvArea* pLoopArea(NULL);

	mov	DWORD PTR _pLoopArea$[ebp], 0

; 342  : 	int iLoop;
; 343  : 	CvPlot* pLoopPlot(NULL);

	mov	DWORD PTR _pLoopPlot$[ebp], 0

; 344  : #ifdef AUI_WARNING_FIXES
; 345  : 	uint iI;
; 346  : #else
; 347  : 	int iI;
; 348  : #endif
; 349  : 	int uiFertility;
; 350  : 
; 351  : 	// Set all area fertilities to 0
; 352  : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226518[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226518[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
	jmp	SHORT $LN9@ComputeTil
$LN8@ComputeTil:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226522[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226522[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
$LN9@ComputeTil:
	cmp	DWORD PTR _pLoopArea$[ebp], 0
	je	SHORT $LN7@ComputeTil

; 353  : 	{
; 354  : 		pLoopArea->setTotalFoundValue(0);

	push	0
	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue

; 355  : 	}

	jmp	SHORT $LN8@ComputeTil
$LN7@ComputeTil:

; 356  : 
; 357  : 	// Now process through the map
; 358  : 	for(iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@ComputeTil
$LN5@ComputeTil:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN6@ComputeTil:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226526[ebp], edx
	mov	eax, DWORD PTR $T226526[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T226530[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR $T226530[ebp]
	jge	$LN10@ComputeTil

; 359  : 	{
; 360  : 		pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226534[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T226534[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], ecx

; 361  : 		CvAssert(pLoopPlot);
; 362  : 		if(!pLoopPlot) continue;

	jne	SHORT $LN3@ComputeTil
	jmp	SHORT $LN5@ComputeTil
$LN3@ComputeTil:

; 363  : 
; 364  : 		// Compute fertility and save off in player 0's found value slot
; 365  : 		//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 366  : 		//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 367  : 		uiFertility = m_pSiteEvaluator->PlotFertilityValue(pLoopPlot);

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _uiFertility$[ebp], eax

; 368  : 		pLoopPlot->setFoundValue((PlayerTypes)0, uiFertility);

	mov	ecx, DWORD PTR _uiFertility$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::setFoundValue

; 369  : 
; 370  : 		if(uiFertility > 0)

	cmp	DWORD PTR _uiFertility$[ebp], 0
	jle	SHORT $LN2@ComputeTil

; 371  : 		{
; 372  : 			// Add to total for area
; 373  : 			CvArea* pArea = GC.getMap().getArea(pLoopPlot->getArea());

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T226541[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226545[ebp], ecx
	mov	edx, DWORD PTR $T226541[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226545[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pArea$219900[ebp], eax

; 374  : 			CvAssert(pArea);
; 375  : 			if(!pArea) continue;

	cmp	DWORD PTR _pArea$219900[ebp], 0
	jne	SHORT $LN1@ComputeTil
	jmp	$LN5@ComputeTil
$LN1@ComputeTil:

; 376  : 			pArea->setTotalFoundValue(pArea->getTotalFoundValue() + uiFertility);

	mov	ecx, DWORD PTR _pArea$219900[ebp]
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	add	eax, DWORD PTR _uiFertility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$219900[ebp]
	call	?setTotalFoundValue@CvArea@@QAEXH@Z	; CvArea::setTotalFoundValue
$LN2@ComputeTil:

; 377  : 		}

	jmp	$LN5@ComputeTil
$LN10@ComputeTil:

; 378  : 	}
; 379  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ComputeTileFertilityValues@CvStartPositioner@@AAEXXZ ENDP ; CvStartPositioner::ComputeTileFertilityValues
_TEXT	ENDS
PUBLIC	?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z ; CvStartPositioner::ChopIntoThreeRegions
PUBLIC	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions
; Function compile flags: /Odtp
;	COMDAT ?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z
_TEXT	SEGMENT
tv72 = -160						; size = 4
_this$ = -156						; size = 4
_secondRegion$219936 = -108				; size = 32
_thirdRegion$219937 = -76				; size = 32
_secondRegion$219931 = -44				; size = 32
_bTaller$219912 = -9					; size = 1
_iNumDivides$ = -8					; size = 4
_iLaterSubdivisions$ = -4				; size = 4
_region$ = 8						; size = 32
_iNumDivisions$ = 40					; size = 4
?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z PROC ; CvStartPositioner::SubdivideRegion, COMDAT
; _this$ = ecx

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 	int iNumDivides = 0;

	mov	DWORD PTR _iNumDivides$[ebp], 0

; 385  : 	int iLaterSubdivisions = 0;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 0

; 386  : 
; 387  : 	// Break recursion when number of divisions is down to 1
; 388  : 	if(iNumDivisions == 1)

	cmp	DWORD PTR _iNumDivisions$[ebp], 1
	jne	SHORT $LN21@SubdivideR

; 389  : 	{
; 390  : 		// Store this as a final region
; 391  : 		m_StartRegionVector.push_back(region);

	lea	eax, DWORD PTR _region$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back
	jmp	$LN22@SubdivideR
$LN21@SubdivideR:

; 392  : 	}
; 393  : 
; 394  : 	// Need to subdivide
; 395  : 	else if(iNumDivisions > 1)

	cmp	DWORD PTR _iNumDivisions$[ebp], 1
	jle	$LN22@SubdivideR

; 396  : 	{
; 397  : 		// See if region is taller or wider
; 398  : 		bool bTaller = true;

	mov	BYTE PTR _bTaller$219912[ebp], 1

; 399  : 		if((region.m_Boundaries.m_iNorthEdge - region.m_Boundaries.m_iSouthEdge) <
; 400  : 		        (region.m_Boundaries.m_iEastEdge - region.m_Boundaries.m_iWestEdge))

	mov	ecx, DWORD PTR _region$[ebp]
	sub	ecx, DWORD PTR _region$[ebp+4]
	mov	edx, DWORD PTR _region$[ebp+8]
	sub	edx, DWORD PTR _region$[ebp+12]
	cmp	ecx, edx
	jge	SHORT $LN18@SubdivideR

; 401  : 		{
; 402  : 			bTaller = false;

	mov	BYTE PTR _bTaller$219912[ebp], 0
$LN18@SubdivideR:

; 403  : 		}
; 404  : 
; 405  : 		// If number of divisions is greater than 3...
; 406  : 		//
; 407  : 		// Number       First Divide     Each Subdivision
; 408  : 		// ------       ------------     ----------------
; 409  : 		//   4                2                 2
; 410  : 		//  5-6               3                 2
; 411  : 		//  7-8               2                 4
; 412  : 		//   9                3                 3
; 413  : 		// 10-12              3                 4
; 414  : 		// 13-16              2                 8
; 415  : 		// 17-18              3                 6
; 416  : 		// 19-20              2                10
; 417  : 		// 21-22              3                 8
; 418  : 		switch(iNumDivisions)

	mov	eax, DWORD PTR _iNumDivisions$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 20			; 00000014H
	ja	$LN16@SubdivideR
	mov	edx, DWORD PTR tv72[ebp]
	movzx	eax, BYTE PTR $LN74@SubdivideR[edx]
	jmp	DWORD PTR $LN75@SubdivideR[eax*4]
$LN15@SubdivideR:

; 419  : 		{
; 420  : 		case 2:
; 421  : 			iNumDivides = 2;

	mov	DWORD PTR _iNumDivides$[ebp], 2

; 422  : 			iLaterSubdivisions = 1;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 1

; 423  : 			break;

	jmp	$LN16@SubdivideR
$LN14@SubdivideR:

; 424  : 		case 3:
; 425  : 			iNumDivides = 3;

	mov	DWORD PTR _iNumDivides$[ebp], 3

; 426  : 			iLaterSubdivisions = 1;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 1

; 427  : 			break;

	jmp	$LN16@SubdivideR
$LN13@SubdivideR:

; 428  : 		case 4:
; 429  : 			iNumDivides = 2;

	mov	DWORD PTR _iNumDivides$[ebp], 2

; 430  : 			iLaterSubdivisions = 2;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 2

; 431  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN12@SubdivideR:

; 432  : 		case 5:
; 433  : 		case 6:
; 434  : 			iNumDivides = 3;

	mov	DWORD PTR _iNumDivides$[ebp], 3

; 435  : 			iLaterSubdivisions = 2;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 2

; 436  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN11@SubdivideR:

; 437  : 		case 7:
; 438  : 		case 8:
; 439  : 			iNumDivides = 2;

	mov	DWORD PTR _iNumDivides$[ebp], 2

; 440  : 			iLaterSubdivisions = 4;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 4

; 441  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN10@SubdivideR:

; 442  : 		case 9:
; 443  : 			iNumDivides = 3;

	mov	DWORD PTR _iNumDivides$[ebp], 3

; 444  : 			iLaterSubdivisions = 3;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 3

; 445  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN9@SubdivideR:

; 446  : 		case 10:
; 447  : 		case 11:
; 448  : 		case 12:
; 449  : 			iNumDivides = 3;

	mov	DWORD PTR _iNumDivides$[ebp], 3

; 450  : 			iLaterSubdivisions = 4;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 4

; 451  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN8@SubdivideR:

; 452  : 		case 13:
; 453  : 		case 14:
; 454  : 		case 15:
; 455  : 		case 16:
; 456  : 			iNumDivides = 2;

	mov	DWORD PTR _iNumDivides$[ebp], 2

; 457  : 			iLaterSubdivisions = 8;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 8

; 458  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN7@SubdivideR:

; 459  : 		case 17:
; 460  : 		case 18:
; 461  : 			iNumDivides = 3;

	mov	DWORD PTR _iNumDivides$[ebp], 3

; 462  : 			iLaterSubdivisions = 6;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 6

; 463  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN6@SubdivideR:

; 464  : 		case 19:
; 465  : 		case 20:
; 466  : 			iNumDivides = 2;

	mov	DWORD PTR _iNumDivides$[ebp], 2

; 467  : 			iLaterSubdivisions = 10;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 10	; 0000000aH

; 468  : 			break;

	jmp	SHORT $LN16@SubdivideR
$LN5@SubdivideR:

; 469  : 		case 21:
; 470  : 		case 22:
; 471  : 			iNumDivides = 3;

	mov	DWORD PTR _iNumDivides$[ebp], 3

; 472  : 			iLaterSubdivisions = 8;

	mov	DWORD PTR _iLaterSubdivisions$[ebp], 8
$LN16@SubdivideR:

; 473  : 			break;
; 474  : 		default:
; 475  : 			CvAssertMsg(false, "Trying to create regions for more than 18 major civs.");
; 476  : 		}
; 477  : 
; 478  : 		if(iNumDivides == 2)

	cmp	DWORD PTR _iNumDivides$[ebp], 2
	jne	SHORT $LN3@SubdivideR

; 479  : 		{
; 480  : 			CvStartRegion secondRegion;

	lea	ecx, DWORD PTR _secondRegion$219931[ebp]
	call	??0CvStartRegion@@QAE@XZ		; CvStartRegion::CvStartRegion

; 481  : 			ChopIntoTwoRegions(bTaller, &region, &secondRegion, 50);

	push	50					; 00000032H
	lea	ecx, DWORD PTR _secondRegion$219931[ebp]
	push	ecx
	lea	edx, DWORD PTR _region$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bTaller$219912[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions

; 482  : 			SubdivideRegion(region, iLaterSubdivisions);

	mov	ecx, DWORD PTR _iLaterSubdivisions$[ebp]
	push	ecx
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	edx, DWORD PTR _region$[ebp]
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 483  : 			SubdivideRegion(secondRegion, iLaterSubdivisions);

	mov	eax, DWORD PTR _iLaterSubdivisions$[ebp]
	push	eax
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	edx, DWORD PTR _secondRegion$219931[ebp]
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion
	jmp	$LN22@SubdivideR
$LN3@SubdivideR:

; 484  : 		}
; 485  : 		else if(iNumDivides == 3)

	cmp	DWORD PTR _iNumDivides$[ebp], 3
	jne	$LN22@SubdivideR

; 486  : 		{
; 487  : 			CvStartRegion secondRegion;

	lea	ecx, DWORD PTR _secondRegion$219936[ebp]
	call	??0CvStartRegion@@QAE@XZ		; CvStartRegion::CvStartRegion

; 488  : 			CvStartRegion thirdRegion;

	lea	ecx, DWORD PTR _thirdRegion$219937[ebp]
	call	??0CvStartRegion@@QAE@XZ		; CvStartRegion::CvStartRegion

; 489  : 			ChopIntoThreeRegions(bTaller, &region, &secondRegion, &thirdRegion);

	lea	eax, DWORD PTR _thirdRegion$219937[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondRegion$219936[ebp]
	push	ecx
	lea	edx, DWORD PTR _region$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bTaller$219912[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z ; CvStartPositioner::ChopIntoThreeRegions

; 490  : 			SubdivideRegion(region, iLaterSubdivisions);

	mov	ecx, DWORD PTR _iLaterSubdivisions$[ebp]
	push	ecx
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	edx, DWORD PTR _region$[ebp]
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 491  : 			SubdivideRegion(secondRegion, iLaterSubdivisions);

	mov	eax, DWORD PTR _iLaterSubdivisions$[ebp]
	push	eax
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	edx, DWORD PTR _secondRegion$219936[ebp]
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion

; 492  : 			SubdivideRegion(thirdRegion, iLaterSubdivisions);

	mov	eax, DWORD PTR _iLaterSubdivisions$[ebp]
	push	eax
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	edx, DWORD PTR _thirdRegion$219937[ebp]
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ; CvStartPositioner::SubdivideRegion
$LN22@SubdivideR:

; 493  : 		}
; 494  : 	}
; 495  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
	npad	1
$LN75@SubdivideR:
	DD	$LN15@SubdivideR
	DD	$LN14@SubdivideR
	DD	$LN13@SubdivideR
	DD	$LN12@SubdivideR
	DD	$LN11@SubdivideR
	DD	$LN10@SubdivideR
	DD	$LN9@SubdivideR
	DD	$LN8@SubdivideR
	DD	$LN7@SubdivideR
	DD	$LN6@SubdivideR
	DD	$LN5@SubdivideR
$LN74@SubdivideR:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	4
	DB	4
	DB	5
	DB	6
	DB	6
	DB	6
	DB	7
	DB	7
	DB	7
	DB	7
	DB	8
	DB	8
	DB	9
	DB	9
	DB	10					; 0000000aH
	DB	10					; 0000000aH
?SubdivideRegion@CvStartPositioner@@AAEXVCvStartRegion@@H@Z ENDP ; CvStartPositioner::SubdivideRegion
_TEXT	ENDS
PUBLIC	?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ; CvStartPositioner::ComputeRowFertility
; Function compile flags: /Odtp
;	COMDAT ?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_iEastEdge$219958 = -16					; size = 4
_iNorthEdge$219953 = -12				; size = 4
_uiFertilitySoFar$ = -8					; size = 4
_uiTargetFertility$ = -4				; size = 4
_bTaller$ = 8						; size = 1
_region$ = 12						; size = 4
_secondRegion$ = 16					; size = 4
_iChopPercent$ = 20					; size = 4
?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z PROC ; CvStartPositioner::ChopIntoTwoRegions, COMDAT
; _this$ = ecx

; 499  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 500  : 	CvAssert(region);
; 501  : 	if(!region) return;

	cmp	DWORD PTR _region$[ebp], 0
	jne	SHORT $LN8@ChopIntoTw
	jmp	$LN9@ChopIntoTw
$LN8@ChopIntoTw:

; 502  : 	CvAssert(secondRegion);
; 503  : 	if(!secondRegion) return;

	cmp	DWORD PTR _secondRegion$[ebp], 0
	jne	SHORT $LN7@ChopIntoTw
	jmp	$LN9@ChopIntoTw
$LN7@ChopIntoTw:

; 504  : 
; 505  : 	int uiTargetFertility;
; 506  : 	int uiFertilitySoFar = 0;

	mov	DWORD PTR _uiFertilitySoFar$[ebp], 0

; 507  : 
; 508  : 	// Do some initialization on second region
; 509  : 	secondRegion->m_iAreaID = region->m_iAreaID;

	mov	eax, DWORD PTR _secondRegion$[ebp]
	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 510  : 
; 511  : 	// How much fertility do we want in the first region?
; 512  : 	uiTargetFertility = region->m_uiFertility * iChopPercent / 100;

	mov	eax, DWORD PTR _region$[ebp]
	mov	eax, DWORD PTR [eax+16]
	imul	eax, DWORD PTR _iChopPercent$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _uiTargetFertility$[ebp], eax

; 513  : 
; 514  : 	// Taller than wide
; 515  : 	if(bTaller)

	movzx	edx, BYTE PTR _bTaller$[ebp]
	test	edx, edx
	je	SHORT $LN6@ChopIntoTw

; 516  : 	{
; 517  : 		// We know that the second region will have the same width and same north edge
; 518  : 		secondRegion->m_Boundaries.m_iEastEdge = region->m_Boundaries.m_iEastEdge;

	mov	eax, DWORD PTR _secondRegion$[ebp]
	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 519  : 		secondRegion->m_Boundaries.m_iWestEdge = region->m_Boundaries.m_iWestEdge;

	mov	eax, DWORD PTR _secondRegion$[ebp]
	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 520  : 		secondRegion->m_Boundaries.m_iNorthEdge = region->m_Boundaries.m_iNorthEdge;

	mov	eax, DWORD PTR _secondRegion$[ebp]
	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 521  : 
; 522  : 		// Move up one row at a time until we have exceeded the target fertility
; 523  : 		int iNorthEdge = region->m_Boundaries.m_iSouthEdge;

	mov	eax, DWORD PTR _region$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _iNorthEdge$219953[ebp], ecx
$LN5@ChopIntoTw:

; 524  : 		while(uiFertilitySoFar < uiTargetFertility)

	mov	edx, DWORD PTR _uiFertilitySoFar$[ebp]
	cmp	edx, DWORD PTR _uiTargetFertility$[ebp]
	jge	SHORT $LN4@ChopIntoTw

; 525  : 		{
; 526  : 			uiFertilitySoFar += ComputeRowFertility(region->m_iAreaID,
; 527  : 			                                        region->m_Boundaries.m_iWestEdge, region->m_Boundaries.m_iEastEdge, iNorthEdge, iNorthEdge);

	mov	eax, DWORD PTR _iNorthEdge$219953[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNorthEdge$219953[ebp]
	push	ecx
	mov	edx, DWORD PTR _region$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _region$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ; CvStartPositioner::ComputeRowFertility
	add	eax, DWORD PTR _uiFertilitySoFar$[ebp]
	mov	DWORD PTR _uiFertilitySoFar$[ebp], eax

; 528  : 			iNorthEdge++;

	mov	edx, DWORD PTR _iNorthEdge$219953[ebp]
	add	edx, 1
	mov	DWORD PTR _iNorthEdge$219953[ebp], edx

; 529  : 		}

	jmp	SHORT $LN5@ChopIntoTw
$LN4@ChopIntoTw:

; 530  : 
; 531  : 		// Set edges
; 532  : 		region->m_Boundaries.m_iNorthEdge = iNorthEdge - 1;

	mov	eax, DWORD PTR _iNorthEdge$219953[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _region$[ebp]
	mov	DWORD PTR [ecx], eax

; 533  : 		secondRegion->m_Boundaries.m_iSouthEdge = iNorthEdge;

	mov	edx, DWORD PTR _secondRegion$[ebp]
	mov	eax, DWORD PTR _iNorthEdge$219953[ebp]
	mov	DWORD PTR [edx+4], eax

; 534  : 	}
; 535  : 
; 536  : 	// Wider than tall
; 537  : 	else

	jmp	SHORT $LN3@ChopIntoTw
$LN6@ChopIntoTw:

; 538  : 	{
; 539  : 		// We know that the second region will have the same height and same east edge
; 540  : 		secondRegion->m_Boundaries.m_iNorthEdge = region->m_Boundaries.m_iNorthEdge;

	mov	ecx, DWORD PTR _secondRegion$[ebp]
	mov	edx, DWORD PTR _region$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 541  : 		secondRegion->m_Boundaries.m_iSouthEdge = region->m_Boundaries.m_iSouthEdge;

	mov	ecx, DWORD PTR _secondRegion$[ebp]
	mov	edx, DWORD PTR _region$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 542  : 		secondRegion->m_Boundaries.m_iEastEdge = region->m_Boundaries.m_iEastEdge;

	mov	ecx, DWORD PTR _secondRegion$[ebp]
	mov	edx, DWORD PTR _region$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 543  : 
; 544  : 		// Move right one column at a time until we have exceeded the target fertility
; 545  : 		int iEastEdge = region->m_Boundaries.m_iWestEdge;

	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _iEastEdge$219958[ebp], edx
$LN2@ChopIntoTw:

; 546  : 		while(uiFertilitySoFar < uiTargetFertility)

	mov	eax, DWORD PTR _uiFertilitySoFar$[ebp]
	cmp	eax, DWORD PTR _uiTargetFertility$[ebp]
	jge	SHORT $LN1@ChopIntoTw

; 547  : 		{
; 548  : 			uiFertilitySoFar += ComputeRowFertility(region->m_iAreaID,
; 549  : 			                                        iEastEdge, iEastEdge, region->m_Boundaries.m_iSouthEdge, region->m_Boundaries.m_iNorthEdge);

	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _region$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _iEastEdge$219958[ebp]
	push	edx
	mov	eax, DWORD PTR _iEastEdge$219958[ebp]
	push	eax
	mov	ecx, DWORD PTR _region$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ; CvStartPositioner::ComputeRowFertility
	add	eax, DWORD PTR _uiFertilitySoFar$[ebp]
	mov	DWORD PTR _uiFertilitySoFar$[ebp], eax

; 550  : 			iEastEdge++;

	mov	eax, DWORD PTR _iEastEdge$219958[ebp]
	add	eax, 1
	mov	DWORD PTR _iEastEdge$219958[ebp], eax

; 551  : 		}

	jmp	SHORT $LN2@ChopIntoTw
$LN1@ChopIntoTw:

; 552  : 
; 553  : 		// Set edges
; 554  : 		region->m_Boundaries.m_iEastEdge = iEastEdge - 1;

	mov	ecx, DWORD PTR _iEastEdge$219958[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _region$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 555  : 		secondRegion->m_Boundaries.m_iWestEdge = iEastEdge;

	mov	eax, DWORD PTR _secondRegion$[ebp]
	mov	ecx, DWORD PTR _iEastEdge$219958[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN3@ChopIntoTw:

; 556  : 	}
; 557  : 
; 558  : 	// Finish initializing regions
; 559  : 	secondRegion->m_uiFertility = region->m_uiFertility - uiFertilitySoFar;

	mov	edx, DWORD PTR _region$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR _uiFertilitySoFar$[ebp]
	mov	ecx, DWORD PTR _secondRegion$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 560  : 	region->m_uiFertility = uiFertilitySoFar;

	mov	edx, DWORD PTR _region$[ebp]
	mov	eax, DWORD PTR _uiFertilitySoFar$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN9@ChopIntoTw:

; 561  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ENDP ; CvStartPositioner::ChopIntoTwoRegions
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bTaller$ = 8						; size = 1
_region$ = 12						; size = 4
_secondRegion$ = 16					; size = 4
_thirdRegion$ = 20					; size = 4
?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z PROC ; CvStartPositioner::ChopIntoThreeRegions, COMDAT
; _this$ = ecx

; 565  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 	CvAssert(region);
; 567  : 	if(!region) return;

	cmp	DWORD PTR _region$[ebp], 0
	jne	SHORT $LN3@ChopIntoTh
	jmp	SHORT $LN4@ChopIntoTh
$LN3@ChopIntoTh:

; 568  : 	CvAssert(secondRegion);
; 569  : 	if(!secondRegion) return;

	cmp	DWORD PTR _secondRegion$[ebp], 0
	jne	SHORT $LN2@ChopIntoTh
	jmp	SHORT $LN4@ChopIntoTh
$LN2@ChopIntoTh:

; 570  : 	CvAssert(thirdRegion);
; 571  : 	if(!thirdRegion) return;

	cmp	DWORD PTR _thirdRegion$[ebp], 0
	jne	SHORT $LN1@ChopIntoTh
	jmp	SHORT $LN4@ChopIntoTh
$LN1@ChopIntoTh:

; 572  : 
; 573  : 	// Chop off the first third
; 574  : 	ChopIntoTwoRegions(bTaller, region, secondRegion, 33);

	push	33					; 00000021H
	mov	eax, DWORD PTR _secondRegion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _region$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bTaller$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions

; 575  : 
; 576  : 	// Chop the bigger piece in half
; 577  : 	ChopIntoTwoRegions(bTaller, secondRegion, thirdRegion, 50);

	push	50					; 00000032H
	mov	eax, DWORD PTR _thirdRegion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _secondRegion$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bTaller$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChopIntoTwoRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@1H@Z ; CvStartPositioner::ChopIntoTwoRegions
$LN4@ChopIntoTh:

; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ChopIntoThreeRegions@CvStartPositioner@@AAEX_NPAVCvStartRegion@@11@Z ENDP ; CvStartPositioner::ChopIntoThreeRegions
_TEXT	ENDS
EXTRN	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z:PROC ; CvPlot::getFoundValue
; Function compile flags: /Odtp
;	COMDAT ?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z
_TEXT	SEGMENT
tv144 = -72						; size = 4
tv159 = -68						; size = 4
_this$ = -64						; size = 4
$T226736 = -60						; size = 4
$T226688 = -56						; size = 4
$T226675 = -52						; size = 4
$T226671 = -48						; size = 4
$T226657 = -44						; size = 4
$T226653 = -37						; size = 1
$T226642 = -36						; size = 4
$T226638 = -29						; size = 1
_iMapY$226732 = -28					; size = 4
_iMapX$226731 = -24					; size = 4
$T226631 = -20						; size = 4
_pPlot$219989 = -16					; size = 4
_iCol$219985 = -12					; size = 4
_iRow$219981 = -8					; size = 4
_rtnValue$ = -4						; size = 4
_iAreaID$ = 8						; size = 4
_xMin$ = 12						; size = 4
_xMax$ = 16						; size = 4
_yMin$ = 20						; size = 4
_yMax$ = 24						; size = 4
?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z PROC ; CvStartPositioner::ComputeRowFertility, COMDAT
; _this$ = ecx

; 582  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 583  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 584  : 
; 585  : 	for(int iRow = yMin; iRow <= yMax; iRow++)

	mov	eax, DWORD PTR _yMin$[ebp]
	mov	DWORD PTR _iRow$219981[ebp], eax
	jmp	SHORT $LN7@ComputeRow
$LN6@ComputeRow:
	mov	ecx, DWORD PTR _iRow$219981[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRow$219981[ebp], ecx
$LN7@ComputeRow:
	mov	edx, DWORD PTR _iRow$219981[ebp]
	cmp	edx, DWORD PTR _yMax$[ebp]
	jg	$LN5@ComputeRow

; 586  : 	{
; 587  : 		for(int iCol = xMin; iCol <= xMax; iCol++)

	mov	eax, DWORD PTR _xMin$[ebp]
	mov	DWORD PTR _iCol$219985[ebp], eax
	jmp	SHORT $LN4@ComputeRow
$LN3@ComputeRow:
	mov	ecx, DWORD PTR _iCol$219985[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCol$219985[ebp], ecx
$LN4@ComputeRow:
	mov	edx, DWORD PTR _iCol$219985[ebp]
	cmp	edx, DWORD PTR _xMax$[ebp]
	jg	$LN2@ComputeRow

; 588  : 		{
; 589  : 			CvPlot* pPlot = GC.getMap().plot(iCol, iRow);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226631[ebp], eax
	cmp	DWORD PTR _iCol$219985[ebp], -2147483647 ; 80000001H
	je	SHORT $LN12@ComputeRow
	cmp	DWORD PTR _iRow$219981[ebp], -2147483647 ; 80000001H
	jne	SHORT $LN13@ComputeRow
$LN12@ComputeRow:
	mov	DWORD PTR _pPlot$219989[ebp], 0
	jmp	$LN14@ComputeRow
$LN13@ComputeRow:
	mov	ecx, DWORD PTR $T226631[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T226638[ebp], dl
	mov	eax, DWORD PTR $T226631[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226642[ebp], ecx
	movzx	edx, BYTE PTR $T226638[ebp]
	test	edx, edx
	je	SHORT $LN25@ComputeRow
	cmp	DWORD PTR _iCol$219985[ebp], 0
	jge	SHORT $LN24@ComputeRow
	mov	eax, DWORD PTR _iCol$219985[ebp]
	cdq
	idiv	DWORD PTR $T226642[ebp]
	add	edx, DWORD PTR $T226642[ebp]
	mov	DWORD PTR _iMapX$226731[ebp], edx
	jmp	SHORT $LN26@ComputeRow
	jmp	SHORT $LN25@ComputeRow
$LN24@ComputeRow:
	mov	eax, DWORD PTR _iCol$219985[ebp]
	cmp	eax, DWORD PTR $T226642[ebp]
	jl	SHORT $LN25@ComputeRow
	mov	eax, DWORD PTR _iCol$219985[ebp]
	cdq
	idiv	DWORD PTR $T226642[ebp]
	mov	DWORD PTR _iMapX$226731[ebp], edx
	jmp	SHORT $LN26@ComputeRow
$LN25@ComputeRow:
	mov	ecx, DWORD PTR _iCol$219985[ebp]
	mov	DWORD PTR _iMapX$226731[ebp], ecx
$LN26@ComputeRow:
	mov	edx, DWORD PTR $T226631[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T226653[ebp], al
	mov	ecx, DWORD PTR $T226631[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T226657[ebp], edx
	movzx	eax, BYTE PTR $T226653[ebp]
	test	eax, eax
	je	SHORT $LN35@ComputeRow
	cmp	DWORD PTR _iRow$219981[ebp], 0
	jge	SHORT $LN34@ComputeRow
	mov	eax, DWORD PTR _iRow$219981[ebp]
	cdq
	idiv	DWORD PTR $T226657[ebp]
	add	edx, DWORD PTR $T226657[ebp]
	mov	DWORD PTR _iMapY$226732[ebp], edx
	jmp	SHORT $LN36@ComputeRow
	jmp	SHORT $LN35@ComputeRow
$LN34@ComputeRow:
	mov	ecx, DWORD PTR _iRow$219981[ebp]
	cmp	ecx, DWORD PTR $T226657[ebp]
	jl	SHORT $LN35@ComputeRow
	mov	eax, DWORD PTR _iRow$219981[ebp]
	cdq
	idiv	DWORD PTR $T226657[ebp]
	mov	DWORD PTR _iMapY$226732[ebp], edx
	jmp	SHORT $LN36@ComputeRow
$LN35@ComputeRow:
	mov	edx, DWORD PTR _iRow$219981[ebp]
	mov	DWORD PTR _iMapY$226732[ebp], edx
$LN36@ComputeRow:
	cmp	DWORD PTR _iMapX$226731[ebp], 0
	jl	SHORT $LN40@ComputeRow
	mov	eax, DWORD PTR $T226631[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226671[ebp], ecx
	mov	edx, DWORD PTR _iMapX$226731[ebp]
	cmp	edx, DWORD PTR $T226671[ebp]
	jge	SHORT $LN40@ComputeRow
	cmp	DWORD PTR _iMapY$226732[ebp], 0
	jl	SHORT $LN40@ComputeRow
	mov	eax, DWORD PTR $T226631[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T226675[ebp], ecx
	mov	edx, DWORD PTR _iMapY$226732[ebp]
	cmp	edx, DWORD PTR $T226675[ebp]
	jge	SHORT $LN40@ComputeRow
	mov	DWORD PTR tv159[ebp], 1
	jmp	SHORT $LN38@ComputeRow
$LN40@ComputeRow:
	mov	DWORD PTR tv159[ebp], 0
$LN38@ComputeRow:
	cmp	DWORD PTR tv159[ebp], 0
	je	SHORT $LN16@ComputeRow
	mov	eax, DWORD PTR $T226631[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226688[ebp], ecx
	mov	edx, DWORD PTR _iMapY$226732[ebp]
	imul	edx, DWORD PTR $T226688[ebp]
	add	edx, DWORD PTR _iMapX$226731[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T226631[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv144[ebp], edx
	jmp	SHORT $LN17@ComputeRow
$LN16@ComputeRow:
	mov	DWORD PTR tv144[ebp], 0
$LN17@ComputeRow:
	mov	ecx, DWORD PTR tv144[ebp]
	mov	DWORD PTR _pPlot$219989[ebp], ecx
$LN14@ComputeRow:

; 590  : 
; 591  : 			if(pPlot && pPlot->getArea() == iAreaID)

	cmp	DWORD PTR _pPlot$219989[ebp], 0
	je	SHORT $LN1@ComputeRow
	mov	edx, DWORD PTR _pPlot$219989[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T226736[ebp], eax
	mov	ecx, DWORD PTR $T226736[ebp]
	cmp	ecx, DWORD PTR _iAreaID$[ebp]
	jne	SHORT $LN1@ComputeRow

; 592  : 			{
; 593  : 				// Retrieve from player 0's found value slot
; 594  : 				//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 595  : 				//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 596  : 				rtnValue += pPlot->getFoundValue((PlayerTypes)0);

	push	0
	mov	ecx, DWORD PTR _pPlot$219989[ebp]
	call	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ; CvPlot::getFoundValue
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@ComputeRow:

; 597  : 			}
; 598  : 		}

	jmp	$LN3@ComputeRow
$LN2@ComputeRow:

; 599  : 	}

	jmp	$LN6@ComputeRow
$LN5@ComputeRow:

; 600  : 
; 601  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 602  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?ComputeRowFertility@CvStartPositioner@@AAEHHHHHH@Z ENDP ; CvStartPositioner::ComputeRowFertility
_TEXT	ENDS
PUBLIC	??_C@_0DM@GJJMMFKJ@Adding?5player?0?5id?5?$DN?5?$CFd?0?5plot?5x?5?$DN@ ; `string'
PUBLIC	?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z ; CvStartPositioner::TooCloseToAnotherCiv
PUBLIC	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	__$ArrayPad$
EXTRN	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z:PROC ; CvPlayer::setStartingPlot
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ:PROC	; CvMinorCivInfo::GetMinorCivTrait
EXTRN	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z:PROC ; CvGlobals::getMinorCivInfo
EXTRN	?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ:PROC ; CvMinorCivAI::GetMinorCivType
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
;	COMDAT ??_C@_0DM@GJJMMFKJ@Adding?5player?0?5id?5?$DN?5?$CFd?0?5plot?5x?5?$DN@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DM@GJJMMFKJ@Adding?5player?0?5id?5?$DN?5?$CFd?0?5plot?5x?5?$DN@ DB 'A'
	DB	'dding player, id = %d, plot x = %d, y = %d, fertility = %u', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z$0
__ehfuncinfo$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
_TEXT	SEGMENT
tv250 = -192						; size = 4
tv330 = -188						; size = 4
tv342 = -184						; size = 4
_this$ = -180						; size = 4
$T226896 = -176						; size = 4
$T226888 = -172						; size = 4
$T226881 = -168						; size = 4
$T226877 = -164						; size = 4
$T226835 = -160						; size = 4
$T226822 = -156						; size = 4
$T226818 = -152						; size = 4
$T226811 = -148						; size = 4
$T226807 = -141						; size = 1
$T226796 = -140						; size = 4
$T226792 = -133						; size = 1
_iMapY$226873 = -132					; size = 4
_iMapX$226872 = -128					; size = 4
$T226785 = -124						; size = 4
$T226781 = -120						; size = 4
$T226777 = -116						; size = 4
$T226762 = -112						; size = 4
$T226758 = -108						; size = 4
$T226742 = -102						; size = 1
$T226741 = -101						; size = 1
$T226740 = -100						; size = 4
_iCol$220019 = -96					; size = 4
_iRow$220015 = -92					; size = 4
_uiBestFoundValue$ = -88				; size = 4
_eMinorCivType$ = -84					; size = 4
_pBestPlot$ = -80					; size = 4
_iMajorFoodReq$ = -76					; size = 4
_bIsMinorCiv$ = -69					; size = 1
_uiPlotFoundValue$ = -68				; size = 4
_iPercentOfBest$ = -64					; size = 4
_strString$ = -60					; size = 28
__$ArrayPad$ = -32					; size = 4
_pLoopPlot$ = -28					; size = 4
_iMinorFoodReq$ = -24					; size = 4
_eTeam$ = -20						; size = 4
_bDebugMap$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_iPlayerIndex$ = 8					; size = 4
_region$ = 12						; size = 32
_bRelaxFoodReq$ = 44					; size = 1
?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z PROC ; CvStartPositioner::AddCivToRegion, COMDAT
; _this$ = ecx

; 606  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 	CvString strString;

	lea	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 608  : 	int uiBestFoundValue = 0;

	mov	DWORD PTR _uiBestFoundValue$[ebp], 0

; 609  : 	int uiPlotFoundValue;
; 610  : 	CvPlot* pBestPlot = NULL;

	mov	DWORD PTR _pBestPlot$[ebp], 0

; 611  : 	CvPlot* pLoopPlot = NULL;

	mov	DWORD PTR _pLoopPlot$[ebp], 0

; 612  : 	int iMinorFoodReq = GC.getMINOR_CIV_FOOD_REQUIREMENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7148
	mov	DWORD PTR _iMinorFoodReq$[ebp], eax

; 613  : 	int iMajorFoodReq = GC.getMAJOR_CIV_FOOD_REQUIREMENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7152
	mov	DWORD PTR _iMajorFoodReq$[ebp], ecx

; 614  : 	bool bIsMinorCiv = GET_PLAYER((PlayerTypes)iPlayerIndex).isMinorCiv();

	mov	edx, DWORD PTR _iPlayerIndex$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226758[ebp], edx
	mov	ecx, DWORD PTR $T226758[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	BYTE PTR _bIsMinorCiv$[ebp], al

; 615  : 	TeamTypes eTeam = GET_PLAYER((PlayerTypes)iPlayerIndex).getTeam();

	mov	eax, DWORD PTR _iPlayerIndex$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226762[ebp], eax
	mov	ecx, DWORD PTR $T226762[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 616  : 	int iPercentOfBest = GC.getMIN_START_FOUND_VALUE_AS_PERCENT_OF_BEST();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7156
	mov	DWORD PTR _iPercentOfBest$[ebp], eax

; 617  : 
; 618  : 	MinorCivTypes eMinorCivType = NO_MINORCIV;

	mov	DWORD PTR _eMinorCivType$[ebp], -1

; 619  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 620  : 	CvMinorCivInfo* pMinorCivInfo = NULL;
; 621  : #endif
; 622  : 	if(bIsMinorCiv)

	movzx	ecx, BYTE PTR _bIsMinorCiv$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@AddCivToRe

; 623  : 	{
; 624  : 		eMinorCivType =GET_PLAYER((PlayerTypes) iPlayerIndex).GetMinorCivAI()->GetMinorCivType();

	mov	edx, DWORD PTR _iPlayerIndex$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226777[ebp], edx
	mov	ecx, DWORD PTR $T226777[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetMinorCivType@CvMinorCivAI@@QBE?AW4MinorCivTypes@@XZ ; CvMinorCivAI::GetMinorCivType
	mov	DWORD PTR _eMinorCivType$[ebp], eax
$LN23@AddCivToRe:

; 625  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 626  : 		pMinorCivInfo = GC.getMinorCivInfo(eMinorCivType);
; 627  : #endif
; 628  : 	}
; 629  : 
; 630  : 	bool bDebugMap = GC.getMap().getWorldSize() == WORLDSIZE_DEBUG;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226781[ebp], eax
	mov	ecx, DWORD PTR $T226781[ebp]
	call	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ; CvMap::getWorldSize
	xor	ecx, ecx
	cmp	eax, 6
	sete	cl
	mov	BYTE PTR _bDebugMap$[ebp], cl

; 631  : 
; 632  : 	// ***** Debug *****
; 633  : 	if(bDebugMap)

	movzx	edx, BYTE PTR _bDebugMap$[ebp]
	test	edx, edx
	je	SHORT $LN22@AddCivToRe

; 634  : 	{
; 635  : 		iMinorFoodReq = 0;

	mov	DWORD PTR _iMinorFoodReq$[ebp], 0

; 636  : 		iMajorFoodReq = 0;

	mov	DWORD PTR _iMajorFoodReq$[ebp], 0
$LN22@AddCivToRe:

; 637  : 	}
; 638  : 
; 639  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 640  : 	CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(GET_PLAYER((PlayerTypes)iPlayerIndex).getCivilizationType());
; 641  : #endif
; 642  : 
; 643  : 	// Find best found value in region
; 644  : 	for(int iRow = region.m_Boundaries.m_iSouthEdge; iRow <= region.m_Boundaries.m_iNorthEdge; iRow++)

	mov	eax, DWORD PTR _region$[ebp+4]
	mov	DWORD PTR _iRow$220015[ebp], eax
	jmp	SHORT $LN21@AddCivToRe
$LN20@AddCivToRe:
	mov	ecx, DWORD PTR _iRow$220015[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRow$220015[ebp], ecx
$LN21@AddCivToRe:
	mov	edx, DWORD PTR _iRow$220015[ebp]
	cmp	edx, DWORD PTR _region$[ebp]
	jg	$LN19@AddCivToRe

; 645  : 	{
; 646  : 		for(int iCol = region.m_Boundaries.m_iWestEdge; iCol <= region.m_Boundaries.m_iEastEdge; iCol++)

	mov	eax, DWORD PTR _region$[ebp+12]
	mov	DWORD PTR _iCol$220019[ebp], eax
	jmp	SHORT $LN18@AddCivToRe
$LN17@AddCivToRe:
	mov	ecx, DWORD PTR _iCol$220019[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCol$220019[ebp], ecx
$LN18@AddCivToRe:
	mov	edx, DWORD PTR _iCol$220019[ebp]
	cmp	edx, DWORD PTR _region$[ebp+8]
	jg	$LN16@AddCivToRe

; 647  : 		{
; 648  : 			pLoopPlot = GC.getMap().plot(iCol, iRow);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T226785[ebp], eax
	cmp	DWORD PTR _iCol$220019[ebp], -2147483647 ; 80000001H
	je	SHORT $LN51@AddCivToRe
	cmp	DWORD PTR _iRow$220015[ebp], -2147483647 ; 80000001H
	jne	SHORT $LN52@AddCivToRe
$LN51@AddCivToRe:
	mov	DWORD PTR _pLoopPlot$[ebp], 0
	jmp	$LN53@AddCivToRe
$LN52@AddCivToRe:
	mov	ecx, DWORD PTR $T226785[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T226792[ebp], dl
	mov	eax, DWORD PTR $T226785[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226796[ebp], ecx
	movzx	edx, BYTE PTR $T226792[ebp]
	test	edx, edx
	je	SHORT $LN64@AddCivToRe
	cmp	DWORD PTR _iCol$220019[ebp], 0
	jge	SHORT $LN63@AddCivToRe
	mov	eax, DWORD PTR _iCol$220019[ebp]
	cdq
	idiv	DWORD PTR $T226796[ebp]
	add	edx, DWORD PTR $T226796[ebp]
	mov	DWORD PTR _iMapX$226872[ebp], edx
	jmp	SHORT $LN65@AddCivToRe
	jmp	SHORT $LN64@AddCivToRe
$LN63@AddCivToRe:
	mov	eax, DWORD PTR _iCol$220019[ebp]
	cmp	eax, DWORD PTR $T226796[ebp]
	jl	SHORT $LN64@AddCivToRe
	mov	eax, DWORD PTR _iCol$220019[ebp]
	cdq
	idiv	DWORD PTR $T226796[ebp]
	mov	DWORD PTR _iMapX$226872[ebp], edx
	jmp	SHORT $LN65@AddCivToRe
$LN64@AddCivToRe:
	mov	ecx, DWORD PTR _iCol$220019[ebp]
	mov	DWORD PTR _iMapX$226872[ebp], ecx
$LN65@AddCivToRe:
	mov	edx, DWORD PTR $T226785[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T226807[ebp], al
	mov	ecx, DWORD PTR $T226785[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T226811[ebp], edx
	movzx	eax, BYTE PTR $T226807[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226811[ebp]
	push	ecx
	mov	edx, DWORD PTR _iRow$220015[ebp]
	push	edx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$226873[ebp], eax
	cmp	DWORD PTR _iMapX$226872[ebp], 0
	jl	SHORT $LN73@AddCivToRe
	mov	eax, DWORD PTR $T226785[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226818[ebp], ecx
	mov	edx, DWORD PTR _iMapX$226872[ebp]
	cmp	edx, DWORD PTR $T226818[ebp]
	jge	SHORT $LN73@AddCivToRe
	cmp	DWORD PTR _iMapY$226873[ebp], 0
	jl	SHORT $LN73@AddCivToRe
	mov	eax, DWORD PTR $T226785[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T226822[ebp], ecx
	mov	edx, DWORD PTR _iMapY$226873[ebp]
	cmp	edx, DWORD PTR $T226822[ebp]
	jge	SHORT $LN73@AddCivToRe
	mov	DWORD PTR tv342[ebp], 1
	jmp	SHORT $LN71@AddCivToRe
$LN73@AddCivToRe:
	mov	DWORD PTR tv342[ebp], 0
$LN71@AddCivToRe:
	cmp	DWORD PTR tv342[ebp], 0
	je	SHORT $LN55@AddCivToRe
	mov	eax, DWORD PTR $T226785[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226835[ebp], ecx
	mov	edx, DWORD PTR _iMapY$226873[ebp]
	imul	edx, DWORD PTR $T226835[ebp]
	add	edx, DWORD PTR _iMapX$226872[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T226785[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv330[ebp], edx
	jmp	SHORT $LN56@AddCivToRe
$LN55@AddCivToRe:
	mov	DWORD PTR tv330[ebp], 0
$LN56@AddCivToRe:
	mov	ecx, DWORD PTR tv330[ebp]
	mov	DWORD PTR _pLoopPlot$[ebp], ecx
$LN53@AddCivToRe:

; 649  : 
; 650  : 			// Make sure it actually *is* in region
; 651  : 			if(pLoopPlot && pLoopPlot->getArea() == region.m_iAreaID)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	$LN15@AddCivToRe
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T226877[ebp], eax
	mov	ecx, DWORD PTR $T226877[ebp]
	cmp	ecx, DWORD PTR _region$[ebp+20]
	jne	$LN15@AddCivToRe

; 652  : 			{
; 653  : 				// Check food requirement
; 654  : 				if((bRelaxFoodReq && MeetsFoodRequirement(pLoopPlot, eTeam, iMinorFoodReq))
; 655  : 				        || (bIsMinorCiv && MeetsFoodRequirement(pLoopPlot, eTeam, iMinorFoodReq))
; 656  : 				        || MeetsFoodRequirement(pLoopPlot, eTeam, iMajorFoodReq))

	movzx	edx, BYTE PTR _bRelaxFoodReq$[ebp]
	test	edx, edx
	je	SHORT $LN12@AddCivToRe
	mov	eax, DWORD PTR _iMinorFoodReq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@AddCivToRe
$LN12@AddCivToRe:
	movzx	ecx, BYTE PTR _bIsMinorCiv$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@AddCivToRe
	mov	edx, DWORD PTR _iMinorFoodReq$[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@AddCivToRe
$LN11@AddCivToRe:
	mov	eax, DWORD PTR _iMajorFoodReq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ; CvStartPositioner::MeetsFoodRequirement
	movzx	eax, al
	test	eax, eax
	je	$LN15@AddCivToRe
$LN13@AddCivToRe:

; 657  : 				{
; 658  : #ifdef AUI_STARTPOSITIONER_FLAVORED_STARTS
; 659  : 					// Plot found values are now calculated for each player to account for flavoring
; 660  : 					uiPlotFoundValue = m_pSiteEvaluator->PlotFoundValue(pLoopPlot, &(GET_PLAYER((PlayerTypes)iPlayerIndex)));
; 661  : #else
; 662  : 					// Retrieve from player 1's found value slot
; 663  : 					//   (Normally shouldn't be using a hard-coded player reference, but here in the pre-game initialization it is safe to do so.
; 664  : 					//    Allows us to reuse this data storage instead of jamming even more data into the CvPlot class that will never be used at run-time).
; 665  : 					uiPlotFoundValue = pLoopPlot->getFoundValue((PlayerTypes)1);

	push	1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ; CvPlot::getFoundValue
	mov	DWORD PTR _uiPlotFoundValue$[ebp], eax

; 666  : #endif
; 667  : 
; 668  : 					// If we're a Maritime Minor Civ then decrease the value of non-coastal starts
; 669  : #ifdef AUI_STARTPOSITIONER_COASTAL_CIV_WATER_BIAS
; 670  : 					if ((pMinorCivInfo && pMinorCivInfo->GetMinorCivTrait() == MINOR_CIV_TRAIT_MARITIME) ||
; 671  : 						(!pMinorCivInfo && pCivInfo && pCivInfo->isCoastalCiv()))
; 672  : 					{
; 673  : #else
; 674  : 					if(bIsMinorCiv)

	movzx	ecx, BYTE PTR _bIsMinorCiv$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@AddCivToRe

; 675  : 					{
; 676  : 						if(GC.getMinorCivInfo(eMinorCivType)->GetMinorCivTrait() == MINOR_CIV_TRAIT_MARITIME)

	mov	edx, DWORD PTR _eMinorCivType$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMinorCivInfo@CvGlobals@@QAEPAVCvMinorCivInfo@@W4MinorCivTypes@@@Z ; CvGlobals::getMinorCivInfo
	mov	ecx, eax
	call	?GetMinorCivTrait@CvMinorCivInfo@@QBEHXZ ; CvMinorCivInfo::GetMinorCivTrait
	cmp	eax, 2
	jne	SHORT $LN10@AddCivToRe

; 677  : #endif
; 678  : 						{
; 679  : 							if(!pLoopPlot->isCoastalLand(GC.getLAKE_MAX_AREA_SIZE()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6508
	mov	DWORD PTR $T226881[ebp], eax
	mov	ecx, DWORD PTR $T226881[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@AddCivToRe

; 680  : 							{
; 681  : 								uiPlotFoundValue /= 2;

	mov	eax, DWORD PTR _uiPlotFoundValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _uiPlotFoundValue$[ebp], eax
$LN10@AddCivToRe:

; 682  : 							}
; 683  : 						}
; 684  : 					}
; 685  : 
; 686  : 					// Above the minimum found value?
; 687  : 					if(bDebugMap || ((int)uiPlotFoundValue > (int)m_iBestFoundValueOnMap * iPercentOfBest / 100))

	movzx	eax, BYTE PTR _bDebugMap$[ebp]
	test	eax, eax
	jne	SHORT $LN6@AddCivToRe
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	imul	eax, DWORD PTR _iPercentOfBest$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _uiPlotFoundValue$[ebp], eax
	jle	SHORT $LN15@AddCivToRe
$LN6@AddCivToRe:

; 688  : 					{
; 689  : 						// Check distance
; 690  : 						if(!TooCloseToAnotherCiv(pLoopPlot))

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z ; CvStartPositioner::TooCloseToAnotherCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN15@AddCivToRe

; 691  : 						{
; 692  : 							// Best so far?
; 693  : 							if(bDebugMap || uiPlotFoundValue > uiBestFoundValue)

	movzx	ecx, BYTE PTR _bDebugMap$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@AddCivToRe
	mov	edx, DWORD PTR _uiPlotFoundValue$[ebp]
	cmp	edx, DWORD PTR _uiBestFoundValue$[ebp]
	jle	SHORT $LN15@AddCivToRe
$LN3@AddCivToRe:

; 694  : 							{
; 695  : 								uiBestFoundValue = uiPlotFoundValue;

	mov	eax, DWORD PTR _uiPlotFoundValue$[ebp]
	mov	DWORD PTR _uiBestFoundValue$[ebp], eax

; 696  : 								pBestPlot = pLoopPlot;

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	mov	DWORD PTR _pBestPlot$[ebp], ecx
$LN15@AddCivToRe:

; 697  : 							}
; 698  : 						}
; 699  : 					}
; 700  : 				}
; 701  : 			}
; 702  : 		}

	jmp	$LN17@AddCivToRe
$LN16@AddCivToRe:

; 703  : 	}

	jmp	$LN20@AddCivToRe
$LN19@AddCivToRe:

; 704  : 
; 705  : 	if(pBestPlot != NULL)

	cmp	DWORD PTR _pBestPlot$[ebp], 0
	je	$LN2@AddCivToRe

; 706  : 	{
; 707  : 		GET_PLAYER((PlayerTypes)iPlayerIndex).setStartingPlot(pBestPlot);

	mov	edx, DWORD PTR _pBestPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _iPlayerIndex$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?setStartingPlot@CvPlayer@@QAEXPAVCvPlot@@@Z ; CvPlayer::setStartingPlot

; 708  : 		strString.Format("Adding player, id = %d, plot x = %d, y = %d, fertility = %u",
; 709  : 		                 iPlayerIndex, pBestPlot->getX(), pBestPlot->getY(), uiBestFoundValue);

	mov	eax, DWORD PTR _pBestPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T226888[ebp], ecx
	mov	edx, DWORD PTR _uiBestFoundValue$[ebp]
	push	edx
	mov	eax, DWORD PTR $T226888[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _iPlayerIndex$[ebp]
	push	eax
	push	OFFSET ??_C@_0DM@GJJMMFKJ@Adding?5player?0?5id?5?$DN?5?$CFd?0?5plot?5x?5?$DN@
	lea	ecx, DWORD PTR _strString$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 710  : 		LogStartPositionMessage(strString);

	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T226740[ebp], esp
	mov	DWORD PTR $T226896[ebp], edx
	lea	eax, DWORD PTR _strString$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226896[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T226896[ebp]
	mov	DWORD PTR tv250[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ; CvStartPositioner::LogStartPositionMessage

; 711  : 		return true;

	mov	BYTE PTR $T226741[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T226741[ebp]
	jmp	SHORT $LN24@AddCivToRe

; 712  : 	}
; 713  : 	else

	jmp	SHORT $LN1@AddCivToRe
$LN2@AddCivToRe:

; 714  : 	{
; 715  : 		return false;

	mov	BYTE PTR $T226742[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T226742[ebp]
	jmp	SHORT $LN24@AddCivToRe
$LN1@AddCivToRe:

; 716  : 	}
; 717  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN24@AddCivToRe:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z$0:
	lea	ecx, DWORD PTR _strString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddCivToRegion@CvStartPositioner@@AAE_NHVCvStartRegion@@_N@Z ENDP ; CvStartPositioner::AddCivToRegion
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Odtp
;	COMDAT ?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -212						; size = 4
$T227026 = -128						; size = 4
$T227022 = -124						; size = 4
$T227018 = -120						; size = 4
$T227014 = -116						; size = 4
$T227010 = -112						; size = 4
$T226957 = -52						; size = 4
$T226953 = -48						; size = 4
$T226949 = -44						; size = 4
$T226945 = -40						; size = 4
$T226941 = -36						; size = 4
$T226937 = -32						; size = 4
$T226933 = -28						; size = 4
$T226929 = -21						; size = 1
$T226920 = -20						; size = 4
_iSeparationIfOnAnotherContinent$220064 = -16		; size = 4
_pStartPlot$ = -12					; size = 4
_rtnValue$ = -5						; size = 1
_iI$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z PROC ; CvStartPositioner::TooCloseToAnotherCiv, COMDAT
; _this$ = ecx

; 721  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	DWORD PTR _this$[ebp], ecx

; 722  : 	int iI;
; 723  : 	bool rtnValue = false;

	mov	BYTE PTR _rtnValue$[ebp], 0

; 724  : 	CvPlot* pStartPlot(NULL);

	mov	DWORD PTR _pStartPlot$[ebp], 0

; 725  : 
; 726  : 	CvAssert(pPlot);
; 727  : 	if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN10@TooCloseTo

; 728  : 		return rtnValue;

	mov	al, BYTE PTR _rtnValue$[ebp]
	jmp	$LN11@TooCloseTo
$LN10@TooCloseTo:

; 729  : 
; 730  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN9@TooCloseTo
$LN8@TooCloseTo:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN9@TooCloseTo:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN7@TooCloseTo

; 731  : 	{
; 732  : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226920[ebp], ecx
	mov	edx, DWORD PTR $T226920[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T226929[ebp], al
	movzx	ecx, BYTE PTR $T226929[ebp]
	test	ecx, ecx
	je	$LN6@TooCloseTo

; 733  : 		{
; 734  : 			pStartPlot = GET_PLAYER((PlayerTypes)iI).getStartingPlot();

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226933[ebp], edx
	mov	ecx, DWORD PTR $T226933[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	DWORD PTR _pStartPlot$[ebp], eax

; 735  : 			if(pStartPlot != NULL)

	cmp	DWORD PTR _pStartPlot$[ebp], 0
	je	$LN6@TooCloseTo

; 736  : 			{
; 737  : 				// If in same area, use full distance
; 738  : 				if(pStartPlot->getArea() == pPlot->getArea())

	mov	eax, DWORD PTR _pStartPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T226937[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T226941[ebp], eax
	mov	ecx, DWORD PTR $T226937[ebp]
	cmp	ecx, DWORD PTR $T226941[ebp]
	jne	SHORT $LN4@TooCloseTo

; 739  : 				{
; 740  : 					if(plotDistance(pPlot->getX(), pPlot->getY(),
; 741  : 					                pStartPlot->getX(), pStartPlot->getY()) < m_iRequiredSeparation)

	mov	edx, DWORD PTR _pStartPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T226945[ebp], eax
	mov	ecx, DWORD PTR _pStartPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T226949[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T226953[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T226957[ebp], eax
	mov	ecx, DWORD PTR $T226945[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226949[ebp]
	push	edx
	mov	eax, DWORD PTR $T226953[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226957[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+60]
	jge	SHORT $LN3@TooCloseTo

; 742  : 					{
; 743  : 						return true;

	mov	al, 1
	jmp	SHORT $LN11@TooCloseTo
$LN3@TooCloseTo:

; 744  : 					}
; 745  : 				}
; 746  : 
; 747  : 				// If in another area, use a fraction of full distance
; 748  : 				else

	jmp	SHORT $LN6@TooCloseTo
$LN4@TooCloseTo:

; 749  : 				{
; 750  : 					int iSeparationIfOnAnotherContinent = m_iRequiredSeparation * GC.getMIN_DISTANCE_OTHER_AREA_PERCENT() / 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7144
	mov	DWORD PTR $T227010[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	imul	eax, DWORD PTR $T227010[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iSeparationIfOnAnotherContinent$220064[ebp], eax

; 751  : 					if(plotDistance(pPlot->getX(), pPlot->getY(),
; 752  : 					                pStartPlot->getX(), pStartPlot->getY()) < iSeparationIfOnAnotherContinent)

	mov	edx, DWORD PTR _pStartPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T227014[ebp], eax
	mov	ecx, DWORD PTR _pStartPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T227018[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T227022[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T227026[ebp], eax
	mov	ecx, DWORD PTR $T227014[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227018[ebp]
	push	edx
	mov	eax, DWORD PTR $T227022[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227026[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iSeparationIfOnAnotherContinent$220064[ebp]
	jge	SHORT $LN6@TooCloseTo

; 753  : 					{
; 754  : 						return true;

	mov	al, 1
	jmp	SHORT $LN11@TooCloseTo
$LN6@TooCloseTo:

; 755  : 					}
; 756  : 				}
; 757  : 			}
; 758  : 		}
; 759  : 	}

	jmp	$LN8@TooCloseTo
$LN7@TooCloseTo:

; 760  : 
; 761  : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[ebp]
$LN11@TooCloseTo:

; 762  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TooCloseToAnotherCiv@CvStartPositioner@@AAE_NPAVCvPlot@@@Z ENDP ; CvStartPositioner::TooCloseToAnotherCiv
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T227195 = -80						; size = 4
$T227168 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T227168[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T227168[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T227168[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T227195[ebp], edx
	mov	eax, DWORD PTR $T227195[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T227218 = -16						; size = 4
$T227210 = -12						; size = 4
$T227206 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T227206[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227210[ebp], ecx
	movzx	edx, BYTE PTR $T227206[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T227210[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T227210[ebp]
	mov	DWORD PTR $T227218[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T227210[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T227210[ebp]
	mov	DWORD PTR $T227218[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T227218[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T227218[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T227239 = -16						; size = 4
$T227231 = -12						; size = 4
$T227227 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T227227[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T227231[ebp], ecx
	movzx	edx, BYTE PTR $T227227[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T227231[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T227231[ebp]
	mov	DWORD PTR $T227239[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T227231[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T227231[ebp]
	mov	DWORD PTR $T227239[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T227239[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T227239[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
EXTRN	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::calculateNatureYield
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T227249 = -20						; size = 4
$T227245 = -16						; size = 4
_iI$220075 = -12					; size = 4
_bFoundFoodPlot$ = -5					; size = 1
_pLoopPlot$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_eTeam$ = 12						; size = 4
_iFoodRequirement$ = 16					; size = 4
?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z PROC ; CvStartPositioner::MeetsFoodRequirement, COMDAT
; _this$ = ecx

; 766  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 767  : 	CvPlot* pLoopPlot(NULL);

	mov	DWORD PTR _pLoopPlot$[ebp], 0

; 768  : 	bool bFoundFoodPlot = false;

	mov	BYTE PTR _bFoundFoodPlot$[ebp], 0

; 769  : 
; 770  : 	CvAssert(pPlot);
; 771  : 	if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN7@MeetsFoodR

; 772  : 		return bFoundFoodPlot;

	mov	al, BYTE PTR _bFoundFoodPlot$[ebp]
	jmp	SHORT $LN8@MeetsFoodR
$LN7@MeetsFoodR:

; 773  : 
; 774  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$220075[ebp], 0
	jmp	SHORT $LN6@MeetsFoodR
$LN5@MeetsFoodR:
	mov	eax, DWORD PTR _iI$220075[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220075[ebp], eax
$LN6@MeetsFoodR:
	cmp	DWORD PTR _iI$220075[ebp], 6
	jge	SHORT $LN4@MeetsFoodR

; 775  : 	{
; 776  : 		pLoopPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T227245[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T227249[ebp], ecx
	mov	edx, DWORD PTR _iI$220075[ebp]
	push	edx
	mov	eax, DWORD PTR $T227245[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227249[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 777  : 		if(pLoopPlot == NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	jne	SHORT $LN3@MeetsFoodR

; 778  : 		{
; 779  : 			return false;   // Right at map edge

	xor	al, al
	jmp	SHORT $LN8@MeetsFoodR

; 780  : 		}
; 781  : 		else

	jmp	SHORT $LN2@MeetsFoodR
$LN3@MeetsFoodR:

; 782  : 		{
; 783  : 			if(pLoopPlot->calculateNatureYield(YIELD_FOOD, eTeam, false) >= iFoodRequirement)

	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	cmp	eax, DWORD PTR _iFoodRequirement$[ebp]
	jl	SHORT $LN2@MeetsFoodR

; 784  : 			{
; 785  : 				bFoundFoodPlot = true;

	mov	BYTE PTR _bFoundFoodPlot$[ebp], 1

; 786  : 				break;

	jmp	SHORT $LN4@MeetsFoodR
$LN2@MeetsFoodR:

; 787  : 			}
; 788  : 		}
; 789  : 	}

	jmp	SHORT $LN5@MeetsFoodR
$LN4@MeetsFoodR:

; 790  : 	return bFoundFoodPlot;

	mov	al, BYTE PTR _bFoundFoodPlot$[ebp]
$LN8@MeetsFoodR:

; 791  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MeetsFoodRequirement@CvStartPositioner@@AAE_NPAVCvPlot@@W4TeamTypes@@H@Z ENDP ; CvStartPositioner::MeetsFoodRequirement
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T227676 = -80						; size = 4
$T227631 = -76						; size = 4
$T227618 = -72						; size = 4
$T227614 = -68						; size = 4
$T227600 = -64						; size = 4
$T227596 = -57						; size = 1
$T227585 = -56						; size = 4
$T227581 = -49						; size = 1
_iMapY$227675 = -48					; size = 4
_iMapX$227674 = -44					; size = 4
$T227574 = -40						; size = 4
$T227550 = -36						; size = 4
$T227513 = -32						; size = 4
$T227501 = -28						; size = 4
$T227497 = -21						; size = 1
$T227486 = -20						; size = 4
$T227482 = -13						; size = 1
_iMapY$227549 = -12					; size = 4
_iMapX$227548 = -8					; size = 4
$T227475 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227475[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T227550[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T227475[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T227482[ebp], dl
	mov	eax, DWORD PTR $T227475[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227486[ebp], ecx
	movzx	edx, BYTE PTR $T227482[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T227486[ebp]
	add	edx, DWORD PTR $T227486[ebp]
	mov	DWORD PTR _iMapX$227548[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T227486[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T227486[ebp]
	mov	DWORD PTR _iMapX$227548[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$227548[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T227475[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T227497[ebp], al
	mov	ecx, DWORD PTR $T227475[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T227501[ebp], edx
	movzx	eax, BYTE PTR $T227497[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T227501[ebp]
	add	edx, DWORD PTR $T227501[ebp]
	mov	DWORD PTR _iMapY$227549[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T227501[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T227501[ebp]
	mov	DWORD PTR _iMapY$227549[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$227549[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$227549[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$227548[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227475[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T227475[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T227513[ebp], eax
	mov	ecx, DWORD PTR _iMapY$227549[ebp]
	imul	ecx, DWORD PTR $T227513[ebp]
	add	ecx, DWORD PTR _iMapX$227548[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T227475[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T227550[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T227550[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227574[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T227676[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T227574[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T227581[ebp], dl
	mov	eax, DWORD PTR $T227574[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227585[ebp], ecx
	movzx	edx, BYTE PTR $T227581[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T227585[ebp]
	add	edx, DWORD PTR $T227585[ebp]
	mov	DWORD PTR _iMapX$227674[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T227585[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T227585[ebp]
	mov	DWORD PTR _iMapX$227674[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$227674[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T227574[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T227596[ebp], al
	mov	ecx, DWORD PTR $T227574[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T227600[ebp], edx
	movzx	eax, BYTE PTR $T227596[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T227600[ebp]
	add	edx, DWORD PTR $T227600[ebp]
	mov	DWORD PTR _iMapY$227675[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T227600[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T227600[ebp]
	mov	DWORD PTR _iMapY$227675[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$227675[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$227674[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T227574[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227614[ebp], ecx
	mov	edx, DWORD PTR _iMapX$227674[ebp]
	cmp	edx, DWORD PTR $T227614[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$227675[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T227574[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T227618[ebp], ecx
	mov	edx, DWORD PTR _iMapY$227675[ebp]
	cmp	edx, DWORD PTR $T227618[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T227574[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T227631[ebp], ecx
	mov	edx, DWORD PTR _iMapY$227675[ebp]
	imul	edx, DWORD PTR $T227631[ebp]
	add	edx, DWORD PTR _iMapX$227674[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T227574[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T227676[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T227676[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
EXTRN	?getLandPlots@CvMap@@QAEHXZ:PROC		; CvMap::getLandPlots
EXTRN	?getTargetNumCities@CvWorldInfo@@QBEHXZ:PROC	; CvWorldInfo::getTargetNumCities
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?countCivPlayersAlive@CvGame@@QBEHXZ:PROC	; CvGame::countCivPlayersAlive
EXTRN	?countMajorCivsAlive@CvGame@@QBEHXZ:PROC	; CvGame::countMajorCivsAlive
EXTRN	?maxPlotDistance@CvMap@@QAEHXZ:PROC		; CvMap::maxPlotDistance
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
;	COMDAT ?StartingPlotRange@CvStartPositioner@@ABEHXZ
_TEXT	SEGMENT
tv92 = -72						; size = 4
tv138 = -68						; size = 4
_this$ = -64						; size = 4
$T227723 = -60						; size = 4
$T227717 = -56						; size = 4
$T227713 = -52						; size = 4
$T227706 = -48						; size = 4
$T227700 = -44						; size = 4
$T227696 = -40						; size = 4
$T227692 = -36						; size = 4
$T227688 = -32						; size = 4
$T227684 = -28						; size = 4
$T227680 = -24						; size = 4
$T227679 = -20						; size = 4
_iExpectedCities$ = -16					; size = 4
_iRange$ = -12						; size = 4
_iNumMinors$ = -8					; size = 4
_iNumMajors$ = -4					; size = 4
?StartingPlotRange@CvStartPositioner@@ABEHXZ PROC	; CvStartPositioner::StartingPlotRange, COMDAT
; _this$ = ecx

; 795  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 796  : 	int iRange;
; 797  : 	int iNumMinors, iNumMajors;
; 798  : 	int iExpectedCities;
; 799  : 
; 800  : 	// Start with the range as a percentage of the maximum path length across the map
; 801  : 	iRange = (GC.getMap().maxPlotDistance() + 10);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227684[ebp], eax
	mov	ecx, DWORD PTR $T227684[ebp]
	call	?maxPlotDistance@CvMap@@QAEHXZ		; CvMap::maxPlotDistance
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _iRange$[ebp], eax

; 802  : 	iRange *= GC.getSTARTING_DISTANCE_PERCENT();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6240
	mov	DWORD PTR $T227688[ebp], ecx
	mov	edx, DWORD PTR _iRange$[ebp]
	imul	edx, DWORD PTR $T227688[ebp]
	mov	DWORD PTR _iRange$[ebp], edx

; 803  : 	iRange /= 100;

	mov	eax, DWORD PTR _iRange$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iRange$[ebp], eax

; 804  : 
; 805  : 	// Now compute how many cities we expect on the map (we'll say just 1 for each minor civ)
; 806  : 	iNumMajors = GC.getGame().countMajorCivsAlive();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227692[ebp], edx
	mov	ecx, DWORD PTR $T227692[ebp]
	call	?countMajorCivsAlive@CvGame@@QBEHXZ	; CvGame::countMajorCivsAlive
	mov	DWORD PTR _iNumMajors$[ebp], eax

; 807  : 	iNumMinors = GC.getGame().countCivPlayersAlive() - iNumMajors;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T227696[ebp], eax
	mov	ecx, DWORD PTR $T227696[ebp]
	call	?countCivPlayersAlive@CvGame@@QBEHXZ	; CvGame::countCivPlayersAlive
	sub	eax, DWORD PTR _iNumMajors$[ebp]
	mov	DWORD PTR _iNumMinors$[ebp], eax

; 808  : 	iExpectedCities = GC.getMap().getWorldInfo().getTargetNumCities() * iNumMajors;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227700[ebp], ecx
	mov	ecx, DWORD PTR $T227700[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getTargetNumCities@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getTargetNumCities
	imul	eax, DWORD PTR _iNumMajors$[ebp]
	mov	DWORD PTR _iExpectedCities$[ebp], eax

; 809  : 	iExpectedCities += iNumMinors;

	mov	edx, DWORD PTR _iExpectedCities$[ebp]
	add	edx, DWORD PTR _iNumMinors$[ebp]
	mov	DWORD PTR _iExpectedCities$[ebp], edx

; 810  : 	iExpectedCities = std::max(1,iExpectedCities);

	mov	DWORD PTR $T227679[ebp], 1
	mov	eax, DWORD PTR $T227679[ebp]
	cmp	eax, DWORD PTR _iExpectedCities$[ebp]
	jge	SHORT $LN15@StartingPl
	lea	ecx, DWORD PTR _iExpectedCities$[ebp]
	mov	DWORD PTR tv138[ebp], ecx
	jmp	SHORT $LN16@StartingPl
$LN15@StartingPl:
	lea	edx, DWORD PTR $T227679[ebp]
	mov	DWORD PTR tv138[ebp], edx
$LN16@StartingPl:
	mov	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR $T227706[ebp], eax
	mov	ecx, DWORD PTR $T227706[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iExpectedCities$[ebp], edx

; 811  : 
; 812  : 	// Adjust range compared to how many plots we have per city
; 813  : 	iRange *= GC.getMap().getLandPlots();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227713[ebp], eax
	mov	ecx, DWORD PTR $T227713[ebp]
	call	?getLandPlots@CvMap@@QAEHXZ		; CvMap::getLandPlots
	imul	eax, DWORD PTR _iRange$[ebp]
	mov	DWORD PTR _iRange$[ebp], eax

; 814  : 	iRange /= (NUM_CITY_PLOTS / 2); // NUM_CITY_PLOTS; -- I am assuming that some tiles will be watter or unused

	mov	eax, DWORD PTR _iRange$[ebp]
	cdq
	mov	ecx, 18					; 00000012H
	idiv	ecx
	mov	DWORD PTR _iRange$[ebp], eax

; 815  : 	iRange /= iExpectedCities;

	mov	eax, DWORD PTR _iRange$[ebp]
	cdq
	idiv	DWORD PTR _iExpectedCities$[ebp]
	mov	DWORD PTR _iRange$[ebp], eax

; 816  : 
; 817  : 	// Used to be a Python hook (minStartingDistanceModifier) here
; 818  : 
; 819  : 	return std::max(iRange, GC.getMIN_CIV_STARTING_DISTANCE());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6244
	mov	DWORD PTR $T227717[ebp], edx
	mov	eax, DWORD PTR $T227717[ebp]
	mov	DWORD PTR $T227680[ebp], eax
	mov	ecx, DWORD PTR _iRange$[ebp]
	cmp	ecx, DWORD PTR $T227680[ebp]
	jge	SHORT $LN23@StartingPl
	lea	edx, DWORD PTR $T227680[ebp]
	mov	DWORD PTR tv92[ebp], edx
	jmp	SHORT $LN24@StartingPl
$LN23@StartingPl:
	lea	eax, DWORD PTR _iRange$[ebp]
	mov	DWORD PTR tv92[ebp], eax
$LN24@StartingPl:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T227723[ebp], ecx
	mov	edx, DWORD PTR $T227723[ebp]
	mov	eax, DWORD PTR [edx]

; 820  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartingPlotRange@CvStartPositioner@@ABEHXZ ENDP	; CvStartPositioner::StartingPlotRange
_TEXT	ENDS
PUBLIC	??_C@_0BF@ILDDFBIK@StartPositionLog?4csv?$AA@	; `string'
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0BF@ILDDFBIK@StartPositionLog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BF@ILDDFBIK@StartPositionLog?4csv?$AA@ DB 'StartPositionLog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z$0
__ehfuncinfo$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.cpp
xdata$x	ENDS
;	COMDAT ?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
_TEXT	SEGMENT
tv75 = -32						; size = 4
_this$ = -28						; size = 4
$T227734 = -24						; size = 4
_pLog$220097 = -20					; size = 4
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 28
?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z PROC ; CvStartPositioner::LogStartPositionMessage, COMDAT
; _this$ = ecx

; 824  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 825  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@LogStartPo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@LogStartPo

; 826  : 	{
; 827  : 		FILogFile* pLog;
; 828  : 		pLog = LOGFILEMGR.GetLog("StartPositionLog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv75[ebp], eax
	push	0
	push	1
	push	OFFSET ??_C@_0BF@ILDDFBIK@StartPositionLog?4csv?$AA@
	mov	edx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$220097[ebp], eax

; 829  : 		pLog->Msg(strMsg);

	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T227734[ebp], eax
	mov	eax, DWORD PTR $T227734[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$220097[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$220097[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8
$LN1@LogStartPo:

; 830  : 	}
; 831  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMsg$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStartPositionMessage@CvStartPositioner@@AAEXVCvString@@@Z ENDP ; CvStartPositioner::LogStartPositionMessage
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::~vector<CvContinent,std::allocator<CvContinent> >
PUBLIC	?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::insert
PUBLIC	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T227882 = -32						; size = 4
$T227872 = -28						; size = 4
$T227862 = -24						; size = 4
__Cat$227869 = -19					; size = 1
$T227867 = -18						; size = 1
$T227866 = -17						; size = 1
$T227839 = -16						; size = 4
$T227835 = -12						; size = 4
$T227834 = -8						; size = 4
$T227833 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	mov	DWORD PTR $T227839[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T227839[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T227872[ebp], eax
	mov	ecx, DWORD PTR $T227872[ebp]
	mov	DWORD PTR $T227862[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T227866[ebp], dl
	mov	al, BYTE PTR __Cat$227869[ebp]
	mov	BYTE PTR $T227867[ebp], al
	movzx	ecx, BYTE PTR $T227866[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T227867[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T227862[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 4
	add	eax, DWORD PTR $T227872[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T227882[ebp], eax
	mov	ecx, DWORD PTR $T227882[ebp]
	mov	DWORD PTR $T227834[ebp], ecx
	mov	edx, DWORD PTR $T227834[ebp]
	mov	DWORD PTR $T227833[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227833[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227835[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAEXABVCvContinent@@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::~vector<CvStartRegion,std::allocator<CvStartRegion> >
PUBLIC	?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::insert
PUBLIC	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T228085 = -32						; size = 4
$T228075 = -28						; size = 4
$T228065 = -24						; size = 4
__Cat$228072 = -19					; size = 1
$T228070 = -18						; size = 1
$T228069 = -17						; size = 1
$T228042 = -16						; size = 4
$T228038 = -12						; size = 4
$T228037 = -8						; size = 4
$T228036 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	mov	DWORD PTR $T228042[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@2
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 5
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@2:
	mov	ecx, DWORD PTR $T228042[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T228075[ebp], eax
	mov	ecx, DWORD PTR $T228075[ebp]
	mov	DWORD PTR $T228065[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T228069[ebp], dl
	mov	al, BYTE PTR __Cat$228072[ebp]
	mov	BYTE PTR $T228070[ebp], al
	movzx	ecx, BYTE PTR $T228069[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T228070[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T228065[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 5
	add	eax, DWORD PTR $T228075[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T228085[ebp], eax
	mov	ecx, DWORD PTR $T228085[ebp]
	mov	DWORD PTR $T228037[ebp], ecx
	mov	edx, DWORD PTR $T228037[ebp]
	mov	DWORD PTR $T228036[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228036[ebp]
	push	ecx
	lea	edx, DWORD PTR $T228038[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::insert
$LN3@push_back@2:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAEXABVCvStartRegion@@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::push_back
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::insert
PUBLIC	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T228202 = -32						; size = 4
$T228192 = -28						; size = 4
$T228182 = -24						; size = 4
__Cat$228189 = -19					; size = 1
$T228187 = -18						; size = 1
$T228186 = -17						; size = 1
$T228159 = -16						; size = 4
$T228155 = -12						; size = 4
$T228154 = -8						; size = 4
$T228153 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR $T228159[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@3
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@3
$LN9@push_back@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@3:
	mov	ecx, DWORD PTR $T228159[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T228192[ebp], eax
	mov	ecx, DWORD PTR $T228192[ebp]
	mov	DWORD PTR $T228182[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T228186[ebp], dl
	mov	al, BYTE PTR __Cat$228189[ebp]
	mov	BYTE PTR $T228187[ebp], al
	movzx	ecx, BYTE PTR $T228186[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T228187[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T228182[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 3
	add	eax, DWORD PTR $T228192[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@3
$LN2@push_back@3:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T228202[ebp], eax
	mov	ecx, DWORD PTR $T228202[ebp]
	mov	DWORD PTR $T228154[ebp], ecx
	mov	edx, DWORD PTR $T228154[ebp]
	mov	DWORD PTR $T228153[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228153[ebp]
	push	ecx
	lea	edx, DWORD PTR $T228155[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::insert
$LN3@push_back@3:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAEXABVCvPlayerStartRank@@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::~_Vector_val<CvContinent,std::allocator<CvContinent> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvContinent,std::allocator<CvContinent> >::~_Vector_val<CvContinent,std::allocator<CvContinent> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::~_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >::~_Vector_val<CvStartRegion,std::allocator<CvStartRegion> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::~_Vector_val<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$228340 = -24					; size = 4
$T228323 = -20						; size = 4
$T228304 = -16						; size = 4
$T228291 = -12						; size = 4
$T228288 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228304[ebp], ecx
	mov	edx, DWORD PTR $T228304[ebp]
	mov	DWORD PTR $T228288[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T228288[ebp]
	sar	eax, 4
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228323[ebp], edx
	mov	eax, DWORD PTR $T228323[ebp]
	mov	DWORD PTR $T228291[ebp], eax
	mov	ecx, DWORD PTR $T228291[ebp]
	mov	DWORD PTR __Tmp$228340[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$228340[ebp]
	mov	DWORD PTR __Tmp$228340[ebp], edx
	mov	eax, DWORD PTR __Tmp$228340[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@ABVCvContinent@@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T228487 = -64						; size = 4
$T228469 = -60						; size = 4
$T228468 = -56						; size = 4
$T228452 = -52						; size = 4
__Cat$228475 = -46					; size = 1
$T228472 = -45						; size = 1
$T228426 = -44						; size = 4
$T228425 = -40						; size = 4
$T228424 = -36						; size = 4
$T228407 = -30						; size = 1
$T228406 = -29						; size = 1
$T228405 = -28						; size = 4
$T228404 = -24						; size = 4
__Cat$228414 = -16					; size = 1
$T228411 = -15						; size = 1
$T228410 = -14						; size = 1
$T228409 = -13						; size = 1
__Ptr$220239 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228426[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228425[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T228424[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T228409[ebp], cl
	mov	dl, BYTE PTR __Cat$228414[ebp]
	mov	BYTE PTR $T228410[ebp], dl
	mov	al, BYTE PTR $T228409[ebp]
	mov	BYTE PTR $T228407[ebp], al
	mov	cl, BYTE PTR $T228411[ebp]
	mov	BYTE PTR $T228406[ebp], cl
	mov	edx, DWORD PTR $T228426[ebp]
	mov	DWORD PTR $T228405[ebp], edx
	mov	eax, DWORD PTR $T228424[ebp]
	mov	DWORD PTR $T228404[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T228405[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T228405[ebp], ecx
	mov	edx, DWORD PTR $T228404[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T228404[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T228404[ebp]
	cmp	eax, DWORD PTR $T228425[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T228404[ebp]
	mov	edx, DWORD PTR $T228405[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	edx, DWORD PTR $T228405[ebp]
	mov	DWORD PTR __Ptr$220239[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T228487[ebp], ecx
	mov	edx, DWORD PTR $T228487[ebp]
	mov	DWORD PTR $T228469[ebp], edx
	mov	eax, DWORD PTR __Ptr$220239[ebp]
	mov	DWORD PTR $T228468[ebp], eax
	mov	cl, BYTE PTR __Cat$228475[ebp]
	mov	BYTE PTR $T228472[ebp], cl
	mov	edx, DWORD PTR $T228468[ebp]
	mov	DWORD PTR $T228452[ebp], edx
	jmp	SHORT $LN39@erase
$LN38@erase:
	mov	eax, DWORD PTR $T228452[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T228452[ebp], eax
$LN39@erase:
	mov	ecx, DWORD PTR $T228452[ebp]
	cmp	ecx, DWORD PTR $T228469[ebp]
	je	SHORT $LN31@erase
	jmp	SHORT $LN38@erase
$LN31@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$220239[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@V?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@0@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ; std::_Allocate<CvContinent>
PUBLIC	?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$228504 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$228504[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$228504[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$228504[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ; std::_Allocate<CvContinent>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Buy
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T228599 = -32						; size = 4
$T228598 = -28						; size = 4
$T228594 = -24						; size = 4
$T228593 = -20						; size = 4
$T228575 = -16						; size = 4
$T228574 = -12						; size = 4
$T228558 = -8						; size = 4
__Cat$228581 = -2					; size = 1
$T228578 = -1						; size = 1
?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228594[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228593[ebp], ecx
	mov	edx, DWORD PTR $T228594[ebp]
	mov	DWORD PTR $T228575[ebp], edx
	mov	eax, DWORD PTR $T228593[ebp]
	mov	DWORD PTR $T228574[ebp], eax
	mov	cl, BYTE PTR __Cat$228581[ebp]
	mov	BYTE PTR $T228578[ebp], cl
	mov	edx, DWORD PTR $T228574[ebp]
	mov	DWORD PTR $T228558[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T228558[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T228558[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T228558[ebp]
	cmp	ecx, DWORD PTR $T228575[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	DWORD PTR $T228599[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T228598[ebp], eax
	mov	ecx, DWORD PTR $T228598[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$228659 = -24					; size = 4
$T228637 = -20						; size = 4
$T228618 = -16						; size = 4
$T228605 = -12						; size = 4
$T228602 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	test	edx, edx
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228618[ebp], ecx
	mov	edx, DWORD PTR $T228618[ebp]
	mov	DWORD PTR $T228602[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T228602[ebp]
	sar	eax, 5
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228637[ebp], edx
	mov	eax, DWORD PTR $T228637[ebp]
	mov	DWORD PTR $T228605[ebp], eax
	mov	ecx, DWORD PTR $T228605[ebp]
	mov	DWORD PTR __Tmp$228659[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$228659[ebp]
	mov	DWORD PTR __Tmp$228659[ebp], edx
	mov	eax, DWORD PTR __Tmp$228659[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@ABVCvStartRegion@@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T228801 = -64						; size = 4
$T228783 = -60						; size = 4
$T228782 = -56						; size = 4
$T228766 = -52						; size = 4
__Cat$228791 = -46					; size = 1
$T228788 = -45						; size = 1
$T228740 = -44						; size = 4
$T228739 = -40						; size = 4
$T228738 = -36						; size = 4
$T228721 = -30						; size = 1
$T228720 = -29						; size = 1
$T228719 = -28						; size = 4
$T228718 = -24						; size = 4
__Cat$228728 = -16					; size = 1
$T228725 = -15						; size = 1
$T228724 = -14						; size = 1
$T228723 = -13						; size = 1
__Ptr$220294 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228740[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228739[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T228738[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T228723[ebp], cl
	mov	dl, BYTE PTR __Cat$228728[ebp]
	mov	BYTE PTR $T228724[ebp], dl
	mov	al, BYTE PTR $T228723[ebp]
	mov	BYTE PTR $T228721[ebp], al
	mov	cl, BYTE PTR $T228725[ebp]
	mov	BYTE PTR $T228720[ebp], cl
	mov	edx, DWORD PTR $T228740[ebp]
	mov	DWORD PTR $T228719[ebp], edx
	mov	eax, DWORD PTR $T228738[ebp]
	mov	DWORD PTR $T228718[ebp], eax
	jmp	SHORT $LN28@erase@2
$LN27@erase@2:
	mov	ecx, DWORD PTR $T228719[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T228719[ebp], ecx
	mov	edx, DWORD PTR $T228718[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T228718[ebp], edx
$LN28@erase@2:
	mov	eax, DWORD PTR $T228718[ebp]
	cmp	eax, DWORD PTR $T228739[ebp]
	je	SHORT $LN20@erase@2
	mov	esi, DWORD PTR $T228718[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T228719[ebp]
	rep movsd
	jmp	SHORT $LN27@erase@2
$LN20@erase@2:
	mov	ecx, DWORD PTR $T228719[ebp]
	mov	DWORD PTR __Ptr$220294[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T228801[ebp], eax
	mov	ecx, DWORD PTR $T228801[ebp]
	mov	DWORD PTR $T228783[ebp], ecx
	mov	edx, DWORD PTR __Ptr$220294[ebp]
	mov	DWORD PTR $T228782[ebp], edx
	mov	al, BYTE PTR __Cat$228791[ebp]
	mov	BYTE PTR $T228788[ebp], al
	mov	ecx, DWORD PTR $T228782[ebp]
	mov	DWORD PTR $T228766[ebp], ecx
	jmp	SHORT $LN39@erase@2
$LN38@erase@2:
	mov	edx, DWORD PTR $T228766[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T228766[ebp], edx
$LN39@erase@2:
	mov	eax, DWORD PTR $T228766[ebp]
	cmp	eax, DWORD PTR $T228783[ebp]
	je	SHORT $LN31@erase@2
	jmp	SHORT $LN38@erase@2
$LN31@erase@2:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$220294[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@V?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@0@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ; std::_Allocate<CvStartRegion>
PUBLIC	?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$228819 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$228819[ebp], 134217727 ; 07ffffffH
	cmp	DWORD PTR __Count$228819[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$228819[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ; std::_Allocate<CvStartRegion>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T228912 = -32						; size = 4
$T228911 = -28						; size = 4
$T228907 = -24						; size = 4
$T228906 = -20						; size = 4
$T228888 = -16						; size = 4
$T228887 = -12						; size = 4
$T228871 = -8						; size = 4
__Cat$228895 = -2					; size = 1
$T228893 = -1						; size = 1
?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228907[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228906[ebp], ecx
	mov	edx, DWORD PTR $T228907[ebp]
	mov	DWORD PTR $T228888[ebp], edx
	mov	eax, DWORD PTR $T228906[ebp]
	mov	DWORD PTR $T228887[ebp], eax
	mov	cl, BYTE PTR __Cat$228895[ebp]
	mov	BYTE PTR $T228893[ebp], cl
	mov	edx, DWORD PTR $T228887[ebp]
	mov	DWORD PTR $T228871[ebp], edx
	jmp	SHORT $LN12@Tidy@2
$LN11@Tidy@2:
	mov	eax, DWORD PTR $T228871[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T228871[ebp], eax
$LN12@Tidy@2:
	mov	ecx, DWORD PTR $T228871[ebp]
	cmp	ecx, DWORD PTR $T228888[ebp]
	je	SHORT $LN4@Tidy@2
	jmp	SHORT $LN11@Tidy@2
$LN4@Tidy@2:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 5
	mov	DWORD PTR $T228912[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T228911[ebp], eax
	mov	ecx, DWORD PTR $T228911[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$228967 = -24					; size = 4
$T228950 = -20						; size = 4
$T228931 = -16						; size = 4
$T228918 = -12						; size = 4
$T228915 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	test	edx, edx
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228931[ebp], ecx
	mov	edx, DWORD PTR $T228931[ebp]
	mov	DWORD PTR $T228915[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T228915[ebp]
	sar	eax, 3
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228950[ebp], edx
	mov	eax, DWORD PTR $T228950[ebp]
	mov	DWORD PTR $T228918[ebp], eax
	mov	ecx, DWORD PTR $T228918[ebp]
	mov	DWORD PTR __Tmp$228967[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$228967[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$228967[ebp], ecx
	mov	edx, DWORD PTR __Tmp$228967[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@ABVCvPlayerStartRank@@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T229114 = -64						; size = 4
$T229096 = -60						; size = 4
$T229095 = -56						; size = 4
$T229079 = -52						; size = 4
__Cat$229103 = -46					; size = 1
$T229101 = -45						; size = 1
$T229053 = -44						; size = 4
$T229052 = -40						; size = 4
$T229051 = -36						; size = 4
$T229034 = -30						; size = 1
$T229033 = -29						; size = 1
$T229032 = -28						; size = 4
$T229031 = -24						; size = 4
__Cat$229040 = -16					; size = 1
$T229038 = -15						; size = 1
$T229037 = -14						; size = 1
$T229036 = -13						; size = 1
__Ptr$220349 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229053[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T229052[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T229051[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229036[ebp], cl
	mov	dl, BYTE PTR __Cat$229040[ebp]
	mov	BYTE PTR $T229037[ebp], dl
	mov	al, BYTE PTR $T229036[ebp]
	mov	BYTE PTR $T229034[ebp], al
	mov	cl, BYTE PTR $T229038[ebp]
	mov	BYTE PTR $T229033[ebp], cl
	mov	edx, DWORD PTR $T229053[ebp]
	mov	DWORD PTR $T229032[ebp], edx
	mov	eax, DWORD PTR $T229051[ebp]
	mov	DWORD PTR $T229031[ebp], eax
	jmp	SHORT $LN28@erase@3
$LN27@erase@3:
	mov	ecx, DWORD PTR $T229032[ebp]
	add	ecx, 8
	mov	DWORD PTR $T229032[ebp], ecx
	mov	edx, DWORD PTR $T229031[ebp]
	add	edx, 8
	mov	DWORD PTR $T229031[ebp], edx
$LN28@erase@3:
	mov	eax, DWORD PTR $T229031[ebp]
	cmp	eax, DWORD PTR $T229052[ebp]
	je	SHORT $LN20@erase@3
	mov	ecx, DWORD PTR $T229031[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T229032[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN27@erase@3
$LN20@erase@3:
	mov	edx, DWORD PTR $T229032[ebp]
	mov	DWORD PTR __Ptr$220349[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T229114[ebp], ecx
	mov	edx, DWORD PTR $T229114[ebp]
	mov	DWORD PTR $T229096[ebp], edx
	mov	eax, DWORD PTR __Ptr$220349[ebp]
	mov	DWORD PTR $T229095[ebp], eax
	mov	cl, BYTE PTR __Cat$229103[ebp]
	mov	BYTE PTR $T229101[ebp], cl
	mov	edx, DWORD PTR $T229095[ebp]
	mov	DWORD PTR $T229079[ebp], edx
	jmp	SHORT $LN39@erase@3
$LN38@erase@3:
	mov	eax, DWORD PTR $T229079[ebp]
	add	eax, 8
	mov	DWORD PTR $T229079[ebp], eax
$LN39@erase@3:
	mov	ecx, DWORD PTR $T229079[ebp]
	cmp	ecx, DWORD PTR $T229096[ebp]
	je	SHORT $LN31@erase@3
	jmp	SHORT $LN38@erase@3
$LN31@erase@3:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$220349[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@V?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@0@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ; std::_Allocate<CvPlayerStartRank>
PUBLIC	?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$229129 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$229129[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$229129[ebp], 0
	jbe	SHORT $LN11@Buy@3
	mov	eax, DWORD PTR __Count$229129[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@3
$LN11@Buy@3:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@3:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ; std::_Allocate<CvPlayerStartRank>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T229225 = -32						; size = 4
$T229224 = -28						; size = 4
$T229220 = -24						; size = 4
$T229219 = -20						; size = 4
$T229201 = -16						; size = 4
$T229200 = -12						; size = 4
$T229184 = -8						; size = 4
__Cat$229208 = -2					; size = 1
$T229206 = -1						; size = 1
?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T229220[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229219[ebp], ecx
	mov	edx, DWORD PTR $T229220[ebp]
	mov	DWORD PTR $T229201[ebp], edx
	mov	eax, DWORD PTR $T229219[ebp]
	mov	DWORD PTR $T229200[ebp], eax
	mov	cl, BYTE PTR __Cat$229208[ebp]
	mov	BYTE PTR $T229206[ebp], cl
	mov	edx, DWORD PTR $T229200[ebp]
	mov	DWORD PTR $T229184[ebp], edx
	jmp	SHORT $LN12@Tidy@3
$LN11@Tidy@3:
	mov	eax, DWORD PTR $T229184[ebp]
	add	eax, 8
	mov	DWORD PTR $T229184[ebp], eax
$LN12@Tidy@3:
	mov	ecx, DWORD PTR $T229184[ebp]
	cmp	ecx, DWORD PTR $T229201[ebp]
	je	SHORT $LN4@Tidy@3
	jmp	SHORT $LN11@Tidy@3
$LN4@Tidy@3:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	mov	DWORD PTR $T229225[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229224[ebp], eax
	mov	ecx, DWORD PTR $T229224[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
PUBLIC	??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
_TEXT	SEGMENT
tv84 = -436						; size = 4
tv306 = -432						; size = 4
tv292 = -428						; size = 4
tv284 = -424						; size = 4
_this$ = -420						; size = 4
$T229913 = -416						; size = 4
$T229905 = -412						; size = 4
$T229904 = -408						; size = 4
$T229881 = -402						; size = 1
$T229880 = -401						; size = 1
$T229879 = -400						; size = 4
$T229878 = -396						; size = 4
$T229866 = -389						; size = 1
$T229865 = -388						; size = 4
$T229864 = -384						; size = 4
$T229863 = -380						; size = 4
__Cat$229896 = -376					; size = 1
$T229894 = -375						; size = 1
$T229893 = -374						; size = 1
__Cat$229888 = -372					; size = 1
$T229885 = -371						; size = 1
$T229884 = -370						; size = 1
$T229883 = -369						; size = 1
$T229838 = -368						; size = 4
$T229819 = -364						; size = 4
$T229802 = -357						; size = 1
$T229801 = -356						; size = 4
$T229791 = -352						; size = 4
$T229790 = -348						; size = 4
__Cat$229834 = -342					; size = 1
$T229831 = -341						; size = 1
$T229830 = -340						; size = 1
__Cat$229826 = -339					; size = 1
$T229823 = -338						; size = 1
$T229822 = -337						; size = 1
$T229763 = -336						; size = 4
$T229755 = -332						; size = 4
$T229747 = -328						; size = 4
$T229729 = -324						; size = 4
$T229728 = -320						; size = 4
$T229712 = -316						; size = 4
__Cat$229736 = -310					; size = 1
$T229733 = -309						; size = 1
$T229686 = -308						; size = 4
$T229685 = -304						; size = 4
$T229675 = -300						; size = 4
__Cat$229683 = -295					; size = 1
$T229680 = -294						; size = 1
$T229679 = -293						; size = 1
$T229659 = -292						; size = 4
$T229640 = -288						; size = 4
$T229623 = -281						; size = 1
$T229622 = -280						; size = 4
$T229612 = -276						; size = 4
$T229611 = -272						; size = 4
__Cat$229655 = -266					; size = 1
$T229652 = -265						; size = 1
$T229651 = -264						; size = 1
__Cat$229647 = -263					; size = 1
$T229644 = -262						; size = 1
$T229643 = -261						; size = 1
$T229584 = -260						; size = 4
$T229583 = -256						; size = 4
$T229579 = -252						; size = 4
$T229578 = -248						; size = 4
$T229560 = -244						; size = 4
$T229559 = -240						; size = 4
$T229543 = -236						; size = 4
__Cat$229566 = -230					; size = 1
$T229563 = -229						; size = 1
$T229494 = -228						; size = 4
$T229493 = -224						; size = 4
$T229477 = -220						; size = 4
__Cat$229500 = -214					; size = 1
$T229497 = -213						; size = 1
$T229434 = -212						; size = 4
$T229433 = -208						; size = 4
$T229417 = -204						; size = 4
__Cat$229440 = -198					; size = 1
$T229437 = -197						; size = 1
$T229391 = -196						; size = 4
$T229379 = -192						; size = 4
$T229369 = -185						; size = 1
$T229368 = -184						; size = 4
__Cat$229390 = -179					; size = 1
$T229388 = -178						; size = 1
$T229387 = -177						; size = 1
$T229356 = -176						; size = 4
$T229344 = -172						; size = 4
$T229334 = -165						; size = 1
$T229333 = -164						; size = 4
__Cat$229352 = -159					; size = 1
$T229350 = -158						; size = 1
$T229349 = -157						; size = 1
$T229321 = -156						; size = 4
$T229311 = -152						; size = 4
__Cat$229319 = -147					; size = 1
$T229317 = -146						; size = 1
$T229316 = -145						; size = 1
__Count$229283 = -144					; size = 4
__Count$229257 = -72					; size = 4
__Tmp$220442 = -68					; size = 16
__Oldend$220443 = -52					; size = 4
__Tmp$220432 = -48					; size = 16
__Ncopied$220419 = -32					; size = 4
__Newvec$220417 = -28					; size = 4
__Whereoff$220418 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 420				; 000001a4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv284[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	mov	DWORD PTR tv284[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$229257[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$229257[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$229257[ebp]
	mov	DWORD PTR tv292[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv292[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	mov	eax, DWORD PTR tv292[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$229283[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$229283[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$229283[ebp]
	mov	DWORD PTR tv306[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv306[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv306[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ; std::_Allocate<CvContinent>
	add	esp, 8
	mov	DWORD PTR __Newvec$220417[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	mov	DWORD PTR __Whereoff$220418[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$220419[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$220418[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$220417[ebp]
	mov	DWORD PTR $T229321[ebp], eax
	mov	ecx, DWORD PTR $T229321[ebp]
	mov	DWORD PTR $T229311[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T229316[ebp], dl
	mov	al, BYTE PTR __Cat$229319[ebp]
	mov	BYTE PTR $T229317[ebp], al
	movzx	ecx, BYTE PTR $T229316[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229317[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR $T229311[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$220419[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$220419[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229356[ebp], eax
	mov	ecx, DWORD PTR __Newvec$220417[ebp]
	mov	DWORD PTR $T229344[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T229349[ebp], dl
	mov	al, BYTE PTR __Cat$229352[ebp]
	mov	BYTE PTR $T229350[ebp], al
	mov	cl, BYTE PTR $T229349[ebp]
	mov	BYTE PTR $T229334[ebp], cl
	mov	edx, DWORD PTR $T229344[ebp]
	mov	DWORD PTR $T229333[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229333[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR $T229356[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$220419[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$220419[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T229391[ebp], eax
	mov	ecx, DWORD PTR __Whereoff$220418[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$220417[ebp]
	mov	DWORD PTR $T229379[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T229387[ebp], dl
	mov	al, BYTE PTR __Cat$229390[ebp]
	mov	BYTE PTR $T229388[ebp], al
	mov	cl, BYTE PTR $T229387[ebp]
	mov	BYTE PTR $T229369[ebp], cl
	mov	edx, DWORD PTR $T229379[ebp]
	mov	DWORD PTR $T229368[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229368[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229391[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$220419[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$220418[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$220417[ebp]
	mov	DWORD PTR $T229434[ebp], ecx
	mov	edx, DWORD PTR __Newvec$220417[ebp]
	mov	DWORD PTR $T229433[ebp], edx
	mov	al, BYTE PTR __Cat$229440[ebp]
	mov	BYTE PTR $T229437[ebp], al
	mov	ecx, DWORD PTR $T229433[ebp]
	mov	DWORD PTR $T229417[ebp], ecx
	jmp	SHORT $LN86@Insert_n
$LN85@Insert_n:
	mov	edx, DWORD PTR $T229417[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T229417[ebp], edx
$LN86@Insert_n:
	mov	eax, DWORD PTR $T229417[ebp]
	cmp	eax, DWORD PTR $T229434[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN85@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$220419[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR __Whereoff$220418[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Newvec$220417[ebp]
	add	edx, ecx
	mov	DWORD PTR $T229494[ebp], edx
	mov	eax, DWORD PTR __Whereoff$220418[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$220417[ebp]
	mov	DWORD PTR $T229493[ebp], eax
	mov	cl, BYTE PTR __Cat$229500[ebp]
	mov	BYTE PTR $T229497[ebp], cl
	mov	edx, DWORD PTR $T229493[ebp]
	mov	DWORD PTR $T229477[ebp], edx
	jmp	SHORT $LN101@Insert_n
$LN100@Insert_n:
	mov	eax, DWORD PTR $T229477[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T229477[ebp], eax
$LN101@Insert_n:
	mov	ecx, DWORD PTR $T229477[ebp]
	cmp	ecx, DWORD PTR $T229494[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN100@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$220417[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN110@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN110@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], edx

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T229579[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229578[ebp], ecx
	mov	edx, DWORD PTR $T229579[ebp]
	mov	DWORD PTR $T229560[ebp], edx
	mov	eax, DWORD PTR $T229578[ebp]
	mov	DWORD PTR $T229559[ebp], eax
	mov	cl, BYTE PTR __Cat$229566[ebp]
	mov	BYTE PTR $T229563[ebp], cl
	mov	edx, DWORD PTR $T229559[ebp]
	mov	DWORD PTR $T229543[ebp], edx
	jmp	SHORT $LN120@Insert_n
$LN119@Insert_n:
	mov	eax, DWORD PTR $T229543[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T229543[ebp], eax
$LN120@Insert_n:
	mov	ecx, DWORD PTR $T229543[ebp]
	cmp	ecx, DWORD PTR $T229560[ebp]
	je	SHORT $LN112@Insert_n
	jmp	SHORT $LN119@Insert_n
$LN112@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	DWORD PTR $T229584[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T229583[ebp], eax
	mov	ecx, DWORD PTR $T229583[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Newvec$220417[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$220417[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$220417[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 4
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$220432[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$220432[ebp+8], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$220432[ebp+4], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$220432[ebp+12], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T229659[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T229640[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229643[ebp], al
	mov	cl, BYTE PTR __Cat$229647[ebp]
	mov	BYTE PTR $T229644[ebp], cl
	mov	dl, BYTE PTR $T229643[ebp]
	mov	BYTE PTR $T229623[ebp], dl
	mov	eax, DWORD PTR $T229640[ebp]
	mov	DWORD PTR $T229622[ebp], eax
	mov	ecx, DWORD PTR $T229622[ebp]
	mov	DWORD PTR $T229612[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T229611[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229651[ebp], al
	mov	cl, BYTE PTR __Cat$229655[ebp]
	mov	BYTE PTR $T229652[ebp], cl
	movzx	edx, BYTE PTR $T229651[ebp]
	push	edx
	movzx	eax, BYTE PTR $T229652[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229612[ebp]
	push	edx
	mov	eax, DWORD PTR $T229659[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229611[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 4
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T229686[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T229685[ebp], eax
	mov	ecx, DWORD PTR $T229685[ebp]
	mov	DWORD PTR $T229675[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T229679[ebp], dl
	mov	al, BYTE PTR __Cat$229683[ebp]
	mov	BYTE PTR $T229680[ebp], al
	movzx	ecx, BYTE PTR $T229679[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229680[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$220432[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229686[ebp]
	push	edx
	mov	eax, DWORD PTR $T229675[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T229747[ebp], ecx
	mov	eax, DWORD PTR $T229747[ebp]
	mov	DWORD PTR $T229729[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T229728[ebp], ecx
	mov	dl, BYTE PTR __Cat$229736[ebp]
	mov	BYTE PTR $T229733[ebp], dl
	mov	eax, DWORD PTR $T229728[ebp]
	mov	DWORD PTR $T229712[ebp], eax
	jmp	SHORT $LN157@Insert_n
$LN156@Insert_n:
	mov	ecx, DWORD PTR $T229712[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T229712[ebp], ecx
$LN157@Insert_n:
	mov	edx, DWORD PTR $T229712[ebp]
	cmp	edx, DWORD PTR $T229729[ebp]
	je	SHORT $LN149@Insert_n
	jmp	SHORT $LN156@Insert_n
$LN149@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T229763[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T229755[ebp], eax
	jmp	SHORT $LN168@Insert_n
$LN167@Insert_n:
	mov	ecx, DWORD PTR $T229755[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T229755[ebp], ecx
$LN168@Insert_n:
	mov	edx, DWORD PTR $T229755[ebp]
	cmp	edx, DWORD PTR $T229763[ebp]
	je	SHORT $LN164@Insert_n
	mov	eax, DWORD PTR $T229755[ebp]
	mov	ecx, DWORD PTR __Tmp$220432[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$220432[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$220432[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$220432[ebp+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN167@Insert_n
$LN164@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$220442[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$220442[ebp+8], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$220442[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$220442[ebp+12], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$220443[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T229838[ebp], edx
	mov	eax, DWORD PTR $T229838[ebp]
	mov	DWORD PTR $T229819[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229822[ebp], cl
	mov	dl, BYTE PTR __Cat$229826[ebp]
	mov	BYTE PTR $T229823[ebp], dl
	mov	al, BYTE PTR $T229822[ebp]
	mov	BYTE PTR $T229802[ebp], al
	mov	ecx, DWORD PTR $T229819[ebp]
	mov	DWORD PTR $T229801[ebp], ecx
	mov	edx, DWORD PTR $T229801[ebp]
	mov	DWORD PTR $T229791[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __Oldend$220443[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T229790[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T229830[ebp], dl
	mov	al, BYTE PTR __Cat$229834[ebp]
	mov	BYTE PTR $T229831[ebp], al
	movzx	ecx, BYTE PTR $T229830[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229831[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229791[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$220443[ebp]
	push	edx
	mov	eax, DWORD PTR $T229790[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$220443[ebp]
	mov	DWORD PTR $T229905[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T229904[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229883[ebp], cl
	mov	dl, BYTE PTR __Cat$229888[ebp]
	mov	BYTE PTR $T229884[ebp], dl
	mov	al, BYTE PTR $T229883[ebp]
	mov	BYTE PTR $T229881[ebp], al
	mov	cl, BYTE PTR $T229885[ebp]
	mov	BYTE PTR $T229880[ebp], cl
	mov	edx, DWORD PTR $T229905[ebp]
	mov	DWORD PTR $T229879[ebp], edx
	mov	eax, DWORD PTR $T229904[ebp]
	mov	DWORD PTR $T229878[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229893[ebp], cl
	mov	dl, BYTE PTR __Cat$229896[ebp]
	mov	BYTE PTR $T229894[ebp], dl
	mov	al, BYTE PTR $T229893[ebp]
	mov	BYTE PTR $T229866[ebp], al
	mov	ecx, DWORD PTR $T229879[ebp]
	mov	DWORD PTR $T229865[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR __Oldend$220443[ebp]
	sub	eax, edx
	mov	DWORD PTR $T229864[ebp], eax
	mov	ecx, DWORD PTR $T229878[ebp]
	mov	DWORD PTR $T229863[ebp], ecx
$LN196@Insert_n:
	mov	edx, DWORD PTR $T229863[ebp]
	cmp	edx, DWORD PTR $T229864[ebp]
	je	SHORT $LN185@Insert_n
	mov	eax, DWORD PTR $T229864[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T229864[ebp], eax
	mov	ecx, DWORD PTR $T229865[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T229865[ebp], ecx
	mov	edx, DWORD PTR $T229864[ebp]
	mov	eax, DWORD PTR $T229865[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN196@Insert_n
$LN185@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T229913[ebp], eax
	jmp	SHORT $LN203@Insert_n
$LN202@Insert_n:
	mov	ecx, DWORD PTR $T229913[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T229913[ebp], ecx
$LN203@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T229913[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T229913[ebp]
	mov	ecx, DWORD PTR __Tmp$220442[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$220442[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$220442[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$220442[ebp+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN202@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-440]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@2@IABVCvContinent@@@Z ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T229935 = -80						; size = 28
$T229934 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ PROC ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T229935[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T229934[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T229934[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T229935[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229934[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T229934[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T229934[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T229935[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T229935[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T229934[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@KAXXZ ENDP ; std::vector<CvContinent,std::allocator<CvContinent> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
PUBLIC	??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
_TEXT	SEGMENT
tv84 = -468						; size = 4
tv306 = -464						; size = 4
tv292 = -460						; size = 4
tv284 = -456						; size = 4
_this$ = -452						; size = 4
$T230673 = -448						; size = 4
$T230665 = -444						; size = 4
$T230664 = -440						; size = 4
$T230641 = -434						; size = 1
$T230640 = -433						; size = 1
$T230639 = -432						; size = 4
$T230638 = -428						; size = 4
$T230626 = -421						; size = 1
$T230625 = -420						; size = 4
$T230624 = -416						; size = 4
$T230623 = -412						; size = 4
__Cat$230658 = -408					; size = 1
$T230655 = -407						; size = 1
$T230654 = -406						; size = 1
__Cat$230649 = -404					; size = 1
$T230646 = -403						; size = 1
$T230645 = -402						; size = 1
$T230644 = -401						; size = 1
$T230598 = -400						; size = 4
$T230579 = -396						; size = 4
$T230562 = -389						; size = 1
$T230561 = -388						; size = 4
$T230551 = -384						; size = 4
$T230550 = -380						; size = 4
__Cat$230595 = -374					; size = 1
$T230592 = -373						; size = 1
$T230591 = -372						; size = 1
__Cat$230587 = -371					; size = 1
$T230584 = -370						; size = 1
$T230583 = -369						; size = 1
$T230518 = -368						; size = 4
$T230510 = -364						; size = 4
$T230502 = -360						; size = 4
$T230484 = -356						; size = 4
$T230483 = -352						; size = 4
$T230467 = -348						; size = 4
__Cat$230491 = -342					; size = 1
$T230488 = -341						; size = 1
$T230441 = -340						; size = 4
$T230440 = -336						; size = 4
$T230430 = -332						; size = 4
__Cat$230437 = -327					; size = 1
$T230434 = -326						; size = 1
$T230433 = -325						; size = 1
$T230414 = -324						; size = 4
$T230395 = -320						; size = 4
$T230378 = -313						; size = 1
$T230377 = -312						; size = 4
$T230367 = -308						; size = 4
$T230366 = -304						; size = 4
__Cat$230412 = -298					; size = 1
$T230410 = -297						; size = 1
$T230409 = -296						; size = 1
__Cat$230403 = -295					; size = 1
$T230401 = -294						; size = 1
$T230400 = -293						; size = 1
$T230334 = -292						; size = 4
$T230333 = -288						; size = 4
$T230329 = -284						; size = 4
$T230328 = -280						; size = 4
$T230310 = -276						; size = 4
$T230309 = -272						; size = 4
$T230293 = -268						; size = 4
__Cat$230317 = -262					; size = 1
$T230315 = -261						; size = 1
$T230244 = -260						; size = 4
$T230243 = -256						; size = 4
$T230227 = -252						; size = 4
__Cat$230251 = -246					; size = 1
$T230249 = -245						; size = 1
$T230184 = -244						; size = 4
$T230183 = -240						; size = 4
$T230167 = -236						; size = 4
__Cat$230191 = -230					; size = 1
$T230189 = -229						; size = 1
$T230141 = -228						; size = 4
$T230129 = -224						; size = 4
$T230119 = -217						; size = 1
$T230118 = -216						; size = 4
__Cat$230137 = -211					; size = 1
$T230135 = -210						; size = 1
$T230134 = -209						; size = 1
$T230106 = -208						; size = 4
$T230094 = -204						; size = 4
$T230084 = -197						; size = 1
$T230083 = -196						; size = 4
__Cat$230102 = -191					; size = 1
$T230100 = -190						; size = 1
$T230099 = -189						; size = 1
$T230071 = -188						; size = 4
$T230061 = -184						; size = 4
__Cat$230068 = -179					; size = 1
$T230066 = -178						; size = 1
$T230065 = -177						; size = 1
__Count$230033 = -176					; size = 4
__Count$230007 = -104					; size = 4
__Tmp$220517 = -100					; size = 32
__Oldend$220518 = -68					; size = 4
__Tmp$220507 = -64					; size = 32
__Ncopied$220494 = -32					; size = 4
__Newvec$220492 = -28					; size = 4
__Whereoff$220493 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 452				; 000001c4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv284[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 5
	mov	DWORD PTR tv284[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$230007[ebp], 134217727 ; 07ffffffH
	cmp	DWORD PTR __Count$230007[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$230007[ebp]
	mov	DWORD PTR tv292[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv292[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	mov	eax, DWORD PTR tv292[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 5
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$230033[ebp], 134217727 ; 07ffffffH
	cmp	DWORD PTR __Count$230033[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$230033[ebp]
	mov	DWORD PTR tv306[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv306[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv306[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ; std::_Allocate<CvStartRegion>
	add	esp, 8
	mov	DWORD PTR __Newvec$220492[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	mov	DWORD PTR __Whereoff$220493[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$220494[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$220493[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$220492[ebp]
	mov	DWORD PTR $T230071[ebp], eax
	mov	ecx, DWORD PTR $T230071[ebp]
	mov	DWORD PTR $T230061[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T230065[ebp], dl
	mov	al, BYTE PTR __Cat$230068[ebp]
	mov	BYTE PTR $T230066[ebp], al
	movzx	ecx, BYTE PTR $T230065[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T230066[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR $T230061[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$220494[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$220494[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T230106[ebp], eax
	mov	ecx, DWORD PTR __Newvec$220492[ebp]
	mov	DWORD PTR $T230094[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T230099[ebp], dl
	mov	al, BYTE PTR __Cat$230102[ebp]
	mov	BYTE PTR $T230100[ebp], al
	mov	cl, BYTE PTR $T230099[ebp]
	mov	BYTE PTR $T230084[ebp], cl
	mov	edx, DWORD PTR $T230094[ebp]
	mov	DWORD PTR $T230083[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230083[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR $T230106[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$220494[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$220494[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230141[ebp], eax
	mov	ecx, DWORD PTR __Whereoff$220493[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$220492[ebp]
	mov	DWORD PTR $T230129[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T230134[ebp], dl
	mov	al, BYTE PTR __Cat$230137[ebp]
	mov	BYTE PTR $T230135[ebp], al
	mov	cl, BYTE PTR $T230134[ebp]
	mov	BYTE PTR $T230119[ebp], cl
	mov	edx, DWORD PTR $T230129[ebp]
	mov	DWORD PTR $T230118[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230118[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230141[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$220494[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$220493[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$220492[ebp]
	mov	DWORD PTR $T230184[ebp], ecx
	mov	edx, DWORD PTR __Newvec$220492[ebp]
	mov	DWORD PTR $T230183[ebp], edx
	mov	al, BYTE PTR __Cat$230191[ebp]
	mov	BYTE PTR $T230189[ebp], al
	mov	ecx, DWORD PTR $T230183[ebp]
	mov	DWORD PTR $T230167[ebp], ecx
	jmp	SHORT $LN86@Insert_n@2
$LN85@Insert_n@2:
	mov	edx, DWORD PTR $T230167[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T230167[ebp], edx
$LN86@Insert_n@2:
	mov	eax, DWORD PTR $T230167[ebp]
	cmp	eax, DWORD PTR $T230184[ebp]
	je	SHORT $LN7@Insert_n@2
	jmp	SHORT $LN85@Insert_n@2
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$220494[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR __Whereoff$220493[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Newvec$220492[ebp]
	add	edx, ecx
	mov	DWORD PTR $T230244[ebp], edx
	mov	eax, DWORD PTR __Whereoff$220493[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$220492[ebp]
	mov	DWORD PTR $T230243[ebp], eax
	mov	cl, BYTE PTR __Cat$230251[ebp]
	mov	BYTE PTR $T230249[ebp], cl
	mov	edx, DWORD PTR $T230243[ebp]
	mov	DWORD PTR $T230227[ebp], edx
	jmp	SHORT $LN101@Insert_n@2
$LN100@Insert_n@2:
	mov	eax, DWORD PTR $T230227[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T230227[ebp], eax
$LN101@Insert_n@2:
	mov	ecx, DWORD PTR $T230227[ebp]
	cmp	ecx, DWORD PTR $T230244[ebp]
	je	SHORT $LN6@Insert_n@2
	jmp	SHORT $LN100@Insert_n@2
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$220492[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN110@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN110@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 5
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], edx

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T230329[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T230328[ebp], ecx
	mov	edx, DWORD PTR $T230329[ebp]
	mov	DWORD PTR $T230310[ebp], edx
	mov	eax, DWORD PTR $T230328[ebp]
	mov	DWORD PTR $T230309[ebp], eax
	mov	cl, BYTE PTR __Cat$230317[ebp]
	mov	BYTE PTR $T230315[ebp], cl
	mov	edx, DWORD PTR $T230309[ebp]
	mov	DWORD PTR $T230293[ebp], edx
	jmp	SHORT $LN120@Insert_n@2
$LN119@Insert_n@2:
	mov	eax, DWORD PTR $T230293[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T230293[ebp], eax
$LN120@Insert_n@2:
	mov	ecx, DWORD PTR $T230293[ebp]
	cmp	ecx, DWORD PTR $T230310[ebp]
	je	SHORT $LN112@Insert_n@2
	jmp	SHORT $LN119@Insert_n@2
$LN112@Insert_n@2:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 5
	mov	DWORD PTR $T230334[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T230333[ebp], eax
	mov	ecx, DWORD PTR $T230333[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Newvec$220492[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$220492[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$220492[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 5
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	DWORD PTR __Tmp$220507[ebp], 0
	mov	DWORD PTR __Tmp$220507[ebp+4], 0
	mov	DWORD PTR __Tmp$220507[ebp+8], 0
	mov	DWORD PTR __Tmp$220507[ebp+12], 0
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$220507[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$220507[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$220507[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$220507[ebp+12], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$220507[ebp+16], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Tmp$220507[ebp+20], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	al, BYTE PTR [edx+24]
	mov	BYTE PTR __Tmp$220507[ebp+24], al
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR __Tmp$220507[ebp+28], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T230414[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T230395[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T230400[ebp], al
	mov	cl, BYTE PTR __Cat$230403[ebp]
	mov	BYTE PTR $T230401[ebp], cl
	mov	dl, BYTE PTR $T230400[ebp]
	mov	BYTE PTR $T230378[ebp], dl
	mov	eax, DWORD PTR $T230395[ebp]
	mov	DWORD PTR $T230377[ebp], eax
	mov	ecx, DWORD PTR $T230377[ebp]
	mov	DWORD PTR $T230367[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T230366[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T230409[ebp], al
	mov	cl, BYTE PTR __Cat$230412[ebp]
	mov	BYTE PTR $T230410[ebp], cl
	movzx	edx, BYTE PTR $T230409[ebp]
	push	edx
	movzx	eax, BYTE PTR $T230410[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230367[ebp]
	push	edx
	mov	eax, DWORD PTR $T230414[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230366[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 5
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T230441[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230440[ebp], eax
	mov	ecx, DWORD PTR $T230440[ebp]
	mov	DWORD PTR $T230430[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T230433[ebp], dl
	mov	al, BYTE PTR __Cat$230437[ebp]
	mov	BYTE PTR $T230434[ebp], al
	movzx	ecx, BYTE PTR $T230433[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T230434[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$220507[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230441[ebp]
	push	edx
	mov	eax, DWORD PTR $T230430[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T230502[ebp], ecx
	mov	eax, DWORD PTR $T230502[ebp]
	mov	DWORD PTR $T230484[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T230483[ebp], ecx
	mov	dl, BYTE PTR __Cat$230491[ebp]
	mov	BYTE PTR $T230488[ebp], dl
	mov	eax, DWORD PTR $T230483[ebp]
	mov	DWORD PTR $T230467[ebp], eax
	jmp	SHORT $LN159@Insert_n@2
$LN158@Insert_n@2:
	mov	ecx, DWORD PTR $T230467[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T230467[ebp], ecx
$LN159@Insert_n@2:
	mov	edx, DWORD PTR $T230467[ebp]
	cmp	edx, DWORD PTR $T230484[ebp]
	je	SHORT $LN151@Insert_n@2
	jmp	SHORT $LN158@Insert_n@2
$LN151@Insert_n@2:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T230518[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T230510[ebp], eax
	jmp	SHORT $LN170@Insert_n@2
$LN169@Insert_n@2:
	mov	ecx, DWORD PTR $T230510[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T230510[ebp], ecx
$LN170@Insert_n@2:
	mov	edx, DWORD PTR $T230510[ebp]
	cmp	edx, DWORD PTR $T230518[ebp]
	je	SHORT $LN166@Insert_n@2
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$220507[ebp]
	mov	edi, DWORD PTR $T230510[ebp]
	rep movsd
	jmp	SHORT $LN169@Insert_n@2
$LN166@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	DWORD PTR __Tmp$220517[ebp], 0
	mov	DWORD PTR __Tmp$220517[ebp+4], 0
	mov	DWORD PTR __Tmp$220517[ebp+8], 0
	mov	DWORD PTR __Tmp$220517[ebp+12], 0
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$220517[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$220517[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$220517[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$220517[ebp+12], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Tmp$220517[ebp+16], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$220517[ebp+20], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	dl, BYTE PTR [ecx+24]
	mov	BYTE PTR __Tmp$220517[ebp+24], dl
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR __Tmp$220517[ebp+28], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$220518[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T230598[ebp], edx
	mov	eax, DWORD PTR $T230598[ebp]
	mov	DWORD PTR $T230579[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T230583[ebp], cl
	mov	dl, BYTE PTR __Cat$230587[ebp]
	mov	BYTE PTR $T230584[ebp], dl
	mov	al, BYTE PTR $T230583[ebp]
	mov	BYTE PTR $T230562[ebp], al
	mov	ecx, DWORD PTR $T230579[ebp]
	mov	DWORD PTR $T230561[ebp], ecx
	mov	edx, DWORD PTR $T230561[ebp]
	mov	DWORD PTR $T230551[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR __Oldend$220518[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T230550[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T230591[ebp], dl
	mov	al, BYTE PTR __Cat$230595[ebp]
	mov	BYTE PTR $T230592[ebp], al
	movzx	ecx, BYTE PTR $T230591[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T230592[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230551[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$220518[ebp]
	push	edx
	mov	eax, DWORD PTR $T230550[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$220518[ebp]
	mov	DWORD PTR $T230665[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T230664[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T230644[ebp], cl
	mov	dl, BYTE PTR __Cat$230649[ebp]
	mov	BYTE PTR $T230645[ebp], dl
	mov	al, BYTE PTR $T230644[ebp]
	mov	BYTE PTR $T230641[ebp], al
	mov	cl, BYTE PTR $T230646[ebp]
	mov	BYTE PTR $T230640[ebp], cl
	mov	edx, DWORD PTR $T230665[ebp]
	mov	DWORD PTR $T230639[ebp], edx
	mov	eax, DWORD PTR $T230664[ebp]
	mov	DWORD PTR $T230638[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T230654[ebp], cl
	mov	dl, BYTE PTR __Cat$230658[ebp]
	mov	BYTE PTR $T230655[ebp], dl
	mov	al, BYTE PTR $T230654[ebp]
	mov	BYTE PTR $T230626[ebp], al
	mov	ecx, DWORD PTR $T230639[ebp]
	mov	DWORD PTR $T230625[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR __Oldend$220518[ebp]
	sub	eax, edx
	mov	DWORD PTR $T230624[ebp], eax
	mov	ecx, DWORD PTR $T230638[ebp]
	mov	DWORD PTR $T230623[ebp], ecx
$LN200@Insert_n@2:
	mov	edx, DWORD PTR $T230623[ebp]
	cmp	edx, DWORD PTR $T230624[ebp]
	je	SHORT $LN189@Insert_n@2
	mov	eax, DWORD PTR $T230624[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR $T230624[ebp], eax
	mov	ecx, DWORD PTR $T230625[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR $T230625[ebp], ecx
	mov	esi, DWORD PTR $T230624[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T230625[ebp]
	rep movsd
	jmp	SHORT $LN200@Insert_n@2
$LN189@Insert_n@2:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T230673[ebp], edx
	jmp	SHORT $LN207@Insert_n@2
$LN206@Insert_n@2:
	mov	eax, DWORD PTR $T230673[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T230673[ebp], eax
$LN207@Insert_n@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T230673[ebp], ecx
	je	SHORT $LN16@Insert_n@2
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$220517[ebp]
	mov	edi, DWORD PTR $T230673[ebp]
	rep movsd
	jmp	SHORT $LN206@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-472]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@2@IABVCvStartRegion@@@Z ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T230695 = -80						; size = 28
$T230694 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ PROC ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T230695[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T230694[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T230694[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T230695[ebp]
	push	eax
	lea	ecx, DWORD PTR $T230694[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T230694[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T230694[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T230695[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T230695[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T230694[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@KAXXZ ENDP ; std::vector<CvStartRegion,std::allocator<CvStartRegion> >::_Xlen
PUBLIC	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
PUBLIC	??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
tv84 = -420						; size = 4
tv306 = -416						; size = 4
tv292 = -412						; size = 4
tv284 = -408						; size = 4
_this$ = -404						; size = 4
$T231401 = -400						; size = 4
$T231393 = -396						; size = 4
$T231392 = -392						; size = 4
$T231369 = -386						; size = 1
$T231368 = -385						; size = 1
$T231367 = -384						; size = 4
$T231366 = -380						; size = 4
$T231354 = -373						; size = 1
$T231353 = -372						; size = 4
$T231352 = -368						; size = 4
$T231351 = -364						; size = 4
__Cat$231386 = -360					; size = 1
$T231384 = -359						; size = 1
$T231383 = -358						; size = 1
__Cat$231376 = -356					; size = 1
$T231374 = -355						; size = 1
$T231373 = -354						; size = 1
$T231372 = -353						; size = 1
$T231326 = -352						; size = 4
$T231307 = -348						; size = 4
$T231290 = -341						; size = 1
$T231289 = -340						; size = 4
$T231279 = -336						; size = 4
$T231278 = -332						; size = 4
__Cat$231324 = -326					; size = 1
$T231322 = -325						; size = 1
$T231321 = -324						; size = 1
__Cat$231315 = -323					; size = 1
$T231313 = -322						; size = 1
$T231312 = -321						; size = 1
$T231251 = -320						; size = 4
$T231243 = -316						; size = 4
$T231235 = -312						; size = 4
$T231217 = -308						; size = 4
$T231216 = -304						; size = 4
$T231200 = -300						; size = 4
__Cat$231224 = -294					; size = 1
$T231222 = -293						; size = 1
$T231174 = -292						; size = 4
$T231173 = -288						; size = 4
$T231163 = -284						; size = 4
__Cat$231170 = -279					; size = 1
$T231168 = -278						; size = 1
$T231167 = -277						; size = 1
$T231147 = -276						; size = 4
$T231128 = -272						; size = 4
$T231111 = -265						; size = 1
$T231110 = -264						; size = 4
$T231100 = -260						; size = 4
$T231099 = -256						; size = 4
__Cat$231145 = -250					; size = 1
$T231143 = -249						; size = 1
$T231142 = -248						; size = 1
__Cat$231136 = -247					; size = 1
$T231134 = -246						; size = 1
$T231133 = -245						; size = 1
$T231072 = -244						; size = 4
$T231071 = -240						; size = 4
$T231067 = -236						; size = 4
$T231066 = -232						; size = 4
$T231048 = -228						; size = 4
$T231047 = -224						; size = 4
$T231031 = -220						; size = 4
__Cat$231055 = -214					; size = 1
$T231053 = -213						; size = 1
$T230982 = -212						; size = 4
$T230981 = -208						; size = 4
$T230965 = -204						; size = 4
__Cat$230989 = -198					; size = 1
$T230987 = -197						; size = 1
$T230922 = -196						; size = 4
$T230921 = -192						; size = 4
$T230905 = -188						; size = 4
__Cat$230929 = -182					; size = 1
$T230927 = -181						; size = 1
$T230879 = -180						; size = 4
$T230867 = -176						; size = 4
$T230857 = -169						; size = 1
$T230856 = -168						; size = 4
__Cat$230875 = -163					; size = 1
$T230872 = -162						; size = 1
$T230871 = -161						; size = 1
$T230844 = -160						; size = 4
$T230832 = -156						; size = 4
$T230822 = -149						; size = 1
$T230821 = -148						; size = 4
__Cat$230840 = -143					; size = 1
$T230837 = -142						; size = 1
$T230836 = -141						; size = 1
$T230809 = -140						; size = 4
$T230799 = -136						; size = 4
__Cat$230807 = -131					; size = 1
$T230804 = -130						; size = 1
$T230803 = -129						; size = 1
__Count$230773 = -128					; size = 4
__Count$230747 = -56					; size = 4
__Tmp$220592 = -52					; size = 8
__Oldend$220593 = -44					; size = 4
__Tmp$220582 = -40					; size = 8
__Ncopied$220569 = -32					; size = 4
__Newvec$220567 = -28					; size = 4
__Whereoff$220568 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 404				; 00000194H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@3
	mov	DWORD PTR tv284[ebp], 0
	jmp	SHORT $LN27@Insert_n@3
$LN29@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv284[ebp], eax
$LN27@Insert_n@3:
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$230747[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$230747[ebp], 0
	jbe	SHORT $LN35@Insert_n@3
	mov	edx, DWORD PTR __Count$230747[ebp]
	mov	DWORD PTR tv292[ebp], edx
	jmp	SHORT $LN37@Insert_n@3
$LN35@Insert_n@3:
	mov	DWORD PTR tv292[ebp], 1
$LN37@Insert_n@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	eax, DWORD PTR tv292[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen
	jmp	$LN16@Insert_n@3

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$230773[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$230773[ebp], 0
	jbe	SHORT $LN48@Insert_n@3
	mov	ecx, DWORD PTR __Count$230773[ebp]
	mov	DWORD PTR tv306[ebp], ecx
	jmp	SHORT $LN44@Insert_n@3
$LN48@Insert_n@3:
	mov	DWORD PTR tv306[ebp], 1
$LN44@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv306[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@3:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@3:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ; std::_Allocate<CvPlayerStartRank>
	add	esp, 8
	mov	DWORD PTR __Newvec$220567[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR __Whereoff$220568[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$220569[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$220568[ebp]
	mov	ecx, DWORD PTR __Newvec$220567[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T230809[ebp], edx
	mov	eax, DWORD PTR $T230809[ebp]
	mov	DWORD PTR $T230799[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T230803[ebp], cl
	mov	dl, BYTE PTR __Cat$230807[ebp]
	mov	BYTE PTR $T230804[ebp], dl
	movzx	eax, BYTE PTR $T230803[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T230804[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230799[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$220569[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$220569[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T230844[ebp], edx
	mov	eax, DWORD PTR __Newvec$220567[ebp]
	mov	DWORD PTR $T230832[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T230836[ebp], cl
	mov	dl, BYTE PTR __Cat$230840[ebp]
	mov	BYTE PTR $T230837[ebp], dl
	mov	al, BYTE PTR $T230836[ebp]
	mov	BYTE PTR $T230822[ebp], al
	mov	ecx, DWORD PTR $T230832[ebp]
	mov	DWORD PTR $T230821[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T230821[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230844[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$220569[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$220569[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T230879[ebp], edx
	mov	eax, DWORD PTR __Whereoff$220568[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$220567[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T230867[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T230871[ebp], al
	mov	cl, BYTE PTR __Cat$230875[ebp]
	mov	BYTE PTR $T230872[ebp], cl
	mov	dl, BYTE PTR $T230871[ebp]
	mov	BYTE PTR $T230857[ebp], dl
	mov	eax, DWORD PTR $T230867[ebp]
	mov	DWORD PTR $T230856[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230856[ebp]
	push	edx
	mov	eax, DWORD PTR $T230879[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@3
__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$220569[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$220568[ebp]
	mov	eax, DWORD PTR __Newvec$220567[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T230922[ebp], ecx
	mov	edx, DWORD PTR __Newvec$220567[ebp]
	mov	DWORD PTR $T230921[ebp], edx
	mov	al, BYTE PTR __Cat$230929[ebp]
	mov	BYTE PTR $T230927[ebp], al
	mov	ecx, DWORD PTR $T230921[ebp]
	mov	DWORD PTR $T230905[ebp], ecx
	jmp	SHORT $LN86@Insert_n@3
$LN85@Insert_n@3:
	mov	edx, DWORD PTR $T230905[ebp]
	add	edx, 8
	mov	DWORD PTR $T230905[ebp], edx
$LN86@Insert_n@3:
	mov	eax, DWORD PTR $T230905[ebp]
	cmp	eax, DWORD PTR $T230922[ebp]
	je	SHORT $LN7@Insert_n@3
	jmp	SHORT $LN85@Insert_n@3
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$220569[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$220568[ebp]
	mov	edx, DWORD PTR __Newvec$220567[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T230982[ebp], edx
	mov	eax, DWORD PTR __Whereoff$220568[ebp]
	mov	ecx, DWORD PTR __Newvec$220567[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T230981[ebp], edx
	mov	al, BYTE PTR __Cat$230989[ebp]
	mov	BYTE PTR $T230987[ebp], al
	mov	ecx, DWORD PTR $T230981[ebp]
	mov	DWORD PTR $T230965[ebp], ecx
	jmp	SHORT $LN101@Insert_n@3
$LN100@Insert_n@3:
	mov	edx, DWORD PTR $T230965[ebp]
	add	edx, 8
	mov	DWORD PTR $T230965[ebp], edx
$LN101@Insert_n@3:
	mov	eax, DWORD PTR $T230965[ebp]
	cmp	eax, DWORD PTR $T230982[ebp]
	je	SHORT $LN6@Insert_n@3
	jmp	SHORT $LN100@Insert_n@3
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$220567[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN110@Insert_n@3
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN110@Insert_n@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T231067[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231066[ebp], eax
	mov	ecx, DWORD PTR $T231067[ebp]
	mov	DWORD PTR $T231048[ebp], ecx
	mov	edx, DWORD PTR $T231066[ebp]
	mov	DWORD PTR $T231047[ebp], edx
	mov	al, BYTE PTR __Cat$231055[ebp]
	mov	BYTE PTR $T231053[ebp], al
	mov	ecx, DWORD PTR $T231047[ebp]
	mov	DWORD PTR $T231031[ebp], ecx
	jmp	SHORT $LN120@Insert_n@3
$LN119@Insert_n@3:
	mov	edx, DWORD PTR $T231031[ebp]
	add	edx, 8
	mov	DWORD PTR $T231031[ebp], edx
$LN120@Insert_n@3:
	mov	eax, DWORD PTR $T231031[ebp]
	cmp	eax, DWORD PTR $T231048[ebp]
	je	SHORT $LN112@Insert_n@3
	jmp	SHORT $LN119@Insert_n@3
$LN112@Insert_n@3:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T231072[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231071[ebp], edx
	mov	eax, DWORD PTR $T231071[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$220567[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$220567[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$220567[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$220582[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$220582[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T231147[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T231128[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T231133[ebp], cl
	mov	dl, BYTE PTR __Cat$231136[ebp]
	mov	BYTE PTR $T231134[ebp], dl
	mov	al, BYTE PTR $T231133[ebp]
	mov	BYTE PTR $T231111[ebp], al
	mov	ecx, DWORD PTR $T231128[ebp]
	mov	DWORD PTR $T231110[ebp], ecx
	mov	edx, DWORD PTR $T231110[ebp]
	mov	DWORD PTR $T231100[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T231099[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T231142[ebp], cl
	mov	dl, BYTE PTR __Cat$231145[ebp]
	mov	BYTE PTR $T231143[ebp], dl
	movzx	eax, BYTE PTR $T231142[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T231143[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T231100[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231147[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231099[ebp]
	push	edx
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T231174[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T231173[ebp], ecx
	mov	edx, DWORD PTR $T231173[ebp]
	mov	DWORD PTR $T231163[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T231167[ebp], al
	mov	cl, BYTE PTR __Cat$231170[ebp]
	mov	BYTE PTR $T231168[ebp], cl
	movzx	edx, BYTE PTR $T231167[ebp]
	push	edx
	movzx	eax, BYTE PTR $T231168[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$220582[ebp]
	push	edx
	mov	eax, DWORD PTR $T231174[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231163[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T231235[ebp], edx
	mov	eax, DWORD PTR $T231235[ebp]
	mov	DWORD PTR $T231217[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR $T231216[ebp], eax
	mov	cl, BYTE PTR __Cat$231224[ebp]
	mov	BYTE PTR $T231222[ebp], cl
	mov	edx, DWORD PTR $T231216[ebp]
	mov	DWORD PTR $T231200[ebp], edx
	jmp	SHORT $LN157@Insert_n@3
$LN156@Insert_n@3:
	mov	eax, DWORD PTR $T231200[ebp]
	add	eax, 8
	mov	DWORD PTR $T231200[ebp], eax
$LN157@Insert_n@3:
	mov	ecx, DWORD PTR $T231200[ebp]
	cmp	ecx, DWORD PTR $T231217[ebp]
	je	SHORT $LN149@Insert_n@3
	jmp	SHORT $LN156@Insert_n@3
$LN149@Insert_n@3:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T231251[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T231243[ebp], ecx
	jmp	SHORT $LN168@Insert_n@3
$LN167@Insert_n@3:
	mov	edx, DWORD PTR $T231243[ebp]
	add	edx, 8
	mov	DWORD PTR $T231243[ebp], edx
$LN168@Insert_n@3:
	mov	eax, DWORD PTR $T231243[ebp]
	cmp	eax, DWORD PTR $T231251[ebp]
	je	SHORT $LN164@Insert_n@3
	mov	ecx, DWORD PTR __Tmp$220582[ebp]
	mov	edx, DWORD PTR __Tmp$220582[ebp+4]
	mov	eax, DWORD PTR $T231243[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN167@Insert_n@3
$LN164@Insert_n@3:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$220592[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$220592[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$220593[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231326[ebp], edx
	mov	eax, DWORD PTR $T231326[ebp]
	mov	DWORD PTR $T231307[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T231312[ebp], cl
	mov	dl, BYTE PTR __Cat$231315[ebp]
	mov	BYTE PTR $T231313[ebp], dl
	mov	al, BYTE PTR $T231312[ebp]
	mov	BYTE PTR $T231290[ebp], al
	mov	ecx, DWORD PTR $T231307[ebp]
	mov	DWORD PTR $T231289[ebp], ecx
	mov	edx, DWORD PTR $T231289[ebp]
	mov	DWORD PTR $T231279[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$220593[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T231278[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T231321[ebp], dl
	mov	al, BYTE PTR __Cat$231324[ebp]
	mov	BYTE PTR $T231322[ebp], al
	movzx	ecx, BYTE PTR $T231321[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T231322[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231279[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$220593[ebp]
	push	edx
	mov	eax, DWORD PTR $T231278[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$220593[ebp]
	mov	DWORD PTR $T231393[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T231392[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T231372[ebp], cl
	mov	dl, BYTE PTR __Cat$231376[ebp]
	mov	BYTE PTR $T231373[ebp], dl
	mov	al, BYTE PTR $T231372[ebp]
	mov	BYTE PTR $T231369[ebp], al
	mov	cl, BYTE PTR $T231374[ebp]
	mov	BYTE PTR $T231368[ebp], cl
	mov	edx, DWORD PTR $T231393[ebp]
	mov	DWORD PTR $T231367[ebp], edx
	mov	eax, DWORD PTR $T231392[ebp]
	mov	DWORD PTR $T231366[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T231383[ebp], cl
	mov	dl, BYTE PTR __Cat$231386[ebp]
	mov	BYTE PTR $T231384[ebp], dl
	mov	al, BYTE PTR $T231383[ebp]
	mov	BYTE PTR $T231354[ebp], al
	mov	ecx, DWORD PTR $T231367[ebp]
	mov	DWORD PTR $T231353[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	mov	eax, DWORD PTR __Oldend$220593[ebp]
	sub	eax, edx
	mov	DWORD PTR $T231352[ebp], eax
	mov	ecx, DWORD PTR $T231366[ebp]
	mov	DWORD PTR $T231351[ebp], ecx
$LN196@Insert_n@3:
	mov	edx, DWORD PTR $T231351[ebp]
	cmp	edx, DWORD PTR $T231352[ebp]
	je	SHORT $LN185@Insert_n@3
	mov	eax, DWORD PTR $T231352[ebp]
	sub	eax, 8
	mov	DWORD PTR $T231352[ebp], eax
	mov	ecx, DWORD PTR $T231353[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T231353[ebp], ecx
	mov	edx, DWORD PTR $T231352[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T231353[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN196@Insert_n@3
$LN185@Insert_n@3:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T231401[ebp], eax
	jmp	SHORT $LN203@Insert_n@3
$LN202@Insert_n@3:
	mov	ecx, DWORD PTR $T231401[ebp]
	add	ecx, 8
	mov	DWORD PTR $T231401[ebp], ecx
$LN203@Insert_n@3:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	cmp	DWORD PTR $T231401[ebp], ecx
	je	SHORT $LN16@Insert_n@3
	mov	edx, DWORD PTR __Tmp$220592[ebp]
	mov	eax, DWORD PTR __Tmp$220592[ebp+4]
	mov	ecx, DWORD PTR $T231401[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN202@Insert_n@3
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-424]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@2@IABVCvPlayerStartRank@@@Z ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231423 = -80						; size = 28
$T231422 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ PROC ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231423[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T231422[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T231422[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T231423[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231422[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T231422[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231422[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T231423[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231423[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231422[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >::_Xlen
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z
_TEXT	SEGMENT
$T231448 = -16						; size = 4
$T231444 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z PROC ; std::_Allocate<CvContinent>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T231448[ebp], 0
	lea	eax, DWORD PTR $T231448[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231444[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T231444[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231444[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCvContinent@@@std@@YAPAVCvContinent@@IPAV1@@Z ENDP ; std::_Allocate<CvContinent>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z
_TEXT	SEGMENT
$T231462 = -16						; size = 4
$T231458 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z PROC ; std::_Allocate<CvStartRegion>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T231462[ebp], 0
	lea	eax, DWORD PTR $T231462[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231458[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T231458[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231458[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCvStartRegion@@@std@@YAPAVCvStartRegion@@IPAV1@@Z ENDP ; std::_Allocate<CvStartRegion>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z
_TEXT	SEGMENT
$T231469 = -16						; size = 4
$T231465 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z PROC ; std::_Allocate<CvPlayerStartRank>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T231469[ebp], 0
	lea	eax, DWORD PTR $T231469[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231465[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T231465[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231465[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCvPlayerStartRank@@@std@@YAPAVCvPlayerStartRank@@IPAV1@@Z ENDP ; std::_Allocate<CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
PUBLIC	??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
PUBLIC	??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z
_TEXT	SEGMENT
$T232350 = -304						; size = 4
$T232349 = -300						; size = 4
$T232340 = -296						; size = 4
$T232339 = -292						; size = 4
$T232323 = -288						; size = 4
$T232322 = -284						; size = 4
$T232290 = -280						; size = 4
$T232289 = -276						; size = 4
$T232254 = -272						; size = 4
__Mid$221415 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

$LN10@Sort:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$221415[ebp]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$221415[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 4
	mov	DWORD PTR $T232254[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$221415[ebp+4]
	sar	edx, 4
	cmp	DWORD PTR $T232254[ebp], edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$221415[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$221415[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$221415[ebp+4]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$221415[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN10@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T232290[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T232289[ebp], eax
	mov	ecx, DWORD PTR $T232290[ebp]
	sub	ecx, DWORD PTR $T232289[ebp]
	sar	ecx, 4
	cmp	ecx, 1
	jle	SHORT $LN356@Sort
	push	0
	push	0
	mov	edx, DWORD PTR $T232290[ebp]
	push	edx
	mov	eax, DWORD PTR $T232289[ebp]
	push	eax
	call	??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 16					; 00000010H
$LN356@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T232340[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T232339[ebp], edx
	mov	eax, DWORD PTR $T232340[ebp]
	mov	DWORD PTR $T232323[ebp], eax
	mov	ecx, DWORD PTR $T232339[ebp]
	mov	DWORD PTR $T232322[ebp], ecx
	jmp	SHORT $LN377@Sort
$LN369@Sort:
	mov	edx, DWORD PTR $T232323[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR $T232323[ebp], edx
$LN377@Sort:
	mov	eax, DWORD PTR $T232323[ebp]
	sub	eax, DWORD PTR $T232322[ebp]
	sar	eax, 4
	cmp	eax, 1
	jle	SHORT $LN366@Sort
	mov	ecx, DWORD PTR $T232323[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232322[ebp]
	push	edx
	call	??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 8
	jmp	SHORT $LN369@Sort
$LN366@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T232350[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T232349[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T232350[ebp]
	push	edx
	mov	eax, DWORD PTR $T232349[ebp]
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
PUBLIC	??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
PUBLIC	??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z
_TEXT	SEGMENT
$T233231 = -304						; size = 4
$T233230 = -300						; size = 4
$T233221 = -296						; size = 4
$T233220 = -292						; size = 4
$T233204 = -288						; size = 4
$T233203 = -284						; size = 4
$T233171 = -280						; size = 4
$T233170 = -276						; size = 4
$T233135 = -272						; size = 4
__Mid$221486 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

$LN10@Sort@2:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort@2
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN6@Sort@2

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$221486[ebp]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$221486[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 5
	mov	DWORD PTR $T233135[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$221486[ebp+4]
	sar	edx, 5
	cmp	DWORD PTR $T233135[ebp], edx
	jge	SHORT $LN5@Sort@2

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$221486[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$221486[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort@2
$LN5@Sort@2:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$221486[ebp+4]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$221486[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort@2:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN10@Sort@2
$LN6@Sort@2:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN3@Sort@2

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T233171[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T233170[ebp], eax
	mov	ecx, DWORD PTR $T233171[ebp]
	sub	ecx, DWORD PTR $T233170[ebp]
	sar	ecx, 5
	cmp	ecx, 1
	jle	SHORT $LN356@Sort@2
	push	0
	push	0
	mov	edx, DWORD PTR $T233171[ebp]
	push	edx
	mov	eax, DWORD PTR $T233170[ebp]
	push	eax
	call	??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 16					; 00000010H
$LN356@Sort@2:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T233221[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T233220[ebp], edx
	mov	eax, DWORD PTR $T233221[ebp]
	mov	DWORD PTR $T233204[ebp], eax
	mov	ecx, DWORD PTR $T233220[ebp]
	mov	DWORD PTR $T233203[ebp], ecx
	jmp	SHORT $LN377@Sort@2
$LN369@Sort@2:
	mov	edx, DWORD PTR $T233204[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR $T233204[ebp], edx
$LN377@Sort@2:
	mov	eax, DWORD PTR $T233204[ebp]
	sub	eax, DWORD PTR $T233203[ebp]
	sar	eax, 5
	cmp	eax, 1
	jle	SHORT $LN366@Sort@2
	mov	ecx, DWORD PTR $T233204[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233203[ebp]
	push	edx
	call	??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 8
	jmp	SHORT $LN369@Sort@2
$LN366@Sort@2:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort@2
$LN3@Sort@2:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort@2

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T233231[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T233230[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T233231[ebp]
	push	edx
	mov	eax, DWORD PTR $T233230[ebp]
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
	add	esp, 12					; 0000000cH
$LN8@Sort@2:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
PUBLIC	??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
PUBLIC	??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z
_TEXT	SEGMENT
$T234112 = -304						; size = 4
$T234111 = -300						; size = 4
$T234102 = -296						; size = 4
$T234101 = -292						; size = 4
$T234085 = -288						; size = 4
$T234084 = -284						; size = 4
$T234052 = -280						; size = 4
$T234051 = -276						; size = 4
$T234016 = -272						; size = 4
__Mid$221557 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

$LN10@Sort@3:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort@3
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	$LN6@Sort@3

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$221557[ebp]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$221557[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	DWORD PTR $T234016[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$221557[ebp+4]
	sar	edx, 3
	cmp	DWORD PTR $T234016[ebp], edx
	jge	SHORT $LN5@Sort@3

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$221557[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$221557[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort@3
$LN5@Sort@3:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$221557[ebp+4]
	push	eax
	call	??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$221557[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort@3:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN10@Sort@3
$LN6@Sort@3:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN3@Sort@3

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T234052[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234051[ebp], eax
	mov	ecx, DWORD PTR $T234052[ebp]
	sub	ecx, DWORD PTR $T234051[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN356@Sort@3
	push	0
	push	0
	mov	edx, DWORD PTR $T234052[ebp]
	push	edx
	mov	eax, DWORD PTR $T234051[ebp]
	push	eax
	call	??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 16					; 00000010H
$LN356@Sort@3:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T234102[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234101[ebp], edx
	mov	eax, DWORD PTR $T234102[ebp]
	mov	DWORD PTR $T234085[ebp], eax
	mov	ecx, DWORD PTR $T234101[ebp]
	mov	DWORD PTR $T234084[ebp], ecx
	jmp	SHORT $LN377@Sort@3
$LN369@Sort@3:
	mov	edx, DWORD PTR $T234085[ebp]
	sub	edx, 8
	mov	DWORD PTR $T234085[ebp], edx
$LN377@Sort@3:
	mov	eax, DWORD PTR $T234085[ebp]
	sub	eax, DWORD PTR $T234084[ebp]
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN366@Sort@3
	mov	ecx, DWORD PTR $T234085[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234084[ebp]
	push	edx
	call	??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 8
	jmp	SHORT $LN369@Sort@3
$LN366@Sort@3:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort@3
$LN3@Sort@3:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort@3

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T234112[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T234111[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T234112[ebp]
	push	edx
	mov	eax, DWORD PTR $T234111[ebp]
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
	add	esp, 12					; 0000000cH
$LN8@Sort@3:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T234148 = -32						; size = 4
$T234147 = -28						; size = 4
__Vptr$234145 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$234145[ebp], eax
	mov	ecx, DWORD PTR __Vptr$234145[ebp]
	mov	DWORD PTR $T234148[ebp], ecx
	cmp	DWORD PTR $T234148[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR $T234148[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T234148[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR $T234148[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T234148[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T234148[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $LN19@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T234147[ebp], eax
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvContinent@@IV1@V?$allocator@VCvContinent@@@std@@@std@@YAXPAVCvContinent@@IABV1@AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvContinent *,unsigned int,CvContinent,std::allocator<CvContinent> >
PUBLIC	??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z ; std::_Construct<CvStartRegion,CvStartRegion>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z ; std::_Construct<CvStartRegion,CvStartRegion>
	add	esp, 8
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvStartRegion@@IV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAXPAVCvStartRegion@@IABV1@AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvStartRegion *,unsigned int,CvStartRegion,std::allocator<CvStartRegion> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T234252 = -32						; size = 4
$T234251 = -28						; size = 4
__Vptr$234249 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@3
$LN5@Uninit_fil@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$234249[ebp], eax
	mov	ecx, DWORD PTR __Vptr$234249[ebp]
	mov	DWORD PTR $T234252[ebp], ecx
	cmp	DWORD PTR $T234252[ebp], 0
	je	SHORT $LN18@Uninit_fil@3
	mov	edx, DWORD PTR $T234252[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T234252[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T234252[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $LN19@Uninit_fil@3
$LN18@Uninit_fil@3:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil@3:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T234251[ebp], eax
	jmp	SHORT $LN5@Uninit_fil@3
$LN4@Uninit_fil@3:
	jmp	SHORT $LN10@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@3
$LN2@Uninit_fil@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil@3:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@3

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@3
	ret	0
$LN10@Uninit_fil@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@3:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvPlayerStartRank@@IV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAXPAVCvPlayerStartRank@@IABV1@AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvPlayerStartRank *,unsigned int,CvPlayerStartRank,std::allocator<CvPlayerStartRank> >
PUBLIC	??0CvContinent@@QAE@ABV0@@Z			; CvContinent::CvContinent
PUBLIC	??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z ; std::swap<CvContinent>
PUBLIC	??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
$T235319 = -444						; size = 4
$T235318 = -440						; size = 4
$T235301 = -436						; size = 4
__Tmp$235314 = -432					; size = 16
$T235282 = -416						; size = 4
__Tmp$235267 = -412					; size = 4
$T235248 = -408						; size = 4
$T235247 = -404						; size = 4
$T235230 = -400						; size = 4
__Tmp$235243 = -396					; size = 16
$T235211 = -380						; size = 4
$T235193 = -376						; size = 4
$T235192 = -372						; size = 4
$T235175 = -368						; size = 4
__Tmp$235188 = -364					; size = 16
$T235156 = -348						; size = 4
$T235119 = -344						; size = 4
$T235118 = -340						; size = 4
$T235101 = -336						; size = 4
__Tmp$235114 = -332					; size = 16
$T235082 = -316						; size = 4
__Tmp$235067 = -312					; size = 4
__Tmp$235051 = -308					; size = 4
$T235032 = -304						; size = 4
$T235031 = -300						; size = 4
$T235016 = -296						; size = 4
__Tmp$235029 = -292					; size = 16
$T235002 = -276						; size = 4
$T234972 = -272						; size = 4
$T234971 = -268						; size = 4
$T234956 = -264						; size = 4
__Tmp$234970 = -260					; size = 16
$T234942 = -244						; size = 4
__Tmp$234917 = -240					; size = 4
$T234896 = -236						; size = 4
$T234887 = -232						; size = 4
__Tmp$234871 = -228					; size = 4
$T234850 = -224						; size = 4
__Tmp$234834 = -220					; size = 4
$T234816 = -216						; size = 4
$T234796 = -212						; size = 4
$T234795 = -208						; size = 4
$T234776 = -204						; size = 4
__Tmp$234761 = -200					; size = 4
$T234747 = -196						; size = 4
$T234738 = -192						; size = 4
$T234726 = -188						; size = 4
$T234717 = -184						; size = 4
$T234686 = -180						; size = 4
$T234677 = -176						; size = 4
$T234665 = -172						; size = 4
$T234656 = -168						; size = 4
$T234633 = -164						; size = 4
$T234624 = -160						; size = 4
__Tmp$234615 = -156					; size = 4
$T234587 = -152						; size = 4
__Tmp$234578 = -148					; size = 4
$T234553 = -144						; size = 4
__Tmp$234541 = -140					; size = 4
__Tmp$234329 = -68					; size = 4
__Tmp$234306 = -64					; size = 4
$T234287 = -60						; size = 4
$T234286 = -56						; size = 4
$T234285 = -52						; size = 4
$T234284 = -48						; size = 4
$T234283 = -44						; size = 4
$T234282 = -40						; size = 4
$T234281 = -36						; size = 4
$T234280 = -32						; size = 4
$T234279 = -28						; size = 4
$T234278 = -24						; size = 4
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$234306[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	cdq
	sub	eax, edx
	sar	eax, 1
	shl	eax, 4
	add	eax, DWORD PTR __Tmp$234306[ebp]
	mov	DWORD PTR __Tmp$234306[ebp], eax
	mov	ecx, DWORD PTR __Tmp$234306[ebp]
	mov	DWORD PTR __Mid$[ebp], ecx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$234329[ebp], edx
	mov	eax, 1
	neg	eax
	shl	eax, 4
	add	eax, DWORD PTR __Tmp$234329[ebp]
	mov	DWORD PTR __Tmp$234329[ebp], eax
	mov	ecx, DWORD PTR __Tmp$234329[ebp]
	mov	DWORD PTR $T234278[ebp], ecx
	mov	edx, DWORD PTR $T234278[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], edx

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$234541[ebp], eax
	mov	ecx, 1
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$234541[ebp]
	mov	DWORD PTR __Tmp$234541[ebp], ecx
	mov	edx, DWORD PTR __Tmp$234541[ebp]
	mov	DWORD PTR __Plast$[ebp], edx

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

$LN122@Unguarded_:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	$LN164@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234553[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$234578[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$234578[ebp]
	mov	DWORD PTR __Tmp$234578[ebp], edx
	mov	eax, DWORD PTR __Tmp$234578[ebp]
	mov	DWORD PTR $T234279[ebp], eax
	mov	ecx, DWORD PTR $T234279[ebp]
	mov	DWORD PTR $T234587[ebp], ecx
	mov	edx, DWORD PTR $T234587[ebp]
	mov	eax, DWORD PTR $T234553[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN164@Unguarded_
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$234615[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$234615[ebp]
	mov	DWORD PTR __Tmp$234615[ebp], edx
	mov	eax, DWORD PTR __Tmp$234615[ebp]
	mov	DWORD PTR $T234280[ebp], eax
	mov	ecx, DWORD PTR $T234280[ebp]
	mov	DWORD PTR $T234624[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234633[ebp], edx
	mov	eax, DWORD PTR $T234633[ebp]
	mov	ecx, DWORD PTR $T234624[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN164@Unguarded_

; 3033 : 		--_Pfirst;

	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], edx
	jmp	$LN122@Unguarded_

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

$LN164@Unguarded_:
	mov	eax, DWORD PTR __Plast$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234656[ebp], eax
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T234665[ebp], ecx
	mov	edx, DWORD PTR $T234665[ebp]
	mov	eax, DWORD PTR $T234656[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T234677[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234686[ebp], edx
	mov	eax, DWORD PTR $T234686[ebp]
	mov	ecx, DWORD PTR $T234677[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], edx
	jmp	SHORT $LN164@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], eax

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], ecx
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN194@Unguarded_
$LN20@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Gfirst$[ebp], edx
$LN194@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T234717[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234726[ebp], ecx
	mov	edx, DWORD PTR $T234726[ebp]
	mov	eax, DWORD PTR $T234717[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN208@Unguarded_
	jmp	$LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN208@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234738[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T234747[ebp], edx
	mov	eax, DWORD PTR $T234747[ebp]
	mov	ecx, DWORD PTR $T234738[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Tmp$234761[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$234761[ebp]
	mov	DWORD PTR $T234281[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T234796[ebp], edx
	mov	eax, DWORD PTR $T234281[ebp]
	mov	DWORD PTR $T234795[ebp], eax
	mov	ecx, DWORD PTR $T234796[ebp]
	mov	DWORD PTR $T234776[ebp], ecx
	mov	edx, DWORD PTR $T234776[ebp]
	push	edx
	mov	eax, DWORD PTR $T234795[ebp]
	push	eax
	call	??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z ; std::swap<CvContinent>
	add	esp, 8
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN236@Unguarded_
$LN13@Unguarded_:
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Glast$[ebp], ecx
$LN236@Unguarded_:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Glast$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN299@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234816[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$234834[ebp], eax
	mov	ecx, 1
	neg	ecx
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$234834[ebp]
	mov	DWORD PTR __Tmp$234834[ebp], ecx
	mov	edx, DWORD PTR __Tmp$234834[ebp]
	mov	DWORD PTR $T234282[ebp], edx
	mov	eax, DWORD PTR $T234282[ebp]
	mov	DWORD PTR $T234850[ebp], eax
	mov	ecx, DWORD PTR $T234850[ebp]
	mov	edx, DWORD PTR $T234816[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN11@Unguarded_
	jmp	$LN10@Unguarded_
$LN11@Unguarded_:

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	mov	eax, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$234871[ebp], eax
	mov	ecx, 1
	neg	ecx
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$234871[ebp]
	mov	DWORD PTR __Tmp$234871[ebp], ecx
	mov	edx, DWORD PTR __Tmp$234871[ebp]
	mov	DWORD PTR $T234283[ebp], edx
	mov	eax, DWORD PTR $T234283[ebp]
	mov	DWORD PTR $T234887[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234896[ebp], ecx
	mov	edx, DWORD PTR $T234896[ebp]
	mov	eax, DWORD PTR $T234887[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	$LN299@Unguarded_

; 3056 : 			else

	jmp	$LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$234917[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$234917[ebp]
	mov	DWORD PTR __Tmp$234917[ebp], edx
	mov	eax, DWORD PTR __Tmp$234917[ebp]
	mov	DWORD PTR $T234284[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR $T234284[ebp]
	mov	DWORD PTR $T234972[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T234971[ebp], eax
	mov	ecx, DWORD PTR $T234972[ebp]
	mov	DWORD PTR $T234942[ebp], ecx
	mov	edx, DWORD PTR $T234971[ebp]
	mov	DWORD PTR $T234956[ebp], edx
	mov	eax, DWORD PTR $T234956[ebp]
	cmp	eax, DWORD PTR $T234942[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T234956[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$234970[ebp]
	call	??0CvContinent@@QAE@ABV0@@Z		; CvContinent::CvContinent
	mov	edx, DWORD PTR $T234942[ebp]
	mov	eax, DWORD PTR $T234956[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T234942[ebp]
	mov	ecx, DWORD PTR __Tmp$234970[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$234970[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$234970[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$234970[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

$LN299@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __First$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN305@Unguarded_
	mov	eax, DWORD PTR __Gfirst$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN305@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)

$LN305@Unguarded_:
	mov	ecx, DWORD PTR __Glast$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __First$[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN355@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T235032[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235031[ebp], eax
	mov	ecx, DWORD PTR $T235032[ebp]
	mov	DWORD PTR $T235002[ebp], ecx
	mov	edx, DWORD PTR $T235031[ebp]
	mov	DWORD PTR $T235016[ebp], edx
	mov	eax, DWORD PTR $T235016[ebp]
	cmp	eax, DWORD PTR $T235002[ebp]
	je	SHORT $LN5@Unguarded_
	mov	ecx, DWORD PTR $T235016[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$235029[ebp]
	call	??0CvContinent@@QAE@ABV0@@Z		; CvContinent::CvContinent
	mov	edx, DWORD PTR $T235002[ebp]
	mov	eax, DWORD PTR $T235016[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T235002[ebp]
	mov	ecx, DWORD PTR __Tmp$235029[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$235029[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$235029[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$235029[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	eax, DWORD PTR __Plast$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], eax

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$235051[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR __Tmp$235051[ebp]
	mov	DWORD PTR $T234285[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$235067[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Tmp$235067[ebp]
	mov	DWORD PTR $T234286[ebp], eax
	mov	ecx, DWORD PTR $T234285[ebp]
	mov	DWORD PTR $T235119[ebp], ecx
	mov	edx, DWORD PTR $T234286[ebp]
	mov	DWORD PTR $T235118[ebp], edx
	mov	eax, DWORD PTR $T235119[ebp]
	mov	DWORD PTR $T235082[ebp], eax
	mov	ecx, DWORD PTR $T235118[ebp]
	mov	DWORD PTR $T235101[ebp], ecx
	mov	edx, DWORD PTR $T235101[ebp]
	cmp	edx, DWORD PTR $T235082[ebp]
	je	$LN340@Unguarded_
	mov	eax, DWORD PTR $T235101[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$235114[ebp], ecx
	mov	edx, DWORD PTR $T235101[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$235114[ebp+8], eax
	mov	ecx, DWORD PTR $T235101[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$235114[ebp+4], edx
	mov	eax, DWORD PTR $T235101[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$235114[ebp+12], ecx
	mov	edx, DWORD PTR $T235082[ebp]
	mov	eax, DWORD PTR $T235101[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T235082[ebp]
	mov	ecx, DWORD PTR __Tmp$235114[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$235114[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$235114[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$235114[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN340@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN355@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235193[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T235192[ebp], ecx
	mov	edx, DWORD PTR $T235193[ebp]
	mov	DWORD PTR $T235156[ebp], edx
	mov	eax, DWORD PTR $T235192[ebp]
	mov	DWORD PTR $T235175[ebp], eax
	mov	ecx, DWORD PTR $T235175[ebp]
	cmp	ecx, DWORD PTR $T235156[ebp]
	je	$LN2@Unguarded_
	mov	edx, DWORD PTR $T235175[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$235188[ebp], eax
	mov	ecx, DWORD PTR $T235175[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$235188[ebp+8], edx
	mov	eax, DWORD PTR $T235175[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$235188[ebp+4], ecx
	mov	edx, DWORD PTR $T235175[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$235188[ebp+12], eax
	mov	ecx, DWORD PTR $T235156[ebp]
	mov	edx, DWORD PTR $T235175[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T235156[ebp]
	mov	eax, DWORD PTR __Tmp$235188[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$235188[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$235188[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$235188[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T235248[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235247[ebp], ecx
	mov	edx, DWORD PTR $T235248[ebp]
	mov	DWORD PTR $T235211[ebp], edx
	mov	eax, DWORD PTR $T235247[ebp]
	mov	DWORD PTR $T235230[ebp], eax
	mov	ecx, DWORD PTR $T235230[ebp]
	cmp	ecx, DWORD PTR $T235211[ebp]
	je	$LN388@Unguarded_
	mov	edx, DWORD PTR $T235230[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$235243[ebp], eax
	mov	ecx, DWORD PTR $T235230[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$235243[ebp+8], edx
	mov	eax, DWORD PTR $T235230[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$235243[ebp+4], ecx
	mov	edx, DWORD PTR $T235230[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$235243[ebp+12], eax
	mov	ecx, DWORD PTR $T235211[ebp]
	mov	edx, DWORD PTR $T235230[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T235211[ebp]
	mov	eax, DWORD PTR __Tmp$235243[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$235243[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$235243[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$235243[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN388@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	$LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$235267[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Gfirst$[ebp], ecx
	mov	edx, DWORD PTR __Tmp$235267[ebp]
	mov	DWORD PTR $T234287[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T235319[ebp], eax
	mov	ecx, DWORD PTR $T234287[ebp]
	mov	DWORD PTR $T235318[ebp], ecx
	mov	edx, DWORD PTR $T235319[ebp]
	mov	DWORD PTR $T235282[ebp], edx
	mov	eax, DWORD PTR $T235318[ebp]
	mov	DWORD PTR $T235301[ebp], eax
	mov	ecx, DWORD PTR $T235301[ebp]
	cmp	ecx, DWORD PTR $T235282[ebp]
	je	$LN4@Unguarded_
	mov	edx, DWORD PTR $T235301[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$235314[ebp], eax
	mov	ecx, DWORD PTR $T235301[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$235314[ebp+8], edx
	mov	eax, DWORD PTR $T235301[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$235314[ebp+4], ecx
	mov	edx, DWORD PTR $T235301[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$235314[ebp+12], eax
	mov	ecx, DWORD PTR $T235282[ebp]
	mov	edx, DWORD PTR $T235301[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T235282[ebp]
	mov	eax, DWORD PTR __Tmp$235314[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$235314[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$235314[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$235314[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvstartpositioner.h
_TEXT	ENDS
;	COMDAT ??0CvContinent@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
??0CvContinent@@QAE@ABV0@@Z PROC			; CvContinent::CvContinent, COMDAT
; _this$ = ecx

; 32   : 	CvContinent(const CvContinent& source)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 	{
; 34   : 		m_uiFertility = source.m_uiFertility;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 		m_iRegionsAssigned = source.m_iRegionsAssigned;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 36   : 		m_uiFertilityNextRegion = source.m_uiFertilityNextRegion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 37   : 		m_iAreaID = source.m_iAreaID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 38   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CvContinent@@QAE@ABV0@@Z ENDP			; CvContinent::CvContinent
_TEXT	ENDS
PUBLIC	??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ; std::swap<CvStartRegion>
PUBLIC	??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
$T236349 = -540						; size = 4
$T236348 = -536						; size = 4
$T236333 = -532						; size = 4
__Tmp$236346 = -528					; size = 32
$T236315 = -496						; size = 4
__Tmp$236300 = -492					; size = 4
$T236281 = -488						; size = 4
$T236280 = -484						; size = 4
$T236265 = -480						; size = 4
__Tmp$236278 = -476					; size = 32
$T236247 = -444						; size = 4
$T236229 = -440						; size = 4
$T236228 = -436						; size = 4
$T236213 = -432						; size = 4
__Tmp$236226 = -428					; size = 32
$T236195 = -396						; size = 4
$T236158 = -392						; size = 4
$T236157 = -388						; size = 4
$T236142 = -384						; size = 4
__Tmp$236156 = -380					; size = 32
$T236128 = -348						; size = 4
__Tmp$236113 = -344					; size = 4
__Tmp$236097 = -340					; size = 4
$T236078 = -336						; size = 4
$T236077 = -332						; size = 4
$T236062 = -328						; size = 4
__Tmp$236076 = -324					; size = 32
$T236048 = -292						; size = 4
$T236018 = -288						; size = 4
$T236017 = -284						; size = 4
$T236002 = -280						; size = 4
__Tmp$236016 = -276					; size = 32
$T235988 = -244						; size = 4
__Tmp$235963 = -240					; size = 4
$T235942 = -236						; size = 4
$T235933 = -232						; size = 4
__Tmp$235917 = -228					; size = 4
$T235896 = -224						; size = 4
__Tmp$235880 = -220					; size = 4
$T235862 = -216						; size = 4
$T235842 = -212						; size = 4
$T235841 = -208						; size = 4
$T235822 = -204						; size = 4
__Tmp$235807 = -200					; size = 4
$T235793 = -196						; size = 4
$T235784 = -192						; size = 4
$T235772 = -188						; size = 4
$T235763 = -184						; size = 4
$T235732 = -180						; size = 4
$T235723 = -176						; size = 4
$T235711 = -172						; size = 4
$T235702 = -168						; size = 4
$T235679 = -164						; size = 4
$T235670 = -160						; size = 4
__Tmp$235661 = -156					; size = 4
$T235633 = -152						; size = 4
__Tmp$235624 = -148					; size = 4
$T235599 = -144						; size = 4
__Tmp$235587 = -140					; size = 4
__Tmp$235375 = -68					; size = 4
__Tmp$235352 = -64					; size = 4
$T235333 = -60						; size = 4
$T235332 = -56						; size = 4
$T235331 = -52						; size = 4
$T235330 = -48						; size = 4
$T235329 = -44						; size = 4
$T235328 = -40						; size = 4
$T235327 = -36						; size = 4
$T235326 = -32						; size = 4
$T235325 = -28						; size = 4
$T235324 = -24						; size = 4
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 540				; 0000021cH
	push	esi
	push	edi

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$235352[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	cdq
	sub	eax, edx
	sar	eax, 1
	shl	eax, 5
	add	eax, DWORD PTR __Tmp$235352[ebp]
	mov	DWORD PTR __Tmp$235352[ebp], eax
	mov	ecx, DWORD PTR __Tmp$235352[ebp]
	mov	DWORD PTR __Mid$[ebp], ecx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$235375[ebp], edx
	mov	eax, 1
	neg	eax
	shl	eax, 5
	add	eax, DWORD PTR __Tmp$235375[ebp]
	mov	DWORD PTR __Tmp$235375[ebp], eax
	mov	ecx, DWORD PTR __Tmp$235375[ebp]
	mov	DWORD PTR $T235324[ebp], ecx
	mov	edx, DWORD PTR $T235324[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], edx

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$235587[ebp], eax
	mov	ecx, 1
	shl	ecx, 5
	add	ecx, DWORD PTR __Tmp$235587[ebp]
	mov	DWORD PTR __Tmp$235587[ebp], ecx
	mov	edx, DWORD PTR __Tmp$235587[ebp]
	mov	DWORD PTR __Plast$[ebp], edx

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

$LN122@Unguarded_@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	$LN164@Unguarded_@2
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235599[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$235624[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$235624[ebp]
	mov	DWORD PTR __Tmp$235624[ebp], edx
	mov	eax, DWORD PTR __Tmp$235624[ebp]
	mov	DWORD PTR $T235325[ebp], eax
	mov	ecx, DWORD PTR $T235325[ebp]
	mov	DWORD PTR $T235633[ebp], ecx
	mov	edx, DWORD PTR $T235599[ebp]
	mov	ecx, DWORD PTR [edx+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235599[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235633[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235633[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN164@Unguarded_@2
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$235661[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$235661[ebp]
	mov	DWORD PTR __Tmp$235661[ebp], edx
	mov	eax, DWORD PTR __Tmp$235661[ebp]
	mov	DWORD PTR $T235326[ebp], eax
	mov	ecx, DWORD PTR $T235326[ebp]
	mov	DWORD PTR $T235670[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235679[ebp], edx
	mov	eax, DWORD PTR $T235670[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235670[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235679[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235679[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN164@Unguarded_@2

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	$LN122@Unguarded_@2

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

$LN164@Unguarded_@2:
	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN24@Unguarded_@2
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235702[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T235711[ebp], eax
	mov	ecx, DWORD PTR $T235702[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235702[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235711[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235711[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_@2
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T235723[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235732[ebp], edx
	mov	eax, DWORD PTR $T235723[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235723[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235732[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235732[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_@2

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	$LN164@Unguarded_@2
$LN24@Unguarded_@2:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_@2:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN194@Unguarded_@2
$LN20@Unguarded_@2:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN194@Unguarded_@2:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@Unguarded_@2

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T235763[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235772[ebp], eax
	mov	ecx, DWORD PTR $T235763[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235763[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235772[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235772[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN208@Unguarded_@2
	jmp	$LN17@Unguarded_@2

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN208@Unguarded_@2:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235784[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T235793[ebp], edx
	mov	eax, DWORD PTR $T235784[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235784[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235793[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235793[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_@2

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_@2

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_@2
$LN16@Unguarded_@2:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Tmp$235807[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Tmp$235807[ebp]
	mov	DWORD PTR $T235327[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T235842[ebp], ecx
	mov	edx, DWORD PTR $T235327[ebp]
	mov	DWORD PTR $T235841[ebp], edx
	mov	eax, DWORD PTR $T235842[ebp]
	mov	DWORD PTR $T235822[ebp], eax
	mov	ecx, DWORD PTR $T235822[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235841[ebp]
	push	edx
	call	??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ; std::swap<CvStartRegion>
	add	esp, 8
$LN17@Unguarded_@2:
	jmp	$LN20@Unguarded_@2
$LN19@Unguarded_@2:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN236@Unguarded_@2
$LN13@Unguarded_@2:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR __Glast$[ebp], eax
$LN236@Unguarded_@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN299@Unguarded_@2

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235862[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$235880[ebp], edx
	mov	eax, 1
	neg	eax
	shl	eax, 5
	add	eax, DWORD PTR __Tmp$235880[ebp]
	mov	DWORD PTR __Tmp$235880[ebp], eax
	mov	ecx, DWORD PTR __Tmp$235880[ebp]
	mov	DWORD PTR $T235328[ebp], ecx
	mov	edx, DWORD PTR $T235328[ebp]
	mov	DWORD PTR $T235896[ebp], edx
	mov	eax, DWORD PTR $T235862[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235862[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235896[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235896[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN11@Unguarded_@2
	jmp	$LN10@Unguarded_@2
$LN11@Unguarded_@2:

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$235917[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$235917[ebp]
	mov	DWORD PTR __Tmp$235917[ebp], edx
	mov	eax, DWORD PTR __Tmp$235917[ebp]
	mov	DWORD PTR $T235329[ebp], eax
	mov	ecx, DWORD PTR $T235329[ebp]
	mov	DWORD PTR $T235933[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T235942[ebp], edx
	mov	eax, DWORD PTR $T235933[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T235933[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T235942[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T235942[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN9@Unguarded_@2

; 3055 : 				break;

	jmp	$LN299@Unguarded_@2

; 3056 : 			else

	jmp	$LN10@Unguarded_@2
$LN9@Unguarded_@2:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$235963[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$235963[ebp]
	mov	DWORD PTR __Tmp$235963[ebp], edx
	mov	eax, DWORD PTR __Tmp$235963[ebp]
	mov	DWORD PTR $T235330[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR $T235330[ebp]
	mov	DWORD PTR $T236018[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236017[ebp], eax
	mov	ecx, DWORD PTR $T236018[ebp]
	mov	DWORD PTR $T235988[ebp], ecx
	mov	edx, DWORD PTR $T236017[ebp]
	mov	DWORD PTR $T236002[ebp], edx
	mov	eax, DWORD PTR $T236002[ebp]
	cmp	eax, DWORD PTR $T235988[ebp]
	je	SHORT $LN10@Unguarded_@2
	mov	ecx, DWORD PTR $T236002[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$236016[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T235988[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T236002[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$236016[ebp]
	mov	edi, DWORD PTR $T235988[ebp]
	rep movsd
$LN10@Unguarded_@2:
	jmp	$LN13@Unguarded_@2

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

$LN299@Unguarded_@2:
	mov	edx, DWORD PTR __Glast$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __First$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN305@Unguarded_@2
	mov	edx, DWORD PTR __Gfirst$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN305@Unguarded_@2

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_@2

; 3060 : 
; 3061 : 		if (_Glast == _First)

$LN305@Unguarded_@2:
	mov	eax, DWORD PTR __Glast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __First$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN353@Unguarded_@2

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	eax, DWORD PTR __Plast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Unguarded_@2

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T236078[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236077[ebp], edx
	mov	eax, DWORD PTR $T236078[ebp]
	mov	DWORD PTR $T236048[ebp], eax
	mov	ecx, DWORD PTR $T236077[ebp]
	mov	DWORD PTR $T236062[ebp], ecx
	mov	edx, DWORD PTR $T236062[ebp]
	cmp	edx, DWORD PTR $T236048[ebp]
	je	SHORT $LN5@Unguarded_@2
	mov	eax, DWORD PTR $T236062[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$236076[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T236048[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T236062[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$236076[ebp]
	mov	edi, DWORD PTR $T236048[ebp]
	rep movsd
$LN5@Unguarded_@2:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$236097[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Gfirst$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$236097[ebp]
	mov	DWORD PTR $T235331[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$236113[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$236113[ebp]
	mov	DWORD PTR $T235332[ebp], ecx
	mov	edx, DWORD PTR $T235331[ebp]
	mov	DWORD PTR $T236158[ebp], edx
	mov	eax, DWORD PTR $T235332[ebp]
	mov	DWORD PTR $T236157[ebp], eax
	mov	ecx, DWORD PTR $T236158[ebp]
	mov	DWORD PTR $T236128[ebp], ecx
	mov	edx, DWORD PTR $T236157[ebp]
	mov	DWORD PTR $T236142[ebp], edx
	mov	eax, DWORD PTR $T236142[ebp]
	cmp	eax, DWORD PTR $T236128[ebp]
	je	SHORT $LN340@Unguarded_@2
	mov	ecx, DWORD PTR $T236142[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$236156[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T236128[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T236142[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$236156[ebp]
	mov	edi, DWORD PTR $T236128[ebp]
	rep movsd
$LN340@Unguarded_@2:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_@2
$LN353@Unguarded_@2:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@Unguarded_@2

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR __Glast$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Pfirst$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Unguarded_@2

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236229[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T236228[ebp], eax
	mov	ecx, DWORD PTR $T236229[ebp]
	mov	DWORD PTR $T236195[ebp], ecx
	mov	edx, DWORD PTR $T236228[ebp]
	mov	DWORD PTR $T236213[ebp], edx
	mov	eax, DWORD PTR $T236213[ebp]
	cmp	eax, DWORD PTR $T236195[ebp]
	je	SHORT $LN2@Unguarded_@2
	mov	ecx, DWORD PTR $T236213[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$236226[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T236195[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T236213[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$236226[ebp]
	mov	edi, DWORD PTR $T236195[ebp]
	rep movsd
$LN2@Unguarded_@2:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T236281[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236280[ebp], ecx
	mov	edx, DWORD PTR $T236281[ebp]
	mov	DWORD PTR $T236247[ebp], edx
	mov	eax, DWORD PTR $T236280[ebp]
	mov	DWORD PTR $T236265[ebp], eax
	mov	ecx, DWORD PTR $T236265[ebp]
	cmp	ecx, DWORD PTR $T236247[ebp]
	je	SHORT $LN388@Unguarded_@2
	mov	edx, DWORD PTR $T236265[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$236278[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T236247[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T236265[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$236278[ebp]
	mov	edi, DWORD PTR $T236247[ebp]
	rep movsd
$LN388@Unguarded_@2:

; 3073 : 			}
; 3074 : 		else

	jmp	$LN4@Unguarded_@2
$LN3@Unguarded_@2:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR __Glast$[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$236300[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR __Tmp$236300[ebp]
	mov	DWORD PTR $T235333[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T236349[ebp], ecx
	mov	edx, DWORD PTR $T235333[ebp]
	mov	DWORD PTR $T236348[ebp], edx
	mov	eax, DWORD PTR $T236349[ebp]
	mov	DWORD PTR $T236315[ebp], eax
	mov	ecx, DWORD PTR $T236348[ebp]
	mov	DWORD PTR $T236333[ebp], ecx
	mov	edx, DWORD PTR $T236333[ebp]
	cmp	edx, DWORD PTR $T236315[ebp]
	je	SHORT $LN4@Unguarded_@2
	mov	eax, DWORD PTR $T236333[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$236346[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T236315[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T236333[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$236346[ebp]
	mov	edi, DWORD PTR $T236315[ebp]
	rep movsd
$LN4@Unguarded_@2:

; 3076 : 		}

	jmp	$LN23@Unguarded_@2
$LN28@Unguarded_@2:

; 3077 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z ; std::swap<CvPlayerStartRank>
PUBLIC	??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
$T237407 = -396						; size = 4
$T237406 = -392						; size = 4
$T237389 = -388						; size = 4
__Tmp$237402 = -384					; size = 8
$T237370 = -376						; size = 4
__Tmp$237355 = -372					; size = 4
$T237336 = -368						; size = 4
$T237335 = -364						; size = 4
$T237318 = -360						; size = 4
__Tmp$237331 = -356					; size = 8
$T237299 = -348						; size = 4
$T237281 = -344						; size = 4
$T237280 = -340						; size = 4
$T237263 = -336						; size = 4
__Tmp$237279 = -332					; size = 8
$T237244 = -324						; size = 4
$T237207 = -320						; size = 4
$T237206 = -316						; size = 4
$T237189 = -312						; size = 4
__Tmp$237205 = -308					; size = 8
$T237170 = -300						; size = 4
__Tmp$237155 = -296					; size = 4
__Tmp$237139 = -292					; size = 4
$T237120 = -288						; size = 4
$T237119 = -284						; size = 4
$T237102 = -280						; size = 4
__Tmp$237118 = -276					; size = 8
$T237083 = -268						; size = 4
$T237053 = -264						; size = 4
$T237052 = -260						; size = 4
$T237035 = -256						; size = 4
__Tmp$237051 = -252					; size = 8
$T237016 = -244						; size = 4
__Tmp$236991 = -240					; size = 4
$T236970 = -236						; size = 4
$T236961 = -232						; size = 4
__Tmp$236945 = -228					; size = 4
$T236924 = -224						; size = 4
__Tmp$236908 = -220					; size = 4
$T236890 = -216						; size = 4
$T236870 = -212						; size = 4
$T236869 = -208						; size = 4
$T236850 = -204						; size = 4
__Tmp$236835 = -200					; size = 4
$T236821 = -196						; size = 4
$T236812 = -192						; size = 4
$T236800 = -188						; size = 4
$T236791 = -184						; size = 4
$T236760 = -180						; size = 4
$T236751 = -176						; size = 4
$T236739 = -172						; size = 4
$T236730 = -168						; size = 4
$T236707 = -164						; size = 4
$T236698 = -160						; size = 4
__Tmp$236682 = -156					; size = 4
$T236661 = -152						; size = 4
__Tmp$236652 = -148					; size = 4
$T236627 = -144						; size = 4
__Tmp$236615 = -140					; size = 4
__Tmp$236403 = -68					; size = 4
__Tmp$236380 = -64					; size = 4
$T236361 = -60						; size = 4
$T236360 = -56						; size = 4
$T236359 = -52						; size = 4
$T236358 = -48						; size = 4
$T236357 = -44						; size = 4
$T236356 = -40						; size = 4
$T236355 = -36						; size = 4
$T236354 = -32						; size = 4
$T236353 = -28						; size = 4
$T236352 = -24						; size = 4
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$236380[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __Tmp$236380[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$236380[ebp], edx
	mov	eax, DWORD PTR __Tmp$236380[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$236403[ebp], ecx
	mov	edx, 1
	neg	edx
	mov	eax, DWORD PTR __Tmp$236403[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$236403[ebp], ecx
	mov	edx, DWORD PTR __Tmp$236403[ebp]
	mov	DWORD PTR $T236352[ebp], edx
	mov	eax, DWORD PTR $T236352[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$236615[ebp], ecx
	mov	edx, 1
	shl	edx, 3
	add	edx, DWORD PTR __Tmp$236615[ebp]
	mov	DWORD PTR __Tmp$236615[ebp], edx
	mov	eax, DWORD PTR __Tmp$236615[ebp]
	mov	DWORD PTR __Plast$[ebp], eax

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

$LN122@Unguarded_@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Pfirst$[ebp]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN164@Unguarded_@3
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236627[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$236652[ebp], edx
	mov	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$236652[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$236652[ebp], edx
	mov	eax, DWORD PTR __Tmp$236652[ebp]
	mov	DWORD PTR $T236353[ebp], eax
	mov	ecx, DWORD PTR $T236353[ebp]
	mov	DWORD PTR $T236661[ebp], ecx
	mov	edx, DWORD PTR $T236661[ebp]
	mov	eax, DWORD PTR $T236627[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN164@Unguarded_@3
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$236682[ebp], ecx
	mov	edx, 1
	neg	edx
	mov	eax, DWORD PTR __Tmp$236682[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$236682[ebp], ecx
	mov	edx, DWORD PTR __Tmp$236682[ebp]
	mov	DWORD PTR $T236354[ebp], edx
	mov	eax, DWORD PTR $T236354[ebp]
	mov	DWORD PTR $T236698[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236707[ebp], ecx
	mov	edx, DWORD PTR $T236707[ebp]
	mov	eax, DWORD PTR $T236698[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN164@Unguarded_@3

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	$LN122@Unguarded_@3

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

$LN164@Unguarded_@3:
	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@Unguarded_@3
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236730[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T236739[ebp], eax
	mov	ecx, DWORD PTR $T236739[ebp]
	mov	edx, DWORD PTR $T236730[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN24@Unguarded_@3
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T236751[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236760[ebp], ecx
	mov	edx, DWORD PTR $T236760[ebp]
	mov	eax, DWORD PTR $T236751[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_@3

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN164@Unguarded_@3
$LN24@Unguarded_@3:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_@3:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN194@Unguarded_@3
$LN20@Unguarded_@3:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN194@Unguarded_@3:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN19@Unguarded_@3

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T236791[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236800[ebp], eax
	mov	ecx, DWORD PTR $T236800[ebp]
	mov	edx, DWORD PTR $T236791[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN208@Unguarded_@3
	jmp	$LN17@Unguarded_@3

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN208@Unguarded_@3:
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236812[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T236821[ebp], ecx
	mov	edx, DWORD PTR $T236821[ebp]
	mov	eax, DWORD PTR $T236812[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_@3

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_@3

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_@3
$LN16@Unguarded_@3:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Tmp$236835[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Tmp$236835[ebp]
	mov	DWORD PTR $T236355[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T236870[ebp], ecx
	mov	edx, DWORD PTR $T236355[ebp]
	mov	DWORD PTR $T236869[ebp], edx
	mov	eax, DWORD PTR $T236870[ebp]
	mov	DWORD PTR $T236850[ebp], eax
	mov	ecx, DWORD PTR $T236850[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236869[ebp]
	push	edx
	call	??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z ; std::swap<CvPlayerStartRank>
	add	esp, 8
$LN17@Unguarded_@3:
	jmp	$LN20@Unguarded_@3
$LN19@Unguarded_@3:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN236@Unguarded_@3
$LN13@Unguarded_@3:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN236@Unguarded_@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN301@Unguarded_@3

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236890[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$236908[ebp], edx
	mov	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$236908[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$236908[ebp], edx
	mov	eax, DWORD PTR __Tmp$236908[ebp]
	mov	DWORD PTR $T236356[ebp], eax
	mov	ecx, DWORD PTR $T236356[ebp]
	mov	DWORD PTR $T236924[ebp], ecx
	mov	edx, DWORD PTR $T236924[ebp]
	mov	eax, DWORD PTR $T236890[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN11@Unguarded_@3
	jmp	$LN10@Unguarded_@3
$LN11@Unguarded_@3:

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$236945[ebp], ecx
	mov	edx, 1
	neg	edx
	mov	eax, DWORD PTR __Tmp$236945[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$236945[ebp], ecx
	mov	edx, DWORD PTR __Tmp$236945[ebp]
	mov	DWORD PTR $T236357[ebp], edx
	mov	eax, DWORD PTR $T236357[ebp]
	mov	DWORD PTR $T236961[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T236970[ebp], ecx
	mov	edx, DWORD PTR $T236970[ebp]
	mov	eax, DWORD PTR $T236961[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN9@Unguarded_@3

; 3055 : 				break;

	jmp	$LN301@Unguarded_@3

; 3056 : 			else

	jmp	$LN10@Unguarded_@3
$LN9@Unguarded_@3:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR __Tmp$236991[ebp], ecx
	mov	edx, 1
	neg	edx
	mov	eax, DWORD PTR __Tmp$236991[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$236991[ebp], ecx
	mov	edx, DWORD PTR __Tmp$236991[ebp]
	mov	DWORD PTR $T236358[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR $T236358[ebp]
	mov	DWORD PTR $T237053[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237052[ebp], edx
	mov	eax, DWORD PTR $T237053[ebp]
	mov	DWORD PTR $T237016[ebp], eax
	mov	ecx, DWORD PTR $T237052[ebp]
	mov	DWORD PTR $T237035[ebp], ecx
	mov	edx, DWORD PTR $T237035[ebp]
	cmp	edx, DWORD PTR $T237016[ebp]
	je	SHORT $LN10@Unguarded_@3
	mov	eax, DWORD PTR $T237035[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$237051[ebp], ecx
	mov	edx, DWORD PTR $T237035[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$237051[ebp+4], eax
	mov	ecx, DWORD PTR $T237016[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T237035[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T237016[ebp]
	mov	eax, DWORD PTR __Tmp$237051[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$237051[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN10@Unguarded_@3:
	jmp	$LN13@Unguarded_@3

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

$LN301@Unguarded_@3:
	mov	edx, DWORD PTR __Glast$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __First$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN307@Unguarded_@3
	mov	edx, DWORD PTR __Gfirst$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN307@Unguarded_@3

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_@3

; 3060 : 
; 3061 : 		if (_Glast == _First)

$LN307@Unguarded_@3:
	mov	eax, DWORD PTR __Glast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __First$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN359@Unguarded_@3

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	eax, DWORD PTR __Plast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN5@Unguarded_@3

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T237120[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237119[ebp], edx
	mov	eax, DWORD PTR $T237120[ebp]
	mov	DWORD PTR $T237083[ebp], eax
	mov	ecx, DWORD PTR $T237119[ebp]
	mov	DWORD PTR $T237102[ebp], ecx
	mov	edx, DWORD PTR $T237102[ebp]
	cmp	edx, DWORD PTR $T237083[ebp]
	je	SHORT $LN5@Unguarded_@3
	mov	eax, DWORD PTR $T237102[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$237118[ebp], ecx
	mov	edx, DWORD PTR $T237102[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$237118[ebp+4], eax
	mov	ecx, DWORD PTR $T237083[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T237102[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T237083[ebp]
	mov	eax, DWORD PTR __Tmp$237118[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$237118[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN5@Unguarded_@3:

; 3065 : 			++_Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$237139[ebp], eax
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
	mov	edx, DWORD PTR __Tmp$237139[ebp]
	mov	DWORD PTR $T236359[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Tmp$237155[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Tmp$237155[ebp]
	mov	DWORD PTR $T236360[ebp], edx
	mov	eax, DWORD PTR $T236359[ebp]
	mov	DWORD PTR $T237207[ebp], eax
	mov	ecx, DWORD PTR $T236360[ebp]
	mov	DWORD PTR $T237206[ebp], ecx
	mov	edx, DWORD PTR $T237207[ebp]
	mov	DWORD PTR $T237170[ebp], edx
	mov	eax, DWORD PTR $T237206[ebp]
	mov	DWORD PTR $T237189[ebp], eax
	mov	ecx, DWORD PTR $T237189[ebp]
	cmp	ecx, DWORD PTR $T237170[ebp]
	je	SHORT $LN344@Unguarded_@3
	mov	edx, DWORD PTR $T237189[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$237205[ebp], eax
	mov	ecx, DWORD PTR $T237189[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237205[ebp+4], edx
	mov	eax, DWORD PTR $T237170[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T237189[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T237170[ebp]
	mov	edx, DWORD PTR __Tmp$237205[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$237205[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN344@Unguarded_@3:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_@3
$LN359@Unguarded_@3:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last$[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN3@Unguarded_@3

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN2@Unguarded_@3

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237281[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T237280[ebp], edx
	mov	eax, DWORD PTR $T237281[ebp]
	mov	DWORD PTR $T237244[ebp], eax
	mov	ecx, DWORD PTR $T237280[ebp]
	mov	DWORD PTR $T237263[ebp], ecx
	mov	edx, DWORD PTR $T237263[ebp]
	cmp	edx, DWORD PTR $T237244[ebp]
	je	SHORT $LN2@Unguarded_@3
	mov	eax, DWORD PTR $T237263[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$237279[ebp], ecx
	mov	edx, DWORD PTR $T237263[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$237279[ebp+4], eax
	mov	ecx, DWORD PTR $T237244[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T237263[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T237244[ebp]
	mov	eax, DWORD PTR __Tmp$237279[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$237279[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_@3:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T237336[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T237335[ebp], ecx
	mov	edx, DWORD PTR $T237336[ebp]
	mov	DWORD PTR $T237299[ebp], edx
	mov	eax, DWORD PTR $T237335[ebp]
	mov	DWORD PTR $T237318[ebp], eax
	mov	ecx, DWORD PTR $T237318[ebp]
	cmp	ecx, DWORD PTR $T237299[ebp]
	je	SHORT $LN392@Unguarded_@3
	mov	edx, DWORD PTR $T237318[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$237331[ebp], eax
	mov	ecx, DWORD PTR $T237318[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$237331[ebp+4], edx
	mov	eax, DWORD PTR $T237299[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T237318[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T237299[ebp]
	mov	edx, DWORD PTR __Tmp$237331[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$237331[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN392@Unguarded_@3:

; 3073 : 			}
; 3074 : 		else

	jmp	$LN4@Unguarded_@3
$LN3@Unguarded_@3:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR __Tmp$237355[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	add	eax, 8
	mov	DWORD PTR __Gfirst$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$237355[ebp]
	mov	DWORD PTR $T236361[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR $T237407[ebp], edx
	mov	eax, DWORD PTR $T236361[ebp]
	mov	DWORD PTR $T237406[ebp], eax
	mov	ecx, DWORD PTR $T237407[ebp]
	mov	DWORD PTR $T237370[ebp], ecx
	mov	edx, DWORD PTR $T237406[ebp]
	mov	DWORD PTR $T237389[ebp], edx
	mov	eax, DWORD PTR $T237389[ebp]
	cmp	eax, DWORD PTR $T237370[ebp]
	je	SHORT $LN4@Unguarded_@3
	mov	ecx, DWORD PTR $T237389[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$237402[ebp], edx
	mov	eax, DWORD PTR $T237389[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$237402[ebp+4], ecx
	mov	edx, DWORD PTR $T237370[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T237389[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T237370[ebp]
	mov	ecx, DWORD PTR __Tmp$237402[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$237402[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Unguarded_@3:

; 3076 : 		}

	jmp	$LN23@Unguarded_@3
$LN28@Unguarded_@3:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@V12@@0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z
_TEXT	SEGMENT
tv74 = -16						; size = 4
$T237411 = -12						; size = 4
$T237410 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z PROC ; std::_Construct<CvStartRegion,CvStartRegion>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	mov	DWORD PTR $T237411[ebp], ecx
	cmp	DWORD PTR $T237411[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T237411[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T237411[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T237411[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	al, BYTE PTR [edx+24]
	mov	BYTE PTR [ecx+24], al
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR $T237411[ebp]
	mov	DWORD PTR tv74[ebp], ecx
	jmp	SHORT $LN4@Construct
$LN3@Construct:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Construct:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T237410[ebp], edx

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z ENDP ; std::_Construct<CvStartRegion,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z
_TEXT	SEGMENT
__Tmp$238109 = -308					; size = 4
__Tmp$238091 = -304					; size = 4
__Tmp$237895 = -220					; size = 4
__Tmp$237870 = -216					; size = 4
__Tmp$237688 = -132					; size = 4
__Tmp$237663 = -128					; size = 4
__Tmp$237478 = -44					; size = 4
__Tmp$237462 = -40					; size = 4
$T237435 = -36						; size = 4
$T237434 = -32						; size = 4
$T237433 = -28						; size = 4
$T237432 = -24						; size = 4
$T237431 = -20						; size = 4
$T237430 = -16						; size = 4
$T237429 = -12						; size = 4
$T237428 = -8						; size = 4
__Step$222394 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$222394[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$237462[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	shl	edx, 1
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$237462[ebp]
	mov	DWORD PTR __Tmp$237462[ebp], edx
	mov	eax, DWORD PTR __Tmp$237462[ebp]
	mov	DWORD PTR $T237428[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$237478[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$237478[ebp]
	mov	DWORD PTR __Tmp$237478[ebp], edx
	mov	eax, DWORD PTR __Tmp$237478[ebp]
	mov	DWORD PTR $T237429[ebp], eax
	mov	ecx, DWORD PTR $T237428[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237429[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$237663[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$237663[ebp]
	mov	DWORD PTR __Tmp$237663[ebp], edx
	mov	eax, DWORD PTR __Tmp$237663[ebp]
	mov	DWORD PTR $T237430[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$237688[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$237688[ebp]
	mov	DWORD PTR __Tmp$237688[ebp], edx
	mov	eax, DWORD PTR __Tmp$237688[ebp]
	mov	DWORD PTR $T237431[ebp], eax
	mov	ecx, DWORD PTR $T237430[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T237431[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$237870[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$237870[ebp]
	mov	DWORD PTR __Tmp$237870[ebp], edx
	mov	eax, DWORD PTR __Tmp$237870[ebp]
	mov	DWORD PTR $T237432[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$237895[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	shl	edx, 1
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$237895[ebp]
	mov	DWORD PTR __Tmp$237895[ebp], edx
	mov	eax, DWORD PTR __Tmp$237895[ebp]
	mov	DWORD PTR $T237433[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237432[ebp]
	push	edx
	mov	eax, DWORD PTR $T237433[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$238091[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$238091[ebp]
	mov	DWORD PTR __Tmp$238091[ebp], edx
	mov	eax, DWORD PTR __Tmp$238091[ebp]
	mov	DWORD PTR $T237434[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$238109[ebp], ecx
	mov	edx, DWORD PTR __Step$222394[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$238109[ebp]
	mov	DWORD PTR __Tmp$238109[ebp], edx
	mov	eax, DWORD PTR __Tmp$238109[ebp]
	mov	DWORD PTR $T237435[ebp], eax
	mov	ecx, DWORD PTR $T237434[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T237435[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z
_TEXT	SEGMENT
$T238527 = -28						; size = 4
$T238523 = -24						; size = 4
__Tmp$238509 = -20					; size = 4
$T238490 = -16						; size = 4
__Hole$222420 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z PROC ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$222420[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$222420[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$222420[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$222420[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$238509[ebp], edx
	mov	eax, DWORD PTR __Hole$222420[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Tmp$238509[ebp]
	mov	DWORD PTR __Tmp$238509[ebp], eax
	mov	ecx, DWORD PTR __Tmp$238509[ebp]
	mov	DWORD PTR $T238490[ebp], ecx
	mov	edx, DWORD PTR $T238490[ebp]
	mov	DWORD PTR $T238523[ebp], edx
	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T238527[ebp], esp
	mov	eax, DWORD PTR $T238527[ebp]
	mov	ecx, DWORD PTR $T238523[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T238527[ebp]
	mov	ecx, DWORD PTR $T238523[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T238527[ebp]
	mov	ecx, DWORD PTR $T238523[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T238527[ebp]
	mov	ecx, DWORD PTR $T238523[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR __Bottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Hole$222420[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 28					; 0000001cH

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAHPAVCvContinent@@@Z ENDP ; std::_Make_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z
_TEXT	SEGMENT
$T239013 = -88						; size = 4
$T239001 = -84						; size = 4
$T238976 = -80						; size = 4
$T238975 = -76						; size = 4
$T238974 = -72						; size = 4
$T238938 = -66						; size = 1
$T238937 = -65						; size = 1
$T238936 = -64						; size = 4
$T238935 = -60						; size = 4
$T238934 = -56						; size = 4
$T238893 = -52						; size = 4
__Cat$238945 = -44					; size = 1
$T238942 = -43						; size = 1
$T238941 = -42						; size = 1
$T238940 = -41						; size = 1
$T238844 = -40						; size = 4
$T238835 = -36						; size = 4
$T238799 = -32						; size = 4
__First1$222463 = -28					; size = 4
__Val$222452 = -24					; size = 16
__Next1$222451 = -8					; size = 4
__Next$222447 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$222447[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$222447[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$222447[ebp], edx
	mov	eax, DWORD PTR __Next$222447[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$222447[ebp]
	mov	DWORD PTR __Next1$222451[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$222447[ebp]
	mov	DWORD PTR $T238835[ebp], edx
	mov	eax, DWORD PTR $T238835[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Val$222452[ebp], ecx
	mov	edx, DWORD PTR $T238835[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$222452[ebp+8], eax
	mov	ecx, DWORD PTR $T238835[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$222452[ebp+4], edx
	mov	eax, DWORD PTR $T238835[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Val$222452[ebp+12], ecx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238844[ebp], edx
	mov	eax, DWORD PTR $T238844[ebp]
	mov	ecx, DWORD PTR __Val$222452[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$222451[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next1$222451[ebp], ecx
	mov	edx, DWORD PTR __Next1$222451[ebp]
	mov	DWORD PTR $T238976[ebp], edx
	mov	eax, DWORD PTR __Next$222447[ebp]
	mov	DWORD PTR $T238975[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238974[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238940[ebp], dl
	mov	al, BYTE PTR __Cat$238945[ebp]
	mov	BYTE PTR $T238941[ebp], al
	mov	cl, BYTE PTR $T238940[ebp]
	mov	BYTE PTR $T238938[ebp], cl
	mov	dl, BYTE PTR $T238942[ebp]
	mov	BYTE PTR $T238937[ebp], dl
	mov	eax, DWORD PTR $T238976[ebp]
	mov	DWORD PTR $T238936[ebp], eax
	mov	ecx, DWORD PTR $T238975[ebp]
	mov	DWORD PTR $T238935[ebp], ecx
	mov	edx, DWORD PTR $T238974[ebp]
	mov	DWORD PTR $T238934[ebp], edx
$LN49@Insertion_:
	mov	eax, DWORD PTR $T238934[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T238935[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN45@Insertion_
	mov	ecx, DWORD PTR $T238935[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T238935[ebp], ecx
	mov	edx, DWORD PTR $T238935[ebp]
	mov	DWORD PTR $T238893[ebp], edx
	mov	eax, DWORD PTR $T238936[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T238936[ebp], eax
	mov	ecx, DWORD PTR $T238893[ebp]
	mov	edx, DWORD PTR $T238936[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	jmp	SHORT $LN49@Insertion_
$LN45@Insertion_:
	mov	edx, DWORD PTR $T238936[ebp]
	mov	DWORD PTR $T238799[ebp], edx

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$222452[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$222452[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$222452[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$222452[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$222451[ebp]
	mov	DWORD PTR __First1$222463[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$222463[ebp]
	mov	DWORD PTR __Next1$222451[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$222463[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __First1$222463[ebp], edx
	mov	eax, DWORD PTR __First1$222463[ebp]
	mov	DWORD PTR $T239001[ebp], eax
	mov	ecx, DWORD PTR $T239001[ebp]
	mov	edx, DWORD PTR __Val$222452[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN91@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR __First1$222463[ebp]
	mov	DWORD PTR $T239013[ebp], edx
	mov	eax, DWORD PTR $T239013[ebp]
	mov	ecx, DWORD PTR __Next1$222451[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Insertion_

; 2985 : 				*_Next1 = _Val;	// insert element in hole

$LN91@Insertion_:
	mov	ecx, DWORD PTR __Next1$222451[ebp]
	mov	edx, DWORD PTR __Val$222452[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$222452[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$222452[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$222452[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z
_TEXT	SEGMENT
__Tmp$239715 = -356					; size = 4
__Tmp$239699 = -352					; size = 4
__Tmp$239499 = -252					; size = 4
__Tmp$239474 = -248					; size = 4
__Tmp$239285 = -148					; size = 4
__Tmp$239262 = -144					; size = 4
__Tmp$239083 = -44					; size = 4
__Tmp$239071 = -40					; size = 4
$T239039 = -36						; size = 4
$T239038 = -32						; size = 4
$T239037 = -28						; size = 4
$T239036 = -24						; size = 4
$T239035 = -20						; size = 4
$T239034 = -16						; size = 4
$T239033 = -12						; size = 4
$T239032 = -8						; size = 4
__Step$222469 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 656				; 00000290H

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median@2

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$222469[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$239071[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	shl	edx, 1
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239071[ebp]
	mov	DWORD PTR __Tmp$239071[ebp], edx
	mov	eax, DWORD PTR __Tmp$239071[ebp]
	mov	DWORD PTR $T239032[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$239083[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239083[ebp]
	mov	DWORD PTR __Tmp$239083[ebp], edx
	mov	eax, DWORD PTR __Tmp$239083[ebp]
	mov	DWORD PTR $T239033[ebp], eax
	mov	ecx, DWORD PTR $T239032[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239033[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$239262[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239262[ebp]
	mov	DWORD PTR __Tmp$239262[ebp], edx
	mov	eax, DWORD PTR __Tmp$239262[ebp]
	mov	DWORD PTR $T239034[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$239285[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239285[ebp]
	mov	DWORD PTR __Tmp$239285[ebp], edx
	mov	eax, DWORD PTR __Tmp$239285[ebp]
	mov	DWORD PTR $T239035[ebp], eax
	mov	ecx, DWORD PTR $T239034[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T239035[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$239474[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239474[ebp]
	mov	DWORD PTR __Tmp$239474[ebp], edx
	mov	eax, DWORD PTR __Tmp$239474[ebp]
	mov	DWORD PTR $T239036[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$239499[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	shl	edx, 1
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239499[ebp]
	mov	DWORD PTR __Tmp$239499[ebp], edx
	mov	eax, DWORD PTR __Tmp$239499[ebp]
	mov	DWORD PTR $T239037[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239036[ebp]
	push	edx
	mov	eax, DWORD PTR $T239037[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$239699[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239699[ebp]
	mov	DWORD PTR __Tmp$239699[ebp], edx
	mov	eax, DWORD PTR __Tmp$239699[ebp]
	mov	DWORD PTR $T239038[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$239715[ebp], ecx
	mov	edx, DWORD PTR __Step$222469[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$239715[ebp]
	mov	DWORD PTR __Tmp$239715[ebp], edx
	mov	eax, DWORD PTR __Tmp$239715[ebp]
	mov	DWORD PTR $T239039[ebp], eax
	mov	ecx, DWORD PTR $T239038[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T239039[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median@2
$LN2@Median@2:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
	add	esp, 12					; 0000000cH
$LN3@Median@2:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z
_TEXT	SEGMENT
$T240118 = -24						; size = 4
__Tmp$240105 = -20					; size = 4
$T240085 = -16						; size = 4
__Hole$222495 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z PROC ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$222495[ebp], eax
$LN2@Make_heap@2:
	cmp	DWORD PTR __Hole$222495[ebp], 0
	jle	SHORT $LN3@Make_heap@2

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$222495[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$222495[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$240105[ebp], edx
	mov	eax, DWORD PTR __Hole$222495[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Tmp$240105[ebp]
	mov	DWORD PTR __Tmp$240105[ebp], eax
	mov	ecx, DWORD PTR __Tmp$240105[ebp]
	mov	DWORD PTR $T240085[ebp], ecx
	mov	edx, DWORD PTR $T240085[ebp]
	mov	DWORD PTR $T240118[ebp], edx
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	mov	eax, DWORD PTR $T240118[ebp]
	push	eax
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	ecx, DWORD PTR __Bottom$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Hole$222495[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 44					; 0000002cH

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap@2
$LN3@Make_heap@2:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAHPAVCvStartRegion@@@Z ENDP ; std::_Make_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z
_TEXT	SEGMENT
$T240608 = -100						; size = 4
$T240596 = -96						; size = 4
$T240571 = -92						; size = 4
$T240570 = -88						; size = 4
$T240569 = -84						; size = 4
$T240533 = -78						; size = 1
$T240532 = -77						; size = 1
$T240531 = -76						; size = 4
$T240530 = -72						; size = 4
$T240529 = -68						; size = 4
$T240488 = -64						; size = 4
__Cat$240541 = -56					; size = 1
$T240538 = -55						; size = 1
$T240537 = -54						; size = 1
$T240536 = -53						; size = 1
$T240439 = -52						; size = 4
$T240394 = -48						; size = 4
__First1$222538 = -44					; size = 4
__Val$222527 = -40					; size = 32
__Next1$222526 = -8					; size = 4
__Next$222522 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	esi
	push	edi

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$222522[ebp], ecx
$LN7@Insertion_@2:
	mov	edx, DWORD PTR __Next$222522[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __Next$222522[ebp], edx
	mov	eax, DWORD PTR __Next$222522[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@2

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$222522[ebp]
	mov	DWORD PTR __Next1$222526[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$222522[ebp]
	push	edx
	lea	ecx, DWORD PTR __Val$222527[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240439[ebp], eax
	mov	ecx, DWORD PTR $T240439[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T240439[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	esi, DWORD PTR __Val$222527[ebp+28]
	add	esi, 1
	mov	eax, DWORD PTR __Val$222527[ebp+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$222526[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Next1$222526[ebp], ecx
	mov	edx, DWORD PTR __Next1$222526[ebp]
	mov	DWORD PTR $T240571[ebp], edx
	mov	eax, DWORD PTR __Next$222522[ebp]
	mov	DWORD PTR $T240570[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240569[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T240536[ebp], dl
	mov	al, BYTE PTR __Cat$240541[ebp]
	mov	BYTE PTR $T240537[ebp], al
	mov	cl, BYTE PTR $T240536[ebp]
	mov	BYTE PTR $T240533[ebp], cl
	mov	dl, BYTE PTR $T240538[ebp]
	mov	BYTE PTR $T240532[ebp], dl
	mov	eax, DWORD PTR $T240571[ebp]
	mov	DWORD PTR $T240531[ebp], eax
	mov	ecx, DWORD PTR $T240570[ebp]
	mov	DWORD PTR $T240530[ebp], ecx
	mov	edx, DWORD PTR $T240569[ebp]
	mov	DWORD PTR $T240529[ebp], edx
$LN51@Insertion_@2:
	mov	eax, DWORD PTR $T240529[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T240530[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN47@Insertion_@2
	mov	ecx, DWORD PTR $T240530[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR $T240530[ebp], ecx
	mov	edx, DWORD PTR $T240530[ebp]
	mov	DWORD PTR $T240488[ebp], edx
	mov	eax, DWORD PTR $T240531[ebp]
	sub	eax, 32					; 00000020H
	mov	DWORD PTR $T240531[ebp], eax
	mov	esi, DWORD PTR $T240488[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T240531[ebp]
	rep movsd
	jmp	SHORT $LN51@Insertion_@2
$LN47@Insertion_@2:
	mov	ecx, DWORD PTR $T240531[ebp]
	mov	DWORD PTR $T240394[ebp], ecx

; 2977 : 				*_First = _Val;

	mov	ecx, 8
	lea	esi, DWORD PTR __Val$222527[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	edx, DWORD PTR __Next1$222526[ebp]
	mov	DWORD PTR __First1$222538[ebp], edx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@2
$LN2@Insertion_@2:
	mov	eax, DWORD PTR __First1$222538[ebp]
	mov	DWORD PTR __Next1$222526[ebp], eax
$LN3@Insertion_@2:
	mov	ecx, DWORD PTR __First1$222538[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR __First1$222538[ebp], ecx
	mov	edx, DWORD PTR __First1$222538[ebp]
	mov	DWORD PTR $T240596[ebp], edx
	mov	eax, DWORD PTR $T240596[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T240596[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	esi, DWORD PTR __Val$222527[ebp+28]
	add	esi, 1
	mov	eax, DWORD PTR __Val$222527[ebp+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN93@Insertion_@2

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$222538[ebp]
	mov	DWORD PTR $T240608[ebp], ecx
	mov	esi, DWORD PTR $T240608[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __Next1$222526[ebp]
	rep movsd
	jmp	SHORT $LN2@Insertion_@2

; 2985 : 				*_Next1 = _Val;	// insert element in hole

$LN93@Insertion_@2:
	mov	ecx, 8
	lea	esi, DWORD PTR __Val$222527[ebp]
	mov	edi, DWORD PTR __Next1$222526[ebp]
	rep movsd
$LN4@Insertion_@2:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@2
$LN9@Insertion_@2:

; 2988 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Odtp
;	COMDAT ??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z
_TEXT	SEGMENT
__Tmp$241322 = -284					; size = 4
__Tmp$241304 = -280					; size = 4
__Tmp$241108 = -204					; size = 4
__Tmp$241083 = -200					; size = 4
__Tmp$240887 = -124					; size = 4
__Tmp$240869 = -120					; size = 4
__Tmp$240682 = -44					; size = 4
__Tmp$240666 = -40					; size = 4
$T240634 = -36						; size = 4
$T240633 = -32						; size = 4
$T240632 = -28						; size = 4
$T240631 = -24						; size = 4
$T240630 = -20						; size = 4
$T240629 = -16						; size = 4
$T240628 = -12						; size = 4
$T240627 = -8						; size = 4
__Step$222544 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 464				; 000001d0H

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median@3

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$222544[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$240666[ebp], ecx
	mov	edx, DWORD PTR __Step$222544[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR __Tmp$240666[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$240666[ebp], ecx
	mov	edx, DWORD PTR __Tmp$240666[ebp]
	mov	DWORD PTR $T240627[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$240682[ebp], eax
	mov	ecx, DWORD PTR __Step$222544[ebp]
	mov	edx, DWORD PTR __Tmp$240682[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$240682[ebp], eax
	mov	ecx, DWORD PTR __Tmp$240682[ebp]
	mov	DWORD PTR $T240628[ebp], ecx
	mov	edx, DWORD PTR $T240627[ebp]
	push	edx
	mov	eax, DWORD PTR $T240628[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$240869[ebp], edx
	mov	eax, DWORD PTR __Step$222544[ebp]
	mov	ecx, DWORD PTR __Tmp$240869[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$240869[ebp], edx
	mov	eax, DWORD PTR __Tmp$240869[ebp]
	mov	DWORD PTR $T240629[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Tmp$240887[ebp], ecx
	mov	edx, DWORD PTR __Step$222544[ebp]
	neg	edx
	mov	eax, DWORD PTR __Tmp$240887[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$240887[ebp], ecx
	mov	edx, DWORD PTR __Tmp$240887[ebp]
	mov	DWORD PTR $T240630[ebp], edx
	mov	eax, DWORD PTR $T240629[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240630[ebp]
	push	edx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$241083[ebp], eax
	mov	ecx, DWORD PTR __Step$222544[ebp]
	neg	ecx
	mov	edx, DWORD PTR __Tmp$241083[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$241083[ebp], eax
	mov	ecx, DWORD PTR __Tmp$241083[ebp]
	mov	DWORD PTR $T240631[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$241108[ebp], edx
	mov	eax, DWORD PTR __Step$222544[ebp]
	shl	eax, 1
	neg	eax
	mov	ecx, DWORD PTR __Tmp$241108[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$241108[ebp], edx
	mov	eax, DWORD PTR __Tmp$241108[ebp]
	mov	DWORD PTR $T240632[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240631[ebp]
	push	edx
	mov	eax, DWORD PTR $T240632[ebp]
	push	eax
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$241304[ebp], ecx
	mov	edx, DWORD PTR __Step$222544[ebp]
	neg	edx
	mov	eax, DWORD PTR __Tmp$241304[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$241304[ebp], ecx
	mov	edx, DWORD PTR __Tmp$241304[ebp]
	mov	DWORD PTR $T240633[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$241322[ebp], eax
	mov	ecx, DWORD PTR __Step$222544[ebp]
	mov	edx, DWORD PTR __Tmp$241322[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$241322[ebp], eax
	mov	ecx, DWORD PTR __Tmp$241322[ebp]
	mov	DWORD PTR $T240634[ebp], ecx
	mov	edx, DWORD PTR $T240633[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240634[ebp]
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median@3
$LN2@Median@3:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
	add	esp, 12					; 0000000cH
$LN3@Median@3:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
$T241761 = -28						; size = 4
$T241757 = -24						; size = 4
__Tmp$241748 = -20					; size = 4
$T241724 = -16						; size = 4
__Hole$222570 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z PROC ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$222570[ebp], eax
$LN2@Make_heap@3:
	cmp	DWORD PTR __Hole$222570[ebp], 0
	jle	SHORT $LN3@Make_heap@3

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$222570[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$222570[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$241748[ebp], edx
	mov	eax, DWORD PTR __Hole$222570[ebp]
	mov	ecx, DWORD PTR __Tmp$241748[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$241748[ebp], edx
	mov	eax, DWORD PTR __Tmp$241748[ebp]
	mov	DWORD PTR $T241724[ebp], eax
	mov	ecx, DWORD PTR $T241724[ebp]
	mov	DWORD PTR $T241757[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T241761[ebp], esp
	mov	edx, DWORD PTR $T241761[ebp]
	mov	eax, DWORD PTR $T241757[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T241761[ebp]
	mov	eax, DWORD PTR $T241757[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$222570[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap@3
$LN3@Make_heap@3:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAHPAVCvPlayerStartRank@@@Z ENDP ; std::_Make_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
$T242247 = -80						; size = 4
$T242235 = -76						; size = 4
$T242210 = -72						; size = 4
$T242209 = -68						; size = 4
$T242208 = -64						; size = 4
$T242172 = -58						; size = 1
$T242171 = -57						; size = 1
$T242170 = -56						; size = 4
$T242169 = -52						; size = 4
$T242168 = -48						; size = 4
$T242127 = -44						; size = 4
__Cat$242178 = -36					; size = 1
$T242176 = -35						; size = 1
$T242175 = -34						; size = 1
$T242174 = -33						; size = 1
$T242078 = -32						; size = 4
$T242069 = -28						; size = 4
$T242033 = -24						; size = 4
__First1$222613 = -20					; size = 4
__Val$222602 = -16					; size = 8
__Next1$222601 = -8					; size = 4
__Next$222597 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@3

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$222597[ebp], ecx
$LN7@Insertion_@3:
	mov	edx, DWORD PTR __Next$222597[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$222597[ebp], edx
	mov	eax, DWORD PTR __Next$222597[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@3

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$222597[ebp]
	mov	DWORD PTR __Next1$222601[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$222597[ebp]
	mov	DWORD PTR $T242069[ebp], edx
	mov	eax, DWORD PTR $T242069[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Val$222602[ebp], ecx
	mov	edx, DWORD PTR $T242069[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$222602[ebp+4], eax

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242078[ebp], ecx
	mov	edx, DWORD PTR $T242078[ebp]
	mov	eax, DWORD PTR __Val$222602[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN5@Insertion_@3

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, DWORD PTR __Next1$222601[ebp]
	add	eax, 8
	mov	DWORD PTR __Next1$222601[ebp], eax
	mov	ecx, DWORD PTR __Next1$222601[ebp]
	mov	DWORD PTR $T242210[ebp], ecx
	mov	edx, DWORD PTR __Next$222597[ebp]
	mov	DWORD PTR $T242209[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242208[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242174[ebp], cl
	mov	dl, BYTE PTR __Cat$242178[ebp]
	mov	BYTE PTR $T242175[ebp], dl
	mov	al, BYTE PTR $T242174[ebp]
	mov	BYTE PTR $T242172[ebp], al
	mov	cl, BYTE PTR $T242176[ebp]
	mov	BYTE PTR $T242171[ebp], cl
	mov	edx, DWORD PTR $T242210[ebp]
	mov	DWORD PTR $T242170[ebp], edx
	mov	eax, DWORD PTR $T242209[ebp]
	mov	DWORD PTR $T242169[ebp], eax
	mov	ecx, DWORD PTR $T242208[ebp]
	mov	DWORD PTR $T242168[ebp], ecx
$LN49@Insertion_@3:
	mov	edx, DWORD PTR $T242168[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T242169[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN45@Insertion_@3
	mov	eax, DWORD PTR $T242169[ebp]
	sub	eax, 8
	mov	DWORD PTR $T242169[ebp], eax
	mov	ecx, DWORD PTR $T242169[ebp]
	mov	DWORD PTR $T242127[ebp], ecx
	mov	edx, DWORD PTR $T242170[ebp]
	sub	edx, 8
	mov	DWORD PTR $T242170[ebp], edx
	mov	eax, DWORD PTR $T242127[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T242170[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN49@Insertion_@3
$LN45@Insertion_@3:
	mov	ecx, DWORD PTR $T242170[ebp]
	mov	DWORD PTR $T242033[ebp], ecx

; 2977 : 				*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$222602[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$222602[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@3
$LN5@Insertion_@3:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	edx, DWORD PTR __Next1$222601[ebp]
	mov	DWORD PTR __First1$222613[ebp], edx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@3
$LN2@Insertion_@3:
	mov	eax, DWORD PTR __First1$222613[ebp]
	mov	DWORD PTR __Next1$222601[ebp], eax
$LN3@Insertion_@3:
	mov	ecx, DWORD PTR __First1$222613[ebp]
	sub	ecx, 8
	mov	DWORD PTR __First1$222613[ebp], ecx
	mov	edx, DWORD PTR __First1$222613[ebp]
	mov	DWORD PTR $T242235[ebp], edx
	mov	eax, DWORD PTR $T242235[ebp]
	mov	ecx, DWORD PTR __Val$222602[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN91@Insertion_@3

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$222613[ebp]
	mov	DWORD PTR $T242247[ebp], ecx
	mov	edx, DWORD PTR $T242247[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Next1$222601[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Insertion_@3

; 2985 : 				*_Next1 = _Val;	// insert element in hole

$LN91@Insertion_@3:
	mov	eax, DWORD PTR __Next1$222601[ebp]
	mov	ecx, DWORD PTR __Val$222602[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$222602[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Insertion_@3:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@3
$LN9@Insertion_@3:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z
_TEXT	SEGMENT
__Cat$242270 = -3					; size = 1
$T242267 = -2						; size = 1
$T242266 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T242266[ebp], al
	mov	cl, BYTE PTR __Cat$242270[ebp]
	mov	BYTE PTR $T242267[ebp], cl
	movzx	edx, BYTE PTR $T242266[ebp]
	push	edx
	movzx	eax, BYTE PTR $T242267[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@stdext@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z
_TEXT	SEGMENT
__Cat$242278 = -3					; size = 1
$T242275 = -2						; size = 1
$T242274 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T242274[ebp], al
	mov	cl, BYTE PTR __Cat$242278[ebp]
	mov	BYTE PTR $T242275[ebp], cl
	movzx	edx, BYTE PTR $T242274[ebp]
	push	edx
	movzx	eax, BYTE PTR $T242275[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@stdext@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z
_TEXT	SEGMENT
__Cat$242286 = -3					; size = 1
$T242283 = -2						; size = 1
$T242282 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T242282[ebp], al
	mov	cl, BYTE PTR __Cat$242286[ebp]
	mov	BYTE PTR $T242283[ebp], cl
	movzx	edx, BYTE PTR $T242282[ebp]
	push	edx
	movzx	eax, BYTE PTR $T242283[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@stdext@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z
_TEXT	SEGMENT
$T242493 = -120						; size = 4
$T242492 = -116						; size = 4
$T242475 = -112						; size = 4
__Tmp$242488 = -108					; size = 16
$T242456 = -92						; size = 4
$T242443 = -88						; size = 4
$T242434 = -84						; size = 4
$T242425 = -80						; size = 4
$T242424 = -76						; size = 4
$T242407 = -72						; size = 4
__Tmp$242420 = -68					; size = 16
$T242388 = -52						; size = 4
$T242375 = -48						; size = 4
$T242366 = -44						; size = 4
$T242357 = -40						; size = 4
$T242356 = -36						; size = 4
$T242339 = -32						; size = 4
__Tmp$242352 = -28					; size = 16
$T242320 = -12						; size = 4
$T242307 = -8						; size = 4
$T242298 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242298[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T242307[ebp], ecx
	mov	edx, DWORD PTR $T242307[ebp]
	mov	eax, DWORD PTR $T242298[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN33@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242357[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T242356[ebp], edx
	mov	eax, DWORD PTR $T242357[ebp]
	mov	DWORD PTR $T242320[ebp], eax
	mov	ecx, DWORD PTR $T242356[ebp]
	mov	DWORD PTR $T242339[ebp], ecx
	mov	edx, DWORD PTR $T242339[ebp]
	cmp	edx, DWORD PTR $T242320[ebp]
	je	SHORT $LN33@Med3
	mov	eax, DWORD PTR $T242339[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$242352[ebp], ecx
	mov	edx, DWORD PTR $T242339[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$242352[ebp+8], eax
	mov	ecx, DWORD PTR $T242339[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$242352[ebp+4], edx
	mov	eax, DWORD PTR $T242339[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$242352[ebp+12], ecx
	mov	edx, DWORD PTR $T242320[ebp]
	mov	eax, DWORD PTR $T242339[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T242320[ebp]
	mov	ecx, DWORD PTR __Tmp$242352[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$242352[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$242352[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$242352[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN33@Med3:
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T242366[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T242375[ebp], ecx
	mov	edx, DWORD PTR $T242375[ebp]
	mov	eax, DWORD PTR $T242366[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN58@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T242425[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T242424[ebp], edx
	mov	eax, DWORD PTR $T242425[ebp]
	mov	DWORD PTR $T242388[ebp], eax
	mov	ecx, DWORD PTR $T242424[ebp]
	mov	DWORD PTR $T242407[ebp], ecx
	mov	edx, DWORD PTR $T242407[ebp]
	cmp	edx, DWORD PTR $T242388[ebp]
	je	SHORT $LN58@Med3
	mov	eax, DWORD PTR $T242407[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$242420[ebp], ecx
	mov	edx, DWORD PTR $T242407[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$242420[ebp+8], eax
	mov	ecx, DWORD PTR $T242407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$242420[ebp+4], edx
	mov	eax, DWORD PTR $T242407[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$242420[ebp+12], ecx
	mov	edx, DWORD PTR $T242388[ebp]
	mov	eax, DWORD PTR $T242407[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T242388[ebp]
	mov	ecx, DWORD PTR __Tmp$242420[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$242420[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$242420[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$242420[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN58@Med3:
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242434[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T242443[ebp], ecx
	mov	edx, DWORD PTR $T242443[ebp]
	mov	eax, DWORD PTR $T242434[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242493[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T242492[ebp], edx
	mov	eax, DWORD PTR $T242493[ebp]
	mov	DWORD PTR $T242456[ebp], eax
	mov	ecx, DWORD PTR $T242492[ebp]
	mov	DWORD PTR $T242475[ebp], ecx
	mov	edx, DWORD PTR $T242475[ebp]
	cmp	edx, DWORD PTR $T242456[ebp]
	je	SHORT $LN4@Med3
	mov	eax, DWORD PTR $T242475[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$242488[ebp], ecx
	mov	edx, DWORD PTR $T242475[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$242488[ebp+8], eax
	mov	ecx, DWORD PTR $T242475[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$242488[ebp+4], edx
	mov	eax, DWORD PTR $T242475[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$242488[ebp+12], ecx
	mov	edx, DWORD PTR $T242456[ebp]
	mov	eax, DWORD PTR $T242475[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T242456[ebp]
	mov	ecx, DWORD PTR __Tmp$242488[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$242488[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$242488[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Tmp$242488[ebp+12]
	mov	DWORD PTR [eax+12], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z
_TEXT	SEGMENT
__Tmp$222698 = -16					; size = 16
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z PROC	; std::swap<CvContinent>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$222698[ebp], edx
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$222698[ebp+8], ecx
	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$222698[ebp+4], eax
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$222698[ebp+12], edx

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 23   : 		_Right = _Tmp;

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Tmp$222698[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$222698[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$222698[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Tmp$222698[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@VCvContinent@@@std@@YAXAAVCvContinent@@0@Z ENDP	; std::swap<CvContinent>
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z
_TEXT	SEGMENT
$T242662 = -80						; size = 4
__Tmp$242645 = -76					; size = 4
$T242634 = -72						; size = 4
__Tmp$242620 = -68					; size = 4
__Tmp$242596 = -64					; size = 4
$T242585 = -60						; size = 4
__Tmp$242571 = -56					; size = 4
$T242557 = -52						; size = 4
__Tmp$242543 = -48					; size = 4
$T242532 = -44						; size = 4
__Tmp$242518 = -40					; size = 4
$T242506 = -32						; size = 4
$T242505 = -28						; size = 4
$T242504 = -24						; size = 4
$T242503 = -20						; size = 4
$T242502 = -16						; size = 4
$T242501 = -12						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 16
??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	$LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$242518[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$242518[ebp]
	mov	DWORD PTR __Tmp$242518[ebp], ecx
	mov	edx, DWORD PTR __Tmp$242518[ebp]
	mov	DWORD PTR $T242502[ebp], edx
	mov	eax, DWORD PTR $T242502[ebp]
	mov	DWORD PTR $T242532[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$242543[ebp], ecx
	mov	edx, DWORD PTR __Idx$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$242543[ebp]
	mov	DWORD PTR __Tmp$242543[ebp], edx
	mov	eax, DWORD PTR __Tmp$242543[ebp]
	mov	DWORD PTR $T242501[ebp], eax
	mov	ecx, DWORD PTR $T242501[ebp]
	mov	DWORD PTR $T242557[ebp], ecx
	mov	edx, DWORD PTR $T242557[ebp]
	mov	eax, DWORD PTR $T242532[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Idx$[ebp], ecx
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$242571[ebp], edx
	mov	eax, DWORD PTR __Idx$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Tmp$242571[ebp]
	mov	DWORD PTR __Tmp$242571[ebp], eax
	mov	ecx, DWORD PTR __Tmp$242571[ebp]
	mov	DWORD PTR $T242504[ebp], ecx
	mov	edx, DWORD PTR $T242504[ebp]
	mov	DWORD PTR $T242585[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$242596[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$242596[ebp]
	mov	DWORD PTR __Tmp$242596[ebp], ecx
	mov	edx, DWORD PTR __Tmp$242596[ebp]
	mov	DWORD PTR $T242503[ebp], edx
	mov	eax, DWORD PTR $T242585[ebp]
	mov	ecx, DWORD PTR $T242503[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], ecx

; 2064 : 		}

	jmp	$LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$242620[ebp], eax
	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$242620[ebp]
	mov	DWORD PTR __Tmp$242620[ebp], ecx
	mov	edx, DWORD PTR __Tmp$242620[ebp]
	mov	DWORD PTR $T242506[ebp], edx
	mov	eax, DWORD PTR $T242506[ebp]
	mov	DWORD PTR $T242634[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$242645[ebp], ecx
	mov	edx, DWORD PTR __Hole$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$242645[ebp]
	mov	DWORD PTR __Tmp$242645[ebp], edx
	mov	eax, DWORD PTR __Tmp$242645[ebp]
	mov	DWORD PTR $T242505[ebp], eax
	mov	ecx, DWORD PTR $T242634[ebp]
	mov	edx, DWORD PTR $T242505[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 2069 : 		_Hole = _Bottom - 1;

	mov	edx, DWORD PTR __Bottom$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Hole$[ebp], edx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T242662[ebp], esp
	mov	eax, DWORD PTR $T242662[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T242662[ebp]
	mov	eax, DWORD PTR __Val$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T242662[ebp]
	mov	edx, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR $T242662[ebp]
	mov	ecx, DWORD PTR __Val$[ebp+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR __Top$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 28					; 0000001cH

; 2072 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
; Function compile flags: /Odtp
;	COMDAT ??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >, COMDAT

; 2094 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	cmp	eax, 1
	jle	SHORT $LN2@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
	add	esp, 12					; 0000000cH
$LN2@pop_heap:

; 2099 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z
_TEXT	SEGMENT
$T243371 = -168						; size = 4
$T243370 = -164						; size = 4
$T243355 = -160						; size = 4
__Tmp$243368 = -156					; size = 32
$T243337 = -124						; size = 4
$T243324 = -120						; size = 4
$T243315 = -116						; size = 4
$T243306 = -112						; size = 4
$T243305 = -108						; size = 4
$T243290 = -104						; size = 4
__Tmp$243304 = -100					; size = 32
$T243272 = -68						; size = 4
$T243259 = -64						; size = 4
$T243250 = -60						; size = 4
$T243241 = -56						; size = 4
$T243240 = -52						; size = 4
$T243225 = -48						; size = 4
__Tmp$243239 = -44					; size = 32
$T243211 = -12						; size = 4
$T243198 = -8						; size = 4
$T243189 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	esi
	push	edi

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T243189[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T243198[ebp], ecx
	mov	edx, DWORD PTR $T243189[ebp]
	mov	ecx, DWORD PTR [edx+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T243189[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T243198[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T243198[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@Med3@2

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T243241[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T243240[ebp], edx
	mov	eax, DWORD PTR $T243241[ebp]
	mov	DWORD PTR $T243211[ebp], eax
	mov	ecx, DWORD PTR $T243240[ebp]
	mov	DWORD PTR $T243225[ebp], ecx
	mov	edx, DWORD PTR $T243225[ebp]
	cmp	edx, DWORD PTR $T243211[ebp]
	je	SHORT $LN31@Med3@2
	mov	eax, DWORD PTR $T243225[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$243239[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T243211[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T243225[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$243239[ebp]
	mov	edi, DWORD PTR $T243211[ebp]
	rep movsd

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN31@Med3@2:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T243250[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T243259[ebp], edx
	mov	eax, DWORD PTR $T243250[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T243250[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T243259[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T243259[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN58@Med3@2

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T243306[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T243305[ebp], edx
	mov	eax, DWORD PTR $T243306[ebp]
	mov	DWORD PTR $T243272[ebp], eax
	mov	ecx, DWORD PTR $T243305[ebp]
	mov	DWORD PTR $T243290[ebp], ecx
	mov	edx, DWORD PTR $T243290[ebp]
	cmp	edx, DWORD PTR $T243272[ebp]
	je	SHORT $LN58@Med3@2
	mov	eax, DWORD PTR $T243290[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$243304[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T243272[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T243290[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$243304[ebp]
	mov	edi, DWORD PTR $T243272[ebp]
	rep movsd

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN58@Med3@2:
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T243315[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T243324[ebp], edx
	mov	eax, DWORD PTR $T243315[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T243315[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T243324[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T243324[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Med3@2

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T243371[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T243370[ebp], edx
	mov	eax, DWORD PTR $T243371[ebp]
	mov	DWORD PTR $T243337[ebp], eax
	mov	ecx, DWORD PTR $T243370[ebp]
	mov	DWORD PTR $T243355[ebp], ecx
	mov	edx, DWORD PTR $T243355[ebp]
	cmp	edx, DWORD PTR $T243337[ebp]
	je	SHORT $LN4@Med3@2
	mov	eax, DWORD PTR $T243355[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$243368[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	esi, DWORD PTR $T243337[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T243355[ebp]
	rep movsd
	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$243368[ebp]
	mov	edi, DWORD PTR $T243337[ebp]
	rep movsd
$LN4@Med3@2:

; 3005 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z
_TEXT	SEGMENT
__Tmp$222831 = -32					; size = 32
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z PROC ; std::swap<CvStartRegion>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$222831[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __Left$[ebp]
	rep movsd

; 23   : 		_Right = _Tmp;

	mov	ecx, 8
	lea	esi, DWORD PTR __Tmp$222831[ebp]
	mov	edi, DWORD PTR __Right$[ebp]
	rep movsd
$LN2@swap@2:

; 24   : 		}
; 25   : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@VCvStartRegion@@@std@@YAXAAVCvStartRegion@@0@Z ENDP ; std::swap<CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z
_TEXT	SEGMENT
__Tmp$243524 = -76					; size = 4
$T243513 = -72						; size = 4
__Tmp$243499 = -68					; size = 4
__Tmp$243475 = -64					; size = 4
$T243464 = -60						; size = 4
__Tmp$243450 = -56					; size = 4
$T243436 = -52						; size = 4
__Tmp$243422 = -48					; size = 4
$T243411 = -44						; size = 4
__Tmp$243397 = -40					; size = 4
$T243385 = -32						; size = 4
$T243384 = -28						; size = 4
$T243383 = -24						; size = 4
$T243382 = -20						; size = 4
$T243381 = -16						; size = 4
$T243380 = -12						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 32
??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	push	esi
	push	edi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea@2
$LN4@Adjust_hea@2:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea@2:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	$LN3@Adjust_hea@2

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$243397[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	shl	ecx, 5
	add	ecx, DWORD PTR __Tmp$243397[ebp]
	mov	DWORD PTR __Tmp$243397[ebp], ecx
	mov	edx, DWORD PTR __Tmp$243397[ebp]
	mov	DWORD PTR $T243381[ebp], edx
	mov	eax, DWORD PTR $T243381[ebp]
	mov	DWORD PTR $T243411[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$243422[ebp], ecx
	mov	edx, DWORD PTR __Idx$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$243422[ebp]
	mov	DWORD PTR __Tmp$243422[ebp], edx
	mov	eax, DWORD PTR __Tmp$243422[ebp]
	mov	DWORD PTR $T243380[ebp], eax
	mov	ecx, DWORD PTR $T243380[ebp]
	mov	DWORD PTR $T243436[ebp], ecx
	mov	edx, DWORD PTR $T243411[ebp]
	mov	ecx, DWORD PTR [edx+28]
	add	ecx, 1
	mov	edx, DWORD PTR $T243411[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T243436[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T243436[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@Adjust_hea@2

; 2062 : 			--_Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Idx$[ebp], ecx
$LN2@Adjust_hea@2:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$243450[ebp], edx
	mov	eax, DWORD PTR __Idx$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Tmp$243450[ebp]
	mov	DWORD PTR __Tmp$243450[ebp], eax
	mov	ecx, DWORD PTR __Tmp$243450[ebp]
	mov	DWORD PTR $T243383[ebp], ecx
	mov	edx, DWORD PTR $T243383[ebp]
	mov	DWORD PTR $T243464[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$243475[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Tmp$243475[ebp]
	mov	DWORD PTR __Tmp$243475[ebp], ecx
	mov	edx, DWORD PTR __Tmp$243475[ebp]
	mov	DWORD PTR $T243382[ebp], edx
	mov	esi, DWORD PTR $T243464[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T243382[ebp]
	rep movsd
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	$LN4@Adjust_hea@2
$LN3@Adjust_hea@2:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea@2

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$243499[ebp], edx
	mov	eax, DWORD PTR __Bottom$[ebp]
	sub	eax, 1
	shl	eax, 5
	add	eax, DWORD PTR __Tmp$243499[ebp]
	mov	DWORD PTR __Tmp$243499[ebp], eax
	mov	ecx, DWORD PTR __Tmp$243499[ebp]
	mov	DWORD PTR $T243385[ebp], ecx
	mov	edx, DWORD PTR $T243385[ebp]
	mov	DWORD PTR $T243513[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$243524[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Tmp$243524[ebp]
	mov	DWORD PTR __Tmp$243524[ebp], ecx
	mov	edx, DWORD PTR __Tmp$243524[ebp]
	mov	DWORD PTR $T243384[ebp], edx
	mov	esi, DWORD PTR $T243513[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T243384[ebp]
	rep movsd

; 2069 : 		_Hole = _Bottom - 1;

	mov	eax, DWORD PTR __Bottom$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Hole$[ebp], eax
$LN1@Adjust_hea@2:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	eax, DWORD PTR __Top$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 44					; 0000002cH

; 2072 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
; Function compile flags: /Odtp
;	COMDAT ??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >, COMDAT

; 2094 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	cmp	eax, 1
	jle	SHORT $LN2@pop_heap@2

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
	add	esp, 12					; 0000000cH
$LN2@pop_heap@2:

; 2099 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$pop_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z
_TEXT	SEGMENT
$T244282 = -96						; size = 4
$T244281 = -92						; size = 4
$T244264 = -88						; size = 4
__Tmp$244280 = -84					; size = 8
$T244245 = -76						; size = 4
$T244232 = -72						; size = 4
$T244223 = -68						; size = 4
$T244214 = -64						; size = 4
$T244213 = -60						; size = 4
$T244196 = -56						; size = 4
__Tmp$244212 = -52					; size = 8
$T244177 = -44						; size = 4
$T244164 = -40						; size = 4
$T244155 = -36						; size = 4
$T244146 = -32						; size = 4
$T244145 = -28						; size = 4
$T244128 = -24						; size = 4
__Tmp$244144 = -20					; size = 8
$T244109 = -12						; size = 4
$T244096 = -8						; size = 4
$T244087 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244087[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T244096[ebp], ecx
	mov	edx, DWORD PTR $T244096[ebp]
	mov	eax, DWORD PTR $T244087[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN33@Med3@3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244146[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T244145[ebp], edx
	mov	eax, DWORD PTR $T244146[ebp]
	mov	DWORD PTR $T244109[ebp], eax
	mov	ecx, DWORD PTR $T244145[ebp]
	mov	DWORD PTR $T244128[ebp], ecx
	mov	edx, DWORD PTR $T244128[ebp]
	cmp	edx, DWORD PTR $T244109[ebp]
	je	SHORT $LN33@Med3@3
	mov	eax, DWORD PTR $T244128[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$244144[ebp], ecx
	mov	edx, DWORD PTR $T244128[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$244144[ebp+4], eax
	mov	ecx, DWORD PTR $T244109[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T244128[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T244109[ebp]
	mov	eax, DWORD PTR __Tmp$244144[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$244144[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN33@Med3@3:
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T244155[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T244164[ebp], eax
	mov	ecx, DWORD PTR $T244164[ebp]
	mov	edx, DWORD PTR $T244155[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN58@Med3@3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T244214[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T244213[ebp], ecx
	mov	edx, DWORD PTR $T244214[ebp]
	mov	DWORD PTR $T244177[ebp], edx
	mov	eax, DWORD PTR $T244213[ebp]
	mov	DWORD PTR $T244196[ebp], eax
	mov	ecx, DWORD PTR $T244196[ebp]
	cmp	ecx, DWORD PTR $T244177[ebp]
	je	SHORT $LN58@Med3@3
	mov	edx, DWORD PTR $T244196[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$244212[ebp], eax
	mov	ecx, DWORD PTR $T244196[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$244212[ebp+4], edx
	mov	eax, DWORD PTR $T244177[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T244196[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T244177[ebp]
	mov	edx, DWORD PTR __Tmp$244212[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$244212[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN58@Med3@3:
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244223[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T244232[ebp], edx
	mov	eax, DWORD PTR $T244232[ebp]
	mov	ecx, DWORD PTR $T244223[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Med3@3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T244282[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T244281[ebp], eax
	mov	ecx, DWORD PTR $T244282[ebp]
	mov	DWORD PTR $T244245[ebp], ecx
	mov	edx, DWORD PTR $T244281[ebp]
	mov	DWORD PTR $T244264[ebp], edx
	mov	eax, DWORD PTR $T244264[ebp]
	cmp	eax, DWORD PTR $T244245[ebp]
	je	SHORT $LN4@Med3@3
	mov	ecx, DWORD PTR $T244264[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$244280[ebp], edx
	mov	eax, DWORD PTR $T244264[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$244280[ebp+4], ecx
	mov	edx, DWORD PTR $T244245[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T244264[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T244245[ebp]
	mov	ecx, DWORD PTR __Tmp$244280[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$244280[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3@3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z
_TEXT	SEGMENT
__Tmp$222964 = -8					; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z PROC ; std::swap<CvPlayerStartRank>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$222964[ebp], edx
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$222964[ebp+4], ecx

; 21   : 
; 22   : 		_Left = _Right;

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Tmp$222964[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$222964[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN2@swap@3:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@VCvPlayerStartRank@@@std@@YAXAAVCvPlayerStartRank@@0@Z ENDP ; std::swap<CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
$T244451 = -80						; size = 4
__Tmp$244434 = -76					; size = 4
$T244423 = -72						; size = 4
__Tmp$244409 = -68					; size = 4
__Tmp$244385 = -64					; size = 4
$T244374 = -60						; size = 4
__Tmp$244360 = -56					; size = 4
$T244346 = -52						; size = 4
__Tmp$244332 = -48					; size = 4
$T244321 = -44						; size = 4
__Tmp$244307 = -40					; size = 4
$T244295 = -32						; size = 4
$T244294 = -28						; size = 4
$T244293 = -24						; size = 4
$T244292 = -20						; size = 4
$T244291 = -16						; size = 4
$T244290 = -12						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea@3
$LN4@Adjust_hea@3:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea@3:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	$LN3@Adjust_hea@3

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$244307[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __Tmp$244307[ebp]
	lea	eax, DWORD PTR [edx+ecx*8-8]
	mov	DWORD PTR __Tmp$244307[ebp], eax
	mov	ecx, DWORD PTR __Tmp$244307[ebp]
	mov	DWORD PTR $T244291[ebp], ecx
	mov	edx, DWORD PTR $T244291[ebp]
	mov	DWORD PTR $T244321[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$244332[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __Tmp$244332[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$244332[ebp], eax
	mov	ecx, DWORD PTR __Tmp$244332[ebp]
	mov	DWORD PTR $T244290[ebp], ecx
	mov	edx, DWORD PTR $T244290[ebp]
	mov	DWORD PTR $T244346[ebp], edx
	mov	eax, DWORD PTR $T244346[ebp]
	mov	ecx, DWORD PTR $T244321[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Adjust_hea@3

; 2062 : 			--_Idx;

	mov	edx, DWORD PTR __Idx$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Idx$[ebp], edx
$LN2@Adjust_hea@3:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$244360[ebp], eax
	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __Tmp$244360[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$244360[ebp], eax
	mov	ecx, DWORD PTR __Tmp$244360[ebp]
	mov	DWORD PTR $T244293[ebp], ecx
	mov	edx, DWORD PTR $T244293[ebp]
	mov	DWORD PTR $T244374[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$244385[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	edx, DWORD PTR __Tmp$244385[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$244385[ebp], eax
	mov	ecx, DWORD PTR __Tmp$244385[ebp]
	mov	DWORD PTR $T244292[ebp], ecx
	mov	edx, DWORD PTR $T244374[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T244292[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	$LN4@Adjust_hea@3
$LN3@Adjust_hea@3:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea@3

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$244409[ebp], edx
	mov	eax, DWORD PTR __Bottom$[ebp]
	mov	ecx, DWORD PTR __Tmp$244409[ebp]
	lea	edx, DWORD PTR [ecx+eax*8-8]
	mov	DWORD PTR __Tmp$244409[ebp], edx
	mov	eax, DWORD PTR __Tmp$244409[ebp]
	mov	DWORD PTR $T244295[ebp], eax
	mov	ecx, DWORD PTR $T244295[ebp]
	mov	DWORD PTR $T244423[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$244434[ebp], edx
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	ecx, DWORD PTR __Tmp$244434[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$244434[ebp], edx
	mov	eax, DWORD PTR __Tmp$244434[ebp]
	mov	DWORD PTR $T244294[ebp], eax
	mov	ecx, DWORD PTR $T244423[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T244294[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	mov	edx, DWORD PTR __Bottom$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Hole$[ebp], edx
$LN1@Adjust_hea@3:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	sub	esp, 8
	mov	DWORD PTR $T244451[ebp], esp
	mov	eax, DWORD PTR $T244451[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T244451[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Top$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Hole$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H

; 2072 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
; Function compile flags: /Odtp
;	COMDAT ??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >, COMDAT

; 2094 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN2@pop_heap@3

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ; std::_Pop_heap_0<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
	add	esp, 12					; 0000000cH
$LN2@pop_heap@3:

; 2099 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$pop_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T245024 = -32						; size = 4
$T245023 = -28						; size = 4
__Vptr$245021 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245021[ebp], ecx
	mov	edx, DWORD PTR __Vptr$245021[ebp]
	mov	DWORD PTR $T245024[ebp], edx
	cmp	DWORD PTR $T245024[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR $T245024[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T245024[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T245024[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T245024[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T245024[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T245023[ebp], ecx
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvContinent@@PAV1@V?$allocator@VCvContinent@@@std@@@std@@YAPAVCvContinent@@PAV1@00AAV?$allocator@VCvContinent@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvContinent *,CvContinent *,std::allocator<CvContinent> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Construct@VCvStartRegion@@V1@@std@@YAXPAVCvStartRegion@@ABV1@@Z ; std::_Construct<CvStartRegion,CvStartRegion>
	add	esp, 8
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvStartRegion@@PAV1@V?$allocator@VCvStartRegion@@@std@@@std@@YAPAVCvStartRegion@@PAV1@00AAV?$allocator@VCvStartRegion@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvStartRegion *,CvStartRegion *,std::allocator<CvStartRegion> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__ehfuncinfo$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -36						; size = 4
$T245127 = -32						; size = 4
$T245126 = -28						; size = 4
__Vptr$245124 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245124[ebp], ecx
	mov	edx, DWORD PTR __Vptr$245124[ebp]
	mov	DWORD PTR $T245127[ebp], edx
	cmp	DWORD PTR $T245127[ebp], 0
	je	SHORT $LN18@Uninit_cop@3
	mov	eax, DWORD PTR $T245127[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T245127[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T245127[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_cop@3
$LN18@Uninit_cop@3:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop@3:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T245126[ebp], ecx
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvPlayerStartRank@@PAV1@V?$allocator@VCvPlayerStartRank@@@std@@@std@@YAPAVCvPlayerStartRank@@PAV1@00AAV?$allocator@VCvPlayerStartRank@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPlayerStartRank *,CvPlayerStartRank *,std::allocator<CvPlayerStartRank> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z
_TEXT	SEGMENT
__Tmp$245245 = -44					; size = 4
__Tmp$245221 = -40					; size = 4
$T245210 = -36						; size = 4
__Tmp$245201 = -32					; size = 4
$T245182 = -28						; size = 4
__Tmp$245173 = -24					; size = 4
$T245157 = -20						; size = 4
$T245156 = -16						; size = 4
$T245155 = -12						; size = 4
$T245154 = -8						; size = 4
__Idx$223119 = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 16
??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z PROC ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 1972 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$223119[ebp], eax

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	jmp	SHORT $LN3@Push_heap
$LN2@Push_heap:
	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$223119[ebp], eax
$LN3@Push_heap:
	mov	eax, DWORD PTR __Top$[ebp]
	cmp	eax, DWORD PTR __Hole$[ebp]
	jge	$LN1@Push_heap
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245173[ebp], ecx
	mov	edx, DWORD PTR __Idx$223119[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$245173[ebp]
	mov	DWORD PTR __Tmp$245173[ebp], edx
	mov	eax, DWORD PTR __Tmp$245173[ebp]
	mov	DWORD PTR $T245154[ebp], eax
	mov	ecx, DWORD PTR $T245154[ebp]
	mov	DWORD PTR $T245182[ebp], ecx
	mov	edx, DWORD PTR $T245182[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Val$[ebp+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245201[ebp], eax
	mov	ecx, DWORD PTR __Idx$223119[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$245201[ebp]
	mov	DWORD PTR __Tmp$245201[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245201[ebp]
	mov	DWORD PTR $T245156[ebp], edx
	mov	eax, DWORD PTR $T245156[ebp]
	mov	DWORD PTR $T245210[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245221[ebp], ecx
	mov	edx, DWORD PTR __Hole$[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$245221[ebp]
	mov	DWORD PTR __Tmp$245221[ebp], edx
	mov	eax, DWORD PTR __Tmp$245221[ebp]
	mov	DWORD PTR $T245155[ebp], eax
	mov	ecx, DWORD PTR $T245210[ebp]
	mov	edx, DWORD PTR $T245155[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 1978 : 		_Hole = _Idx;

	mov	edx, DWORD PTR __Idx$223119[ebp]
	mov	DWORD PTR __Hole$[ebp], edx

; 1979 : 		}

	jmp	$LN2@Push_heap
$LN1@Push_heap:

; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245245[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$245245[ebp]
	mov	DWORD PTR __Tmp$245245[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245245[ebp]
	mov	DWORD PTR $T245157[ebp], edx
	mov	eax, DWORD PTR $T245157[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR __Val$[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 1982 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Push_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ENDP ; std::_Push_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
; Function compile flags: /Odtp
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z
_TEXT	SEGMENT
__Tmp$245348 = -36					; size = 4
__Tmp$245323 = -32					; size = 4
$T245305 = -28						; size = 4
$T245301 = -24						; size = 4
__Tmp$245285 = -20					; size = 4
$T245264 = -16						; size = 4
$T245263 = -12						; size = 4
$T245262 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$245285[ebp], eax
	mov	ecx, 1
	neg	ecx
	shl	ecx, 4
	add	ecx, DWORD PTR __Tmp$245285[ebp]
	mov	DWORD PTR __Tmp$245285[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245285[ebp]
	mov	DWORD PTR $T245262[ebp], edx
	mov	eax, DWORD PTR $T245262[ebp]
	mov	DWORD PTR $T245301[ebp], eax
	push	0
	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T245305[ebp], esp
	mov	ecx, DWORD PTR $T245305[ebp]
	mov	edx, DWORD PTR $T245301[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T245305[ebp]
	mov	edx, DWORD PTR $T245301[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T245305[ebp]
	mov	edx, DWORD PTR $T245301[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR $T245305[ebp]
	mov	edx, DWORD PTR $T245301[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$245323[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$245323[ebp]
	mov	DWORD PTR __Tmp$245323[ebp], edx
	mov	eax, DWORD PTR __Tmp$245323[ebp]
	mov	DWORD PTR $T245263[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$245348[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 4
	add	edx, DWORD PTR __Tmp$245348[ebp]
	mov	DWORD PTR __Tmp$245348[ebp], edx
	mov	eax, DWORD PTR __Tmp$245348[ebp]
	mov	DWORD PTR $T245264[ebp], eax
	mov	ecx, DWORD PTR $T245263[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245264[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 32					; 00000020H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@VCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@0PAVCvContinent@@@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,CvContinent>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z
_TEXT	SEGMENT
__Tmp$245750 = -44					; size = 4
__Tmp$245726 = -40					; size = 4
$T245715 = -36						; size = 4
__Tmp$245701 = -32					; size = 4
$T245687 = -28						; size = 4
__Tmp$245673 = -24					; size = 4
$T245662 = -20						; size = 4
$T245661 = -16						; size = 4
$T245660 = -12						; size = 4
$T245659 = -8						; size = 4
__Idx$223160 = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 32
??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z PROC ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>, COMDAT

; 1972 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$223160[ebp], eax

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	jmp	SHORT $LN3@Push_heap@2
$LN2@Push_heap@2:
	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$223160[ebp], eax
$LN3@Push_heap@2:
	mov	eax, DWORD PTR __Top$[ebp]
	cmp	eax, DWORD PTR __Hole$[ebp]
	jge	$LN1@Push_heap@2
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245673[ebp], ecx
	mov	edx, DWORD PTR __Idx$223160[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$245673[ebp]
	mov	DWORD PTR __Tmp$245673[ebp], edx
	mov	eax, DWORD PTR __Tmp$245673[ebp]
	mov	DWORD PTR $T245659[ebp], eax
	mov	ecx, DWORD PTR $T245659[ebp]
	mov	DWORD PTR $T245687[ebp], ecx
	mov	ecx, DWORD PTR __Val$[ebp+28]
	add	ecx, 1
	mov	eax, DWORD PTR __Val$[ebp+16]
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR $T245687[ebp]
	mov	esi, DWORD PTR [edx+28]
	add	esi, 1
	mov	eax, DWORD PTR $T245687[ebp]
	mov	eax, DWORD PTR [eax+16]
	cdq
	idiv	esi
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Push_heap@2

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245701[ebp], ecx
	mov	edx, DWORD PTR __Idx$223160[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$245701[ebp]
	mov	DWORD PTR __Tmp$245701[ebp], edx
	mov	eax, DWORD PTR __Tmp$245701[ebp]
	mov	DWORD PTR $T245661[ebp], eax
	mov	ecx, DWORD PTR $T245661[ebp]
	mov	DWORD PTR $T245715[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245726[ebp], edx
	mov	eax, DWORD PTR __Hole$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Tmp$245726[ebp]
	mov	DWORD PTR __Tmp$245726[ebp], eax
	mov	ecx, DWORD PTR __Tmp$245726[ebp]
	mov	DWORD PTR $T245660[ebp], ecx
	mov	esi, DWORD PTR $T245715[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T245660[ebp]
	rep movsd

; 1978 : 		_Hole = _Idx;

	mov	edx, DWORD PTR __Idx$223160[ebp]
	mov	DWORD PTR __Hole$[ebp], edx

; 1979 : 		}

	jmp	$LN2@Push_heap@2
$LN1@Push_heap@2:

; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245750[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Tmp$245750[ebp]
	mov	DWORD PTR __Tmp$245750[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245750[ebp]
	mov	DWORD PTR $T245662[ebp], edx
	mov	ecx, 8
	lea	esi, DWORD PTR __Val$[ebp]
	mov	edi, DWORD PTR $T245662[ebp]
	rep movsd

; 1982 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Push_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ENDP ; std::_Push_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z
_TEXT	SEGMENT
$T246180 = -208						; size = 4
$T246179 = -204						; size = 4
$T246178 = -200						; size = 4
$T246177 = -196						; size = 32
$T245892 = -44						; size = 4
$T245871 = -40						; size = 4
__Tmp$245860 = -32					; size = 4
__Tmp$245835 = -28					; size = 4
$T245806 = -24						; size = 4
__Tmp$245797 = -20					; size = 4
$T245769 = -16						; size = 4
$T245768 = -12						; size = 4
$T245767 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	esi
	push	edi

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$245797[ebp], eax
	mov	ecx, 1
	neg	ecx
	shl	ecx, 5
	add	ecx, DWORD PTR __Tmp$245797[ebp]
	mov	DWORD PTR __Tmp$245797[ebp], ecx
	mov	edx, DWORD PTR __Tmp$245797[ebp]
	mov	DWORD PTR $T245767[ebp], edx
	mov	eax, DWORD PTR $T245767[ebp]
	mov	DWORD PTR $T245806[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$245835[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$245835[ebp]
	mov	DWORD PTR __Tmp$245835[ebp], edx
	mov	eax, DWORD PTR __Tmp$245835[ebp]
	mov	DWORD PTR $T245768[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$245860[ebp], ecx
	mov	edx, 1
	neg	edx
	shl	edx, 5
	add	edx, DWORD PTR __Tmp$245860[ebp]
	mov	DWORD PTR __Tmp$245860[ebp], edx
	mov	eax, DWORD PTR __Tmp$245860[ebp]
	mov	DWORD PTR $T245769[ebp], eax
	mov	ecx, DWORD PTR $T245806[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T246177[ebp]
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	edx, DWORD PTR $T245768[ebp]
	mov	DWORD PTR $T246180[ebp], edx
	mov	eax, DWORD PTR $T245769[ebp]
	mov	DWORD PTR $T246179[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T246178[ebp], ecx
	mov	edx, DWORD PTR $T246178[ebp]
	mov	DWORD PTR $T245871[ebp], edx
	mov	esi, DWORD PTR $T245871[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T246180[ebp]
	rep movsd
	mov	eax, DWORD PTR $T246179[ebp]
	sub	eax, DWORD PTR $T246178[ebp]
	sar	eax, 5
	mov	DWORD PTR $T245892[ebp], eax
	sub	esp, 32					; 00000020H
	mov	ecx, esp
	lea	edx, DWORD PTR $T246177[ebp]
	push	edx
	call	??0CvStartRegion@@QAE@ABV0@@Z		; CvStartRegion::CvStartRegion
	mov	eax, DWORD PTR $T245892[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR $T246178[ebp]
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@HVCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@HHVCvStartRegion@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,int,CvStartRegion>
	add	esp, 44					; 0000002cH

; 2090 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@std@@VCvStartRegion@@@std@@YAXV?$_Vector_iterator@VCvStartRegion@@V?$allocator@VCvStartRegion@@@std@@@0@0PAVCvStartRegion@@@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<CvStartRegion,std::allocator<CvStartRegion> >,CvStartRegion>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
__Tmp$246274 = -44					; size = 4
__Tmp$246250 = -40					; size = 4
$T246239 = -36						; size = 4
__Tmp$246229 = -32					; size = 4
$T246211 = -28						; size = 4
__Tmp$246202 = -24					; size = 4
$T246186 = -20						; size = 4
$T246185 = -16						; size = 4
$T246184 = -12						; size = 4
$T246183 = -8						; size = 4
__Idx$223201 = -4					; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z PROC ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>, COMDAT

; 1972 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$223201[ebp], eax

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	jmp	SHORT $LN3@Push_heap@3
$LN2@Push_heap@3:
	mov	eax, DWORD PTR __Hole$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$223201[ebp], eax
$LN3@Push_heap@3:
	mov	eax, DWORD PTR __Top$[ebp]
	cmp	eax, DWORD PTR __Hole$[ebp]
	jge	$LN1@Push_heap@3
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$246202[ebp], ecx
	mov	edx, DWORD PTR __Idx$223201[ebp]
	mov	eax, DWORD PTR __Tmp$246202[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$246202[ebp], ecx
	mov	edx, DWORD PTR __Tmp$246202[ebp]
	mov	DWORD PTR $T246183[ebp], edx
	mov	eax, DWORD PTR $T246183[ebp]
	mov	DWORD PTR $T246211[ebp], eax
	mov	ecx, DWORD PTR $T246211[ebp]
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	cmp	edx, DWORD PTR __Val$[ebp+4]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Push_heap@3

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$246229[ebp], edx
	mov	eax, DWORD PTR __Idx$223201[ebp]
	mov	ecx, DWORD PTR __Tmp$246229[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$246229[ebp], edx
	mov	eax, DWORD PTR __Tmp$246229[ebp]
	mov	DWORD PTR $T246185[ebp], eax
	mov	ecx, DWORD PTR $T246185[ebp]
	mov	DWORD PTR $T246239[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$246250[ebp], edx
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	ecx, DWORD PTR __Tmp$246250[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Tmp$246250[ebp], edx
	mov	eax, DWORD PTR __Tmp$246250[ebp]
	mov	DWORD PTR $T246184[ebp], eax
	mov	ecx, DWORD PTR $T246239[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T246184[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 1978 : 		_Hole = _Idx;

	mov	edx, DWORD PTR __Idx$223201[ebp]
	mov	DWORD PTR __Hole$[ebp], edx

; 1979 : 		}

	jmp	$LN2@Push_heap@3
$LN1@Push_heap@3:

; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$246274[ebp], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	edx, DWORD PTR __Tmp$246274[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$246274[ebp], eax
	mov	ecx, DWORD PTR __Tmp$246274[ebp]
	mov	DWORD PTR $T246186[ebp], ecx
	mov	edx, DWORD PTR $T246186[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 1982 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Push_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ENDP ; std::_Push_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z
_TEXT	SEGMENT
$T246706 = -196						; size = 4
$T246705 = -192						; size = 4
$T246704 = -188						; size = 4
$T246703 = -184						; size = 8
$T246416 = -52						; size = 4
$T246407 = -48						; size = 4
$T246395 = -44						; size = 4
__Tmp$246377 = -36					; size = 4
__Tmp$246352 = -32					; size = 4
$T246334 = -28						; size = 4
$T246330 = -24						; size = 4
__Tmp$246314 = -20					; size = 4
$T246293 = -16						; size = 4
$T246292 = -12						; size = 4
$T246291 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$246314[ebp], eax
	mov	ecx, 1
	neg	ecx
	mov	edx, DWORD PTR __Tmp$246314[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$246314[ebp], eax
	mov	ecx, DWORD PTR __Tmp$246314[ebp]
	mov	DWORD PTR $T246291[ebp], ecx
	mov	edx, DWORD PTR $T246291[ebp]
	mov	DWORD PTR $T246330[ebp], edx
	lea	eax, DWORD PTR $T246703[ebp]
	mov	DWORD PTR $T246334[ebp], eax
	mov	ecx, DWORD PTR $T246334[ebp]
	mov	edx, DWORD PTR $T246330[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T246334[ebp]
	mov	edx, DWORD PTR $T246330[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$246352[ebp], ecx
	mov	edx, 1
	neg	edx
	mov	eax, DWORD PTR __Tmp$246352[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$246352[ebp], ecx
	mov	edx, DWORD PTR __Tmp$246352[ebp]
	mov	DWORD PTR $T246292[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Tmp$246377[ebp], eax
	mov	ecx, 1
	neg	ecx
	mov	edx, DWORD PTR __Tmp$246377[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$246377[ebp], eax
	mov	ecx, DWORD PTR __Tmp$246377[ebp]
	mov	DWORD PTR $T246293[ebp], ecx
	mov	edx, DWORD PTR $T246292[ebp]
	mov	DWORD PTR $T246706[ebp], edx
	mov	eax, DWORD PTR $T246293[ebp]
	mov	DWORD PTR $T246705[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T246704[ebp], ecx
	mov	edx, DWORD PTR $T246704[ebp]
	mov	DWORD PTR $T246395[ebp], edx
	mov	eax, DWORD PTR $T246395[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T246706[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	sub	esp, 8
	mov	DWORD PTR $T246407[ebp], esp
	mov	ecx, DWORD PTR $T246407[ebp]
	mov	edx, DWORD PTR $T246703[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T246407[ebp]
	mov	ecx, DWORD PTR $T246703[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T246705[ebp]
	sub	edx, DWORD PTR $T246704[ebp]
	sar	edx, 3
	mov	DWORD PTR $T246416[ebp], edx
	mov	eax, DWORD PTR $T246416[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR $T246704[ebp]
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@HVCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@HHVCvPlayerStartRank@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,int,CvPlayerStartRank>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@std@@VCvPlayerStartRank@@@std@@YAXV?$_Vector_iterator@VCvPlayerStartRank@@V?$allocator@VCvPlayerStartRank@@@std@@@0@0PAVCvPlayerStartRank@@@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<CvPlayerStartRank,std::allocator<CvPlayerStartRank> >,CvPlayerStartRank>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z
_TEXT	SEGMENT
$T246739 = -16						; size = 4
$T246730 = -12						; size = 4
$T246718 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 16
___formal$ = 36						; size = 4
??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z PROC ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>, COMDAT

; 2079 : 	{	// pop *_First to *_Dest and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T246718[ebp], eax
	mov	ecx, DWORD PTR $T246718[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	sub	esp, 16					; 00000010H
	mov	DWORD PTR $T246730[ebp], esp
	mov	edx, DWORD PTR $T246730[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T246730[ebp]
	mov	edx, DWORD PTR __Val$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR $T246730[ebp]
	mov	ecx, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T246730[ebp]
	mov	eax, DWORD PTR __Val$[ebp+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 4
	mov	DWORD PTR $T246739[ebp], ecx
	mov	edx, DWORD PTR $T246739[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Adjust_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@HHVCvContinent@@@Z ; std::_Adjust_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
	add	esp, 28					; 0000001cH

; 2082 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap@V?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@std@@HVCvContinent@@@std@@YAXV?$_Vector_iterator@VCvContinent@@V?$allocator@VCvContinent@@@std@@@0@00VCvContinent@@PAH@Z ENDP ; std::_Pop_heap<std::_Vector_iterator<CvContinent,std::allocator<CvContinent> >,int,CvContinent>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T247049 = -2092					; size = 4
$T247048 = -2088					; size = 4
$T247047 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T247047[ebp], eax
	mov	ecx, DWORD PTR $T247047[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T247048[ebp], eax
	mov	eax, DWORD PTR $T247048[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T247049[ebp], eax
	mov	ecx, DWORD PTR $T247049[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T247068 = -8						; size = 4
$T247064 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T247064[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T247064[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T247068[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T247068[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
