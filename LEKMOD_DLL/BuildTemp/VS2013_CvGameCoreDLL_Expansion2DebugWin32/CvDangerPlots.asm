; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDangerPlots.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
PUBLIC	??0CvDangerPlots@@QAE@XZ			; CvDangerPlots::CvDangerPlots
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
;	COMDAT ??0CvDangerPlots@@QAE@XZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T222286 = -52						; size = 4
$T222282 = -48						; size = 4
$T222278 = -44						; size = 4
$T222274 = -40						; size = 4
$T222270 = -36						; size = 4
$T222266 = -32						; size = 4
$T222262 = -28						; size = 4
$T222258 = -24						; size = 4
$T222254 = -20						; size = 4
$T222250 = -16						; size = 4
$T222246 = -12						; size = 4
??0CvDangerPlots@@QAE@XZ PROC				; CvDangerPlots::CvDangerPlots, COMDAT
; _this$ = ecx

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>

; 36   : 	m_fMajorWarMod = GC.getAI_DANGER_MAJOR_APPROACH_WAR();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8048
	movss	DWORD PTR $T222246[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222246[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [eax+8], xmm0

; 37   : 	m_fMajorHostileMod = GC.getAI_DANGER_MAJOR_APPROACH_HOSTILE();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8052
	movss	DWORD PTR $T222250[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222250[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+16], xmm0

; 38   : 	m_fMajorDeceptiveMod = GC.getAI_DANGER_MAJOR_APPROACH_DECEPTIVE();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8056
	movss	DWORD PTR $T222254[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222254[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [edx+24], xmm0

; 39   : 	m_fMajorGuardedMod = GC.getAI_DANGER_MAJOR_APPROACH_GUARDED();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8060
	movss	DWORD PTR $T222258[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222258[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [eax+32], xmm0

; 40   : 	m_fMajorAfraidMod = GC.getAI_DANGER_MAJOR_APPROACH_AFRAID();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8064
	movss	DWORD PTR $T222262[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222262[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+40], xmm0

; 41   : 	m_fMajorFriendlyMod = GC.getAI_DANGER_MAJOR_APPROACH_FRIENDLY();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8068
	movss	DWORD PTR $T222266[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222266[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [edx+48], xmm0

; 42   : 	m_fMajorNeutralMod = GC.getAI_DANGER_MAJOR_APPROACH_NEUTRAL();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8072
	movss	DWORD PTR $T222270[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222270[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [eax+56], xmm0

; 43   : 	m_fMinorNeutralrMod = GC.getAI_DANGER_MINOR_APPROACH_NEUTRAL();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8076
	movss	DWORD PTR $T222274[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222274[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+64], xmm0

; 44   : 	m_fMinorFriendlyMod = GC.getAI_DANGER_MINOR_APPROACH_FRIENDLY();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8080
	movss	DWORD PTR $T222278[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222278[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [edx+72], xmm0

; 45   : 	m_fMinorBullyMod = GC.getAI_DANGER_MINOR_APPROACH_BULLY();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8084
	movss	DWORD PTR $T222282[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222282[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [eax+80], xmm0

; 46   : 	m_fMinorConquestMod = GC.getAI_DANGER_MINOR_APPROACH_CONQUEST();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8088
	movss	DWORD PTR $T222286[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222286[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	QWORD PTR [ecx+88], xmm0

; 47   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvDangerPlots@@QAE@XZ ENDP				; CvDangerPlots::CvDangerPlots
_TEXT	ENDS
PUBLIC	??1?$BaseVector@I$00@@QAE@XZ			; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>
PUBLIC	??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
PUBLIC	?Uninit@CvDangerPlots@@QAEXXZ			; CvDangerPlots::Uninit
PUBLIC	??1CvDangerPlots@@QAE@XZ			; CvDangerPlots::~CvDangerPlots
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvDangerPlots@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvDangerPlots@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvDangerPlots@@QAE@XZ$1
__ehfuncinfo$??1CvDangerPlots@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvDangerPlots@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
xdata$x	ENDS
;	COMDAT ??1CvDangerPlots@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T222338 = -28						; size = 4
$T222318 = -24						; size = 4
$T222317 = -20						; size = 4
_i$222327 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvDangerPlots@@QAE@XZ PROC				; CvDangerPlots::~CvDangerPlots, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvDangerPlots@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 52   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvDangerPlots@@QAEXXZ		; CvDangerPlots::Uninit

; 53   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR $T222338[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T222338[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T222318[ebp], edx
	mov	eax, DWORD PTR $T222338[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T222317[ebp], ecx
	xor	edx, edx
	je	SHORT $LN7@CvDangerPl
	xor	eax, eax
	je	SHORT $LN7@CvDangerPl
	mov	DWORD PTR _i$222327[ebp], 0
	jmp	SHORT $LN12@CvDangerPl
$LN11@CvDangerPl:
	mov	ecx, DWORD PTR _i$222327[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$222327[ebp], ecx
$LN12@CvDangerPl:
	mov	edx, DWORD PTR _i$222327[ebp]
	cmp	edx, DWORD PTR $T222318[ebp]
	jae	SHORT $LN7@CvDangerPl
	jmp	SHORT $LN11@CvDangerPl
$LN7@CvDangerPl:
	mov	eax, DWORD PTR $T222317[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvDangerPlots@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvDangerPlots@@QAE@XZ$1:
	mov	ecx, DWORD PTR $T222338[ebp]
	jmp	??1?$BaseVector@I$00@@QAE@XZ		; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>
__ehhandler$??1CvDangerPlots@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvDangerPlots@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvDangerPlots@@QAE@XZ ENDP				; CvDangerPlots::~CvDangerPlots
PUBLIC	?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
PUBLIC	?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z	; CvDangerPlots::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
tv226 = -56						; size = 4
_this$ = -52						; size = 4
$T222386 = -48						; size = 4
$T222385 = -44						; size = 4
$T222376 = -40						; size = 4
$T222379 = -36						; size = 4
$T222355 = -12						; size = 4
_i$221640 = -8						; size = 4
_iGridSize$221639 = -4					; size = 4
_ePlayer$ = 8						; size = 4
_bAllocate$ = 12					; size = 1
?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z PROC	; CvDangerPlots::Init, COMDAT
; _this$ = ecx

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvDangerPlots@@QAEXXZ		; CvDangerPlots::Uninit

; 59   : 	m_ePlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax], ecx

; 60   : 
; 61   : 	if(bAllocate)

	movzx	edx, BYTE PTR _bAllocate$[ebp]
	test	edx, edx
	je	$LN5@Init

; 62   : 	{
; 63   : 		int iGridSize = GC.getMap().numPlots();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222355[ebp], eax
	mov	ecx, DWORD PTR $T222355[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iGridSize$221639[ebp], edx

; 64   : 		CvAssertMsg(iGridSize > 0, "iGridSize is zero");
; 65   : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 66   : 		m_DangerPlots = FNEW(uint[iGridSize], c_eCiv5GameplayDLL, 0);
; 67   : 		fill(m_DangerPlots, &m_DangerPlots[iGridSize - 1], 0);
; 68   : #else
; 69   : 		m_DangerPlots.resize(iGridSize);

	mov	eax, DWORD PTR _iGridSize$221639[ebp]
	mov	DWORD PTR $T222386[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR $T222385[ebp], ecx
	mov	edx, DWORD PTR $T222385[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR $T222386[ebp]
	jae	SHORT $LN11@Init
	mov	ecx, DWORD PTR $T222386[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222385[ebp]
	call	?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
$LN11@Init:
	mov	edx, DWORD PTR $T222385[ebp]
	add	edx, 8
	mov	DWORD PTR $T222376[ebp], edx
	mov	eax, DWORD PTR $T222376[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T222386[ebp]
	jae	SHORT $LN33@Init
	mov	edx, DWORD PTR $T222376[ebp]
	mov	DWORD PTR tv226[ebp], edx
	jmp	SHORT $LN34@Init
$LN33@Init:
	lea	eax, DWORD PTR $T222386[ebp]
	mov	DWORD PTR tv226[ebp], eax
$LN34@Init:
	mov	ecx, DWORD PTR tv226[ebp]
	mov	DWORD PTR $T222379[ebp], ecx
	mov	edx, DWORD PTR $T222385[ebp]
	mov	eax, DWORD PTR $T222379[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 70   : 		m_bArrayAllocated = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 1

; 71   : 		for(int i = 0; i < iGridSize; i++)

	mov	DWORD PTR _i$221640[ebp], 0
	jmp	SHORT $LN3@Init
$LN2@Init:
	mov	eax, DWORD PTR _i$221640[ebp]
	add	eax, 1
	mov	DWORD PTR _i$221640[ebp], eax
$LN3@Init:
	mov	ecx, DWORD PTR _i$221640[ebp]
	cmp	ecx, DWORD PTR _iGridSize$221639[ebp]
	jge	SHORT $LN5@Init

; 72   : 		{
; 73   : 			m_DangerPlots[i] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR _i$221640[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 74   : 		}

	jmp	SHORT $LN2@Init
$LN5@Init:

; 75   : #endif
; 76   : 	}
; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z ENDP	; CvDangerPlots::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@CvDangerPlots@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T222410 = -8						; size = 4
_i$222405 = -4						; size = 4
?Uninit@CvDangerPlots@@QAEXXZ PROC			; CvDangerPlots::Uninit, COMDAT
; _this$ = ecx

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	m_ePlayer = NO_PLAYER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1

; 83   : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 84   : 	if (m_DangerPlots)
; 85   : 		SAFE_DELETE_ARRAY(m_DangerPlots);
; 86   : #else
; 87   : 	m_DangerPlots.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	mov	DWORD PTR $T222410[ebp], ecx
	xor	edx, edx
	je	SHORT $LN9@Uninit
	mov	DWORD PTR _i$222405[ebp], 0
	jmp	SHORT $LN7@Uninit
$LN6@Uninit:
	mov	eax, DWORD PTR _i$222405[ebp]
	add	eax, 1
	mov	DWORD PTR _i$222405[ebp], eax
$LN7@Uninit:
	mov	ecx, DWORD PTR $T222410[ebp]
	mov	edx, DWORD PTR _i$222405[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN9@Uninit
	jmp	SHORT $LN6@Uninit
$LN9@Uninit:
	mov	eax, DWORD PTR $T222410[ebp]
	mov	DWORD PTR [eax+4], 0

; 88   : 	m_bArrayAllocated = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0

; 89   : #endif
; 90   : 	m_bDirty = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvDangerPlots@@QAEXXZ ENDP			; CvDangerPlots::Uninit
_TEXT	ENDS
PUBLIC	?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z	; CvDangerPlots::GetCityDanger
PUBLIC	?AddDanger@CvDangerPlots@@QAEXHHH_N@Z		; CvDangerPlots::AddDanger
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z ; CvDangerPlots::ShouldIgnoreCitadel
PUBLIC	?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ	; CvDangerPlots::GetDangerValueOfCitadel
PUBLIC	?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z ; CvDangerPlots::AssignCityDangerValue
PUBLIC	?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z ; CvDangerPlots::ShouldIgnoreCity
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
PUBLIC	?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ; CvDangerPlots::AssignUnitDangerValue
PUBLIC	?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z ; CvDangerPlots::ShouldIgnoreUnit
PUBLIC	?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z ; CvDangerPlots::ShouldIgnorePlayer
PUBLIC	?UpdateDanger@CvDangerPlots@@QAEX_N0@Z		; CvDangerPlots::UpdateDanger
EXTRN	?SetThreatValue@CvCity@@QAEXH@Z:PROC		; CvCity::SetThreatValue
EXTRN	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetNearbyEnemyDamage
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedImprovementType
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z:PROC	; CvUnit::canRangeStrikeAt
EXTRN	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canMoveOrAttackInto
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?canRangeStrike@CvUnit@@QBE_NXZ:PROC		; CvUnit::canRangeStrike
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
;	COMDAT ?UpdateDanger@CvDangerPlots@@QAEX_N0@Z
_TEXT	SEGMENT
_this$ = -400						; size = 4
$T222881 = -396						; size = 4
$T222684 = -312						; size = 4
$T222680 = -308						; size = 4
_uiOffset$222675 = -304					; size = 4
$T222663 = -300						; size = 4
$T222659 = -296						; size = 4
$T222655 = -292						; size = 4
$T222559 = -220						; size = 4
$T222555 = -216						; size = 4
$T222548 = -212						; size = 4
$T222544 = -208						; size = 4
$T222461 = -136						; size = 4
$T222457 = -132						; size = 4
$T222453 = -125						; size = 1
$T222416 = -124						; size = 4
_iThreatValue$221731 = -120				; size = 4
_iI$221720 = -116					; size = 4
_eImprovement$221717 = -112				; size = 4
_iDY$221704 = -108					; size = 4
_iDX$221700 = -104					; size = 4
_pCityPlot$221698 = -100				; size = 4
_iRange$221697 = -96					; size = 4
_pLoopPlot$221699 = -92					; size = 4
_iDY$221685 = -88					; size = 4
_iDX$221681 = -84					; size = 4
_pUnitPlot$221679 = -80					; size = 4
_iRange$221677 = -76					; size = 4
_pLoopPlot$221680 = -72					; size = 4
_ePlayer$221664 = -68					; size = 4
_pLoopUnit$221672 = -64					; size = 4
_loopPlayer$221666 = -60				; size = 4
_eTeam$221667 = -56					; size = 4
_pLoopCity$221692 = -52					; size = 4
_iLoop$221671 = -48					; size = 4
_iPlayer$221660 = -44					; size = 4
_i$221654 = -40						; size = 4
_iGridSize$ = -36					; size = 4
_iLoopCity$ = -32					; size = 4
_thisTeam$ = -28					; size = 4
_pPlot$ = -24						; size = 4
_iPlotLoop$ = -20					; size = 4
_thisPlayer$ = -16					; size = 4
_pAdjacentPlot$ = -12					; size = 4
_pLoopCity$ = -8					; size = 4
_iCitadelValue$ = -4					; size = 4
_bPretendWarWithAllCivs$ = 8				; size = 1
_bIgnoreVisibility$ = 12				; size = 1
?UpdateDanger@CvDangerPlots@@QAEX_N0@Z PROC		; CvDangerPlots::UpdateDanger, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	// danger plots have not been initialized yet, so no need to update
; 97   : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 98   : 	if (!m_DangerPlots)
; 99   : #else
; 100  : 	if(!m_bArrayAllocated)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN48@UpdateDang

; 101  : #endif
; 102  : 	{
; 103  : 		return;

	jmp	$LN49@UpdateDang
$LN48@UpdateDang:

; 104  : 	}
; 105  : 
; 106  : 	// wipe out values
; 107  : 	int iGridSize = GC.getMap().numPlots();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222416[ebp], edx
	mov	eax, DWORD PTR $T222416[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iGridSize$[ebp], ecx

; 108  : 	CvAssertMsg(iGridSize == m_DangerPlots.size(), "iGridSize does not match number of DangerPlots");
; 109  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 110  : 	fill(m_DangerPlots, &m_DangerPlots[iGridSize - 1], 0);
; 111  : #else
; 112  : 	for(int i = 0; i < iGridSize; i++)

	mov	DWORD PTR _i$221654[ebp], 0
	jmp	SHORT $LN47@UpdateDang
$LN46@UpdateDang:
	mov	edx, DWORD PTR _i$221654[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221654[ebp], edx
$LN47@UpdateDang:
	mov	eax, DWORD PTR _i$221654[ebp]
	cmp	eax, DWORD PTR _iGridSize$[ebp]
	jge	SHORT $LN57@UpdateDang

; 113  : 	{
; 114  : 		m_DangerPlots[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _i$221654[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 115  : 	}

	jmp	SHORT $LN46@UpdateDang

; 116  : #endif
; 117  : 
; 118  : 	CvPlayer& thisPlayer = GET_PLAYER(m_ePlayer);

$LN57@UpdateDang:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[ebp], edx

; 119  : 	TeamTypes thisTeam = thisPlayer.getTeam();

	mov	eax, DWORD PTR _thisPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _thisTeam$[ebp], eax

; 120  : 
; 121  : 	// for each opposing civ
; 122  : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)

	mov	DWORD PTR _iPlayer$221660[ebp], 0
	jmp	SHORT $LN44@UpdateDang
$LN43@UpdateDang:
	mov	edx, DWORD PTR _iPlayer$221660[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlayer$221660[ebp], edx
$LN44@UpdateDang:
	cmp	DWORD PTR _iPlayer$221660[ebp], 64	; 00000040H
	jge	$LN42@UpdateDang

; 123  : 	{
; 124  : 		PlayerTypes ePlayer = (PlayerTypes)iPlayer;

	mov	eax, DWORD PTR _iPlayer$221660[ebp]
	mov	DWORD PTR _ePlayer$221664[ebp], eax

; 125  : 		CvPlayer& loopPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$221664[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _loopPlayer$221666[ebp], ecx

; 126  : 		TeamTypes eTeam = loopPlayer.getTeam();

	mov	edx, DWORD PTR _loopPlayer$221666[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$221667[ebp], eax

; 127  : 
; 128  : 		if(!loopPlayer.isAlive())

	mov	ecx, DWORD PTR _loopPlayer$221666[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T222453[ebp], dl
	movzx	eax, BYTE PTR $T222453[ebp]
	test	eax, eax
	jne	SHORT $LN41@UpdateDang

; 129  : 		{
; 130  : 			continue;

	jmp	SHORT $LN43@UpdateDang
$LN41@UpdateDang:

; 131  : 		}
; 132  : 
; 133  : 		if(eTeam == thisTeam)

	mov	ecx, DWORD PTR _eTeam$221667[ebp]
	cmp	ecx, DWORD PTR _thisTeam$[ebp]
	jne	SHORT $LN40@UpdateDang

; 134  : 		{
; 135  : 			continue;

	jmp	SHORT $LN43@UpdateDang
$LN40@UpdateDang:

; 136  : 		}
; 137  : 
; 138  : 		if(ShouldIgnorePlayer(ePlayer) && !bPretendWarWithAllCivs)

	mov	edx, DWORD PTR _ePlayer$221664[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z ; CvDangerPlots::ShouldIgnorePlayer
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN39@UpdateDang
	movzx	ecx, BYTE PTR _bPretendWarWithAllCivs$[ebp]
	test	ecx, ecx
	jne	SHORT $LN39@UpdateDang

; 139  : 		{
; 140  : 			continue;

	jmp	SHORT $LN43@UpdateDang
$LN39@UpdateDang:

; 141  : 		}
; 142  : 
; 143  : 		//for each unit
; 144  : 		int iLoop;
; 145  : 		CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$221672[ebp], 0

; 146  : 		for(pLoopUnit = loopPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = loopPlayer.nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$221671[ebp]
	push	edx
	mov	ecx, DWORD PTR _loopPlayer$221666[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$221672[ebp], eax
	jmp	SHORT $LN38@UpdateDang
$LN37@UpdateDang:
	push	0
	lea	eax, DWORD PTR _iLoop$221671[ebp]
	push	eax
	mov	ecx, DWORD PTR _loopPlayer$221666[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$221672[ebp], eax
$LN38@UpdateDang:
	cmp	DWORD PTR _pLoopUnit$221672[ebp], 0
	je	$LN36@UpdateDang

; 147  : 		{
; 148  : 			if(ShouldIgnoreUnit(pLoopUnit, bIgnoreVisibility))

	movzx	ecx, BYTE PTR _bIgnoreVisibility$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopUnit$221672[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z ; CvDangerPlots::ShouldIgnoreUnit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN35@UpdateDang

; 149  : 			{
; 150  : 				continue;

	jmp	SHORT $LN37@UpdateDang
$LN35@UpdateDang:

; 151  : 			}
; 152  : 
; 153  : 			int iRange = pLoopUnit->baseMoves();

	push	-1
	mov	ecx, DWORD PTR _pLoopUnit$221672[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	mov	DWORD PTR _iRange$221677[ebp], eax

; 154  : 			if(pLoopUnit->canRangeStrike())

	mov	ecx, DWORD PTR _pLoopUnit$221672[ebp]
	call	?canRangeStrike@CvUnit@@QBE_NXZ		; CvUnit::canRangeStrike
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@UpdateDang

; 155  : 			{
; 156  : 				iRange += pLoopUnit->GetRange();

	mov	ecx, DWORD PTR _pLoopUnit$221672[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	add	eax, DWORD PTR _iRange$221677[ebp]
	mov	DWORD PTR _iRange$221677[ebp], eax
$LN34@UpdateDang:

; 157  : 			}
; 158  : 
; 159  : 			CvPlot* pUnitPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$221672[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pUnitPlot$221679[ebp], eax

; 160  : 			AssignUnitDangerValue(pLoopUnit, pUnitPlot);

	mov	edx, DWORD PTR _pUnitPlot$221679[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$221672[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ; CvDangerPlots::AssignUnitDangerValue

; 161  : 			CvPlot* pLoopPlot = NULL;

	mov	DWORD PTR _pLoopPlot$221680[ebp], 0

; 162  : 
; 163  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 164  : 			for (int iDY = -iRange; iDY <= iRange; iDY++)
; 165  : 			{
; 166  : 				int iMaxDX = iRange - MAX(0, iDY);
; 167  : 				for (int iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 168  : 				{
; 169  : 					// No need for range check because loops are set up properly
; 170  : 					pLoopPlot = plotXY(pUnitPlot->getX(), pUnitPlot->getY(), iDX, iDY);
; 171  : #else
; 172  : 			for(int iDX = -(iRange); iDX <= iRange; iDX++)

	mov	ecx, DWORD PTR _iRange$221677[ebp]
	neg	ecx
	mov	DWORD PTR _iDX$221681[ebp], ecx
	jmp	SHORT $LN33@UpdateDang
$LN32@UpdateDang:
	mov	edx, DWORD PTR _iDX$221681[ebp]
	add	edx, 1
	mov	DWORD PTR _iDX$221681[ebp], edx
$LN33@UpdateDang:
	mov	eax, DWORD PTR _iDX$221681[ebp]
	cmp	eax, DWORD PTR _iRange$221677[ebp]
	jg	$LN31@UpdateDang

; 173  : 			{
; 174  : 				for(int iDY = -(iRange); iDY <= iRange; iDY++)

	mov	ecx, DWORD PTR _iRange$221677[ebp]
	neg	ecx
	mov	DWORD PTR _iDY$221685[ebp], ecx
	jmp	SHORT $LN30@UpdateDang
$LN29@UpdateDang:
	mov	edx, DWORD PTR _iDY$221685[ebp]
	add	edx, 1
	mov	DWORD PTR _iDY$221685[ebp], edx
$LN30@UpdateDang:
	mov	eax, DWORD PTR _iDY$221685[ebp]
	cmp	eax, DWORD PTR _iRange$221677[ebp]
	jg	$LN28@UpdateDang

; 175  : 				{
; 176  : 					pLoopPlot = plotXYWithRangeCheck(pUnitPlot->getX(), pUnitPlot->getY(), iDX, iDY, iRange);

	mov	ecx, DWORD PTR _pUnitPlot$221679[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T222457[ebp], edx
	mov	eax, DWORD PTR _pUnitPlot$221679[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T222461[ebp], ecx
	mov	edx, DWORD PTR _iRange$221677[ebp]
	push	edx
	mov	eax, DWORD PTR _iDY$221685[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$221681[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222457[ebp]
	push	edx
	mov	eax, DWORD PTR $T222461[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$221680[ebp], eax

; 177  : #endif
; 178  : 					if(!pLoopPlot || pLoopPlot == pUnitPlot)

	cmp	DWORD PTR _pLoopPlot$221680[ebp], 0
	je	SHORT $LN26@UpdateDang
	mov	ecx, DWORD PTR _pLoopPlot$221680[ebp]
	cmp	ecx, DWORD PTR _pUnitPlot$221679[ebp]
	jne	SHORT $LN27@UpdateDang
$LN26@UpdateDang:

; 179  : 					{
; 180  : 						continue;

	jmp	SHORT $LN29@UpdateDang
$LN27@UpdateDang:

; 181  : 					}
; 182  : 
; 183  : 					if(!pLoopUnit->canMoveOrAttackInto(*pLoopPlot) && !pLoopUnit->canRangeStrikeAt(pLoopPlot->getX(),pLoopPlot->getY()))

	push	0
	mov	edx, DWORD PTR _pLoopPlot$221680[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$221672[ebp]
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@UpdateDang
	mov	ecx, DWORD PTR _pLoopPlot$221680[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T222544[ebp], edx
	mov	eax, DWORD PTR _pLoopPlot$221680[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T222548[ebp], ecx
	push	1
	push	1
	mov	edx, DWORD PTR $T222544[ebp]
	push	edx
	mov	eax, DWORD PTR $T222548[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$221672[ebp]
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@UpdateDang

; 184  : 					{
; 185  : 						continue;

	jmp	$LN29@UpdateDang
$LN25@UpdateDang:

; 186  : 					}
; 187  : 
; 188  : 					AssignUnitDangerValue(pLoopUnit, pLoopPlot);

	mov	edx, DWORD PTR _pLoopPlot$221680[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$221672[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ; CvDangerPlots::AssignUnitDangerValue

; 189  : 				}

	jmp	$LN29@UpdateDang
$LN28@UpdateDang:

; 190  : 			}

	jmp	$LN32@UpdateDang
$LN31@UpdateDang:

; 191  : 		}

	jmp	$LN37@UpdateDang
$LN36@UpdateDang:

; 192  : 
; 193  : 		// for each city
; 194  : 		CvCity* pLoopCity;
; 195  : 		for(pLoopCity = loopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = loopPlayer.nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$221671[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loopPlayer$221666[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$221692[ebp], eax
	jmp	SHORT $LN24@UpdateDang
$LN23@UpdateDang:
	push	0
	lea	edx, DWORD PTR _iLoop$221671[ebp]
	push	edx
	mov	ecx, DWORD PTR _loopPlayer$221666[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$221692[ebp], eax
$LN24@UpdateDang:
	cmp	DWORD PTR _pLoopCity$221692[ebp], 0
	je	$LN22@UpdateDang

; 196  : 		{
; 197  : 			if(ShouldIgnoreCity(pLoopCity, bIgnoreVisibility))

	movzx	eax, BYTE PTR _bIgnoreVisibility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$221692[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z ; CvDangerPlots::ShouldIgnoreCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@UpdateDang

; 198  : 			{
; 199  : 				continue;

	jmp	SHORT $LN23@UpdateDang
$LN21@UpdateDang:

; 200  : 			}
; 201  : 
; 202  : 			int iRange = GC.getCITY_ATTACK_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7488
	mov	DWORD PTR _iRange$221697[ebp], eax

; 203  : 			CvPlot* pCityPlot = pLoopCity->plot();

	mov	ecx, DWORD PTR _pLoopCity$221692[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pCityPlot$221698[ebp], eax

; 204  : 			AssignCityDangerValue(pLoopCity, pCityPlot);

	mov	ecx, DWORD PTR _pCityPlot$221698[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopCity$221692[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z ; CvDangerPlots::AssignCityDangerValue

; 205  : 			CvPlot* pLoopPlot = NULL;

	mov	DWORD PTR _pLoopPlot$221699[ebp], 0

; 206  : 
; 207  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 208  : 			int iMaxDX, iDX;
; 209  : 			for (int iDY = -iRange; iDY <= iRange; iDY++)
; 210  : 			{
; 211  : 				iMaxDX = iRange - MAX(0, iDY);
; 212  : 				for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 213  : 				{
; 214  : 					// No need for range check because loops are set up properly
; 215  : 					pLoopPlot = plotXY(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY);
; 216  : #else
; 217  : 			for(int iDX = -(iRange); iDX <= iRange; iDX++)

	mov	eax, DWORD PTR _iRange$221697[ebp]
	neg	eax
	mov	DWORD PTR _iDX$221700[ebp], eax
	jmp	SHORT $LN20@UpdateDang
$LN19@UpdateDang:
	mov	ecx, DWORD PTR _iDX$221700[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDX$221700[ebp], ecx
$LN20@UpdateDang:
	mov	edx, DWORD PTR _iDX$221700[ebp]
	cmp	edx, DWORD PTR _iRange$221697[ebp]
	jg	SHORT $LN18@UpdateDang

; 218  : 			{
; 219  : 				for(int iDY = -(iRange); iDY <= iRange; iDY++)

	mov	eax, DWORD PTR _iRange$221697[ebp]
	neg	eax
	mov	DWORD PTR _iDY$221704[ebp], eax
	jmp	SHORT $LN17@UpdateDang
$LN16@UpdateDang:
	mov	ecx, DWORD PTR _iDY$221704[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$221704[ebp], ecx
$LN17@UpdateDang:
	mov	edx, DWORD PTR _iDY$221704[ebp]
	cmp	edx, DWORD PTR _iRange$221697[ebp]
	jg	SHORT $LN15@UpdateDang

; 220  : 				{
; 221  : 					pLoopPlot = plotXYWithRangeCheck(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY, iRange);

	mov	eax, DWORD PTR _pCityPlot$221698[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T222555[ebp], ecx
	mov	edx, DWORD PTR _pCityPlot$221698[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T222559[ebp], eax
	mov	ecx, DWORD PTR _iRange$221697[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDY$221704[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$221700[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222555[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222559[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$221699[ebp], eax

; 222  : #endif
; 223  : 					if(!pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$221699[ebp], 0
	jne	SHORT $LN14@UpdateDang

; 224  : 					{
; 225  : 						continue;

	jmp	SHORT $LN16@UpdateDang
$LN14@UpdateDang:

; 226  : 					}
; 227  : 
; 228  : 					AssignCityDangerValue(pLoopCity, pLoopPlot);

	mov	eax, DWORD PTR _pLoopPlot$221699[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$221692[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z ; CvDangerPlots::AssignCityDangerValue

; 229  : 				}

	jmp	SHORT $LN16@UpdateDang
$LN15@UpdateDang:

; 230  : 			}

	jmp	$LN19@UpdateDang
$LN18@UpdateDang:

; 231  : 		}

	jmp	$LN23@UpdateDang
$LN22@UpdateDang:

; 232  : 	}

	jmp	$LN43@UpdateDang
$LN42@UpdateDang:

; 233  : 
; 234  : 	// Citadels
; 235  : 	int iCitadelValue = GetDangerValueOfCitadel();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ ; CvDangerPlots::GetDangerValueOfCitadel
	mov	DWORD PTR _iCitadelValue$[ebp], eax

; 236  : #ifdef AUI_WARNING_FIXES
; 237  : 	uint iPlotLoop;
; 238  : #else
; 239  : 	int iPlotLoop;
; 240  : #endif
; 241  : 	CvPlot* pPlot, *pAdjacentPlot;
; 242  : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$[ebp], 0
	jmp	SHORT $LN13@UpdateDang
$LN12@UpdateDang:
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotLoop$[ebp], edx
$LN13@UpdateDang:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222655[ebp], eax
	mov	ecx, DWORD PTR $T222655[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T222659[ebp], edx
	mov	eax, DWORD PTR _iPlotLoop$[ebp]
	cmp	eax, DWORD PTR $T222659[ebp]
	jge	$LN11@UpdateDang

; 243  : 	{
; 244  : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222663[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T222663[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pPlot$[ebp], edx

; 245  : 
; 246  : 		if(pPlot->isRevealed(thisTeam))

	mov	ecx, DWORD PTR _thisTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$222675[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$222675[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _thisTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$222675[ebp]
	mov	edx, DWORD PTR _pPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@UpdateDang

; 247  : 		{
; 248  : 			ImprovementTypes eImprovement = pPlot->getRevealedImprovementType(thisTeam);

	mov	edx, DWORD PTR _thisTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	mov	DWORD PTR _eImprovement$221717[ebp], eax

; 249  : 			if(eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement)->GetNearbyEnemyDamage() > 0)

	cmp	DWORD PTR _eImprovement$221717[ebp], -1
	je	$LN10@UpdateDang
	mov	eax, DWORD PTR _eImprovement$221717[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
	test	eax, eax
	jle	$LN10@UpdateDang

; 250  : 			{
; 251  : 				if(!ShouldIgnoreCitadel(pPlot, bIgnoreVisibility))

	movzx	ecx, BYTE PTR _bIgnoreVisibility$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z ; CvDangerPlots::ShouldIgnoreCitadel
	movzx	eax, al
	test	eax, eax
	jne	$LN10@UpdateDang

; 252  : 				{
; 253  : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$221720[ebp], 0
	jmp	SHORT $LN7@UpdateDang
$LN6@UpdateDang:
	mov	ecx, DWORD PTR _iI$221720[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221720[ebp], ecx
$LN7@UpdateDang:
	cmp	DWORD PTR _iI$221720[ebp], 6
	jge	SHORT $LN10@UpdateDang

; 254  : 					{
; 255  : 						pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T222680[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T222684[ebp], edx
	mov	eax, DWORD PTR _iI$221720[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222680[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222684[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 256  : 
; 257  : 						if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN4@UpdateDang

; 258  : 						{
; 259  : 							AddDanger(pAdjacentPlot->getX(), pAdjacentPlot->getY(), iCitadelValue, true);

	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T222881[ebp], ecx
	push	1
	mov	edx, DWORD PTR _iCitadelValue$[ebp]
	push	edx
	mov	eax, DWORD PTR $T222881[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddDanger@CvDangerPlots@@QAEXHHH_N@Z	; CvDangerPlots::AddDanger
$LN4@UpdateDang:

; 260  : 						}
; 261  : 					}

	jmp	SHORT $LN6@UpdateDang
$LN10@UpdateDang:

; 262  : 				}
; 263  : 			}
; 264  : 		}
; 265  : 	}

	jmp	$LN12@UpdateDang
$LN11@UpdateDang:

; 266  : 
; 267  : 	// testing city danger values
; 268  : 	CvCity* pLoopCity;
; 269  : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 270  : 	for(pLoopCity = thisPlayer.firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = thisPlayer.nextCity(&iLoopCity))

	push	0
	lea	eax, DWORD PTR _iLoopCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN3@UpdateDang
$LN2@UpdateDang:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN3@UpdateDang:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN1@UpdateDang

; 271  : 	{
; 272  : 		int iThreatValue = GetCityDanger(pLoopCity);

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z ; CvDangerPlots::GetCityDanger
	mov	DWORD PTR _iThreatValue$221731[ebp], eax

; 273  : 		pLoopCity->SetThreatValue(iThreatValue);

	mov	eax, DWORD PTR _iThreatValue$221731[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?SetThreatValue@CvCity@@QAEXH@Z		; CvCity::SetThreatValue

; 274  : 	}

	jmp	SHORT $LN2@UpdateDang
$LN1@UpdateDang:

; 275  : 
; 276  : 	m_bDirty = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+5], 0
$LN49@UpdateDang:

; 277  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?UpdateDanger@CvDangerPlots@@QAEX_N0@Z ENDP		; CvDangerPlots::UpdateDanger
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T223091 = -80						; size = 4
$T223046 = -76						; size = 4
$T223033 = -72						; size = 4
$T223029 = -68						; size = 4
$T223015 = -64						; size = 4
$T223011 = -57						; size = 1
$T223000 = -56						; size = 4
$T222996 = -49						; size = 1
_iMapY$223055 = -48					; size = 4
_iMapX$223054 = -44					; size = 4
$T222989 = -40						; size = 4
$T222965 = -36						; size = 4
$T222928 = -32						; size = 4
$T222916 = -28						; size = 4
$T222912 = -21						; size = 1
$T222901 = -20						; size = 4
$T222897 = -13						; size = 1
_iMapY$222964 = -12					; size = 4
_iMapX$222963 = -8					; size = 4
$T222890 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222890[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T222965[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T222890[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T222897[ebp], dl
	mov	eax, DWORD PTR $T222890[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T222901[ebp], ecx
	movzx	edx, BYTE PTR $T222897[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T222901[ebp]
	add	edx, DWORD PTR $T222901[ebp]
	mov	DWORD PTR _iMapX$222963[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T222901[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T222901[ebp]
	mov	DWORD PTR _iMapX$222963[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$222963[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T222890[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T222912[ebp], al
	mov	ecx, DWORD PTR $T222890[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T222916[ebp], edx
	movzx	eax, BYTE PTR $T222912[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T222916[ebp]
	add	edx, DWORD PTR $T222916[ebp]
	mov	DWORD PTR _iMapY$222964[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T222916[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T222916[ebp]
	mov	DWORD PTR _iMapY$222964[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$222964[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$222964[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$222963[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222890[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T222890[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T222928[ebp], eax
	mov	ecx, DWORD PTR _iMapY$222964[ebp]
	imul	ecx, DWORD PTR $T222928[ebp]
	add	ecx, DWORD PTR _iMapX$222963[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T222890[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T222965[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T222965[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T222989[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T223091[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T222989[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T222996[ebp], dl
	mov	eax, DWORD PTR $T222989[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223000[ebp], ecx
	movzx	edx, BYTE PTR $T222996[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T223000[ebp]
	add	edx, DWORD PTR $T223000[ebp]
	mov	DWORD PTR _iMapX$223054[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T223000[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T223000[ebp]
	mov	DWORD PTR _iMapX$223054[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$223054[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T222989[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T223011[ebp], al
	mov	ecx, DWORD PTR $T222989[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T223015[ebp], edx
	movzx	eax, BYTE PTR $T223011[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T223015[ebp]
	add	edx, DWORD PTR $T223015[ebp]
	mov	DWORD PTR _iMapY$223055[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T223015[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T223015[ebp]
	mov	DWORD PTR _iMapY$223055[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$223055[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$223054[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T222989[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223029[ebp], ecx
	mov	edx, DWORD PTR _iMapX$223054[ebp]
	cmp	edx, DWORD PTR $T223029[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$223055[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T222989[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T223033[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223055[ebp]
	cmp	edx, DWORD PTR $T223033[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T222989[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223046[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223055[ebp]
	imul	edx, DWORD PTR $T223046[ebp]
	add	edx, DWORD PTR _iMapX$223054[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T222989[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T223091[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T223091[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216998 = -20					; size = 4
_iAbsDX$216997 = -16					; size = 4
_iAbsDY$216995 = -12					; size = 4
_iAbsDX$216994 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216994[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216995[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216994[ebp]
	add	edx, DWORD PTR _iAbsDY$216995[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216997[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216998[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216997[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216998[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216997[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216998[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T223346 = -56						; size = 4
$T223301 = -52						; size = 4
$T223288 = -48						; size = 4
$T223284 = -44						; size = 4
$T223270 = -40						; size = 4
$T223266 = -33						; size = 1
$T223255 = -32						; size = 4
$T223251 = -25						; size = 1
_iMapY$223345 = -24					; size = 4
_iMapX$223344 = -20					; size = 4
$T223244 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223244[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T223346[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T223244[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T223251[ebp], dl
	mov	eax, DWORD PTR $T223244[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223255[ebp], ecx
	movzx	edx, BYTE PTR $T223251[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T223255[ebp]
	add	edx, DWORD PTR $T223255[ebp]
	mov	DWORD PTR _iMapX$223344[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T223255[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T223255[ebp]
	mov	DWORD PTR _iMapX$223344[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$223344[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T223244[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T223266[ebp], al
	mov	ecx, DWORD PTR $T223244[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T223270[ebp], edx
	movzx	eax, BYTE PTR $T223266[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T223270[ebp]
	add	edx, DWORD PTR $T223270[ebp]
	mov	DWORD PTR _iMapY$223345[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T223270[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T223270[ebp]
	mov	DWORD PTR _iMapY$223345[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$223345[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$223344[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T223244[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223284[ebp], ecx
	mov	edx, DWORD PTR _iMapX$223344[ebp]
	cmp	edx, DWORD PTR $T223284[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$223345[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T223244[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T223288[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223345[ebp]
	cmp	edx, DWORD PTR $T223288[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T223244[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223301[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223345[ebp]
	imul	edx, DWORD PTR $T223301[ebp]
	add	edx, DWORD PTR _iMapX$223344[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T223244[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T223346[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T223346[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
_TEXT	ENDS
;	COMDAT ?AddDanger@CvDangerPlots@@QAEXHHH_N@Z
_TEXT	SEGMENT
tv83 = -20						; size = 4
_this$ = -16						; size = 4
$T223356 = -12						; size = 4
$T223352 = -8						; size = 4
_idx$ = -4						; size = 4
_iPlotX$ = 8						; size = 4
_iPlotY$ = 12						; size = 4
_iValue$ = 16						; size = 4
_bWithinOneMove$ = 20					; size = 1
?AddDanger@CvDangerPlots@@QAEXHHH_N@Z PROC		; CvDangerPlots::AddDanger, COMDAT
; _this$ = ecx

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 	const int idx = iPlotX + iPlotY * GC.getMap().getGridWidth();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223352[ebp], eax
	mov	ecx, DWORD PTR $T223352[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223356[ebp], edx
	mov	eax, DWORD PTR _iPlotY$[ebp]
	imul	eax, DWORD PTR $T223356[ebp]
	add	eax, DWORD PTR _iPlotX$[ebp]
	mov	DWORD PTR _idx$[ebp], eax

; 283  : #ifdef AUI_DANGER_PLOTS_FIX_ADD_DANGER_WITHIN_ONE_MOVE
; 284  : 	iValue &= ~0x1;
; 285  : #else
; 286  : 	if (iValue > 0)

	cmp	DWORD PTR _iValue$[ebp], 0
	jle	SHORT $LN10@AddDanger

; 287  : 	{
; 288  : 		if (bWithinOneMove)

	movzx	ecx, BYTE PTR _bWithinOneMove$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@AddDanger

; 289  : 		{
; 290  : 			iValue |= 0x1;

	mov	edx, DWORD PTR _iValue$[ebp]
	or	edx, 1
	mov	DWORD PTR _iValue$[ebp], edx

; 291  : 		}
; 292  : 		else

	jmp	SHORT $LN10@AddDanger
$LN2@AddDanger:

; 293  : 		{
; 294  : 			iValue &= ~0x1;

	mov	eax, DWORD PTR _iValue$[ebp]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR _iValue$[ebp], eax

; 295  : 		}
; 296  : 	}
; 297  : #endif
; 298  : 
; 299  : 	m_DangerPlots[idx] += iValue;

$LN10@AddDanger:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	eax, DWORD PTR _idx$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv83[ebp], ecx
	mov	edx, DWORD PTR tv83[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _iValue$[ebp]
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR [ecx], eax

; 300  : #ifdef AUI_DANGER_PLOTS_FIX_ADD_DANGER_WITHIN_ONE_MOVE
; 301  : 	if (bWithinOneMove)
; 302  : 	{
; 303  : 		m_DangerPlots[idx] |= 0x1;
; 304  : 	}
; 305  : #endif
; 306  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddDanger@CvDangerPlots@@QAEXHHH_N@Z ENDP		; CvDangerPlots::AddDanger
_TEXT	ENDS
PUBLIC	?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z	; CvDangerPlots::GetDanger
; Function compile flags: /Odtp
;	COMDAT ?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T223377 = -20						; size = 4
$T223373 = -16						; size = 4
$T223369 = -12						; size = 4
$T223365 = -8						; size = 4
_idx$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z PROC	; CvDangerPlots::GetDanger, COMDAT
; _this$ = ecx

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 	const int idx = pPlot.getX() + pPlot.getY() * GC.getMap().getGridWidth();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T223365[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T223369[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223373[ebp], ecx
	mov	edx, DWORD PTR $T223373[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223377[ebp], eax
	mov	ecx, DWORD PTR $T223369[ebp]
	imul	ecx, DWORD PTR $T223377[ebp]
	add	ecx, DWORD PTR $T223365[ebp]
	mov	DWORD PTR _idx$[ebp], ecx

; 312  : 	return m_DangerPlots[idx];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR _idx$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 313  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z ENDP	; CvDangerPlots::GetDanger
_TEXT	ENDS
PUBLIC	?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z ; CvDangerPlots::IsUnderImmediateThreat
; Function compile flags: /Odtp
;	COMDAT ?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z PROC ; CvDangerPlots::IsUnderImmediateThreat, COMDAT
; _this$ = ecx

; 317  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 318  : 	return GetDanger(pPlot) & 0x1;

	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z ; CvDangerPlots::GetDanger
	and	eax, 1

; 319  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z ENDP ; CvDangerPlots::IsUnderImmediateThreat
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T223395 = -32						; size = 4
$T223391 = -28						; size = 4
_pEvalPlot$221768 = -24					; size = 4
_iY$221764 = -20					; size = 4
_iX$221760 = -16					; size = 4
_iDangerValue$ = -12					; size = 4
_pPlot$ = -8						; size = 4
_iEvalRange$ = -4					; size = 4
_pCity$ = 8						; size = 4
?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z PROC	; CvDangerPlots::GetCityDanger, COMDAT
; _this$ = ecx

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 	CvAssertMsg(pCity, "pCity is null");
; 325  : 	if(!pCity) return 0;

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	SHORT $LN8@GetCityDan
	xor	eax, eax
	jmp	$LN9@GetCityDan
$LN8@GetCityDan:

; 326  : 
; 327  : 	CvAssertMsg(pCity->getOwner() == m_ePlayer, "City does not belong to us");
; 328  : 
; 329  : 	CvPlot* pPlot = pCity->plot();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pPlot$[ebp], eax

; 330  : 	int iEvalRange = GC.getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2704
	mov	DWORD PTR _iEvalRange$[ebp], eax

; 331  : 
; 332  : 	int iDangerValue = 0;

	mov	DWORD PTR _iDangerValue$[ebp], 0

; 333  : 
; 334  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 335  : 	CvPlot* pEvalPlot;
; 336  : 	for (int iDY = -iEvalRange; iDY <= iEvalRange; iDY++)
; 337  : 	{
; 338  : 		int iMaxDX = iEvalRange - MAX(0, iDY);
; 339  : 		for (int iDX = -iEvalRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 340  : 		{
; 341  : 			// No need for range check because loops are set up properly
; 342  : 			pEvalPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 343  : #else
; 344  : 	for(int iX = -iEvalRange; iX <= iEvalRange; iX++)

	mov	ecx, DWORD PTR _iEvalRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iX$221760[ebp], ecx
	jmp	SHORT $LN7@GetCityDan
$LN6@GetCityDan:
	mov	edx, DWORD PTR _iX$221760[ebp]
	add	edx, 1
	mov	DWORD PTR _iX$221760[ebp], edx
$LN7@GetCityDan:
	mov	eax, DWORD PTR _iX$221760[ebp]
	cmp	eax, DWORD PTR _iEvalRange$[ebp]
	jg	SHORT $LN5@GetCityDan

; 345  : 	{
; 346  : 		for(int iY = -iEvalRange; iY <= iEvalRange; iY++)

	mov	ecx, DWORD PTR _iEvalRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iY$221764[ebp], ecx
	jmp	SHORT $LN4@GetCityDan
$LN3@GetCityDan:
	mov	edx, DWORD PTR _iY$221764[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$221764[ebp], edx
$LN4@GetCityDan:
	mov	eax, DWORD PTR _iY$221764[ebp]
	cmp	eax, DWORD PTR _iEvalRange$[ebp]
	jg	SHORT $LN2@GetCityDan

; 347  : 		{
; 348  : 			CvPlot* pEvalPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iX, iY, iEvalRange);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T223391[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T223395[ebp], ecx
	mov	edx, DWORD PTR _iEvalRange$[ebp]
	push	edx
	mov	eax, DWORD PTR _iY$221764[ebp]
	push	eax
	mov	ecx, DWORD PTR _iX$221760[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223391[ebp]
	push	edx
	mov	eax, DWORD PTR $T223395[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pEvalPlot$221768[ebp], eax

; 349  : #endif
; 350  : 			if(!pEvalPlot)

	cmp	DWORD PTR _pEvalPlot$221768[ebp], 0
	jne	SHORT $LN1@GetCityDan

; 351  : 			{
; 352  : 				continue;

	jmp	SHORT $LN3@GetCityDan
$LN1@GetCityDan:

; 353  : 			}
; 354  : 
; 355  : 			iDangerValue += GetDanger(*pEvalPlot);

	mov	ecx, DWORD PTR _pEvalPlot$221768[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z ; CvDangerPlots::GetDanger
	add	eax, DWORD PTR _iDangerValue$[ebp]
	mov	DWORD PTR _iDangerValue$[ebp], eax

; 356  : 		}

	jmp	SHORT $LN3@GetCityDan
$LN2@GetCityDan:

; 357  : 	}

	jmp	SHORT $LN6@GetCityDan
$LN5@GetCityDan:

; 358  : 
; 359  : 	return iDangerValue;

	mov	eax, DWORD PTR _iDangerValue$[ebp]
$LN9@GetCityDan:

; 360  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z ENDP	; CvDangerPlots::GetCityDanger
_TEXT	ENDS
PUBLIC	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Odtp
;	COMDAT ?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
tv232 = -80						; size = 4
tv184 = -76						; size = 4
_this$ = -72						; size = 4
$T223609 = -68						; size = 4
$T223605 = -64						; size = 4
$T223601 = -60						; size = 4
$T223597 = -56						; size = 4
$T223593 = -52						; size = 4
$T223584 = -48						; size = 4
$T223580 = -44						; size = 4
$T223571 = -40						; size = 4
$T223567 = -36						; size = 4
$T223563 = -32						; size = 4
$T223559 = -28						; size = 4
$T223555 = -24						; size = 4
$T223546 = -20						; size = 4
$T223542 = -16						; size = 4
$T223533 = -12						; size = 4
_bIgnoreInFriendlyTerritory$ = -5			; size = 1
_iResult$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iDanger$ = 16						; size = 4
?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z PROC ; CvDangerPlots::ModifyDangerByRelationship, COMDAT
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 	CvAssertMsg(pPlot, "No plot passed in?");
; 365  : 	bool bIgnoreInFriendlyTerritory = false;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 0

; 366  : 	int iResult = iDanger;

	mov	eax, DWORD PTR _iDanger$[ebp]
	mov	DWORD PTR _iResult$[ebp], eax

; 367  : 
; 368  : 	// Full value if a player we're at war with
; 369  : 	if(GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223533[ebp], ecx
	mov	edx, DWORD PTR $T223533[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223542[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223546[ebp], edx
	mov	eax, DWORD PTR $T223546[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223555[ebp], eax
	mov	edx, DWORD PTR $T223555[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223559[ebp], edx
	mov	eax, DWORD PTR $T223542[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223559[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@ModifyDang

; 370  : 	{
; 371  : 		return iResult;

	mov	eax, DWORD PTR _iResult$[ebp]
	jmp	$LN24@ModifyDang
$LN23@ModifyDang:

; 372  : 	}
; 373  : 
; 374  : 	// if it's a human player, ignore neutral units
; 375  : 	if(GET_PLAYER(m_ePlayer).isHuman())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223563[ebp], eax
	mov	ecx, DWORD PTR $T223563[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@ModifyDang

; 376  : 	{
; 377  : 		return 0;

	xor	eax, eax
	jmp	$LN24@ModifyDang
$LN22@ModifyDang:

; 378  : 	}
; 379  : 
; 380  : 	if(GET_PLAYER(m_ePlayer).isMinorCiv())  // if the evaluator is a minor civ

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223567[ebp], eax
	mov	ecx, DWORD PTR $T223567[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@ModifyDang

; 381  : 	{
; 382  : 		if(!GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))  // and they're not at war with the other player

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223571[ebp], edx
	mov	eax, DWORD PTR $T223571[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223580[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223584[ebp], eax
	mov	ecx, DWORD PTR $T223584[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223593[ebp], eax
	mov	eax, DWORD PTR $T223593[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223597[ebp], eax
	mov	ecx, DWORD PTR $T223580[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T223597[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@ModifyDang

; 383  : 		{
; 384  : 			bIgnoreInFriendlyTerritory = true; // ignore friendly territory

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1
$LN20@ModifyDang:

; 385  : 		}
; 386  : 	}

	jmp	$LN6@ModifyDang
$LN21@ModifyDang:

; 387  : 	else if(!GET_PLAYER(ePlayer).isMinorCiv())

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223601[ebp], eax
	mov	ecx, DWORD PTR $T223601[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN18@ModifyDang

; 388  : 	{
; 389  : 		// should we be using bHideTrueFeelings?
; 390  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223605[ebp], eax
	push	0
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T223605[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv184[ebp], eax
	cmp	DWORD PTR tv184[ebp], 6
	ja	$LN16@ModifyDang
	mov	edx, DWORD PTR tv184[ebp]
	jmp	DWORD PTR $LN66@ModifyDang[edx*4]
$LN15@ModifyDang:

; 391  : 		{
; 392  : 		case MAJOR_CIV_APPROACH_WAR:
; 393  : 			iResult = (int)(iResult * m_fMajorWarMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [eax+8]
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _iResult$[ebp], ecx

; 394  : 			break;

	jmp	$LN16@ModifyDang
$LN14@ModifyDang:

; 395  : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 396  : 			iResult = (int)(iResult * m_fMajorHostileMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [edx+16]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iResult$[ebp], eax

; 397  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 398  : 			break;

	jmp	$LN16@ModifyDang
$LN13@ModifyDang:

; 399  : 		case MAJOR_CIV_APPROACH_DECEPTIVE:
; 400  : 			iResult = (int)(iResult * m_fMajorDeceptiveMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+24]
	cvttsd2si edx, xmm0
	mov	DWORD PTR _iResult$[ebp], edx

; 401  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 402  : 			break;

	jmp	SHORT $LN16@ModifyDang
$LN12@ModifyDang:

; 403  : 		case MAJOR_CIV_APPROACH_GUARDED:
; 404  : 			iResult = (int)(iResult * m_fMajorGuardedMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [eax+32]
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _iResult$[ebp], ecx

; 405  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 406  : 			break;

	jmp	SHORT $LN16@ModifyDang
$LN11@ModifyDang:

; 407  : 		case MAJOR_CIV_APPROACH_AFRAID:
; 408  : 			iResult = (int)(iResult * m_fMajorAfraidMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [edx+40]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iResult$[ebp], eax

; 409  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 410  : 			break;

	jmp	SHORT $LN16@ModifyDang
$LN10@ModifyDang:

; 411  : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 412  : 			iResult = (int)(iResult * m_fMajorFriendlyMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+48]
	cvttsd2si edx, xmm0
	mov	DWORD PTR _iResult$[ebp], edx

; 413  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 414  : 			break;

	jmp	SHORT $LN16@ModifyDang
$LN9@ModifyDang:

; 415  : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 416  : 			iResult = (int)(iResult * m_fMajorNeutralMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [eax+56]
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _iResult$[ebp], ecx

; 417  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1
$LN16@ModifyDang:

; 418  : 			break;
; 419  : 		}
; 420  : 	}
; 421  : 	else

	jmp	$LN6@ModifyDang
$LN18@ModifyDang:

; 422  : 	{
; 423  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223609[ebp], eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T223609[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	mov	DWORD PTR tv232[ebp], eax
	cmp	DWORD PTR tv232[ebp], 4
	ja	SHORT $LN6@ModifyDang
	mov	edx, DWORD PTR tv232[ebp]
	jmp	DWORD PTR $LN67@ModifyDang[edx*4]
$LN5@ModifyDang:

; 424  : 		{
; 425  : 		case MINOR_CIV_APPROACH_IGNORE:
; 426  : 			iResult = (int)(iResult * m_fMinorNeutralrMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [eax+64]
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _iResult$[ebp], ecx

; 427  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 428  : 			break;

	jmp	SHORT $LN6@ModifyDang
$LN4@ModifyDang:

; 429  : 		case MINOR_CIV_APPROACH_FRIENDLY:
; 430  : 			iResult = (int)(iResult * m_fMinorFriendlyMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [edx+72]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iResult$[ebp], eax

; 431  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 432  : 			break;

	jmp	SHORT $LN6@ModifyDang
$LN3@ModifyDang:

; 433  : 		case MINOR_CIV_APPROACH_BULLY:
; 434  : 			iResult = (int)(iResult * m_fMinorBullyMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [ecx+80]
	cvttsd2si edx, xmm0
	mov	DWORD PTR _iResult$[ebp], edx

; 435  : 			break;

	jmp	SHORT $LN6@ModifyDang
$LN2@ModifyDang:

; 436  : 		case MINOR_CIV_APPROACH_CONQUEST:
; 437  : 			iResult = (int)(iResult * m_fMinorConquestMod);

	cvtsi2sd xmm0, DWORD PTR _iResult$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulsd	xmm0, QWORD PTR [eax+88]
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _iResult$[ebp], ecx
$LN6@ModifyDang:

; 438  : 			break;
; 439  : 		}
; 440  : 	}
; 441  : 
; 442  : 	// if the plot is in our own territory and, with the current approach, we should ignore danger values in our own territory
; 443  : 	// zero out the value
; 444  : 	if(pPlot && pPlot->getOwner() == m_ePlayer && bIgnoreInFriendlyTerritory)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN1@ModifyDang
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN1@ModifyDang
	movzx	edx, BYTE PTR _bIgnoreInFriendlyTerritory$[ebp]
	test	edx, edx
	je	SHORT $LN1@ModifyDang

; 445  : 	{
; 446  : 		iResult = 0;

	mov	DWORD PTR _iResult$[ebp], 0
$LN1@ModifyDang:

; 447  : 	}
; 448  : 
; 449  : 	return iResult;

	mov	eax, DWORD PTR _iResult$[ebp]
$LN24@ModifyDang:

; 450  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN66@ModifyDang:
	DD	$LN15@ModifyDang
	DD	$LN14@ModifyDang
	DD	$LN13@ModifyDang
	DD	$LN12@ModifyDang
	DD	$LN11@ModifyDang
	DD	$LN10@ModifyDang
	DD	$LN9@ModifyDang
$LN67@ModifyDang:
	DD	$LN5@ModifyDang
	DD	$LN4@ModifyDang
	DD	$LN6@ModifyDang
	DD	$LN2@ModifyDang
	DD	$LN3@ModifyDang
?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ENDP ; CvDangerPlots::ModifyDangerByRelationship
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z ; CvDangerPlots::IsDangerByRelationshipZero
;	COMDAT __real@0000000000000000
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
CONST	ENDS
;	COMDAT ?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z
_TEXT	SEGMENT
tv240 = -120						; size = 4
tv236 = -116						; size = 4
tv232 = -112						; size = 4
tv228 = -108						; size = 4
tv225 = -104						; size = 4
tv211 = -100						; size = 4
tv207 = -96						; size = 4
tv203 = -92						; size = 4
tv199 = -88						; size = 4
tv195 = -84						; size = 4
tv191 = -80						; size = 4
tv187 = -76						; size = 4
tv184 = -72						; size = 4
_this$ = -68						; size = 4
$T223718 = -64						; size = 4
$T223714 = -60						; size = 4
$T223710 = -56						; size = 4
$T223706 = -52						; size = 4
$T223702 = -48						; size = 4
$T223693 = -44						; size = 4
$T223689 = -40						; size = 4
$T223680 = -36						; size = 4
$T223676 = -32						; size = 4
$T223672 = -28						; size = 4
$T223668 = -24						; size = 4
$T223664 = -20						; size = 4
$T223655 = -16						; size = 4
$T223651 = -12						; size = 4
$T223642 = -8						; size = 4
_bResultMultiplierIsZero$ = -2				; size = 1
_bIgnoreInFriendlyTerritory$ = -1			; size = 1
_ePlayer$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z PROC ; CvDangerPlots::IsDangerByRelationshipZero, COMDAT
; _this$ = ecx

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 	CvAssertMsg(pPlot, "No plot passed in?");
; 458  : 	bool bIgnoreInFriendlyTerritory = false;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 0

; 459  : #ifdef AUI_DANGER_PLOTS_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_DO_NOT_IGNORE_TRESSPASSERS
; 460  : 	bool bConsiderInFriendlyTerritory = false;
; 461  : #endif
; 462  : 
; 463  : 	// Full value if a player we're at war with
; 464  : 	if(GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223642[ebp], eax
	mov	ecx, DWORD PTR $T223642[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223651[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223655[ebp], ecx
	mov	edx, DWORD PTR $T223655[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223664[ebp], eax
	mov	ecx, DWORD PTR $T223664[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223668[ebp], ecx
	mov	edx, DWORD PTR $T223651[ebp]
	push	edx
	mov	ecx, DWORD PTR $T223668[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@IsDangerBy

; 465  : 	{
; 466  : 		return false;

	xor	al, al
	jmp	$LN24@IsDangerBy
$LN23@IsDangerBy:

; 467  : 	}
; 468  : 
; 469  : 	// if it's a human player, ignore neutral units
; 470  : 	if(GET_PLAYER(m_ePlayer).isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223672[ebp], edx
	mov	ecx, DWORD PTR $T223672[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@IsDangerBy

; 471  : 	{
; 472  : 		return true;

	mov	al, 1
	jmp	$LN24@IsDangerBy
$LN22@IsDangerBy:

; 473  : 	}
; 474  : 
; 475  : 	bool bResultMultiplierIsZero = false;

	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], 0

; 476  : 	if(GET_PLAYER(m_ePlayer).isMinorCiv())  // if the evaluator is a minor civ

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223676[ebp], edx
	mov	ecx, DWORD PTR $T223676[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN21@IsDangerBy

; 477  : 	{
; 478  : 		if(!GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))  // and they're not at war with the other player

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223680[ebp], ecx
	mov	edx, DWORD PTR $T223680[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223689[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223693[ebp], edx
	mov	eax, DWORD PTR $T223693[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223702[ebp], eax
	mov	edx, DWORD PTR $T223702[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223706[ebp], edx
	mov	eax, DWORD PTR $T223689[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223706[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@IsDangerBy

; 479  : 		{
; 480  : #ifdef AUI_DANGER_PLOTS_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_DO_NOT_IGNORE_TRESSPASSERS
; 481  : 			bConsiderInFriendlyTerritory = true;
; 482  : #ifndef AUI_DANGER_PLOTS_FIX_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_IGNORE_ALL_NONWARRED
; 483  : 			bIgnoreInFriendlyTerritory = true; // ignore friendly territory
; 484  : #endif
; 485  : #elif defined(AUI_DANGER_PLOTS_FIX_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_IGNORE_ALL_NONWARRED)
; 486  : 			return true;
; 487  : #else
; 488  : 			bIgnoreInFriendlyTerritory = true; // ignore friendly territory

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1
$LN20@IsDangerBy:

; 489  : #endif
; 490  : 		}
; 491  : 	}

	jmp	$LN6@IsDangerBy
$LN21@IsDangerBy:

; 492  : 	else if(!GET_PLAYER(ePlayer).isMinorCiv())

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223710[ebp], edx
	mov	ecx, DWORD PTR $T223710[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	$LN18@IsDangerBy

; 493  : 	{
; 494  : 		// should we be using bHideTrueFeelings?
; 495  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223714[ebp], edx
	push	0
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223714[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv184[ebp], eax
	cmp	DWORD PTR tv184[ebp], 6
	ja	$LN16@IsDangerBy
	mov	ecx, DWORD PTR tv184[ebp]
	jmp	DWORD PTR $LN88@IsDangerBy[ecx*4]
$LN15@IsDangerBy:

; 496  : 		{
; 497  : 		case MAJOR_CIV_APPROACH_WAR:
; 498  : 			bResultMultiplierIsZero = m_fMajorWarMod == 0.f;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN26@IsDangerBy
	mov	DWORD PTR tv187[ebp], 1
	jmp	SHORT $LN27@IsDangerBy
$LN26@IsDangerBy:
	mov	DWORD PTR tv187[ebp], 0
$LN27@IsDangerBy:
	mov	al, BYTE PTR tv187[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], al

; 499  : 			break;

	jmp	$LN16@IsDangerBy
$LN14@IsDangerBy:

; 500  : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 501  : 			bResultMultiplierIsZero = m_fMajorHostileMod == 0.f;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+16]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN28@IsDangerBy
	mov	DWORD PTR tv191[ebp], 1
	jmp	SHORT $LN29@IsDangerBy
$LN28@IsDangerBy:
	mov	DWORD PTR tv191[ebp], 0
$LN29@IsDangerBy:
	mov	dl, BYTE PTR tv191[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], dl

; 502  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 503  : 			break;

	jmp	$LN16@IsDangerBy
$LN13@IsDangerBy:

; 504  : 		case MAJOR_CIV_APPROACH_DECEPTIVE:
; 505  : 			bResultMultiplierIsZero = m_fMajorDeceptiveMod == 0.f;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+24]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN30@IsDangerBy
	mov	DWORD PTR tv195[ebp], 1
	jmp	SHORT $LN31@IsDangerBy
$LN30@IsDangerBy:
	mov	DWORD PTR tv195[ebp], 0
$LN31@IsDangerBy:
	mov	cl, BYTE PTR tv195[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], cl

; 506  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 507  : 			break;

	jmp	$LN16@IsDangerBy
$LN12@IsDangerBy:

; 508  : 		case MAJOR_CIV_APPROACH_GUARDED:
; 509  : 			bResultMultiplierIsZero = m_fMajorGuardedMod == 0.f;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx+32]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@IsDangerBy
	mov	DWORD PTR tv199[ebp], 1
	jmp	SHORT $LN33@IsDangerBy
$LN32@IsDangerBy:
	mov	DWORD PTR tv199[ebp], 0
$LN33@IsDangerBy:
	mov	al, BYTE PTR tv199[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], al

; 510  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 511  : 			break;

	jmp	$LN16@IsDangerBy
$LN11@IsDangerBy:

; 512  : 		case MAJOR_CIV_APPROACH_AFRAID:
; 513  : 			bResultMultiplierIsZero = m_fMajorAfraidMod == 0.f;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+40]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN34@IsDangerBy
	mov	DWORD PTR tv203[ebp], 1
	jmp	SHORT $LN35@IsDangerBy
$LN34@IsDangerBy:
	mov	DWORD PTR tv203[ebp], 0
$LN35@IsDangerBy:
	mov	dl, BYTE PTR tv203[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], dl

; 514  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 515  : 			break;

	jmp	SHORT $LN16@IsDangerBy
$LN10@IsDangerBy:

; 516  : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 517  : 			bResultMultiplierIsZero = m_fMajorFriendlyMod == 0.f;

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+48]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	DWORD PTR tv207[ebp], 1
	jmp	SHORT $LN37@IsDangerBy
$LN36@IsDangerBy:
	mov	DWORD PTR tv207[ebp], 0
$LN37@IsDangerBy:
	mov	cl, BYTE PTR tv207[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], cl

; 518  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 519  : 			break;

	jmp	SHORT $LN16@IsDangerBy
$LN9@IsDangerBy:

; 520  : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 521  : 			bResultMultiplierIsZero = m_fMajorNeutralMod == 0.f;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx+56]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN38@IsDangerBy
	mov	DWORD PTR tv211[ebp], 1
	jmp	SHORT $LN39@IsDangerBy
$LN38@IsDangerBy:
	mov	DWORD PTR tv211[ebp], 0
$LN39@IsDangerBy:
	mov	al, BYTE PTR tv211[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], al

; 522  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1
$LN16@IsDangerBy:

; 523  : 			break;
; 524  : 		}
; 525  : 	}
; 526  : 	else

	jmp	$LN6@IsDangerBy
$LN18@IsDangerBy:

; 527  : 	{
; 528  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223718[ebp], edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223718[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	mov	DWORD PTR tv225[ebp], eax
	cmp	DWORD PTR tv225[ebp], 4
	ja	$LN6@IsDangerBy
	mov	ecx, DWORD PTR tv225[ebp]
	jmp	DWORD PTR $LN89@IsDangerBy[ecx*4]
$LN5@IsDangerBy:

; 529  : 		{
; 530  : 		case MINOR_CIV_APPROACH_IGNORE:
; 531  : 			bResultMultiplierIsZero = m_fMinorNeutralrMod == 0.f;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx+64]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN40@IsDangerBy
	mov	DWORD PTR tv228[ebp], 1
	jmp	SHORT $LN41@IsDangerBy
$LN40@IsDangerBy:
	mov	DWORD PTR tv228[ebp], 0
$LN41@IsDangerBy:
	mov	al, BYTE PTR tv228[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], al

; 532  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 533  : 			break;

	jmp	$LN6@IsDangerBy
$LN4@IsDangerBy:

; 534  : 		case MINOR_CIV_APPROACH_FRIENDLY:
; 535  : 			bResultMultiplierIsZero = m_fMinorFriendlyMod == 0.f;

	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [ecx+72]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN42@IsDangerBy
	mov	DWORD PTR tv232[ebp], 1
	jmp	SHORT $LN43@IsDangerBy
$LN42@IsDangerBy:
	mov	DWORD PTR tv232[ebp], 0
$LN43@IsDangerBy:
	mov	dl, BYTE PTR tv232[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], dl

; 536  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[ebp], 1

; 537  : 			break;

	jmp	SHORT $LN6@IsDangerBy
$LN3@IsDangerBy:

; 538  : 		case MINOR_CIV_APPROACH_BULLY:
; 539  : 			bResultMultiplierIsZero = (m_fMinorBullyMod == 0.f);

	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+80]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN44@IsDangerBy
	mov	DWORD PTR tv236[ebp], 1
	jmp	SHORT $LN45@IsDangerBy
$LN44@IsDangerBy:
	mov	DWORD PTR tv236[ebp], 0
$LN45@IsDangerBy:
	mov	cl, BYTE PTR tv236[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], cl

; 540  : 			break;

	jmp	SHORT $LN6@IsDangerBy
$LN2@IsDangerBy:

; 541  : 		case MINOR_CIV_APPROACH_CONQUEST:
; 542  : 			bResultMultiplierIsZero = m_fMinorConquestMod == 0.f;

	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx+88]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@IsDangerBy
	mov	DWORD PTR tv240[ebp], 1
	jmp	SHORT $LN47@IsDangerBy
$LN46@IsDangerBy:
	mov	DWORD PTR tv240[ebp], 0
$LN47@IsDangerBy:
	mov	al, BYTE PTR tv240[ebp]
	mov	BYTE PTR _bResultMultiplierIsZero$[ebp], al
$LN6@IsDangerBy:

; 543  : 			break;
; 544  : 		}
; 545  : 	}
; 546  : 
; 547  : 	// if the plot is in our own territory and, with the current approach, we should ignore danger values in our own territory
; 548  : 	// zero out the value
; 549  : #ifdef AUI_DANGER_PLOTS_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_DO_NOT_IGNORE_TRESSPASSERS
; 550  : 	if (pPlot && pPlot->getOwner() == m_ePlayer)
; 551  : 	{
; 552  : 		if (bConsiderInFriendlyTerritory)
; 553  : 			return false;
; 554  : 		if (bIgnoreInFriendlyTerritory)
; 555  : 			return true;
; 556  : 	}
; 557  : #else
; 558  : 	if(pPlot && pPlot->getOwner() == m_ePlayer && bIgnoreInFriendlyTerritory)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN1@IsDangerBy
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@IsDangerBy
	movzx	ecx, BYTE PTR _bIgnoreInFriendlyTerritory$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@IsDangerBy

; 559  : 	{
; 560  : 		return true;

	mov	al, 1
	jmp	SHORT $LN24@IsDangerBy
$LN1@IsDangerBy:

; 561  : 	}
; 562  : #endif
; 563  : 
; 564  : 	return bResultMultiplierIsZero;

	mov	al, BYTE PTR _bResultMultiplierIsZero$[ebp]
$LN24@IsDangerBy:

; 565  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN88@IsDangerBy:
	DD	$LN15@IsDangerBy
	DD	$LN14@IsDangerBy
	DD	$LN13@IsDangerBy
	DD	$LN12@IsDangerBy
	DD	$LN11@IsDangerBy
	DD	$LN10@IsDangerBy
	DD	$LN9@IsDangerBy
$LN89@IsDangerBy:
	DD	$LN5@IsDangerBy
	DD	$LN4@IsDangerBy
	DD	$LN6@IsDangerBy
	DD	$LN2@IsDangerBy
	DD	$LN3@IsDangerBy
?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z ENDP ; CvDangerPlots::IsDangerByRelationshipZero
_TEXT	ENDS
EXTRN	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsFriends
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T223792 = -48						; size = 4
$T223772 = -44						; size = 4
$T223768 = -40						; size = 4
$T223747 = -36						; size = 4
$T223743 = -32						; size = 4
$T223739 = -28						; size = 4
$T223735 = -24						; size = 4
$T223731 = -20						; size = 4
_eMajorTeam$221861 = -16				; size = 4
_eMinorTeam$221862 = -12				; size = 4
_pMajor$221856 = -8					; size = 4
_pMinor$221855 = -4					; size = 4
_ePlayer$ = 8						; size = 4
?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z PROC ; CvDangerPlots::ShouldIgnorePlayer, COMDAT
; _this$ = ecx

; 574  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 	if(GET_PLAYER(m_ePlayer).isMinorCiv() != GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian() && !GET_PLAYER(m_ePlayer).isBarbarian())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223731[ebp], ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223735[ebp], edx
	mov	ecx, DWORD PTR $T223731[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	esi, al
	mov	ecx, DWORD PTR $T223735[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	cmp	esi, eax
	je	$LN6@ShouldIgno
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223739[ebp], ecx
	mov	ecx, DWORD PTR $T223739[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN6@ShouldIgno
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223743[ebp], ecx
	mov	ecx, DWORD PTR $T223743[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN6@ShouldIgno

; 576  : 	{
; 577  : 		CvPlayer* pMinor = NULL;

	mov	DWORD PTR _pMinor$221855[ebp], 0

; 578  : 		CvPlayer* pMajor;
; 579  : 
; 580  : 		if(GET_PLAYER(m_ePlayer).isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223747[ebp], ecx
	mov	ecx, DWORD PTR $T223747[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN23@ShouldIgno

; 581  : 		{
; 582  : 			pMinor = &GET_PLAYER(m_ePlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pMinor$221855[ebp], ecx

; 583  : 			pMajor = &GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pMajor$221856[ebp], edx

; 584  : 		}
; 585  : 		else

	jmp	SHORT $LN29@ShouldIgno

; 586  : 		{
; 587  : 			pMinor = &GET_PLAYER(ePlayer);

$LN23@ShouldIgno:
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pMinor$221855[ebp], eax

; 588  : 			pMajor = &GET_PLAYER(m_ePlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pMajor$221856[ebp], edx

; 589  : 		}
; 590  : 
; 591  : 		if(pMinor->GetMinorCivAI()->IsFriends(pMajor->GetID()))

$LN29@ShouldIgno:
	mov	eax, DWORD PTR _pMajor$221856[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T223768[ebp], ecx
	mov	edx, DWORD PTR $T223768[ebp]
	push	edx
	mov	ecx, DWORD PTR _pMinor$221855[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@ShouldIgno

; 592  : 		{
; 593  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@ShouldIgno
$LN3@ShouldIgno:

; 594  : 		}
; 595  : 
; 596  : 		// if we're a major, we should ignore minors that are not at war with us
; 597  : 		if (!GET_PLAYER(m_ePlayer).isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223772[ebp], edx
	mov	ecx, DWORD PTR $T223772[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@ShouldIgno

; 598  : 		{
; 599  : 			TeamTypes eMajorTeam = pMajor->getTeam();

	mov	ecx, DWORD PTR _pMajor$221856[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMajorTeam$221861[ebp], eax

; 600  : 			TeamTypes eMinorTeam = pMinor->getTeam();

	mov	eax, DWORD PTR _pMinor$221855[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMinorTeam$221862[ebp], eax

; 601  : 			if (!GET_TEAM(eMajorTeam).isAtWar(eMinorTeam))

	mov	edx, DWORD PTR _eMajorTeam$221861[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223792[ebp], edx
	mov	eax, DWORD PTR _eMinorTeam$221862[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223792[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@ShouldIgno

; 602  : 			{
; 603  : 				return true;

	mov	al, 1
	jmp	SHORT $LN7@ShouldIgno
$LN6@ShouldIgno:

; 604  : 			}
; 605  : 		}
; 606  : 	}
; 607  : 
; 608  : 	return false;

	xor	al, al
$LN7@ShouldIgno:

; 609  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDangerPlots::ShouldIgnorePlayer
_TEXT	ENDS
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleOtherUnit
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
; Function compile flags: /Odtp
;	COMDAT ?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T223831 = -28						; size = 4
$T223822 = -24						; size = 4
$T223818 = -17						; size = 1
$T223817 = -16						; size = 4
$T223807 = -12						; size = 4
$T223798 = -8						; size = 4
_pPlot$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_bIgnoreVisibility$ = 12				; size = 1
?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z PROC ; CvDangerPlots::ShouldIgnoreUnit, COMDAT
; _this$ = ecx

; 617  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 618  : 	if(!pUnit->IsCanAttack())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@ShouldIgno@2

; 619  : 	{
; 620  : 		return true;

	mov	al, 1
	jmp	$LN6@ShouldIgno@2
$LN5@ShouldIgno@2:

; 621  : 	}
; 622  : 
; 623  : #if defined(AUI_DANGER_PLOTS_SHOULD_IGNORE_UNIT_MINORS_SEE_MAJORS)
; 624  : 	if (pUnit->isInvisible(GET_PLAYER(m_ePlayer).getTeam(), false))
; 625  : 	{
; 626  : 		return true;
; 627  : 	}
; 628  : 
; 629  : 	if (GET_PLAYER(m_ePlayer).isMinorCiv() && !GET_PLAYER(pUnit->getOwner()).isMinorCiv() && !pUnit->isBarbarian() &&
; 630  : 		GET_PLAYER(m_ePlayer).GetClosestFriendlyCity(*pUnit->plot(), AUI_DANGER_PLOTS_SHOULD_IGNORE_UNIT_MINORS_SEE_MAJORS))
; 631  : 		bIgnoreVisibility = true;
; 632  : #endif
; 633  : 
; 634  : #ifdef AUI_DANGER_PLOTS_FIX_SHOULD_IGNORE_UNIT_IGNORE_VISIBILITY_PLOT
; 635  : 	if (!pUnit->plot()->isVisible(GET_PLAYER(m_ePlayer).getTeam()) && !bIgnoreVisibility)
; 636  : #else
; 637  : 	if(!pUnit->plot()->isVisible(GET_PLAYER(m_ePlayer).getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223798[ebp], edx
	mov	eax, DWORD PTR $T223798[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223807[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T223817[ebp], eax
	cmp	DWORD PTR $T223807[ebp], -1
	jne	SHORT $LN17@ShouldIgno@2
	mov	BYTE PTR $T223818[ebp], 0
	jmp	SHORT $LN15@ShouldIgno@2
$LN17@ShouldIgno@2:
	mov	edx, DWORD PTR $T223817[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR $T223807[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T223818[ebp], al
$LN15@ShouldIgno@2:
	movzx	ecx, BYTE PTR $T223818[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@ShouldIgno@2

; 638  : #endif
; 639  : 	{
; 640  : 		return true;

	mov	al, 1
	jmp	$LN6@ShouldIgno@2
$LN4@ShouldIgno@2:

; 641  : 	}
; 642  : 
; 643  : #if !defined(AUI_DANGER_PLOTS_SHOULD_IGNORE_UNIT_MINORS_SEE_MAJORS)
; 644  : 	if(pUnit->isInvisible(GET_PLAYER(m_ePlayer).getTeam(), false))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223822[ebp], eax
	mov	ecx, DWORD PTR $T223822[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223831[ebp], eax
	push	1
	push	0
	mov	eax, DWORD PTR $T223831[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ShouldIgno@2

; 645  : 	{
; 646  : 		return true;

	mov	al, 1
	jmp	SHORT $LN6@ShouldIgno@2
$LN3@ShouldIgno@2:

; 647  : 	}
; 648  : #endif
; 649  : 
; 650  : 	CvPlot* pPlot = pUnit->plot();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pPlot$[ebp], eax

; 651  : 	CvAssertMsg(pPlot, "Plot is null?")
; 652  : 
; 653  : 	if(NULL != pPlot && !pPlot->isVisibleOtherUnit(m_ePlayer) && !bIgnoreVisibility)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN2@ShouldIgno@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@ShouldIgno@2
	movzx	edx, BYTE PTR _bIgnoreVisibility$[ebp]
	test	edx, edx
	jne	SHORT $LN2@ShouldIgno@2

; 654  : 	{
; 655  : 		return true;

	mov	al, 1
	jmp	SHORT $LN6@ShouldIgno@2
$LN2@ShouldIgno@2:

; 656  : 	}
; 657  : 
; 658  : 	// fix post-gold!
; 659  : 	if(pUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN1@ShouldIgno@2

; 660  : 	{
; 661  : 		return true;

	mov	al, 1
	jmp	SHORT $LN6@ShouldIgno@2
$LN1@ShouldIgno@2:

; 662  : 	}
; 663  : 
; 664  : 	return false;

	xor	al, al
$LN6@ShouldIgno@2:

; 665  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z ENDP ; CvDangerPlots::ShouldIgnoreUnit
_TEXT	ENDS
EXTRN	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z:PROC	; CvCity::isRevealed
; Function compile flags: /Odtp
;	COMDAT ?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T223846 = -8						; size = 4
$T223837 = -4						; size = 4
_pCity$ = 8						; size = 4
_bIgnoreVisibility$ = 12				; size = 1
?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z PROC ; CvDangerPlots::ShouldIgnoreCity, COMDAT
; _this$ = ecx

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 674  : 	// ignore unseen cities
; 675  : 	if(!pCity->isRevealed(GET_PLAYER(m_ePlayer).getTeam(), false)  && !bIgnoreVisibility)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223837[ebp], ecx
	mov	edx, DWORD PTR $T223837[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223846[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T223846[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@ShouldIgno@3
	movzx	eax, BYTE PTR _bIgnoreVisibility$[ebp]
	test	eax, eax
	jne	SHORT $LN1@ShouldIgno@3

; 676  : 	{
; 677  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@ShouldIgno@3
$LN1@ShouldIgno@3:

; 678  : 	}
; 679  : 
; 680  : 	return false;

	xor	al, al
$LN2@ShouldIgno@3:

; 681  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z ENDP ; CvDangerPlots::ShouldIgnoreCity
_TEXT	ENDS
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
; Function compile flags: /Odtp
;	COMDAT ?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T223900 = -32						; size = 4
$T223891 = -28						; size = 4
$T223887 = -24						; size = 4
$T223878 = -20						; size = 4
_uiOffset$223870 = -16					; size = 4
$T223861 = -12						; size = 4
$T223852 = -8						; size = 4
_eOwner$ = -4						; size = 4
_pCitadelPlot$ = 8					; size = 4
_bIgnoreVisibility$ = 12				; size = 1
?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z PROC ; CvDangerPlots::ShouldIgnoreCitadel, COMDAT
; _this$ = ecx

; 689  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 690  : 	// ignore unseen cities
; 691  : 	if(!pCitadelPlot->isRevealed(GET_PLAYER(m_ePlayer).getTeam())  && !bIgnoreVisibility)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223852[ebp], ecx
	mov	edx, DWORD PTR $T223852[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223861[ebp], eax
	mov	ecx, DWORD PTR $T223861[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$223870[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$223870[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T223861[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$223870[ebp]
	mov	edx, DWORD PTR _pCitadelPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN17@ShouldIgno@4
	movzx	edx, BYTE PTR _bIgnoreVisibility$[ebp]
	test	edx, edx
	jne	SHORT $LN17@ShouldIgno@4

; 692  : 	{
; 693  : 		return true;

	mov	al, 1
	jmp	$LN5@ShouldIgno@4

; 694  : 	}
; 695  : 
; 696  : 	PlayerTypes eOwner = pCitadelPlot->getOwner();

$LN17@ShouldIgno@4:
	mov	eax, DWORD PTR _pCitadelPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _eOwner$[ebp], ecx

; 697  : 	if(eOwner != NO_PLAYER)

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN3@ShouldIgno@4

; 698  : 	{
; 699  : 		// Our own citadels aren't dangerous
; 700  : 		if(eOwner == m_ePlayer)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eOwner$[ebp]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN2@ShouldIgno@4

; 701  : 		{
; 702  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@ShouldIgno@4
$LN2@ShouldIgno@4:

; 703  : 		}
; 704  : 
; 705  : 		if(!atWar(GET_PLAYER(m_ePlayer).getTeam(), GET_PLAYER(eOwner).getTeam()))

	mov	ecx, DWORD PTR _eOwner$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223878[ebp], ecx
	mov	edx, DWORD PTR $T223878[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223887[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223891[ebp], edx
	mov	eax, DWORD PTR $T223891[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223900[ebp], eax
	mov	edx, DWORD PTR $T223887[ebp]
	push	edx
	mov	eax, DWORD PTR $T223900[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@ShouldIgno@4

; 706  : 		{
; 707  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@ShouldIgno@4
$LN3@ShouldIgno@4:

; 708  : 		}
; 709  : 	}
; 710  : 
; 711  : 	return false;

	xor	al, al
$LN5@ShouldIgno@4:

; 712  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z ENDP ; CvDangerPlots::ShouldIgnoreCitadel
_TEXT	ENDS
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ:PROC ; CvUnit::GetBaseCombatStrengthConsideringDamage
; Function compile flags: /Odtp
;	COMDAT ?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
tv142 = -64						; size = 4
_this$ = -60						; size = 4
$T223961 = -56						; size = 4
$T223949 = -52						; size = 4
$T223940 = -48						; size = 4
$T223931 = -44						; size = 4
$T223912 = -40						; size = 4
$T223903 = -36						; size = 4
_iTurnsAway$221905 = -32				; size = 4
_iPlotY$221902 = -28					; size = 4
_kPathFinder$221900 = -24				; size = 4
_pNode$221904 = -20					; size = 4
_iPlotX$221901 = -16					; size = 4
_iUnitCombatValue$221907 = -12				; size = 4
_iCombatValueCalc$ = -8					; size = 4
_iBaseUnitCombatValue$ = -4				; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvDangerPlots::AssignUnitDangerValue, COMDAT
; _this$ = ecx

; 717  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 	// MAJIK NUMBARS TO MOVE TO XML
; 719  : 	int iCombatValueCalc = 100;

	mov	DWORD PTR _iCombatValueCalc$[ebp], 100	; 00000064H

; 720  : 	int iBaseUnitCombatValue = pUnit->GetBaseCombatStrengthConsideringDamage() * iCombatValueCalc;

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	imul	eax, DWORD PTR _iCombatValueCalc$[ebp]
	mov	DWORD PTR _iBaseUnitCombatValue$[ebp], eax

; 721  : 	// Combat capable?  If not, the calculations will always result in 0, so just skip it.
; 722  : 	if(iBaseUnitCombatValue > 0)

	cmp	DWORD PTR _iBaseUnitCombatValue$[ebp], 0
	jle	$LN4@AssignUnit

; 723  : 	{
; 724  : 		// Will any danger be zero'ed out?
; 725  : 		if(!IsDangerByRelationshipZero(pUnit->getOwner(), pPlot))

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T223912[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223912[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z ; CvDangerPlots::IsDangerByRelationshipZero
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN4@AssignUnit

; 726  : 		{
; 727  : 			//int iDistance = plotDistance(pUnitPlot->getX(), pUnitPlot->getY(), pPlot->getX(), pPlot->getY());
; 728  : 			//int iRange = pUnit->baseMoves();
; 729  : 			//FAssertMsg(iRange > 0, "0 range? Uh oh");
; 730  : 
; 731  : 			CvIgnoreUnitsPathFinder& kPathFinder = GC.getIgnoreUnitsPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR _kPathFinder$221900[ebp], eax

; 732  : 			kPathFinder.SetData(pUnit);

	mov	edx, DWORD PTR _kPathFinder$221900[ebp]
	movzx	eax, BYTE PTR [edx+80]
	test	eax, eax
	je	SHORT $LN10@AssignUnit
	mov	ecx, DWORD PTR _kPathFinder$221900[ebp]
	mov	edx, DWORD PTR [ecx+44]
	cmp	edx, DWORD PTR _pUnit$[ebp]
	je	SHORT $LN10@AssignUnit
	mov	eax, DWORD PTR _kPathFinder$221900[ebp]
	mov	BYTE PTR [eax+78], 1
$LN10@AssignUnit:
	mov	ecx, DWORD PTR _kPathFinder$221900[ebp]
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 733  : 
; 734  : 			int iPlotX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iPlotX$221901[ebp], ecx

; 735  : 			int iPlotY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iPlotY$221902[ebp], eax

; 736  : 			// can the unit actually walk there
; 737  : 			if(!kPathFinder.GeneratePath(pUnit->getX(), pUnit->getY(), iPlotX, iPlotY, 0, true /*bReuse*/))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T223931[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T223940[ebp], ecx
	push	1
	push	0
	mov	edx, DWORD PTR _iPlotY$221902[ebp]
	push	edx
	mov	eax, DWORD PTR _iPlotX$221901[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223931[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223940[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPathFinder$221900[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@AssignUnit

; 738  : 			{
; 739  : 				return;

	jmp	$LN4@AssignUnit
$LN1@AssignUnit:

; 740  : 			}
; 741  : 
; 742  : 			CvAStarNode* pNode = kPathFinder.GetLastNode();

	mov	ecx, DWORD PTR _kPathFinder$221900[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$221904[ebp], edx

; 743  : 			int iTurnsAway = pNode->m_iData2;

	mov	eax, DWORD PTR _pNode$221904[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _iTurnsAway$221905[ebp], ecx

; 744  : 			iTurnsAway = max(iTurnsAway, 1);

	mov	DWORD PTR $T223903[ebp], 1
	mov	edx, DWORD PTR _iTurnsAway$221905[ebp]
	cmp	edx, DWORD PTR $T223903[ebp]
	jge	SHORT $LN29@AssignUnit
	lea	eax, DWORD PTR $T223903[ebp]
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN30@AssignUnit
$LN29@AssignUnit:
	lea	ecx, DWORD PTR _iTurnsAway$221905[ebp]
	mov	DWORD PTR tv142[ebp], ecx
$LN30@AssignUnit:
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T223949[ebp], edx
	mov	eax, DWORD PTR $T223949[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iTurnsAway$221905[ebp], ecx

; 745  : 
; 746  : 			int iUnitCombatValue = iBaseUnitCombatValue / iTurnsAway;

	mov	eax, DWORD PTR _iBaseUnitCombatValue$[ebp]
	cdq
	idiv	DWORD PTR _iTurnsAway$221905[ebp]
	mov	DWORD PTR _iUnitCombatValue$221907[ebp], eax

; 747  : 			iUnitCombatValue = ModifyDangerByRelationship(pUnit->getOwner(), pPlot, iUnitCombatValue);

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T223961[ebp], eax
	mov	ecx, DWORD PTR _iUnitCombatValue$221907[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223961[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship
	mov	DWORD PTR _iUnitCombatValue$221907[ebp], eax

; 748  : 			AddDanger(iPlotX, iPlotY, iUnitCombatValue, iTurnsAway <= 1);

	cmp	DWORD PTR _iTurnsAway$221905[ebp], 1
	setle	cl
	movzx	edx, cl
	push	edx
	mov	eax, DWORD PTR _iUnitCombatValue$221907[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotY$221902[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotX$221901[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddDanger@CvDangerPlots@@QAEXHHH_N@Z	; CvDangerPlots::AddDanger
$LN4@AssignUnit:

; 749  : 		}
; 750  : 	}
; 751  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvDangerPlots::AssignUnitDangerValue
_TEXT	ENDS
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
; Function compile flags: /Odtp
;	COMDAT ?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T223976 = -12						; size = 4
$T223972 = -8						; size = 4
_iCombatValue$ = -4					; size = 4
_pCity$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z PROC ; CvDangerPlots::AssignCityDangerValue, COMDAT
; _this$ = ecx

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 757  : 	int iCombatValue = pCity->getStrengthValue();

	push	0
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	DWORD PTR _iCombatValue$[ebp], eax

; 758  : 	iCombatValue = ModifyDangerByRelationship(pCity->getOwner(), pPlot, iCombatValue);

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T223972[ebp], ecx
	mov	edx, DWORD PTR _iCombatValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223972[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship
	mov	DWORD PTR _iCombatValue$[ebp], eax

; 759  : 	AddDanger(pPlot->getX(), pPlot->getY(), iCombatValue, false);

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T223976[ebp], eax
	push	0
	mov	ecx, DWORD PTR _iCombatValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223976[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddDanger@CvDangerPlots@@QAEXHHH_N@Z	; CvDangerPlots::AddDanger

; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z ENDP ; CvDangerPlots::AssignCityDangerValue
_TEXT	ENDS
EXTRN	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z:PROC ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
; Function compile flags: /Odtp
;	COMDAT ?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T223985 = -12						; size = 4
_iPower$ = -8						; size = 4
_pMilitaryAI$ = -4					; size = 4
?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ PROC	; CvDangerPlots::GetDangerValueOfCitadel, COMDAT
; _this$ = ecx

; 764  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 	// Compute power of this player's strongest unit
; 766  : 	CvMilitaryAI* pMilitaryAI = GET_PLAYER(m_ePlayer).GetMilitaryAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223985[ebp], ecx
	mov	ecx, DWORD PTR $T223985[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	DWORD PTR _pMilitaryAI$[ebp], eax

; 767  : 	int iPower = pMilitaryAI->GetPowerOfStrongestBuildableUnit(DOMAIN_LAND);

	push	2
	mov	ecx, DWORD PTR _pMilitaryAI$[ebp]
	call	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
	mov	DWORD PTR _iPower$[ebp], eax

; 768  : 
; 769  : 	// Magic number to approximate danger from one turn of citadel damage
; 770  : 	return iPower * 50;

	mov	eax, DWORD PTR _iPower$[ebp]
	imul	eax, 50					; 00000032H

; 771  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ ENDP	; CvDangerPlots::GetDangerValueOfCitadel
_TEXT	ENDS
PUBLIC	?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z	; CvDangerPlots::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv143 = -40						; size = 4
_this$ = -36						; size = 4
$T224024 = -32						; size = 4
$T224017 = -28						; size = 4
$T224016 = -24						; size = 4
$T224007 = -20						; size = 4
$T224012 = -16						; size = 4
_i$221925 = -12						; size = 4
_iGridSize$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z PROC	; CvDangerPlots::Read, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 776  : 	// Version number to maintain backwards compatibility
; 777  : 	uint uiVersion;
; 778  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 779  : 
; 780  : 	kStream >> m_ePlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 781  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 782  : 	bool bArrayAllocated = false;
; 783  : 	kStream >> bArrayAllocated;
; 784  : #else
; 785  : 	kStream >> m_bArrayAllocated;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 786  : #endif
; 787  : 
; 788  : 	int iGridSize;
; 789  : 	kStream >> iGridSize;

	lea	ecx, DWORD PTR _iGridSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 790  : 
; 791  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 792  : 	if (m_DangerPlots)
; 793  : 		SAFE_DELETE_ARRAY(m_DangerPlots);
; 794  : 	if (bArrayAllocated)
; 795  : 	{
; 796  : 		m_DangerPlots = FNEW(uint[iGridSize], c_eCiv5GameplayDLL, 0);
; 797  : #else
; 798  : 	m_DangerPlots.resize(iGridSize);

	mov	edx, DWORD PTR _iGridSize$[ebp]
	mov	DWORD PTR $T224017[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	mov	DWORD PTR $T224016[ebp], eax
	mov	ecx, DWORD PTR $T224016[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR $T224017[ebp]
	jae	SHORT $LN12@Read
	mov	eax, DWORD PTR $T224017[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224016[ebp]
	call	?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
$LN12@Read:
	mov	ecx, DWORD PTR $T224016[ebp]
	add	ecx, 8
	mov	DWORD PTR $T224007[ebp], ecx
	mov	edx, DWORD PTR $T224007[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR $T224017[ebp]
	jae	SHORT $LN17@Read
	mov	ecx, DWORD PTR $T224007[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	jmp	SHORT $LN18@Read
$LN17@Read:
	lea	edx, DWORD PTR $T224017[ebp]
	mov	DWORD PTR tv143[ebp], edx
$LN18@Read:
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR $T224012[ebp], eax
	mov	ecx, DWORD PTR $T224016[ebp]
	mov	edx, DWORD PTR $T224012[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 799  : #endif
; 800  : 	for(int i = 0; i < iGridSize; i++)

	mov	DWORD PTR _i$221925[ebp], 0
	jmp	SHORT $LN3@Read
$LN2@Read:
	mov	ecx, DWORD PTR _i$221925[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$221925[ebp], ecx
$LN3@Read:
	mov	edx, DWORD PTR _i$221925[ebp]
	cmp	edx, DWORD PTR _iGridSize$[ebp]
	jge	SHORT $LN1@Read

; 801  : 	{
; 802  : 		kStream >> m_DangerPlots[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	edx, DWORD PTR _i$221925[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T224024[ebp], eax
	mov	ecx, DWORD PTR $T224024[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 803  : 	}

	jmp	SHORT $LN2@Read
$LN1@Read:

; 804  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 805  : 	}
; 806  : #endif
; 807  : 
; 808  : 	m_bDirty = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 0

; 809  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z ENDP	; CvDangerPlots::Read
_TEXT	ENDS
PUBLIC	?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z	; CvDangerPlots::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T224058 = -32						; size = 4
$T224048 = -28						; size = 4
$T224044 = -24						; size = 4
$T224040 = -20						; size = 4
$T224036 = -16						; size = 4
_i$221935 = -12						; size = 4
_iGridSize$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z PROC	; CvDangerPlots::Write, COMDAT
; _this$ = ecx

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 814  : 	// Current version number
; 815  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 816  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 817  : 
; 818  : 	kStream << m_ePlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 819  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 820  : 	kStream << (m_DangerPlots != NULL);
; 821  : #else
; 822  : 	kStream << m_bArrayAllocated;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 823  : #endif
; 824  : 
; 825  : 	int iGridSize = GC.getMap().getGridWidth() * GC.getMap().getGridHeight();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224036[ebp], ecx
	mov	edx, DWORD PTR $T224036[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T224040[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224044[ebp], ecx
	mov	edx, DWORD PTR $T224044[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T224048[ebp], eax
	mov	ecx, DWORD PTR $T224040[ebp]
	imul	ecx, DWORD PTR $T224048[ebp]
	mov	DWORD PTR _iGridSize$[ebp], ecx

; 826  : 	kStream << iGridSize;

	lea	edx, DWORD PTR _iGridSize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 827  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 828  : 	if (m_DangerPlots)
; 829  : 	{
; 830  : 		for (int i = 0; i < iGridSize; i++)
; 831  : 		{
; 832  : 			kStream << m_DangerPlots[i];
; 833  : 		}
; 834  : 	}
; 835  : 	else
; 836  : 	{
; 837  : 		for (int i = 0; i < iGridSize; i++)
; 838  : 		{
; 839  : 			kStream << (uint)0;
; 840  : 		}
; 841  : 	}
; 842  : #else
; 843  : 	for(int i = 0; i < iGridSize; i++)

	mov	DWORD PTR _i$221935[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	eax, DWORD PTR _i$221935[ebp]
	add	eax, 1
	mov	DWORD PTR _i$221935[ebp], eax
$LN3@Write:
	mov	ecx, DWORD PTR _i$221935[ebp]
	cmp	ecx, DWORD PTR _iGridSize$[ebp]
	jge	SHORT $LN4@Write

; 844  : 	{
; 845  : 		kStream << m_DangerPlots[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR _i$221935[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T224058[ebp], edx
	mov	eax, DWORD PTR $T224058[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 846  : 	}

	jmp	SHORT $LN2@Write
$LN4@Write:

; 847  : #endif
; 848  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z ENDP	; CvDangerPlots::Write
_TEXT	ENDS
PUBLIC	?SetDirty@CvDangerPlots@@QAEXXZ			; CvDangerPlots::SetDirty
; Function compile flags: /Odtp
;	COMDAT ?SetDirty@CvDangerPlots@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetDirty@CvDangerPlots@@QAEXXZ PROC			; CvDangerPlots::SetDirty, COMDAT
; _this$ = ecx

; 852  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 853  : 	m_bDirty = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+5], 1

; 854  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetDirty@CvDangerPlots@@QAEXXZ ENDP			; CvDangerPlots::SetDirty
_TEXT	ENDS
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224077 = -20						; size = 4
_pRet$224073 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$224073[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$224073[ebp]
	mov	DWORD PTR $T224077[ebp], eax
	jmp	SHORT $LN7@FFastVecto
$LN6@FFastVecto:
	mov	DWORD PTR $T224077[ebp], 0
$LN7@FFastVecto:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T224077[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@I$00@@QAE@XZ		; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>
__ehhandler$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T224112 = -24						; size = 4
$T224111 = -20						; size = 4
_i$224104 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224112[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T224111[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN4@FFastVecto@2
	xor	edx, edx
	je	SHORT $LN4@FFastVecto@2
	mov	DWORD PTR _i$224104[ebp], 0
	jmp	SHORT $LN9@FFastVecto@2
$LN8@FFastVecto@2:
	mov	eax, DWORD PTR _i$224104[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224104[ebp], eax
$LN9@FFastVecto@2:
	mov	ecx, DWORD PTR _i$224104[ebp]
	cmp	ecx, DWORD PTR $T224112[ebp]
	jae	SHORT $LN4@FFastVecto@2
	jmp	SHORT $LN8@FFastVecto@2
$LN4@FFastVecto@2:
	mov	edx, DWORD PTR $T224111[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@I$00@@QAE@XZ		; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>
__ehhandler$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@I$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@I$00@@QAE@XZ PROC			; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@I$00@@QAE@XZ ENDP			; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z
_TEXT	SEGMENT
tv184 = -48						; size = 4
_this$ = -44						; size = 4
$T224168 = -40						; size = 4
$T224167 = -36						; size = 4
_i$224160 = -32						; size = 4
$T224139 = -28						; size = 4
_pRet$224135 = -24					; size = 4
$T224126 = -20						; size = 4
_i$221987 = -16						; size = 4
_uiNewSize$221978 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$221978[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$221978[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize
$LN8@GrowSize:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$221978[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize
$LN9@GrowSize:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T224139[ebp], eax
	cmp	DWORD PTR $T224139[ebp], 0
	jbe	SHORT $LN16@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T224139[ebp]
	shl	ecx, 2
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$224135[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T224139[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$224135[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN6@GrowSize

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize
$LN6@GrowSize:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$221987[ebp], 0
	jmp	SHORT $LN4@GrowSize
$LN3@GrowSize:
	mov	edx, DWORD PTR _i$221987[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221987[ebp], edx
$LN4@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$221987[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$221987[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T224126[ebp], ecx
	cmp	DWORD PTR $T224126[ebp], 0
	je	SHORT $LN14@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T224126[ebp]
	mov	edx, DWORD PTR _i$221987[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T224126[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN15@GrowSize
$LN14@GrowSize:
	mov	DWORD PTR tv184[ebp], 0
$LN15@GrowSize:
	jmp	SHORT $LN3@GrowSize
$LN5@GrowSize:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224168[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T224167[ebp], edx
	xor	eax, eax
	je	SHORT $LN23@GrowSize
	xor	ecx, ecx
	je	SHORT $LN23@GrowSize
	mov	DWORD PTR _i$224160[ebp], 0
	jmp	SHORT $LN28@GrowSize
$LN27@GrowSize:
	mov	edx, DWORD PTR _i$224160[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224160[ebp], edx
$LN28@GrowSize:
	mov	eax, DWORD PTR _i$224160[ebp]
	cmp	eax, DWORD PTR $T224168[ebp]
	jae	SHORT $LN23@GrowSize
	jmp	SHORT $LN27@GrowSize
$LN23@GrowSize:
	mov	ecx, DWORD PTR $T224167[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize
$LN7@GrowSize:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN12@GrowSize:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T224186 = -8						; size = 4
$T224182 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224182[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T224182[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T224186[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T224186[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
END
