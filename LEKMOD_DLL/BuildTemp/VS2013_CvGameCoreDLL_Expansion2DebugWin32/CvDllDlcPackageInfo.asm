; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDllDlcPackageInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05OCFELOIJ@1?40?40?$AA@			; `string'
CONST	SEGMENT
_guidICvUnknown DD 0d89ba82fH
	DW	09fa3H
	DW	04696H
	DB	0b3H
	DB	0f4H
	DB	052H
	DB	0bdH
	DB	0b1H
	DB	01H
	DB	0cfH
	DB	0b2H
_guidICvEnumerator DD 0579a12e9H
	DW	03c70H
	DW	04276H
	DB	084H
	DB	060H
	DB	0c9H
	DB	041H
	DB	0a5H
	DB	0f9H
	DB	058H
	DB	05fH
_guidICvDlcPackageInfo1 DD 01a87b286H
	DW	05001H
	DW	04661H
	DB	09aH
	DB	089H
	DB	081H
	DB	026H
	DB	0afH
	DB	013H
	DB	027H
	DB	02H
CONST	ENDS
_DATA	SEGMENT
_CIV5_XP2_DLL_VERSION DD FLAT:??_C@_05OCFELOIJ@1?40?40?$AA@
_DATA	ENDS
;	COMDAT ??_C@_05OCFELOIJ@1?40?40?$AA@
CONST	SEGMENT
??_C@_05OCFELOIJ@1?40?40?$AA@ DB '1.0.0', 00H		; `string'
CONST	ENDS
PUBLIC	??_7CvDllDlcPackageInfo@@6B@			; CvDllDlcPackageInfo::`vftable'
PUBLIC	??_7ICvDlcPackageInfo1@@6B@			; ICvDlcPackageInfo1::`vftable'
PUBLIC	??_7ICvUnknown@@6B@				; ICvUnknown::`vftable'
PUBLIC	??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z	; CvDllDlcPackageInfo::CvDllDlcPackageInfo
PUBLIC	?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z ; CvDllDlcPackageInfo::QueryInterface
PUBLIC	?Destroy@CvDllDlcPackageInfo@@EAGXXZ		; CvDllDlcPackageInfo::Destroy
PUBLIC	?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ ; CvDllDlcPackageInfo::GetPackageID
EXTRN	__purecall:PROC
;	COMDAT ??_7CvDllDlcPackageInfo@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
CONST	SEGMENT
??_7CvDllDlcPackageInfo@@6B@ DD FLAT:?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z ; CvDllDlcPackageInfo::`vftable'
	DD	FLAT:?Destroy@CvDllDlcPackageInfo@@EAGXXZ
	DD	FLAT:?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ
CONST	ENDS
;	COMDAT ??_7ICvDlcPackageInfo1@@6B@
CONST	SEGMENT
??_7ICvDlcPackageInfo1@@6B@ DD FLAT:__purecall		; ICvDlcPackageInfo1::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7ICvUnknown@@6B@
CONST	SEGMENT
??_7ICvUnknown@@6B@ DD FLAT:__purecall			; ICvUnknown::`vftable'
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_kGuid$ = 8						; size = 4
??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z PROC		; CvDllDlcPackageInfo::CvDllDlcPackageInfo, COMDAT
; _this$ = ecx

; 16   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ICvUnknown@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ICvDlcPackageInfo1@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7CvDllDlcPackageInfo@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 1
	mov	ecx, DWORD PTR _kGuid$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 17   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z ENDP		; CvDllDlcPackageInfo::CvDllDlcPackageInfo
_TEXT	ENDS
PUBLIC	??1CvDllDlcPackageInfo@@QAE@XZ			; CvDllDlcPackageInfo::~CvDllDlcPackageInfo
; Function compile flags: /Odtp
;	COMDAT ??1CvDllDlcPackageInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvDllDlcPackageInfo@@QAE@XZ PROC			; CvDllDlcPackageInfo::~CvDllDlcPackageInfo, COMDAT
; _this$ = ecx

; 20   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDllDlcPackageInfo@@6B@

; 21   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvDllDlcPackageInfo@@QAE@XZ ENDP			; CvDllDlcPackageInfo::~CvDllDlcPackageInfo
_TEXT	ENDS
PUBLIC	?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ	; CvDllDlcPackageInfo::IncrementReference
; Function compile flags: /Odtp
;	COMDAT ?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z
_TEXT	SEGMENT
tv90 = -88						; size = 4
tv161 = -84						; size = 4
tv85 = -80						; size = 4
tv137 = -76						; size = 4
$T219762 = -72						; size = 16
$T219761 = -56						; size = 16
$T219760 = -40						; size = 16
$T219759 = -20						; size = 16
_this$ = 8						; size = 4
_guidInterface$ = 12					; size = 16
?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z PROC ; CvDllDlcPackageInfo::QueryInterface, COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi

; 25   : 	if(guidInterface == ICvUnknown::GetInterfaceId() ||
; 26   : 	        guidInterface == ICvDlcPackageInfo1::GetInterfaceId())

	mov	eax, DWORD PTR _guidICvUnknown
	mov	DWORD PTR $T219760[ebp], eax
	mov	ecx, DWORD PTR _guidICvUnknown+4
	mov	DWORD PTR $T219760[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvUnknown+8
	mov	DWORD PTR $T219760[ebp+8], edx
	mov	eax, DWORD PTR _guidICvUnknown+12
	mov	DWORD PTR $T219760[ebp+12], eax
	mov	ecx, DWORD PTR $T219760[ebp]
	mov	DWORD PTR $T219759[ebp], ecx
	mov	edx, DWORD PTR $T219760[ebp+4]
	mov	DWORD PTR $T219759[ebp+4], edx
	mov	eax, DWORD PTR $T219760[ebp+8]
	mov	DWORD PTR $T219759[ebp+8], eax
	mov	ecx, DWORD PTR $T219760[ebp+12]
	mov	DWORD PTR $T219759[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T219759[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv137[ebp], edx
	repe cmpsb
	je	SHORT $LN17@QueryInter
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv137[ebp], eax
$LN17@QueryInter:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv85[ebp], 0
	sete	dl
	test	edx, edx
	jne	SHORT $LN1@QueryInter
	mov	eax, DWORD PTR _guidICvDlcPackageInfo1
	mov	DWORD PTR $T219762[ebp], eax
	mov	ecx, DWORD PTR _guidICvDlcPackageInfo1+4
	mov	DWORD PTR $T219762[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvDlcPackageInfo1+8
	mov	DWORD PTR $T219762[ebp+8], edx
	mov	eax, DWORD PTR _guidICvDlcPackageInfo1+12
	mov	DWORD PTR $T219762[ebp+12], eax
	mov	ecx, DWORD PTR $T219762[ebp]
	mov	DWORD PTR $T219761[ebp], ecx
	mov	edx, DWORD PTR $T219762[ebp+4]
	mov	DWORD PTR $T219761[ebp+4], edx
	mov	eax, DWORD PTR $T219762[ebp+8]
	mov	DWORD PTR $T219761[ebp+8], eax
	mov	ecx, DWORD PTR $T219762[ebp+12]
	mov	DWORD PTR $T219761[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T219761[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv161[ebp], edx
	repe cmpsb
	je	SHORT $LN18@QueryInter
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv161[ebp], eax
$LN18@QueryInter:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv90[ebp], 0
	sete	dl
	test	edx, edx
	je	SHORT $LN2@QueryInter
$LN1@QueryInter:

; 27   : 	{
; 28   : 		IncrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ ; CvDllDlcPackageInfo::IncrementReference

; 29   : 		return this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN3@QueryInter
$LN2@QueryInter:

; 30   : 	}
; 31   : 
; 32   : 	return NULL;

	xor	eax, eax
$LN3@QueryInter:

; 33   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z ENDP ; CvDllDlcPackageInfo::QueryInterface
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ PROC	; CvDllDlcPackageInfo::IncrementReference, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 37   : 	++m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 38   : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 39   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ ENDP	; CvDllDlcPackageInfo::IncrementReference
_TEXT	ENDS
PUBLIC	??3CvDllDlcPackageInfo@@SAXPAX@Z		; CvDllDlcPackageInfo::operator delete
PUBLIC	?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ	; CvDllDlcPackageInfo::DecrementReference
; Function compile flags: /Odtp
;	COMDAT ?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T219794 = -8						; size = 4
$T219793 = -4						; size = 4
?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ PROC	; CvDllDlcPackageInfo::DecrementReference, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 	if(m_uiRefCount == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN2@DecrementR

; 44   : 	{
; 45   : 		delete this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T219794[ebp], ecx
	mov	edx, DWORD PTR $T219794[ebp]
	mov	DWORD PTR $T219793[ebp], edx
	cmp	DWORD PTR $T219793[ebp], 0
	je	SHORT $LN5@DecrementR
	mov	ecx, DWORD PTR $T219793[ebp]
	call	??1CvDllDlcPackageInfo@@QAE@XZ		; CvDllDlcPackageInfo::~CvDllDlcPackageInfo
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN8@DecrementR
	mov	ecx, DWORD PTR $T219793[ebp]
	push	ecx
	call	??3CvDllDlcPackageInfo@@SAXPAX@Z	; CvDllDlcPackageInfo::operator delete
	add	esp, 4
$LN8@DecrementR:
	mov	edx, DWORD PTR $T219793[ebp]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN6@DecrementR
$LN5@DecrementR:
	mov	DWORD PTR tv70[ebp], 0
$LN6@DecrementR:

; 46   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@DecrementR

; 47   : 	}
; 48   : 	else

	jmp	SHORT $LN3@DecrementR
$LN2@DecrementR:

; 49   : 	{
; 50   : 		--m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 51   : 		return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
$LN3@DecrementR:

; 52   : 	}
; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ ENDP	; CvDllDlcPackageInfo::DecrementReference
_TEXT	ENDS
PUBLIC	?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ	; CvDllDlcPackageInfo::GetReferenceCount
; Function compile flags: /Odtp
;	COMDAT ?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ PROC	; CvDllDlcPackageInfo::GetReferenceCount, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 58   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ ENDP	; CvDllDlcPackageInfo::GetReferenceCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@CvDllDlcPackageInfo@@EAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Destroy@CvDllDlcPackageInfo@@EAGXXZ PROC		; CvDllDlcPackageInfo::Destroy, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp

; 62   : 	DecrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ ; CvDllDlcPackageInfo::DecrementReference

; 63   : }

	pop	ebp
	ret	4
?Destroy@CvDllDlcPackageInfo@@EAGXXZ ENDP		; CvDllDlcPackageInfo::Destroy
_TEXT	ENDS
EXTRN	?Free@CvDllGameContext@@SAXPAX@Z:PROC		; CvDllGameContext::Free
; Function compile flags: /Odtp
;	COMDAT ??3CvDllDlcPackageInfo@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CvDllDlcPackageInfo@@SAXPAX@Z PROC			; CvDllDlcPackageInfo::operator delete, COMDAT

; 66   : {

	push	ebp
	mov	ebp, esp

; 67   : 	CvDllGameContext::Free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 68   : }

	pop	ebp
	ret	0
??3CvDllDlcPackageInfo@@SAXPAX@Z ENDP			; CvDllDlcPackageInfo::operator delete
_TEXT	ENDS
PUBLIC	??2CvDllDlcPackageInfo@@SAPAXI@Z		; CvDllDlcPackageInfo::operator new
EXTRN	?Allocate@CvDllGameContext@@SAPAXI@Z:PROC	; CvDllGameContext::Allocate
; Function compile flags: /Odtp
;	COMDAT ??2CvDllDlcPackageInfo@@SAPAXI@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
??2CvDllDlcPackageInfo@@SAPAXI@Z PROC			; CvDllDlcPackageInfo::operator new, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp

; 72   : 	return CvDllGameContext::Allocate(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
	add	esp, 4

; 73   : }

	pop	ebp
	ret	0
??2CvDllDlcPackageInfo@@SAPAXI@Z ENDP			; CvDllDlcPackageInfo::operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ PROC	; CvDllDlcPackageInfo::GetPackageID, COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   : 	return m_packageId;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 78   : }

	pop	ebp
	ret	8
?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ ENDP	; CvDllDlcPackageInfo::GetPackageID
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ ; std::_Vector_val<_GUID,std::allocator<_GUID> >::~_Vector_val<_GUID,std::allocator<_GUID> >
PUBLIC	??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
PUBLIC	??_7CvDllDlcPackageInfoList@@6B@		; CvDllDlcPackageInfoList::`vftable'
PUBLIC	??_7ICvEnumerator@@6B@				; ICvEnumerator::`vftable'
PUBLIC	??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z ; CvDllDlcPackageInfoList::CvDllDlcPackageInfoList
PUBLIC	?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z ; CvDllDlcPackageInfoList::QueryInterface
PUBLIC	?Destroy@CvDllDlcPackageInfoList@@EAGXXZ	; CvDllDlcPackageInfoList::Destroy
PUBLIC	?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ	; CvDllDlcPackageInfoList::MoveNext
PUBLIC	?Reset@CvDllDlcPackageInfoList@@UAGXXZ		; CvDllDlcPackageInfoList::Reset
PUBLIC	?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ ; CvDllDlcPackageInfoList::GetCurrent
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_7CvDllDlcPackageInfoList@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_7CvDllDlcPackageInfoList@@6B@ DD FLAT:?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z ; CvDllDlcPackageInfoList::`vftable'
	DD	FLAT:?Destroy@CvDllDlcPackageInfoList@@EAGXXZ
	DD	FLAT:?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ
	DD	FLAT:?Reset@CvDllDlcPackageInfoList@@UAGXXZ
	DD	FLAT:?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ
CONST	ENDS
;	COMDAT ??_7ICvEnumerator@@6B@
CONST	SEGMENT
??_7ICvEnumerator@@6B@ DD FLAT:__purecall		; ICvEnumerator::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z$1
__ehfuncinfo$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
xdata$x	ENDS
;	COMDAT ??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z
_TEXT	SEGMENT
tv162 = -80						; size = 4
tv187 = -76						; size = 4
_this$ = -72						; size = 4
$T219906 = -68						; size = 4
$T219905 = -64						; size = 4
$T219904 = -60						; size = 4
$T219880 = -54						; size = 1
$T219867 = -53						; size = 1
$T219863 = -52						; size = 4
$T219856 = -44						; size = 4
$T219888 = -38						; size = 1
$T219841 = -32						; size = 4
$T219837 = -28						; size = 4
$T219828 = -24						; size = 4
$T219814 = -20						; size = 4
$T219813 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_packageIDs$ = 8					; size = 4
??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z PROC ; CvDllDlcPackageInfoList::CvDllDlcPackageInfoList, COMDAT
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ICvUnknown@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ICvEnumerator@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7CvDllDlcPackageInfoList@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 1
	mov	ecx, DWORD PTR _packageIDs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T219828[ebp], edx
	mov	eax, DWORD PTR $T219828[ebp]
	mov	DWORD PTR $T219813[ebp], eax
	mov	ecx, DWORD PTR _packageIDs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T219837[ebp], edx
	mov	eax, DWORD PTR $T219837[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T219841[ebp], ecx
	mov	edx, DWORD PTR $T219841[ebp]
	mov	DWORD PTR $T219814[ebp], edx
	mov	eax, DWORD PTR $T219813[ebp]
	mov	DWORD PTR $T219906[ebp], eax
	mov	ecx, DWORD PTR $T219814[ebp]
	mov	DWORD PTR $T219905[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T219904[ebp], edx
	lea	eax, DWORD PTR $T219880[ebp]
	mov	DWORD PTR $T219856[ebp], eax
	lea	ecx, DWORD PTR $T219867[ebp]
	mov	DWORD PTR $T219863[ebp], ecx
	mov	edx, DWORD PTR $T219904[ebp]
	mov	DWORD PTR tv187[ebp], edx
	mov	eax, DWORD PTR $T219904[ebp]
	mov	DWORD PTR tv162[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	movzx	ecx, BYTE PTR $T219888[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219906[ebp]
	push	edx
	mov	eax, DWORD PTR $T219905[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219904[ebp]
	call	??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], -1

; 85   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z$1:
	mov	ecx, DWORD PTR $T219904[ebp]
	jmp	??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ
__ehhandler$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z ENDP ; CvDllDlcPackageInfoList::CvDllDlcPackageInfoList
PUBLIC	?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy
PUBLIC	??1CvDllDlcPackageInfoList@@QAE@XZ		; CvDllDlcPackageInfoList::~CvDllDlcPackageInfoList
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvDllDlcPackageInfoList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvDllDlcPackageInfoList@@QAE@XZ$1
__ehfuncinfo$??1CvDllDlcPackageInfoList@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvDllDlcPackageInfoList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
xdata$x	ENDS
;	COMDAT ??1CvDllDlcPackageInfoList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T220006 = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1CvDllDlcPackageInfoList@@QAE@XZ PROC			; CvDllDlcPackageInfoList::~CvDllDlcPackageInfoList, COMDAT
; _this$ = ecx

; 88   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvDllDlcPackageInfoList@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDllDlcPackageInfoList@@6B@

; 89   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T220006[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T220006[ebp]
	call	?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvDllDlcPackageInfoList@@QAE@XZ$1:
	mov	ecx, DWORD PTR $T220006[ebp]
	jmp	??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ
__ehhandler$??1CvDllDlcPackageInfoList@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvDllDlcPackageInfoList@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvDllDlcPackageInfoList@@QAE@XZ ENDP			; CvDllDlcPackageInfoList::~CvDllDlcPackageInfoList
PUBLIC	?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::IncrementReference
; Function compile flags: /Odtp
;	COMDAT ?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z
_TEXT	SEGMENT
tv90 = -88						; size = 4
tv161 = -84						; size = 4
tv85 = -80						; size = 4
tv137 = -76						; size = 4
$T220019 = -72						; size = 16
$T220018 = -56						; size = 16
$T220017 = -40						; size = 16
$T220016 = -20						; size = 16
_this$ = 8						; size = 4
_guidInterface$ = 12					; size = 16
?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z PROC ; CvDllDlcPackageInfoList::QueryInterface, COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi

; 93   : 	if(guidInterface == ICvUnknown::GetInterfaceId() ||
; 94   : 	        guidInterface == ICvEnumerator::GetInterfaceId())

	mov	eax, DWORD PTR _guidICvUnknown
	mov	DWORD PTR $T220017[ebp], eax
	mov	ecx, DWORD PTR _guidICvUnknown+4
	mov	DWORD PTR $T220017[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvUnknown+8
	mov	DWORD PTR $T220017[ebp+8], edx
	mov	eax, DWORD PTR _guidICvUnknown+12
	mov	DWORD PTR $T220017[ebp+12], eax
	mov	ecx, DWORD PTR $T220017[ebp]
	mov	DWORD PTR $T220016[ebp], ecx
	mov	edx, DWORD PTR $T220017[ebp+4]
	mov	DWORD PTR $T220016[ebp+4], edx
	mov	eax, DWORD PTR $T220017[ebp+8]
	mov	DWORD PTR $T220016[ebp+8], eax
	mov	ecx, DWORD PTR $T220017[ebp+12]
	mov	DWORD PTR $T220016[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T220016[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv137[ebp], edx
	repe cmpsb
	je	SHORT $LN17@QueryInter@2
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv137[ebp], eax
$LN17@QueryInter@2:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv85[ebp], 0
	sete	dl
	test	edx, edx
	jne	SHORT $LN1@QueryInter@2
	mov	eax, DWORD PTR _guidICvEnumerator
	mov	DWORD PTR $T220019[ebp], eax
	mov	ecx, DWORD PTR _guidICvEnumerator+4
	mov	DWORD PTR $T220019[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvEnumerator+8
	mov	DWORD PTR $T220019[ebp+8], edx
	mov	eax, DWORD PTR _guidICvEnumerator+12
	mov	DWORD PTR $T220019[ebp+12], eax
	mov	ecx, DWORD PTR $T220019[ebp]
	mov	DWORD PTR $T220018[ebp], ecx
	mov	edx, DWORD PTR $T220019[ebp+4]
	mov	DWORD PTR $T220018[ebp+4], edx
	mov	eax, DWORD PTR $T220019[ebp+8]
	mov	DWORD PTR $T220018[ebp+8], eax
	mov	ecx, DWORD PTR $T220019[ebp+12]
	mov	DWORD PTR $T220018[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T220018[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv161[ebp], edx
	repe cmpsb
	je	SHORT $LN18@QueryInter@2
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv161[ebp], eax
$LN18@QueryInter@2:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv90[ebp], 0
	sete	dl
	test	edx, edx
	je	SHORT $LN2@QueryInter@2
$LN1@QueryInter@2:

; 95   : 	{
; 96   : 		IncrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::IncrementReference

; 97   : 		return this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN3@QueryInter@2
$LN2@QueryInter@2:

; 98   : 	}
; 99   : 
; 100  : 	return NULL;

	xor	eax, eax
$LN3@QueryInter@2:

; 101  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z ENDP ; CvDllDlcPackageInfoList::QueryInterface
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ PROC ; CvDllDlcPackageInfoList::IncrementReference, COMDAT
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 	++m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 106  : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ ENDP ; CvDllDlcPackageInfoList::IncrementReference
_TEXT	ENDS
PUBLIC	??3CvDllDlcPackageInfoList@@SAXPAX@Z		; CvDllDlcPackageInfoList::operator delete
PUBLIC	?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::DecrementReference
; Function compile flags: /Odtp
;	COMDAT ?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T220051 = -8						; size = 4
$T220050 = -4						; size = 4
?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ PROC ; CvDllDlcPackageInfoList::DecrementReference, COMDAT
; _this$ = ecx

; 110  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 	if(m_uiRefCount == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	SHORT $LN2@DecrementR@2

; 112  : 	{
; 113  : 		delete this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T220051[ebp], ecx
	mov	edx, DWORD PTR $T220051[ebp]
	mov	DWORD PTR $T220050[ebp], edx
	cmp	DWORD PTR $T220050[ebp], 0
	je	SHORT $LN5@DecrementR@2
	mov	ecx, DWORD PTR $T220050[ebp]
	call	??1CvDllDlcPackageInfoList@@QAE@XZ	; CvDllDlcPackageInfoList::~CvDllDlcPackageInfoList
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN8@DecrementR@2
	mov	ecx, DWORD PTR $T220050[ebp]
	push	ecx
	call	??3CvDllDlcPackageInfoList@@SAXPAX@Z	; CvDllDlcPackageInfoList::operator delete
	add	esp, 4
$LN8@DecrementR@2:
	mov	edx, DWORD PTR $T220050[ebp]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN6@DecrementR@2
$LN5@DecrementR@2:
	mov	DWORD PTR tv70[ebp], 0
$LN6@DecrementR@2:

; 114  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@DecrementR@2

; 115  : 	}
; 116  : 	else

	jmp	SHORT $LN3@DecrementR@2
$LN2@DecrementR@2:

; 117  : 	{
; 118  : 		--m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 119  : 		return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
$LN3@DecrementR@2:

; 120  : 	}
; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ ENDP ; CvDllDlcPackageInfoList::DecrementReference
_TEXT	ENDS
PUBLIC	?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::GetReferenceCount
; Function compile flags: /Odtp
;	COMDAT ?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ PROC	; CvDllDlcPackageInfoList::GetReferenceCount, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ ENDP	; CvDllDlcPackageInfoList::GetReferenceCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@CvDllDlcPackageInfoList@@EAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Destroy@CvDllDlcPackageInfoList@@EAGXXZ PROC		; CvDllDlcPackageInfoList::Destroy, COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  : 	DecrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::DecrementReference

; 131  : }

	pop	ebp
	ret	4
?Destroy@CvDllDlcPackageInfoList@@EAGXXZ ENDP		; CvDllDlcPackageInfoList::Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3CvDllDlcPackageInfoList@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CvDllDlcPackageInfoList@@SAXPAX@Z PROC		; CvDllDlcPackageInfoList::operator delete, COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp

; 135  : 	CvDllGameContext::Free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 136  : }

	pop	ebp
	ret	0
??3CvDllDlcPackageInfoList@@SAXPAX@Z ENDP		; CvDllDlcPackageInfoList::operator delete
_TEXT	ENDS
PUBLIC	??2CvDllDlcPackageInfoList@@SAPAXI@Z		; CvDllDlcPackageInfoList::operator new
; Function compile flags: /Odtp
;	COMDAT ??2CvDllDlcPackageInfoList@@SAPAXI@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
??2CvDllDlcPackageInfoList@@SAPAXI@Z PROC		; CvDllDlcPackageInfoList::operator new, COMDAT

; 139  : {

	push	ebp
	mov	ebp, esp

; 140  : 	return CvDllGameContext::Allocate(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
	add	esp, 4

; 141  : }

	pop	ebp
	ret	0
??2CvDllDlcPackageInfoList@@SAPAXI@Z ENDP		; CvDllDlcPackageInfoList::operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ
_TEXT	SEGMENT
$T220079 = -12						; size = 4
$T220075 = -8						; size = 4
$T220071 = -4						; size = 4
_this$ = 8						; size = 4
?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ PROC		; CvDllDlcPackageInfoList::MoveNext, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 145  : 	if(m_iIndex == -1)	// In the uninitialized state?

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jne	SHORT $LN4@MoveNext

; 146  : 	{
; 147  : 		if(m_packageIDs.size() > 0)	// Any in the list?

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T220071[ebp], ecx
	mov	edx, DWORD PTR $T220071[ebp]
	mov	eax, DWORD PTR $T220071[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	test	ecx, ecx
	jbe	SHORT $LN3@MoveNext

; 148  : 		{
; 149  : 			m_iIndex = 0;	// then we can start

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 150  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@MoveNext

; 151  : 		}
; 152  : 		else

	jmp	SHORT $LN4@MoveNext
$LN3@MoveNext:

; 153  : 			return false;	// Nope, just leave as -1 and return false

	xor	al, al
	jmp	SHORT $LN5@MoveNext
$LN4@MoveNext:

; 154  : 	}
; 155  : 
; 156  : 	if((size_t)m_iIndex < m_packageIDs.size())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T220075[ebp], eax
	mov	ecx, DWORD PTR $T220075[ebp]
	mov	edx, DWORD PTR $T220075[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	jae	SHORT $LN1@MoveNext

; 157  : 		m_iIndex++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN1@MoveNext:

; 158  : 
; 159  : 	return (size_t)m_iIndex < m_packageIDs.size();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T220079[ebp], edx
	mov	eax, DWORD PTR $T220079[ebp]
	mov	ecx, DWORD PTR $T220079[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], edx
	sbb	eax, eax
	neg	eax
$LN5@MoveNext:

; 160  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ ENDP		; CvDllDlcPackageInfoList::MoveNext
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Reset@CvDllDlcPackageInfoList@@UAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Reset@CvDllDlcPackageInfoList@@UAGXXZ PROC		; CvDllDlcPackageInfoList::Reset, COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  : 	m_iIndex = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], -1

; 165  : }

	pop	ebp
	ret	4
?Reset@CvDllDlcPackageInfoList@@UAGXXZ ENDP		; CvDllDlcPackageInfoList::Reset
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ$0
__ehfuncinfo$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
xdata$x	ENDS
;	COMDAT ?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ
_TEXT	SEGMENT
tv87 = -32						; size = 4
$T220096 = -28						; size = 4
$T220092 = -24						; size = 4
$T220085 = -20						; size = 4
$T220084 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ PROC ; CvDllDlcPackageInfoList::GetCurrent, COMDAT

; 168  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 169  : 	if(m_iIndex > -1 && (size_t)m_iIndex < m_packageIDs.size())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], -1
	jle	SHORT $LN1@GetCurrent
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T220092[ebp], ecx
	mov	edx, DWORD PTR $T220092[ebp]
	mov	eax, DWORD PTR $T220092[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], ecx
	jae	SHORT $LN1@GetCurrent

; 170  : 	{
; 171  : 		return new CvDllDlcPackageInfo(m_packageIDs[m_iIndex]);

	push	24					; 00000018H
	call	??2CvDllDlcPackageInfo@@SAPAXI@Z	; CvDllDlcPackageInfo::operator new
	add	esp, 4
	mov	DWORD PTR $T220085[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T220085[ebp], 0
	je	SHORT $LN4@GetCurrent
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR $T220096[ebp], ecx
	mov	eax, DWORD PTR $T220096[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220085[ebp]
	call	??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z ; CvDllDlcPackageInfo::CvDllDlcPackageInfo
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN5@GetCurrent
$LN4@GetCurrent:
	mov	DWORD PTR tv87[ebp], 0
$LN5@GetCurrent:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T220084[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T220084[ebp]
	jmp	SHORT $LN2@GetCurrent
$LN1@GetCurrent:

; 172  : 	}
; 173  : 
; 174  : 	return NULL;

	xor	eax, eax
$LN2@GetCurrent:

; 175  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ$0:
	mov	eax, DWORD PTR $T220085[ebp]
	push	eax
	call	??3CvDllDlcPackageInfo@@SAXPAX@Z	; CvDllDlcPackageInfo::operator delete
	pop	ecx
	ret	0
__ehhandler$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ ENDP ; CvDllDlcPackageInfoList::GetCurrent
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<_GUID,std::allocator<_GUID> >::~_Vector_val<_GUID,std::allocator<_GUID> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<_GUID,std::allocator<_GUID> >::~_Vector_val<_GUID,std::allocator<_GUID> >
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T220177 = -32						; size = 4
$T220176 = -28						; size = 4
$T220172 = -24						; size = 4
$T220171 = -20						; size = 4
$T220153 = -16						; size = 4
$T220152 = -12						; size = 4
$T220136 = -8						; size = 4
__Cat$220161 = -2					; size = 1
$T220158 = -1						; size = 1
?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220171[ebp], ecx
	mov	edx, DWORD PTR $T220172[ebp]
	mov	DWORD PTR $T220153[ebp], edx
	mov	eax, DWORD PTR $T220171[ebp]
	mov	DWORD PTR $T220152[ebp], eax
	mov	cl, BYTE PTR __Cat$220161[ebp]
	mov	BYTE PTR $T220158[ebp], cl
	mov	edx, DWORD PTR $T220152[ebp]
	mov	DWORD PTR $T220136[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T220136[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T220136[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T220136[ebp]
	cmp	ecx, DWORD PTR $T220153[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	DWORD PTR $T220177[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220176[ebp], eax
	mov	ecx, DWORD PTR $T220176[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
PUBLIC	?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Buy
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$0
__unwindtable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$4
__ehfuncinfo$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -160						; size = 4
$T220251 = -124						; size = 4
$T220247 = -118						; size = 1
$T220230 = -116						; size = 4
$T220181 = -24						; size = 4
$T220180 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 532  : 		void _Construct(_Iter _First,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 			_Iter _Last, input_iterator_tag)
; 534  : 		{	// initialize with [_First, _Last), input iterators
; 535  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Buy

; 536  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 537  : 		insert(begin(), _First, _Last);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220230[ebp], ecx
	mov	edx, DWORD PTR $T220230[ebp]
	mov	DWORD PTR $T220181[ebp], edx
	mov	eax, DWORD PTR $T220181[ebp]
	mov	DWORD PTR $T220180[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220251[ebp], ecx
	movzx	edx, BYTE PTR $T220247[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220251[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220180[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
	jmp	SHORT $LN4@Construct
__catch$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$0:

; 538  : 		_CATCH_ALL
; 539  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy

; 540  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 541  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Construct
	ret	0
$LN4@Construct:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Construct:

; 542  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
PUBLIC	??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z	; std::_Allocate<_GUID>
PUBLIC	?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$220343 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$220343[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$220343[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$220343[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z ; std::_Allocate<_GUID>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Buy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T220374 = -80						; size = 28
$T220373 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T220374[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T220373[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T220373[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T220374[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220373[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T220373[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T220373[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T220374[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T220374[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T220373[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z
_TEXT	SEGMENT
$T220399 = -16						; size = 4
$T220395 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z PROC	; std::_Allocate<_GUID>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T220399[ebp], 0
	lea	eax, DWORD PTR $T220399[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220395[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T220395[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220395[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z ENDP	; std::_Allocate<_GUID>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
PUBLIC	??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >
PUBLIC	__$ArrayPad$220806
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__catchsym$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$3
__ehfuncinfo$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
tv215 = -352						; size = 4
tv214 = -348						; size = 4
tv87 = -344						; size = 4
tv260 = -340						; size = 4
tv246 = -336						; size = 4
tv227 = -332						; size = 4
_this$ = -328						; size = 4
$T220869 = -324						; size = 4
$T220868 = -320						; size = 4
__Tmp$220865 = -316					; size = 16
$T220839 = -296						; size = 4
$T220838 = -292						; size = 4
__Tmp$220835 = -288					; size = 16
$T220809 = -268						; size = 4
$T220808 = -264						; size = 4
__Tmp$220805 = -260					; size = 16
__$ArrayPad$220806 = -244				; size = 4
$T220779 = -240						; size = 4
$T220769 = -236						; size = 4
$T220768 = -232						; size = 4
__Cat$220777 = -227					; size = 1
$T220775 = -226						; size = 1
$T220774 = -225						; size = 1
$T220752 = -224						; size = 4
$T220751 = -220						; size = 4
$T220747 = -216						; size = 4
$T220746 = -212						; size = 4
$T220728 = -208						; size = 4
$T220727 = -204						; size = 4
$T220711 = -200						; size = 4
__Cat$220734 = -194					; size = 1
$T220731 = -193						; size = 1
$T220662 = -192						; size = 4
$T220661 = -188						; size = 4
$T220645 = -184						; size = 4
__Cat$220668 = -178					; size = 1
$T220665 = -177						; size = 1
$T220619 = -176						; size = 4
$T220607 = -172						; size = 4
$T220597 = -165						; size = 1
$T220596 = -164						; size = 4
__Cat$220615 = -159					; size = 1
$T220613 = -158						; size = 1
$T220612 = -157						; size = 1
$T220575 = -156						; size = 4
$T220574 = -152						; size = 4
__Cat$220583 = -147					; size = 1
$T220581 = -146						; size = 1
$T220580 = -145						; size = 1
$T220558 = -144						; size = 4
$T220546 = -140						; size = 4
$T220536 = -133						; size = 1
$T220535 = -132						; size = 4
__Cat$220554 = -127					; size = 1
$T220552 = -126						; size = 1
$T220551 = -125						; size = 1
__Count$220511 = -124					; size = 4
__Count$220485 = -52					; size = 4
$T220465 = -48						; size = 4
$T220445 = -44						; size = 4
$T220444 = -40						; size = 4
__Newvec$219228 = -32					; size = 4
__Ptr$219229 = -28					; size = 4
__Capacity$ = -24					; size = 4
__Count$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 925  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$220806[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 926  : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 927  : 		{	// insert [_First, _Last) at _Where, forward iterators
; 928  : 
; 929  :  #if _HAS_ITERATOR_DEBUGGING
; 930  : 		if (_Where._Mycont != this
; 931  : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 932  : 			_DEBUG_ERROR("vector insert iterator outside range");
; 933  : 		_DEBUG_RANGE(_First, _Last);
; 934  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 935  : 
; 936  : 		size_type _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 937  : 		_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220465[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T220445[ebp], ecx
	mov	edx, DWORD PTR $T220465[ebp]
	mov	DWORD PTR $T220444[ebp], edx
	jmp	SHORT $LN31@Insert
$LN29@Insert:
	mov	eax, DWORD PTR $T220444[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T220444[ebp], ecx
$LN31@Insert:
	mov	edx, DWORD PTR $T220444[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T220445[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN18@Insert
	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	jmp	SHORT $LN29@Insert
$LN18@Insert:

; 938  : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN37@Insert
	mov	DWORD PTR tv227[ebp], 0
	jmp	SHORT $LN35@Insert
$LN37@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	mov	DWORD PTR tv227[ebp], ecx
$LN35@Insert:
	mov	edx, DWORD PTR tv227[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 939  : 
; 940  : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN9@Insert
	jmp	$LN11@Insert
$LN9@Insert:

; 941  : 			;
; 942  : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$220485[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$220485[ebp], 0
	jbe	SHORT $LN43@Insert
	mov	eax, DWORD PTR __Count$220485[ebp]
	mov	DWORD PTR tv246[ebp], eax
	jmp	SHORT $LN45@Insert
$LN43@Insert:
	mov	DWORD PTR tv246[ebp], 1
$LN45@Insert:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	mov	ecx, DWORD PTR tv246[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN50@Insert

; 943  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen
	jmp	$LN11@Insert

; 944  : 		else if (_Capacity < size() + _Count)

$LN50@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], ecx
	jae	$LN5@Insert

; 945  : 			{	// not enough room, reallocate
; 946  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 947  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$220511[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$220511[ebp], 0
	jbe	SHORT $LN56@Insert
	mov	edx, DWORD PTR __Count$220511[ebp]
	mov	DWORD PTR tv260[ebp], edx
	jmp	SHORT $LN52@Insert
$LN56@Insert:
	mov	DWORD PTR tv260[ebp], 1
$LN52@Insert:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv260[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN12@Insert
	mov	DWORD PTR tv87[ebp], 0
	jmp	SHORT $LN13@Insert
$LN12@Insert:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv87[ebp], edx
$LN13@Insert:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 948  : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN62@Insert

; 949  : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 950  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN62@Insert:
	push	0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	call	??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z ; std::_Allocate<_GUID>
	add	esp, 8
	mov	DWORD PTR __Newvec$219228[ebp], eax

; 951  : 			pointer _Ptr = _Newvec;

	mov	edx, DWORD PTR __Newvec$219228[ebp]
	mov	DWORD PTR __Ptr$219229[ebp], edx

; 952  : 
; 953  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 954  : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 955  : 				_Newvec);	// copy prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220558[ebp], ecx
	mov	edx, DWORD PTR __Newvec$219228[ebp]
	mov	DWORD PTR $T220546[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T220551[ebp], al
	mov	cl, BYTE PTR __Cat$220554[ebp]
	mov	BYTE PTR $T220552[ebp], cl
	mov	dl, BYTE PTR $T220551[ebp]
	mov	BYTE PTR $T220536[ebp], dl
	mov	eax, DWORD PTR $T220546[ebp]
	mov	DWORD PTR $T220535[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220535[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220558[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv214[ebp], eax
	mov	edx, DWORD PTR tv214[ebp]
	mov	DWORD PTR __Ptr$219229[ebp], edx

; 956  : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff

	mov	eax, DWORD PTR __Ptr$219229[ebp]
	mov	DWORD PTR $T220575[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220574[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220580[ebp], dl
	mov	al, BYTE PTR __Cat$220583[ebp]
	mov	BYTE PTR $T220581[ebp], al
	movzx	ecx, BYTE PTR $T220580[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T220581[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220575[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220574[ebp]
	push	eax
	call	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	ecx, DWORD PTR tv215[ebp]
	mov	DWORD PTR __Ptr$219229[ebp], ecx

; 957  : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220619[ebp], eax
	mov	ecx, DWORD PTR __Ptr$219229[ebp]
	mov	DWORD PTR $T220607[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220612[ebp], dl
	mov	al, BYTE PTR __Cat$220615[ebp]
	mov	BYTE PTR $T220613[ebp], al
	mov	cl, BYTE PTR $T220612[ebp]
	mov	BYTE PTR $T220597[ebp], cl
	mov	edx, DWORD PTR $T220607[ebp]
	mov	DWORD PTR $T220596[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220596[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220619[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >
	add	esp, 16					; 00000010H
	jmp	SHORT $LN14@Insert
__catch$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$0:

; 958  : 			_CATCH_ALL
; 959  : 			_Destroy(_Newvec, _Ptr);

	mov	ecx, DWORD PTR __Ptr$219229[ebp]
	mov	DWORD PTR $T220662[ebp], ecx
	mov	edx, DWORD PTR __Newvec$219228[ebp]
	mov	DWORD PTR $T220661[ebp], edx
	mov	al, BYTE PTR __Cat$220668[ebp]
	mov	BYTE PTR $T220665[ebp], al
	mov	ecx, DWORD PTR $T220661[ebp]
	mov	DWORD PTR $T220645[ebp], ecx
	jmp	SHORT $LN94@Insert
$LN93@Insert:
	mov	edx, DWORD PTR $T220645[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T220645[ebp], edx
$LN94@Insert:
	mov	eax, DWORD PTR $T220645[ebp]
	cmp	eax, DWORD PTR $T220662[ebp]
	je	SHORT $LN86@Insert
	jmp	SHORT $LN93@Insert
$LN86@Insert:

; 960  : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$219228[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 961  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 962  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert
	ret	0
$LN14@Insert:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 963  : 
; 964  : 			_Count += size();

$LN103@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 4
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 965  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN2@Insert

; 966  : 				{	// destroy and deallocate old array
; 967  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220747[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220746[ebp], eax
	mov	ecx, DWORD PTR $T220747[ebp]
	mov	DWORD PTR $T220728[ebp], ecx
	mov	edx, DWORD PTR $T220746[ebp]
	mov	DWORD PTR $T220727[ebp], edx
	mov	al, BYTE PTR __Cat$220734[ebp]
	mov	BYTE PTR $T220731[ebp], al
	mov	ecx, DWORD PTR $T220727[ebp]
	mov	DWORD PTR $T220711[ebp], ecx
	jmp	SHORT $LN113@Insert
$LN112@Insert:
	mov	edx, DWORD PTR $T220711[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T220711[ebp], edx
$LN113@Insert:
	mov	eax, DWORD PTR $T220711[ebp]
	cmp	eax, DWORD PTR $T220728[ebp]
	je	SHORT $LN105@Insert
	jmp	SHORT $LN112@Insert
$LN105@Insert:

; 968  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 4
	mov	DWORD PTR $T220752[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220751[ebp], edx
	mov	eax, DWORD PTR $T220751[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Insert:

; 969  : 				}
; 970  : 
; 971  :  #if _HAS_ITERATOR_DEBUGGING
; 972  : 			this->_Orphan_all();
; 973  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 974  : 
; 975  : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$219228[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 976  : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$219228[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 977  : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$219228[ebp]
	mov	DWORD PTR [edx+4], eax

; 978  : 			}
; 979  : 		else

	jmp	$LN11@Insert
$LN5@Insert:

; 980  : 			{	// new stuff fits, append and rotate into place
; 981  : 			_Ucopy(_First, _Last, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220779[ebp], edx
	mov	eax, DWORD PTR $T220779[ebp]
	mov	DWORD PTR $T220769[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220768[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220774[ebp], dl
	mov	al, BYTE PTR __Cat$220777[ebp]
	mov	BYTE PTR $T220775[ebp], al
	movzx	ecx, BYTE PTR $T220774[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T220775[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220769[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220768[ebp]
	push	eax
	call	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
	add	esp, 24					; 00000018H

; 982  : 
; 983  : 			_Reverse(_Where._Myptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220809[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220808[ebp], eax
	jmp	SHORT $LN130@Insert
$LN129@Insert:
	mov	ecx, DWORD PTR $T220808[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T220808[ebp], ecx
$LN130@Insert:
	mov	edx, DWORD PTR $T220808[ebp]
	cmp	edx, DWORD PTR $T220809[ebp]
	je	$LN131@Insert
	mov	eax, DWORD PTR $T220809[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR $T220809[ebp], eax
	mov	ecx, DWORD PTR $T220808[ebp]
	cmp	ecx, DWORD PTR $T220809[ebp]
	je	$LN131@Insert
	mov	edx, DWORD PTR $T220808[ebp]
	cmp	edx, DWORD PTR $T220809[ebp]
	je	SHORT $LN133@Insert
	mov	eax, DWORD PTR $T220808[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$220805[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$220805[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$220805[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$220805[ebp+12], edx
	mov	eax, DWORD PTR $T220809[ebp]
	mov	ecx, DWORD PTR $T220808[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T220809[ebp]
	mov	edx, DWORD PTR __Tmp$220805[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$220805[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$220805[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Tmp$220805[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN133@Insert:
	jmp	$LN129@Insert
$LN131@Insert:

; 984  : 			_Reverse(_Mylast, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR $T220839[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220838[ebp], ecx
	jmp	SHORT $LN140@Insert
$LN139@Insert:
	mov	edx, DWORD PTR $T220838[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T220838[ebp], edx
$LN140@Insert:
	mov	eax, DWORD PTR $T220838[ebp]
	cmp	eax, DWORD PTR $T220839[ebp]
	je	$LN141@Insert
	mov	ecx, DWORD PTR $T220839[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T220839[ebp], ecx
	mov	edx, DWORD PTR $T220838[ebp]
	cmp	edx, DWORD PTR $T220839[ebp]
	je	$LN141@Insert
	mov	eax, DWORD PTR $T220838[ebp]
	cmp	eax, DWORD PTR $T220839[ebp]
	je	SHORT $LN143@Insert
	mov	ecx, DWORD PTR $T220838[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$220835[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$220835[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$220835[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$220835[ebp+12], eax
	mov	ecx, DWORD PTR $T220839[ebp]
	mov	edx, DWORD PTR $T220838[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T220839[ebp]
	mov	eax, DWORD PTR __Tmp$220835[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$220835[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$220835[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$220835[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN143@Insert:
	jmp	$LN139@Insert
$LN141@Insert:

; 985  : 			_Reverse(_Where._Myptr, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220869[ebp], edx
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220868[ebp], ecx
	jmp	SHORT $LN150@Insert
$LN149@Insert:
	mov	edx, DWORD PTR $T220868[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T220868[ebp], edx
$LN150@Insert:
	mov	eax, DWORD PTR $T220868[ebp]
	cmp	eax, DWORD PTR $T220869[ebp]
	je	$LN151@Insert
	mov	ecx, DWORD PTR $T220869[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR $T220869[ebp], ecx
	mov	edx, DWORD PTR $T220868[ebp]
	cmp	edx, DWORD PTR $T220869[ebp]
	je	$LN151@Insert
	mov	eax, DWORD PTR $T220868[ebp]
	cmp	eax, DWORD PTR $T220869[ebp]
	je	SHORT $LN153@Insert
	mov	ecx, DWORD PTR $T220868[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$220865[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$220865[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$220865[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$220865[ebp+12], eax
	mov	ecx, DWORD PTR $T220869[ebp]
	mov	edx, DWORD PTR $T220868[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T220869[ebp]
	mov	eax, DWORD PTR __Tmp$220865[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$220865[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$220865[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$220865[ebp+12]
	mov	DWORD PTR [edx+12], ecx
$LN153@Insert:
	jmp	$LN149@Insert
$LN151@Insert:

; 986  : 
; 987  : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN11@Insert:

; 988  : 
; 989  :  #if _HAS_ITERATOR_DEBUGGING
; 990  : 			_Orphan_range(_Where._Myptr, _Mylast);
; 991  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 992  : 
; 993  : 			}
; 994  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$220806[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv129 = -36						; size = 4
$T220935 = -32						; size = 4
$T220930 = -28						; size = 4
__Vptr$220928 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN18@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __First$[ebp], eax
$LN18@Uninit_cop:
	mov	ecx, DWORD PTR __First$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR $T220935[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$220928[ebp], eax
	mov	ecx, DWORD PTR __Vptr$220928[ebp]
	mov	DWORD PTR $T220930[ebp], ecx
	cmp	DWORD PTR $T220930[ebp], 0
	je	SHORT $LN30@Uninit_cop
	mov	edx, DWORD PTR $T220935[ebp]
	mov	eax, DWORD PTR $T220930[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T220930[ebp]
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN26@Uninit_cop
$LN30@Uninit_cop:
	mov	DWORD PTR tv129[ebp], 0
$LN26@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
PUBLIC	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z
_TEXT	SEGMENT
__Cat$220960 = -3					; size = 1
$T220956 = -2						; size = 1
$T220955 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T220955[ebp], al
	mov	cl, BYTE PTR __Cat$220960[ebp]
	mov	BYTE PTR $T220956[ebp], cl
	movzx	edx, BYTE PTR $T220955[ebp]
	push	edx
	movzx	eax, BYTE PTR $T220956[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T220988 = -28						; size = 4
__Vptr$220986 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$220986[ebp], ecx
	mov	edx, DWORD PTR __Vptr$220986[ebp]
	mov	DWORD PTR $T220988[ebp], edx
	cmp	DWORD PTR $T220988[ebp], 0
	je	SHORT $LN18@Uninit_cop@2
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T220988[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T220988[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop@2
$LN18@Uninit_cop@2:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop@2:
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
