; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvBuildingClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@CHIGIAJF@BBB0D085?9A0B1?94475?9B007?93E549CF3@ ; `string'
PUBLIC	??_C@_0CF@BGPMLEKF@2968ab37?929a3?94de7?98b84?9ece68823@ ; `string'
;	COMDAT ??_C@_0CF@CHIGIAJF@BBB0D085?9A0B1?94475?9B007?93E549CF3@
CONST	SEGMENT
??_C@_0CF@CHIGIAJF@BBB0D085?9A0B1?94475?9B007?93E549CF3@ DB 'BBB0D085-A0B'
	DB	'1-4475-B007-3E549CF3ADC3', 00H		; `string'
CONST	ENDS
CONST	SEGMENT
_CIV5_DLC_06_SCENARIO_MODID DD FLAT:??_C@_0CF@BGPMLEKF@2968ab37?929a3?94de7?98b84?9ece68823@
_CIV5_DLC_06_PACKAGEID DD FLAT:??_C@_0CF@CHIGIAJF@BBB0D085?9A0B1?94475?9B007?93E549CF3@
CONST	ENDS
;	COMDAT ??_C@_0CF@BGPMLEKF@2968ab37?929a3?94de7?98b84?9ece68823@
CONST	SEGMENT
??_C@_0CF@BGPMLEKF@2968ab37?929a3?94de7?98b84?9ece68823@ DB '2968ab37-29a'
	DB	'3-4de7-8b84-ece688231e40', 00H		; `string'
CONST	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
PUBLIC	??_7CvBuildingEntry@@6B@			; CvBuildingEntry::`vftable'
PUBLIC	??0CvBuildingEntry@@QAE@XZ			; CvBuildingEntry::CvBuildingEntry
PUBLIC	?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBuildingEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_7CvBuildingEntry@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_7CvBuildingEntry@@6B@ DD FLAT:?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBuildingEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvBuildingEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$3
__ehfuncinfo$??0CvBuildingEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvBuildingEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvBuildingEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T225660 = -24						; size = 4
$T225655 = -20						; size = 4
$T225650 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvBuildingEntry@@QAE@XZ PROC				; CvBuildingEntry::CvBuildingEntry, COMDAT
; _this$ = ecx

; 232  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvBuildingEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvBuildingEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+304], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+316], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+336], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+340], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+348], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+352], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+356], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+364], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+368], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+372], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+376], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+380], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+392], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+404], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+408], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+412], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+424], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+428], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+432], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+436], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+440], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+444], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+448], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+452], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+456], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+460], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+508], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+512], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+516], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+524], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+528], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+532], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+536], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+540], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+544], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+548], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+552], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+556], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+560], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+564], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+568], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+572], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+576], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+580], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+584], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+588], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+589], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+592], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+596], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+600], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+604], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+608], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+612], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+616], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+620], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+624], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+628], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+632], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+636], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+640], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+644], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+648], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+652], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+656], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+660], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+664], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+668], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+672], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+676], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+680], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+684], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+688], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+692], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+696], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+700], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+704], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+708], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+712], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+716], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+717], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+718], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+719], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+720], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+721], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+722], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+723], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+724], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+725], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+726], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+727], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+728], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+729], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+730], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+731], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+732], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+733], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+734], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+735], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+736], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+737], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+738], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+739], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+740], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+741], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+742], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+743], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+744], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+745], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+746], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+747], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+748], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 752				; 000002f0H
	mov	DWORD PTR $T225650[ebp], edx
	mov	ecx, DWORD PTR $T225650[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 780				; 0000030cH
	mov	DWORD PTR $T225655[ebp], eax
	mov	ecx, DWORD PTR $T225655[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 808				; 00000328H
	mov	DWORD PTR $T225660[ebp], ecx
	mov	ecx, DWORD PTR $T225660[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+836], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+840], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+844], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+848], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+852], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+856], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+860], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+864], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+868], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+872], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+876], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+880], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+884], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+888], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+892], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+896], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+900], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+904], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+912], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+916], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+920], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+924], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+928], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+932], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+936], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+940], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+944], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+948], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+952], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+956], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+960], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	call	??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+976], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+980], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+984], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+988], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+992], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+996], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1000], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1004], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1008], 0

; 233  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvBuildingEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 808				; 00000328H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvBuildingEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvBuildingEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBuildingEntry@@QAE@XZ ENDP				; CvBuildingEntry::CvBuildingEntry
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T225919 = -48						; size = 4
$T225914 = -44						; size = 4
$T225909 = -40						; size = 4
$T225904 = -36						; size = 4
$T225899 = -32						; size = 4
$T225894 = -28						; size = 4
$T225889 = -24						; size = 4
$T225884 = -20						; size = 4
$T225879 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T225879[ebp], eax
	mov	ecx, DWORD PTR $T225879[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T225884[ebp], ecx
	mov	ecx, DWORD PTR $T225884[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T225889[ebp], edx
	mov	ecx, DWORD PTR $T225889[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T225894[ebp], eax
	mov	ecx, DWORD PTR $T225894[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T225899[ebp], ecx
	mov	ecx, DWORD PTR $T225899[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T225904[ebp], edx
	mov	ecx, DWORD PTR $T225904[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T225909[ebp], eax
	mov	ecx, DWORD PTR $T225909[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T225914[ebp], ecx
	mov	ecx, DWORD PTR $T225914[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T225919[ebp], edx
	mov	ecx, DWORD PTR $T225919[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
PUBLIC	??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear
PUBLIC	??_ECvThemingBonusInfo@@QAEPAXI@Z		; CvThemingBonusInfo::`vector deleting destructor'
PUBLIC	??1CvBuildingEntry@@QAE@XZ			; CvBuildingEntry::~CvBuildingEntry
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvBuildingEntry@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1CvBuildingEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBuildingEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$16
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvBuildingEntry@@QAE@XZ
_TEXT	SEGMENT
tv213 = -392						; size = 4
_this$ = -388						; size = 4
$T226544 = -348						; size = 4
$T226539 = -344						; size = 4
$T226534 = -340						; size = 4
$T226529 = -336						; size = 4
$T226142 = -276						; size = 4
$T226138 = -268						; size = 4
$T226137 = -264						; size = 4
$T226118 = -260						; size = 4
$T226116 = -256						; size = 4
$T226112 = -252						; size = 4
$T226110 = -248						; size = 4
$T226106 = -244						; size = 4
$T226104 = -240						; size = 4
$T226100 = -236						; size = 4
$T226098 = -232						; size = 4
$T226094 = -228						; size = 4
$T226092 = -224						; size = 4
$T226088 = -220						; size = 4
$T226086 = -216						; size = 4
$T226082 = -212						; size = 4
$T226080 = -208						; size = 4
$T226076 = -204						; size = 4
$T226074 = -200						; size = 4
$T226070 = -196						; size = 4
$T226068 = -192						; size = 4
$T226064 = -188						; size = 4
$T226062 = -184						; size = 4
$T226058 = -180						; size = 4
$T226056 = -176						; size = 4
$T226052 = -172						; size = 4
$T226050 = -168						; size = 4
$T226046 = -164						; size = 4
$T226044 = -160						; size = 4
$T226040 = -156						; size = 4
$T226038 = -152						; size = 4
$T226034 = -148						; size = 4
$T226032 = -144						; size = 4
$T226028 = -140						; size = 4
$T226026 = -136						; size = 4
$T226022 = -132						; size = 4
$T226020 = -128						; size = 4
$T226016 = -124						; size = 4
$T226014 = -120						; size = 4
$T226010 = -116						; size = 4
$T226008 = -112						; size = 4
$T226004 = -108						; size = 4
$T226002 = -104						; size = 4
$T225998 = -100						; size = 4
$T225996 = -96						; size = 4
$T225992 = -92						; size = 4
$T225990 = -88						; size = 4
$T225986 = -84						; size = 4
$T225984 = -80						; size = 4
$T225980 = -76						; size = 4
$T225978 = -72						; size = 4
$T225974 = -68						; size = 4
$T225972 = -64						; size = 4
$T225968 = -60						; size = 4
$T225966 = -56						; size = 4
$T225962 = -52						; size = 4
$T225960 = -48						; size = 4
$T225956 = -44						; size = 4
$T225954 = -40						; size = 4
$T225950 = -36						; size = 4
$T225948 = -32						; size = 4
$T225944 = -28						; size = 4
$T225942 = -24						; size = 4
$T225938 = -20						; size = 4
$T225936 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBuildingEntry@@QAE@XZ PROC				; CvBuildingEntry::~CvBuildingEntry, COMDAT
; _this$ = ecx

; 237  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBuildingEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 380				; 0000017cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvBuildingEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 238  : 	SAFE_DELETE_ARRAY(m_piLockedBuildingClasses);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 836				; 00000344H
	mov	DWORD PTR $T225938[ebp], ecx
	mov	edx, DWORD PTR $T225938[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225936[ebp], eax
	mov	ecx, DWORD PTR $T225936[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T225938[ebp]
	mov	DWORD PTR [edx], 0

; 239  : 	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 840				; 00000348H
	mov	DWORD PTR $T225944[ebp], eax
	mov	ecx, DWORD PTR $T225944[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225942[ebp], edx
	mov	eax, DWORD PTR $T225942[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T225944[ebp]
	mov	DWORD PTR [ecx], 0

; 240  : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 844				; 0000034cH
	mov	DWORD PTR $T225950[ebp], edx
	mov	eax, DWORD PTR $T225950[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225948[ebp], ecx
	mov	edx, DWORD PTR $T225948[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T225950[ebp]
	mov	DWORD PTR [eax], 0

; 241  : 	SAFE_DELETE_ARRAY(m_piResourceQuantity);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 848				; 00000350H
	mov	DWORD PTR $T225956[ebp], ecx
	mov	edx, DWORD PTR $T225956[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225954[ebp], eax
	mov	ecx, DWORD PTR $T225954[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T225956[ebp]
	mov	DWORD PTR [edx], 0

; 242  : 	SAFE_DELETE_ARRAY(m_piResourceCultureChanges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 852				; 00000354H
	mov	DWORD PTR $T225962[ebp], eax
	mov	ecx, DWORD PTR $T225962[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225960[ebp], edx
	mov	eax, DWORD PTR $T225960[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T225962[ebp]
	mov	DWORD PTR [ecx], 0

; 243  : 	SAFE_DELETE_ARRAY(m_piResourceFaithChanges);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 856				; 00000358H
	mov	DWORD PTR $T225968[ebp], edx
	mov	eax, DWORD PTR $T225968[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225966[ebp], ecx
	mov	edx, DWORD PTR $T225966[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T225968[ebp]
	mov	DWORD PTR [eax], 0

; 244  : 	SAFE_DELETE_ARRAY(m_piProductionTraits);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 860				; 0000035cH
	mov	DWORD PTR $T225974[ebp], ecx
	mov	edx, DWORD PTR $T225974[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225972[ebp], eax
	mov	ecx, DWORD PTR $T225972[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T225974[ebp]
	mov	DWORD PTR [edx], 0

; 245  : 	SAFE_DELETE_ARRAY(m_piSeaPlotYieldChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 864				; 00000360H
	mov	DWORD PTR $T225980[ebp], eax
	mov	ecx, DWORD PTR $T225980[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225978[ebp], edx
	mov	eax, DWORD PTR $T225978[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T225980[ebp]
	mov	DWORD PTR [ecx], 0

; 246  : 	SAFE_DELETE_ARRAY(m_piRiverPlotYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 868				; 00000364H
	mov	DWORD PTR $T225986[ebp], edx
	mov	eax, DWORD PTR $T225986[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225984[ebp], ecx
	mov	edx, DWORD PTR $T225984[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T225986[ebp]
	mov	DWORD PTR [eax], 0

; 247  : 	SAFE_DELETE_ARRAY(m_piLakePlotYieldChange);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 872				; 00000368H
	mov	DWORD PTR $T225992[ebp], ecx
	mov	edx, DWORD PTR $T225992[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225990[ebp], eax
	mov	ecx, DWORD PTR $T225990[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T225992[ebp]
	mov	DWORD PTR [edx], 0

; 248  : 	SAFE_DELETE_ARRAY(m_piSeaResourceYieldChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 876				; 0000036cH
	mov	DWORD PTR $T225998[ebp], eax
	mov	ecx, DWORD PTR $T225998[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225996[ebp], edx
	mov	eax, DWORD PTR $T225996[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T225998[ebp]
	mov	DWORD PTR [ecx], 0

; 249  : 	SAFE_DELETE_ARRAY(m_piYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 880				; 00000370H
	mov	DWORD PTR $T226004[ebp], edx
	mov	eax, DWORD PTR $T226004[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226002[ebp], ecx
	mov	edx, DWORD PTR $T226002[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226004[ebp]
	mov	DWORD PTR [eax], 0

; 250  : 	SAFE_DELETE_ARRAY(m_piYieldChangePerPop);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 884				; 00000374H
	mov	DWORD PTR $T226010[ebp], ecx
	mov	edx, DWORD PTR $T226010[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226008[ebp], eax
	mov	ecx, DWORD PTR $T226008[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226010[ebp]
	mov	DWORD PTR [edx], 0

; 251  : 	SAFE_DELETE_ARRAY(m_piYieldChangePerReligion);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 888				; 00000378H
	mov	DWORD PTR $T226016[ebp], eax
	mov	ecx, DWORD PTR $T226016[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226014[ebp], edx
	mov	eax, DWORD PTR $T226014[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226016[ebp]
	mov	DWORD PTR [ecx], 0

; 252  : 	SAFE_DELETE_ARRAY(m_piYieldModifier);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 892				; 0000037cH
	mov	DWORD PTR $T226022[ebp], edx
	mov	eax, DWORD PTR $T226022[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226020[ebp], ecx
	mov	edx, DWORD PTR $T226020[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226022[ebp]
	mov	DWORD PTR [eax], 0

; 253  : 	SAFE_DELETE_ARRAY(m_piAreaYieldModifier);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	mov	DWORD PTR $T226028[ebp], ecx
	mov	edx, DWORD PTR $T226028[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226026[ebp], eax
	mov	ecx, DWORD PTR $T226026[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226028[ebp]
	mov	DWORD PTR [edx], 0

; 254  : 	SAFE_DELETE_ARRAY(m_piGlobalYieldModifier);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 900				; 00000384H
	mov	DWORD PTR $T226034[ebp], eax
	mov	ecx, DWORD PTR $T226034[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226032[ebp], edx
	mov	eax, DWORD PTR $T226032[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226034[ebp]
	mov	DWORD PTR [ecx], 0

; 255  : 	SAFE_DELETE_ARRAY(m_piTechEnhancedYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 904				; 00000388H
	mov	DWORD PTR $T226040[ebp], edx
	mov	eax, DWORD PTR $T226040[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226038[ebp], ecx
	mov	edx, DWORD PTR $T226038[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226040[ebp]
	mov	DWORD PTR [eax], 0

; 256  : 	SAFE_DELETE_ARRAY(m_piUnitCombatFreeExperience);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 908				; 0000038cH
	mov	DWORD PTR $T226046[ebp], ecx
	mov	edx, DWORD PTR $T226046[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226044[ebp], eax
	mov	ecx, DWORD PTR $T226044[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226046[ebp]
	mov	DWORD PTR [edx], 0

; 257  : 	SAFE_DELETE_ARRAY(m_piUnitCombatProductionModifiers);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 912				; 00000390H
	mov	DWORD PTR $T226052[ebp], eax
	mov	ecx, DWORD PTR $T226052[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226050[ebp], edx
	mov	eax, DWORD PTR $T226050[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226052[ebp]
	mov	DWORD PTR [ecx], 0

; 258  : 	SAFE_DELETE_ARRAY(m_piDomainFreeExperience);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 916				; 00000394H
	mov	DWORD PTR $T226058[ebp], edx
	mov	eax, DWORD PTR $T226058[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226056[ebp], ecx
	mov	edx, DWORD PTR $T226056[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226058[ebp]
	mov	DWORD PTR [eax], 0

; 259  : 	SAFE_DELETE_ARRAY(m_piDomainFreeExperiencePerGreatWork);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	mov	DWORD PTR $T226064[ebp], ecx
	mov	edx, DWORD PTR $T226064[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226062[ebp], eax
	mov	ecx, DWORD PTR $T226062[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226064[ebp]
	mov	DWORD PTR [edx], 0

; 260  : 	SAFE_DELETE_ARRAY(m_piDomainProductionModifier);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 924				; 0000039cH
	mov	DWORD PTR $T226070[ebp], eax
	mov	ecx, DWORD PTR $T226070[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226068[ebp], edx
	mov	eax, DWORD PTR $T226068[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226070[ebp]
	mov	DWORD PTR [ecx], 0

; 261  : 	SAFE_DELETE_ARRAY(m_piPrereqNumOfBuildingClass);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 928				; 000003a0H
	mov	DWORD PTR $T226076[ebp], edx
	mov	eax, DWORD PTR $T226076[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226074[ebp], ecx
	mov	edx, DWORD PTR $T226074[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226076[ebp]
	mov	DWORD PTR [eax], 0

; 262  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 932				; 000003a4H
	mov	DWORD PTR $T226082[ebp], ecx
	mov	edx, DWORD PTR $T226082[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226080[ebp], eax
	mov	ecx, DWORD PTR $T226080[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226082[ebp]
	mov	DWORD PTR [edx], 0

; 263  : 	SAFE_DELETE_ARRAY(m_piLocalResourceAnds);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 936				; 000003a8H
	mov	DWORD PTR $T226088[ebp], eax
	mov	ecx, DWORD PTR $T226088[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226086[ebp], edx
	mov	eax, DWORD PTR $T226086[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226088[ebp]
	mov	DWORD PTR [ecx], 0

; 264  : 	SAFE_DELETE_ARRAY(m_piLocalResourceOrs);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 940				; 000003acH
	mov	DWORD PTR $T226094[ebp], edx
	mov	eax, DWORD PTR $T226094[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226092[ebp], ecx
	mov	edx, DWORD PTR $T226092[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226094[ebp]
	mov	DWORD PTR [eax], 0

; 265  : 	SAFE_DELETE_ARRAY(m_paiHurryModifier);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 944				; 000003b0H
	mov	DWORD PTR $T226100[ebp], ecx
	mov	edx, DWORD PTR $T226100[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226098[ebp], eax
	mov	ecx, DWORD PTR $T226098[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226100[ebp]
	mov	DWORD PTR [edx], 0

; 266  : 	SAFE_DELETE_ARRAY(m_pbBuildingClassNeededInCity);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 948				; 000003b4H
	mov	DWORD PTR $T226106[ebp], eax
	mov	ecx, DWORD PTR $T226106[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226104[ebp], edx
	mov	eax, DWORD PTR $T226104[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T226106[ebp]
	mov	DWORD PTR [ecx], 0

; 267  : 	SAFE_DELETE_ARRAY(m_piNumFreeUnits);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 952				; 000003b8H
	mov	DWORD PTR $T226112[ebp], edx
	mov	eax, DWORD PTR $T226112[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226110[ebp], ecx
	mov	edx, DWORD PTR $T226110[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T226112[ebp]
	mov	DWORD PTR [eax], 0

; 268  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassHappiness);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1000				; 000003e8H
	mov	DWORD PTR $T226118[ebp], ecx
	mov	edx, DWORD PTR $T226118[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226116[ebp], eax
	mov	ecx, DWORD PTR $T226116[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T226118[ebp]
	mov	DWORD PTR [edx], 0

; 269  : 	SAFE_DELETE_ARRAY(m_paThemingBonusInfo);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1004				; 000003ecH
	mov	DWORD PTR $T226142[ebp], eax
	mov	ecx, DWORD PTR $T226142[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226138[ebp], edx
	mov	eax, DWORD PTR $T226138[ebp]
	mov	DWORD PTR $T226137[ebp], eax
	cmp	DWORD PTR $T226137[ebp], 0
	je	SHORT $LN72@CvBuilding
	push	3
	mov	ecx, DWORD PTR $T226137[ebp]
	call	??_ECvThemingBonusInfo@@QAEPAXI@Z
	mov	DWORD PTR tv213[ebp], eax
	jmp	SHORT $LN73@CvBuilding
$LN72@CvBuilding:
	mov	DWORD PTR tv213[ebp], 0
$LN73@CvBuilding:
	mov	ecx, DWORD PTR $T226142[ebp]
	mov	DWORD PTR [ecx], 0

; 270  : 
; 271  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 272  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldChange.first, m_ppaiResourceYieldChange.second);
; 273  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiFeatureYieldChange.first, m_ppaiFeatureYieldChange.second);
; 274  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiSpecialistYieldChange.first, m_ppaiSpecialistYieldChange.second);
; 275  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldModifier.first, m_ppaiResourceYieldModifier.second);
; 276  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiTerrainYieldChange.first, m_ppaiTerrainYieldChange.second);
; 277  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges.first, m_ppiBuildingClassYieldChanges.second);
; 278  : #else
; 279  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 956				; 000003bcH
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 280  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiFeatureYieldChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 960				; 000003c0H
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 281  : 	m_ppiResourceYieldChangeGlobal.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	call	?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear

; 282  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiImprovementYieldChange);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 976				; 000003d0H
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 283  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiImprovementYieldChangeGlobal);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 980				; 000003d4H
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 284  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiSpecialistYieldChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 984				; 000003d8H
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 285  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiResourceYieldModifier);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 988				; 000003dcH
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 286  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppaiTerrainYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 992				; 000003e0H
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 287  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 996				; 000003e4H
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 288  : #endif
; 289  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	mov	DWORD PTR $T226529[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T226529[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 808				; 00000328H
	mov	DWORD PTR $T226534[ebp], edx
	mov	ecx, DWORD PTR $T226534[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 780				; 0000030cH
	mov	DWORD PTR $T226539[ebp], eax
	mov	ecx, DWORD PTR $T226539[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	mov	DWORD PTR $T226544[ebp], ecx
	mov	ecx, DWORD PTR $T226544[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 808				; 00000328H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	jmp	??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvBuildingEntry@@QAE@XZ$16:
	mov	ecx, DWORD PTR $T226529[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1CvBuildingEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-384]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBuildingEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBuildingEntry@@QAE@XZ ENDP				; CvBuildingEntry::~CvBuildingEntry
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::~map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
PUBLIC	??_C@_0L@PCIDMOGB@AIPriority?$AA@		; `string'
PUBLIC	??_C@_0BG@EJBGBLAF@RequiresUniquePlayers?$AA@	; `string'
PUBLIC	??_C@_0BD@GCJNKDGD@RequiresSamePlayer?$AA@	; `string'
PUBLIC	??_C@_0BE@NLIHKJCA@RequiresAnyButOwner?$AA@	; `string'
PUBLIC	??_C@_0O@EAFLGFAG@RequiresOwner?$AA@		; `string'
PUBLIC	??_C@_0BH@EFDLMKCH@MustBeEqualArtArtifact?$AA@	; `string'
PUBLIC	??_C@_0P@GNOHBNJJ@MustBeArtifact?$AA@		; `string'
PUBLIC	??_C@_09NLDBJDIG@MustBeArt?$AA@			; `string'
PUBLIC	??_C@_0L@DIMOPICO@UniqueEras?$AA@		; `string'
PUBLIC	??_C@_07OFEDJIM@SameEra?$AA@			; `string'
PUBLIC	??_C@_0M@OHKMKKDH@Description?$AA@		; `string'
PUBLIC	??_C@_05JKBOBFBJ@Bonus?$AA@			; `string'
PUBLIC	??_C@_0PB@BKIKAOJ@select?5Bonus?0?5Description?0?5SameE@ ; `string'
PUBLIC	??_C@_0BI@FNMMLPPC@Building_ThemingBonuses?$AA@	; `string'
PUBLIC	??0CvThemingBonusInfo@@QAE@XZ			; CvThemingBonusInfo::CvThemingBonusInfo
PUBLIC	??1CvThemingBonusInfo@@QAE@XZ			; CvThemingBonusInfo::~CvThemingBonusInfo
PUBLIC	??_C@_0BAD@LLOHFPOB@select?5BuildingClasses?4ID?5as?5Bui@ ; `string'
PUBLIC	??_C@_0CD@CCDFOGAD@Building_BuildingClassYieldChang@ ; `string'
PUBLIC	??_C@_0NO@HBICDKAJ@select?5Resources?4ID?5as?5ResourceI@ ; `string'
PUBLIC	??_C@_0CA@NHDIHGND@Building_ResourceYieldModifiers?$AA@ ; `string'
PUBLIC	??_C@_0OI@LJOIPFFC@select?5Specialists?4ID?5as?5Special@ ; `string'
PUBLIC	??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0M@EENMFCNN@Specialists?$AA@		; `string'
PUBLIC	??_C@_0NG@LEMPHPMP@select?5Terrains?4ID?5as?5TerrainID?0@ ; `string'
PUBLIC	??_C@_0BN@FACJPGAH@Building_TerrainYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_08DHHJBCFH@Terrains?$AA@			; `string'
PUBLIC	??_C@_0PE@OFIKBFJL@select?5Improvements?4ID?5as?5Improv@ ; `string'
PUBLIC	??_C@_0CH@MGEIPAHD@Building_ImprovementYieldChanges@ ; `string'
PUBLIC	??_C@_0OO@PKOLDNPO@select?5Improvements?4ID?5as?5Improv@ ; `string'
PUBLIC	??_C@_0CB@DLDFPMAF@Building_ImprovementYieldChanges@ ; `string'
PUBLIC	??_C@_0N@CJDAHDJO@Improvements?$AA@		; `string'
PUBLIC	??_C@_0NG@GFABIFCI@select?5Features?4ID?5as?5FeatureID?0@ ; `string'
PUBLIC	??_C@_0BN@POIIGNJJ@Building_FeatureYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_08CLANBDND@Features?$AA@			; `string'
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
PUBLIC	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
PUBLIC	??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[]
PUBLIC	??_C@_0OC@IPOJEDJL@select?5Resources?4ID?5as?5ResourceI@ ; `string'
PUBLIC	??_C@_0CE@NNCMAIMH@Building_ResourceYieldChangesGlo@ ; `string'
PUBLIC	??_C@_0NM@BGEPCKDK@select?5Resources?4ID?5as?5ResourceI@ ; `string'
PUBLIC	??_C@_0BO@DAGAEBIC@Building_ResourceYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_06JAMLCLDI@Yields?$AA@			; `string'
PUBLIC	??_C@_0BK@KEIIEDIM@Building_LocalResourceOrs?$AA@ ; `string'
PUBLIC	??_C@_0BL@FMCOIOMO@Building_LocalResourceAnds?$AA@ ; `string'
PUBLIC	??_C@_0N@INKDAICK@Technologies?$AA@		; `string'
PUBLIC	??_C@_0BI@FJIPNBFH@Building_TechAndPrereqs?$AA@	; `string'
PUBLIC	??_C@_08GHGFPPBE@TechType?$AA@			; `string'
PUBLIC	??_C@_0BP@JGKKCIIB@Building_LockedBuildingClasses?$AA@ ; `string'
PUBLIC	??_C@_0CA@CANCEICJ@Building_BuildingClassHappiness?$AA@ ; `string'
PUBLIC	??_C@_05CFLIFMAE@Units?$AA@			; `string'
PUBLIC	??_C@_0BD@HDEINNGJ@Building_FreeUnits?$AA@	; `string'
PUBLIC	??_C@_08PNBAGKKP@UnitType?$AA@			; `string'
PUBLIC	??_C@_08GKPCIDEN@NumUnits?$AA@			; `string'
PUBLIC	??_C@_0BN@KECJDNDG@Building_ClassesNeededInCity?$AA@ ; `string'
PUBLIC	??_C@_0BA@GLDILOEP@BuildingClasses?$AA@		; `string'
PUBLIC	??_C@_0BP@JDFHAFIM@Building_PrereqBuildingClasses?$AA@ ; `string'
PUBLIC	??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@	; `string'
PUBLIC	??_C@_0BC@FGLMMPNJ@NumBuildingNeeded?$AA@	; `string'
PUBLIC	??_C@_0CD@EKBOGPMO@Building_DomainProductionModifie@ ; `string'
PUBLIC	??_C@_0CK@MJOJOACL@Building_DomainFreeExperiencePer@ ; `string'
PUBLIC	??_C@_07FKLJOGGC@Domains?$AA@			; `string'
PUBLIC	??_C@_0BP@DEFLAPCG@Building_DomainFreeExperiences?$AA@ ; `string'
PUBLIC	??_C@_0L@NIGHKLOG@DomainType?$AA@		; `string'
PUBLIC	??_C@_0CH@GNAGIJKO@Building_UnitCombatProductionMod@ ; `string'
PUBLIC	??_C@_08GMKLKDKJ@Modifier?$AA@			; `string'
PUBLIC	??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@		; `string'
PUBLIC	??_C@_0CD@MKMIPBLA@Building_UnitCombatFreeExperienc@ ; `string'
PUBLIC	??_C@_0P@GFHIODK@UnitCombatType?$AA@		; `string'
PUBLIC	??_C@_0L@PGMCIMFM@HurryInfos?$AA@		; `string'
PUBLIC	??_C@_0BI@PCDONCNC@Building_HurryModifiers?$AA@	; `string'
PUBLIC	??_C@_09FFMCMAO@HurryType?$AA@			; `string'
PUBLIC	??_C@_0BO@HNEMOEFM@Building_ResourceFaithChanges?$AA@ ; `string'
PUBLIC	??_C@_0M@PCGABKEM@FaithChange?$AA@		; `string'
PUBLIC	??_C@_0CA@BPLMBBCM@Building_ResourceCultureChanges?$AA@ ; `string'
PUBLIC	??_C@_0O@DKCHOOHE@CultureChange?$AA@		; `string'
PUBLIC	??_C@_0BK@EKPBEKIH@Building_ResourceQuantity?$AA@ ; `string'
PUBLIC	??_C@_08GACJPEFO@Quantity?$AA@			; `string'
PUBLIC	??_C@_09FDCBPLKG@Resources?$AA@			; `string'
PUBLIC	??_C@_0CG@MMPBLPJH@Building_ResourceQuantityRequire@ ; `string'
PUBLIC	??_C@_0N@EPHJOCBJ@ResourceType?$AA@		; `string'
PUBLIC	??_C@_0CC@GLEKPBJF@Building_TechEnhancedYieldChange@ ; `string'
PUBLIC	??_C@_0BO@ICDPBNEO@Building_GlobalYieldModifiers?$AA@ ; `string'
PUBLIC	??_C@_0BM@IJNPCKEJ@Building_AreaYieldModifiers?$AA@ ; `string'
PUBLIC	??_C@_0BI@KNPCMJI@Building_YieldModifiers?$AA@	; `string'
PUBLIC	??_C@_0CB@OKBCIELK@Building_YieldChangesPerReligion@ ; `string'
PUBLIC	??_C@_0BM@LCICFHBJ@Building_YieldChangesPerPop?$AA@ ; `string'
PUBLIC	??_C@_0BG@MDKFBHAG@Building_YieldChanges?$AA@	; `string'
PUBLIC	??_C@_0CB@PAPAGMOD@Building_SeaResourceYieldChanges@ ; `string'
PUBLIC	??_C@_0BO@EMCADFDK@Building_LakePlotYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0BP@BNNDBJKD@Building_RiverPlotYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0BN@BAOCADIP@Building_SeaPlotYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0BB@EJAOEGAC@Building_Flavors?$AA@	; `string'
PUBLIC	??_C@_0N@OGHNDFPH@BuildingType?$AA@		; `string'
PUBLIC	??_C@_0O@GDKFHJNN@FreeGreatWork?$AA@		; `string'
PUBLIC	??_C@_0P@OEIEFIFC@GreatWorkCount?$AA@		; `string'
PUBLIC	??_C@_0BC@CPKOPKBA@GreatWorkSlotType?$AA@	; `string'
PUBLIC	??_C@_0BG@PEIPJGC@GreatPeopleRateChange?$AA@	; `string'
PUBLIC	??_C@_0BH@CNHDGJOG@SpecialistExtraCulture?$AA@	; `string'
PUBLIC	??_C@_0BA@KNNJHJEH@SpecialistCount?$AA@		; `string'
PUBLIC	??_C@_0P@KLBEOMLO@SpecialistType?$AA@		; `string'
PUBLIC	??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@	; `string'
PUBLIC	??_C@_0L@NJNFNDFO@PrereqTech?$AA@		; `string'
PUBLIC	??_C@_0BJ@JEAPEJLP@ReplacementBuildingClass?$AA@ ; `string'
PUBLIC	??_C@_0BF@CBBLNJGG@FreePromotionRemoved?$AA@	; `string'
PUBLIC	??_C@_0BF@HBFHHGMI@TrainedFreePromotion?$AA@	; `string'
PUBLIC	??_C@_0O@FDCFKJMG@FreePromotion?$AA@		; `string'
PUBLIC	??_C@_0BF@FAEFDHBK@FreeBuildingThisCity?$AA@	; `string'
PUBLIC	??_C@_0N@EHKBNAC@FreeBuilding?$AA@		; `string'
PUBLIC	??_C@_0BE@LLHNLPLG@TechEnhancedTourism?$AA@	; `string'
PUBLIC	??_C@_0BC@DFCBDFGG@EnhancedYieldTech?$AA@	; `string'
PUBLIC	??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@		; `string'
PUBLIC	??_C@_0M@NNMHACIA@MaxStartEra?$AA@		; `string'
PUBLIC	??_C@_0N@LADKBMLE@FreeStartEra?$AA@		; `string'
PUBLIC	??_C@_0O@KJJJODBC@VictoryPrereq?$AA@		; `string'
PUBLIC	??_C@_0BG@OCNBBLOA@ProhibitedCityTerrain?$AA@	; `string'
PUBLIC	??_C@_0BG@DNNKFMIB@NearbyTerrainRequired?$AA@	; `string'
PUBLIC	??_C@_0BB@NLLCNLEE@ThemingBonusHelp?$AA@	; `string'
PUBLIC	??_C@_0BC@BAEHGPFA@WonderSplashAudio?$AA@	; `string'
PUBLIC	?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z	; CvBuildingEntry::SetArtDefineTag
PUBLIC	??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@		; `string'
PUBLIC	??_C@_0O@GBPAPFFG@BuildingClass?$AA@		; `string'
PUBLIC	??_C@_0BH@EABPJAPH@ArtInfoRandomVariation?$AA@	; `string'
PUBLIC	??_C@_0BE@DGFAELDF@ArtInfoEraVariation?$AA@	; `string'
PUBLIC	??_C@_0BJ@JGFNFBNF@ArtInfoCulturalVariation?$AA@ ; `string'
PUBLIC	??_C@_0O@NLIKPLNH@PortraitIndex?$AA@		; `string'
PUBLIC	??_C@_0BA@DMIICDJF@DisplayPosition?$AA@		; `string'
PUBLIC	??_C@_0BB@CHNMMAEN@ExtraLeagueVotes?$AA@	; `string'
PUBLIC	??_C@_0BN@JGEIPAGC@GreatScientistBeakerModifier?$AA@ ; `string'
PUBLIC	??_C@_0BN@NNLIKACH@XBuiltTriggersIdeologyChoice?$AA@ ; `string'
PUBLIC	??_C@_0BK@NHOICAO@GreatWorksTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@GABFOINA@InstantMilitaryIncrease?$AA@	; `string'
PUBLIC	??_C@_0BI@EHLPJCJM@LandmarksTourismPercent?$AA@	; `string'
PUBLIC	??_C@_0BF@FKGBMAOG@InstantSpyRankChange?$AA@	; `string'
PUBLIC	??_C@_0CA@LIDBPAKF@CityStateTradeRouteGoldModifier?$AA@ ; `string'
PUBLIC	??_C@_0CG@NMEAPNPJ@CityStateTradeRouteProductionMod@ ; `string'
PUBLIC	??_C@_0BI@DMDIJHPD@TradeRouteLandGoldBonus?$AA@	; `string'
PUBLIC	??_C@_0BP@MNFCPAGM@TradeRouteLandDistanceModifier?$AA@ ; `string'
PUBLIC	??_C@_0BH@MHOEOOPE@TradeRouteSeaGoldBonus?$AA@	; `string'
PUBLIC	??_C@_0BO@DJLKJBBF@TradeRouteSeaDistanceModifier?$AA@ ; `string'
PUBLIC	??_C@_0BD@PCCNONCD@NumTradeRouteBonus?$AA@	; `string'
PUBLIC	??_C@_0BG@KDKDANDF@TradeRouteTargetBonus?$AA@	; `string'
PUBLIC	??_C@_0BJ@LGPMFPOC@TradeRouteRecipientBonus?$AA@ ; `string'
PUBLIC	??_C@_0O@MKBDDMLG@SpyRankChange?$AA@		; `string'
PUBLIC	??_C@_0L@MHOKHMFG@ExtraSpies?$AA@		; `string'
PUBLIC	??_C@_0BI@LABECCNE@GlobalEspionageModifier?$AA@	; `string'
PUBLIC	??_C@_0BC@LMEAJMHG@EspionageModifier?$AA@	; `string'
PUBLIC	??_C@_0BK@ODFECGBH@ReligiousPressureModifier?$AA@ ; `string'
PUBLIC	??_C@_0BH@GFFBMGNA@ExtraMissionarySpreads?$AA@	; `string'
PUBLIC	??_C@_0O@OGDMFMLE@VictoryPoints?$AA@		; `string'
PUBLIC	??_C@_0BG@GHFKMIAN@MinorFriendshipChange?$AA@	; `string'
PUBLIC	??_C@_0BD@LNJPJMKG@ExtraCityHitPoints?$AA@	; `string'
PUBLIC	??_C@_0BB@JKDLEHAG@GlobalDefenseMod?$AA@	; `string'
PUBLIC	??_C@_0BC@NIACICCM@DefensePerCitizen?$AA@	; `string'
PUBLIC	??_C@_07PEDPFCGC@Defense?$AA@			; `string'
PUBLIC	??_C@_0BC@BOAIOPHA@AllowsRangeStrike?$AA@	; `string'
PUBLIC	??_C@_0BH@NDBHABCH@NearbyMountainRequired?$AA@	; `string'
PUBLIC	??_C@_04PABHPHAJ@Gold?$AA@			; `string'
PUBLIC	??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@	; `string'
PUBLIC	??_C@_0BA@DPFMCCIM@FreeGreatPeople?$AA@		; `string'
PUBLIC	??_C@_0BF@ONPKDJAH@MountainScienceYield?$AA@	; `string'
PUBLIC	??_C@_0O@DENBKNLO@FreeFlatFaith?$AA@		; `string'
PUBLIC	??_C@_0N@PJBJAAKG@FreePolicies?$AA@		; `string'
PUBLIC	??_C@_09LNIJJMDM@FreeTechs?$AA@			; `string'
PUBLIC	??_C@_09LDHOCFOF@TechShare?$AA@			; `string'
PUBLIC	??_C@_0BG@LMGKPHCK@LocalPopulationChange?$AA@	; `string'
PUBLIC	??_C@_0BH@PIGIEKJF@GlobalPopulationChange?$AA@	; `string'
PUBLIC	??_C@_0BK@HHDDIAGF@GlobalPlotBuyCostModifier?$AA@ ; `string'
PUBLIC	??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BO@JENENNEF@GlobalPlotCultureCostModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BH@NHKFNDOG@CapturePlunderModifier?$AA@	; `string'
PUBLIC	??_C@_0CB@KIEKHDEM@CityConnectionTradeRouteModifier@ ; `string'
PUBLIC	??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BO@BNLDOPDP@GlobalSpaceProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@KLOFIIDO@SpaceProductionModifier?$AA@	; `string'
PUBLIC	??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@	; `string'
PUBLIC	??_C@_0BG@HACMNBGA@NoOccupiedUnhappiness?$AA@	; `string'
PUBLIC	??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@	; `string'
PUBLIC	??_C@_0BG@PPCKEPPB@HappinessPerXPolicies?$AA@	; `string'
PUBLIC	??_C@_0BB@HFLAGBOL@HappinessPerCity?$AA@	; `string'
PUBLIC	??_C@_0BE@EFAAFPFO@UnhappinessModifier?$AA@	; `string'
PUBLIC	??_C@_0BC@CGGCCKPG@UnmoddedHappiness?$AA@	; `string'
PUBLIC	??_C@_09MNJMGIDC@Happiness?$AA@			; `string'
PUBLIC	??_C@_0P@ELFDMBAA@HealRateChange?$AA@		; `string'
PUBLIC	??_C@_0BC@JODJDJH@NukeExplosionRand?$AA@	; `string'
PUBLIC	??_C@_0N@DKGPEEDC@NukeModifier?$AA@		; `string'
PUBLIC	??_C@_0M@IDJEHHOP@AirModifier?$AA@		; `string'
PUBLIC	??_C@_07DKMLGOLM@Airlift?$AA@			; `string'
PUBLIC	??_C@_08GPFHOIEA@FoodKept?$AA@			; `string'
PUBLIC	??_C@_0BB@PGIKLGNH@GlobalExperience?$AA@	; `string'
PUBLIC	??_C@_0L@DCGNFONO@Experience?$AA@		; `string'
PUBLIC	??_C@_0BC@EMNAJIOA@GoldenAgeModifier?$AA@	; `string'
PUBLIC	??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@	; `string'
PUBLIC	??_C@_0BG@DMFMCIBK@GreatPersonExpendGold?$AA@	; `string'
PUBLIC	??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BO@IMGFGCPH@GlobalGreatPeopleRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@	; `string'
PUBLIC	??_C@_0BK@KFILFBOG@GlobalCultureRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BE@BFGDBNFC@CultureRateModifier?$AA@	; `string'
PUBLIC	??_C@_0M@HHMEOJHA@LevelPrereq?$AA@		; `string'
PUBLIC	??_C@_0N@JPPGNKPJ@CitiesPrereq?$AA@		; `string'
PUBLIC	??_C@_0N@DDEKGLDJ@ConquestProb?$AA@		; `string'
PUBLIC	??_C@_0M@ILJKFCBC@MinAreaSize?$AA@		; `string'
PUBLIC	??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@	; `string'
PUBLIC	??_C@_0P@JHBNAHPF@NumCityCostMod?$AA@		; `string'
PUBLIC	??_C@_0BJ@PLFPOGBO@NullifyInfluenceModifier?$AA@ ; `string'
PUBLIC	??_C@_0BM@BLJJFLJE@AllowsProductionTradeRoutes?$AA@ ; `string'
PUBLIC	??_C@_0BG@IGJKJBLH@AllowsFoodTradeRoutes?$AA@	; `string'
PUBLIC	??_C@_0N@FOBHMOJA@MaliTreasury?$AA@		; `string'
PUBLIC	??_C@_09BGJOJKFJ@Espionage?$AA@			; `string'
PUBLIC	??_C@_0P@EAJEPOJD@AffectSpiesNow?$AA@		; `string'
PUBLIC	??_C@_08OBDEBKOC@HolyCity?$AA@			; `string'
PUBLIC	??_C@_0BB@IPGENGJF@UnlockedByLeague?$AA@	; `string'
PUBLIC	??_C@_0BB@PABPOOPJ@UnlockedByBelief?$AA@	; `string'
PUBLIC	??_C@_0L@GJEJPIBI@LeagueCost?$AA@		; `string'
PUBLIC	??_C@_09JGBPBICB@FaithCost?$AA@			; `string'
PUBLIC	??_C@_04FICPKHNF@Cost?$AA@			; `string'
PUBLIC	??_C@_0BC@CHJMKLJG@AllowsWaterRoutes?$AA@	; `string'
PUBLIC	??_C@_0BB@JIBMBBHG@DiplomaticVoting?$AA@	; `string'
PUBLIC	??_C@_0O@GDMCMLLL@ExtraLuxuries?$AA@		; `string'
PUBLIC	??_C@_08IEGLFCGA@CityWall?$AA@			; `string'
PUBLIC	??_C@_0L@EEGCDFDE@NukeImmune?$AA@		; `string'
PUBLIC	??_C@_0N@GGKADJEK@NeverCapture?$AA@		; `string'
PUBLIC	??_C@_0N@MDAIKEA@MapCentering?$AA@		; `string'
PUBLIC	??_C@_0CH@GBMHJELN@GrantsFreeCulturalGreatPersonWit@ ; `string'
PUBLIC	??_C@_09BDPFDCPN@GoldenAge?$AA@			; `string'
PUBLIC	??_C@_07OLAOAIED@Capital?$AA@			; `string'
PUBLIC	??_C@_0BF@DPODFGDF@PlayerBorderObstacle?$AA@	; `string'
PUBLIC	??_C@_0P@LIILLJIL@BorderObstacle?$AA@		; `string'
PUBLIC	??_C@_0M@MIOBODFK@IsReligious?$AA@		; `string'
PUBLIC	??_C@_0P@PDCEKFCE@FoundsReligion?$AA@		; `string'
PUBLIC	??_C@_04JNNIPAFF@Flat?$AA@			; `string'
PUBLIC	??_C@_04JPPFLFAM@Hill?$AA@			; `string'
PUBLIC	??_C@_08IAPOEMFP@Mountain?$AA@			; `string'
PUBLIC	??_C@_0L@NGNKNLMG@FreshWater?$AA@		; `string'
PUBLIC	??_C@_05IGBIAPGD@River?$AA@			; `string'
PUBLIC	??_C@_05EMKMBNJK@Water?$AA@			; `string'
PUBLIC	??_C@_09KDGDANDP@TeamShare?$AA@			; `string'
PUBLIC	??_C@_0BH@CODCFEOP@MutuallyExclusiveGroup?$AA@	; `string'
PUBLIC	??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT ??_C@_0L@PCIDMOGB@AIPriority?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0L@PCIDMOGB@AIPriority?$AA@ DB 'AIPriority', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EJBGBLAF@RequiresUniquePlayers?$AA@
CONST	SEGMENT
??_C@_0BG@EJBGBLAF@RequiresUniquePlayers?$AA@ DB 'RequiresUniquePlayers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GCJNKDGD@RequiresSamePlayer?$AA@
CONST	SEGMENT
??_C@_0BD@GCJNKDGD@RequiresSamePlayer?$AA@ DB 'RequiresSamePlayer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLIHKJCA@RequiresAnyButOwner?$AA@
CONST	SEGMENT
??_C@_0BE@NLIHKJCA@RequiresAnyButOwner?$AA@ DB 'RequiresAnyButOwner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EAFLGFAG@RequiresOwner?$AA@
CONST	SEGMENT
??_C@_0O@EAFLGFAG@RequiresOwner?$AA@ DB 'RequiresOwner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EFDLMKCH@MustBeEqualArtArtifact?$AA@
CONST	SEGMENT
??_C@_0BH@EFDLMKCH@MustBeEqualArtArtifact?$AA@ DB 'MustBeEqualArtArtifact'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GNOHBNJJ@MustBeArtifact?$AA@
CONST	SEGMENT
??_C@_0P@GNOHBNJJ@MustBeArtifact?$AA@ DB 'MustBeArtifact', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLDBJDIG@MustBeArt?$AA@
CONST	SEGMENT
??_C@_09NLDBJDIG@MustBeArt?$AA@ DB 'MustBeArt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DIMOPICO@UniqueEras?$AA@
CONST	SEGMENT
??_C@_0L@DIMOPICO@UniqueEras?$AA@ DB 'UniqueEras', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OFEDJIM@SameEra?$AA@
CONST	SEGMENT
??_C@_07OFEDJIM@SameEra?$AA@ DB 'SameEra', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OHKMKKDH@Description?$AA@
CONST	SEGMENT
??_C@_0M@OHKMKKDH@Description?$AA@ DB 'Description', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKBOBFBJ@Bonus?$AA@
CONST	SEGMENT
??_C@_05JKBOBFBJ@Bonus?$AA@ DB 'Bonus', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0PB@BKIKAOJ@select?5Bonus?0?5Description?0?5SameE@
CONST	SEGMENT
??_C@_0PB@BKIKAOJ@select?5Bonus?0?5Description?0?5SameE@ DB 'select Bonus'
	DB	', Description, SameEra, UniqueEras, MustBeArt, MustBeArtifact'
	DB	', MustBeEqualArtArtifact, RequiresOwner, RequiresAnyButOwner,'
	DB	' RequiresSamePlayer, RequiresUniquePlayers, AIPriority from B'
	DB	'uilding_ThemingBonuses where BuildingType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FNMMLPPC@Building_ThemingBonuses?$AA@
CONST	SEGMENT
??_C@_0BI@FNMMLPPC@Building_ThemingBonuses?$AA@ DB 'Building_ThemingBonus'
	DB	'es', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAD@LLOHFPOB@select?5BuildingClasses?4ID?5as?5Bui@
CONST	SEGMENT
??_C@_0BAD@LLOHFPOB@select?5BuildingClasses?4ID?5as?5Bui@ DB 'select Buil'
	DB	'dingClasses.ID as BuildingClassID, Yields.ID as YieldID, Yiel'
	DB	'dChange from Building_BuildingClassYieldChanges inner join Bu'
	DB	'ildingClasses on BuildingClasses.Type = BuildingClassType inn'
	DB	'er join Yields on Yields.Type = YieldType where BuildingType '
	DB	'= ?', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CCDFOGAD@Building_BuildingClassYieldChang@
CONST	SEGMENT
??_C@_0CD@CCDFOGAD@Building_BuildingClassYieldChang@ DB 'Building_Buildin'
	DB	'gClassYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0NO@HBICDKAJ@select?5Resources?4ID?5as?5ResourceI@
CONST	SEGMENT
??_C@_0NO@HBICDKAJ@select?5Resources?4ID?5as?5ResourceI@ DB 'select Resou'
	DB	'rces.ID as ResourceID, Yields.ID as YieldID, Yield from Build'
	DB	'ing_ResourceYieldModifiers inner join Resources on Resources.'
	DB	'Type = ResourceType inner join Yields on Yields.Type = YieldT'
	DB	'ype where BuildingType = ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NHDIHGND@Building_ResourceYieldModifiers?$AA@
CONST	SEGMENT
??_C@_0CA@NHDIHGND@Building_ResourceYieldModifiers?$AA@ DB 'Building_Reso'
	DB	'urceYieldModifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0OI@LJOIPFFC@select?5Specialists?4ID?5as?5Special@
CONST	SEGMENT
??_C@_0OI@LJOIPFFC@select?5Specialists?4ID?5as?5Special@ DB 'select Speci'
	DB	'alists.ID as SpecialistID, Yields.ID as YieldID, Yield from B'
	DB	'uilding_SpecialistYieldChanges inner join Specialists on Spec'
	DB	'ialists.Type = SpecialistType inner join Yields on Yields.Typ'
	DB	'e = YieldType where BuildingType = ?', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@
CONST	SEGMENT
??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@ DB 'Building_Speci'
	DB	'alistYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENMFCNN@Specialists?$AA@
CONST	SEGMENT
??_C@_0M@EENMFCNN@Specialists?$AA@ DB 'Specialists', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NG@LEMPHPMP@select?5Terrains?4ID?5as?5TerrainID?0@
CONST	SEGMENT
??_C@_0NG@LEMPHPMP@select?5Terrains?4ID?5as?5TerrainID?0@ DB 'select Terr'
	DB	'ains.ID as TerrainID, Yields.ID as YieldID, Yield from Buildi'
	DB	'ng_TerrainYieldChanges inner join Terrains on Terrains.Type ='
	DB	' TerrainType inner join Yields on Yields.Type = YieldType whe'
	DB	're BuildingType = ?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FACJPGAH@Building_TerrainYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BN@FACJPGAH@Building_TerrainYieldChanges?$AA@ DB 'Building_Terrain'
	DB	'YieldChanges', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHHJBCFH@Terrains?$AA@
CONST	SEGMENT
??_C@_08DHHJBCFH@Terrains?$AA@ DB 'Terrains', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0PE@OFIKBFJL@select?5Improvements?4ID?5as?5Improv@
CONST	SEGMENT
??_C@_0PE@OFIKBFJL@select?5Improvements?4ID?5as?5Improv@ DB 'select Impro'
	DB	'vements.ID as ImprovementID, Yields.ID as YieldID, Yield from'
	DB	' Building_ImprovementYieldChangesGlobal inner join Improvemen'
	DB	'ts on Improvements.Type = ImprovementType inner join Yields o'
	DB	'n Yields.Type = YieldType where BuildingType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MGEIPAHD@Building_ImprovementYieldChanges@
CONST	SEGMENT
??_C@_0CH@MGEIPAHD@Building_ImprovementYieldChanges@ DB 'Building_Improve'
	DB	'mentYieldChangesGlobal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0OO@PKOLDNPO@select?5Improvements?4ID?5as?5Improv@
CONST	SEGMENT
??_C@_0OO@PKOLDNPO@select?5Improvements?4ID?5as?5Improv@ DB 'select Impro'
	DB	'vements.ID as ImprovementID, Yields.ID as YieldID, Yield from'
	DB	' Building_ImprovementYieldChanges inner join Improvements on '
	DB	'Improvements.Type = ImprovementType inner join Yields on Yiel'
	DB	'ds.Type = YieldType where BuildingType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DLDFPMAF@Building_ImprovementYieldChanges@
CONST	SEGMENT
??_C@_0CB@DLDFPMAF@Building_ImprovementYieldChanges@ DB 'Building_Improve'
	DB	'mentYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CJDAHDJO@Improvements?$AA@
CONST	SEGMENT
??_C@_0N@CJDAHDJO@Improvements?$AA@ DB 'Improvements', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NG@GFABIFCI@select?5Features?4ID?5as?5FeatureID?0@
CONST	SEGMENT
??_C@_0NG@GFABIFCI@select?5Features?4ID?5as?5FeatureID?0@ DB 'select Feat'
	DB	'ures.ID as FeatureID, Yields.ID as YieldID, Yield from Buildi'
	DB	'ng_FeatureYieldChanges inner join Features on Features.Type ='
	DB	' FeatureType inner join Yields on Yields.Type = YieldType whe'
	DB	're BuildingType = ?', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@POIIGNJJ@Building_FeatureYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BN@POIIGNJJ@Building_FeatureYieldChanges?$AA@ DB 'Building_Feature'
	DB	'YieldChanges', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLANBDND@Features?$AA@
CONST	SEGMENT
??_C@_08CLANBDND@Features?$AA@ DB 'Features', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0OC@IPOJEDJL@select?5Resources?4ID?5as?5ResourceI@
CONST	SEGMENT
??_C@_0OC@IPOJEDJL@select?5Resources?4ID?5as?5ResourceI@ DB 'select Resou'
	DB	'rces.ID as ResourceID, Yields.ID as YieldID, Yield from Build'
	DB	'ing_ResourceYieldChangesGlobal inner join Resources on Resour'
	DB	'ces.Type = ResourceType inner join Yields on Yields.Type = Yi'
	DB	'eldType where BuildingType = ?', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NNCMAIMH@Building_ResourceYieldChangesGlo@
CONST	SEGMENT
??_C@_0CE@NNCMAIMH@Building_ResourceYieldChangesGlo@ DB 'Building_Resourc'
	DB	'eYieldChangesGlobal', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0NM@BGEPCKDK@select?5Resources?4ID?5as?5ResourceI@
CONST	SEGMENT
??_C@_0NM@BGEPCKDK@select?5Resources?4ID?5as?5ResourceI@ DB 'select Resou'
	DB	'rces.ID as ResourceID, Yields.ID as YieldID, Yield from Build'
	DB	'ing_ResourceYieldChanges inner join Resources on Resources.Ty'
	DB	'pe = ResourceType inner join Yields on Yields.Type = YieldTyp'
	DB	'e where BuildingType = ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DAGAEBIC@Building_ResourceYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BO@DAGAEBIC@Building_ResourceYieldChanges?$AA@ DB 'Building_Resour'
	DB	'ceYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06JAMLCLDI@Yields?$AA@
CONST	SEGMENT
??_C@_06JAMLCLDI@Yields?$AA@ DB 'Yields', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KEIIEDIM@Building_LocalResourceOrs?$AA@
CONST	SEGMENT
??_C@_0BK@KEIIEDIM@Building_LocalResourceOrs?$AA@ DB 'Building_LocalResou'
	DB	'rceOrs', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FMCOIOMO@Building_LocalResourceAnds?$AA@
CONST	SEGMENT
??_C@_0BL@FMCOIOMO@Building_LocalResourceAnds?$AA@ DB 'Building_LocalReso'
	DB	'urceAnds', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INKDAICK@Technologies?$AA@
CONST	SEGMENT
??_C@_0N@INKDAICK@Technologies?$AA@ DB 'Technologies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FJIPNBFH@Building_TechAndPrereqs?$AA@
CONST	SEGMENT
??_C@_0BI@FJIPNBFH@Building_TechAndPrereqs?$AA@ DB 'Building_TechAndPrere'
	DB	'qs', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08GHGFPPBE@TechType?$AA@
CONST	SEGMENT
??_C@_08GHGFPPBE@TechType?$AA@ DB 'TechType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JGKKCIIB@Building_LockedBuildingClasses?$AA@
CONST	SEGMENT
??_C@_0BP@JGKKCIIB@Building_LockedBuildingClasses?$AA@ DB 'Building_Locke'
	DB	'dBuildingClasses', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CANCEICJ@Building_BuildingClassHappiness?$AA@
CONST	SEGMENT
??_C@_0CA@CANCEICJ@Building_BuildingClassHappiness?$AA@ DB 'Building_Buil'
	DB	'dingClassHappiness', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFLIFMAE@Units?$AA@
CONST	SEGMENT
??_C@_05CFLIFMAE@Units?$AA@ DB 'Units', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HDEINNGJ@Building_FreeUnits?$AA@
CONST	SEGMENT
??_C@_0BD@HDEINNGJ@Building_FreeUnits?$AA@ DB 'Building_FreeUnits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PNBAGKKP@UnitType?$AA@
CONST	SEGMENT
??_C@_08PNBAGKKP@UnitType?$AA@ DB 'UnitType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKPCIDEN@NumUnits?$AA@
CONST	SEGMENT
??_C@_08GKPCIDEN@NumUnits?$AA@ DB 'NumUnits', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KECJDNDG@Building_ClassesNeededInCity?$AA@
CONST	SEGMENT
??_C@_0BN@KECJDNDG@Building_ClassesNeededInCity?$AA@ DB 'Building_Classes'
	DB	'NeededInCity', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
CONST	SEGMENT
??_C@_0BA@GLDILOEP@BuildingClasses?$AA@ DB 'BuildingClasses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JDFHAFIM@Building_PrereqBuildingClasses?$AA@
CONST	SEGMENT
??_C@_0BP@JDFHAFIM@Building_PrereqBuildingClasses?$AA@ DB 'Building_Prere'
	DB	'qBuildingClasses', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
CONST	SEGMENT
??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@ DB 'BuildingClassType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FGLMMPNJ@NumBuildingNeeded?$AA@
CONST	SEGMENT
??_C@_0BC@FGLMMPNJ@NumBuildingNeeded?$AA@ DB 'NumBuildingNeeded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EKBOGPMO@Building_DomainProductionModifie@
CONST	SEGMENT
??_C@_0CD@EKBOGPMO@Building_DomainProductionModifie@ DB 'Building_DomainP'
	DB	'roductionModifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MJOJOACL@Building_DomainFreeExperiencePer@
CONST	SEGMENT
??_C@_0CK@MJOJOACL@Building_DomainFreeExperiencePer@ DB 'Building_DomainF'
	DB	'reeExperiencePerGreatWork', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKLJOGGC@Domains?$AA@
CONST	SEGMENT
??_C@_07FKLJOGGC@Domains?$AA@ DB 'Domains', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DEFLAPCG@Building_DomainFreeExperiences?$AA@
CONST	SEGMENT
??_C@_0BP@DEFLAPCG@Building_DomainFreeExperiences?$AA@ DB 'Building_Domai'
	DB	'nFreeExperiences', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NIGHKLOG@DomainType?$AA@
CONST	SEGMENT
??_C@_0L@NIGHKLOG@DomainType?$AA@ DB 'DomainType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GNAGIJKO@Building_UnitCombatProductionMod@
CONST	SEGMENT
??_C@_0CH@GNAGIJKO@Building_UnitCombatProductionMod@ DB 'Building_UnitCom'
	DB	'batProductionModifiers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GMKLKDKJ@Modifier?$AA@
CONST	SEGMENT
??_C@_08GMKLKDKJ@Modifier?$AA@ DB 'Modifier', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
CONST	SEGMENT
??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@ DB 'UnitCombatInfos', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MKMIPBLA@Building_UnitCombatFreeExperienc@
CONST	SEGMENT
??_C@_0CD@MKMIPBLA@Building_UnitCombatFreeExperienc@ DB 'Building_UnitCom'
	DB	'batFreeExperiences', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GFHIODK@UnitCombatType?$AA@
CONST	SEGMENT
??_C@_0P@GFHIODK@UnitCombatType?$AA@ DB 'UnitCombatType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGMCIMFM@HurryInfos?$AA@
CONST	SEGMENT
??_C@_0L@PGMCIMFM@HurryInfos?$AA@ DB 'HurryInfos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PCDONCNC@Building_HurryModifiers?$AA@
CONST	SEGMENT
??_C@_0BI@PCDONCNC@Building_HurryModifiers?$AA@ DB 'Building_HurryModifie'
	DB	'rs', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09FFMCMAO@HurryType?$AA@
CONST	SEGMENT
??_C@_09FFMCMAO@HurryType?$AA@ DB 'HurryType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HNEMOEFM@Building_ResourceFaithChanges?$AA@
CONST	SEGMENT
??_C@_0BO@HNEMOEFM@Building_ResourceFaithChanges?$AA@ DB 'Building_Resour'
	DB	'ceFaithChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCGABKEM@FaithChange?$AA@
CONST	SEGMENT
??_C@_0M@PCGABKEM@FaithChange?$AA@ DB 'FaithChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BPLMBBCM@Building_ResourceCultureChanges?$AA@
CONST	SEGMENT
??_C@_0CA@BPLMBBCM@Building_ResourceCultureChanges?$AA@ DB 'Building_Reso'
	DB	'urceCultureChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DKCHOOHE@CultureChange?$AA@
CONST	SEGMENT
??_C@_0O@DKCHOOHE@CultureChange?$AA@ DB 'CultureChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EKPBEKIH@Building_ResourceQuantity?$AA@
CONST	SEGMENT
??_C@_0BK@EKPBEKIH@Building_ResourceQuantity?$AA@ DB 'Building_ResourceQu'
	DB	'antity', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08GACJPEFO@Quantity?$AA@
CONST	SEGMENT
??_C@_08GACJPEFO@Quantity?$AA@ DB 'Quantity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FDCBPLKG@Resources?$AA@
CONST	SEGMENT
??_C@_09FDCBPLKG@Resources?$AA@ DB 'Resources', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@MMPBLPJH@Building_ResourceQuantityRequire@
CONST	SEGMENT
??_C@_0CG@MMPBLPJH@Building_ResourceQuantityRequire@ DB 'Building_Resourc'
	DB	'eQuantityRequirements', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
CONST	SEGMENT
??_C@_0N@EPHJOCBJ@ResourceType?$AA@ DB 'ResourceType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GLEKPBJF@Building_TechEnhancedYieldChange@
CONST	SEGMENT
??_C@_0CC@GLEKPBJF@Building_TechEnhancedYieldChange@ DB 'Building_TechEnh'
	DB	'ancedYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ICDPBNEO@Building_GlobalYieldModifiers?$AA@
CONST	SEGMENT
??_C@_0BO@ICDPBNEO@Building_GlobalYieldModifiers?$AA@ DB 'Building_Global'
	DB	'YieldModifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IJNPCKEJ@Building_AreaYieldModifiers?$AA@
CONST	SEGMENT
??_C@_0BM@IJNPCKEJ@Building_AreaYieldModifiers?$AA@ DB 'Building_AreaYiel'
	DB	'dModifiers', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KNPCMJI@Building_YieldModifiers?$AA@
CONST	SEGMENT
??_C@_0BI@KNPCMJI@Building_YieldModifiers?$AA@ DB 'Building_YieldModifier'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OKBCIELK@Building_YieldChangesPerReligion@
CONST	SEGMENT
??_C@_0CB@OKBCIELK@Building_YieldChangesPerReligion@ DB 'Building_YieldCh'
	DB	'angesPerReligion', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LCICFHBJ@Building_YieldChangesPerPop?$AA@
CONST	SEGMENT
??_C@_0BM@LCICFHBJ@Building_YieldChangesPerPop?$AA@ DB 'Building_YieldCha'
	DB	'ngesPerPop', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MDKFBHAG@Building_YieldChanges?$AA@
CONST	SEGMENT
??_C@_0BG@MDKFBHAG@Building_YieldChanges?$AA@ DB 'Building_YieldChanges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PAPAGMOD@Building_SeaResourceYieldChanges@
CONST	SEGMENT
??_C@_0CB@PAPAGMOD@Building_SeaResourceYieldChanges@ DB 'Building_SeaReso'
	DB	'urceYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EMCADFDK@Building_LakePlotYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BO@EMCADFDK@Building_LakePlotYieldChanges?$AA@ DB 'Building_LakePl'
	DB	'otYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BNNDBJKD@Building_RiverPlotYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BP@BNNDBJKD@Building_RiverPlotYieldChanges?$AA@ DB 'Building_River'
	DB	'PlotYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BAOCADIP@Building_SeaPlotYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BN@BAOCADIP@Building_SeaPlotYieldChanges?$AA@ DB 'Building_SeaPlot'
	DB	'YieldChanges', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EJAOEGAC@Building_Flavors?$AA@
CONST	SEGMENT
??_C@_0BB@EJAOEGAC@Building_Flavors?$AA@ DB 'Building_Flavors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OGHNDFPH@BuildingType?$AA@
CONST	SEGMENT
??_C@_0N@OGHNDFPH@BuildingType?$AA@ DB 'BuildingType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GDKFHJNN@FreeGreatWork?$AA@
CONST	SEGMENT
??_C@_0O@GDKFHJNN@FreeGreatWork?$AA@ DB 'FreeGreatWork', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OEIEFIFC@GreatWorkCount?$AA@
CONST	SEGMENT
??_C@_0P@OEIEFIFC@GreatWorkCount?$AA@ DB 'GreatWorkCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CPKOPKBA@GreatWorkSlotType?$AA@
CONST	SEGMENT
??_C@_0BC@CPKOPKBA@GreatWorkSlotType?$AA@ DB 'GreatWorkSlotType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PEIPJGC@GreatPeopleRateChange?$AA@
CONST	SEGMENT
??_C@_0BG@PEIPJGC@GreatPeopleRateChange?$AA@ DB 'GreatPeopleRateChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNHDGJOG@SpecialistExtraCulture?$AA@
CONST	SEGMENT
??_C@_0BH@CNHDGJOG@SpecialistExtraCulture?$AA@ DB 'SpecialistExtraCulture'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KNNJHJEH@SpecialistCount?$AA@
CONST	SEGMENT
??_C@_0BA@KNNJHJEH@SpecialistCount?$AA@ DB 'SpecialistCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KLBEOMLO@SpecialistType?$AA@
CONST	SEGMENT
??_C@_0P@KLBEOMLO@SpecialistType?$AA@ DB 'SpecialistType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@
CONST	SEGMENT
??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@ DB 'PolicyBranchType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NJNFNDFO@PrereqTech?$AA@
CONST	SEGMENT
??_C@_0L@NJNFNDFO@PrereqTech?$AA@ DB 'PrereqTech', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JEAPEJLP@ReplacementBuildingClass?$AA@
CONST	SEGMENT
??_C@_0BJ@JEAPEJLP@ReplacementBuildingClass?$AA@ DB 'ReplacementBuildingC'
	DB	'lass', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBBLNJGG@FreePromotionRemoved?$AA@
CONST	SEGMENT
??_C@_0BF@CBBLNJGG@FreePromotionRemoved?$AA@ DB 'FreePromotionRemoved', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HBFHHGMI@TrainedFreePromotion?$AA@
CONST	SEGMENT
??_C@_0BF@HBFHHGMI@TrainedFreePromotion?$AA@ DB 'TrainedFreePromotion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FDCFKJMG@FreePromotion?$AA@
CONST	SEGMENT
??_C@_0O@FDCFKJMG@FreePromotion?$AA@ DB 'FreePromotion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAEFDHBK@FreeBuildingThisCity?$AA@
CONST	SEGMENT
??_C@_0BF@FAEFDHBK@FreeBuildingThisCity?$AA@ DB 'FreeBuildingThisCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHKBNAC@FreeBuilding?$AA@
CONST	SEGMENT
??_C@_0N@EHKBNAC@FreeBuilding?$AA@ DB 'FreeBuilding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LLHNLPLG@TechEnhancedTourism?$AA@
CONST	SEGMENT
??_C@_0BE@LLHNLPLG@TechEnhancedTourism?$AA@ DB 'TechEnhancedTourism', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DFCBDFGG@EnhancedYieldTech?$AA@
CONST	SEGMENT
??_C@_0BC@DFCBDFGG@EnhancedYieldTech?$AA@ DB 'EnhancedYieldTech', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@
CONST	SEGMENT
??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@ DB 'ObsoleteTech', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNMHACIA@MaxStartEra?$AA@
CONST	SEGMENT
??_C@_0M@NNMHACIA@MaxStartEra?$AA@ DB 'MaxStartEra', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LADKBMLE@FreeStartEra?$AA@
CONST	SEGMENT
??_C@_0N@LADKBMLE@FreeStartEra?$AA@ DB 'FreeStartEra', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KJJJODBC@VictoryPrereq?$AA@
CONST	SEGMENT
??_C@_0O@KJJJODBC@VictoryPrereq?$AA@ DB 'VictoryPrereq', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OCNBBLOA@ProhibitedCityTerrain?$AA@
CONST	SEGMENT
??_C@_0BG@OCNBBLOA@ProhibitedCityTerrain?$AA@ DB 'ProhibitedCityTerrain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNNKFMIB@NearbyTerrainRequired?$AA@
CONST	SEGMENT
??_C@_0BG@DNNKFMIB@NearbyTerrainRequired?$AA@ DB 'NearbyTerrainRequired', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NLLCNLEE@ThemingBonusHelp?$AA@
CONST	SEGMENT
??_C@_0BB@NLLCNLEE@ThemingBonusHelp?$AA@ DB 'ThemingBonusHelp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BAEHGPFA@WonderSplashAudio?$AA@
CONST	SEGMENT
??_C@_0BC@BAEHGPFA@WonderSplashAudio?$AA@ DB 'WonderSplashAudio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@
CONST	SEGMENT
??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@ DB 'ArtDefineTag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GBPAPFFG@BuildingClass?$AA@
CONST	SEGMENT
??_C@_0O@GBPAPFFG@BuildingClass?$AA@ DB 'BuildingClass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EABPJAPH@ArtInfoRandomVariation?$AA@
CONST	SEGMENT
??_C@_0BH@EABPJAPH@ArtInfoRandomVariation?$AA@ DB 'ArtInfoRandomVariation'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DGFAELDF@ArtInfoEraVariation?$AA@
CONST	SEGMENT
??_C@_0BE@DGFAELDF@ArtInfoEraVariation?$AA@ DB 'ArtInfoEraVariation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JGFNFBNF@ArtInfoCulturalVariation?$AA@
CONST	SEGMENT
??_C@_0BJ@JGFNFBNF@ArtInfoCulturalVariation?$AA@ DB 'ArtInfoCulturalVaria'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NLIKPLNH@PortraitIndex?$AA@
CONST	SEGMENT
??_C@_0O@NLIKPLNH@PortraitIndex?$AA@ DB 'PortraitIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMIICDJF@DisplayPosition?$AA@
CONST	SEGMENT
??_C@_0BA@DMIICDJF@DisplayPosition?$AA@ DB 'DisplayPosition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHNMMAEN@ExtraLeagueVotes?$AA@
CONST	SEGMENT
??_C@_0BB@CHNMMAEN@ExtraLeagueVotes?$AA@ DB 'ExtraLeagueVotes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JGEIPAGC@GreatScientistBeakerModifier?$AA@
CONST	SEGMENT
??_C@_0BN@JGEIPAGC@GreatScientistBeakerModifier?$AA@ DB 'GreatScientistBe'
	DB	'akerModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NNLIKACH@XBuiltTriggersIdeologyChoice?$AA@
CONST	SEGMENT
??_C@_0BN@NNLIKACH@XBuiltTriggersIdeologyChoice?$AA@ DB 'XBuiltTriggersId'
	DB	'eologyChoice', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NHOICAO@GreatWorksTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BK@NHOICAO@GreatWorksTourismModifier?$AA@ DB 'GreatWorksTourismMod'
	DB	'ifier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GABFOINA@InstantMilitaryIncrease?$AA@
CONST	SEGMENT
??_C@_0BI@GABFOINA@InstantMilitaryIncrease?$AA@ DB 'InstantMilitaryIncrea'
	DB	'se', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EHLPJCJM@LandmarksTourismPercent?$AA@
CONST	SEGMENT
??_C@_0BI@EHLPJCJM@LandmarksTourismPercent?$AA@ DB 'LandmarksTourismPerce'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FKGBMAOG@InstantSpyRankChange?$AA@
CONST	SEGMENT
??_C@_0BF@FKGBMAOG@InstantSpyRankChange?$AA@ DB 'InstantSpyRankChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LIDBPAKF@CityStateTradeRouteGoldModifier?$AA@
CONST	SEGMENT
??_C@_0CA@LIDBPAKF@CityStateTradeRouteGoldModifier?$AA@ DB 'CityStateTrad'
	DB	'eRouteGoldModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NMEAPNPJ@CityStateTradeRouteProductionMod@
CONST	SEGMENT
??_C@_0CG@NMEAPNPJ@CityStateTradeRouteProductionMod@ DB 'CityStateTradeRo'
	DB	'uteProductionModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DMDIJHPD@TradeRouteLandGoldBonus?$AA@
CONST	SEGMENT
??_C@_0BI@DMDIJHPD@TradeRouteLandGoldBonus?$AA@ DB 'TradeRouteLandGoldBon'
	DB	'us', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MNFCPAGM@TradeRouteLandDistanceModifier?$AA@
CONST	SEGMENT
??_C@_0BP@MNFCPAGM@TradeRouteLandDistanceModifier?$AA@ DB 'TradeRouteLand'
	DB	'DistanceModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MHOEOOPE@TradeRouteSeaGoldBonus?$AA@
CONST	SEGMENT
??_C@_0BH@MHOEOOPE@TradeRouteSeaGoldBonus?$AA@ DB 'TradeRouteSeaGoldBonus'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DJLKJBBF@TradeRouteSeaDistanceModifier?$AA@
CONST	SEGMENT
??_C@_0BO@DJLKJBBF@TradeRouteSeaDistanceModifier?$AA@ DB 'TradeRouteSeaDi'
	DB	'stanceModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCCNONCD@NumTradeRouteBonus?$AA@
CONST	SEGMENT
??_C@_0BD@PCCNONCD@NumTradeRouteBonus?$AA@ DB 'NumTradeRouteBonus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KDKDANDF@TradeRouteTargetBonus?$AA@
CONST	SEGMENT
??_C@_0BG@KDKDANDF@TradeRouteTargetBonus?$AA@ DB 'TradeRouteTargetBonus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LGPMFPOC@TradeRouteRecipientBonus?$AA@
CONST	SEGMENT
??_C@_0BJ@LGPMFPOC@TradeRouteRecipientBonus?$AA@ DB 'TradeRouteRecipientB'
	DB	'onus', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MKBDDMLG@SpyRankChange?$AA@
CONST	SEGMENT
??_C@_0O@MKBDDMLG@SpyRankChange?$AA@ DB 'SpyRankChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MHOKHMFG@ExtraSpies?$AA@
CONST	SEGMENT
??_C@_0L@MHOKHMFG@ExtraSpies?$AA@ DB 'ExtraSpies', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LABECCNE@GlobalEspionageModifier?$AA@
CONST	SEGMENT
??_C@_0BI@LABECCNE@GlobalEspionageModifier?$AA@ DB 'GlobalEspionageModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMEAJMHG@EspionageModifier?$AA@
CONST	SEGMENT
??_C@_0BC@LMEAJMHG@EspionageModifier?$AA@ DB 'EspionageModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ODFECGBH@ReligiousPressureModifier?$AA@
CONST	SEGMENT
??_C@_0BK@ODFECGBH@ReligiousPressureModifier?$AA@ DB 'ReligiousPressureMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GFFBMGNA@ExtraMissionarySpreads?$AA@
CONST	SEGMENT
??_C@_0BH@GFFBMGNA@ExtraMissionarySpreads?$AA@ DB 'ExtraMissionarySpreads'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OGDMFMLE@VictoryPoints?$AA@
CONST	SEGMENT
??_C@_0O@OGDMFMLE@VictoryPoints?$AA@ DB 'VictoryPoints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GHFKMIAN@MinorFriendshipChange?$AA@
CONST	SEGMENT
??_C@_0BG@GHFKMIAN@MinorFriendshipChange?$AA@ DB 'MinorFriendshipChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LNJPJMKG@ExtraCityHitPoints?$AA@
CONST	SEGMENT
??_C@_0BD@LNJPJMKG@ExtraCityHitPoints?$AA@ DB 'ExtraCityHitPoints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JKDLEHAG@GlobalDefenseMod?$AA@
CONST	SEGMENT
??_C@_0BB@JKDLEHAG@GlobalDefenseMod?$AA@ DB 'GlobalDefenseMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NIACICCM@DefensePerCitizen?$AA@
CONST	SEGMENT
??_C@_0BC@NIACICCM@DefensePerCitizen?$AA@ DB 'DefensePerCitizen', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PEDPFCGC@Defense?$AA@
CONST	SEGMENT
??_C@_07PEDPFCGC@Defense?$AA@ DB 'Defense', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BOAIOPHA@AllowsRangeStrike?$AA@
CONST	SEGMENT
??_C@_0BC@BOAIOPHA@AllowsRangeStrike?$AA@ DB 'AllowsRangeStrike', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NDBHABCH@NearbyMountainRequired?$AA@
CONST	SEGMENT
??_C@_0BH@NDBHABCH@NearbyMountainRequired?$AA@ DB 'NearbyMountainRequired'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04PABHPHAJ@Gold?$AA@
CONST	SEGMENT
??_C@_04PABHPHAJ@Gold?$AA@ DB 'Gold', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@
CONST	SEGMENT
??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@ DB 'MedianTechPercentChan'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPFMCCIM@FreeGreatPeople?$AA@
CONST	SEGMENT
??_C@_0BA@DPFMCCIM@FreeGreatPeople?$AA@ DB 'FreeGreatPeople', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ONPKDJAH@MountainScienceYield?$AA@
CONST	SEGMENT
??_C@_0BF@ONPKDJAH@MountainScienceYield?$AA@ DB 'MountainScienceYield', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DENBKNLO@FreeFlatFaith?$AA@
CONST	SEGMENT
??_C@_0O@DENBKNLO@FreeFlatFaith?$AA@ DB 'FreeFlatFaith', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PJBJAAKG@FreePolicies?$AA@
CONST	SEGMENT
??_C@_0N@PJBJAAKG@FreePolicies?$AA@ DB 'FreePolicies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LNIJJMDM@FreeTechs?$AA@
CONST	SEGMENT
??_C@_09LNIJJMDM@FreeTechs?$AA@ DB 'FreeTechs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LDHOCFOF@TechShare?$AA@
CONST	SEGMENT
??_C@_09LDHOCFOF@TechShare?$AA@ DB 'TechShare', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LMGKPHCK@LocalPopulationChange?$AA@
CONST	SEGMENT
??_C@_0BG@LMGKPHCK@LocalPopulationChange?$AA@ DB 'LocalPopulationChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PIGIEKJF@GlobalPopulationChange?$AA@
CONST	SEGMENT
??_C@_0BH@PIGIEKJF@GlobalPopulationChange?$AA@ DB 'GlobalPopulationChange'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HHDDIAGF@GlobalPlotBuyCostModifier?$AA@
CONST	SEGMENT
??_C@_0BK@HHDDIAGF@GlobalPlotBuyCostModifier?$AA@ DB 'GlobalPlotBuyCostMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@
CONST	SEGMENT
??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@ DB 'PlotBuyCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JENENNEF@GlobalPlotCultureCostModifier?$AA@
CONST	SEGMENT
??_C@_0BO@JENENNEF@GlobalPlotCultureCostModifier?$AA@ DB 'GlobalPlotCultu'
	DB	'reCostModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@
CONST	SEGMENT
??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@ DB 'PlotCultureCostModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@
CONST	SEGMENT
??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@ DB 'PolicyCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NHKFNDOG@CapturePlunderModifier?$AA@
CONST	SEGMENT
??_C@_0BH@NHKFNDOG@CapturePlunderModifier?$AA@ DB 'CapturePlunderModifier'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KIEKHDEM@CityConnectionTradeRouteModifier@
CONST	SEGMENT
??_C@_0CB@KIEKHDEM@CityConnectionTradeRouteModifier@ DB 'CityConnectionTr'
	DB	'adeRouteModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@ DB 'WonderProductionModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@ DB 'BuildingProduction'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BNLDOPDP@GlobalSpaceProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BO@BNLDOPDP@GlobalSpaceProductionModifier?$AA@ DB 'GlobalSpaceProd'
	DB	'uctionModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KLOFIIDO@SpaceProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BI@KLOFIIDO@SpaceProductionModifier?$AA@ DB 'SpaceProductionModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@ DB 'MilitaryProduction'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
CONST	SEGMENT
??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@ DB 'WorkerSpeedModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HACMNBGA@NoOccupiedUnhappiness?$AA@
CONST	SEGMENT
??_C@_0BG@HACMNBGA@NoOccupiedUnhappiness?$AA@ DB 'NoOccupiedUnhappiness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@
CONST	SEGMENT
??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@ DB 'CityCountUnhappinessM'
	DB	'od', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PPCKEPPB@HappinessPerXPolicies?$AA@
CONST	SEGMENT
??_C@_0BG@PPCKEPPB@HappinessPerXPolicies?$AA@ DB 'HappinessPerXPolicies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HFLAGBOL@HappinessPerCity?$AA@
CONST	SEGMENT
??_C@_0BB@HFLAGBOL@HappinessPerCity?$AA@ DB 'HappinessPerCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EFAAFPFO@UnhappinessModifier?$AA@
CONST	SEGMENT
??_C@_0BE@EFAAFPFO@UnhappinessModifier?$AA@ DB 'UnhappinessModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CGGCCKPG@UnmoddedHappiness?$AA@
CONST	SEGMENT
??_C@_0BC@CGGCCKPG@UnmoddedHappiness?$AA@ DB 'UnmoddedHappiness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNJMGIDC@Happiness?$AA@
CONST	SEGMENT
??_C@_09MNJMGIDC@Happiness?$AA@ DB 'Happiness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ELFDMBAA@HealRateChange?$AA@
CONST	SEGMENT
??_C@_0P@ELFDMBAA@HealRateChange?$AA@ DB 'HealRateChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JODJDJH@NukeExplosionRand?$AA@
CONST	SEGMENT
??_C@_0BC@JODJDJH@NukeExplosionRand?$AA@ DB 'NukeExplosionRand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKGPEEDC@NukeModifier?$AA@
CONST	SEGMENT
??_C@_0N@DKGPEEDC@NukeModifier?$AA@ DB 'NukeModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDJEHHOP@AirModifier?$AA@
CONST	SEGMENT
??_C@_0M@IDJEHHOP@AirModifier?$AA@ DB 'AirModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DKMLGOLM@Airlift?$AA@
CONST	SEGMENT
??_C@_07DKMLGOLM@Airlift?$AA@ DB 'Airlift', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GPFHOIEA@FoodKept?$AA@
CONST	SEGMENT
??_C@_08GPFHOIEA@FoodKept?$AA@ DB 'FoodKept', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PGIKLGNH@GlobalExperience?$AA@
CONST	SEGMENT
??_C@_0BB@PGIKLGNH@GlobalExperience?$AA@ DB 'GlobalExperience', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DCGNFONO@Experience?$AA@
CONST	SEGMENT
??_C@_0L@DCGNFONO@Experience?$AA@ DB 'Experience', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EMNAJIOA@GoldenAgeModifier?$AA@
CONST	SEGMENT
??_C@_0BC@EMNAJIOA@GoldenAgeModifier?$AA@ DB 'GoldenAgeModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@
CONST	SEGMENT
??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@ DB 'UnitUpgradeCostMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DMFMCIBK@GreatPersonExpendGold?$AA@
CONST	SEGMENT
??_C@_0BG@DMFMCIBK@GreatPersonExpendGold?$AA@ DB 'GreatPersonExpendGold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@ DB 'GreatGeneralRateModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IMGFGCPH@GlobalGreatPeopleRateModifier?$AA@
CONST	SEGMENT
??_C@_0BO@IMGFGCPH@GlobalGreatPeopleRateModifier?$AA@ DB 'GlobalGreatPeop'
	DB	'leRateModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@
CONST	SEGMENT
??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@ DB 'GreatPeopleRateModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFILFBOG@GlobalCultureRateModifier?$AA@
CONST	SEGMENT
??_C@_0BK@KFILFBOG@GlobalCultureRateModifier?$AA@ DB 'GlobalCultureRateMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BFGDBNFC@CultureRateModifier?$AA@
CONST	SEGMENT
??_C@_0BE@BFGDBNFC@CultureRateModifier?$AA@ DB 'CultureRateModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HHMEOJHA@LevelPrereq?$AA@
CONST	SEGMENT
??_C@_0M@HHMEOJHA@LevelPrereq?$AA@ DB 'LevelPrereq', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JPPGNKPJ@CitiesPrereq?$AA@
CONST	SEGMENT
??_C@_0N@JPPGNKPJ@CitiesPrereq?$AA@ DB 'CitiesPrereq', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DDEKGLDJ@ConquestProb?$AA@
CONST	SEGMENT
??_C@_0N@DDEKGLDJ@ConquestProb?$AA@ DB 'ConquestProb', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILJKFCBC@MinAreaSize?$AA@
CONST	SEGMENT
??_C@_0M@ILJKFCBC@MinAreaSize?$AA@ DB 'MinAreaSize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@
CONST	SEGMENT
??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@ DB 'HurryCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JHBNAHPF@NumCityCostMod?$AA@
CONST	SEGMENT
??_C@_0P@JHBNAHPF@NumCityCostMod?$AA@ DB 'NumCityCostMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PLFPOGBO@NullifyInfluenceModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@PLFPOGBO@NullifyInfluenceModifier?$AA@ DB 'NullifyInfluenceModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BLJJFLJE@AllowsProductionTradeRoutes?$AA@
CONST	SEGMENT
??_C@_0BM@BLJJFLJE@AllowsProductionTradeRoutes?$AA@ DB 'AllowsProductionT'
	DB	'radeRoutes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IGJKJBLH@AllowsFoodTradeRoutes?$AA@
CONST	SEGMENT
??_C@_0BG@IGJKJBLH@AllowsFoodTradeRoutes?$AA@ DB 'AllowsFoodTradeRoutes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FOBHMOJA@MaliTreasury?$AA@
CONST	SEGMENT
??_C@_0N@FOBHMOJA@MaliTreasury?$AA@ DB 'MaliTreasury', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BGJOJKFJ@Espionage?$AA@
CONST	SEGMENT
??_C@_09BGJOJKFJ@Espionage?$AA@ DB 'Espionage', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EAJEPOJD@AffectSpiesNow?$AA@
CONST	SEGMENT
??_C@_0P@EAJEPOJD@AffectSpiesNow?$AA@ DB 'AffectSpiesNow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBDEBKOC@HolyCity?$AA@
CONST	SEGMENT
??_C@_08OBDEBKOC@HolyCity?$AA@ DB 'HolyCity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPGENGJF@UnlockedByLeague?$AA@
CONST	SEGMENT
??_C@_0BB@IPGENGJF@UnlockedByLeague?$AA@ DB 'UnlockedByLeague', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PABPOOPJ@UnlockedByBelief?$AA@
CONST	SEGMENT
??_C@_0BB@PABPOOPJ@UnlockedByBelief?$AA@ DB 'UnlockedByBelief', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GJEJPIBI@LeagueCost?$AA@
CONST	SEGMENT
??_C@_0L@GJEJPIBI@LeagueCost?$AA@ DB 'LeagueCost', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JGBPBICB@FaithCost?$AA@
CONST	SEGMENT
??_C@_09JGBPBICB@FaithCost?$AA@ DB 'FaithCost', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FICPKHNF@Cost?$AA@
CONST	SEGMENT
??_C@_04FICPKHNF@Cost?$AA@ DB 'Cost', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CHJMKLJG@AllowsWaterRoutes?$AA@
CONST	SEGMENT
??_C@_0BC@CHJMKLJG@AllowsWaterRoutes?$AA@ DB 'AllowsWaterRoutes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JIBMBBHG@DiplomaticVoting?$AA@
CONST	SEGMENT
??_C@_0BB@JIBMBBHG@DiplomaticVoting?$AA@ DB 'DiplomaticVoting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GDMCMLLL@ExtraLuxuries?$AA@
CONST	SEGMENT
??_C@_0O@GDMCMLLL@ExtraLuxuries?$AA@ DB 'ExtraLuxuries', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IEGLFCGA@CityWall?$AA@
CONST	SEGMENT
??_C@_08IEGLFCGA@CityWall?$AA@ DB 'CityWall', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EEGCDFDE@NukeImmune?$AA@
CONST	SEGMENT
??_C@_0L@EEGCDFDE@NukeImmune?$AA@ DB 'NukeImmune', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGKADJEK@NeverCapture?$AA@
CONST	SEGMENT
??_C@_0N@GGKADJEK@NeverCapture?$AA@ DB 'NeverCapture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDAIKEA@MapCentering?$AA@
CONST	SEGMENT
??_C@_0N@MDAIKEA@MapCentering?$AA@ DB 'MapCentering', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GBMHJELN@GrantsFreeCulturalGreatPersonWit@
CONST	SEGMENT
??_C@_0CH@GBMHJELN@GrantsFreeCulturalGreatPersonWit@ DB 'GrantsFreeCultur'
	DB	'alGreatPersonWithTrait', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BDPFDCPN@GoldenAge?$AA@
CONST	SEGMENT
??_C@_09BDPFDCPN@GoldenAge?$AA@ DB 'GoldenAge', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLAOAIED@Capital?$AA@
CONST	SEGMENT
??_C@_07OLAOAIED@Capital?$AA@ DB 'Capital', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DPODFGDF@PlayerBorderObstacle?$AA@
CONST	SEGMENT
??_C@_0BF@DPODFGDF@PlayerBorderObstacle?$AA@ DB 'PlayerBorderObstacle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LIILLJIL@BorderObstacle?$AA@
CONST	SEGMENT
??_C@_0P@LIILLJIL@BorderObstacle?$AA@ DB 'BorderObstacle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MIOBODFK@IsReligious?$AA@
CONST	SEGMENT
??_C@_0M@MIOBODFK@IsReligious?$AA@ DB 'IsReligious', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PDCEKFCE@FoundsReligion?$AA@
CONST	SEGMENT
??_C@_0P@PDCEKFCE@FoundsReligion?$AA@ DB 'FoundsReligion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNNIPAFF@Flat?$AA@
CONST	SEGMENT
??_C@_04JNNIPAFF@Flat?$AA@ DB 'Flat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JPPFLFAM@Hill?$AA@
CONST	SEGMENT
??_C@_04JPPFLFAM@Hill?$AA@ DB 'Hill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAPOEMFP@Mountain?$AA@
CONST	SEGMENT
??_C@_08IAPOEMFP@Mountain?$AA@ DB 'Mountain', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NGNKNLMG@FreshWater?$AA@
CONST	SEGMENT
??_C@_0L@NGNKNLMG@FreshWater?$AA@ DB 'FreshWater', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGBIAPGD@River?$AA@
CONST	SEGMENT
??_C@_05IGBIAPGD@River?$AA@ DB 'River', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EMKMBNJK@Water?$AA@
CONST	SEGMENT
??_C@_05EMKMBNJK@Water?$AA@ DB 'Water', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDGDANDP@TeamShare?$AA@
CONST	SEGMENT
??_C@_09KDGDANDP@TeamShare?$AA@ DB 'TeamShare', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CODCFEOP@MutuallyExclusiveGroup?$AA@
CONST	SEGMENT
??_C@_0BH@CODCFEOP@MutuallyExclusiveGroup?$AA@ DB 'MutuallyExclusiveGroup'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@
CONST	SEGMENT
??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@ DB 'GoldMaintenance', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$37
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv1681 = -788						; size = 4
tv2826 = -781						; size = 1
tv2823 = -780						; size = 4
tv2820 = -776						; size = 4
tv1667 = -772						; size = 4
tv1781 = -768						; size = 4
tv1322 = -764						; size = 4
_this$ = -760						; size = 4
$T227621 = -756						; size = 4
$T227620 = -752						; size = 4
$T226907 = -496						; size = 4
$T226901 = -492						; size = 4
$T226881 = -488						; size = 4
$T226880 = -484						; size = 4
$T226879 = -480						; size = 12
_pThemingInfo$218544 = -468				; size = 4
_pResourceTypes$218537 = -464				; size = 4
_strResourceTypesKey$218535 = -460			; size = 28
_lenBuildingType$218540 = -432				; size = 4
_iNumThemes$218527 = -428				; size = 4
_idx$218534 = -424					; size = 4
_iYieldChange$218526 = -420				; size = 4
_BuildingClassID$218524 = -416				; size = 4
_iYieldID$218525 = -412					; size = 4
_pResults$218518 = -408					; size = 4
_strKey$218516 = -404					; size = 28
_ResourceID$218513 = -376				; size = 4
_yield$218515 = -372					; size = 4
_YieldID$218514 = -368					; size = 4
_pResults$218507 = -364					; size = 4
_strKey$218505 = -360					; size = 28
_yield$218504 = -332					; size = 4
_SpecialistID$218502 = -328				; size = 4
_YieldID$218503 = -324					; size = 4
_pResults$218496 = -320					; size = 4
_strKey$218494 = -316					; size = 28
_TerrainID$218490 = -288				; size = 4
_yield$218492 = -284					; size = 4
_YieldID$218491 = -280					; size = 4
_pResults$218484 = -276					; size = 4
_strKey$218482 = -272					; size = 28
_yield$218480 = -244					; size = 4
_ImprovementID$218478 = -240				; size = 4
_YieldID$218479 = -236					; size = 4
_pResults$218472 = -232					; size = 4
_strKey$218470 = -228					; size = 28
_yield$218469 = -200					; size = 4
_ImprovementID$218467 = -196				; size = 4
_YieldID$218468 = -192					; size = 4
_pResults$218461 = -188					; size = 4
_strKey$218459 = -184					; size = 28
_FeatureID$218455 = -156				; size = 4
_yield$218457 = -152					; size = 4
_YieldID$218456 = -148					; size = 4
_pResults$218449 = -144					; size = 4
_strKey$218447 = -140					; size = 28
_iYield$217934 = -112					; size = 4
_iYieldType$217933 = -108				; size = 4
_iResource$217932 = -104				; size = 4
_pResults$217926 = -100					; size = 4
_strKey$217924 = -96					; size = 28
_ResourceID$217921 = -68				; size = 4
_yield$217923 = -64					; size = 4
_YieldID$217922 = -60					; size = 4
_pResults$217915 = -56					; size = 4
_strKey$217913 = -52					; size = 28
__$ArrayPad$ = -24					; size = 4
_szTextVal$ = -20					; size = 4
_szBuildingType$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvBuildingEntry::CacheResults, COMDAT
; _this$ = ecx

; 293  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 776				; 00000308H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN31@CacheResul

; 295  : 		return false;

	xor	al, al
	jmp	$LN32@CacheResul
$LN31@CacheResul:

; 296  : 
; 297  : 	//Basic Properties
; 298  : 	m_iGoldMaintenance = kResults.GetInt("GoldMaintenance");

	push	OFFSET ??_C@_0BA@NGAILOKJ@GoldMaintenance?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 299  : 	m_iMutuallyExclusiveGroup = kResults.GetInt("MutuallyExclusiveGroup");

	push	OFFSET ??_C@_0BH@CODCFEOP@MutuallyExclusiveGroup?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+304], eax

; 300  : 	m_bTeamShare = kResults.GetBool("TeamShare");

	push	OFFSET ??_C@_09KDGDANDP@TeamShare?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+716], al

; 301  : 	m_bWater = kResults.GetBool("Water");

	push	OFFSET ??_C@_05EMKMBNJK@Water?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+717], al

; 302  : 	m_bRiver = kResults.GetBool("River");

	push	OFFSET ??_C@_05IGBIAPGD@River?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+718], al

; 303  : 	m_bFreshWater = kResults.GetBool("FreshWater");

	push	OFFSET ??_C@_0L@NGNKNLMG@FreshWater?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+719], al

; 304  : 	m_bMountain = kResults.GetBool("Mountain");

	push	OFFSET ??_C@_08IAPOEMFP@Mountain?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+720], al

; 305  : 	m_bHill = kResults.GetBool("Hill");

	push	OFFSET ??_C@_04JPPFLFAM@Hill?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+721], al

; 306  : 	m_bFlat = kResults.GetBool("Flat");

	push	OFFSET ??_C@_04JNNIPAFF@Flat?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+722], al

; 307  : 	m_bFoundsReligion = kResults.GetBool("FoundsReligion");

	push	OFFSET ??_C@_0P@PDCEKFCE@FoundsReligion?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+723], al

; 308  : 	m_bIsReligious = kResults.GetBool("IsReligious");

	push	OFFSET ??_C@_0M@MIOBODFK@IsReligious?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+724], al

; 309  : 	m_bBorderObstacle = kResults.GetBool("BorderObstacle");

	push	OFFSET ??_C@_0P@LIILLJIL@BorderObstacle?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+725], al

; 310  : 	m_bPlayerBorderObstacle = kResults.GetBool("PlayerBorderObstacle");

	push	OFFSET ??_C@_0BF@DPODFGDF@PlayerBorderObstacle?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+726], al

; 311  : 	m_bCapital = kResults.GetBool("Capital");

	push	OFFSET ??_C@_07OLAOAIED@Capital?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+727], al

; 312  : 	m_bGoldenAge = kResults.GetBool("GoldenAge");

	push	OFFSET ??_C@_09BDPFDCPN@GoldenAge?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+728], al

; 313  : 	m_bGrantsFreeCulturalGreatPersonWithTrait = kResults.GetBool("GrantsFreeCulturalGreatPersonWithTrait"); // NQMP GJS - New France UA

	push	OFFSET ??_C@_0CH@GBMHJELN@GrantsFreeCulturalGreatPersonWit@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+729], al

; 314  : 	m_bMapCentering = kResults.GetBool("MapCentering");

	push	OFFSET ??_C@_0N@MDAIKEA@MapCentering?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+730], al

; 315  : 	m_bNeverCapture = kResults.GetBool("NeverCapture");

	push	OFFSET ??_C@_0N@GGKADJEK@NeverCapture?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+731], al

; 316  : 	m_bNukeImmune = kResults.GetBool("NukeImmune");

	push	OFFSET ??_C@_0L@EEGCDFDE@NukeImmune?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+732], al

; 317  : 	m_bCityWall = kResults.GetBool("CityWall");

	push	OFFSET ??_C@_08IEGLFCGA@CityWall?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+736], al

; 318  : 	m_bExtraLuxuries = kResults.GetBool("ExtraLuxuries");

	push	OFFSET ??_C@_0O@GDMCMLLL@ExtraLuxuries?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+733], al

; 319  : 	m_bDiplomaticVoting = kResults.GetBool("DiplomaticVoting");

	push	OFFSET ??_C@_0BB@JIBMBBHG@DiplomaticVoting?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+734], al

; 320  : 	m_bAllowsWaterRoutes = kResults.GetBool("AllowsWaterRoutes");

	push	OFFSET ??_C@_0BC@CHJMKLJG@AllowsWaterRoutes?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+735], al

; 321  : 	m_iProductionCost = kResults.GetInt("Cost");

	push	OFFSET ??_C@_04FICPKHNF@Cost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+368], eax

; 322  : 	m_iFaithCost = kResults.GetInt("FaithCost");

	push	OFFSET ??_C@_09JGBPBICB@FaithCost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 323  : 	m_iLeagueCost = kResults.GetInt("LeagueCost");

	push	OFFSET ??_C@_0L@GJEJPIBI@LeagueCost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+376], eax

; 324  : 	m_bUnlockedByBelief = kResults.GetBool("UnlockedByBelief");

	push	OFFSET ??_C@_0BB@PABPOOPJ@UnlockedByBelief?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+737], al

; 325  : 	m_bUnlockedByLeague = kResults.GetBool("UnlockedByLeague");

	push	OFFSET ??_C@_0BB@IPGENGJF@UnlockedByLeague?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+738], al

; 326  : 	m_bRequiresHolyCity = kResults.GetBool("HolyCity");

	push	OFFSET ??_C@_08OBDEBKOC@HolyCity?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+739], al

; 327  : 	m_bAffectSpiesNow = kResults.GetBool("AffectSpiesNow");

	push	OFFSET ??_C@_0P@EAJEPOJD@AffectSpiesNow?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+740], al

; 328  : 	m_bEspionage = kResults.GetBool("Espionage");

	push	OFFSET ??_C@_09BGJOJKFJ@Espionage?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+741], al

; 329  : #ifdef NQ_MALI_TREASURY
; 330  : 	m_bMalianTreasury = kResults.GetBool("MaliTreasury");

	push	OFFSET ??_C@_0N@FOBHMOJA@MaliTreasury?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+742], al

; 331  : #endif
; 332  : 	m_bAllowsFoodTradeRoutes = kResults.GetBool("AllowsFoodTradeRoutes");

	push	OFFSET ??_C@_0BG@IGJKJBLH@AllowsFoodTradeRoutes?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+743], al

; 333  : 	m_bAllowsProductionTradeRoutes = kResults.GetBool("AllowsProductionTradeRoutes");

	push	OFFSET ??_C@_0BM@BLJJFLJE@AllowsProductionTradeRoutes?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+744], al

; 334  : 	m_bNullifyInfluenceModifier = kResults.GetBool("NullifyInfluenceModifier");

	push	OFFSET ??_C@_0BJ@PLFPOGBO@NullifyInfluenceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+745], al

; 335  : 	m_iNumCityCostMod = kResults.GetInt("NumCityCostMod");

	push	OFFSET ??_C@_0P@JHBNAHPF@NumCityCostMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+380], eax

; 336  : 	m_iHurryCostModifier = kResults.GetInt("HurryCostModifier");

	push	OFFSET ??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+384], eax

; 337  : 	m_iMinAreaSize = kResults.GetInt("MinAreaSize");

	push	OFFSET ??_C@_0M@ILJKFCBC@MinAreaSize?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+508], eax

; 338  : 	m_iConquestProbability = kResults.GetInt("ConquestProb");

	push	OFFSET ??_C@_0N@DDEKGLDJ@ConquestProb?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+512], eax

; 339  : 	m_iNumCitiesPrereq = kResults.GetInt("CitiesPrereq");

	push	OFFSET ??_C@_0N@JPPGNKPJ@CitiesPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], eax

; 340  : 	m_iUnitLevelPrereq = kResults.GetInt("LevelPrereq");

	push	OFFSET ??_C@_0M@HHMEOJHA@LevelPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+392], eax

; 341  : 	m_iCultureRateModifier = kResults.GetInt("CultureRateModifier");

	push	OFFSET ??_C@_0BE@BFGDBNFC@CultureRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], eax

; 342  : 	m_iGlobalCultureRateModifier = kResults.GetInt("GlobalCultureRateModifier");

	push	OFFSET ??_C@_0BK@KFILFBOG@GlobalCultureRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+400], eax

; 343  : 	m_iGreatPeopleRateModifier = kResults.GetInt("GreatPeopleRateModifier");

	push	OFFSET ??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+404], eax

; 344  : 	m_iGlobalGreatPeopleRateModifier = kResults.GetInt("GlobalGreatPeopleRateModifier");

	push	OFFSET ??_C@_0BO@IMGFGCPH@GlobalGreatPeopleRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+408], eax

; 345  : 	m_iGreatGeneralRateModifier = kResults.GetInt("GreatGeneralRateModifier");

	push	OFFSET ??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+412], eax

; 346  : 	m_iGreatPersonExpendGold = kResults.GetInt("GreatPersonExpendGold");

	push	OFFSET ??_C@_0BG@DMFMCIBK@GreatPersonExpendGold?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], eax

; 347  : 	m_iUnitUpgradeCostMod = kResults.GetInt("UnitUpgradeCostMod");

	push	OFFSET ??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], eax

; 348  : 	m_iGoldenAgeModifier = kResults.GetInt("GoldenAgeModifier");

	push	OFFSET ??_C@_0BC@EMNAJIOA@GoldenAgeModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+424], eax

; 349  : 	m_iFreeExperience = kResults.GetInt("Experience");

	push	OFFSET ??_C@_0L@DCGNFONO@Experience?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+428], eax

; 350  : 	m_iGlobalFreeExperience = kResults.GetInt("GlobalExperience");

	push	OFFSET ??_C@_0BB@PGIKLGNH@GlobalExperience?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], eax

; 351  : 	m_iFoodKept = kResults.GetInt("FoodKept");

	push	OFFSET ??_C@_08GPFHOIEA@FoodKept?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+436], eax

; 352  : 	m_bAirlift = kResults.GetBool("Airlift");

	push	OFFSET ??_C@_07DKMLGOLM@Airlift?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+440], al

; 353  : 	m_iAirModifier = kResults.GetInt("AirModifier");

	push	OFFSET ??_C@_0M@IDJEHHOP@AirModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+444], eax

; 354  : 	m_iNukeModifier = kResults.GetInt("NukeModifier");

	push	OFFSET ??_C@_0N@DKGPEEDC@NukeModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+448], eax

; 355  : 	m_iNukeExplosionRand = kResults.GetInt("NukeExplosionRand");

	push	OFFSET ??_C@_0BC@JODJDJH@NukeExplosionRand?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+452], eax

; 356  : 	m_iHealRateChange = kResults.GetInt("HealRateChange");

	push	OFFSET ??_C@_0P@ELFDMBAA@HealRateChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+516], eax

; 357  : 	m_iHappiness = kResults.GetInt("Happiness");

	push	OFFSET ??_C@_09MNJMGIDC@Happiness?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+520], eax

; 358  : 	m_iUnmoddedHappiness = kResults.GetInt("UnmoddedHappiness");

	push	OFFSET ??_C@_0BC@CGGCCKPG@UnmoddedHappiness?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+524], eax

; 359  : 	m_iUnhappinessModifier = kResults.GetInt("UnhappinessModifier");

	push	OFFSET ??_C@_0BE@EFAAFPFO@UnhappinessModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+528], eax

; 360  : 	m_iHappinessPerCity = kResults.GetInt("HappinessPerCity");

	push	OFFSET ??_C@_0BB@HFLAGBOL@HappinessPerCity?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+532], eax

; 361  : 	m_iHappinessPerXPolicies = kResults.GetInt("HappinessPerXPolicies");

	push	OFFSET ??_C@_0BG@PPCKEPPB@HappinessPerXPolicies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+536], eax

; 362  : 	m_iCityCountUnhappinessMod = kResults.GetInt("CityCountUnhappinessMod");

	push	OFFSET ??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+540], eax

; 363  : 	m_bNoOccupiedUnhappiness = kResults.GetBool("NoOccupiedUnhappiness");

	push	OFFSET ??_C@_0BG@HACMNBGA@NoOccupiedUnhappiness?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+544], al

; 364  : 	m_iWorkerSpeedModifier = kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+456], eax

; 365  : 	m_iMilitaryProductionModifier = kResults.GetInt("MilitaryProductionModifier");

	push	OFFSET ??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+460], eax

; 366  : 	m_iSpaceProductionModifier = kResults.GetInt("SpaceProductionModifier");

	push	OFFSET ??_C@_0BI@KLOFIIDO@SpaceProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], eax

; 367  : 	m_iGlobalSpaceProductionModifier = kResults.GetInt("GlobalSpaceProductionModifier");

	push	OFFSET ??_C@_0BO@BNLDOPDP@GlobalSpaceProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], eax

; 368  : 	m_iBuildingProductionModifier = kResults.GetInt("BuildingProductionModifier");

	push	OFFSET ??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+472], eax

; 369  : 	m_iWonderProductionModifier = kResults.GetInt("WonderProductionModifier");

	push	OFFSET ??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+476], eax

; 370  : 	m_iCityConnectionTradeRouteModifier = kResults.GetInt("CityConnectionTradeRouteModifier");

	push	OFFSET ??_C@_0CB@KIEKHDEM@CityConnectionTradeRouteModifier@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], eax

; 371  : 	m_iCapturePlunderModifier = kResults.GetInt("CapturePlunderModifier");

	push	OFFSET ??_C@_0BH@NHKFNDOG@CapturePlunderModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+484], eax

; 372  : 	m_iPolicyCostModifier = kResults.GetInt("PolicyCostModifier");

	push	OFFSET ??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], eax

; 373  : 	m_iPlotCultureCostModifier = kResults.GetInt("PlotCultureCostModifier");

	push	OFFSET ??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+496], eax

; 374  : 	m_iGlobalPlotCultureCostModifier = kResults.GetInt("GlobalPlotCultureCostModifier");

	push	OFFSET ??_C@_0BO@JENENNEF@GlobalPlotCultureCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+492], eax

; 375  : 	m_iPlotBuyCostModifier = kResults.GetInt("PlotBuyCostModifier");

	push	OFFSET ??_C@_0BE@MHNLMMNB@PlotBuyCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+504], eax

; 376  : 	m_iGlobalPlotBuyCostModifier = kResults.GetInt("GlobalPlotBuyCostModifier");

	push	OFFSET ??_C@_0BK@HHDDIAGF@GlobalPlotBuyCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+500], eax

; 377  : 	m_iGlobalPopulationChange = kResults.GetInt("GlobalPopulationChange");

	push	OFFSET ??_C@_0BH@PIGIEKJF@GlobalPopulationChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+548], eax

; 378  : #ifdef NQ_LOCAL_POPULATION_CHANGE_FROM_BUILDING
; 379  : 	m_iLocalPopulationChange = kResults.GetInt("LocalPopulationChange");

	push	OFFSET ??_C@_0BG@LMGKPHCK@LocalPopulationChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+552], eax

; 380  : #endif
; 381  : 	m_iTechShare = kResults.GetInt("TechShare");

	push	OFFSET ??_C@_09LDHOCFOF@TechShare?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+556], eax

; 382  : 	m_iFreeTechs = kResults.GetInt("FreeTechs");

	push	OFFSET ??_C@_09LNIJJMDM@FreeTechs?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+560], eax

; 383  : 	m_iFreePolicies = kResults.GetInt("FreePolicies");

	push	OFFSET ??_C@_0N@PJBJAAKG@FreePolicies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+564], eax

; 384  : 	m_iFreeFlatFaith = kResults.GetInt("FreeFlatFaith"); // NQMP GJS - New Stonehenge

	push	OFFSET ??_C@_0O@DENBKNLO@FreeFlatFaith?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+568], eax

; 385  : 	m_iMountainScienceYield = kResults.GetInt("MountainScienceYield"); // NQMP GJS - mountain science yield

	push	OFFSET ??_C@_0BF@ONPKDJAH@MountainScienceYield?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+572], eax

; 386  : 	m_iFreeGreatPeople = kResults.GetInt("FreeGreatPeople");

	push	OFFSET ??_C@_0BA@DPFMCCIM@FreeGreatPeople?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+576], eax

; 387  : 	m_iMedianTechPercentChange = kResults.GetInt("MedianTechPercentChange");

	push	OFFSET ??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+580], eax

; 388  : 	m_iGold = kResults.GetInt("Gold");

	push	OFFSET ??_C@_04PABHPHAJ@Gold?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+584], eax

; 389  : 	m_bNearbyMountainRequired = kResults.GetInt("NearbyMountainRequired");

	push	OFFSET ??_C@_0BH@NDBHABCH@NearbyMountainRequired?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	test	eax, eax
	setne	dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+588], dl

; 390  : 	m_bAllowsRangeStrike = kResults.GetInt("AllowsRangeStrike");

	push	OFFSET ??_C@_0BC@BOAIOPHA@AllowsRangeStrike?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	test	eax, eax
	setne	cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+589], cl

; 391  : 	m_iDefenseModifier = kResults.GetInt("Defense");

	push	OFFSET ??_C@_07PEDPFCGC@Defense?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+592], eax

; 392  : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 393  : 	m_iDefensePerCitizen = kResults.GetInt("DefensePerCitizen");

	push	OFFSET ??_C@_0BC@NIACICCM@DefensePerCitizen?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+596], eax

; 394  : #endif
; 395  : 	m_iGlobalDefenseModifier = kResults.GetInt("GlobalDefenseMod");

	push	OFFSET ??_C@_0BB@JKDLEHAG@GlobalDefenseMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+600], eax

; 396  : 	m_iExtraCityHitPoints = kResults.GetInt("ExtraCityHitPoints");

	push	OFFSET ??_C@_0BD@LNJPJMKG@ExtraCityHitPoints?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+604], eax

; 397  : 	m_iMinorFriendshipChange = kResults.GetInt("MinorFriendshipChange");

	push	OFFSET ??_C@_0BG@GHFKMIAN@MinorFriendshipChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+612], eax

; 398  : 	m_iVictoryPoints = kResults.GetInt("VictoryPoints");

	push	OFFSET ??_C@_0O@OGDMFMLE@VictoryPoints?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+616], eax

; 399  : 	m_iExtraMissionarySpreads = kResults.GetInt("ExtraMissionarySpreads");

	push	OFFSET ??_C@_0BH@GFFBMGNA@ExtraMissionarySpreads?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+620], eax

; 400  : 	m_iReligiousPressureModifier = kResults.GetInt("ReligiousPressureModifier");

	push	OFFSET ??_C@_0BK@ODFECGBH@ReligiousPressureModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+624], eax

; 401  : 	m_iEspionageModifier = kResults.GetInt("EspionageModifier");

	push	OFFSET ??_C@_0BC@LMEAJMHG@EspionageModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+628], eax

; 402  : 	m_iGlobalEspionageModifier = kResults.GetInt("GlobalEspionageModifier");

	push	OFFSET ??_C@_0BI@LABECCNE@GlobalEspionageModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+632], eax

; 403  : 	m_iExtraSpies = kResults.GetInt("ExtraSpies");

	push	OFFSET ??_C@_0L@MHOKHMFG@ExtraSpies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+636], eax

; 404  : 	m_iSpyRankChange = kResults.GetInt("SpyRankChange");

	push	OFFSET ??_C@_0O@MKBDDMLG@SpyRankChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+640], eax

; 405  : 	m_iTradeRouteRecipientBonus = kResults.GetInt("TradeRouteRecipientBonus");

	push	OFFSET ??_C@_0BJ@LGPMFPOC@TradeRouteRecipientBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+664], eax

; 406  : 	m_iTradeRouteTargetBonus = kResults.GetInt("TradeRouteTargetBonus");

	push	OFFSET ??_C@_0BG@KDKDANDF@TradeRouteTargetBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+668], eax

; 407  : 	m_iNumTradeRouteBonus = kResults.GetInt("NumTradeRouteBonus");

	push	OFFSET ??_C@_0BD@PCCNONCD@NumTradeRouteBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 408  : 	m_iTradeRouteSeaDistanceModifier = kResults.GetInt("TradeRouteSeaDistanceModifier");

	push	OFFSET ??_C@_0BO@DJLKJBBF@TradeRouteSeaDistanceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+676], eax

; 409  : 	m_iTradeRouteSeaGoldBonus = kResults.GetInt("TradeRouteSeaGoldBonus");

	push	OFFSET ??_C@_0BH@MHOEOOPE@TradeRouteSeaGoldBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+680], eax

; 410  : 	m_iTradeRouteLandDistanceModifier = kResults.GetInt("TradeRouteLandDistanceModifier");

	push	OFFSET ??_C@_0BP@MNFCPAGM@TradeRouteLandDistanceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+684], eax

; 411  : 	m_iTradeRouteLandGoldBonus = kResults.GetInt("TradeRouteLandGoldBonus");

	push	OFFSET ??_C@_0BI@DMDIJHPD@TradeRouteLandGoldBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+688], eax

; 412  : 	m_iCityStateTradeRouteProductionModifier = kResults.GetInt("CityStateTradeRouteProductionModifier");

	push	OFFSET ??_C@_0CG@NMEAPNPJ@CityStateTradeRouteProductionMod@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+692], eax

; 413  : 	m_iCityStateTradeRouteGoldModifier = kResults.GetInt("CityStateTradeRouteGoldModifier"); // NQMP GJS - new Economic Union

	push	OFFSET ??_C@_0CA@LIDBPAKF@CityStateTradeRouteGoldModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+696], eax

; 414  : 	m_iInstantSpyRankChange = kResults.GetInt("InstantSpyRankChange");

	push	OFFSET ??_C@_0BF@FKGBMAOG@InstantSpyRankChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+644], eax

; 415  : 	m_iLandmarksTourismPercent = kResults.GetInt("LandmarksTourismPercent");

	push	OFFSET ??_C@_0BI@EHLPJCJM@LandmarksTourismPercent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+648], eax

; 416  : 	m_iInstantMilitaryIncrease = kResults.GetInt("InstantMilitaryIncrease");

	push	OFFSET ??_C@_0BI@GABFOINA@InstantMilitaryIncrease?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+652], eax

; 417  : 	m_iGreatWorksTourismModifier = kResults.GetInt("GreatWorksTourismModifier");

	push	OFFSET ??_C@_0BK@NHOICAO@GreatWorksTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 418  : 	m_iXBuiltTriggersIdeologyChoice = kResults.GetInt("XBuiltTriggersIdeologyChoice");

	push	OFFSET ??_C@_0BN@NNLIKACH@XBuiltTriggersIdeologyChoice?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+660], eax

; 419  : 	m_iGreatScientistBeakerModifier = kResults.GetInt("GreatScientistBeakerModifier");

	push	OFFSET ??_C@_0BN@JGEIPAGC@GreatScientistBeakerModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+700], eax

; 420  : 	m_iExtraLeagueVotes = kResults.GetInt("ExtraLeagueVotes");

	push	OFFSET ??_C@_0BB@CHNMMAEN@ExtraLeagueVotes?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+704], eax

; 421  : 	m_iPreferredDisplayPosition = kResults.GetInt("DisplayPosition");

	push	OFFSET ??_C@_0BA@DMIICDJF@DisplayPosition?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+708], eax

; 422  : 	m_iPortraitIndex = kResults.GetInt("PortraitIndex");

	push	OFFSET ??_C@_0O@NLIKPLNH@PortraitIndex?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+712], eax

; 423  : 
; 424  : 	m_bArtInfoCulturalVariation = kResults.GetBool("ArtInfoCulturalVariation");

	push	OFFSET ??_C@_0BJ@JGFNFBNF@ArtInfoCulturalVariation?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+746], al

; 425  : 	m_bArtInfoEraVariation = kResults.GetBool("ArtInfoEraVariation");

	push	OFFSET ??_C@_0BE@DGFAELDF@ArtInfoEraVariation?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+747], al

; 426  : 	m_bArtInfoRandomVariation = kResults.GetBool("ArtInfoRandomVariation");

	push	OFFSET ??_C@_0BH@EABPJAPH@ArtInfoRandomVariation?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+748], al

; 427  : 
; 428  : 	//References
; 429  : 	const char* szTextVal;
; 430  : 	szTextVal = kResults.GetText("BuildingClass");

	push	OFFSET ??_C@_0O@GBPAPFFG@BuildingClass?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 431  : 	m_iBuildingClassType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], eax

; 432  : 
; 433  : 	//This may need to be deferred to a routine that is called AFTER pre-fetch has been called for all infos.
; 434  : 	m_pkBuildingClassInfo = GC.getBuildingClassInfo(static_cast<BuildingClassTypes>(m_iBuildingClassType));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+260]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 435  : 	CvAssertMsg(m_pkBuildingClassInfo, "Could not find BuildingClassInfo for BuildingType. Have BuildingClasses been prefetched yet?");
; 436  : 
; 437  : 	szTextVal = kResults.GetText("ArtDefineTag");

	push	OFFSET ??_C@_0N@NLPPFOOH@ArtDefineTag?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 438  : 	SetArtDefineTag(szTextVal);

	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z ; CvBuildingEntry::SetArtDefineTag

; 439  : 
; 440  : 	szTextVal = kResults.GetText("WonderSplashAudio");

	push	OFFSET ??_C@_0BC@BAEHGPFA@WonderSplashAudio?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 441  : 	m_strWonderSplashAudio = szTextVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 780				; 0000030cH
	mov	DWORD PTR $T226901[ebp], eax
	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN49@CacheResul
	mov	ecx, DWORD PTR _szTextVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226901[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN50@CacheResul
$LN49@CacheResul:
	mov	ecx, DWORD PTR $T226901[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN50@CacheResul:

; 442  : 
; 443  : 	szTextVal = kResults.GetText("ThemingBonusHelp");

	push	OFFSET ??_C@_0BB@NLLCNLEE@ThemingBonusHelp?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 444  : 	m_strThemingBonusHelp = szTextVal;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 808				; 00000328H
	mov	DWORD PTR $T226907[ebp], edx
	cmp	DWORD PTR _szTextVal$[ebp], 0
	je	SHORT $LN53@CacheResul
	mov	eax, DWORD PTR _szTextVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226907[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN54@CacheResul
$LN53@CacheResul:
	mov	ecx, DWORD PTR $T226907[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN54@CacheResul:

; 445  : 
; 446  : 	szTextVal = kResults.GetText("NearbyTerrainRequired");

	push	OFFSET ??_C@_0BG@DNNKFMIB@NearbyTerrainRequired?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 447  : 	m_iNearbyTerrainRequired = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	ecx, DWORD PTR _szTextVal$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+268], eax

; 448  : 
; 449  : 	szTextVal = kResults.GetText("ProhibitedCityTerrain");

	push	OFFSET ??_C@_0BG@OCNBBLOA@ProhibitedCityTerrain?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 450  : 	m_iProhibitedCityTerrain = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	eax, DWORD PTR _szTextVal$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 451  : 
; 452  : 	szTextVal = kResults.GetText("VictoryPrereq");

	push	OFFSET ??_C@_0O@KJJJODBC@VictoryPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 453  : 	m_iVictoryPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 454  : 
; 455  : 	szTextVal = kResults.GetText("FreeStartEra");

	push	OFFSET ??_C@_0N@LADKBMLE@FreeStartEra?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 456  : 	m_iFreeStartEra = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], eax

; 457  : 
; 458  : 	szTextVal = kResults.GetText("MaxStartEra");

	push	OFFSET ??_C@_0M@NNMHACIA@MaxStartEra?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 459  : 	m_iMaxStartEra = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], eax

; 460  : 
; 461  : 	szTextVal = kResults.GetText("ObsoleteTech");

	push	OFFSET ??_C@_0N@KNKPCICJ@ObsoleteTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 462  : 	m_iObsoleteTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax

; 463  : 
; 464  : 	szTextVal = kResults.GetText("EnhancedYieldTech");

	push	OFFSET ??_C@_0BC@DFCBDFGG@EnhancedYieldTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 465  : 	m_iEnhancedYieldTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], eax

; 466  : 
; 467  : 	m_iTechEnhancedTourism = kResults.GetInt("TechEnhancedTourism");

	push	OFFSET ??_C@_0BE@LLHNLPLG@TechEnhancedTourism?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+296], eax

; 468  : 
; 469  : 	szTextVal = kResults.GetText("FreeBuilding");

	push	OFFSET ??_C@_0N@EHKBNAC@FreeBuilding?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 470  : 	m_iFreeBuildingClass = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	eax, DWORD PTR _szTextVal$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+348], eax

; 471  : 
; 472  : 	szTextVal = kResults.GetText("FreeBuildingThisCity");

	push	OFFSET ??_C@_0BF@FAEFDHBK@FreeBuildingThisCity?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 473  : 	m_iFreeBuildingThisCity = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+352], eax

; 474  : 
; 475  : 	szTextVal = kResults.GetText("FreePromotion");

	push	OFFSET ??_C@_0O@FDCFKJMG@FreePromotion?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 476  : 	m_iFreePromotion = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+356], eax

; 477  : 
; 478  : 	szTextVal = kResults.GetText("TrainedFreePromotion");

	push	OFFSET ??_C@_0BF@HBFHHGMI@TrainedFreePromotion?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 479  : 	m_iTrainedFreePromotion = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 480  : 
; 481  : 	szTextVal = kResults.GetText("FreePromotionRemoved");

	push	OFFSET ??_C@_0BF@CBBLNJGG@FreePromotionRemoved?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 482  : 	m_iFreePromotionRemoved = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+364], eax

; 483  : 
; 484  : 	szTextVal = kResults.GetText("ReplacementBuildingClass");

	push	OFFSET ??_C@_0BJ@JEAPEJLP@ReplacementBuildingClass?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 485  : 	m_iReplacementBuildingClass= GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], eax

; 486  : 
; 487  : 	szTextVal = kResults.GetText("PrereqTech");

	push	OFFSET ??_C@_0L@NJNFNDFO@PrereqTech?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 488  : 	m_iPrereqAndTech = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 489  : 
; 490  : 	szTextVal = kResults.GetText("PolicyBranchType");

	push	OFFSET ??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 491  : 	m_iPolicyBranchType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+316], eax

; 492  : 
; 493  : 	szTextVal = kResults.GetText("SpecialistType");

	push	OFFSET ??_C@_0P@KLBEOMLO@SpecialistType?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 494  : 	m_iSpecialistType = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], eax

; 495  : 	m_iSpecialistCount = kResults.GetInt("SpecialistCount");

	push	OFFSET ??_C@_0BA@KNNJHJEH@SpecialistCount?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], eax

; 496  : 	m_iSpecialistExtraCulture = kResults.GetInt("SpecialistExtraCulture");

	push	OFFSET ??_C@_0BH@CNHDGJOG@SpecialistExtraCulture?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 497  : 	m_iGreatPeopleRateChange= kResults.GetInt("GreatPeopleRateChange");

	push	OFFSET ??_C@_0BG@PEIPJGC@GreatPeopleRateChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+332], eax

; 498  : 
; 499  : 	szTextVal = kResults.GetText("GreatWorkSlotType");

	push	OFFSET ??_C@_0BC@CPKOPKBA@GreatWorkSlotType?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 500  : 	m_eGreatWorkSlotType = (GreatWorkSlotType)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	eax, DWORD PTR _szTextVal$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+336], eax

; 501  : 	m_iGreatWorkCount = kResults.GetInt("GreatWorkCount");

	push	OFFSET ??_C@_0P@OEIEFIFC@GreatWorkCount?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+340], eax

; 502  : 	szTextVal = kResults.GetText("FreeGreatWork");

	push	OFFSET ??_C@_0O@GDKFHJNN@FreeGreatWork?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 503  : 	m_eFreeGreatWork = (GreatWorkType)GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	eax, DWORD PTR _szTextVal$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 504  : 
; 505  : 	//Arrays
; 506  : 	const char* szBuildingType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szBuildingType$[ebp], eax

; 507  : 
; 508  : 	kUtility.SetFlavors(m_piFlavorValue, "Building_Flavors", "BuildingType", szBuildingType);

	push	0
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BB@EJAOEGAC@Building_Flavors?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 932				; 000003a4H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 509  : 
; 510  : 	kUtility.SetYields(m_piSeaPlotYieldChange, "Building_SeaPlotYieldChanges", "BuildingType", szBuildingType);

	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BN@BAOCADIP@Building_SeaPlotYieldChanges?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 864				; 00000360H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 511  : 	kUtility.SetYields(m_piRiverPlotYieldChange, "Building_RiverPlotYieldChanges", "BuildingType", szBuildingType);

	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BP@BNNDBJKD@Building_RiverPlotYieldChanges?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 868				; 00000364H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 512  : 	kUtility.SetYields(m_piLakePlotYieldChange, "Building_LakePlotYieldChanges", "BuildingType", szBuildingType);

	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BO@EMCADFDK@Building_LakePlotYieldChanges?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 872				; 00000368H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 513  : 	kUtility.SetYields(m_piSeaResourceYieldChange, "Building_SeaResourceYieldChanges", "BuildingType", szBuildingType);

	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0CB@PAPAGMOD@Building_SeaResourceYieldChanges@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 876				; 0000036cH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 514  : 	kUtility.SetYields(m_piYieldChange, "Building_YieldChanges", "BuildingType", szBuildingType);

	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BG@MDKFBHAG@Building_YieldChanges?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 515  : 	kUtility.SetYields(m_piYieldChangePerPop, "Building_YieldChangesPerPop", "BuildingType", szBuildingType);

	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BM@LCICFHBJ@Building_YieldChangesPerPop?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 884				; 00000374H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 516  : 	kUtility.SetYields(m_piYieldChangePerReligion, "Building_YieldChangesPerReligion", "BuildingType", szBuildingType);

	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0CB@OKBCIELK@Building_YieldChangesPerReligion@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 888				; 00000378H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 517  : 	kUtility.SetYields(m_piYieldModifier, "Building_YieldModifiers", "BuildingType", szBuildingType);

	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BI@KNPCMJI@Building_YieldModifiers?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 518  : 	kUtility.SetYields(m_piAreaYieldModifier, "Building_AreaYieldModifiers", "BuildingType", szBuildingType);

	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BM@IJNPCKEJ@Building_AreaYieldModifiers?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 896				; 00000380H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 519  : 	kUtility.SetYields(m_piGlobalYieldModifier, "Building_GlobalYieldModifiers", "BuildingType", szBuildingType);

	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BO@ICDPBNEO@Building_GlobalYieldModifiers?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 900				; 00000384H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 520  : 	kUtility.SetYields(m_piTechEnhancedYieldChange, "Building_TechEnhancedYieldChanges", "BuildingType", szBuildingType);

	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0CC@GLEKPBJF@Building_TechEnhancedYieldChange@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 904				; 00000388H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 521  : 
; 522  : 	kUtility.PopulateArrayByValue(m_piResourceQuantityRequirements, "Resources", "Building_ResourceQuantityRequirements", "ResourceType", "BuildingType", szBuildingType, "Cost");

	push	0
	push	0
	push	OFFSET ??_C@_04FICPKHNF@Cost?$AA@
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0CG@MMPBLPJH@Building_ResourceQuantityRequire@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 844				; 0000034cH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 523  : 	kUtility.PopulateArrayByValue(m_piResourceQuantity, "Resources", "Building_ResourceQuantity", "ResourceType", "BuildingType", szBuildingType, "Quantity");

	push	0
	push	0
	push	OFFSET ??_C@_08GACJPEFO@Quantity?$AA@
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0BK@EKPBEKIH@Building_ResourceQuantity?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 848				; 00000350H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 524  : 	kUtility.PopulateArrayByValue(m_piResourceCultureChanges, "Resources", "Building_ResourceCultureChanges", "ResourceType", "BuildingType", szBuildingType, "CultureChange");

	push	0
	push	0
	push	OFFSET ??_C@_0O@DKCHOOHE@CultureChange?$AA@
	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0CA@BPLMBBCM@Building_ResourceCultureChanges?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 852				; 00000354H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 525  : 	kUtility.PopulateArrayByValue(m_piResourceFaithChanges, "Resources", "Building_ResourceFaithChanges", "ResourceType", "BuildingType", szBuildingType, "FaithChange");

	push	0
	push	0
	push	OFFSET ??_C@_0M@PCGABKEM@FaithChange?$AA@
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0BO@HNEMOEFM@Building_ResourceFaithChanges?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 856				; 00000358H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 526  : 
; 527  : 	kUtility.PopulateArrayByValue(m_paiHurryModifier, "HurryInfos", "Building_HurryModifiers", "HurryType", "BuildingType", szBuildingType, "HurryCostModifier");

	push	0
	push	0
	push	OFFSET ??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_09FFMCMAO@HurryType?$AA@
	push	OFFSET ??_C@_0BI@PCDONCNC@Building_HurryModifiers?$AA@
	push	OFFSET ??_C@_0L@PGMCIMFM@HurryInfos?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 944				; 000003b0H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 528  : 
; 529  : 	//kUtility.PopulateArrayByValue(m_piProductionTraits, "Traits", "Building_ProductionTraits", "TraitType", "BuildingType", szBuildingType, "Trait");
; 530  : 
; 531  : 	kUtility.PopulateArrayByValue(m_piUnitCombatFreeExperience, "UnitCombatInfos", "Building_UnitCombatFreeExperiences", "UnitCombatType", "BuildingType", szBuildingType, "Experience");

	push	0
	push	0
	push	OFFSET ??_C@_0L@DCGNFONO@Experience?$AA@
	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0P@GFHIODK@UnitCombatType?$AA@
	push	OFFSET ??_C@_0CD@MKMIPBLA@Building_UnitCombatFreeExperienc@
	push	OFFSET ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 908				; 0000038cH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 532  : 	kUtility.PopulateArrayByValue(m_piUnitCombatProductionModifiers, "UnitCombatInfos", "Building_UnitCombatProductionModifiers", "UnitCombatType", "BuildingType", szBuildingType, "Modifier");

	push	0
	push	0
	push	OFFSET ??_C@_08GMKLKDKJ@Modifier?$AA@
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0P@GFHIODK@UnitCombatType?$AA@
	push	OFFSET ??_C@_0CH@GNAGIJKO@Building_UnitCombatProductionMod@
	push	OFFSET ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 912				; 00000390H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 533  : 	kUtility.PopulateArrayByValue(m_piDomainFreeExperience, "Domains", "Building_DomainFreeExperiences", "DomainType", "BuildingType", szBuildingType, "Experience", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET ??_C@_0L@DCGNFONO@Experience?$AA@
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0L@NIGHKLOG@DomainType?$AA@
	push	OFFSET ??_C@_0BP@DEFLAPCG@Building_DomainFreeExperiences?$AA@
	push	OFFSET ??_C@_07FKLJOGGC@Domains?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 916				; 00000394H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 534  : 	kUtility.PopulateArrayByValue(m_piDomainFreeExperiencePerGreatWork, "Domains", "Building_DomainFreeExperiencePerGreatWork", "DomainType", "BuildingType", szBuildingType, "Experience", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET ??_C@_0L@DCGNFONO@Experience?$AA@
	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0L@NIGHKLOG@DomainType?$AA@
	push	OFFSET ??_C@_0CK@MJOJOACL@Building_DomainFreeExperiencePer@
	push	OFFSET ??_C@_07FKLJOGGC@Domains?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 535  : 	kUtility.PopulateArrayByValue(m_piDomainProductionModifier, "Domains", "Building_DomainProductionModifiers", "DomainType", "BuildingType", szBuildingType, "Modifier", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET ??_C@_08GMKLKDKJ@Modifier?$AA@
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0L@NIGHKLOG@DomainType?$AA@
	push	OFFSET ??_C@_0CD@EKBOGPMO@Building_DomainProductionModifie@
	push	OFFSET ??_C@_07FKLJOGGC@Domains?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 924				; 0000039cH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 536  : 
; 537  : 	kUtility.PopulateArrayByValue(m_piPrereqNumOfBuildingClass, "BuildingClasses", "Building_PrereqBuildingClasses", "BuildingClassType", "BuildingType", szBuildingType, "NumBuildingNeeded");

	push	0
	push	0
	push	OFFSET ??_C@_0BC@FGLMMPNJ@NumBuildingNeeded?$AA@
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0BP@JDFHAFIM@Building_PrereqBuildingClasses?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 928				; 000003a0H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 538  : 	kUtility.PopulateArrayByExistence(m_pbBuildingClassNeededInCity, "BuildingClasses", "Building_ClassesNeededInCity", "BuildingClassType", "BuildingType", szBuildingType);

	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0BN@KECJDNDG@Building_ClassesNeededInCity?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 948				; 000003b4H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 539  : 	//kUtility.PopulateArrayByExistence(m_piNumFreeUnits, "Units", "Building_FreeUnits", "UnitType", "BuildingType", szBuildingType);
; 540  : 	kUtility.PopulateArrayByValue(m_piNumFreeUnits, "Units", "Building_FreeUnits", "UnitType", "BuildingType", szBuildingType, "NumUnits");

	push	0
	push	0
	push	OFFSET ??_C@_08GKPCIDEN@NumUnits?$AA@
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_08PNBAGKKP@UnitType?$AA@
	push	OFFSET ??_C@_0BD@HDEINNGJ@Building_FreeUnits?$AA@
	push	OFFSET ??_C@_05CFLIFMAE@Units?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 952				; 000003b8H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 541  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassHappiness, "BuildingClasses", "Building_BuildingClassHappiness", "BuildingClassType", "BuildingType", szBuildingType, "Happiness");

	push	0
	push	0
	push	OFFSET ??_C@_09MNJMGIDC@Happiness?$AA@
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0CA@CANCEICJ@Building_BuildingClassHappiness?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1000				; 000003e8H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 542  : 
; 543  : 	kUtility.PopulateArrayByExistence(m_piLockedBuildingClasses, "BuildingClasses", "Building_LockedBuildingClasses", "BuildingClassType", "BuildingType", szBuildingType);

	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0BP@JGKKCIIB@Building_LockedBuildingClasses?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 836				; 00000344H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 544  : 	kUtility.PopulateArrayByExistence(m_piPrereqAndTechs, "Technologies", "Building_TechAndPrereqs", "TechType", "BuildingType", szBuildingType);

	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_08GHGFPPBE@TechType?$AA@
	push	OFFSET ??_C@_0BI@FJIPNBFH@Building_TechAndPrereqs?$AA@
	push	OFFSET ??_C@_0N@INKDAICK@Technologies?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 840				; 00000348H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 545  : 	kUtility.PopulateArrayByExistence(m_piLocalResourceAnds, "Resources", "Building_LocalResourceAnds", "ResourceType", "BuildingType", szBuildingType);

	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0BL@FMCOIOMO@Building_LocalResourceAnds?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 936				; 000003a8H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 546  : 	kUtility.PopulateArrayByExistence(m_piLocalResourceOrs, "Resources", "Building_LocalResourceOrs", "ResourceType", "BuildingType", szBuildingType);

	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@OGHNDFPH@BuildingType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0BK@KEIIEDIM@Building_LocalResourceOrs?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 940				; 000003acH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPAHPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 547  : 
; 548  : 	//ResourceYieldChanges
; 549  : 	{
; 550  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 551  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldChange.first, "Resources", "Yields");
; 552  : 		m_ppaiResourceYieldChange.second = kUtility.MaxRows("Resources");
; 553  : #else
; 554  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldChange, "Resources", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 956				; 000003bcH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 555  : #endif
; 556  : 
; 557  : 		std::string strKey("Building_ResourceYieldChanges");

	push	OFFSET ??_C@_0BO@DAGAEBIC@Building_ResourceYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$217913[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 558  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$217913[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$217915[ebp], eax

; 559  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$217915[ebp], 0
	jne	SHORT $LN30@CacheResul

; 560  : 		{
; 561  : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, Yields.ID as YieldID, Yield from Building_ResourceYieldChanges inner join Resources on Resources.Type = ResourceType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0NM@BGEPCKDK@select?5Resources?4ID?5as?5ResourceI@
	lea	ecx, DWORD PTR _strKey$217913[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$217915[ebp], eax
$LN30@CacheResul:

; 562  : 		}
; 563  : 
; 564  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$217915[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN29@CacheResul:

; 565  : 
; 566  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$217915[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@CacheResul

; 567  : 		{
; 568  : 			const int ResourceID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$217915[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _ResourceID$217921[ebp], eax

; 569  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$217915[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$217922[ebp], eax

; 570  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$217915[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$217923[ebp], eax

; 571  : 
; 572  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 573  : 			m_ppaiResourceYieldChange.first[ResourceID][YieldID] = yield;
; 574  : #else
; 575  : 			m_ppaiResourceYieldChange[ResourceID][YieldID] = yield;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	eax, DWORD PTR _ResourceID$217921[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _YieldID$217922[ebp]
	mov	eax, DWORD PTR _yield$217923[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 576  : #endif
; 577  : 		}

	jmp	SHORT $LN29@CacheResul
$LN28@CacheResul:

; 578  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$217913[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 579  : 	//Building_ResourceYieldChangesGlobal
; 580  : 	{
; 581  : 		std::string strKey("Building_ResourceYieldChangesGlobal");

	push	OFFSET ??_C@_0CE@NNCMAIMH@Building_ResourceYieldChangesGlo@
	lea	ecx, DWORD PTR _strKey$217924[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 582  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$217924[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$217926[ebp], eax

; 583  : 		if (pResults == NULL)

	cmp	DWORD PTR _pResults$217926[ebp], 0
	jne	SHORT $LN27@CacheResul

; 584  : 		{
; 585  : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, Yields.ID as YieldID, Yield from Building_ResourceYieldChangesGlobal inner join Resources on Resources.Type = ResourceType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0OC@IPOJEDJL@select?5Resources?4ID?5as?5ResourceI@
	lea	edx, DWORD PTR _strKey$217924[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$217926[ebp], eax
$LN27@CacheResul:

; 586  : 		}
; 587  : 
; 588  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$217926[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN26@CacheResul:

; 589  : 
; 590  : 		while (pResults->Step())

	mov	ecx, DWORD PTR _pResults$217926[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@CacheResul

; 591  : 		{
; 592  : 			const int iResource = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$217926[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iResource$217932[ebp], eax

; 593  : 			const int iYieldType = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$217926[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYieldType$217933[ebp], eax

; 594  : 			const int iYield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$217926[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYield$217934[ebp], eax

; 595  : 
; 596  : 			m_ppiResourceYieldChangeGlobal[iResource][iYieldType] += iYield;

	lea	edx, DWORD PTR _iYieldType$217933[ebp]
	push	edx
	lea	eax, DWORD PTR _iResource$217932[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	call	??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[]
	mov	ecx, eax
	call	??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
	mov	DWORD PTR tv1322[ebp], eax
	mov	ecx, DWORD PTR tv1322[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _iYield$217934[ebp]
	mov	eax, DWORD PTR tv1322[ebp]
	mov	DWORD PTR [eax], edx

; 597  : 		}

	jmp	SHORT $LN26@CacheResul
$LN25@CacheResul:

; 598  : 
; 599  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$217926[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 600  : 
; 601  : 		//Trim extra memory off container since this is mostly read-only.
; 602  : 		std::map<int, std::map<int, int>>(m_ppiResourceYieldChangeGlobal).swap(m_ppiResourceYieldChangeGlobal);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	push	ecx
	lea	ecx, DWORD PTR $T226879[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
	lea	edx, DWORD PTR $T226879[ebp]
	mov	DWORD PTR tv1781[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 964				; 000003c4H
	push	eax
	mov	ecx, DWORD PTR tv1781[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T226879[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 603  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$217924[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 604  : 
; 605  : 	//FeatureYieldChanges
; 606  : 	{
; 607  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 608  : 		kUtility.Initialize2DArray(m_ppaiFeatureYieldChange.first, "Features", "Yields");
; 609  : 		m_ppaiFeatureYieldChange.second = kUtility.MaxRows("Features");
; 610  : #else
; 611  : 		kUtility.Initialize2DArray(m_ppaiFeatureYieldChange, "Features", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_08CLANBDND@Features?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 612  : #endif
; 613  : 
; 614  : 		std::string strKey("Building_FeatureYieldChanges");

	push	OFFSET ??_C@_0BN@POIIGNJJ@Building_FeatureYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$218447[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 615  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218447[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218449[ebp], eax

; 616  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$218449[ebp], 0
	jne	SHORT $LN24@CacheResul

; 617  : 		{
; 618  : 			pResults = kUtility.PrepareResults(strKey, "select Features.ID as FeatureID, Yields.ID as YieldID, Yield from Building_FeatureYieldChanges inner join Features on Features.Type = FeatureType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0NG@GFABIFCI@select?5Features?4ID?5as?5FeatureID?0@
	lea	eax, DWORD PTR _strKey$218447[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218449[ebp], eax
$LN24@CacheResul:

; 619  : 		}
; 620  : 
; 621  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$218449[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN23@CacheResul:

; 622  : 
; 623  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218449[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@CacheResul

; 624  : 		{
; 625  : 			const int FeatureID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$218449[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _FeatureID$218455[ebp], eax

; 626  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$218449[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$218456[ebp], eax

; 627  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$218449[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$218457[ebp], eax

; 628  : 
; 629  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 630  : 			m_ppaiFeatureYieldChange.first[FeatureID][YieldID] = yield;
; 631  : #else
; 632  : 			m_ppaiFeatureYieldChange[FeatureID][YieldID] = yield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+960]
	mov	edx, DWORD PTR _FeatureID$218455[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _YieldID$218456[ebp]
	mov	edx, DWORD PTR _yield$218457[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 633  : #endif
; 634  : 		}

	jmp	SHORT $LN23@CacheResul
$LN22@CacheResul:

; 635  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$218447[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 636  : 	//ImprovementYieldChanges
; 637  : 	{
; 638  : 		kUtility.Initialize2DArray(m_ppaiImprovementYieldChange, "Improvements", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0N@CJDAHDJO@Improvements?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 976				; 000003d0H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 639  : 
; 640  : 		std::string strKey("Building_ImprovementYieldChanges");

	push	OFFSET ??_C@_0CB@DLDFPMAF@Building_ImprovementYieldChanges@
	lea	ecx, DWORD PTR _strKey$218459[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 641  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$218459[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218461[ebp], eax

; 642  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$218461[ebp], 0
	jne	SHORT $LN21@CacheResul

; 643  : 		{
; 644  : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Building_ImprovementYieldChanges inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0OO@PKOLDNPO@select?5Improvements?4ID?5as?5Improv@
	lea	edx, DWORD PTR _strKey$218459[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218461[ebp], eax
$LN21@CacheResul:

; 645  : 		}
; 646  : 
; 647  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$218461[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN20@CacheResul:

; 648  : 
; 649  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218461[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@CacheResul

; 650  : 		{
; 651  : 			const int ImprovementID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$218461[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _ImprovementID$218467[ebp], eax

; 652  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$218461[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$218468[ebp], eax

; 653  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$218461[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$218469[ebp], eax

; 654  : 
; 655  : 			m_ppaiImprovementYieldChange[ImprovementID][YieldID] = yield;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+976]
	mov	ecx, DWORD PTR _ImprovementID$218467[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _YieldID$218468[ebp]
	mov	ecx, DWORD PTR _yield$218469[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 656  : 		}

	jmp	SHORT $LN20@CacheResul
$LN19@CacheResul:

; 657  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$218459[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 658  : 	//ImprovementYieldChangesGlobal
; 659  : 	{
; 660  : 		kUtility.Initialize2DArray(m_ppaiImprovementYieldChangeGlobal, "Improvements", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0N@CJDAHDJO@Improvements?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 980				; 000003d4H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 661  : 
; 662  : 		std::string strKey("Building_ImprovementYieldChangesGlobal");

	push	OFFSET ??_C@_0CH@MGEIPAHD@Building_ImprovementYieldChanges@
	lea	ecx, DWORD PTR _strKey$218470[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 663  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218470[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218472[ebp], eax

; 664  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$218472[ebp], 0
	jne	SHORT $LN18@CacheResul

; 665  : 		{
; 666  : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Building_ImprovementYieldChangesGlobal inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0PE@OFIKBFJL@select?5Improvements?4ID?5as?5Improv@
	lea	ecx, DWORD PTR _strKey$218470[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218472[ebp], eax
$LN18@CacheResul:

; 667  : 		}
; 668  : 
; 669  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$218472[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN17@CacheResul:

; 670  : 
; 671  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218472[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@CacheResul

; 672  : 		{
; 673  : 			const int ImprovementID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$218472[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _ImprovementID$218478[ebp], eax

; 674  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$218472[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$218479[ebp], eax

; 675  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$218472[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$218480[ebp], eax

; 676  : 
; 677  : 			m_ppaiImprovementYieldChangeGlobal[ImprovementID][YieldID] = yield;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+980]
	mov	eax, DWORD PTR _ImprovementID$218478[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _YieldID$218479[ebp]
	mov	eax, DWORD PTR _yield$218480[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 678  : 		}

	jmp	SHORT $LN17@CacheResul
$LN16@CacheResul:

; 679  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$218470[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 680  : 
; 681  : 	//TerrainYieldChanges
; 682  : 	{
; 683  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 684  : 		kUtility.Initialize2DArray(m_ppaiTerrainYieldChange.first, "Terrains", "Yields");
; 685  : 		m_ppaiTerrainYieldChange.second = kUtility.MaxRows("Terrains");
; 686  : #else
; 687  : 		kUtility.Initialize2DArray(m_ppaiTerrainYieldChange, "Terrains", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_08DHHJBCFH@Terrains?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 992				; 000003e0H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 688  : #endif
; 689  : 
; 690  : 		std::string strKey("Building_TerrainYieldChanges");

	push	OFFSET ??_C@_0BN@FACJPGAH@Building_TerrainYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$218482[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 691  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218482[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218484[ebp], eax

; 692  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$218484[ebp], 0
	jne	SHORT $LN15@CacheResul

; 693  : 		{
; 694  : 			pResults = kUtility.PrepareResults(strKey, "select Terrains.ID as TerrainID, Yields.ID as YieldID, Yield from Building_TerrainYieldChanges inner join Terrains on Terrains.Type = TerrainType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0NG@LEMPHPMP@select?5Terrains?4ID?5as?5TerrainID?0@
	lea	eax, DWORD PTR _strKey$218482[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218484[ebp], eax
$LN15@CacheResul:

; 695  : 		}
; 696  : 
; 697  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$218484[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN14@CacheResul:

; 698  : 
; 699  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218484[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@CacheResul

; 700  : 		{
; 701  : 			const int TerrainID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$218484[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _TerrainID$218490[ebp], eax

; 702  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$218484[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$218491[ebp], eax

; 703  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$218484[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$218492[ebp], eax

; 704  : 
; 705  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 706  : 			m_ppaiTerrainYieldChange.first[TerrainID][YieldID] = yield;
; 707  : #else
; 708  : 			m_ppaiTerrainYieldChange[TerrainID][YieldID] = yield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+992]
	mov	edx, DWORD PTR _TerrainID$218490[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _YieldID$218491[ebp]
	mov	edx, DWORD PTR _yield$218492[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 709  : #endif
; 710  : 		}

	jmp	SHORT $LN14@CacheResul
$LN13@CacheResul:

; 711  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$218482[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 712  : 
; 713  : 	//SpecialistYieldChanges
; 714  : 	{
; 715  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 716  : 		kUtility.Initialize2DArray(m_ppaiSpecialistYieldChange.first, "Specialists", "Yields");
; 717  : 		m_ppaiSpecialistYieldChange.second = kUtility.MaxRows("Specialists");
; 718  : #else
; 719  : 		kUtility.Initialize2DArray(m_ppaiSpecialistYieldChange, "Specialists", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0M@EENMFCNN@Specialists?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 984				; 000003d8H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 720  : #endif
; 721  : 
; 722  : 		std::string strKey("Building_SpecialistYieldChanges");

	push	OFFSET ??_C@_0CA@HPDLFOI@Building_SpecialistYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$218494[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 8

; 723  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$218494[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218496[ebp], eax

; 724  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$218496[ebp], 0
	jne	SHORT $LN12@CacheResul

; 725  : 		{
; 726  : 			pResults = kUtility.PrepareResults(strKey, "select Specialists.ID as SpecialistID, Yields.ID as YieldID, Yield from Building_SpecialistYieldChanges inner join Specialists on Specialists.Type = SpecialistType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0OI@LJOIPFFC@select?5Specialists?4ID?5as?5Special@
	lea	edx, DWORD PTR _strKey$218494[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218496[ebp], eax
$LN12@CacheResul:

; 727  : 		}
; 728  : 
; 729  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$218496[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN11@CacheResul:

; 730  : 
; 731  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218496[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@CacheResul

; 732  : 		{
; 733  : 			const int SpecialistID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$218496[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _SpecialistID$218502[ebp], eax

; 734  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$218496[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$218503[ebp], eax

; 735  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$218496[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$218504[ebp], eax

; 736  : 
; 737  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 738  : 			m_ppaiSpecialistYieldChange.first[SpecialistID][YieldID] = yield;
; 739  : #else
; 740  : 			m_ppaiSpecialistYieldChange[SpecialistID][YieldID] = yield;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+984]
	mov	ecx, DWORD PTR _SpecialistID$218502[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _YieldID$218503[ebp]
	mov	ecx, DWORD PTR _yield$218504[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 741  : #endif
; 742  : 		}

	jmp	SHORT $LN11@CacheResul
$LN10@CacheResul:

; 743  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$218494[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 744  : 
; 745  : 	//ResourceYieldModifiers
; 746  : 	{
; 747  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 748  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldModifier.first, "Resources", "Yields");
; 749  : 		m_ppaiResourceYieldModifier.second = kUtility.MaxRows("Resources");
; 750  : #else
; 751  : 		kUtility.Initialize2DArray(m_ppaiResourceYieldModifier, "Resources", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 988				; 000003dcH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 752  : #endif
; 753  : 
; 754  : 		std::string strKey("Building_ResourceYieldModifiers");

	push	OFFSET ??_C@_0CA@NHDIHGND@Building_ResourceYieldModifiers?$AA@
	lea	ecx, DWORD PTR _strKey$218505[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 9

; 755  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$218505[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218507[ebp], eax

; 756  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$218507[ebp], 0
	jne	SHORT $LN9@CacheResul

; 757  : 		{
; 758  : 			pResults = kUtility.PrepareResults(strKey, "select Resources.ID as ResourceID, Yields.ID as YieldID, Yield from Building_ResourceYieldModifiers inner join Resources on Resources.Type = ResourceType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0NO@HBICDKAJ@select?5Resources?4ID?5as?5ResourceI@
	lea	ecx, DWORD PTR _strKey$218505[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218507[ebp], eax
$LN9@CacheResul:

; 759  : 		}
; 760  : 
; 761  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	edx, DWORD PTR _szBuildingType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$218507[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN8@CacheResul:

; 762  : 
; 763  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218507[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@CacheResul

; 764  : 		{
; 765  : 			const int ResourceID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$218507[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _ResourceID$218513[ebp], eax

; 766  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$218507[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$218514[ebp], eax

; 767  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$218507[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$218515[ebp], eax

; 768  : 
; 769  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 770  : 			m_ppaiResourceYieldModifier.first[ResourceID][YieldID] = yield;
; 771  : #else
; 772  : 			m_ppaiResourceYieldModifier[ResourceID][YieldID] = yield;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+988]
	mov	eax, DWORD PTR _ResourceID$218513[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _YieldID$218514[ebp]
	mov	eax, DWORD PTR _yield$218515[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 773  : #endif
; 774  : 		}

	jmp	SHORT $LN8@CacheResul
$LN7@CacheResul:

; 775  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$218505[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 
; 777  : 	//BuildingClassYieldChanges
; 778  : 	{
; 779  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 780  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges.first, "BuildingClasses", "Yields");
; 781  : 		m_ppiBuildingClassYieldChanges.second = kUtility.MaxRows("BuildingClasses");
; 782  : #else
; 783  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges, "BuildingClasses", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 996				; 000003e4H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 784  : #endif
; 785  : 
; 786  : 		std::string strKey("Building_BuildingClassYieldChanges");

	push	OFFSET ??_C@_0CD@CCDFOGAD@Building_BuildingClassYieldChang@
	lea	ecx, DWORD PTR _strKey$218516[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 787  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$218516[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$218518[ebp], eax

; 788  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$218518[ebp], 0
	jne	SHORT $LN6@CacheResul

; 789  : 		{
; 790  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldChange from Building_BuildingClassYieldChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Yields on Yields.Type = YieldType where BuildingType = ?");

	push	OFFSET ??_C@_0BAD@LLOHFPOB@select?5BuildingClasses?4ID?5as?5Bui@
	lea	eax, DWORD PTR _strKey$218516[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$218518[ebp], eax
$LN6@CacheResul:

; 791  : 		}
; 792  : 
; 793  : 		pResults->Bind(1, szBuildingType);

	push	1
	mov	ecx, DWORD PTR _szBuildingType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$218518[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN5@CacheResul:

; 794  : 
; 795  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$218518[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@CacheResul

; 796  : 		{
; 797  : 			const int BuildingClassID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$218518[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _BuildingClassID$218524[ebp], eax

; 798  : 			const int iYieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$218518[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYieldID$218525[ebp], eax

; 799  : 			const int iYieldChange = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$218518[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYieldChange$218526[ebp], eax

; 800  : 
; 801  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 802  : 			m_ppiBuildingClassYieldChanges.first[BuildingClassID][iYieldID] = iYieldChange;
; 803  : #else
; 804  : 			m_ppiBuildingClassYieldChanges[BuildingClassID][iYieldID] = iYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+996]
	mov	edx, DWORD PTR _BuildingClassID$218524[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _iYieldID$218525[ebp]
	mov	edx, DWORD PTR _iYieldChange$218526[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 805  : #endif
; 806  : 		}

	jmp	SHORT $LN5@CacheResul
$LN4@CacheResul:

; 807  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$218516[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 808  : 
; 809  : 	{
; 810  : 		//Initialize Theming Bonuses
; 811  : 		const int iNumThemes = MAX_THEMING_BONUSES; /* 12 */

	mov	DWORD PTR _iNumThemes$218527[ebp], 12	; 0000000cH

; 812  : 		m_paThemingBonusInfo = FNEW(CvThemingBonusInfo[iNumThemes], c_eCiv5GameplayDLL, 0);

	push	580					; 00000244H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226881[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	cmp	DWORD PTR $T226881[ebp], 0
	je	SHORT $LN34@CacheResul
	mov	eax, DWORD PTR $T226881[ebp]
	mov	DWORD PTR [eax], 12			; 0000000cH
	push	OFFSET ??1CvThemingBonusInfo@@QAE@XZ
	push	OFFSET ??0CvThemingBonusInfo@@QAE@XZ	; CvThemingBonusInfo::CvThemingBonusInfo
	push	12					; 0000000cH
	push	48					; 00000030H
	mov	ecx, DWORD PTR $T226881[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T226881[ebp]
	add	edx, 4
	mov	DWORD PTR tv1667[ebp], edx
	jmp	SHORT $LN35@CacheResul
$LN34@CacheResul:
	mov	DWORD PTR tv1667[ebp], 0
$LN35@CacheResul:
	mov	eax, DWORD PTR tv1667[ebp]
	mov	DWORD PTR $T226880[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T226880[ebp]
	mov	DWORD PTR [ecx+1004], edx

; 813  : 		int idx = 0;

	mov	DWORD PTR _idx$218534[ebp], 0

; 814  : 
; 815  : 		std::string strResourceTypesKey = "Building_ThemingBonuses";

	push	OFFSET ??_C@_0BI@FNMMLPPC@Building_ThemingBonuses?$AA@
	lea	ecx, DWORD PTR _strResourceTypesKey$218535[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH

; 816  : 		Database::Results* pResourceTypes = kUtility.GetResults(strResourceTypesKey);

	lea	eax, DWORD PTR _strResourceTypesKey$218535[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResourceTypes$218537[ebp], eax

; 817  : 		if(pResourceTypes == NULL)

	cmp	DWORD PTR _pResourceTypes$218537[ebp], 0
	jne	SHORT $LN3@CacheResul

; 818  : 		{
; 819  : 			pResourceTypes = kUtility.PrepareResults(strResourceTypesKey, "select Bonus, Description, SameEra, UniqueEras, MustBeArt, MustBeArtifact, MustBeEqualArtArtifact, RequiresOwner, RequiresAnyButOwner, RequiresSamePlayer, RequiresUniquePlayers, AIPriority from Building_ThemingBonuses where BuildingType = ?");

	push	OFFSET ??_C@_0PB@BKIKAOJ@select?5Bonus?0?5Description?0?5SameE@
	lea	ecx, DWORD PTR _strResourceTypesKey$218535[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResourceTypes$218537[ebp], eax
$LN3@CacheResul:

; 820  : 		}
; 821  : 
; 822  : 		const size_t lenBuildingType = strlen(szBuildingType);

	mov	edx, DWORD PTR _szBuildingType$[ebp]
	mov	DWORD PTR tv2820[ebp], edx
	mov	eax, DWORD PTR tv2820[ebp]
	add	eax, 1
	mov	DWORD PTR tv2823[ebp], eax
$LL333@CacheResul:
	mov	ecx, DWORD PTR tv2820[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv2826[ebp], dl
	add	DWORD PTR tv2820[ebp], 1
	cmp	BYTE PTR tv2826[ebp], 0
	jne	SHORT $LL333@CacheResul
	mov	eax, DWORD PTR tv2820[ebp]
	sub	eax, DWORD PTR tv2823[ebp]
	mov	DWORD PTR tv1681[ebp], eax
	mov	ecx, DWORD PTR tv1681[ebp]
	mov	DWORD PTR _lenBuildingType$218540[ebp], ecx

; 823  : 		pResourceTypes->Bind(1, szBuildingType, lenBuildingType, false);

	push	0
	mov	edx, DWORD PTR _lenBuildingType$218540[ebp]
	push	edx
	mov	eax, DWORD PTR _szBuildingType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z
$LN2@CacheResul:

; 824  : 
; 825  : 		while(pResourceTypes->Step())

	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@CacheResul

; 826  : 		{
; 827  : 			CvThemingBonusInfo& pThemingInfo = m_paThemingBonusInfo[idx];

	mov	edx, DWORD PTR _idx$218534[ebp]
	imul	edx, 48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+1004]
	mov	DWORD PTR _pThemingInfo$218544[ebp], edx

; 828  : 
; 829  : 			pThemingInfo.m_iBonus = pResourceTypes->GetInt("Bonus");

	push	OFFSET ??_C@_05JKBOBFBJ@Bonus?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	DWORD PTR [ecx], eax

; 830  : 			pThemingInfo.m_strDescription = pResourceTypes->GetText("Description");

	push	OFFSET ??_C@_0M@OHKMKKDH@Description?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR $T227621[ebp], eax
	mov	edx, DWORD PTR _pThemingInfo$218544[ebp]
	add	edx, 4
	mov	DWORD PTR $T227620[ebp], edx
	cmp	DWORD PTR $T227621[ebp], 0
	je	SHORT $LN330@CacheResul
	mov	eax, DWORD PTR $T227621[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227620[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN331@CacheResul
$LN330@CacheResul:
	mov	ecx, DWORD PTR $T227620[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN331@CacheResul:

; 831  : 			pThemingInfo.m_bSameEra = pResourceTypes->GetBool("SameEra");

	push	OFFSET ??_C@_07OFEDJIM@SameEra?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [ecx+32], al

; 832  : 			pThemingInfo.m_bUniqueEras = pResourceTypes->GetBool("UniqueEras");

	push	OFFSET ??_C@_0L@DIMOPICO@UniqueEras?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [edx+33], al

; 833  : 			pThemingInfo.m_bMustBeArt = pResourceTypes->GetBool("MustBeArt");

	push	OFFSET ??_C@_09NLDBJDIG@MustBeArt?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [ecx+34], al

; 834  : 			pThemingInfo.m_bMustBeArtifact = pResourceTypes->GetBool("MustBeArtifact");

	push	OFFSET ??_C@_0P@GNOHBNJJ@MustBeArtifact?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [edx+35], al

; 835  : 			pThemingInfo.m_bMustBeEqualArtArtifact = pResourceTypes->GetBool("MustBeEqualArtArtifact");

	push	OFFSET ??_C@_0BH@EFDLMKCH@MustBeEqualArtArtifact?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [ecx+36], al

; 836  : 			pThemingInfo.m_bRequiresOwner = pResourceTypes->GetBool("RequiresOwner");

	push	OFFSET ??_C@_0O@EAFLGFAG@RequiresOwner?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [edx+37], al

; 837  : 			pThemingInfo.m_bRequiresAnyButOwner = pResourceTypes->GetBool("RequiresAnyButOwner");

	push	OFFSET ??_C@_0BE@NLIHKJCA@RequiresAnyButOwner?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [ecx+38], al

; 838  : 			pThemingInfo.m_bRequiresSamePlayer = pResourceTypes->GetBool("RequiresSamePlayer");

	push	OFFSET ??_C@_0BD@GCJNKDGD@RequiresSamePlayer?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [edx+39], al

; 839  : 			pThemingInfo.m_bRequiresUniquePlayers = pResourceTypes->GetBool("RequiresUniquePlayers");

	push	OFFSET ??_C@_0BG@EJBGBLAF@RequiresUniquePlayers?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	BYTE PTR [ecx+40], al

; 840  : 			pThemingInfo.m_iAIPriority = pResourceTypes->GetInt("AIPriority");

	push	OFFSET ??_C@_0L@PCIDMOGB@AIPriority?$AA@
	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _pThemingInfo$218544[ebp]
	mov	DWORD PTR [edx+44], eax

; 841  : 
; 842  : 			idx++;

	mov	eax, DWORD PTR _idx$218534[ebp]
	add	eax, 1
	mov	DWORD PTR _idx$218534[ebp], eax

; 843  : 		}

	jmp	$LN2@CacheResul
$LN1@CacheResul:

; 844  : 
; 845  : 		m_iNumThemingBonuses = idx;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _idx$218534[ebp]
	mov	DWORD PTR [ecx+1008], edx

; 846  : 		pResourceTypes->Reset();

	mov	ecx, DWORD PTR _pResourceTypes$218537[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 847  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strResourceTypesKey$218535[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 848  : 
; 849  : 	return true;

	mov	al, 1
$LN32@CacheResul:

; 850  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$217913[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$217924[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR $T226879[ebp]
	jmp	??1?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$37:
	lea	ecx, DWORD PTR $T226879[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$218447[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _strKey$218459[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _strKey$218470[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _strKey$218482[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7:
	lea	ecx, DWORD PTR _strKey$218494[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8:
	lea	ecx, DWORD PTR _strKey$218505[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$9:
	lea	ecx, DWORD PTR _strKey$218516[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$10:
	mov	eax, DWORD PTR $T226881[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__unwindfunclet$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$11:
	lea	ecx, DWORD PTR _strResourceTypesKey$218535[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-780]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvBuildingEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvBuildingEntry::CacheResults
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_ECvThemingBonusInfo@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227637 = -4						; size = 4
___flags$ = 8						; size = 4
??_ECvThemingBonusInfo@@QAEPAXI@Z PROC			; CvThemingBonusInfo::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN6@vector
	push	OFFSET ??1CvThemingBonusInfo@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN6@vector:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T227637[ebp], eax
	mov	ecx, DWORD PTR $T227637[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@vector
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECvThemingBonusInfo@@QAEPAXI@Z ENDP			; CvThemingBonusInfo::`vector deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvThemingBonusInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227649 = -4						; size = 4
??1CvThemingBonusInfo@@QAE@XZ PROC			; CvThemingBonusInfo::~CvThemingBonusInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T227649[ebp], eax
	mov	ecx, DWORD PTR $T227649[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvThemingBonusInfo@@QAE@XZ ENDP			; CvThemingBonusInfo::~CvThemingBonusInfo
_TEXT	ENDS
PUBLIC	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetBuildingClassType
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassType@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingClassType@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetBuildingClassType, COMDAT
; _this$ = ecx

; 854  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 855  : 	return m_iBuildingClassType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+260]

; 856  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetBuildingClassType
_TEXT	ENDS
PUBLIC	??_C@_0DM@JOEMEGPJ@ERROR?3?5Building?5does?5not?5contain@ ; `string'
PUBLIC	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
;	COMDAT ??_C@_0DM@JOEMEGPJ@ERROR?3?5Building?5does?5not?5contain@
CONST	SEGMENT
??_C@_0DM@JOEMEGPJ@ERROR?3?5Building?5does?5not?5contain@ DB 'ERROR: Buil'
	DB	'ding does not contain valid BuildingClass type!!', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_szError$218576 = -4					; size = 4
?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ PROC ; CvBuildingEntry::GetBuildingClassInfo, COMDAT
; _this$ = ecx

; 859  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 860  : 	if(m_pkBuildingClassInfo == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+264], 0
	jne	SHORT $LN1@GetBuildin

; 861  : 	{
; 862  : 		const char* szError = "ERROR: Building does not contain valid BuildingClass type!!";

	mov	DWORD PTR _szError$218576[ebp], OFFSET ??_C@_0DM@JOEMEGPJ@ERROR?3?5Building?5does?5not?5contain@

; 863  : 		GC.LogMessage(szError);

	mov	ecx, DWORD PTR _szError$218576[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage
$LN1@GetBuildin:

; 864  : 		CvAssertMsg(false, szError);
; 865  : 	}
; 866  : 
; 867  : #pragma warning ( push )
; 868  : #pragma warning ( disable : 6011 ) // Dereferencing NULL pointer
; 869  : 	return *m_pkBuildingClassInfo;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+264]

; 870  : #pragma warning ( pop )
; 871  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ENDP ; CvBuildingEntry::GetBuildingClassInfo
_TEXT	ENDS
PUBLIC	?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetNearbyTerrainRequired
; Function compile flags: /Odtp
;	COMDAT ?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNearbyTerrainRequired, COMDAT
; _this$ = ecx

; 875  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 	return m_iNearbyTerrainRequired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 877  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNearbyTerrainRequired@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNearbyTerrainRequired
_TEXT	ENDS
PUBLIC	?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetProhibitedCityTerrain
; Function compile flags: /Odtp
;	COMDAT ?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetProhibitedCityTerrain, COMDAT
; _this$ = ecx

; 881  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 882  : 	return m_iProhibitedCityTerrain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 883  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProhibitedCityTerrain@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetProhibitedCityTerrain
_TEXT	ENDS
PUBLIC	?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetVictoryPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetVictoryPrereq, COMDAT
; _this$ = ecx

; 887  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 888  : 	return m_iVictoryPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 889  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetVictoryPrereq@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetVictoryPrereq
_TEXT	ENDS
PUBLIC	?GetFreeStartEra@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeStartEra
; Function compile flags: /Odtp
;	COMDAT ?GetFreeStartEra@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeStartEra@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeStartEra, COMDAT
; _this$ = ecx

; 893  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 894  : 	return m_iFreeStartEra;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 895  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeStartEra@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeStartEra
_TEXT	ENDS
PUBLIC	?GetMaxStartEra@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetMaxStartEra
; Function compile flags: /Odtp
;	COMDAT ?GetMaxStartEra@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxStartEra@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetMaxStartEra, COMDAT
; _this$ = ecx

; 899  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  : 	return m_iMaxStartEra;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 901  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxStartEra@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetMaxStartEra
_TEXT	ENDS
PUBLIC	?GetObsoleteTech@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetObsoleteTech
; Function compile flags: /Odtp
;	COMDAT ?GetObsoleteTech@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObsoleteTech@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetObsoleteTech, COMDAT
; _this$ = ecx

; 905  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 906  : 	return m_iObsoleteTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 907  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetObsoleteTech@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetObsoleteTech
_TEXT	ENDS
PUBLIC	?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetEnhancedYieldTech
; Function compile flags: /Odtp
;	COMDAT ?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetEnhancedYieldTech, COMDAT
; _this$ = ecx

; 911  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 912  : 	return m_iEnhancedYieldTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 913  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEnhancedYieldTech@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetEnhancedYieldTech
_TEXT	ENDS
PUBLIC	?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetTechEnhancedTourism
; Function compile flags: /Odtp
;	COMDAT ?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTechEnhancedTourism, COMDAT
; _this$ = ecx

; 917  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 918  : 	return m_iTechEnhancedTourism;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 919  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechEnhancedTourism@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTechEnhancedTourism
_TEXT	ENDS
PUBLIC	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetGoldMaintenance
; Function compile flags: /Odtp
;	COMDAT ?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGoldMaintenance, COMDAT
; _this$ = ecx

; 923  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 924  : 	return m_iGoldMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 925  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGoldMaintenance
_TEXT	ENDS
PUBLIC	?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMutuallyExclusiveGroup
; Function compile flags: /Odtp
;	COMDAT ?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetMutuallyExclusiveGroup, COMDAT
; _this$ = ecx

; 929  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 	return m_iMutuallyExclusiveGroup;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]

; 931  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMutuallyExclusiveGroup@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetMutuallyExclusiveGroup
_TEXT	ENDS
PUBLIC	?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetReplacementBuildingClass
; Function compile flags: /Odtp
;	COMDAT ?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetReplacementBuildingClass, COMDAT
; _this$ = ecx

; 935  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 936  : 	return m_iReplacementBuildingClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+308]

; 937  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetReplacementBuildingClass@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetReplacementBuildingClass
_TEXT	ENDS
PUBLIC	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPrereqAndTech
PUBLIC	?GetEra@CvBuildingEntry@@QBEHXZ			; CvBuildingEntry::GetEra
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
; Function compile flags: /Odtp
;	COMDAT ?GetEra@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pTech$218617 = -8					; size = 4
_eTech$ = -4						; size = 4
?GetEra@CvBuildingEntry@@QBEHXZ PROC			; CvBuildingEntry::GetEra, COMDAT
; _this$ = ecx

; 941  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 942  : 	TechTypes eTech = (TechTypes)GetPrereqAndTech();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	mov	DWORD PTR _eTech$[ebp], eax

; 943  : 	if (eTech != NO_TECH)

	cmp	DWORD PTR _eTech$[ebp], -1
	je	SHORT $LN1@GetEra

; 944  : 	{
; 945  : 		CvTechEntry* pTech = GC.getTechInfo((TechTypes)GetPrereqAndTech());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pTech$218617[ebp], eax

; 946  : 		return pTech->GetEra();

	mov	ecx, DWORD PTR _pTech$218617[ebp]
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	jmp	SHORT $LN2@GetEra
$LN1@GetEra:

; 947  : 	}
; 948  : 
; 949  : 	return -1;

	or	eax, -1
$LN2@GetEra:

; 950  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEra@CvBuildingEntry@@QBEHXZ ENDP			; CvBuildingEntry::GetEra
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetPrereqAndTech, COMDAT
; _this$ = ecx

; 955  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 956  : 	return m_iPrereqAndTech;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+312]

; 957  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetPrereqAndTech
_TEXT	ENDS
PUBLIC	?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPolicyBranchType
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetPolicyBranchType, COMDAT
; _this$ = ecx

; 961  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 962  : 	return m_iPolicyBranchType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]

; 963  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicyBranchType@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetPolicyBranchType
_TEXT	ENDS
PUBLIC	?GetSpecialistType@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetSpecialistType
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistType@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpecialistType@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetSpecialistType, COMDAT
; _this$ = ecx

; 967  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 968  : 	return m_iSpecialistType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+320]

; 969  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpecialistType@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetSpecialistType
_TEXT	ENDS
PUBLIC	?GetSpecialistCount@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetSpecialistCount
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistCount@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpecialistCount@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetSpecialistCount, COMDAT
; _this$ = ecx

; 973  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 974  : 	return m_iSpecialistCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+324]

; 975  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpecialistCount@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetSpecialistCount
_TEXT	ENDS
PUBLIC	?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpecialistExtraCulture
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetSpecialistExtraCulture, COMDAT
; _this$ = ecx

; 979  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 	return m_iSpecialistExtraCulture;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+328]

; 981  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpecialistExtraCulture@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetSpecialistExtraCulture
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatPeopleRateChange
; Function compile flags: /Odtp
;	COMDAT ?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGreatPeopleRateChange, COMDAT
; _this$ = ecx

; 985  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 986  : 	return m_iGreatPeopleRateChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]

; 987  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatPeopleRateChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGreatPeopleRateChange
_TEXT	ENDS
PUBLIC	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
; Function compile flags: /Odtp
;	COMDAT ?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ PROC ; CvBuildingEntry::GetGreatWorkSlotType, COMDAT
; _this$ = ecx

; 991  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 	return m_eGreatWorkSlotType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+336]

; 993  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ENDP ; CvBuildingEntry::GetGreatWorkSlotType
_TEXT	ENDS
PUBLIC	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetGreatWorkCount
; Function compile flags: /Odtp
;	COMDAT ?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetGreatWorkCount, COMDAT
; _this$ = ecx

; 1001 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1002 : 	return m_iGreatWorkCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+340]

; 1003 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetGreatWorkCount
_TEXT	ENDS
PUBLIC	?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ ; CvBuildingEntry::GetFreeGreatWork
; Function compile flags: /Odtp
;	COMDAT ?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ PROC ; CvBuildingEntry::GetFreeGreatWork, COMDAT
; _this$ = ecx

; 1007 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1008 : 	return m_eFreeGreatWork;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+344]

; 1009 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeGreatWork@CvBuildingEntry@@QBE?AW4GreatWorkType@@XZ ENDP ; CvBuildingEntry::GetFreeGreatWork
_TEXT	ENDS
PUBLIC	?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeBuildingClass
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreeBuildingClass, COMDAT
; _this$ = ecx

; 1013 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1014 : 	return m_iFreeBuildingClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+348]

; 1015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreeBuildingClass
_TEXT	ENDS
PUBLIC	?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetFreeBuildingThisCity
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreeBuildingThisCity, COMDAT
; _this$ = ecx

; 1019 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 	return m_iFreeBuildingThisCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+352]

; 1021 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuildingThisCity@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreeBuildingThisCity
_TEXT	ENDS
PUBLIC	?GetFreePromotion@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreePromotion
; Function compile flags: /Odtp
;	COMDAT ?GetFreePromotion@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreePromotion@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreePromotion, COMDAT
; _this$ = ecx

; 1025 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1026 : 	return m_iFreePromotion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+356]

; 1027 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreePromotion@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreePromotion
_TEXT	ENDS
PUBLIC	?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTrainedFreePromotion
; Function compile flags: /Odtp
;	COMDAT ?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTrainedFreePromotion, COMDAT
; _this$ = ecx

; 1031 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1032 : 	return m_iTrainedFreePromotion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+360]

; 1033 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTrainedFreePromotion@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTrainedFreePromotion
_TEXT	ENDS
PUBLIC	?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetFreePromotionRemoved
; Function compile flags: /Odtp
;	COMDAT ?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreePromotionRemoved, COMDAT
; _this$ = ecx

; 1037 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1038 : 	return m_iFreePromotionRemoved;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+364]

; 1039 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreePromotionRemoved@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreePromotionRemoved
_TEXT	ENDS
PUBLIC	?GetProductionCost@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetProductionCost
; Function compile flags: /Odtp
;	COMDAT ?GetProductionCost@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProductionCost@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetProductionCost, COMDAT
; _this$ = ecx

; 1043 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1044 : 	return m_iProductionCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+368]

; 1045 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProductionCost@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetProductionCost
_TEXT	ENDS
PUBLIC	?GetFaithCost@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetFaithCost
; Function compile flags: /Odtp
;	COMDAT ?GetFaithCost@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFaithCost@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFaithCost, COMDAT
; _this$ = ecx

; 1049 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1050 : 	return m_iFaithCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+372]

; 1051 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFaithCost@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFaithCost
_TEXT	ENDS
PUBLIC	?GetLeagueCost@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetLeagueCost
; Function compile flags: /Odtp
;	COMDAT ?GetLeagueCost@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLeagueCost@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetLeagueCost, COMDAT
; _this$ = ecx

; 1055 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1056 : 	return m_iLeagueCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+376]

; 1057 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLeagueCost@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetLeagueCost
_TEXT	ENDS
PUBLIC	?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNumCityCostMod
; Function compile flags: /Odtp
;	COMDAT ?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetNumCityCostMod, COMDAT
; _this$ = ecx

; 1061 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1062 : 	return m_iNumCityCostMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+380]

; 1063 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCityCostMod@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetNumCityCostMod
_TEXT	ENDS
PUBLIC	?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetHurryCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetHurryCostModifier, COMDAT
; _this$ = ecx

; 1067 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 	return m_iHurryCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+384]

; 1069 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHurryCostModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetHurryCostModifier
_TEXT	ENDS
PUBLIC	?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNumCitiesPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNumCitiesPrereq, COMDAT
; _this$ = ecx

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1074 : 	return m_iNumCitiesPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+388]

; 1075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesPrereq@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNumCitiesPrereq
_TEXT	ENDS
PUBLIC	?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnitLevelPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnitLevelPrereq, COMDAT
; _this$ = ecx

; 1079 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1080 : 	return m_iUnitLevelPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+392]

; 1081 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitLevelPrereq@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnitLevelPrereq
_TEXT	ENDS
PUBLIC	?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetCultureRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetCultureRateModifier, COMDAT
; _this$ = ecx

; 1085 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 	return m_iCultureRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+396]

; 1087 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureRateModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetCultureRateModifier
_TEXT	ENDS
PUBLIC	?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalCultureRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalCultureRateModifier, COMDAT
; _this$ = ecx

; 1091 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 	return m_iGlobalCultureRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+400]

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalCultureRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalCultureRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatPeopleRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 1097 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1098 : 	return m_iGreatPeopleRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+404]

; 1099 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalGreatPeopleRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 1103 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 	return m_iGlobalGreatPeopleRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+408]

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalGreatPeopleRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatGeneralRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 1109 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 	return m_iGreatGeneralRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+412]

; 1111 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatGeneralRateModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatPersonExpendGold
; Function compile flags: /Odtp
;	COMDAT ?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGreatPersonExpendGold, COMDAT
; _this$ = ecx

; 1115 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1116 : 	return m_iGreatPersonExpendGold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+416]

; 1117 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatPersonExpendGold@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGreatPersonExpendGold
_TEXT	ENDS
PUBLIC	?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnitUpgradeCostMod
; Function compile flags: /Odtp
;	COMDAT ?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnitUpgradeCostMod, COMDAT
; _this$ = ecx

; 1121 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1122 : 	return m_iUnitUpgradeCostMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+420]

; 1123 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitUpgradeCostMod@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnitUpgradeCostMod
_TEXT	ENDS
PUBLIC	?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetGoldenAgeModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGoldenAgeModifier, COMDAT
; _this$ = ecx

; 1127 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1128 : 	return m_iGoldenAgeModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+424]

; 1129 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGoldenAgeModifier
_TEXT	ENDS
PUBLIC	?GetFreeExperience@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeExperience
; Function compile flags: /Odtp
;	COMDAT ?GetFreeExperience@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeExperience@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeExperience, COMDAT
; _this$ = ecx

; 1133 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1134 : 	return m_iFreeExperience;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+428]

; 1135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeExperience@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeExperience
_TEXT	ENDS
PUBLIC	?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalFreeExperience
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGlobalFreeExperience, COMDAT
; _this$ = ecx

; 1139 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1140 : 	return m_iGlobalFreeExperience;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+432]

; 1141 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalFreeExperience@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGlobalFreeExperience
_TEXT	ENDS
PUBLIC	?GetFoodKept@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetFoodKept
; Function compile flags: /Odtp
;	COMDAT ?GetFoodKept@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFoodKept@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFoodKept, COMDAT
; _this$ = ecx

; 1145 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 	return m_iFoodKept;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+436]

; 1147 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFoodKept@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFoodKept
_TEXT	ENDS
PUBLIC	?IsAirlift@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsAirlift
; Function compile flags: /Odtp
;	COMDAT ?IsAirlift@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAirlift@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsAirlift, COMDAT
; _this$ = ecx

; 1151 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1152 : 	return m_bAirlift;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+440]

; 1153 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAirlift@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsAirlift
_TEXT	ENDS
PUBLIC	?GetAirModifier@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetAirModifier
; Function compile flags: /Odtp
;	COMDAT ?GetAirModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAirModifier@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetAirModifier, COMDAT
; _this$ = ecx

; 1157 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1158 : 	return m_iAirModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+444]

; 1159 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAirModifier@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetAirModifier
_TEXT	ENDS
PUBLIC	?GetNukeModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNukeModifier
; Function compile flags: /Odtp
;	COMDAT ?GetNukeModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNukeModifier@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetNukeModifier, COMDAT
; _this$ = ecx

; 1163 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1164 : 	return m_iNukeModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+448]

; 1165 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNukeModifier@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetNukeModifier
_TEXT	ENDS
PUBLIC	?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNukeExplosionRand
; Function compile flags: /Odtp
;	COMDAT ?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNukeExplosionRand, COMDAT
; _this$ = ecx

; 1169 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1170 : 	return m_iNukeExplosionRand;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+452]

; 1171 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNukeExplosionRand@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNukeExplosionRand
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetWorkerSpeedModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 1175 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1176 : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+456]

; 1177 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorkerSpeedModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMilitaryProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetMilitaryProductionModifier, COMDAT
; _this$ = ecx

; 1181 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1182 : 	return m_iMilitaryProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+460]

; 1183 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMilitaryProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetMilitaryProductionModifier
_TEXT	ENDS
PUBLIC	?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetSpaceProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetSpaceProductionModifier, COMDAT
; _this$ = ecx

; 1187 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 	return m_iSpaceProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+464]

; 1189 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetSpaceProductionModifier
_TEXT	ENDS
PUBLIC	?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalSpaceProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalSpaceProductionModifier, COMDAT
; _this$ = ecx

; 1193 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1194 : 	return m_iGlobalSpaceProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+468]

; 1195 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalSpaceProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalSpaceProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetBuildingProductionModifier, COMDAT
; _this$ = ecx

; 1199 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1200 : 	return m_iBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+472]

; 1201 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetWonderProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 1205 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1206 : 	return m_iWonderProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+476]

; 1207 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWonderProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityConnectionTradeRouteModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityConnectionTradeRouteModifier, COMDAT
; _this$ = ecx

; 1211 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1212 : 	return m_iCityConnectionTradeRouteModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+480]

; 1213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityConnectionTradeRouteModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityConnectionTradeRouteModifier
_TEXT	ENDS
PUBLIC	?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCapturePlunderModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetCapturePlunderModifier, COMDAT
; _this$ = ecx

; 1217 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1218 : 	return m_iCapturePlunderModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+484]

; 1219 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapturePlunderModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetCapturePlunderModifier
_TEXT	ENDS
PUBLIC	?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPolicyCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetPolicyCostModifier, COMDAT
; _this$ = ecx

; 1223 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1224 : 	return m_iPolicyCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+488]

; 1225 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicyCostModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetPolicyCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPlotCultureCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 1229 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1230 : 	return m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+496]

; 1231 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalPlotCultureCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 1235 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1236 : 	return m_iGlobalPlotCultureCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+492]

; 1237 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalPlotCultureCostModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPlotBuyCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetPlotBuyCostModifier, COMDAT
; _this$ = ecx

; 1241 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1242 : 	return m_iPlotBuyCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+504]

; 1243 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetPlotBuyCostModifier
_TEXT	ENDS
PUBLIC	?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalPlotBuyCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalPlotBuyCostModifier, COMDAT
; _this$ = ecx

; 1247 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1248 : 	return m_iGlobalPlotBuyCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+500]

; 1249 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalPlotBuyCostModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalPlotBuyCostModifier
_TEXT	ENDS
PUBLIC	?GetMinAreaSize@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetMinAreaSize
; Function compile flags: /Odtp
;	COMDAT ?GetMinAreaSize@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinAreaSize@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetMinAreaSize, COMDAT
; _this$ = ecx

; 1253 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 	return m_iMinAreaSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+508]

; 1255 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinAreaSize@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetMinAreaSize
_TEXT	ENDS
PUBLIC	?GetConquestProbability@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetConquestProbability
; Function compile flags: /Odtp
;	COMDAT ?GetConquestProbability@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetConquestProbability@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetConquestProbability, COMDAT
; _this$ = ecx

; 1259 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1260 : 	return m_iConquestProbability;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+512]

; 1261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetConquestProbability@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetConquestProbability
_TEXT	ENDS
PUBLIC	?GetHealRateChange@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetHealRateChange
; Function compile flags: /Odtp
;	COMDAT ?GetHealRateChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHealRateChange@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetHealRateChange, COMDAT
; _this$ = ecx

; 1265 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1266 : 	return m_iHealRateChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+516]

; 1267 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHealRateChange@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetHealRateChange
_TEXT	ENDS
PUBLIC	?GetHappiness@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetHappiness
; Function compile flags: /Odtp
;	COMDAT ?GetHappiness@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappiness@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetHappiness, COMDAT
; _this$ = ecx

; 1271 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1272 : 	return m_iHappiness;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+520]

; 1273 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappiness@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetHappiness
_TEXT	ENDS
PUBLIC	?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnmoddedHappiness
; Function compile flags: /Odtp
;	COMDAT ?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnmoddedHappiness, COMDAT
; _this$ = ecx

; 1277 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1278 : 	return m_iUnmoddedHappiness;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+524]

; 1279 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnmoddedHappiness@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnmoddedHappiness
_TEXT	ENDS
PUBLIC	?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetUnhappinessModifier
; Function compile flags: /Odtp
;	COMDAT ?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetUnhappinessModifier, COMDAT
; _this$ = ecx

; 1283 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1284 : 	return m_iUnhappinessModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+528]

; 1285 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnhappinessModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetHappinessPerCity
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetHappinessPerCity, COMDAT
; _this$ = ecx

; 1289 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1290 : 	return m_iHappinessPerCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+532]

; 1291 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessPerCity@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetHappinessPerCity
_TEXT	ENDS
PUBLIC	?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetHappinessPerXPolicies
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetHappinessPerXPolicies, COMDAT
; _this$ = ecx

; 1295 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1296 : 	return m_iHappinessPerXPolicies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+536]

; 1297 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessPerXPolicies@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetHappinessPerXPolicies
_TEXT	ENDS
PUBLIC	?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityCountUnhappinessMod
; Function compile flags: /Odtp
;	COMDAT ?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityCountUnhappinessMod, COMDAT
; _this$ = ecx

; 1301 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1302 : 	return m_iCityCountUnhappinessMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+540]

; 1303 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityCountUnhappinessMod@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityCountUnhappinessMod
_TEXT	ENDS
PUBLIC	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNoOccupiedUnhappiness
; Function compile flags: /Odtp
;	COMDAT ?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsNoOccupiedUnhappiness, COMDAT
; _this$ = ecx

; 1307 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1308 : 	return m_bNoOccupiedUnhappiness;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+544]

; 1309 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsNoOccupiedUnhappiness
_TEXT	ENDS
PUBLIC	?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalPopulationChange
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGlobalPopulationChange, COMDAT
; _this$ = ecx

; 1313 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1314 : 	return m_iGlobalPopulationChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+548]

; 1315 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalPopulationChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGlobalPopulationChange
_TEXT	ENDS
PUBLIC	?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetLocalPopulationChange
; Function compile flags: /Odtp
;	COMDAT ?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetLocalPopulationChange, COMDAT
; _this$ = ecx

; 1320 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1321 : 	return m_iLocalPopulationChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+552]

; 1322 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalPopulationChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetLocalPopulationChange
_TEXT	ENDS
PUBLIC	?GetTechShare@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetTechShare
; Function compile flags: /Odtp
;	COMDAT ?GetTechShare@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechShare@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetTechShare, COMDAT
; _this$ = ecx

; 1327 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1328 : 	return m_iTechShare;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+556]

; 1329 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechShare@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetTechShare
_TEXT	ENDS
PUBLIC	?GetFreeTechs@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetFreeTechs
; Function compile flags: /Odtp
;	COMDAT ?GetFreeTechs@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeTechs@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeTechs, COMDAT
; _this$ = ecx

; 1333 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1334 : 	return m_iFreeTechs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+560]

; 1335 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeTechs@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeTechs
_TEXT	ENDS
PUBLIC	?GetFreePolicies@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreePolicies
; Function compile flags: /Odtp
;	COMDAT ?GetFreePolicies@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreePolicies@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreePolicies, COMDAT
; _this$ = ecx

; 1339 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1340 : 	return m_iFreePolicies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+564]

; 1341 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreePolicies@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreePolicies
_TEXT	ENDS
PUBLIC	?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeFlatFaith
; Function compile flags: /Odtp
;	COMDAT ?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetFreeFlatFaith, COMDAT
; _this$ = ecx

; 1346 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1347 : 	return m_iFreeFlatFaith;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+568]

; 1348 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeFlatFaith@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetFreeFlatFaith
_TEXT	ENDS
PUBLIC	?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMountainScienceYield
; Function compile flags: /Odtp
;	COMDAT ?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetMountainScienceYield, COMDAT
; _this$ = ecx

; 1354 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1355 : 	return m_iMountainScienceYield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+572]

; 1356 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMountainScienceYield@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetMountainScienceYield
_TEXT	ENDS
PUBLIC	?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFreeGreatPeople
; Function compile flags: /Odtp
;	COMDAT ?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetFreeGreatPeople, COMDAT
; _this$ = ecx

; 1361 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1362 : 	return m_iFreeGreatPeople;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+576]

; 1363 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeGreatPeople@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetFreeGreatPeople
_TEXT	ENDS
PUBLIC	?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMedianTechPercentChange
; Function compile flags: /Odtp
;	COMDAT ?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetMedianTechPercentChange, COMDAT
; _this$ = ecx

; 1367 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1368 : 	return m_iMedianTechPercentChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+580]

; 1369 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMedianTechPercentChange@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetMedianTechPercentChange
_TEXT	ENDS
PUBLIC	?GetGold@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetGold
; Function compile flags: /Odtp
;	COMDAT ?GetGold@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGold@CvBuildingEntry@@QBEHXZ PROC			; CvBuildingEntry::GetGold, COMDAT
; _this$ = ecx

; 1373 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1374 : 	return m_iGold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+584]

; 1375 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGold@CvBuildingEntry@@QBEHXZ ENDP			; CvBuildingEntry::GetGold
_TEXT	ENDS
PUBLIC	?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNearbyMountainRequired
; Function compile flags: /Odtp
;	COMDAT ?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsNearbyMountainRequired, COMDAT
; _this$ = ecx

; 1379 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1380 : 	return m_bNearbyMountainRequired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+588]

; 1381 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNearbyMountainRequired@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsNearbyMountainRequired
_TEXT	ENDS
PUBLIC	?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsAllowsRangeStrike
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsAllowsRangeStrike, COMDAT
; _this$ = ecx

; 1385 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1386 : 	return m_bAllowsRangeStrike;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+589]

; 1387 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsRangeStrike@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsAllowsRangeStrike
_TEXT	ENDS
PUBLIC	?GetDefenseModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetDefenseModifier
; Function compile flags: /Odtp
;	COMDAT ?GetDefenseModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDefenseModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetDefenseModifier, COMDAT
; _this$ = ecx

; 1391 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1392 : 	return m_iDefenseModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+592]

; 1393 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDefenseModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetDefenseModifier
_TEXT	ENDS
PUBLIC	?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetDefensePerCitizen
; Function compile flags: /Odtp
;	COMDAT ?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetDefensePerCitizen, COMDAT
; _this$ = ecx

; 1398 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1399 : 	return m_iDefensePerCitizen;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+596]

; 1400 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDefensePerCitizen@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetDefensePerCitizen
_TEXT	ENDS
PUBLIC	?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalDefenseModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetGlobalDefenseModifier, COMDAT
; _this$ = ecx

; 1406 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1407 : 	return m_iGlobalDefenseModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+600]

; 1408 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalDefenseModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetGlobalDefenseModifier
_TEXT	ENDS
PUBLIC	?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetExtraCityHitPoints
; Function compile flags: /Odtp
;	COMDAT ?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetExtraCityHitPoints, COMDAT
; _this$ = ecx

; 1412 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1413 : 	return m_iExtraCityHitPoints;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+604]

; 1414 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraCityHitPoints@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetExtraCityHitPoints
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetMinorFriendshipChange
; Function compile flags: /Odtp
;	COMDAT ?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetMinorFriendshipChange, COMDAT
; _this$ = ecx

; 1418 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1419 : 	return m_iMinorFriendshipChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+612]

; 1420 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorFriendshipChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetMinorFriendshipChange
_TEXT	ENDS
PUBLIC	?GetVictoryPoints@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetVictoryPoints
; Function compile flags: /Odtp
;	COMDAT ?GetVictoryPoints@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVictoryPoints@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetVictoryPoints, COMDAT
; _this$ = ecx

; 1424 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1425 : 	return m_iVictoryPoints;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+616]

; 1426 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetVictoryPoints@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetVictoryPoints
_TEXT	ENDS
PUBLIC	?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetExtraMissionarySpreads
; Function compile flags: /Odtp
;	COMDAT ?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetExtraMissionarySpreads, COMDAT
; _this$ = ecx

; 1430 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1431 : 	return m_iExtraMissionarySpreads;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+620]

; 1432 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraMissionarySpreads@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetExtraMissionarySpreads
_TEXT	ENDS
PUBLIC	?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetReligiousPressureModifier
; Function compile flags: /Odtp
;	COMDAT ?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetReligiousPressureModifier, COMDAT
; _this$ = ecx

; 1436 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1437 : 	return m_iReligiousPressureModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+624]

; 1438 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetReligiousPressureModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetReligiousPressureModifier
_TEXT	ENDS
PUBLIC	?GetEspionageModifier@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetEspionageModifier
; Function compile flags: /Odtp
;	COMDAT ?GetEspionageModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEspionageModifier@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetEspionageModifier, COMDAT
; _this$ = ecx

; 1442 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1443 : 	return m_iEspionageModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+628]

; 1444 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEspionageModifier@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetEspionageModifier
_TEXT	ENDS
PUBLIC	?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGlobalEspionageModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGlobalEspionageModifier, COMDAT
; _this$ = ecx

; 1448 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1449 : 	return m_iGlobalEspionageModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+632]

; 1450 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalEspionageModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGlobalEspionageModifier
_TEXT	ENDS
PUBLIC	?GetExtraSpies@CvBuildingEntry@@QBEHXZ		; CvBuildingEntry::GetExtraSpies
; Function compile flags: /Odtp
;	COMDAT ?GetExtraSpies@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraSpies@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetExtraSpies, COMDAT
; _this$ = ecx

; 1454 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1455 : 	return m_iExtraSpies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+636]

; 1456 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraSpies@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetExtraSpies
_TEXT	ENDS
PUBLIC	?GetSpyRankChange@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetSpyRankChange
; Function compile flags: /Odtp
;	COMDAT ?GetSpyRankChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpyRankChange@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetSpyRankChange, COMDAT
; _this$ = ecx

; 1460 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1461 : 	return m_iSpyRankChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+640]

; 1462 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpyRankChange@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetSpyRankChange
_TEXT	ENDS
PUBLIC	?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteRecipientBonus
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteRecipientBonus, COMDAT
; _this$ = ecx

; 1466 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1467 : 	return m_iTradeRouteRecipientBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+664]

; 1468 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteRecipientBonus@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteRecipientBonus
_TEXT	ENDS
PUBLIC	?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteTargetBonus
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTradeRouteTargetBonus, COMDAT
; _this$ = ecx

; 1472 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1473 : 	return m_iTradeRouteTargetBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+668]

; 1474 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteTargetBonus@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTradeRouteTargetBonus
_TEXT	ENDS
PUBLIC	?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetNumTradeRouteBonus
; Function compile flags: /Odtp
;	COMDAT ?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetNumTradeRouteBonus, COMDAT
; _this$ = ecx

; 1477 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1478 : 	return m_iNumTradeRouteBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]

; 1479 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumTradeRouteBonus@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetNumTradeRouteBonus
_TEXT	ENDS
PUBLIC	?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier, COMDAT
; _this$ = ecx

; 1482 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1483 : 	return m_iTradeRouteSeaDistanceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+676]

; 1484 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteSeaDistanceModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteSeaDistanceModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteSeaGoldBonus
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetTradeRouteSeaGoldBonus, COMDAT
; _this$ = ecx

; 1487 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1488 : 	return m_iTradeRouteSeaGoldBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+680]

; 1489 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteSeaGoldBonus@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetTradeRouteSeaGoldBonus
_TEXT	ENDS
PUBLIC	?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteLandDistanceModifier, COMDAT
; _this$ = ecx

; 1492 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1493 : 	return m_iTradeRouteLandDistanceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+684]

; 1494 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteLandDistanceModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteLandDistanceModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetTradeRouteLandGoldBonus
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetTradeRouteLandGoldBonus, COMDAT
; _this$ = ecx

; 1497 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1498 : 	return m_iTradeRouteLandGoldBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+688]

; 1499 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteLandGoldBonus@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetTradeRouteLandGoldBonus
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityStateTradeRouteProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityStateTradeRouteProductionModifier, COMDAT
; _this$ = ecx

; 1502 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1503 : 	return m_iCityStateTradeRouteProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+692]

; 1504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityStateTradeRouteProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityStateTradeRouteGoldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetCityStateTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 1508 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1509 : 	return m_iCityStateTradeRouteGoldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+696]

; 1510 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetCityStateTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatScientistBeakerModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatScientistBeakerModifier, COMDAT
; _this$ = ecx

; 1514 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1515 : 	return m_iGreatScientistBeakerModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+700]

; 1516 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatScientistBeakerModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatScientistBeakerModifier
_TEXT	ENDS
PUBLIC	?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetInstantSpyRankChange
; Function compile flags: /Odtp
;	COMDAT ?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetInstantSpyRankChange, COMDAT
; _this$ = ecx

; 1520 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1521 : 	return m_iInstantSpyRankChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+644]

; 1522 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstantSpyRankChange@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetInstantSpyRankChange
_TEXT	ENDS
PUBLIC	?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetLandmarksTourismPercent
; Function compile flags: /Odtp
;	COMDAT ?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetLandmarksTourismPercent, COMDAT
; _this$ = ecx

; 1526 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1527 : 	return m_iLandmarksTourismPercent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+648]

; 1528 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandmarksTourismPercent@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetLandmarksTourismPercent
_TEXT	ENDS
PUBLIC	?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetInstantMilitaryIncrease
; Function compile flags: /Odtp
;	COMDAT ?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetInstantMilitaryIncrease, COMDAT
; _this$ = ecx

; 1532 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1533 : 	return m_iInstantMilitaryIncrease;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+652]

; 1534 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstantMilitaryIncrease@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetInstantMilitaryIncrease
_TEXT	ENDS
PUBLIC	?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorksTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetGreatWorksTourismModifier, COMDAT
; _this$ = ecx

; 1538 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1539 : 	return m_iGreatWorksTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+656]

; 1540 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatWorksTourismModifier@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetGreatWorksTourismModifier
_TEXT	ENDS
PUBLIC	?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
; Function compile flags: /Odtp
;	COMDAT ?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice, COMDAT
; _this$ = ecx

; 1544 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1545 : 	return m_iXBuiltTriggersIdeologyChoice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+660]

; 1546 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
_TEXT	ENDS
PUBLIC	?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetExtraLeagueVotes
; Function compile flags: /Odtp
;	COMDAT ?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ PROC	; CvBuildingEntry::GetExtraLeagueVotes, COMDAT
; _this$ = ecx

; 1550 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1551 : 	return m_iExtraLeagueVotes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+704]

; 1552 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraLeagueVotes@CvBuildingEntry@@QBEHXZ ENDP	; CvBuildingEntry::GetExtraLeagueVotes
_TEXT	ENDS
PUBLIC	?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPreferredDisplayPosition
; Function compile flags: /Odtp
;	COMDAT ?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ PROC ; CvBuildingEntry::GetPreferredDisplayPosition, COMDAT
; _this$ = ecx

; 1556 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1557 : 	return m_iPreferredDisplayPosition;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+708]

; 1558 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ ENDP ; CvBuildingEntry::GetPreferredDisplayPosition
_TEXT	ENDS
PUBLIC	?GetPortraitIndex@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetPortraitIndex
; Function compile flags: /Odtp
;	COMDAT ?GetPortraitIndex@CvBuildingEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPortraitIndex@CvBuildingEntry@@QBEHXZ PROC		; CvBuildingEntry::GetPortraitIndex, COMDAT
; _this$ = ecx

; 1562 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1563 : 	return m_iPortraitIndex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+712]

; 1564 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPortraitIndex@CvBuildingEntry@@QBEHXZ ENDP		; CvBuildingEntry::GetPortraitIndex
_TEXT	ENDS
PUBLIC	?IsTeamShare@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsTeamShare
; Function compile flags: /Odtp
;	COMDAT ?IsTeamShare@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTeamShare@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsTeamShare, COMDAT
; _this$ = ecx

; 1568 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1569 : 	return m_bTeamShare;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+716]

; 1570 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeamShare@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsTeamShare
_TEXT	ENDS
PUBLIC	?IsWater@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsWater
; Function compile flags: /Odtp
;	COMDAT ?IsWater@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWater@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsWater, COMDAT
; _this$ = ecx

; 1574 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1575 : 	return m_bWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+717]

; 1576 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsWater@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsWater
_TEXT	ENDS
PUBLIC	?IsRiver@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsRiver
; Function compile flags: /Odtp
;	COMDAT ?IsRiver@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRiver@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsRiver, COMDAT
; _this$ = ecx

; 1580 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1581 : 	return m_bRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+718]

; 1582 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRiver@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsRiver
_TEXT	ENDS
PUBLIC	?IsFreshWater@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsFreshWater
; Function compile flags: /Odtp
;	COMDAT ?IsFreshWater@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFreshWater@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsFreshWater, COMDAT
; _this$ = ecx

; 1586 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1587 : 	return m_bFreshWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+719]

; 1588 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFreshWater@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsFreshWater
_TEXT	ENDS
PUBLIC	?IsMountain@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsMountain
; Function compile flags: /Odtp
;	COMDAT ?IsMountain@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMountain@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsMountain, COMDAT
; _this$ = ecx

; 1592 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1593 : 	return m_bMountain;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+720]

; 1594 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMountain@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsMountain
_TEXT	ENDS
PUBLIC	?IsHill@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsHill
; Function compile flags: /Odtp
;	COMDAT ?IsHill@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHill@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsHill, COMDAT
; _this$ = ecx

; 1598 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1599 : 	return m_bHill;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+721]

; 1600 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHill@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsHill
_TEXT	ENDS
PUBLIC	?IsFlat@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsFlat
; Function compile flags: /Odtp
;	COMDAT ?IsFlat@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlat@CvBuildingEntry@@QBE_NXZ PROC			; CvBuildingEntry::IsFlat, COMDAT
; _this$ = ecx

; 1604 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1605 : 	return m_bFlat;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+722]

; 1606 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlat@CvBuildingEntry@@QBE_NXZ ENDP			; CvBuildingEntry::IsFlat
_TEXT	ENDS
PUBLIC	?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsFoundsReligion
; Function compile flags: /Odtp
;	COMDAT ?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsFoundsReligion, COMDAT
; _this$ = ecx

; 1610 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1611 : 	return m_bFoundsReligion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+723]

; 1612 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsFoundsReligion@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsFoundsReligion
_TEXT	ENDS
PUBLIC	?IsReligious@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsReligious
; Function compile flags: /Odtp
;	COMDAT ?IsReligious@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsReligious@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsReligious, COMDAT
; _this$ = ecx

; 1616 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1617 : 	return m_bIsReligious;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+724]

; 1618 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsReligious@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsReligious
_TEXT	ENDS
PUBLIC	?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsBorderObstacle
; Function compile flags: /Odtp
;	COMDAT ?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsBorderObstacle, COMDAT
; _this$ = ecx

; 1622 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1623 : 	return m_bBorderObstacle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+725]

; 1624 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBorderObstacle@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsBorderObstacle
_TEXT	ENDS
PUBLIC	?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsPlayerBorderObstacle
; Function compile flags: /Odtp
;	COMDAT ?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsPlayerBorderObstacle, COMDAT
; _this$ = ecx

; 1628 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1629 : 	return m_bPlayerBorderObstacle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+726]

; 1630 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayerBorderObstacle@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsPlayerBorderObstacle
_TEXT	ENDS
PUBLIC	?IsCityWall@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsCityWall
; Function compile flags: /Odtp
;	COMDAT ?IsCityWall@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCityWall@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsCityWall, COMDAT
; _this$ = ecx

; 1634 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1635 : 	return m_bCityWall;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+736]

; 1636 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCityWall@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsCityWall
_TEXT	ENDS
PUBLIC	?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsUnlockedByBelief
; Function compile flags: /Odtp
;	COMDAT ?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsUnlockedByBelief, COMDAT
; _this$ = ecx

; 1640 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1641 : 	return m_bUnlockedByBelief;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+737]

; 1642 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsUnlockedByBelief
_TEXT	ENDS
PUBLIC	?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsUnlockedByLeague
; Function compile flags: /Odtp
;	COMDAT ?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsUnlockedByLeague, COMDAT
; _this$ = ecx

; 1646 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1647 : 	return m_bUnlockedByLeague;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+738]

; 1648 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnlockedByLeague@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsUnlockedByLeague
_TEXT	ENDS
PUBLIC	?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsRequiresHolyCity
; Function compile flags: /Odtp
;	COMDAT ?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsRequiresHolyCity, COMDAT
; _this$ = ecx

; 1652 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1653 : 	return m_bRequiresHolyCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+739]

; 1654 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRequiresHolyCity@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsRequiresHolyCity
_TEXT	ENDS
PUBLIC	?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::AffectSpiesNow
; Function compile flags: /Odtp
;	COMDAT ?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::AffectSpiesNow, COMDAT
; _this$ = ecx

; 1658 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1659 : 	return m_bAffectSpiesNow;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+740]

; 1660 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AffectSpiesNow@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::AffectSpiesNow
_TEXT	ENDS
PUBLIC	?IsEspionage@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsEspionage
; Function compile flags: /Odtp
;	COMDAT ?IsEspionage@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEspionage@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsEspionage, COMDAT
; _this$ = ecx

; 1664 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1665 : 	return m_bEspionage;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+741]

; 1666 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEspionage@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsEspionage
_TEXT	ENDS
PUBLIC	?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsMalianTreasury
; Function compile flags: /Odtp
;	COMDAT ?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsMalianTreasury, COMDAT
; _this$ = ecx

; 1671 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1672 : 	return m_bMalianTreasury;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+742]

; 1673 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMalianTreasury@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsMalianTreasury
_TEXT	ENDS
PUBLIC	?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::AllowsFoodTradeRoutes
; Function compile flags: /Odtp
;	COMDAT ?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::AllowsFoodTradeRoutes, COMDAT
; _this$ = ecx

; 1677 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1678 : 	return m_bAllowsFoodTradeRoutes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+743]

; 1679 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AllowsFoodTradeRoutes@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::AllowsFoodTradeRoutes
_TEXT	ENDS
PUBLIC	?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::AllowsProductionTradeRoutes
; Function compile flags: /Odtp
;	COMDAT ?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ PROC ; CvBuildingEntry::AllowsProductionTradeRoutes, COMDAT
; _this$ = ecx

; 1682 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1683 : 	return m_bAllowsProductionTradeRoutes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+744]

; 1684 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AllowsProductionTradeRoutes@CvBuildingEntry@@QBE_NXZ ENDP ; CvBuildingEntry::AllowsProductionTradeRoutes
_TEXT	ENDS
PUBLIC	?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::NullifyInfluenceModifier
; Function compile flags: /Odtp
;	COMDAT ?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::NullifyInfluenceModifier, COMDAT
; _this$ = ecx

; 1687 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1688 : 	return m_bNullifyInfluenceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+745]

; 1689 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NullifyInfluenceModifier@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::NullifyInfluenceModifier
_TEXT	ENDS
PUBLIC	?IsCapital@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsCapital
; Function compile flags: /Odtp
;	COMDAT ?IsCapital@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCapital@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsCapital, COMDAT
; _this$ = ecx

; 1693 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1694 : 	return m_bCapital;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+727]

; 1695 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsCapital@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsCapital
_TEXT	ENDS
PUBLIC	?IsGoldenAge@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsGoldenAge
; Function compile flags: /Odtp
;	COMDAT ?IsGoldenAge@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGoldenAge@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsGoldenAge, COMDAT
; _this$ = ecx

; 1699 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1700 : 	return m_bGoldenAge;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+728]

; 1701 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGoldenAge@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsGoldenAge
_TEXT	ENDS
PUBLIC	?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsGrantsFreeCulturalGreatPersonWithTrait
; Function compile flags: /Odtp
;	COMDAT ?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ PROC ; CvBuildingEntry::IsGrantsFreeCulturalGreatPersonWithTrait, COMDAT
; _this$ = ecx

; 1706 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1707 : 	return m_bGrantsFreeCulturalGreatPersonWithTrait;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+729]

; 1708 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGrantsFreeCulturalGreatPersonWithTrait@CvBuildingEntry@@QBE_NXZ ENDP ; CvBuildingEntry::IsGrantsFreeCulturalGreatPersonWithTrait
_TEXT	ENDS
PUBLIC	?IsMapCentering@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsMapCentering
; Function compile flags: /Odtp
;	COMDAT ?IsMapCentering@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMapCentering@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsMapCentering, COMDAT
; _this$ = ecx

; 1713 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1714 : 	return m_bMapCentering;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+730]

; 1715 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMapCentering@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsMapCentering
_TEXT	ENDS
PUBLIC	?IsNeverCapture@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsNeverCapture
; Function compile flags: /Odtp
;	COMDAT ?IsNeverCapture@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNeverCapture@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsNeverCapture, COMDAT
; _this$ = ecx

; 1719 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1720 : 	return m_bNeverCapture;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+731]

; 1721 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNeverCapture@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsNeverCapture
_TEXT	ENDS
PUBLIC	?IsNukeImmune@CvBuildingEntry@@QBE_NXZ		; CvBuildingEntry::IsNukeImmune
; Function compile flags: /Odtp
;	COMDAT ?IsNukeImmune@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNukeImmune@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsNukeImmune, COMDAT
; _this$ = ecx

; 1725 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1726 : 	return m_bNukeImmune;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+732]

; 1727 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNukeImmune@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsNukeImmune
_TEXT	ENDS
PUBLIC	?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsExtraLuxuries
; Function compile flags: /Odtp
;	COMDAT ?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ PROC		; CvBuildingEntry::IsExtraLuxuries, COMDAT
; _this$ = ecx

; 1731 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1732 : 	return m_bExtraLuxuries;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+733]

; 1733 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsExtraLuxuries@CvBuildingEntry@@QBE_NXZ ENDP		; CvBuildingEntry::IsExtraLuxuries
_TEXT	ENDS
PUBLIC	?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsDiplomaticVoting
; Function compile flags: /Odtp
;	COMDAT ?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsDiplomaticVoting, COMDAT
; _this$ = ecx

; 1737 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 	return m_bDiplomaticVoting;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+734]

; 1739 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDiplomaticVoting@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsDiplomaticVoting
_TEXT	ENDS
PUBLIC	?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::AllowsWaterRoutes
; Function compile flags: /Odtp
;	COMDAT ?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::AllowsWaterRoutes, COMDAT
; _this$ = ecx

; 1743 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1744 : 	return m_bAllowsWaterRoutes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+735]

; 1745 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AllowsWaterRoutes@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::AllowsWaterRoutes
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetYieldModifier
PUBLIC	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
PUBLIC	?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChangePerReligion
PUBLIC	?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetYieldChangePerPop
PUBLIC	?GetYieldChange@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetYieldChange
PUBLIC	?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsScienceBuilding
; Function compile flags: /Odtp
;	COMDAT ?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bRtnValue$ = -1					; size = 1
?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ PROC	; CvBuildingEntry::IsScienceBuilding, COMDAT
; _this$ = ecx

; 1749 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1750 : 	bool bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[ebp], 0

; 1751 : 
; 1752 : 	if(IsCapital())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsCapital@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@IsScienceB

; 1753 : 	{
; 1754 : 		bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[ebp], 0
	jmp	SHORT $LN10@IsScienceB
$LN11@IsScienceB:

; 1755 : 	}
; 1756 : 	else if(GetYieldChange(YIELD_SCIENCE) > 0)

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN9@IsScienceB

; 1757 : 	{
; 1758 : 		bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
	jmp	SHORT $LN10@IsScienceB
$LN9@IsScienceB:

; 1759 : 	}
; 1760 : 	else if(GetYieldChangePerPop(YIELD_SCIENCE) > 0)

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChangePerPop
	test	eax, eax
	jle	SHORT $LN7@IsScienceB

; 1761 : 	{
; 1762 : 		bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
	jmp	SHORT $LN10@IsScienceB
$LN7@IsScienceB:

; 1763 : 	}
; 1764 : 	else if(GetYieldChangePerReligion(YIELD_SCIENCE) > 0)

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChangePerReligion
	test	eax, eax
	jle	SHORT $LN5@IsScienceB

; 1765 : 	{
; 1766 : 		bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
	jmp	SHORT $LN10@IsScienceB
$LN5@IsScienceB:

; 1767 : 	}
; 1768 : 	else if(GetTechEnhancedYieldChange(YIELD_SCIENCE) > 0)

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetTechEnhancedYieldChange
	test	eax, eax
	jle	SHORT $LN3@IsScienceB

; 1769 : 	{
; 1770 : 		bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
	jmp	SHORT $LN10@IsScienceB
$LN3@IsScienceB:

; 1771 : 	}
; 1772 : 	else if(GetYieldModifier(YIELD_SCIENCE) > 0)

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetYieldModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldModifier
	test	eax, eax
	jle	SHORT $LN10@IsScienceB

; 1773 : 	{
; 1774 : 		bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
$LN10@IsScienceB:

; 1775 : 	}
; 1776 : 
; 1777 : 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[ebp]

; 1778 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ ENDP	; CvBuildingEntry::IsScienceBuilding
_TEXT	ENDS
PUBLIC	?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ	; CvBuildingEntry::GetArtDefineTag
; Function compile flags: /Odtp
;	COMDAT ?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ PROC		; CvBuildingEntry::GetArtDefineTag, COMDAT
; _this$ = ecx

; 1782 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1783 : 	return m_strArtDefineTag.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 1784 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetArtDefineTag@CvBuildingEntry@@QBEPBDXZ ENDP		; CvBuildingEntry::GetArtDefineTag
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227951 = -4						; size = 4
_szVal$ = 8						; size = 4
?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z PROC	; CvBuildingEntry::SetArtDefineTag, COMDAT
; _this$ = ecx

; 1788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1789 : 	m_strArtDefineTag = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 752				; 000002f0H
	mov	DWORD PTR $T227951[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN4@SetArtDefi
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T227951[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@SetArtDefi
$LN4@SetArtDefi:
	mov	ecx, DWORD PTR $T227951[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@SetArtDefi:

; 1790 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetArtDefineTag@CvBuildingEntry@@QAEXPBD@Z ENDP	; CvBuildingEntry::SetArtDefineTag
_TEXT	ENDS
PUBLIC	?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ ; CvBuildingEntry::GetArtInfoCulturalVariation
; Function compile flags: /Odtp
;	COMDAT ?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ PROC ; CvBuildingEntry::GetArtInfoCulturalVariation, COMDAT
; _this$ = ecx

; 1794 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1795 : 	return m_bArtInfoCulturalVariation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+746]

; 1796 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetArtInfoCulturalVariation@CvBuildingEntry@@QBE?B_NXZ ENDP ; CvBuildingEntry::GetArtInfoCulturalVariation
_TEXT	ENDS
PUBLIC	?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ ; CvBuildingEntry::GetArtInfoEraVariation
; Function compile flags: /Odtp
;	COMDAT ?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ PROC	; CvBuildingEntry::GetArtInfoEraVariation, COMDAT
; _this$ = ecx

; 1800 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1801 : 	return m_bArtInfoEraVariation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+747]

; 1802 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetArtInfoEraVariation@CvBuildingEntry@@QBE?B_NXZ ENDP	; CvBuildingEntry::GetArtInfoEraVariation
_TEXT	ENDS
PUBLIC	?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ ; CvBuildingEntry::GetArtInfoRandomVariation
; Function compile flags: /Odtp
;	COMDAT ?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ PROC ; CvBuildingEntry::GetArtInfoRandomVariation, COMDAT
; _this$ = ecx

; 1806 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1807 : 	return m_bArtInfoRandomVariation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+748]

; 1808 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetArtInfoRandomVariation@CvBuildingEntry@@QBE?B_NXZ ENDP ; CvBuildingEntry::GetArtInfoRandomVariation
_TEXT	ENDS
PUBLIC	?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ	; CvBuildingEntry::GetWonderSplashAudio
; Function compile flags: /Odtp
;	COMDAT ?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ PROC	; CvBuildingEntry::GetWonderSplashAudio, COMDAT
; _this$ = ecx

; 1811 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1812 : 	return m_strWonderSplashAudio.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 1813 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWonderSplashAudio@CvBuildingEntry@@QBEPBDXZ ENDP	; CvBuildingEntry::GetWonderSplashAudio
_TEXT	ENDS
PUBLIC	?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ ; CvBuildingEntry::GetThemingBonusHelp
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227963 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ PROC ; CvBuildingEntry::GetThemingBonusHelp, COMDAT
; _this$ = ecx

; 1816 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T227963[ebp], 0

; 1817 : 	return m_strThemingBonusHelp;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 808				; 00000328H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T227963[ebp]
	or	ecx, 1
	mov	DWORD PTR $T227963[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1818 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetThemingBonusHelp@CvBuildingEntry@@QBE?AVCvString@@XZ ENDP ; CvBuildingEntry::GetThemingBonusHelp
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChange@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetYieldChange, COMDAT
; _this$ = ecx

; 1824 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1825 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1826 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1827 : 	return m_piYieldChange ? m_piYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+880], 0
	je	SHORT $LN3@GetYieldCh
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+880]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh
$LN3@GetYieldCh:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh:
	mov	eax, DWORD PTR tv69[ebp]

; 1828 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChange@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetYieldChange
_TEXT	ENDS
PUBLIC	?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ	; CvBuildingEntry::GetYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC	; CvBuildingEntry::GetYieldChangeArray, COMDAT
; _this$ = ecx

; 1832 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1833 : 	return m_piYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+880]

; 1834 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP	; CvBuildingEntry::GetYieldChangeArray
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetYieldChangePerPop, COMDAT
; _this$ = ecx

; 1838 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1839 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1840 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1841 : 	return m_piYieldChangePerPop ? m_piYieldChangePerPop[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+884], 0
	je	SHORT $LN3@GetYieldCh@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+884]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@2
$LN3@GetYieldCh@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh@2:
	mov	eax, DWORD PTR tv69[ebp]

; 1842 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangePerPop@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetYieldChangePerPop
_TEXT	ENDS
PUBLIC	?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetYieldChangePerPopArray
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetYieldChangePerPopArray, COMDAT
; _this$ = ecx

; 1846 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1847 : 	return m_piYieldChangePerPop;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+884]

; 1848 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetYieldChangePerPopArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetYieldChangePerPopArray
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetYieldChangePerReligion, COMDAT
; _this$ = ecx

; 1852 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1853 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1854 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1855 : 	return m_piYieldChangePerReligion ? m_piYieldChangePerReligion[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+888], 0
	je	SHORT $LN3@GetYieldCh@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+888]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldCh@3
$LN3@GetYieldCh@3:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldCh@3:
	mov	eax, DWORD PTR tv69[ebp]

; 1856 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldChangePerReligion@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetYieldChangePerReligion
_TEXT	ENDS
PUBLIC	?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetYieldChangePerReligionArray
; Function compile flags: /Odtp
;	COMDAT ?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetYieldChangePerReligionArray, COMDAT
; _this$ = ecx

; 1860 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1861 : 	return m_piYieldChangePerReligion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+888]

; 1862 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetYieldChangePerReligionArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetYieldChangePerReligionArray
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetYieldModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldModifier@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetYieldModifier, COMDAT
; _this$ = ecx

; 1866 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1867 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1868 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1869 : 	return m_piYieldModifier ? m_piYieldModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+892], 0
	je	SHORT $LN3@GetYieldMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+892]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldMo
$LN3@GetYieldMo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldMo:
	mov	eax, DWORD PTR tv69[ebp]

; 1870 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldModifier@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetYieldModifier
_TEXT	ENDS
PUBLIC	?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetYieldModifierArray
; Function compile flags: /Odtp
;	COMDAT ?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ PROC	; CvBuildingEntry::GetYieldModifierArray, COMDAT
; _this$ = ecx

; 1874 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1875 : 	return m_piYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+892]

; 1876 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ENDP	; CvBuildingEntry::GetYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetAreaYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetAreaYieldModifier, COMDAT
; _this$ = ecx

; 1880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1881 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1882 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1883 : 	return m_piAreaYieldModifier ? m_piAreaYieldModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+896], 0
	je	SHORT $LN3@GetAreaYie
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+896]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetAreaYie
$LN3@GetAreaYie:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetAreaYie:
	mov	eax, DWORD PTR tv69[ebp]

; 1884 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetAreaYieldModifier
_TEXT	ENDS
PUBLIC	?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetAreaYieldModifierArray
; Function compile flags: /Odtp
;	COMDAT ?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetAreaYieldModifierArray, COMDAT
; _this$ = ecx

; 1888 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1889 : 	return m_piAreaYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+896]

; 1890 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAreaYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetAreaYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetGlobalYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetGlobalYieldModifier, COMDAT
; _this$ = ecx

; 1894 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1895 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1896 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1897 : 	return m_piGlobalYieldModifier ? m_piGlobalYieldModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+900], 0
	je	SHORT $LN3@GetGlobalY
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetGlobalY
$LN3@GetGlobalY:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetGlobalY:
	mov	eax, DWORD PTR tv69[ebp]

; 1898 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetGlobalYieldModifier@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetGlobalYieldModifier
_TEXT	ENDS
PUBLIC	?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetGlobalYieldModifierArray
; Function compile flags: /Odtp
;	COMDAT ?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetGlobalYieldModifierArray, COMDAT
; _this$ = ecx

; 1902 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1903 : 	return m_piGlobalYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+900]

; 1904 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalYieldModifierArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetGlobalYieldModifierArray
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetTechEnhancedYieldChange, COMDAT
; _this$ = ecx

; 1908 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1909 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1910 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1911 : 	return m_piTechEnhancedYieldChange ? m_piTechEnhancedYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+904], 0
	je	SHORT $LN3@GetTechEnh
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+904]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetTechEnh
$LN3@GetTechEnh:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetTechEnh:
	mov	eax, DWORD PTR tv69[ebp]

; 1912 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTechEnhancedYieldChange@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetTechEnhancedYieldChange
_TEXT	ENDS
PUBLIC	?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetTechEnhancedYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetTechEnhancedYieldChangeArray, COMDAT
; _this$ = ecx

; 1916 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1917 : 	return m_piTechEnhancedYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+904]

; 1918 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechEnhancedYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetTechEnhancedYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetSeaPlotYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetSeaPlotYieldChange, COMDAT
; _this$ = ecx

; 1922 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1923 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1924 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1925 : 	return m_piSeaPlotYieldChange ? m_piSeaPlotYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+864], 0
	je	SHORT $LN3@GetSeaPlot
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+864]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetSeaPlot
$LN3@GetSeaPlot:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetSeaPlot:
	mov	eax, DWORD PTR tv69[ebp]

; 1926 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSeaPlotYieldChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetSeaPlotYieldChange
_TEXT	ENDS
PUBLIC	?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetSeaPlotYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetSeaPlotYieldChangeArray, COMDAT
; _this$ = ecx

; 1930 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1931 : 	return m_piSeaPlotYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+864]

; 1932 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSeaPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetSeaPlotYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetRiverPlotYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetRiverPlotYieldChange, COMDAT
; _this$ = ecx

; 1936 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1937 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1938 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1939 : 	return m_piRiverPlotYieldChange ? m_piRiverPlotYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+868], 0
	je	SHORT $LN3@GetRiverPl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+868]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetRiverPl
$LN3@GetRiverPl:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetRiverPl:
	mov	eax, DWORD PTR tv69[ebp]

; 1940 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetRiverPlotYieldChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetRiverPlotYieldChange
_TEXT	ENDS
PUBLIC	?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetRiverPlotYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetRiverPlotYieldChangeArray, COMDAT
; _this$ = ecx

; 1944 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1945 : 	return m_piRiverPlotYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+868]

; 1946 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRiverPlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetRiverPlotYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetLakePlotYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLakePlotYieldChange, COMDAT
; _this$ = ecx

; 1950 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1951 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1952 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1953 : 	return m_piLakePlotYieldChange ? m_piLakePlotYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+872], 0
	je	SHORT $LN3@GetLakePlo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+872]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetLakePlo
$LN3@GetLakePlo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetLakePlo:
	mov	eax, DWORD PTR tv69[ebp]

; 1954 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLakePlotYieldChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLakePlotYieldChange
_TEXT	ENDS
PUBLIC	?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetLakePlotYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetLakePlotYieldChangeArray, COMDAT
; _this$ = ecx

; 1958 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1959 : 	return m_piLakePlotYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+872]

; 1960 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLakePlotYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetLakePlotYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetSeaResourceYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetSeaResourceYieldChange, COMDAT
; _this$ = ecx

; 1964 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1965 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 1966 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1967 : 	return m_piSeaResourceYieldChange ? m_piSeaResourceYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+876], 0
	je	SHORT $LN3@GetSeaReso
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+876]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetSeaReso
$LN3@GetSeaReso:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetSeaReso:
	mov	eax, DWORD PTR tv69[ebp]

; 1968 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSeaResourceYieldChange@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetSeaResourceYieldChange
_TEXT	ENDS
PUBLIC	?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ; CvBuildingEntry::GetSeaResourceYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ PROC ; CvBuildingEntry::GetSeaResourceYieldChangeArray, COMDAT
; _this$ = ecx

; 1972 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1973 : 	return m_piSeaResourceYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+876]

; 1974 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSeaResourceYieldChangeArray@CvBuildingEntry@@QBEPAHXZ ENDP ; CvBuildingEntry::GetSeaResourceYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetUnitCombatFreeExperience
; Function compile flags: /Odtp
;	COMDAT ?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetUnitCombatFreeExperience, COMDAT
; _this$ = ecx

; 1978 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1979 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1980 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1981 : 	return m_piUnitCombatFreeExperience ? m_piUnitCombatFreeExperience[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+908], 0
	je	SHORT $LN3@GetUnitCom
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+908]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetUnitCom
$LN3@GetUnitCom:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetUnitCom:
	mov	eax, DWORD PTR tv69[ebp]

; 1982 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitCombatFreeExperience@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetUnitCombatFreeExperience
_TEXT	ENDS
PUBLIC	?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetUnitCombatProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetUnitCombatProductionModifier, COMDAT
; _this$ = ecx

; 1986 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1987 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 1988 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1989 : 	return m_piUnitCombatProductionModifiers ? m_piUnitCombatProductionModifiers[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+912], 0
	je	SHORT $LN3@GetUnitCom@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetUnitCom@2
$LN3@GetUnitCom@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetUnitCom@2:
	mov	eax, DWORD PTR tv69[ebp]

; 1990 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitCombatProductionModifier@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetUnitCombatProductionModifier
_TEXT	ENDS
PUBLIC	?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainFreeExperience
; Function compile flags: /Odtp
;	COMDAT ?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetDomainFreeExperience, COMDAT
; _this$ = ecx

; 1994 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1995 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 1996 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 1997 : 	return m_piDomainFreeExperience ? m_piDomainFreeExperience[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+916], 0
	je	SHORT $LN3@GetDomainF
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+916]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetDomainF
$LN3@GetDomainF:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetDomainF:
	mov	eax, DWORD PTR tv69[ebp]

; 1998 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDomainFreeExperience@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetDomainFreeExperience
_TEXT	ENDS
PUBLIC	?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainFreeExperiencePerGreatWork
; Function compile flags: /Odtp
;	COMDAT ?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetDomainFreeExperiencePerGreatWork, COMDAT
; _this$ = ecx

; 2002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2003 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 2004 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2005 : 	return m_piDomainFreeExperiencePerGreatWork ? m_piDomainFreeExperiencePerGreatWork[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+920], 0
	je	SHORT $LN3@GetDomainF@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+920]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetDomainF@2
$LN3@GetDomainF@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetDomainF@2:
	mov	eax, DWORD PTR tv69[ebp]

; 2006 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDomainFreeExperiencePerGreatWork@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetDomainFreeExperiencePerGreatWork
_TEXT	ENDS
PUBLIC	?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetDomainProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetDomainProductionModifier, COMDAT
; _this$ = ecx

; 2010 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2011 : 	CvAssertMsg(i < NUM_DOMAIN_TYPES, "Index out of bounds");
; 2012 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2013 : 	return m_piDomainProductionModifier ? m_piDomainProductionModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+924], 0
	je	SHORT $LN3@GetDomainP
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+924]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetDomainP
$LN3@GetDomainP:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetDomainP:
	mov	eax, DWORD PTR tv69[ebp]

; 2014 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDomainProductionModifier@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetDomainProductionModifier
_TEXT	ENDS
PUBLIC	?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetLockedBuildingClasses
; Function compile flags: /Odtp
;	COMDAT ?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLockedBuildingClasses, COMDAT
; _this$ = ecx

; 2018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2019 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2020 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2021 : 	return m_piLockedBuildingClasses ? m_piLockedBuildingClasses[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+836], 0
	je	SHORT $LN3@GetLockedB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+836]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetLockedB
$LN3@GetLockedB:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetLockedB:
	mov	eax, DWORD PTR tv69[ebp]

; 2022 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLockedBuildingClasses@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLockedBuildingClasses
_TEXT	ENDS
PUBLIC	?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetPrereqAndTechs
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetPrereqAndTechs, COMDAT
; _this$ = ecx

; 2026 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2027 : 	CvAssertMsg(i < GC.getNUM_BUILDING_AND_TECH_PREREQS(), "Index out of bounds");
; 2028 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2029 : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+840], 0
	je	SHORT $LN3@GetPrereqA
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+840]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPrereqA
$LN3@GetPrereqA:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPrereqA:
	mov	eax, DWORD PTR tv69[ebp]

; 2030 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetPrereqAndTechs
_TEXT	ENDS
PUBLIC	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceQuantityRequirement
; Function compile flags: /Odtp
;	COMDAT ?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 2034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2035 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2036 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2037 : 	return m_piResourceQuantityRequirements ? m_piResourceQuantityRequirements[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+844], 0
	je	SHORT $LN3@GetResourc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+844]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetResourc
$LN3@GetResourc:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetResourc:
	mov	eax, DWORD PTR tv69[ebp]

; 2038 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetResourceQuantity
; Function compile flags: /Odtp
;	COMDAT ?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetResourceQuantity, COMDAT
; _this$ = ecx

; 2042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2043 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2044 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2045 : 	return m_piResourceQuantity ? m_piResourceQuantity[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+848], 0
	je	SHORT $LN3@GetResourc@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+848]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetResourc@2
$LN3@GetResourc@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetResourc@2:
	mov	eax, DWORD PTR tv69[ebp]

; 2046 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceQuantity@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetResourceQuantity
_TEXT	ENDS
PUBLIC	?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceCultureChange
; Function compile flags: /Odtp
;	COMDAT ?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetResourceCultureChange, COMDAT
; _this$ = ecx

; 2050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2051 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2052 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2053 : 	return m_piResourceCultureChanges ? m_piResourceCultureChanges[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+852], 0
	je	SHORT $LN3@GetResourc@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+852]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetResourc@3
$LN3@GetResourc@3:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetResourc@3:
	mov	eax, DWORD PTR tv69[ebp]

; 2054 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceCultureChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetResourceCultureChange
_TEXT	ENDS
PUBLIC	?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceFaithChange
; Function compile flags: /Odtp
;	COMDAT ?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetResourceFaithChange, COMDAT
; _this$ = ecx

; 2058 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2059 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2060 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2061 : 	return m_piResourceFaithChanges ? m_piResourceFaithChanges[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+856], 0
	je	SHORT $LN3@GetResourc@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetResourc@4
$LN3@GetResourc@4:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetResourc@4:
	mov	eax, DWORD PTR tv69[ebp]

; 2062 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceFaithChange@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetResourceFaithChange
_TEXT	ENDS
PUBLIC	?GetProductionTraits@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetProductionTraits
; Function compile flags: /Odtp
;	COMDAT ?GetProductionTraits@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetProductionTraits@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetProductionTraits, COMDAT
; _this$ = ecx

; 2066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2067 : 	CvAssertMsg(i < GC.getNumTraitInfos(), "Index out of bounds");
; 2068 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2069 : 	return m_piProductionTraits ? m_piProductionTraits[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+860], 0
	je	SHORT $LN3@GetProduct
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetProduct
$LN3@GetProduct:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetProduct:
	mov	eax, DWORD PTR tv69[ebp]

; 2070 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetProductionTraits@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetProductionTraits
_TEXT	ENDS
PUBLIC	?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetPrereqNumOfBuildingClass
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetPrereqNumOfBuildingClass, COMDAT
; _this$ = ecx

; 2074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2075 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2076 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2077 : 	return m_piPrereqNumOfBuildingClass ? m_piPrereqNumOfBuildingClass[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+928], 0
	je	SHORT $LN3@GetPrereqN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+928]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPrereqN
$LN3@GetPrereqN:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPrereqN:
	mov	eax, DWORD PTR tv69[ebp]

; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrereqNumOfBuildingClass@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetPrereqNumOfBuildingClass
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetFlavorValue@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFlavorValue@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 2082 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2083 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 2084 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2085 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+932], 0
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetFlavorV
$LN3@GetFlavorV:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetFlavorV:
	mov	eax, DWORD PTR tv69[ebp]

; 2086 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFlavorValue@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetLocalResourceAnd
; Function compile flags: /Odtp
;	COMDAT ?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLocalResourceAnd, COMDAT
; _this$ = ecx

; 2090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2091 : 	CvAssertMsg(i < GC.getNUM_BUILDING_RESOURCE_PREREQS(), "Index out of bounds");
; 2092 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2093 : 	return m_piLocalResourceAnds ? m_piLocalResourceAnds[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+936], 0
	je	SHORT $LN3@GetLocalRe
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetLocalRe
$LN3@GetLocalRe:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetLocalRe:
	mov	eax, DWORD PTR tv69[ebp]

; 2094 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLocalResourceAnd@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLocalResourceAnd
_TEXT	ENDS
PUBLIC	?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetLocalResourceOr
; Function compile flags: /Odtp
;	COMDAT ?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z PROC	; CvBuildingEntry::GetLocalResourceOr, COMDAT
; _this$ = ecx

; 2098 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2099 : 	CvAssertMsg(i < GC.getNUM_BUILDING_RESOURCE_PREREQS(), "Index out of bounds");
; 2100 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2101 : 	return m_piLocalResourceOrs ? m_piLocalResourceOrs[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+940], 0
	je	SHORT $LN3@GetLocalRe@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetLocalRe@2
$LN3@GetLocalRe@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetLocalRe@2:
	mov	eax, DWORD PTR tv69[ebp]

; 2102 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLocalResourceOr@CvBuildingEntry@@QBEHH@Z ENDP	; CvBuildingEntry::GetLocalResourceOr
_TEXT	ENDS
PUBLIC	?GetHurryModifier@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetHurryModifier
; Function compile flags: /Odtp
;	COMDAT ?GetHurryModifier@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetHurryModifier@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetHurryModifier, COMDAT
; _this$ = ecx

; 2106 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2107 : 	CvAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
; 2108 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2109 : 	return m_paiHurryModifier ? m_paiHurryModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+944], 0
	je	SHORT $LN3@GetHurryMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+944]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetHurryMo
$LN3@GetHurryMo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetHurryMo:
	mov	eax, DWORD PTR tv69[ebp]

; 2110 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetHurryModifier@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetHurryModifier
_TEXT	ENDS
PUBLIC	?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z ; CvBuildingEntry::IsBuildingClassNeededInCity
; Function compile flags: /Odtp
;	COMDAT ?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z
_TEXT	SEGMENT
tv68 = -5						; size = 1
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z PROC ; CvBuildingEntry::IsBuildingClassNeededInCity, COMDAT
; _this$ = ecx

; 2114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2115 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2116 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2117 : 	return m_pbBuildingClassNeededInCity ? m_pbBuildingClassNeededInCity[i] : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+948], 0
	je	SHORT $LN3@IsBuilding
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+948]
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR tv68[ebp], cl
	jmp	SHORT $LN4@IsBuilding
$LN3@IsBuilding:
	mov	BYTE PTR tv68[ebp], 0
$LN4@IsBuilding:
	mov	al, BYTE PTR tv68[ebp]

; 2118 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsBuildingClassNeededInCity@CvBuildingEntry@@QBE_NH@Z ENDP ; CvBuildingEntry::IsBuildingClassNeededInCity
_TEXT	ENDS
PUBLIC	?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z	; CvBuildingEntry::GetNumFreeUnits
; Function compile flags: /Odtp
;	COMDAT ?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z PROC		; CvBuildingEntry::GetNumFreeUnits, COMDAT
; _this$ = ecx

; 2122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2123 : 	CvAssertMsg(i < GC.getNumUnitInfos(), "Index out of bounds");
; 2124 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2125 : 	return m_piNumFreeUnits ? m_piNumFreeUnits[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	je	SHORT $LN3@GetNumFree
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+952]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetNumFree
$LN3@GetNumFree:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetNumFree:
	mov	eax, DWORD PTR tv69[ebp]

; 2126 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumFreeUnits@CvBuildingEntry@@QBEHH@Z ENDP		; CvBuildingEntry::GetNumFreeUnits
_TEXT	ENDS
PUBLIC	?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetResourceYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z PROC	; CvBuildingEntry::GetResourceYieldChange, COMDAT
; _this$ = ecx

; 2130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2131 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2132 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2133 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2134 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2135 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2136 : 	return m_ppaiResourceYieldChange.first ? (m_ppaiResourceYieldChange.first)[i][j] : -1;
; 2137 : #else
; 2138 : 	return m_ppaiResourceYieldChange ? m_ppaiResourceYieldChange[i][j] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+956], 0
	je	SHORT $LN3@GetResourc@5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetResourc@5
$LN3@GetResourc@5:
	mov	DWORD PTR tv71[ebp], -1
$LN4@GetResourc@5:
	mov	eax, DWORD PTR tv71[ebp]

; 2139 : #endif
; 2140 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetResourceYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP	; CvBuildingEntry::GetResourceYieldChange
_TEXT	ENDS
PUBLIC	?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetResourceYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetResourceYieldChangeArray, COMDAT
; _this$ = ecx

; 2144 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2145 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2146 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2147 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2148 : 	return m_ppaiResourceYieldChange.first ? m_ppaiResourceYieldChange.first[i] : NULL;
; 2149 : #else
; 2150 : 	return m_ppaiResourceYieldChange[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+956]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2151 : #endif
; 2152 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetResourceYieldChangeArray
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find
PUBLIC	?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetResourceYieldChangeGlobal
; Function compile flags: /Odtp
;	COMDAT ?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T228285 = -92						; size = 4
$T228280 = -88						; size = 4
$T228181 = -52						; size = 4
$T228120 = -16						; size = 4
$T228119 = -12						; size = 4
_itYield$219408 = -8					; size = 4
_itResource$ = -4					; size = 4
_iResource$ = 8						; size = 4
_iYieldType$ = 12					; size = 4
?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetResourceYieldChangeGlobal, COMDAT
; _this$ = ecx

; 2155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 2156 : 	CvAssertMsg(iResource < GC.getNumResourceInfos(), "Index out of bounds");
; 2157 : 	CvAssertMsg(iResource > -1, "Index out of bounds");
; 2158 : 	CvAssertMsg(iYieldType < NUM_YIELD_TYPES, "Index out of bounds");
; 2159 : 	CvAssertMsg(iYieldType > -1, "Index out of bounds");
; 2160 : 	std::map<int, std::map<int, int>>::const_iterator itResource = m_ppiResourceYieldChangeGlobal.find(iResource);

	lea	eax, DWORD PTR _iResource$[ebp]
	push	eax
	lea	ecx, DWORD PTR _itResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	call	?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find

; 2161 : 	if (itResource != m_ppiResourceYieldChangeGlobal.end()) // find returns the iterator to map::end if the key iResource is not present in the map

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+968]
	mov	DWORD PTR $T228181[ebp], eax
	mov	ecx, DWORD PTR $T228181[ebp]
	mov	DWORD PTR $T228119[ebp], ecx
	mov	edx, DWORD PTR _itResource$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T228119[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@GetResourc@6

; 2162 : 	{
; 2163 : 		std::map<int, int>::const_iterator itYield = itResource->second.find(iYieldType);

	lea	eax, DWORD PTR _iYieldType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _itYield$219408[ebp]
	push	ecx
	mov	ecx, DWORD PTR _itResource$[ebp]
	add	ecx, 16					; 00000010H
	call	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find

; 2164 : 		if (itYield != itResource->second.end()) // find returns the iterator to map::end if the key iYield is not present in the map

	mov	edx, DWORD PTR _itResource$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T228280[ebp], edx
	mov	eax, DWORD PTR $T228280[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T228285[ebp], ecx
	mov	edx, DWORD PTR $T228285[ebp]
	mov	DWORD PTR $T228120[ebp], edx
	mov	eax, DWORD PTR _itYield$219408[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T228120[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@GetResourc@6

; 2165 : 		{
; 2166 : 			return itYield->second;

	mov	ecx, DWORD PTR _itYield$219408[ebp]
	mov	eax, DWORD PTR [ecx+16]
	jmp	SHORT $LN3@GetResourc@6
$LN2@GetResourc@6:

; 2167 : 		}
; 2168 : 	}
; 2169 : 
; 2170 : 	return 0;

	xor	eax, eax
$LN3@GetResourc@6:

; 2171 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetResourceYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetResourceYieldChangeGlobal
_TEXT	ENDS
PUBLIC	?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetFeatureYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z PROC	; CvBuildingEntry::GetFeatureYieldChange, COMDAT
; _this$ = ecx

; 2174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2175 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 2176 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2177 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2178 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2179 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2180 : 	return m_ppaiFeatureYieldChange.first ? (m_ppaiFeatureYieldChange.first)[i][j] : -1;
; 2181 : #else
; 2182 : 	return m_ppaiFeatureYieldChange ? m_ppaiFeatureYieldChange[i][j] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+960], 0
	je	SHORT $LN3@GetFeature
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+960]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetFeature
$LN3@GetFeature:
	mov	DWORD PTR tv71[ebp], -1
$LN4@GetFeature:
	mov	eax, DWORD PTR tv71[ebp]

; 2183 : #endif
; 2184 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetFeatureYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP	; CvBuildingEntry::GetFeatureYieldChange
_TEXT	ENDS
PUBLIC	?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetFeatureYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetFeatureYieldChangeArray, COMDAT
; _this$ = ecx

; 2188 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2189 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 2190 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2191 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2192 : 	return m_ppaiFeatureYieldChange.first ? m_ppaiFeatureYieldChange.first[i] : NULL;
; 2193 : #else
; 2194 : 	return m_ppaiFeatureYieldChange[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+960]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2195 : #endif
; 2196 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFeatureYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetFeatureYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetImprovementYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChange, COMDAT
; _this$ = ecx

; 2199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2200 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2201 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2202 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2203 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2204 : 	return m_ppaiImprovementYieldChange ? m_ppaiImprovementYieldChange[i][j] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+976], 0
	je	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+976]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetImprove
$LN3@GetImprove:
	mov	DWORD PTR tv71[ebp], -1
$LN4@GetImprove:
	mov	eax, DWORD PTR tv71[ebp]

; 2205 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetImprovementYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChange
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetImprovementYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChangeArray, COMDAT
; _this$ = ecx

; 2209 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2210 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2211 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2212 : 	return m_ppaiImprovementYieldChange[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+976]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImprovementYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetImprovementYieldChangeGlobal
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChangeGlobal, COMDAT
; _this$ = ecx

; 2216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2217 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2218 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2219 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2220 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2221 : 	return m_ppaiImprovementYieldChangeGlobal ? m_ppaiImprovementYieldChangeGlobal[i][j] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+980], 0
	je	SHORT $LN3@GetImprove@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+980]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetImprove@2
$LN3@GetImprove@2:
	mov	DWORD PTR tv71[ebp], -1
$LN4@GetImprove@2:
	mov	eax, DWORD PTR tv71[ebp]

; 2222 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetImprovementYieldChangeGlobal@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChangeGlobal
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetImprovementYieldChangeGlobalArray
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetImprovementYieldChangeGlobalArray, COMDAT
; _this$ = ecx

; 2226 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2227 : 	CvAssertMsg(i < GC.getNumFeatureInfos(), "Index out of bounds");
; 2228 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2229 : 	return m_ppaiImprovementYieldChangeGlobal[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+980]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2230 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImprovementYieldChangeGlobalArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetImprovementYieldChangeGlobalArray
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetSpecialistYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetSpecialistYieldChange, COMDAT
; _this$ = ecx

; 2238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2239 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2240 : #ifndef AUI_WARNING_FIXES
; 2241 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2242 : #endif
; 2243 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2244 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2245 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2246 : 	return m_ppaiSpecialistYieldChange.first ? (m_ppaiSpecialistYieldChange.first)[i][j] : -1;
; 2247 : #else
; 2248 : 	return m_ppaiSpecialistYieldChange ? m_ppaiSpecialistYieldChange[i][j] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN3@GetSpecial
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+984]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetSpecial
$LN3@GetSpecial:
	mov	DWORD PTR tv71[ebp], -1
$LN4@GetSpecial:
	mov	eax, DWORD PTR tv71[ebp]

; 2249 : #endif
; 2250 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetSpecialistYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetSpecialistYieldChange
_TEXT	ENDS
PUBLIC	?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetSpecialistYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetSpecialistYieldChangeArray, COMDAT
; _this$ = ecx

; 2254 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2255 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2256 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2257 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2258 : 	return m_ppaiSpecialistYieldChange.first ? m_ppaiSpecialistYieldChange.first[i] : NULL;
; 2259 : #else
; 2260 : 	return m_ppaiSpecialistYieldChange[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+984]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2261 : #endif
; 2262 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSpecialistYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetSpecialistYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetResourceYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetResourceYieldModifier, COMDAT
; _this$ = ecx

; 2266 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2267 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2268 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2269 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2270 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2271 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2272 : 	return m_ppaiResourceYieldModifier.first ? (m_ppaiResourceYieldModifier.first)[i][j] : -1;
; 2273 : #else
; 2274 : 	return m_ppaiResourceYieldModifier ? m_ppaiResourceYieldModifier[i][j] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+988], 0
	je	SHORT $LN3@GetResourc@7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+988]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetResourc@7
$LN3@GetResourc@7:
	mov	DWORD PTR tv71[ebp], -1
$LN4@GetResourc@7:
	mov	eax, DWORD PTR tv71[ebp]

; 2275 : #endif
; 2276 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetResourceYieldModifier@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetResourceYieldModifier
_TEXT	ENDS
PUBLIC	?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetResourceYieldModifierArray
; Function compile flags: /Odtp
;	COMDAT ?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetResourceYieldModifierArray, COMDAT
; _this$ = ecx

; 2280 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2281 : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 2282 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2283 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2284 : 	return m_ppaiResourceYieldModifier.first ? m_ppaiResourceYieldModifier.first[i] : NULL;
; 2285 : #else
; 2286 : 	return m_ppaiResourceYieldModifier[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+988]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2287 : #endif
; 2288 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceYieldModifierArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetResourceYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetTerrainYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z PROC	; CvBuildingEntry::GetTerrainYieldChange, COMDAT
; _this$ = ecx

; 2292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2293 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 2294 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2295 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2296 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2297 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2298 : 	return m_ppaiTerrainYieldChange.first ? (m_ppaiTerrainYieldChange.first)[i][j] : -1;
; 2299 : #else
; 2300 : 	return m_ppaiTerrainYieldChange ? m_ppaiTerrainYieldChange[i][j] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+992], 0
	je	SHORT $LN3@GetTerrain
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+992]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@GetTerrain
$LN3@GetTerrain:
	mov	DWORD PTR tv71[ebp], -1
$LN4@GetTerrain:
	mov	eax, DWORD PTR tv71[ebp]

; 2301 : #endif
; 2302 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTerrainYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP	; CvBuildingEntry::GetTerrainYieldChange
_TEXT	ENDS
PUBLIC	?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ; CvBuildingEntry::GetTerrainYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z PROC ; CvBuildingEntry::GetTerrainYieldChangeArray, COMDAT
; _this$ = ecx

; 2306 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2307 : 	CvAssertMsg(i < GC.getNumTerrainInfos(), "Index out of bounds");
; 2308 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2309 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2310 : 	return m_ppaiTerrainYieldChange.first ? m_ppaiTerrainYieldChange.first[i] : NULL;
; 2311 : #else
; 2312 : 	return m_ppaiTerrainYieldChange[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+992]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2313 : #endif
; 2314 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTerrainYieldChangeArray@CvBuildingEntry@@QBEPAHH@Z ENDP ; CvBuildingEntry::GetTerrainYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z ; CvBuildingEntry::GetBuildingClassYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z PROC ; CvBuildingEntry::GetBuildingClassYieldChange, COMDAT
; _this$ = ecx

; 2318 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2319 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2320 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2321 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2322 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2323 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2324 : 	return m_ppiBuildingClassYieldChanges.first ? (m_ppiBuildingClassYieldChanges.first)[i][j] : -1;
; 2325 : #else
; 2326 : 	return m_ppiBuildingClassYieldChanges[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+996]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2327 : #endif
; 2328 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBuildingClassYieldChange@CvBuildingEntry@@QBEHHH@Z ENDP ; CvBuildingEntry::GetBuildingClassYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetBuildingClassHappiness
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z PROC ; CvBuildingEntry::GetBuildingClassHappiness, COMDAT
; _this$ = ecx

; 2332 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2333 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2334 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2335 : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1000], 0
	je	SHORT $LN3@GetBuildin@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1000]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetBuildin@2
$LN3@GetBuildin@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetBuildin@2:
	mov	eax, DWORD PTR tv69[ebp]

; 2336 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingClassHappiness@CvBuildingEntry@@QBEHH@Z ENDP ; CvBuildingEntry::GetBuildingClassHappiness
_TEXT	ENDS
PUBLIC	?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ; CvBuildingEntry::GetThemingBonusInfo
; Function compile flags: /Odtp
;	COMDAT ?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z PROC ; CvBuildingEntry::GetThemingBonusInfo, COMDAT
; _this$ = ecx

; 2339 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2340 : 	CvAssertMsg(i < MAX_THEMING_BONUSES, "Index out of bounds");
; 2341 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2342 : 
; 2343 : 	if (m_paThemingBonusInfo[0].m_iBonus == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1004]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN2@GetTheming

; 2344 : 	{
; 2345 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@GetTheming

; 2346 : 	}
; 2347 : 	else

	jmp	SHORT $LN3@GetTheming
$LN2@GetTheming:

; 2348 : 	{
; 2349 : 		return &m_paThemingBonusInfo[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+1004]
$LN3@GetTheming:

; 2350 : 	}
; 2351 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetThemingBonusInfo@CvBuildingEntry@@QBEPAVCvThemingBonusInfo@@H@Z ENDP ; CvBuildingEntry::GetThemingBonusInfo
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Buy
PUBLIC	??0CvBuildingXMLEntries@@QAE@XZ			; CvBuildingXMLEntries::CvBuildingXMLEntries
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvBuildingXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBuildingXMLEntries@@QAE@XZ$1
__ehfuncinfo$??0CvBuildingXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvBuildingXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvBuildingXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T228390 = -30						; size = 1
$T228377 = -29						; size = 1
$T228373 = -28						; size = 4
$T228366 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvBuildingXMLEntries@@QAE@XZ PROC			; CvBuildingXMLEntries::CvBuildingXMLEntries, COMDAT
; _this$ = ecx

; 2358 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvBuildingXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T228390[ebp]
	mov	DWORD PTR $T228366[ebp], eax
	lea	ecx, DWORD PTR $T228377[ebp]
	mov	DWORD PTR $T228373[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 2359 : 
; 2360 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBuildingXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvBuildingXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvBuildingXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBuildingXMLEntries@@QAE@XZ ENDP			; CvBuildingXMLEntries::CvBuildingXMLEntries
PUBLIC	??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvBuildingXMLEntries@@QAEXXZ	; CvBuildingXMLEntries::DeleteArray
PUBLIC	??1CvBuildingXMLEntries@@QAE@XZ			; CvBuildingXMLEntries::~CvBuildingXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvBuildingXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBuildingXMLEntries@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBuildingXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvBuildingXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvBuildingXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvBuildingXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBuildingXMLEntries@@QAE@XZ PROC			; CvBuildingXMLEntries::~CvBuildingXMLEntries, COMDAT
; _this$ = ecx

; 2364 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBuildingXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2365 : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvBuildingXMLEntries@@QAEXXZ ; CvBuildingXMLEntries::DeleteArray

; 2366 : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBuildingXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
__unwindfunclet$??1CvBuildingXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvBuildingXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBuildingXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBuildingXMLEntries@@QAE@XZ ENDP			; CvBuildingXMLEntries::~CvBuildingXMLEntries
PUBLIC	?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ; CvBuildingXMLEntries::GetBuildingEntries
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ PROC ; CvBuildingXMLEntries::GetBuildingEntries, COMDAT
; _this$ = ecx

; 2370 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2371 : 	return m_paBuildingEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 2372 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingEntries@CvBuildingXMLEntries@@QAEAAV?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@XZ ENDP ; CvBuildingXMLEntries::GetBuildingEntries
_TEXT	ENDS
PUBLIC	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ	; CvBuildingXMLEntries::GetNumBuildings
; Function compile flags: /Odtp
;	COMDAT ?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ PROC	; CvBuildingXMLEntries::GetNumBuildings, COMDAT
; _this$ = ecx

; 2380 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2381 : 	return m_paBuildingEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 2382 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ENDP	; CvBuildingXMLEntries::GetNumBuildings
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvBuildingXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv143 = -116						; size = 4
_this$ = -112						; size = 4
$T228633 = -56						; size = 4
$T228617 = -52						; size = 4
$T228738 = -48						; size = 4
$T228737 = -44						; size = 4
$T228736 = -40						; size = 4
$T228735 = -36						; size = 4
$T228734 = -32						; size = 4
$T228601 = -28						; size = 4
$T228594 = -24						; size = 4
$T228593 = -20						; size = 4
$T228560 = -16						; size = 4
$T228536 = -12						; size = 4
$T228526 = -8						; size = 4
_it$219705 = -4						; size = 4
?DeleteArray@CvBuildingXMLEntries@@QAEXXZ PROC		; CvBuildingXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 2386 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 2387 : 	for(std::vector<CvBuildingEntry*>::iterator it = m_paBuildingEntries.begin(); it != m_paBuildingEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228536[ebp], ecx
	mov	edx, DWORD PTR $T228536[ebp]
	mov	DWORD PTR _it$219705[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$219705[ebp]
	add	eax, 4
	mov	DWORD PTR _it$219705[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228560[ebp], edx
	mov	eax, DWORD PTR $T228560[ebp]
	mov	DWORD PTR $T228526[ebp], eax
	mov	ecx, DWORD PTR _it$219705[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T228526[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 2388 : 	{
; 2389 : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$219705[ebp]
	mov	DWORD PTR $T228601[ebp], edx
	mov	eax, DWORD PTR $T228601[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T228594[ebp], ecx
	mov	edx, DWORD PTR $T228594[ebp]
	mov	DWORD PTR $T228593[ebp], edx
	cmp	DWORD PTR $T228593[ebp], 0
	je	SHORT $LN32@DeleteArra
	mov	ecx, DWORD PTR $T228593[ebp]
	call	??1CvBuildingEntry@@QAE@XZ		; CvBuildingEntry::~CvBuildingEntry
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN35@DeleteArra
	mov	ecx, DWORD PTR $T228593[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@DeleteArra:
	mov	edx, DWORD PTR $T228593[ebp]
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv143[ebp], 0
$LN33@DeleteArra:
	mov	eax, DWORD PTR $T228601[ebp]
	mov	DWORD PTR [eax], 0

; 2390 : 	}

	jmp	$LN2@DeleteArra
$LN1@DeleteArra:

; 2391 : 
; 2392 : 	m_paBuildingEntries.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T228617[ebp], edx
	mov	eax, DWORD PTR $T228617[ebp]
	mov	DWORD PTR $T228735[ebp], eax
	mov	ecx, DWORD PTR $T228735[ebp]
	mov	DWORD PTR $T228734[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T228633[ebp], eax
	mov	ecx, DWORD PTR $T228633[ebp]
	mov	DWORD PTR $T228737[ebp], ecx
	mov	edx, DWORD PTR $T228737[ebp]
	mov	DWORD PTR $T228736[ebp], edx
	mov	eax, DWORD PTR $T228734[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228736[ebp]
	push	ecx
	lea	edx, DWORD PTR $T228738[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::erase

; 2393 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvBuildingXMLEntries@@QAEXXZ ENDP		; CvBuildingXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z PROC ; CvBuildingXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 2401 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2402 : 	return m_paBuildingEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2403 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ENDP ; CvBuildingXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >
PUBLIC	??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
PUBLIC	??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >
PUBLIC	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Buy
PUBLIC	?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Buy
PUBLIC	?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
PUBLIC	??0CvCityBuildings@@QAE@XZ			; CvCityBuildings::CvCityBuildings
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__ehfuncinfo$??0CvCityBuildings@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CvCityBuildings@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvCityBuildings@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCityBuildings@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvCityBuildings@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvCityBuildings@@QAE@XZ$6
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvCityBuildings@@QAE@XZ$1
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvCityBuildings@@QAE@XZ$9
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvCityBuildings@@QAE@XZ
_TEXT	SEGMENT
tv263 = -340						; size = 4
tv292 = -336						; size = 4
tv208 = -332						; size = 4
tv237 = -328						; size = 4
tv157 = -324						; size = 4
tv182 = -320						; size = 4
_this$ = -316						; size = 4
$T228972 = -312						; size = 4
$T228931 = -222						; size = 1
$T228918 = -221						; size = 1
$T228914 = -220						; size = 4
$T228907 = -212						; size = 4
$T228900 = -204						; size = 4
$T228861 = -126						; size = 1
$T228848 = -125						; size = 1
$T228844 = -124						; size = 4
$T228837 = -116						; size = 4
$T228830 = -108						; size = 4
$T228791 = -30						; size = 1
$T228778 = -29						; size = 1
$T228774 = -28						; size = 4
$T228767 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvCityBuildings@@QAE@XZ PROC				; CvCityBuildings::CvCityBuildings, COMDAT
; _this$ = ecx

; 2437 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvCityBuildings@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 328				; 00000148H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	mov	DWORD PTR $T228830[ebp], eax
	lea	ecx, DWORD PTR $T228791[ebp]
	mov	DWORD PTR $T228767[ebp], ecx
	lea	edx, DWORD PTR $T228778[ebp]
	mov	DWORD PTR $T228774[ebp], edx
	mov	eax, DWORD PTR $T228830[ebp]
	mov	DWORD PTR tv182[ebp], eax
	mov	ecx, DWORD PTR $T228830[ebp]
	mov	DWORD PTR tv157[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR $T228830[ebp]
	call	?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR $T228900[ebp], edx
	lea	eax, DWORD PTR $T228861[ebp]
	mov	DWORD PTR $T228837[ebp], eax
	lea	ecx, DWORD PTR $T228848[ebp]
	mov	DWORD PTR $T228844[ebp], ecx
	mov	edx, DWORD PTR $T228900[ebp]
	mov	DWORD PTR tv237[ebp], edx
	mov	eax, DWORD PTR $T228900[ebp]
	mov	DWORD PTR tv208[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	0
	mov	ecx, DWORD PTR $T228900[ebp]
	call	?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR $T228972[ebp], ecx
	lea	edx, DWORD PTR $T228931[ebp]
	mov	DWORD PTR $T228907[ebp], edx
	lea	eax, DWORD PTR $T228918[ebp]
	mov	DWORD PTR $T228914[ebp], eax
	mov	ecx, DWORD PTR $T228972[ebp]
	mov	DWORD PTR tv292[ebp], ecx
	mov	edx, DWORD PTR $T228972[ebp]
	mov	DWORD PTR tv263[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	0
	mov	ecx, DWORD PTR $T228972[ebp]
	call	?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0

; 2438 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvCityBuildings@@QAE@XZ$3:
	mov	ecx, DWORD PTR $T228830[ebp]
	jmp	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvCityBuildings@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
__unwindfunclet$??0CvCityBuildings@@QAE@XZ$6:
	mov	ecx, DWORD PTR $T228900[ebp]
	jmp	??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvCityBuildings@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
__unwindfunclet$??0CvCityBuildings@@QAE@XZ$9:
	mov	ecx, DWORD PTR $T228972[ebp]
	jmp	??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ
__ehhandler$??0CvCityBuildings@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-332]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvCityBuildings@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvCityBuildings@@QAE@XZ ENDP				; CvCityBuildings::CvCityBuildings
PUBLIC	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
PUBLIC	?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy
PUBLIC	?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Tidy
PUBLIC	??1CvCityBuildings@@QAE@XZ			; CvCityBuildings::~CvCityBuildings
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__ehfuncinfo$??1CvCityBuildings@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1CvCityBuildings@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvCityBuildings@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvCityBuildings@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvCityBuildings@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvCityBuildings@@QAE@XZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvCityBuildings@@QAE@XZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvCityBuildings@@QAE@XZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvCityBuildings@@QAE@XZ
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T229241 = -120						; size = 4
$T229155 = -84						; size = 4
$T229069 = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1CvCityBuildings@@QAE@XZ PROC				; CvCityBuildings::~CvCityBuildings, COMDAT
; _this$ = ecx

; 2442 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvCityBuildings@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2443 : }

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	mov	DWORD PTR $T229069[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T229069[ebp]
	call	?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR $T229155[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T229155[ebp]
	call	?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR $T229241[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T229241[ebp]
	call	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvCityBuildings@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
__unwindfunclet$??1CvCityBuildings@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
__unwindfunclet$??1CvCityBuildings@@QAE@XZ$3:
	mov	ecx, DWORD PTR $T229069[ebp]
	jmp	??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvCityBuildings@@QAE@XZ$5:
	mov	ecx, DWORD PTR $T229155[ebp]
	jmp	??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvCityBuildings@@QAE@XZ$7:
	mov	ecx, DWORD PTR $T229241[ebp]
	jmp	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1CvCityBuildings@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvCityBuildings@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvCityBuildings@@QAE@XZ ENDP				; CvCityBuildings::~CvCityBuildings
PUBLIC	?Reset@CvCityBuildings@@QAEXXZ			; CvCityBuildings::Reset
PUBLIC	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
PUBLIC	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
PUBLIC	?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z ; CvCityBuildings::Init
; Function compile flags: /Odtp
;	COMDAT ?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -224						; size = 4
$T229653 = -220						; size = 4
$T229486 = -152						; size = 4
$T229470 = -148						; size = 4
$T229639 = -144						; size = 4
$T229638 = -140						; size = 4
$T229637 = -136						; size = 4
$T229636 = -132						; size = 4
$T229635 = -128						; size = 4
$T229454 = -124						; size = 4
$T229287 = -56						; size = 4
$T229271 = -52						; size = 4
$T229441 = -48						; size = 4
$T229440 = -44						; size = 4
$T229439 = -40						; size = 4
$T229438 = -36						; size = 4
$T229437 = -32						; size = 4
$T229255 = -28						; size = 4
$T229254 = -24						; size = 4
$T229253 = -20						; size = 4
$T229252 = -16						; size = 4
$T229251 = -12						; size = 4
$T229250 = -8						; size = 4
_iNumBuildings$ = -4					; size = 4
_pBuildings$ = 8					; size = 4
_pCity$ = 12						; size = 4
?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z PROC ; CvCityBuildings::Init, COMDAT
; _this$ = ecx

; 2447 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	DWORD PTR _this$[ebp], ecx

; 2448 : 	// Store off the pointers to objects we'll need later
; 2449 : 	m_pBuildings = pBuildings;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pBuildings$[ebp]
	mov	DWORD PTR [eax+108], ecx

; 2450 : 	m_pCity = pCity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	DWORD PTR [edx+112], eax

; 2451 : 
; 2452 : 	// Initialize status arrays
; 2453 : 
; 2454 : 	int iNumBuildings = m_pBuildings->GetNumBuildings();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+108]
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	mov	DWORD PTR _iNumBuildings$[ebp], eax

; 2455 : 
; 2456 : 	CvAssertMsg((0 < iNumBuildings),  "m_pBuildings->GetNumBuildings() is not greater than zero but an array is being allocated in CvCityBuildings::Init");
; 2457 : 
; 2458 : 	CvAssertMsg(m_paiBuildingProduction==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingProduction");
; 2459 : 	m_paiBuildingProduction = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T229250[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T229250[ebp]
	mov	DWORD PTR [eax+36], ecx

; 2460 : 
; 2461 : 	CvAssertMsg(m_paiBuildingProductionTime==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingProductionTime");
; 2462 : 	m_paiBuildingProductionTime = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T229251[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T229251[ebp]
	mov	DWORD PTR [eax+40], ecx

; 2463 : 
; 2464 : 	CvAssertMsg(m_paiBuildingOriginalOwner==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingOriginalOwner");
; 2465 : 	m_paiBuildingOriginalOwner = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T229252[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T229252[ebp]
	mov	DWORD PTR [eax+44], ecx

; 2466 : 
; 2467 : 	CvAssertMsg(m_paiBuildingOriginalTime==NULL, "about to leak memory, CvCityBuildings::m_paiBuildingOriginalTime");
; 2468 : 	m_paiBuildingOriginalTime = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T229253[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T229253[ebp]
	mov	DWORD PTR [eax+48], ecx

; 2469 : 
; 2470 : 	CvAssertMsg(m_paiNumRealBuilding==NULL, "about to leak memory, CvCityBuildings::m_paiNumRealBuilding");
; 2471 : 	m_paiNumRealBuilding = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T229254[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T229254[ebp]
	mov	DWORD PTR [eax+52], ecx

; 2472 : 
; 2473 : 	CvAssertMsg(m_paiNumFreeBuilding==NULL, "about to leak memory, CvCityBuildings::m_paiNumFreeBuilding");
; 2474 : 	m_paiNumFreeBuilding = FNEW(int[iNumBuildings], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T229255[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T229255[ebp]
	mov	DWORD PTR [eax+56], ecx

; 2475 : 
; 2476 : 	m_aBuildingYieldChange.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR $T229454[ebp], edx
	mov	eax, DWORD PTR $T229454[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T229271[ebp], ecx
	mov	edx, DWORD PTR $T229271[ebp]
	mov	DWORD PTR $T229438[ebp], edx
	mov	eax, DWORD PTR $T229438[ebp]
	mov	DWORD PTR $T229437[ebp], eax
	mov	ecx, DWORD PTR $T229454[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229287[ebp], edx
	mov	eax, DWORD PTR $T229287[ebp]
	mov	DWORD PTR $T229440[ebp], eax
	mov	ecx, DWORD PTR $T229440[ebp]
	mov	DWORD PTR $T229439[ebp], ecx
	mov	edx, DWORD PTR $T229437[ebp]
	push	edx
	mov	eax, DWORD PTR $T229439[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229441[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229454[ebp]
	call	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase

; 2477 : 	m_aBuildingGreatWork.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T229653[ebp], edx
	mov	eax, DWORD PTR $T229653[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T229470[ebp], ecx
	mov	edx, DWORD PTR $T229470[ebp]
	mov	DWORD PTR $T229636[ebp], edx
	mov	eax, DWORD PTR $T229636[ebp]
	mov	DWORD PTR $T229635[ebp], eax
	mov	ecx, DWORD PTR $T229653[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229486[ebp], edx
	mov	eax, DWORD PTR $T229486[ebp]
	mov	DWORD PTR $T229638[ebp], eax
	mov	ecx, DWORD PTR $T229638[ebp]
	mov	DWORD PTR $T229637[ebp], ecx
	mov	edx, DWORD PTR $T229635[ebp]
	push	edx
	mov	eax, DWORD PTR $T229637[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229639[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229653[ebp]
	call	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase

; 2478 : 
; 2479 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvCityBuildings@@QAEXXZ		; CvCityBuildings::Reset

; 2480 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Init@CvCityBuildings@@QAEXPAVCvBuildingXMLEntries@@PAVCvCity@@@Z ENDP ; CvCityBuildings::Init
_TEXT	ENDS
PUBLIC	?Uninit@CvCityBuildings@@QAEXXZ			; CvCityBuildings::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvCityBuildings@@QAEXXZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T229691 = -48						; size = 4
$T229689 = -44						; size = 4
$T229685 = -40						; size = 4
$T229683 = -36						; size = 4
$T229679 = -32						; size = 4
$T229677 = -28						; size = 4
$T229673 = -24						; size = 4
$T229671 = -20						; size = 4
$T229667 = -16						; size = 4
$T229665 = -12						; size = 4
$T229661 = -8						; size = 4
$T229659 = -4						; size = 4
?Uninit@CvCityBuildings@@QAEXXZ PROC			; CvCityBuildings::Uninit, COMDAT
; _this$ = ecx

; 2484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 2485 : 	SAFE_DELETE_ARRAY(m_paiBuildingProduction);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR $T229661[ebp], eax
	mov	ecx, DWORD PTR $T229661[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T229659[ebp], edx
	mov	eax, DWORD PTR $T229659[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T229661[ebp]
	mov	DWORD PTR [ecx], 0

; 2486 : 	SAFE_DELETE_ARRAY(m_paiBuildingProductionTime);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	DWORD PTR $T229667[ebp], edx
	mov	eax, DWORD PTR $T229667[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T229665[ebp], ecx
	mov	edx, DWORD PTR $T229665[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T229667[ebp]
	mov	DWORD PTR [eax], 0

; 2487 : 	SAFE_DELETE_ARRAY(m_paiBuildingOriginalOwner);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	DWORD PTR $T229673[ebp], ecx
	mov	edx, DWORD PTR $T229673[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T229671[ebp], eax
	mov	ecx, DWORD PTR $T229671[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T229673[ebp]
	mov	DWORD PTR [edx], 0

; 2488 : 	SAFE_DELETE_ARRAY(m_paiBuildingOriginalTime);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR $T229679[ebp], eax
	mov	ecx, DWORD PTR $T229679[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T229677[ebp], edx
	mov	eax, DWORD PTR $T229677[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T229679[ebp]
	mov	DWORD PTR [ecx], 0

; 2489 : 	SAFE_DELETE_ARRAY(m_paiNumRealBuilding);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	mov	DWORD PTR $T229685[ebp], edx
	mov	eax, DWORD PTR $T229685[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T229683[ebp], ecx
	mov	edx, DWORD PTR $T229683[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T229685[ebp]
	mov	DWORD PTR [eax], 0

; 2490 : 	SAFE_DELETE_ARRAY(m_paiNumFreeBuilding);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	mov	DWORD PTR $T229691[ebp], ecx
	mov	edx, DWORD PTR $T229691[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T229689[ebp], eax
	mov	ecx, DWORD PTR $T229689[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T229691[ebp]
	mov	DWORD PTR [edx], 0

; 2491 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvCityBuildings@@QAEXXZ ENDP			; CvCityBuildings::Uninit
_TEXT	ENDS
PUBLIC	?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::erase
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvCityBuildings@@QAEXXZ
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T229892 = -100						; size = 4
$T229725 = -32						; size = 4
$T229709 = -28						; size = 4
$T229879 = -24						; size = 4
$T229878 = -20						; size = 4
$T229877 = -16						; size = 4
$T229876 = -12						; size = 4
$T229875 = -8						; size = 4
_iI$ = -4						; size = 4
?Reset@CvCityBuildings@@QAEXXZ PROC			; CvCityBuildings::Reset, COMDAT
; _this$ = ecx

; 2495 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 2496 : #ifdef AUI_WARNING_FIXES
; 2497 : 	uint iI;
; 2498 : #else
; 2499 : 	int iI;
; 2500 : #endif
; 2501 : 
; 2502 : 	// Initialize non-arrays
; 2503 : 	m_iNumBuildings = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2504 : 	m_iBuildingProductionModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 2505 : 	m_iBuildingDefense = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 2506 : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 2507 : 	m_iBuildingDefensePerCitizen = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 2508 : #endif
; 2509 : 	m_iBuildingDefenseMod = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 2510 : 	m_iMissionaryExtraSpreads = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 2511 : 	m_iLandmarksTourismPercent = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 2512 : 	m_iGreatWorksTourismModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 2513 : 
; 2514 : 	m_bSoldBuildingThisTurn = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+32], 0

; 2515 : 
; 2516 : 	for(iI = 0; iI < m_pBuildings->GetNumBuildings(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+108]
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN1@Reset

; 2517 : 	{
; 2518 : 		m_paiBuildingProduction[iI] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 2519 : 		m_paiBuildingProductionTime[iI] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 2520 : 		m_paiBuildingOriginalOwner[iI] = NO_PLAYER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 2521 : 		m_paiBuildingOriginalTime[iI] = MIN_INT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -2147483648	; 80000000H

; 2522 : 		m_paiNumRealBuilding[iI] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 2523 : 		m_paiNumFreeBuilding[iI] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 2524 : 	}

	jmp	SHORT $LN2@Reset
$LN1@Reset:

; 2525 : 
; 2526 : 	m_buildingsThatExistAtLeastOnce.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	mov	DWORD PTR $T229892[ebp], edx
	mov	eax, DWORD PTR $T229892[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T229709[ebp], ecx
	mov	edx, DWORD PTR $T229709[ebp]
	mov	DWORD PTR $T229876[ebp], edx
	mov	eax, DWORD PTR $T229876[ebp]
	mov	DWORD PTR $T229875[ebp], eax
	mov	ecx, DWORD PTR $T229892[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T229725[ebp], edx
	mov	eax, DWORD PTR $T229725[ebp]
	mov	DWORD PTR $T229878[ebp], eax
	mov	ecx, DWORD PTR $T229878[ebp]
	mov	DWORD PTR $T229877[ebp], ecx
	mov	edx, DWORD PTR $T229875[ebp]
	push	edx
	mov	eax, DWORD PTR $T229877[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229879[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T229892[ebp]
	call	?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::erase

; 2527 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvCityBuildings@@QAEXXZ ENDP			; CvCityBuildings::Reset
_TEXT	ENDS
PUBLIC	??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; operator>><BuildingGreatWork>
PUBLIC	??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; operator>><BuildingYieldChange>
PUBLIC	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
PUBLIC	?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z	; CvCityBuildings::Read
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z PROC	; CvCityBuildings::Read, COMDAT
; _this$ = ecx

; 2532 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2533 : 	CvAssertMsg(m_pBuildings != NULL && m_pBuildings->GetNumBuildings() > 0, "Number of buildings to serialize is expected to greater than 0");
; 2534 : 
; 2535 : 	// Version number to maintain backwards compatibility
; 2536 : 	uint uiVersion;
; 2537 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2538 : 
; 2539 : 	kStream >> m_iNumBuildings;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2540 : 	kStream >> m_iBuildingProductionModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2541 : 	kStream >> m_iBuildingDefense;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2542 : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 2543 : 	kStream >> m_iBuildingDefensePerCitizen;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2544 : #endif
; 2545 : 	kStream >> m_iBuildingDefenseMod;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2546 : 	kStream >> m_iMissionaryExtraSpreads;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2547 : 	kStream >> m_iLandmarksTourismPercent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2548 : 	kStream >> m_iGreatWorksTourismModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2549 : 
; 2550 : 	kStream >> m_bSoldBuildingThisTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2551 : 
; 2552 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingProduction);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 8

; 2553 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingProductionTime);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 8

; 2554 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingOriginalOwner);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 8

; 2555 : 	BuildingArrayHelpers::Read(kStream, m_paiBuildingOriginalTime);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 8

; 2556 : 	BuildingArrayHelpers::Read(kStream, m_paiNumRealBuilding);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 8

; 2557 : 	BuildingArrayHelpers::Read(kStream, m_paiNumFreeBuilding);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; BuildingArrayHelpers::Read
	add	esp, 8

; 2558 : 
; 2559 : 	kStream >> m_aBuildingYieldChange;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; operator>><BuildingYieldChange>
	add	esp, 8

; 2560 : 	kStream >> m_aBuildingGreatWork;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; operator>><BuildingGreatWork>
	add	esp, 8

; 2561 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvCityBuildings@@QAEXAAVFDataStream@@@Z ENDP	; CvCityBuildings::Read
_TEXT	ENDS
PUBLIC	??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; operator<<<BuildingGreatWork>
PUBLIC	??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; operator<<<BuildingYieldChange>
PUBLIC	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
PUBLIC	?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z	; CvCityBuildings::Write
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iNumBuildings$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z PROC	; CvCityBuildings::Write, COMDAT
; _this$ = ecx

; 2565 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2566 : 	CvAssertMsg(m_pBuildings != NULL && m_pBuildings->GetNumBuildings() > 0, "Number of buildings to serialize is expected to greater than 0");
; 2567 : 
; 2568 : 	// Current version number
; 2569 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 2570 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2571 : 
; 2572 : 	kStream << m_iNumBuildings;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2573 : 	kStream << m_iBuildingProductionModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2574 : 	kStream << m_iBuildingDefense;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2575 : #ifdef NQ_BUILDING_DEFENSE_FROM_CITIZENS
; 2576 : 	kStream << m_iBuildingDefensePerCitizen;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2577 : #endif
; 2578 : 	kStream << m_iBuildingDefenseMod;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2579 : 	kStream << m_iMissionaryExtraSpreads;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2580 : 	kStream << m_iLandmarksTourismPercent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2581 : 	kStream << m_iGreatWorksTourismModifier;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2582 : 	kStream << m_bSoldBuildingThisTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2583 : 
; 2584 : #ifdef _MSC_VER
; 2585 : #pragma warning ( push )
; 2586 : #pragma warning ( disable : 6011 ) // if m_pBuildings is NULL during load, we're screwed. Redesign the class or the loader code.
; 2587 : #endif//_MSC_VER
; 2588 : 	int iNumBuildings = m_pBuildings->GetNumBuildings();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+108]
	call	?GetNumBuildings@CvBuildingXMLEntries@@QAEHXZ ; CvBuildingXMLEntries::GetNumBuildings
	mov	DWORD PTR _iNumBuildings$[ebp], eax

; 2589 : #ifdef _MSC_VER
; 2590 : #pragma warning ( pop )
; 2591 : #endif//_MSC_VER
; 2592 : 
; 2593 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingProduction, iNumBuildings);

	mov	edx, DWORD PTR _iNumBuildings$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 2594 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingProductionTime, iNumBuildings);

	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 2595 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingOriginalOwner, iNumBuildings);

	mov	ecx, DWORD PTR _iNumBuildings$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 2596 : 	BuildingArrayHelpers::Write(kStream, m_paiBuildingOriginalTime, iNumBuildings);

	mov	edx, DWORD PTR _iNumBuildings$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 2597 : 	BuildingArrayHelpers::Write(kStream, m_paiNumRealBuilding, iNumBuildings);

	mov	eax, DWORD PTR _iNumBuildings$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 2598 : 	BuildingArrayHelpers::Write(kStream, m_paiNumFreeBuilding, iNumBuildings);

	mov	ecx, DWORD PTR _iNumBuildings$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; BuildingArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 2599 : 
; 2600 : 	kStream << m_aBuildingYieldChange;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; operator<<<BuildingYieldChange>
	add	esp, 8

; 2601 : 	kStream << m_aBuildingGreatWork;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; operator<<<BuildingGreatWork>
	add	esp, 8

; 2602 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvCityBuildings@@QAEXAAVFDataStream@@@Z ENDP	; CvCityBuildings::Write
_TEXT	ENDS
PUBLIC	?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ; CvCityBuildings::GetBuildings
; Function compile flags: /Odtp
;	COMDAT ?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ PROC ; CvCityBuildings::GetBuildings, COMDAT
; _this$ = ecx

; 2606 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2607 : 	return m_pBuildings;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+108]

; 2608 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildings@CvCityBuildings@@QBEPAVCvBuildingXMLEntries@@XZ ENDP ; CvCityBuildings::GetBuildings
_TEXT	ENDS
PUBLIC	?GetNumBuildings@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetNumBuildings
; Function compile flags: /Odtp
;	COMDAT ?GetNumBuildings@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumBuildings@CvCityBuildings@@QBEHXZ PROC		; CvCityBuildings::GetNumBuildings, COMDAT
; _this$ = ecx

; 2612 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2613 : 	return m_iNumBuildings;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 2614 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumBuildings@CvCityBuildings@@QBEHXZ ENDP		; CvCityBuildings::GetNumBuildings
_TEXT	ENDS
PUBLIC	?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z	; CvCityBuildings::ChangeNumBuildings
; Function compile flags: /Odtp
;	COMDAT ?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z PROC	; CvCityBuildings::ChangeNumBuildings, COMDAT
; _this$ = ecx

; 2618 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2619 : 	m_iNumBuildings = (m_iNumBuildings + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 2620 : 	CvAssert(GetNumBuildings() >= 0);
; 2621 : 
; 2622 : //	GET_PLAYER(m_pCity->getOwner()).updateNumResourceUsed();
; 2623 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z ENDP	; CvCityBuildings::ChangeNumBuildings
_TEXT	ENDS
PUBLIC	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
PUBLIC	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
PUBLIC	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
_this$ = -20						; size = 4
$T229976 = -16						; size = 4
$T229970 = -12						; size = 4
$T229966 = -8						; size = 4
$T229965 = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumBuilding, COMDAT
; _this$ = ecx

; 2627 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2628 : 	CvAssertMsg(eIndex != NO_BUILDING, "BuildingType eIndex is expected to not be NO_BUILDING");
; 2629 : 
; 2630 : 	if(GC.getCITY_MAX_NUM_BUILDINGS() <= 1)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6892
	mov	DWORD PTR $T229970[ebp], eax
	cmp	DWORD PTR $T229970[ebp], 1
	jg	SHORT $LN2@GetNumBuil

; 2631 : 	{
; 2632 : 		return std::max(GetNumRealBuilding(eIndex), GetNumFreeBuilding(eIndex));

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	mov	DWORD PTR $T229965[ebp], eax
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	mov	DWORD PTR $T229966[ebp], eax
	mov	eax, DWORD PTR $T229966[ebp]
	cmp	eax, DWORD PTR $T229965[ebp]
	jge	SHORT $LN9@GetNumBuil
	lea	ecx, DWORD PTR $T229965[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN10@GetNumBuil
$LN9@GetNumBuil:
	lea	edx, DWORD PTR $T229966[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN10@GetNumBuil:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR $T229976[ebp], eax
	mov	ecx, DWORD PTR $T229976[ebp]
	mov	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@GetNumBuil

; 2633 : 	}
; 2634 : 	else

	jmp	SHORT $LN3@GetNumBuil
$LN2@GetNumBuil:

; 2635 : 	{
; 2636 : 		return (GetNumRealBuilding(eIndex) + GetNumFreeBuilding(eIndex));

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	mov	esi, eax
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	add	eax, esi
$LN3@GetNumBuil:

; 2637 : 	}
; 2638 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumBuilding
_TEXT	ENDS
PUBLIC	?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ; CvCityBuildings::HasBuildingClass
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
; Function compile flags: /Odtp
;	COMDAT ?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T230019 = -28						; size = 4
$T230015 = -24						; size = 4
$T229999 = -20						; size = 4
$T229987 = -16						; size = 4
$T229982 = -12						; size = 4
_pkInfo$219959 = -8					; size = 4
_iI$219953 = -4						; size = 4
_eIndex$ = 8						; size = 4
?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::HasBuildingClass, COMDAT
; _this$ = ecx

; 2642 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2643 : 	CvAssertMsg(eIndex != NO_BUILDINGCLASS, "BuildingClassTypes eIndex is expected to not be NO_BUILDINGCLASS");
; 2644 : 
; 2645 : 	for (std::vector<BuildingTypes>::const_iterator iI = m_buildingsThatExistAtLeastOnce.begin(); iI != m_buildingsThatExistAtLeastOnce.end(); ++iI)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	DWORD PTR $T229987[ebp], ecx
	mov	edx, DWORD PTR $T229987[ebp]
	mov	DWORD PTR _iI$219953[ebp], edx
	jmp	SHORT $LN4@HasBuildin
$LN3@HasBuildin:
	mov	eax, DWORD PTR _iI$219953[ebp]
	add	eax, 4
	mov	DWORD PTR _iI$219953[ebp], eax
$LN4@HasBuildin:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR $T229999[ebp], edx
	mov	eax, DWORD PTR $T229999[ebp]
	mov	DWORD PTR $T229982[ebp], eax
	mov	ecx, DWORD PTR _iI$219953[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T229982[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@HasBuildin

; 2646 : 	{
; 2647 : 		CvBuildingEntry* pkInfo = GC.getBuildingInfo(*iI);

	mov	edx, DWORD PTR _iI$219953[ebp]
	mov	DWORD PTR $T230015[ebp], edx
	mov	eax, DWORD PTR $T230015[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkInfo$219959[ebp], eax

; 2648 : 		if (pkInfo && pkInfo->GetBuildingClassType() == eIndex && GetNumBuilding(*iI) > 0)

	cmp	DWORD PTR _pkInfo$219959[ebp], 0
	je	SHORT $LN1@HasBuildin
	mov	ecx, DWORD PTR _pkInfo$219959[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	SHORT $LN1@HasBuildin
	mov	edx, DWORD PTR _iI$219953[ebp]
	mov	DWORD PTR $T230019[ebp], edx
	mov	eax, DWORD PTR $T230019[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN1@HasBuildin

; 2649 : 		{
; 2650 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@HasBuildin
$LN1@HasBuildin:

; 2651 : 		}
; 2652 : 	}

	jmp	SHORT $LN3@HasBuildin
$LN2@HasBuildin:

; 2653 : 	return false;

	xor	al, al
$LN5@HasBuildin:

; 2654 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasBuildingClass@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::HasBuildingClass
_TEXT	ENDS
PUBLIC	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
EXTRN	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z:PROC ; CvTeam::isObsoleteBuilding
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Odtp
;	COMDAT ?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T230026 = -8						; size = 4
$T230025 = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumActiveBuilding, COMDAT
; _this$ = ecx

; 2657 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2658 : 	CvAssertMsg(eIndex != NO_BUILDING, "BuildingType eIndex is expected to not be NO_BUILDING");
; 2659 : 
; 2660 : 	if(GET_TEAM(m_pCity->getTeam()).isObsoleteBuilding(eIndex))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	mov	DWORD PTR $T230025[ebp], eax
	mov	ecx, DWORD PTR $T230025[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T230026[ebp], ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230026[ebp]
	call	?isObsoleteBuilding@CvTeam@@QBE_NW4BuildingTypes@@@Z ; CvTeam::isObsoleteBuilding
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetNumActi

; 2661 : 	{
; 2662 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetNumActi
$LN1@GetNumActi:

; 2663 : 	}
; 2664 : 
; 2665 : 	return (GetNumBuilding(eIndex));

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
$LN2@GetNumActi:

; 2666 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumActiveBuilding
_TEXT	ENDS
PUBLIC	??_C@_0CA@LKNDJLEI@CityBuildingsIsBuildingSellable?$AA@ ; `string'
PUBLIC	?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ; CvCityBuildings::IsHoldingGreatWork
PUBLIC	??_C@_0BF@KOADNKHJ@BUILDINGCLASS_SHRINE?$AA@	; `string'
PUBLIC	?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ ; CvCityBuildings::IsSoldBuildingThisTurn
PUBLIC	?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z ; CvCityBuildings::IsBuildingSellable
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
;	COMDAT ??_C@_0CA@LKNDJLEI@CityBuildingsIsBuildingSellable?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0CA@LKNDJLEI@CityBuildingsIsBuildingSellable?$AA@ DB 'CityBuildings'
	DB	'IsBuildingSellable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KOADNKHJ@BUILDINGCLASS_SHRINE?$AA@
CONST	SEGMENT
??_C@_0BF@KOADNKHJ@BUILDINGCLASS_SHRINE?$AA@ DB 'BUILDINGCLASS_SHRINE', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z$0
__ehfuncinfo$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
_TEXT	SEGMENT
tv181 = -80						; size = 4
tv171 = -76						; size = 4
tv160 = -72						; size = 4
_this$ = -68						; size = 4
$T230079 = -64						; size = 4
$T230075 = -60						; size = 4
$T230068 = -56						; size = 4
$T230056 = -52						; size = 4
$T230052 = -45						; size = 1
$T230051 = -44						; size = 4
$T230047 = -40						; size = 4
$T230043 = -36						; size = 4
$T230034 = -32						; size = 4
$T230029 = -26						; size = 1
_bResult$219984 = -25					; size = 1
_args$219983 = -24					; size = 4
_buildingClassType$ = -20				; size = 4
_pkScriptSystem$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kBuilding$ = 8						; size = 4
?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z PROC ; CvCityBuildings::IsBuildingSellable, COMDAT
; _this$ = ecx

; 2670 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2671 : 	// Can't sell more than one building per turn
; 2672 : 	if(IsSoldBuildingThisTurn())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ ; CvCityBuildings::IsSoldBuildingThisTurn
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@IsBuilding@2

; 2673 : 		return false;

	xor	al, al
	jmp	$LN10@IsBuilding@2
$LN9@IsBuilding@2:

; 2674 : 
; 2675 : 	// Can't sell a building if it doesn't cost us anything
; 2676 : 	
; 2677 : 	if(kBuilding.GetGoldMaintenance() <= 0)

	mov	ecx, DWORD PTR _kBuilding$[ebp]
	call	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGoldMaintenance
	test	eax, eax
	jg	SHORT $LN8@IsBuilding@2

; 2678 : 		return false;

	xor	al, al
	jmp	$LN10@IsBuilding@2
$LN8@IsBuilding@2:

; 2679 : 
; 2680 : 	// Can't sell a building if it's a shrine (no exploits)
; 2681 :     if (kBuilding.GetBuildingClassType() == (BuildingClassTypes)GC.getInfoTypeForString("BUILDINGCLASS_SHRINE"))

	mov	ecx, DWORD PTR _kBuilding$[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0BF@KOADNKHJ@BUILDINGCLASS_SHRINE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jne	SHORT $LN7@IsBuilding@2

; 2682 :         return false;

	xor	al, al
	jmp	$LN10@IsBuilding@2
$LN7@IsBuilding@2:

; 2683 : 
; 2684 : 	// Is this a free building?
; 2685 : 	if(GetNumFreeBuilding((BuildingTypes)kBuilding.GetID()) > 0)

	mov	ecx, DWORD PTR _kBuilding$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T230034[ebp], edx
	mov	eax, DWORD PTR $T230034[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	test	eax, eax
	jle	SHORT $LN6@IsBuilding@2

; 2686 : 		return false;

	xor	al, al
	jmp	$LN10@IsBuilding@2
$LN6@IsBuilding@2:

; 2687 : 
; 2688 : 	// Science building in capital that has given us a tech boost?
; 2689 : 	if(m_pCity->isCapital() && kBuilding.IsScienceBuilding())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@IsBuilding@2
	mov	ecx, DWORD PTR _kBuilding$[ebp]
	call	?IsScienceBuilding@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsScienceBuilding
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@IsBuilding@2

; 2690 : 	{
; 2691 : 		return !(GET_PLAYER(m_pCity->getOwner()).GetPlayerTraits()->IsTechBoostFromCapitalScienceBuildings());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230043[ebp], eax
	mov	ecx, DWORD PTR $T230043[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230047[ebp], ecx
	mov	ecx, DWORD PTR $T230047[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T230051[ebp], eax
	mov	edx, DWORD PTR $T230051[ebp]
	mov	al, BYTE PTR [edx+339]
	mov	BYTE PTR $T230052[ebp], al
	movzx	eax, BYTE PTR $T230052[ebp]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	jmp	$LN10@IsBuilding@2
$LN5@IsBuilding@2:

; 2692 : 	}
; 2693 : 
; 2694 : 	// Great Work present in this one?
; 2695 : 	const BuildingClassTypes buildingClassType = (BuildingClassTypes) kBuilding.GetBuildingClassType();

	mov	ecx, DWORD PTR _kBuilding$[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	mov	DWORD PTR _buildingClassType$[ebp], eax

; 2696 : 	if (IsHoldingGreatWork(buildingClassType))

	mov	ecx, DWORD PTR _buildingClassType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ; CvCityBuildings::IsHoldingGreatWork
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@IsBuilding@2

; 2697 : 	{
; 2698 : 		return false;

	xor	al, al
	jmp	$LN10@IsBuilding@2
$LN4@IsBuilding@2:

; 2699 : 	}
; 2700 : 
; 2701 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T230056[ebp]
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv160[ebp], ecx
	mov	edx, DWORD PTR tv160[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv160[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 2702 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN3@IsBuilding@2

; 2703 : 	{
; 2704 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$219983[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2705 : 		args->Push(m_pCity->getOwner());

	mov	eax, DWORD PTR _args$219983[ebp]
	mov	DWORD PTR tv171[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230068[ebp], eax
	mov	ecx, DWORD PTR $T230068[ebp]
	push	ecx
	mov	edx, DWORD PTR tv171[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv171[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 2706 : 		args->Push(kBuilding.GetID());

	mov	eax, DWORD PTR _args$219983[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR _kBuilding$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T230075[ebp], edx
	mov	eax, DWORD PTR $T230075[ebp]
	push	eax
	mov	ecx, DWORD PTR tv181[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv181[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 2707 : 
; 2708 : 		// Attempt to execute the game events.
; 2709 : 		// Will return false if there are no registered listeners.
; 2710 : 		bool bResult = false;

	mov	BYTE PTR _bResult$219984[ebp], 0

; 2711 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "CityBuildingsIsBuildingSellable", args.get(), bResult))

	mov	ecx, DWORD PTR _args$219983[ebp]
	mov	DWORD PTR $T230079[ebp], ecx
	lea	edx, DWORD PTR _bResult$219984[ebp]
	push	edx
	mov	eax, DWORD PTR $T230079[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@LKNDJLEI@CityBuildingsIsBuildingSellable?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	push	ecx
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@IsBuilding@2

; 2712 : 		{
; 2713 : 			// Check the result.
; 2714 : 			if(bResult == false)

	movzx	eax, BYTE PTR _bResult$219984[ebp]
	test	eax, eax
	jne	SHORT $LN2@IsBuilding@2

; 2715 : 			{
; 2716 : 				return false;

	mov	BYTE PTR $T230029[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$219983[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	al, BYTE PTR $T230029[ebp]
	jmp	SHORT $LN10@IsBuilding@2
$LN2@IsBuilding@2:

; 2717 : 			}
; 2718 : 		}
; 2719 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$219983[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@IsBuilding@2:

; 2720 : 
; 2721 : 	return true;

	mov	al, 1
$LN10@IsBuilding@2:

; 2722 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z$0:
	lea	ecx, DWORD PTR _args$219983[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z ENDP ; CvCityBuildings::IsBuildingSellable
PUBLIC	?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z ; CvCityBuildings::SetSoldBuildingThisTurn
PUBLIC	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding
PUBLIC	?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetSellBuildingRefund
PUBLIC	?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z ; CvCityBuildings::DoSellBuilding
EXTRN	?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z:PROC ; CvCityCitizens::DoRemoveAllSpecialistsFromBuilding
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
; Function compile flags: /Odtp
;	COMDAT ?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T230100 = -16						; size = 4
$T230096 = -12						; size = 4
_iRefund$ = -8						; size = 4
_pkBuildingEntry$ = -4					; size = 4
_eIndex$ = 8						; size = 4
?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z PROC ; CvCityBuildings::DoSellBuilding, COMDAT
; _this$ = ecx

; 2726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2727 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2728 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2729 : 
; 2730 : 	CvBuildingEntry* pkBuildingEntry = GC.getBuildingInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingEntry$[ebp], eax

; 2731 : 	if(!pkBuildingEntry)

	cmp	DWORD PTR _pkBuildingEntry$[ebp], 0
	jne	SHORT $LN2@DoSellBuil

; 2732 : 		return;

	jmp	$LN3@DoSellBuil
$LN2@DoSellBuil:

; 2733 : 
; 2734 : 	// Can we actually do this?
; 2735 : 	if(!IsBuildingSellable(*pkBuildingEntry))

	mov	ecx, DWORD PTR _pkBuildingEntry$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsBuildingSellable@CvCityBuildings@@QBE_NABVCvBuildingEntry@@@Z ; CvCityBuildings::IsBuildingSellable
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@DoSellBuil

; 2736 : 		return;

	jmp	SHORT $LN3@DoSellBuil
$LN1@DoSellBuil:

; 2737 : 
; 2738 : 	// Gold refund
; 2739 : 	int iRefund = GetSellBuildingRefund(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetSellBuildingRefund
	mov	DWORD PTR _iRefund$[ebp], eax

; 2740 : 	GET_PLAYER(m_pCity->getOwner()).GetTreasury()->ChangeGold(iRefund);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230096[ebp], eax
	mov	ecx, DWORD PTR $T230096[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230100[ebp], ecx
	mov	edx, DWORD PTR _iRefund$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230100[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold

; 2741 : 
; 2742 : 	// Kick everyone out
; 2743 : 	m_pCity->GetCityCitizens()->DoRemoveAllSpecialistsFromBuilding(eIndex);

	push	0
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoRemoveAllSpecialistsFromBuilding@CvCityCitizens@@QAEXW4BuildingTypes@@_N@Z ; CvCityCitizens::DoRemoveAllSpecialistsFromBuilding

; 2744 : 
; 2745 : 	SetNumRealBuilding(eIndex, 0);

	push	0
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumRealBuilding

; 2746 : 
; 2747 : 	SetSoldBuildingThisTurn(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z ; CvCityBuildings::SetSoldBuildingThisTurn
$LN3@DoSellBuil:

; 2748 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z ENDP ; CvCityBuildings::DoSellBuilding
_TEXT	ENDS
EXTRN	?getProductionNeeded@CvPlayer@@QBEHW4BuildingTypes@@@Z:PROC ; CvPlayer::getProductionNeeded
; Function compile flags: /Odtp
;	COMDAT ?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T230119 = -16						; size = 4
$T230115 = -12						; size = 4
$T230111 = -8						; size = 4
_iRefund$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetSellBuildingRefund, COMDAT
; _this$ = ecx

; 2752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2753 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2754 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2755 : 
; 2756 : 	int iRefund = GET_PLAYER(m_pCity->getOwner()).getProductionNeeded(eIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T230111[ebp], edx
	mov	eax, DWORD PTR $T230111[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230115[ebp], eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T230115[ebp]
	call	?getProductionNeeded@CvPlayer@@QBEHW4BuildingTypes@@@Z ; CvPlayer::getProductionNeeded
	mov	DWORD PTR _iRefund$[ebp], eax

; 2757 : 	iRefund /= /*10*/ GC.getBUILDING_SALE_DIVISOR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7832
	mov	DWORD PTR $T230119[ebp], edx
	mov	eax, DWORD PTR _iRefund$[ebp]
	cdq
	idiv	DWORD PTR $T230119[ebp]
	mov	DWORD PTR _iRefund$[ebp], eax

; 2758 : 
; 2759 : 	return iRefund;

	mov	eax, DWORD PTR _iRefund$[ebp]

; 2760 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSellBuildingRefund@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetSellBuildingRefund
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ PROC	; CvCityBuildings::IsSoldBuildingThisTurn, COMDAT
; _this$ = ecx

; 2764 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2765 : 	return m_bSoldBuildingThisTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+32]

; 2766 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ ENDP	; CvCityBuildings::IsSoldBuildingThisTurn
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z PROC	; CvCityBuildings::SetSoldBuildingThisTurn, COMDAT
; _this$ = ecx

; 2770 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2771 : 	if(IsSoldBuildingThisTurn() != bValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSoldBuildingThisTurn@CvCityBuildings@@QBE_NXZ ; CvCityBuildings::IsSoldBuildingThisTurn
	movzx	eax, al
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetSoldBui

; 2772 : 		m_bSoldBuildingThisTurn = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [edx+32], al
$LN2@SetSoldBui:

; 2773 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSoldBuildingThisTurn@CvCityBuildings@@QAEX_N@Z ENDP	; CvCityBuildings::SetSoldBuildingThisTurn
_TEXT	ENDS
PUBLIC	?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetTotalBaseBuildingMaintenance
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
; Function compile flags: /Odtp
;	COMDAT ?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_eBuilding$220018 = -16					; size = 4
_pkBuildingInfo$220020 = -12				; size = 4
_iBuildingLoop$220014 = -8				; size = 4
_iTotalCost$ = -4					; size = 4
?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetTotalBaseBuildingMaintenance, COMDAT
; _this$ = ecx

; 2777 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2778 : 	int iTotalCost = 0;

	mov	DWORD PTR _iTotalCost$[ebp], 0

; 2779 : 
; 2780 : #ifdef AUI_WARNING_FIXES
; 2781 : 	for (uint iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)
; 2782 : #else
; 2783 : 	for(int iBuildingLoop = 0; iBuildingLoop < GC.getNumBuildingInfos(); iBuildingLoop++)

	mov	DWORD PTR _iBuildingLoop$220014[ebp], 0
	jmp	SHORT $LN5@GetTotalBa
$LN4@GetTotalBa:
	mov	eax, DWORD PTR _iBuildingLoop$220014[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildingLoop$220014[ebp], eax
$LN5@GetTotalBa:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	DWORD PTR _iBuildingLoop$220014[ebp], eax
	jge	SHORT $LN3@GetTotalBa

; 2784 : #endif
; 2785 : 	{
; 2786 : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iBuildingLoop);

	mov	ecx, DWORD PTR _iBuildingLoop$220014[ebp]
	mov	DWORD PTR _eBuilding$220018[ebp], ecx

; 2787 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$220018[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$220020[ebp], eax

; 2788 : 
; 2789 : 		if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$220020[ebp], 0
	je	SHORT $LN2@GetTotalBa

; 2790 : 		{
; 2791 : 			if(GetNumBuilding(eBuilding))

	mov	eax, DWORD PTR _eBuilding$220018[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	je	SHORT $LN2@GetTotalBa

; 2792 : 				iTotalCost += (pkBuildingInfo->GetGoldMaintenance() * GetNumBuilding(eBuilding));

	mov	ecx, DWORD PTR _pkBuildingInfo$220020[ebp]
	call	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGoldMaintenance
	mov	esi, eax
	mov	ecx, DWORD PTR _eBuilding$220018[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	imul	esi, eax
	add	esi, DWORD PTR _iTotalCost$[ebp]
	mov	DWORD PTR _iTotalCost$[ebp], esi
$LN2@GetTotalBa:

; 2793 : 		}
; 2794 : 	}

	jmp	SHORT $LN4@GetTotalBa
$LN3@GetTotalBa:

; 2795 : 
; 2796 : 	return iTotalCost;

	mov	eax, DWORD PTR _iTotalCost$[ebp]

; 2797 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalBaseBuildingMaintenance@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetTotalBaseBuildingMaintenance
_TEXT	ENDS
PUBLIC	?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProduction
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingProduction, COMDAT
; _this$ = ecx

; 2801 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2802 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2803 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2804 : 	return m_paiBuildingProduction[eIndex] / 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx

; 2805 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingProduction
_TEXT	ENDS
PUBLIC	?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTimes100
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingProductionTimes100, COMDAT
; _this$ = ecx

; 2809 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2810 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2811 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2812 : 	return m_paiBuildingProduction[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2813 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingProductionTimes100
_TEXT	ENDS
PUBLIC	?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTimes100
PUBLIC	?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProduction
; Function compile flags: /Odtp
;	COMDAT ?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingProduction, COMDAT
; _this$ = ecx

; 2817 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2818 : 	SetBuildingProductionTimes100(eIndex, iNewValue*100);

	mov	eax, DWORD PTR _iNewValue$[ebp]
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTimes100

; 2819 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingProduction
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
PUBLIC	?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z ; CvCityBuildings::NotifyNewBuildingStarted
EXTRN	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z:PROC ; CvGlobals::WrapCityPointer
EXTRN	?isCitySelected@CvCity@@QAE_NXZ:PROC		; CvCity::isCitySelected
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z$1
__ehfuncinfo$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
tv155 = -88						; size = 4
tv129 = -84						; size = 4
_this$ = -80						; size = 4
_inst$230205 = -76					; size = 4
$T230201 = -72						; size = 4
$T230188 = -68						; size = 4
_inst$230184 = -64					; size = 4
$T230180 = -60						; size = 4
$T230170 = -56						; size = 4
__Ptr$230168 = -52					; size = 4
$T230165 = -48						; size = 4
__Cvtptr$230160 = -44					; size = 4
__Ans$230161 = -40					; size = 4
$T230154 = -36						; size = 4
$T230150 = -32						; size = 4
$T230146 = -28						; size = 4
$T230135 = -24						; size = 4
$T230134 = -20						; size = 4
_pCity$220091 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingProductionTimes100, COMDAT
; _this$ = ecx

; 2823 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2824 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2825 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings())");
; 2826 : 
; 2827 : 	if(GetBuildingProductionTimes100(eIndex) != iNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTimes100
	cmp	eax, DWORD PTR _iNewValue$[ebp]
	je	$LN4@SetBuildin

; 2828 : 	{
; 2829 : 		if(GetBuildingProductionTimes100(eIndex) == 0)

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTimes100
	test	eax, eax
	jne	SHORT $LN2@SetBuildin

; 2830 : 		{
; 2831 : 			NotifyNewBuildingStarted(eIndex);

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z ; CvCityBuildings::NotifyNewBuildingStarted
$LN2@SetBuildin:

; 2832 : 		}
; 2833 : 
; 2834 : 		m_paiBuildingProduction[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2835 : 		CvAssert(GetBuildingProductionTimes100(eIndex) >= 0);
; 2836 : 
; 2837 : 		if((m_pCity->getOwner() == GC.getGame().getActivePlayer()) && m_pCity->isCitySelected())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230146[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230150[ebp], ecx
	mov	ecx, DWORD PTR $T230150[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T230146[ebp], eax
	jne	SHORT $LN1@SetBuildin
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?isCitySelected@CvCity@@QAE_NXZ		; CvCity::isCitySelected
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@SetBuildin

; 2838 : 		{
; 2839 : 			GC.GetEngineUserInterface()->setDirty(CityScreen_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T230154[ebp]
	mov	DWORD PTR tv129[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv129[ebp], edx
	push	1
	push	21					; 00000015H
	mov	eax, DWORD PTR tv129[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv129[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN1@SetBuildin:

; 2840 : 		}
; 2841 : 
; 2842 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(m_pCity);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	lea	eax, DWORD PTR $T230134[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	DWORD PTR $T230165[ebp], eax
	mov	ecx, DWORD PTR $T230165[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Cvtptr$230160[ebp], edx
	mov	eax, DWORD PTR __Cvtptr$230160[ebp]
	mov	DWORD PTR __Ans$230161[ebp], eax
	mov	ecx, DWORD PTR $T230165[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR __Ans$230161[ebp]
	mov	DWORD PTR $T230135[ebp], edx
	mov	eax, DWORD PTR $T230135[ebp]
	mov	DWORD PTR $T230170[ebp], eax
	mov	ecx, DWORD PTR $T230170[ebp]
	mov	DWORD PTR __Ptr$230168[ebp], ecx
	mov	DWORD PTR $T230170[ebp], 0
	mov	edx, DWORD PTR __Ptr$230168[ebp]
	mov	DWORD PTR _pCity$220091[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T230134[ebp]
	mov	DWORD PTR $T230180[ebp], eax
	cmp	DWORD PTR $T230180[ebp], 0
	je	SHORT $LN22@SetBuildin
	mov	ecx, DWORD PTR $T230180[ebp]
	mov	DWORD PTR _inst$230184[ebp], ecx
	mov	edx, DWORD PTR _inst$230184[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$230184[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN22@SetBuildin:

; 2843 : 
; 2844 : 		GC.GetEngineUserInterface()->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);

	mov	eax, DWORD PTR $T230188[ebp]
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv155[ebp], ecx
	push	0
	mov	edx, DWORD PTR _pCity$220091[ebp]
	push	edx
	mov	eax, DWORD PTR tv155[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv155[ebp]
	mov	eax, DWORD PTR [edx+440]
	call	eax

; 2845 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pCity$220091[ebp]
	mov	DWORD PTR $T230201[ebp], ecx
	cmp	DWORD PTR $T230201[ebp], 0
	je	SHORT $LN4@SetBuildin
	mov	edx, DWORD PTR $T230201[ebp]
	mov	DWORD PTR _inst$230205[ebp], edx
	mov	eax, DWORD PTR _inst$230205[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$230205[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN4@SetBuildin:

; 2846 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z$1:
	lea	ecx, DWORD PTR _pCity$220091[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingProductionTimes100
PUBLIC	?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::ChangeBuildingProductionTimes100
PUBLIC	?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::ChangeBuildingProduction
; Function compile flags: /Odtp
;	COMDAT ?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingProduction, COMDAT
; _this$ = ecx

; 2850 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2851 : 	ChangeBuildingProductionTimes100(eIndex, iChange*100);

	mov	eax, DWORD PTR _iChange$[ebp]
	imul	eax, 100				; 00000064H
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::ChangeBuildingProductionTimes100

; 2852 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ChangeBuildingProduction@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingProduction
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingProductionTimes100, COMDAT
; _this$ = ecx

; 2856 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2857 : 	SetBuildingProductionTimes100(eIndex, (GetBuildingProductionTimes100(eIndex) + iChange));

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingProductionTimes100@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTimes100
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTimes100

; 2858 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ChangeBuildingProductionTimes100@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingProductionTimes100
_TEXT	ENDS
PUBLIC	?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTime
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingProductionTime, COMDAT
; _this$ = ecx

; 2862 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2863 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2864 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2865 : 	return m_paiBuildingProductionTime[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2866 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingProductionTime
_TEXT	ENDS
PUBLIC	?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTime
; Function compile flags: /Odtp
;	COMDAT ?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingProductionTime, COMDAT
; _this$ = ecx

; 2870 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2871 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2872 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2873 : 	m_paiBuildingProductionTime[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2874 : 	CvAssert(GetBuildingProductionTime(eIndex) >= 0);
; 2875 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingProductionTime
_TEXT	ENDS
PUBLIC	?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::ChangeBuildingProductionTime
; Function compile flags: /Odtp
;	COMDAT ?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingProductionTime, COMDAT
; _this$ = ecx

; 2879 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2880 : 	SetBuildingProductionTime(eIndex, (GetBuildingProductionTime(eIndex) + iChange));

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingProductionTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProductionTime
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingProductionTime

; 2881 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ChangeBuildingProductionTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingProductionTime
_TEXT	ENDS
PUBLIC	?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingOriginalOwner
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingOriginalOwner, COMDAT
; _this$ = ecx

; 2885 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2886 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2887 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2888 : 	return m_paiBuildingOriginalOwner[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2889 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingOriginalOwner@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingOriginalOwner
_TEXT	ENDS
PUBLIC	?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalOwner
; Function compile flags: /Odtp
;	COMDAT ?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingOriginalOwner, COMDAT
; _this$ = ecx

; 2893 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2894 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2895 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2896 : 	m_paiBuildingOriginalOwner[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2897 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingOriginalOwner
_TEXT	ENDS
PUBLIC	?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingOriginalTime
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetBuildingOriginalTime, COMDAT
; _this$ = ecx

; 2901 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2902 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2903 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2904 : 	return m_paiBuildingOriginalTime[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2905 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingOriginalTime@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetBuildingOriginalTime
_TEXT	ENDS
PUBLIC	?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalTime
; Function compile flags: /Odtp
;	COMDAT ?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetBuildingOriginalTime, COMDAT
; _this$ = ecx

; 2909 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2910 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2911 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2912 : 	m_paiBuildingOriginalTime[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2913 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingOriginalTime
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumRealBuilding, COMDAT
; _this$ = ecx

; 2917 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2918 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2919 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2920 : 	return m_paiNumRealBuilding[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2921 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumRealBuilding
_TEXT	ENDS
PUBLIC	?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z ; CvCityBuildings::SetNumRealBuildingTimed
EXTRN	?getGameTurnYear@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurnYear
; Function compile flags: /Odtp
;	COMDAT ?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T230246 = -8						; size = 4
$T230237 = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetNumRealBuilding, COMDAT
; _this$ = ecx

; 2925 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2926 : 	SetNumRealBuildingTimed(eIndex, iNewValue, true, m_pCity->getOwner(), GC.getGame().getGameTurnYear());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230237[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230246[ebp], eax
	mov	ecx, DWORD PTR $T230237[ebp]
	call	?getGameTurnYear@CvGame@@QAEHXZ		; CvGame::getGameTurnYear
	push	eax
	mov	ecx, DWORD PTR $T230246[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _iNewValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z ; CvCityBuildings::SetNumRealBuildingTimed

; 2927 : 
; 2928 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetNumRealBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetNumRealBuilding
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
PUBLIC	??_C@_0BI@LMJFBOA@BUILDING_GREAT_FIREWALL?$AA@	; `string'
PUBLIC	??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@ ; `string'
PUBLIC	??_C@_0BO@FPKLCHCH@TXT_KEY_MISC_WONDER_COMPLETED?$AA@ ; `string'
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
PUBLIC	??_C@_0BO@IILDKBEJ@TXT_KEY_MISC_COMPLETES_WONDER?$AA@ ; `string'
PUBLIC	?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ; CvCityBuildings::IncrementWonderStats
PUBLIC	??_C@_0BA@PAFFAEPM@BUILDING_TEMPLE?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	??3CvDllPlot@@SAXPAX@Z:PROC			; CvDllPlot::operator delete
EXTRN	??3CvDllCity@@SAXPAX@Z:PROC			; CvDllCity::operator delete
EXTRN	?FinishedBuilding@CvPlayerAchievements@@QAEXPAVCvCity@@W4BuildingTypes@@@Z:PROC ; CvPlayerAchievements::FinishedBuilding
EXTRN	?updateStrengthValue@CvCity@@QAEXXZ:PROC	; CvCity::updateStrengthValue
EXTRN	?incrementBuildingClassCreatedCount@CvGame@@QAEXW4BuildingClassTypes@@@Z:PROC ; CvGame::incrementBuildingClassCreatedCount
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_??4String@Localization@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z:PROC ; CvGame::addReplayMessage
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?getNameKey@CvPlayer@@QBEPBDXZ:PROC		; CvPlayer::getNameKey
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	?isFinalInitialized@CvGame@@QBE_NXZ:PROC	; CvGame::isFinalInitialized
EXTRN	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeNumResourceUsed
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	??0CvDllPlot@@QAE@PAVCvPlot@@@Z:PROC		; CvDllPlot::CvDllPlot
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	??2CvDllPlot@@SAPAXI@Z:PROC			; CvDllPlot::operator new
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvCity@@QBE_NXZ:PROC			; CvCity::isHuman
EXTRN	?changeNumNationalWonders@CvCity@@QAEXH@Z:PROC	; CvCity::changeNumNationalWonders
EXTRN	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isNationalWonderClass
EXTRN	?changeNumTeamWonders@CvCity@@QAEXH@Z:PROC	; CvCity::changeNumTeamWonders
EXTRN	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isTeamWonderClass
EXTRN	?ChangeNumWonders@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumWonders
EXTRN	?changeNumWorldWonders@CvCity@@QAEXH@Z:PROC	; CvCity::changeNumWorldWonders
EXTRN	?isNoLimit@CvBuildingClassInfo@@QBE_NXZ:PROC	; CvBuildingClassInfo::isNoLimit
EXTRN	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isWorldWonderClass
EXTRN	??0CvDllCity@@QAE@PAVCvCity@@@Z:PROC		; CvDllCity::CvDllCity
EXTRN	??2CvDllCity@@SAPAXI@Z:PROC			; CvDllCity::operator new
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeBaseBuildingGoldMaintenance
EXTRN	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z:PROC ; CvCity::processBuilding
;	COMDAT ??_C@_0BI@LMJFBOA@BUILDING_GREAT_FIREWALL?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BI@LMJFBOA@BUILDING_GREAT_FIREWALL?$AA@ DB 'BUILDING_GREAT_FIREWAL'
	DB	'L', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@
CONST	SEGMENT
??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@ DB 'TXT_KEY_MISC_WON'
	DB	'DER_COMPLETED_UNKNOWN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FPKLCHCH@TXT_KEY_MISC_WONDER_COMPLETED?$AA@
CONST	SEGMENT
??_C@_0BO@FPKLCHCH@TXT_KEY_MISC_WONDER_COMPLETED?$AA@ DB 'TXT_KEY_MISC_WO'
	DB	'NDER_COMPLETED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IILDKBEJ@TXT_KEY_MISC_COMPLETES_WONDER?$AA@
CONST	SEGMENT
??_C@_0BO@IILDKBEJ@TXT_KEY_MISC_COMPLETES_WONDER?$AA@ DB 'TXT_KEY_MISC_CO'
	DB	'MPLETES_WONDER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAFFAEPM@BUILDING_TEMPLE?$AA@
CONST	SEGMENT
??_C@_0BA@PAFFAEPM@BUILDING_TEMPLE?$AA@ DB 'BUILDING_TEMPLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
_TEXT	SEGMENT
tv793 = -1400						; size = 4
tv762 = -1396						; size = 4
tv753 = -1392						; size = 4
tv1307 = -1388						; size = 4
tv1302 = -1382						; size = 1
tv1295 = -1381						; size = 1
tv1291 = -1380						; size = 4
tv1292 = -1376						; size = 4
tv818 = -1372						; size = 4
tv943 = -1368						; size = 4
tv816 = -1364						; size = 4
tv169 = -1360						; size = 4
tv649 = -1356						; size = 4
tv590 = -1352						; size = 4
tv565 = -1348						; size = 4
tv814 = -1344						; size = 4
tv399 = -1340						; size = 4
tv446 = -1336						; size = 4
tv203 = -1332						; size = 4
tv365 = -1328						; size = 4
tv355 = -1324						; size = 4
tv284 = -1320						; size = 4
tv268 = -1316						; size = 4
tv252 = -1312						; size = 4
tv236 = -1308						; size = 4
tv217 = -1304						; size = 4
tv194 = -1300						; size = 4
tv838 = -1296						; size = 4
_this$ = -1292						; size = 4
_inst$230686 = -1288					; size = 4
$T230682 = -1284					; size = 4
$T230667 = -1280					; size = 4
_inst$230662 = -1276					; size = 4
$T230658 = -1272					; size = 4
$T230649 = -1268					; size = 4
__Ptr$230648 = -1264					; size = 4
$T230644 = -1260					; size = 4
__Cvtptr$230639 = -1256					; size = 4
__Ans$230640 = -1252					; size = 4
$T230633 = -1248					; size = 4
$T230629 = -1244					; size = 4
$T230622 = -1240					; size = 4
$T230618 = -1236					; size = 4
$T230609 = -1232					; size = 4
$T230600 = -1228					; size = 4
$T230591 = -1224					; size = 4
$T230582 = -1220					; size = 4
$T230578 = -1216					; size = 4
$T230574 = -1212					; size = 4
$T230565 = -1208					; size = 4
_uiOffset$230563 = -1204				; size = 4
$T230554 = -1200					; size = 4
$T230545 = -1196					; size = 4
$T230536 = -1189					; size = 1
$T230524 = -1188					; size = 4
$T230520 = -1184					; size = 4
$T230519 = -1180					; size = 4
$T230515 = -1176					; size = 4
$T230511 = -1172					; size = 4
$T230504 = -1168					; size = 4
$T230500 = -1164					; size = 4
$T230491 = -1160					; size = 4
$T230482 = -1156					; size = 4
$T230473 = -1152					; size = 4
$T230464 = -1148					; size = 4
$T230460 = -1144					; size = 4
$T230451 = -1140					; size = 4
$T230447 = -1136					; size = 4
$T230439 = -1132					; size = 4
$T230435 = -1128					; size = 4
$T230426 = -1124					; size = 4
$T230417 = -1120					; size = 4
$T230408 = -1116					; size = 4
$T230399 = -1112					; size = 4
_inst$230394 = -1108					; size = 4
$T230391 = -1104					; size = 4
$T230378 = -1100					; size = 4
$T230371 = -1096					; size = 4
_inst$230366 = -1092					; size = 4
$T230363 = -1088					; size = 4
$T230350 = -1084					; size = 4
$T230343 = -1080					; size = 4
$T230336 = -1076					; size = 4
$T230329 = -1072					; size = 4
$T230322 = -1068					; size = 4
$T230318 = -1064					; size = 4
$T230314 = -1060					; size = 4
$T230291 = -1056					; size = 4
$T230270 = -1052					; size = 4
$T230269 = -1048					; size = 4
$T230268 = -1044					; size = 4
$T230267 = -1040					; size = 80
$T230266 = -960						; size = 4
$T230265 = -956						; size = 4
$T230264 = -952						; size = 80
$T230263 = -872						; size = 4
$T230262 = -868						; size = 4
$T230261 = -864						; size = 80
$T230260 = -784						; size = 28
$T230259 = -756						; size = 4
$T230258 = -752						; size = 4
$T230255 = -748						; size = 4
$T230254 = -744						; size = 4
$T230251 = -740						; size = 4
$T230250 = -736						; size = 4
_pNotifications$220322 = -732				; size = 4
_pNotifications$220316 = -728				; size = 4
_thisPlayer$220309 = -724				; size = 4
_iI$220305 = -720					; size = 4
_kPopup$220303 = -716					; size = 536
_pNotifications$220295 = -180				; size = 4
_bDontShowRewardPopup$220292 = -173			; size = 1
_localizedText$220281 = -172				; size = 80
_iResourceLoop$220271 = -92				; size = 4
_pDllPlot$220260 = -88					; size = 4
_pDllCity$220193 = -84					; size = 4
_iOldNumBuilding$220177 = -80				; size = 4
_szBuildingTypeC$220182 = -76				; size = 4
_pCity$220330 = -72					; size = 4
_iNumResources$220270 = -68				; size = 4
_szBuildingType$220183 = -64				; size = 28
__$ArrayPad$ = -36					; size = 4
_iChangeNumRealBuilding$ = -32				; size = 4
_buildingClassType$ = -28				; size = 4
_buildingEntry$ = -24					; size = 4
_kBuildingClassInfo$ = -20				; size = 4
_pPlayer$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
_bFirst$ = 16						; size = 1
_eOriginalOwner$ = 20					; size = 4
_iOriginalTime$ = 24					; size = 4
?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z PROC ; CvCityBuildings::SetNumRealBuildingTimed, COMDAT
; _this$ = ecx

; 2932 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1388				; 0000056cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2933 : 	CvPlayer* pPlayer = &GET_PLAYER(m_pCity->getOwner());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T230291[ebp], edx
	mov	eax, DWORD PTR $T230291[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pPlayer$[ebp], eax

; 2934 : 
; 2935 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 2936 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 2937 : 
; 2938 : 	int iChangeNumRealBuilding = iNewValue - GetNumRealBuilding(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	mov	edx, DWORD PTR _iNewValue$[ebp]
	sub	edx, eax
	mov	DWORD PTR _iChangeNumRealBuilding$[ebp], edx

; 2939 : 
; 2940 : 	CvBuildingEntry* buildingEntry = GC.getBuildingInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _buildingEntry$[ebp], eax

; 2941 : 	const BuildingClassTypes buildingClassType = (BuildingClassTypes) buildingEntry->GetBuildingClassType();

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	mov	DWORD PTR _buildingClassType$[ebp], eax

; 2942 : 	const CvBuildingClassInfo& kBuildingClassInfo = buildingEntry->GetBuildingClassInfo();

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetBuildingClassInfo@CvBuildingEntry@@QBEABVCvBuildingClassInfo@@XZ ; CvBuildingEntry::GetBuildingClassInfo
	mov	DWORD PTR _kBuildingClassInfo$[ebp], eax

; 2943 : 
; 2944 : 	if(iChangeNumRealBuilding != 0)

	cmp	DWORD PTR _iChangeNumRealBuilding$[ebp], 0
	je	$LN50@SetNumReal

; 2945 : 	{
; 2946 : 		int iOldNumBuilding = GetNumBuilding(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	mov	DWORD PTR _iOldNumBuilding$220177[ebp], eax

; 2947 : 
; 2948 : 		m_paiNumRealBuilding[eIndex] = iNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	edx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 2949 : 
; 2950 : 		if(GetNumRealBuilding(eIndex) > 0)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumRealBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumRealBuilding
	test	eax, eax
	jle	SHORT $LN48@SetNumReal

; 2951 : 		{
; 2952 : 			SetBuildingOriginalOwner(eIndex, eOriginalOwner);

	mov	ecx, DWORD PTR _eOriginalOwner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalOwner

; 2953 : 			SetBuildingOriginalTime(eIndex, iOriginalTime);

	mov	eax, DWORD PTR _iOriginalTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalTime

; 2954 : 		}
; 2955 : 		else

	jmp	SHORT $LN47@SetNumReal
$LN48@SetNumReal:

; 2956 : 		{
; 2957 : 			SetBuildingOriginalOwner(eIndex, NO_PLAYER);

	push	-1
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingOriginalOwner@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalOwner

; 2958 : 			SetBuildingOriginalTime(eIndex, MIN_INT);

	push	-2147483648				; 80000000H
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingOriginalTime@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetBuildingOriginalTime
$LN47@SetNumReal:

; 2959 : 		}
; 2960 : 
; 2961 : 		// Process building effects
; 2962 : 		if(iOldNumBuilding != GetNumBuilding(eIndex))

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	cmp	DWORD PTR _iOldNumBuilding$220177[ebp], eax
	je	SHORT $LN46@SetNumReal

; 2963 : 		{
; 2964 : 			m_pCity->processBuilding(eIndex, iChangeNumRealBuilding, bFirst);

	push	0
	push	0
	movzx	edx, BYTE PTR _bFirst$[ebp]
	push	edx
	mov	eax, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z ; CvCity::processBuilding
$LN46@SetNumReal:

; 2965 : 		}
; 2966 : 
; 2967 : 		// Maintenance cost
; 2968 : 		if(buildingEntry->GetGoldMaintenance() != 0)

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGoldMaintenance
	test	eax, eax
	je	SHORT $LN74@SetNumReal

; 2969 : 		{
; 2970 : 			pPlayer->GetTreasury()->ChangeBaseBuildingGoldMaintenance(buildingEntry->GetGoldMaintenance() * iChangeNumRealBuilding);

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetGoldMaintenance@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGoldMaintenance
	imul	eax, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseBuildingGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseBuildingGoldMaintenance

; 2971 : 		}
; 2972 : 
; 2973 : 		//Achievement for Temples
; 2974 : 		const char* szBuildingTypeC = buildingEntry->GetType();

$LN74@SetNumReal:
	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szBuildingTypeC$220182[ebp], eax

; 2975 : 		CvString szBuildingType = szBuildingTypeC;

	cmp	DWORD PTR _szBuildingTypeC$220182[ebp], 0
	je	SHORT $LN78@SetNumReal
	mov	eax, DWORD PTR _szBuildingTypeC$220182[ebp]
	mov	DWORD PTR tv838[ebp], eax
	jmp	SHORT $LN79@SetNumReal
$LN78@SetNumReal:
	mov	DWORD PTR tv838[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN79@SetNumReal:
	mov	ecx, DWORD PTR tv838[ebp]
	push	ecx
	lea	ecx, DWORD PTR _szBuildingType$220183[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2976 : 		if(szBuildingType == "BUILDING_TEMPLE")

	push	OFFSET ??_C@_0BA@PAFFAEPM@BUILDING_TEMPLE?$AA@
	lea	edx, DWORD PTR _szBuildingType$220183[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN44@SetNumReal

; 2977 : 		{
; 2978 : 			if(m_pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230314[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230318[ebp], ecx
	mov	ecx, DWORD PTR $T230318[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T230314[ebp], eax
	jne	SHORT $LN44@SetNumReal

; 2979 : 			{
; 2980 : 				gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_TEMPLES, 1000, ACHIEVEMENT_1000TEMPLES);

	mov	edx, DWORD PTR $T230322[ebp]
	mov	DWORD PTR tv194[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv194[ebp], eax
	push	97					; 00000061H
	push	1000					; 000003e8H
	push	121					; 00000079H
	mov	ecx, DWORD PTR tv194[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv194[ebp]
	mov	eax, DWORD PTR [edx+848]
	call	eax
$LN44@SetNumReal:

; 2981 : 			}
; 2982 : 		}
; 2983 : 
; 2984 : 		if(buildingEntry->GetPreferredDisplayPosition() > 0)

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetPreferredDisplayPosition@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPreferredDisplayPosition
	test	eax, eax
	jle	$LN42@SetNumReal

; 2985 : 		{
; 2986 : 			auto_ptr<ICvCity1> pDllCity(new CvDllCity(m_pCity)); //-V689

	push	12					; 0000000cH
	call	??2CvDllCity@@SAPAXI@Z			; CvDllCity::operator new
	add	esp, 4
	mov	DWORD PTR $T230251[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T230251[ebp], 0
	je	SHORT $LN52@SetNumReal
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	mov	ecx, DWORD PTR $T230251[ebp]
	call	??0CvDllCity@@QAE@PAVCvCity@@@Z		; CvDllCity::CvDllCity
	mov	DWORD PTR tv217[ebp], eax
	jmp	SHORT $LN53@SetNumReal
$LN52@SetNumReal:
	mov	DWORD PTR tv217[ebp], 0
$LN53@SetNumReal:
	mov	eax, DWORD PTR tv217[ebp]
	mov	DWORD PTR $T230250[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T230250[ebp]
	mov	DWORD PTR _pDllCity$220193[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2987 : 
; 2988 : 			if(iNewValue > 0)

	cmp	DWORD PTR _iNewValue$[ebp], 0
	jle	$LN41@SetNumReal

; 2989 : 			{
; 2990 : 				// if this is a WW that (likely has a half-built state)
; 2991 : 				if(isWorldWonderClass(kBuildingClassInfo))

	mov	edx, DWORD PTR _kBuildingClassInfo$[ebp]
	push	edx
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	$LN40@SetNumReal

; 2992 : 				{
; 2993 : 					if(GetBuildingProduction(eIndex))

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingProduction@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetBuildingProduction
	test	eax, eax
	je	SHORT $LN39@SetNumReal

; 2994 : 					{
; 2995 : 						GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_EDITED, pDllCity.get(), eIndex, 1);

	mov	edx, DWORD PTR $T230329[ebp]
	mov	DWORD PTR tv236[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv236[ebp], eax
	push	1
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDllCity$220193[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR tv236[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv236[ebp]
	mov	eax, DWORD PTR [edx+532]
	call	eax

; 2996 : 					}
; 2997 : 					else

	jmp	SHORT $LN38@SetNumReal
$LN39@SetNumReal:

; 2998 : 					{
; 2999 : 						GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_CREATED, pDllCity.get(), eIndex, 1);

	mov	ecx, DWORD PTR $T230336[ebp]
	mov	DWORD PTR tv252[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv252[ebp], edx
	push	1
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDllCity$220193[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR tv252[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv252[ebp]
	mov	edx, DWORD PTR [eax+532]
	call	edx
$LN38@SetNumReal:

; 3000 : 					}
; 3001 : 				}
; 3002 : 				else

	jmp	SHORT $LN37@SetNumReal
$LN40@SetNumReal:

; 3003 : 				{
; 3004 : 					GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_CREATED, pDllCity.get(), eIndex, 1);

	mov	eax, DWORD PTR $T230343[ebp]
	mov	DWORD PTR tv268[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv268[ebp], ecx
	push	1
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDllCity$220193[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR tv268[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv268[ebp]
	mov	eax, DWORD PTR [edx+532]
	call	eax
$LN37@SetNumReal:

; 3005 : 				}
; 3006 : 			}
; 3007 : 			else

	jmp	SHORT $LN36@SetNumReal
$LN41@SetNumReal:

; 3008 : 			{
; 3009 : 				GC.GetEngineUserInterface()->AddDeferredWonderCommand(WONDER_REMOVED, pDllCity.get(), eIndex, 0);

	mov	ecx, DWORD PTR $T230350[ebp]
	mov	DWORD PTR tv284[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv284[ebp], edx
	push	0
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDllCity$220193[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR tv284[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv284[ebp]
	mov	edx, DWORD PTR [eax+532]
	call	edx
$LN36@SetNumReal:

; 3010 : 			}
; 3011 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _pDllCity$220193[ebp]
	mov	DWORD PTR $T230363[ebp], eax
	cmp	DWORD PTR $T230363[ebp], 0
	je	SHORT $LN42@SetNumReal
	mov	ecx, DWORD PTR $T230363[ebp]
	mov	DWORD PTR _inst$230366[ebp], ecx
	mov	edx, DWORD PTR _inst$230366[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$230366[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN42@SetNumReal:

; 3012 : 
; 3013 : 		if(!(kBuildingClassInfo.isNoLimit()))

	mov	ecx, DWORD PTR _kBuildingClassInfo$[ebp]
	call	?isNoLimit@CvBuildingClassInfo@@QBE_NXZ	; CvBuildingClassInfo::isNoLimit
	movzx	eax, al
	test	eax, eax
	jne	$LN35@SetNumReal

; 3014 : 		{
; 3015 : 			if(isWorldWonderClass(kBuildingClassInfo))

	mov	ecx, DWORD PTR _kBuildingClassInfo$[ebp]
	push	ecx
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@SetNumReal

; 3016 : 			{
; 3017 : 				m_pCity->changeNumWorldWonders(iChangeNumRealBuilding);

	mov	eax, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?changeNumWorldWonders@CvCity@@QAEXH@Z	; CvCity::changeNumWorldWonders

; 3018 : 				pPlayer->ChangeNumWonders(iChangeNumRealBuilding);

	mov	edx, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?ChangeNumWonders@CvPlayer@@QAEXH@Z	; CvPlayer::ChangeNumWonders
	jmp	$LN35@SetNumReal
$LN34@SetNumReal:

; 3019 : 			}
; 3020 : 			else if(isTeamWonderClass(kBuildingClassInfo))

	mov	eax, DWORD PTR _kBuildingClassInfo$[ebp]
	push	eax
	call	?isTeamWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isTeamWonderClass
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN32@SetNumReal

; 3021 : 			{
; 3022 : 				m_pCity->changeNumTeamWonders(iChangeNumRealBuilding);

	mov	edx, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?changeNumTeamWonders@CvCity@@QAEXH@Z	; CvCity::changeNumTeamWonders
	jmp	SHORT $LN35@SetNumReal
$LN32@SetNumReal:

; 3023 : 			}
; 3024 : 			else if(isNationalWonderClass(kBuildingClassInfo))

	mov	ecx, DWORD PTR _kBuildingClassInfo$[ebp]
	push	ecx
	call	?isNationalWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isNationalWonderClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN30@SetNumReal

; 3025 : 			{
; 3026 : 				m_pCity->changeNumNationalWonders(iChangeNumRealBuilding);

	mov	eax, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?changeNumNationalWonders@CvCity@@QAEXH@Z ; CvCity::changeNumNationalWonders

; 3027 : 				if(m_pCity->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?isHuman@CvCity@@QBE_NXZ		; CvCity::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@SetNumReal
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230371[ebp], ecx
	mov	ecx, DWORD PTR $T230371[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN29@SetNumReal

; 3028 : 				{
; 3029 : 					IncrementWonderStats(buildingClassType);

	mov	eax, DWORD PTR _buildingClassType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ; CvCityBuildings::IncrementWonderStats
$LN29@SetNumReal:

; 3030 : 				}
; 3031 : 			}
; 3032 : 			else

	jmp	SHORT $LN35@SetNumReal
$LN30@SetNumReal:

; 3033 : 			{
; 3034 : 				ChangeNumBuildings(iChangeNumRealBuilding);

	mov	ecx, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeNumBuildings@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeNumBuildings
$LN35@SetNumReal:

; 3035 : 			}
; 3036 : 		}
; 3037 : 
; 3038 : 		if(buildingEntry->IsCityWall())

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?IsCityWall@CvBuildingEntry@@QBE_NXZ	; CvBuildingEntry::IsCityWall
	movzx	edx, al
	test	edx, edx
	je	$LN27@SetNumReal

; 3039 : 		{
; 3040 : 			auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(m_pCity->plot()));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T230255[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T230255[ebp], 0
	je	SHORT $LN54@SetNumReal
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, DWORD PTR $T230255[ebp]
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	DWORD PTR tv355[ebp], eax
	jmp	SHORT $LN55@SetNumReal
$LN54@SetNumReal:
	mov	DWORD PTR tv355[ebp], 0
$LN55@SetNumReal:
	mov	ecx, DWORD PTR tv355[ebp]
	mov	DWORD PTR $T230254[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T230254[ebp]
	mov	DWORD PTR _pDllPlot$220260[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3041 : 			gDLL->GameplayWallCreated(pDllPlot.get());

	mov	eax, DWORD PTR $T230378[ebp]
	mov	DWORD PTR tv365[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv365[ebp], ecx
	mov	edx, DWORD PTR _pDllPlot$220260[ebp]
	push	edx
	mov	eax, DWORD PTR tv365[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv365[ebp]
	mov	eax, DWORD PTR [edx+704]
	call	eax

; 3042 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _pDllPlot$220260[ebp]
	mov	DWORD PTR $T230391[ebp], ecx
	cmp	DWORD PTR $T230391[ebp], 0
	je	SHORT $LN27@SetNumReal
	mov	edx, DWORD PTR $T230391[ebp]
	mov	DWORD PTR _inst$230394[ebp], edx
	mov	eax, DWORD PTR _inst$230394[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$230394[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN27@SetNumReal:

; 3043 : 
; 3044 : 		// Update the amount of a Resource used up by this Building
; 3045 : 		int iNumResources = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResources$220270[ebp], eax

; 3046 : 		for(int iResourceLoop = 0; iResourceLoop < iNumResources; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$220271[ebp], 0
	jmp	SHORT $LN26@SetNumReal
$LN25@SetNumReal:
	mov	ecx, DWORD PTR _iResourceLoop$220271[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$220271[ebp], ecx
$LN26@SetNumReal:
	mov	edx, DWORD PTR _iResourceLoop$220271[ebp]
	cmp	edx, DWORD PTR _iNumResources$220270[ebp]
	jge	SHORT $LN24@SetNumReal

; 3047 : 		{
; 3048 : 			if(buildingEntry->GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	eax, DWORD PTR _iResourceLoop$220271[ebp]
	push	eax
	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	SHORT $LN23@SetNumReal

; 3049 : 			{
; 3050 : 				pPlayer->changeNumResourceUsed((ResourceTypes) iResourceLoop, iChangeNumRealBuilding * buildingEntry->GetResourceQuantityRequirement(iResourceLoop));

	mov	ecx, DWORD PTR _iResourceLoop$220271[ebp]
	push	ecx
	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetResourceQuantityRequirement@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetResourceQuantityRequirement
	imul	eax, DWORD PTR _iChangeNumRealBuilding$[ebp]
	push	eax
	mov	edx, DWORD PTR _iResourceLoop$220271[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN23@SetNumReal:

; 3051 : 			}
; 3052 : 		}

	jmp	SHORT $LN25@SetNumReal
$LN24@SetNumReal:

; 3053 : 
; 3054 : 		if(iChangeNumRealBuilding > 0)

	cmp	DWORD PTR _iChangeNumRealBuilding$[ebp], 0
	jle	$LN22@SetNumReal

; 3055 : 		{
; 3056 : 			if(bFirst)

	movzx	eax, BYTE PTR _bFirst$[ebp]
	test	eax, eax
	je	$LN22@SetNumReal

; 3057 : 			{
; 3058 : 				if(GC.getGame().isFinalInitialized()/* && !(gDLL->GetWorldBuilderMode() )*/)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230399[ebp], ecx
	mov	ecx, DWORD PTR $T230399[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	edx, al
	test	edx, edx
	je	$LN20@SetNumReal

; 3059 : 				{
; 3060 : 					// World Wonder Notification
; 3061 : 					if(isWorldWonderClass(kBuildingClassInfo))

	mov	eax, DWORD PTR _kBuildingClassInfo$[ebp]
	push	eax
	call	?isWorldWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isWorldWonderClass
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	$LN20@SetNumReal

; 3062 : 					{
; 3063 : 						Localization::String localizedText = Localization::Lookup("TXT_KEY_MISC_COMPLETES_WONDER");

	push	OFFSET ??_C@_0BO@IILDKBEJ@TXT_KEY_MISC_COMPLETES_WONDER?$AA@
	lea	edx, DWORD PTR _localizedText$220281[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3064 : 						localizedText << pPlayer->getNameKey() << buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T230258[ebp], eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T230259[ebp], eax
	lea	eax, DWORD PTR $T230258[ebp]
	push	eax
	lea	ecx, DWORD PTR $T230259[ebp]
	push	ecx
	lea	edx, DWORD PTR _localizedText$220281[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3065 : 						GC.getGame().addReplayMessage(REPLAY_MESSAGE_MAJOR_EVENT, m_pCity->getOwner(), localizedText.toUTF8(), m_pCity->getX(), m_pCity->getY());

	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	mov	DWORD PTR $T230408[ebp], eax
	cmp	DWORD PTR $T230408[ebp], 0
	je	SHORT $LN129@SetNumReal
	mov	eax, DWORD PTR $T230408[ebp]
	mov	DWORD PTR tv203[ebp], eax
	jmp	SHORT $LN130@SetNumReal
$LN129@SetNumReal:
	mov	DWORD PTR tv203[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN130@SetNumReal:
	mov	ecx, DWORD PTR tv203[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T230260[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T230417[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T230426[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T230435[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230439[ebp], edx
	mov	eax, DWORD PTR $T230417[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230426[ebp]
	push	ecx
	lea	edx, DWORD PTR $T230260[ebp]
	push	edx
	mov	eax, DWORD PTR $T230435[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR $T230439[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T230260[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3066 : 
; 3067 : 						bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

	mov	ecx, DWORD PTR $T230447[ebp]
	mov	DWORD PTR tv446[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv446[ebp], edx
	mov	eax, DWORD PTR tv446[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv446[ebp]
	mov	eax, DWORD PTR [edx+456]
	call	eax
	mov	BYTE PTR _bDontShowRewardPopup$220292[ebp], al

; 3068 : 
; 3069 : 						// Notification in MP games
; 3070 : 						if(bDontShowRewardPopup || GC.getGame().isNetworkMultiPlayer())	// KWG: Candidate for !GC.getGame().IsOption(GAMEOPTION_SIMULTANEOUS_TURNS)

	movzx	ecx, BYTE PTR _bDontShowRewardPopup$220292[ebp]
	test	ecx, ecx
	jne	SHORT $LN155@SetNumReal
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230451[ebp], edx
	mov	ecx, DWORD PTR $T230451[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	eax, al
	test	eax, eax
	je	$LN173@SetNumReal

; 3071 : 						{
; 3072 : 							CvNotifications* pNotifications = GET_PLAYER(m_pCity->getOwner()).GetNotifications();

$LN155@SetNumReal:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230460[ebp], eax
	mov	ecx, DWORD PTR $T230460[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230464[ebp], ecx
	mov	ecx, DWORD PTR $T230464[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$220295[ebp], eax

; 3073 : 							if(pNotifications)

	cmp	DWORD PTR _pNotifications$220295[ebp], 0
	je	$LN16@SetNumReal

; 3074 : 							{
; 3075 : 								localizedText = Localization::Lookup("TXT_KEY_MISC_WONDER_COMPLETED");

	push	OFFSET ??_C@_0BO@FPKLCHCH@TXT_KEY_MISC_WONDER_COMPLETED?$AA@
	lea	edx, DWORD PTR $T230261[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv399[ebp], eax
	mov	eax, DWORD PTR tv399[ebp]
	mov	DWORD PTR tv814[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR tv814[ebp]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T230261[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3076 : 								localizedText << pPlayer->getNameKey() << buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T230262[ebp], eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T230263[ebp], eax
	lea	edx, DWORD PTR $T230262[ebp]
	push	edx
	lea	eax, DWORD PTR $T230263[ebp]
	push	eax
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3077 : 								pNotifications->Add(NOTIFICATION_WONDER_COMPLETED_ACTIVE_PLAYER, localizedText.toUTF8(), localizedText.toUTF8(), m_pCity->getX(), m_pCity->getY(), eIndex, pPlayer->GetID());

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230473[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T230482[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T230491[ebp], eax
	mov	ecx, DWORD PTR $T230473[ebp]
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR $T230482[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230491[ebp]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-1686889601				; 9b741b7fH
	mov	ecx, DWORD PTR _pNotifications$220295[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN16@SetNumReal:

; 3078 : 							}
; 3079 : 						}
; 3080 : 						// Popup in SP games
; 3081 : 						else

	jmp	$LN15@SetNumReal

; 3082 : 						{
; 3083 : 							if(m_pCity->getOwner() == GC.getGame().getActivePlayer())

$LN173@SetNumReal:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T230500[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230504[ebp], edx
	mov	ecx, DWORD PTR $T230504[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T230500[ebp], eax
	jne	$LN15@SetNumReal

; 3084 : 							{
; 3085 : 								CvPopupInfo kPopup(BUTTONPOPUP_WONDER_COMPLETED_ACTIVE_PLAYER, eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR _kPopup$220303[ebp], eax
	mov	DWORD PTR _kPopup$220303[ebp+4], -1
	mov	DWORD PTR _kPopup$220303[ebp+8], -1
	mov	DWORD PTR _kPopup$220303[ebp+12], 0
	mov	BYTE PTR _kPopup$220303[ebp+16], 0
	mov	BYTE PTR _kPopup$220303[ebp+17], 0
	mov	DWORD PTR _kPopup$220303[ebp+20], 69	; 00000045H
	mov	BYTE PTR _kPopup$220303[ebp+24], 0

; 3086 : 								GC.GetEngineUserInterface()->AddPopup(kPopup);

	mov	ecx, DWORD PTR $T230511[ebp]
	mov	DWORD PTR tv565[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv565[ebp], edx
	lea	eax, DWORD PTR _kPopup$220303[ebp]
	push	eax
	mov	ecx, DWORD PTR tv565[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv565[ebp]
	mov	eax, DWORD PTR [edx+180]
	call	eax

; 3087 : 
; 3088 : 								if(GET_PLAYER(GC.getGame().getActivePlayer()).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230515[ebp], ecx
	mov	ecx, DWORD PTR $T230515[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR $T230519[ebp], eax
	mov	edx, DWORD PTR $T230519[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230520[ebp], edx
	mov	ecx, DWORD PTR $T230520[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@SetNumReal

; 3089 : 								{
; 3090 : 									gDLL->UnlockAchievement(ACHIEVEMENT_BUILD_WONDER);

	mov	ecx, DWORD PTR $T230524[ebp]
	mov	DWORD PTR tv590[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv590[ebp], edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR tv590[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv590[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 3091 : 
; 3092 : 									//look to see if all wonders have been built to unlock the other one
; 3093 : 									IncrementWonderStats(buildingClassType);

	mov	ecx, DWORD PTR _buildingClassType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ; CvCityBuildings::IncrementWonderStats
$LN15@SetNumReal:

; 3094 : 
; 3095 : 								}
; 3096 : 							}
; 3097 : 						}
; 3098 : 
; 3099 : 						// Wonder notification for all other players
; 3100 : 						for(int iI = 0; iI < MAX_MAJOR_CIVS; iI++)

	mov	DWORD PTR _iI$220305[ebp], 0
	jmp	SHORT $LN12@SetNumReal
$LN11@SetNumReal:
	mov	edx, DWORD PTR _iI$220305[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$220305[ebp], edx
$LN12@SetNumReal:
	cmp	DWORD PTR _iI$220305[ebp], 22		; 00000016H
	jge	$LN10@SetNumReal

; 3101 : 						{
; 3102 : 							CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$220305[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$220309[ebp], eax

; 3103 : 							if(thisPlayer.isAlive())

	mov	ecx, DWORD PTR _thisPlayer$220309[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T230536[ebp], dl
	movzx	eax, BYTE PTR $T230536[ebp]
	test	eax, eax
	je	$LN227@SetNumReal

; 3104 : 							{
; 3105 : 								// Owner already got his messaging
; 3106 : 								if(iI != m_pCity->getOwner())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T230545[ebp], eax
	mov	ecx, DWORD PTR _iI$220305[ebp]
	cmp	ecx, DWORD PTR $T230545[ebp]
	je	$LN227@SetNumReal

; 3107 : 								{
; 3108 : 									// If the builder is met, and the city is revealed
; 3109 : 									// Special case for DLC_06 Scenario: Always show the more informative notification
; 3110 : 									if((m_pCity->plot()->isRevealed(thisPlayer.getTeam()) && GET_TEAM(thisPlayer.getTeam()).isHasMet(m_pCity->getTeam())) || gDLL->IsModActivated(CIV5_DLC_06_SCENARIO_MODID))

	mov	edx, DWORD PTR _thisPlayer$220309[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T230554[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T230565[ebp], eax
	mov	edx, DWORD PTR $T230554[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$230563[ebp], edx
	mov	eax, DWORD PTR _uiOffset$230563[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T230554[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$230563[ebp]
	mov	ecx, DWORD PTR $T230565[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@SetNumReal
	mov	ecx, DWORD PTR _thisPlayer$220309[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T230574[ebp], eax
	mov	eax, DWORD PTR $T230574[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T230578[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR $T230578[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@SetNumReal
$LN5@SetNumReal:
	mov	eax, DWORD PTR $T230582[ebp]
	mov	DWORD PTR tv649[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv649[ebp], ecx
	mov	edx, DWORD PTR _CIV5_DLC_06_SCENARIO_MODID
	push	edx
	mov	eax, DWORD PTR tv649[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv649[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@SetNumReal
$LN6@SetNumReal:

; 3111 : 									{
; 3112 : 										CvNotifications* pNotifications = thisPlayer.GetNotifications();

	mov	ecx, DWORD PTR _thisPlayer$220309[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$220316[ebp], eax

; 3113 : 										if(pNotifications)

	cmp	DWORD PTR _pNotifications$220316[ebp], 0
	je	$LN4@SetNumReal

; 3114 : 										{
; 3115 : 											localizedText = Localization::Lookup("TXT_KEY_MISC_WONDER_COMPLETED");

	push	OFFSET ??_C@_0BO@FPKLCHCH@TXT_KEY_MISC_WONDER_COMPLETED?$AA@
	lea	edx, DWORD PTR $T230264[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv816[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR tv816[ebp]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T230264[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3116 : 											localizedText << pPlayer->getNameKey() << buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T230265[ebp], eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNameKey@CvPlayer@@QBEPBDXZ		; CvPlayer::getNameKey
	mov	DWORD PTR $T230266[ebp], eax
	lea	edx, DWORD PTR $T230265[ebp]
	push	edx
	lea	eax, DWORD PTR $T230266[ebp]
	push	eax
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3117 : 											pNotifications->Add(NOTIFICATION_WONDER_COMPLETED, localizedText.toUTF8(), localizedText.toUTF8(), m_pCity->getX(), m_pCity->getY(), eIndex, pPlayer->GetID());

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230591[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T230600[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T230609[ebp], eax
	mov	ecx, DWORD PTR $T230591[ebp]
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR $T230600[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230609[ebp]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	2091697919				; 7cacc6ffH
	mov	ecx, DWORD PTR _pNotifications$220316[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN4@SetNumReal:

; 3118 : 										}
; 3119 : 									}
; 3120 : 									else

	jmp	$LN227@SetNumReal
$LN7@SetNumReal:

; 3121 : 									{
; 3122 : 										CvNotifications* pNotifications = thisPlayer.GetNotifications();

	mov	ecx, DWORD PTR _thisPlayer$220309[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$220322[ebp], eax

; 3123 : 										if(pNotifications)

	cmp	DWORD PTR _pNotifications$220322[ebp], 0
	je	$LN227@SetNumReal

; 3124 : 										{
; 3125 : 											localizedText = Localization::Lookup("TXT_KEY_MISC_WONDER_COMPLETED_UNKNOWN");

	push	OFFSET ??_C@_0CG@NCAKKGBJ@TXT_KEY_MISC_WONDER_COMPLETED_UN@
	lea	edx, DWORD PTR $T230267[ebp]
	push	edx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR tv943[ebp], eax
	mov	eax, DWORD PTR tv943[ebp]
	mov	DWORD PTR tv818[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR tv818[ebp]
	push	ecx
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_??4String@Localization@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T230267[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 3126 : 											localizedText <<  buildingEntry->GetTextKey();

	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T230268[ebp], eax
	lea	edx, DWORD PTR $T230268[ebp]
	push	edx
	lea	eax, DWORD PTR _localizedText$220281[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 3127 : 											pNotifications->Add(NOTIFICATION_WONDER_COMPLETED, localizedText.toUTF8(), localizedText.toUTF8(), -1, -1, eIndex, -1);

	push	-1
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	push	-1
	push	-1
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	2091697919				; 7cacc6ffH
	mov	ecx, DWORD PTR _pNotifications$220322[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3128 : 										}
; 3129 : 									}
; 3130 : 								}
; 3131 : 							}
; 3132 : 
; 3133 : 							//Achievements!
; 3134 : 							if(pPlayer->GetID() == GC.getGame().getActivePlayer() && strcmp(buildingEntry->GetType(), "BUILDING_GREAT_FIREWALL") == 0)

$LN227@SetNumReal:
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T230618[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230622[ebp], ecx
	mov	ecx, DWORD PTR $T230622[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T230618[ebp], eax
	jne	$LN1@SetNumReal
	mov	DWORD PTR tv1292[ebp], OFFSET ??_C@_0BI@LMJFBOA@BUILDING_GREAT_FIREWALL?$AA@
	mov	ecx, DWORD PTR _buildingEntry$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv1291[ebp], eax
$LL262@SetNumReal:
	mov	edx, DWORD PTR tv1291[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1295[ebp], al
	mov	ecx, DWORD PTR tv1292[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN263@SetNumReal
	cmp	BYTE PTR tv1295[ebp], 0
	je	SHORT $LN264@SetNumReal
	mov	edx, DWORD PTR tv1291[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv1302[ebp], al
	mov	ecx, DWORD PTR tv1292[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN263@SetNumReal
	add	DWORD PTR tv1291[ebp], 2
	add	DWORD PTR tv1292[ebp], 2
	cmp	BYTE PTR tv1302[ebp], 0
	jne	SHORT $LL262@SetNumReal
$LN264@SetNumReal:
	mov	DWORD PTR tv1307[ebp], 0
	jmp	SHORT $LN265@SetNumReal
$LN263@SetNumReal:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv1307[ebp], edx
$LN265@SetNumReal:
	mov	eax, DWORD PTR tv1307[ebp]
	mov	DWORD PTR tv753[ebp], eax
	cmp	DWORD PTR tv753[ebp], 0
	jne	SHORT $LN1@SetNumReal

; 3135 : 							{
; 3136 : 								gDLL->UnlockAchievement(ACHIEVEMENT_XP1_16);

	mov	ecx, DWORD PTR $T230629[ebp]
	mov	DWORD PTR tv762[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv762[ebp], edx
	push	206					; 000000ceH
	mov	eax, DWORD PTR tv762[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv762[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN1@SetNumReal:

; 3137 : 							}
; 3138 : 						}

	jmp	$LN11@SetNumReal
$LN10@SetNumReal:

; 3139 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN20@SetNumReal:

; 3140 : 				}
; 3141 : 
; 3142 : 				GC.getGame().incrementBuildingClassCreatedCount(buildingClassType);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230633[ebp], ecx
	mov	edx, DWORD PTR _buildingClassType$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230633[ebp]
	call	?incrementBuildingClassCreatedCount@CvGame@@QAEXW4BuildingClassTypes@@@Z ; CvGame::incrementBuildingClassCreatedCount
$LN22@SetNumReal:

; 3143 : 			}
; 3144 : 		}
; 3145 : 
; 3146 : 		m_pCity->updateStrengthValue();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?updateStrengthValue@CvCity@@QAEXXZ	; CvCity::updateStrengthValue

; 3147 : 
; 3148 : 		// Building might affect City Banner stats
; 3149 : 		auto_ptr<ICvCity1> pCity = GC.WrapCityPointer(m_pCity);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	lea	eax, DWORD PTR $T230269[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapCityPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvCity1@@@std@@PAVCvCity@@@Z ; CvGlobals::WrapCityPointer
	mov	DWORD PTR $T230644[ebp], eax
	mov	ecx, DWORD PTR $T230644[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Cvtptr$230639[ebp], edx
	mov	eax, DWORD PTR __Cvtptr$230639[ebp]
	mov	DWORD PTR __Ans$230640[ebp], eax
	mov	ecx, DWORD PTR $T230644[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR __Ans$230640[ebp]
	mov	DWORD PTR $T230270[ebp], edx
	mov	eax, DWORD PTR $T230270[ebp]
	mov	DWORD PTR $T230649[ebp], eax
	mov	ecx, DWORD PTR $T230649[ebp]
	mov	DWORD PTR __Ptr$230648[ebp], ecx
	mov	DWORD PTR $T230649[ebp], 0
	mov	edx, DWORD PTR __Ptr$230648[ebp]
	mov	DWORD PTR _pCity$220330[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	eax, DWORD PTR $T230269[ebp]
	mov	DWORD PTR $T230658[ebp], eax
	cmp	DWORD PTR $T230658[ebp], 0
	je	SHORT $LN243@SetNumReal
	mov	ecx, DWORD PTR $T230658[ebp]
	mov	DWORD PTR _inst$230662[ebp], ecx
	mov	edx, DWORD PTR _inst$230662[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$230662[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN243@SetNumReal:

; 3150 : 		GC.GetEngineUserInterface()->SetSpecificCityInfoDirty(pCity.get(), CITY_UPDATE_TYPE_BANNER);

	mov	eax, DWORD PTR $T230667[ebp]
	mov	DWORD PTR tv793[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv793[ebp], ecx
	push	0
	mov	edx, DWORD PTR _pCity$220330[ebp]
	push	edx
	mov	eax, DWORD PTR tv793[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv793[ebp]
	mov	eax, DWORD PTR [edx+440]
	call	eax

; 3151 : 
; 3152 : 		//Test for any achievements being unlocked.
; 3153 : 		pPlayer->GetPlayerAchievements().FinishedBuilding(m_pCity, eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	add	ecx, 63156				; 0000f6b4H
	call	?FinishedBuilding@CvPlayerAchievements@@QAEXPAVCvCity@@W4BuildingTypes@@@Z ; CvPlayerAchievements::FinishedBuilding

; 3154 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _pCity$220330[ebp]
	mov	DWORD PTR $T230682[ebp], ecx
	cmp	DWORD PTR $T230682[ebp], 0
	je	SHORT $LN254@SetNumReal
	mov	edx, DWORD PTR $T230682[ebp]
	mov	DWORD PTR _inst$230686[ebp], edx
	mov	eax, DWORD PTR _inst$230686[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$230686[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN254@SetNumReal:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szBuildingType$220183[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN50@SetNumReal:

; 3155 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$0:
	lea	ecx, DWORD PTR _szBuildingType$220183[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$1:
	mov	eax, DWORD PTR $T230251[ebp]
	push	eax
	call	??3CvDllCity@@SAXPAX@Z			; CvDllCity::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$2:
	lea	ecx, DWORD PTR _pDllCity$220193[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$3:
	mov	eax, DWORD PTR $T230255[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$4:
	lea	ecx, DWORD PTR _pDllPlot$220260[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$5:
	lea	ecx, DWORD PTR _localizedText$220281[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$6:
	lea	ecx, DWORD PTR $T230260[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$7:
	lea	ecx, DWORD PTR $T230261[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$8:
	lea	ecx, DWORD PTR $T230264[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$9:
	lea	ecx, DWORD PTR $T230267[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z$11:
	lea	ecx, DWORD PTR _pCity$220330[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__ehhandler$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1392]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetNumRealBuildingTimed@CvCityBuildings@@QAEXW4BuildingTypes@@H_NW4PlayerTypes@@H@Z ENDP ; CvCityBuildings::SetNumRealBuildingTimed
; Function compile flags: /Odtp
;	COMDAT ?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z PROC ; CvCityBuildings::GetNumFreeBuilding, COMDAT
; _this$ = ecx

; 3159 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3160 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 3161 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 3162 : 	return m_paiNumFreeBuilding[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 3163 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ENDP ; CvCityBuildings::GetNumFreeBuilding
_TEXT	ENDS
PUBLIC	?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ; CvCityBuildings::SetNumFreeBuilding
; Function compile flags: /Odtp
;	COMDAT ?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iOldNumBuilding$220343 = -4				; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z PROC ; CvCityBuildings::SetNumFreeBuilding, COMDAT
; _this$ = ecx

; 3167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3168 : 	CvAssertMsg(eIndex >= 0, "eIndex expected to be >= 0");
; 3169 : 	CvAssertMsg(eIndex < m_pBuildings->GetNumBuildings(), "eIndex expected to be < m_pBuildings->GetNumBuildings()");
; 3170 : 
; 3171 : 	if (GetNumFreeBuilding(eIndex) != iNewValue)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumFreeBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumFreeBuilding
	cmp	eax, DWORD PTR _iNewValue$[ebp]
	je	$LN5@SetNumFree

; 3172 : 	{
; 3173 : 		int iOldNumBuilding = GetNumBuilding(eIndex);

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	mov	DWORD PTR _iOldNumBuilding$220343[ebp], eax

; 3174 : 
; 3175 : 		if (iOldNumBuilding > 0 && iNewValue > 0)

	cmp	DWORD PTR _iOldNumBuilding$220343[ebp], 0
	jle	SHORT $LN3@SetNumFree
	cmp	DWORD PTR _iNewValue$[ebp], 0
	jle	SHORT $LN3@SetNumFree

; 3176 : 		{
; 3177 : 			DoSellBuilding(eIndex);

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoSellBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@@Z ; CvCityBuildings::DoSellBuilding

; 3178 : 			m_paiNumFreeBuilding[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 3179 : 			m_pCity->processBuilding(eIndex, iNewValue, true);			

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z ; CvCity::processBuilding

; 3180 : 		}
; 3181 : 		
; 3182 : 		else

	jmp	SHORT $LN5@SetNumFree
$LN3@SetNumFree:

; 3183 : 		{
; 3184 : 			m_paiNumFreeBuilding[eIndex] = iNewValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 3185 : 
; 3186 : 			if (iOldNumBuilding != GetNumBuilding(eIndex))

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	cmp	DWORD PTR _iOldNumBuilding$220343[ebp], eax
	je	SHORT $LN5@SetNumFree

; 3187 : 			{
; 3188 : 				m_pCity->processBuilding(eIndex, iNewValue - iOldNumBuilding, true);

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _iNewValue$[ebp]
	sub	eax, DWORD PTR _iOldNumBuilding$220343[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?processBuilding@CvCity@@QAEXW4BuildingTypes@@H_N11@Z ; CvCity::processBuilding
$LN5@SetNumFree:

; 3189 : 			}
; 3190 : 		}
; 3191 : 	}
; 3192 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetNumFreeBuilding@CvCityBuildings@@QAEXW4BuildingTypes@@H@Z ENDP ; CvCityBuildings::SetNumFreeBuilding
_TEXT	ENDS
PUBLIC	?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z ; CvCityBuildings::GetBuildingYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T230725 = -16						; size = 4
$T230713 = -12						; size = 4
$T230708 = -8						; size = 4
_it$220460 = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_eYield$ = 12						; size = 4
?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z PROC ; CvCityBuildings::GetBuildingYieldChange, COMDAT
; _this$ = ecx

; 3196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3197 : 	for(std::vector<BuildingYieldChange>::const_iterator it = m_aBuildingYieldChange.begin(); it != m_aBuildingYieldChange.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR $T230713[ebp], ecx
	mov	edx, DWORD PTR $T230713[ebp]
	mov	DWORD PTR _it$220460[ebp], edx
	jmp	SHORT $LN4@GetBuildin@3
$LN3@GetBuildin@3:
	mov	eax, DWORD PTR _it$220460[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _it$220460[ebp], eax
$LN4@GetBuildin@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T230725[ebp], edx
	mov	eax, DWORD PTR $T230725[ebp]
	mov	DWORD PTR $T230708[ebp], eax
	mov	ecx, DWORD PTR _it$220460[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T230708[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetBuildin@3

; 3198 : 	{
; 3199 : 		if((*it).eBuildingClass == eBuildingClass && (*it).eYield == eYield)

	mov	edx, DWORD PTR _it$220460[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eBuildingClass$[ebp]
	jne	SHORT $LN1@GetBuildin@3
	mov	ecx, DWORD PTR _it$220460[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _eYield$[ebp]
	jne	SHORT $LN1@GetBuildin@3

; 3200 : 		{
; 3201 : 			return (*it).iChange;

	mov	eax, DWORD PTR _it$220460[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN5@GetBuildin@3
$LN1@GetBuildin@3:

; 3202 : 		}
; 3203 : 	}

	jmp	SHORT $LN3@GetBuildin@3
$LN2@GetBuildin@3:

; 3204 : 
; 3205 : 	return 0;

	xor	eax, eax
$LN5@GetBuildin@3:

; 3206 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z ENDP ; CvCityBuildings::GetBuildingYieldChange
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back
PUBLIC	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
PUBLIC	?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvCityBuildings::SetBuildingYieldChange
EXTRN	?getCivilizationInfo@CvCity@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvCity::getCivilizationInfo
EXTRN	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z:PROC ; CvCity::ChangeBaseYieldRateFromBuildings
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvCity::getCivilizationType
; Function compile flags: /Odtp
;	COMDAT ?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_this$ = -164						; size = 4
$T230785 = -48						; size = 4
$T230761 = -44						; size = 4
$T230751 = -40						; size = 4
$T230750 = -36						; size = 4
$T230749 = -32						; size = 4
_eBuilding$220539 = -28					; size = 4
_kChange$220538 = -24					; size = 12
_eBuilding$220533 = -12					; size = 4
_iOldChange$220527 = -8					; size = 4
_it$220520 = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_eYield$ = 12						; size = 4
_iChange$ = 16						; size = 4
?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z PROC ; CvCityBuildings::SetBuildingYieldChange, COMDAT
; _this$ = ecx

; 3210 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3211 : #ifdef AUI_WARNING_FIXES
; 3212 : 	CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3213 : 	if (!pCivInfo)
; 3214 : 		return;
; 3215 : #endif
; 3216 : 	for(std::vector<BuildingYieldChange>::iterator it = m_aBuildingYieldChange.begin(); it != m_aBuildingYieldChange.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR $T230761[ebp], ecx
	mov	edx, DWORD PTR $T230761[ebp]
	mov	DWORD PTR _it$220520[ebp], edx
	jmp	SHORT $LN12@SetBuildin@2
$LN11@SetBuildin@2:
	mov	eax, DWORD PTR _it$220520[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _it$220520[ebp], eax
$LN12@SetBuildin@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T230785[ebp], edx
	mov	eax, DWORD PTR $T230785[ebp]
	mov	DWORD PTR $T230749[ebp], eax
	mov	ecx, DWORD PTR _it$220520[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T230749[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@SetBuildin@2

; 3217 : 	{
; 3218 : 		if((*it).eBuildingClass == eBuildingClass && (*it).eYield == eYield)

	mov	edx, DWORD PTR _it$220520[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eBuildingClass$[ebp]
	jne	$LN9@SetBuildin@2
	mov	ecx, DWORD PTR _it$220520[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _eYield$[ebp]
	jne	$LN9@SetBuildin@2

; 3219 : 		{
; 3220 : 			int iOldChange = (*it).iChange;

	mov	eax, DWORD PTR _it$220520[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _iOldChange$220527[ebp], ecx

; 3221 : 			if(iOldChange != iChange)

	mov	edx, DWORD PTR _iOldChange$220527[ebp]
	cmp	edx, DWORD PTR _iChange$[ebp]
	je	$LN8@SetBuildin@2

; 3222 : 			{
; 3223 : 
; 3224 : 				if(iChange == 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	jne	SHORT $LN81@SetBuildin@2

; 3225 : 				{
; 3226 : 					m_aBuildingYieldChange.erase(it);

	mov	eax, DWORD PTR _it$220520[ebp]
	mov	DWORD PTR $T230750[ebp], eax
	mov	ecx, DWORD PTR $T230750[ebp]
	push	ecx
	lea	edx, DWORD PTR $T230751[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase

; 3227 : 				}
; 3228 : 				else

	jmp	SHORT $LN6@SetBuildin@2

; 3229 : 				{
; 3230 : 					(*it).iChange = iChange;

$LN81@SetBuildin@2:
	mov	eax, DWORD PTR _it$220520[ebp]
	mov	ecx, DWORD PTR _iChange$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN6@SetBuildin@2:

; 3231 : 				}
; 3232 : 
; 3233 : #ifdef AUI_WARNING_FIXES
; 3234 : 				BuildingTypes eBuilding = (BuildingTypes)pCivInfo->getCivilizationBuildings(eBuildingClass);
; 3235 : #else
; 3236 : 				BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(m_pCity->getCivilizationType())->getCivilizationBuildings(eBuildingClass);

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220533[ebp], eax

; 3237 : #endif
; 3238 : 				if(NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220533[ebp], -1
	je	SHORT $LN8@SetBuildin@2

; 3239 : 				{
; 3240 : 					if(GetNumActiveBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220533[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	test	eax, eax
	jle	SHORT $LN8@SetBuildin@2

; 3241 : 					{
; 3242 : 						m_pCity->ChangeBaseYieldRateFromBuildings(eYield, (iChange - iOldChange) * GetNumActiveBuilding(eBuilding));

	mov	esi, DWORD PTR _iChange$[ebp]
	sub	esi, DWORD PTR _iOldChange$220527[ebp]
	mov	edx, DWORD PTR _eBuilding$220533[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	imul	esi, eax
	push	esi
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromBuildings
$LN8@SetBuildin@2:

; 3243 : 					}
; 3244 : 				}
; 3245 : 			}
; 3246 : 
; 3247 : 			return;

	jmp	$LN13@SetBuildin@2
$LN9@SetBuildin@2:

; 3248 : 		}
; 3249 : 	}

	jmp	$LN11@SetBuildin@2
$LN10@SetBuildin@2:

; 3250 : 
; 3251 : 	if(0 != iChange)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN13@SetBuildin@2

; 3252 : 	{
; 3253 : 		BuildingYieldChange kChange;

	mov	DWORD PTR _kChange$220538[ebp], -1
	mov	DWORD PTR _kChange$220538[ebp+4], -1
	mov	DWORD PTR _kChange$220538[ebp+8], 0

; 3254 : 		kChange.eBuildingClass = eBuildingClass;

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	mov	DWORD PTR _kChange$220538[ebp], edx

; 3255 : 		kChange.eYield = eYield;

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR _kChange$220538[ebp+4], eax

; 3256 : 		kChange.iChange = iChange;

	mov	ecx, DWORD PTR _iChange$[ebp]
	mov	DWORD PTR _kChange$220538[ebp+8], ecx

; 3257 : 		m_aBuildingYieldChange.push_back(kChange);

	lea	edx, DWORD PTR _kChange$220538[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back

; 3258 : 
; 3259 : 		BuildingTypes eBuilding = (BuildingTypes)m_pCity->getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+112]
	call	?getCivilizationInfo@CvCity@@QBEAAVCvCivilizationInfo@@XZ ; CvCity::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220539[ebp], eax

; 3260 : 		if(NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220539[ebp], -1
	je	SHORT $LN13@SetBuildin@2

; 3261 : 		{
; 3262 : 			if(GetNumActiveBuilding(eBuilding) > 0)

	mov	edx, DWORD PTR _eBuilding$220539[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	test	eax, eax
	jle	SHORT $LN13@SetBuildin@2

; 3263 : 			{
; 3264 : 				m_pCity->ChangeBaseYieldRateFromBuildings(eYield, iChange * GetNumActiveBuilding(eBuilding));

	mov	eax, DWORD PTR _eBuilding$220539[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?ChangeBaseYieldRateFromBuildings@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromBuildings
$LN13@SetBuildin@2:

; 3265 : 			}
; 3266 : 		}
; 3267 : 	}
; 3268 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ENDP ; CvCityBuildings::SetBuildingYieldChange
_TEXT	ENDS
PUBLIC	?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvCityBuildings::ChangeBuildingYieldChange
; Function compile flags: /Odtp
;	COMDAT ?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_eYield$ = 12						; size = 4
_iChange$ = 16						; size = 4
?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z PROC ; CvCityBuildings::ChangeBuildingYieldChange, COMDAT
; _this$ = ecx

; 3272 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3273 : 	SetBuildingYieldChange(eBuildingClass, eYield, GetBuildingYieldChange(eBuildingClass, eYield) + iChange);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuildingClass$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingYieldChange@CvCityBuildings@@QBEHW4BuildingClassTypes@@W4YieldTypes@@@Z ; CvCityBuildings::GetBuildingYieldChange
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ; CvCityBuildings::SetBuildingYieldChange

; 3274 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChangeBuildingYieldChange@CvCityBuildings@@QAEXW4BuildingClassTypes@@W4YieldTypes@@H@Z ENDP ; CvCityBuildings::ChangeBuildingYieldChange
_TEXT	ENDS
PUBLIC	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T231091 = -16						; size = 4
$T231079 = -12						; size = 4
$T231074 = -8						; size = 4
_it$220662 = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_iSlot$ = 12						; size = 4
?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z PROC ; CvCityBuildings::GetBuildingGreatWork, COMDAT
; _this$ = ecx

; 3282 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3283 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231079[ebp], ecx
	mov	edx, DWORD PTR $T231079[ebp]
	mov	DWORD PTR _it$220662[ebp], edx
	jmp	SHORT $LN4@GetBuildin@4
$LN3@GetBuildin@4:
	mov	eax, DWORD PTR _it$220662[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _it$220662[ebp], eax
$LN4@GetBuildin@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T231091[ebp], edx
	mov	eax, DWORD PTR $T231091[ebp]
	mov	DWORD PTR $T231074[ebp], eax
	mov	ecx, DWORD PTR _it$220662[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T231074[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetBuildin@4

; 3284 : 	{
; 3285 : 		if((*it).eBuildingClass == eBuildingClass && (*it).iSlot == iSlot)

	mov	edx, DWORD PTR _it$220662[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eBuildingClass$[ebp]
	jne	SHORT $LN1@GetBuildin@4
	mov	ecx, DWORD PTR _it$220662[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _iSlot$[ebp]
	jne	SHORT $LN1@GetBuildin@4

; 3286 : 		{
; 3287 : 			return (*it).iGreatWorkIndex;

	mov	eax, DWORD PTR _it$220662[ebp]
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN5@GetBuildin@4
$LN1@GetBuildin@4:

; 3288 : 		}
; 3289 : 	}

	jmp	SHORT $LN3@GetBuildin@4
$LN2@GetBuildin@4:

; 3290 : 
; 3291 : 	return -1;

	or	eax, -1
$LN5@GetBuildin@4:

; 3292 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ENDP ; CvCityBuildings::GetBuildingGreatWork
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back
PUBLIC	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
PUBLIC	?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ; CvCityBuildings::SetBuildingGreatWork
; Function compile flags: /Odtp
;	COMDAT ?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z
_TEXT	SEGMENT
tv164 = -160						; size = 4
tv147 = -156						; size = 4
_this$ = -152						; size = 4
$T231428 = -148						; size = 4
$T231305 = -88						; size = 4
$T231151 = -40						; size = 4
$T231127 = -36						; size = 4
$T231117 = -32						; size = 4
$T231116 = -28						; size = 4
$T231115 = -24						; size = 4
_kWork$220736 = -20					; size = 12
_iOldGreatWorkIndex$220729 = -8				; size = 4
_it$220722 = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_iSlot$ = 12						; size = 4
_iGreatWorkIndex$ = 16					; size = 4
?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z PROC ; CvCityBuildings::SetBuildingGreatWork, COMDAT
; _this$ = ecx

; 3300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	DWORD PTR _this$[ebp], ecx

; 3301 : 	for(std::vector<BuildingGreatWork>::iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231127[ebp], ecx
	mov	edx, DWORD PTR $T231127[ebp]
	mov	DWORD PTR _it$220722[ebp], edx
	jmp	SHORT $LN8@SetBuildin@3
$LN7@SetBuildin@3:
	mov	eax, DWORD PTR _it$220722[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _it$220722[ebp], eax
$LN8@SetBuildin@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T231151[ebp], edx
	mov	eax, DWORD PTR $T231151[ebp]
	mov	DWORD PTR $T231115[ebp], eax
	mov	ecx, DWORD PTR _it$220722[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T231115[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@SetBuildin@3

; 3302 : 	{
; 3303 : 		if((*it).eBuildingClass == eBuildingClass && (*it).iSlot == iSlot)

	mov	edx, DWORD PTR _it$220722[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eBuildingClass$[ebp]
	jne	SHORT $LN5@SetBuildin@3
	mov	ecx, DWORD PTR _it$220722[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _iSlot$[ebp]
	jne	SHORT $LN5@SetBuildin@3

; 3304 : 		{
; 3305 : 			int iOldGreatWorkIndex = (*it).iGreatWorkIndex;

	mov	eax, DWORD PTR _it$220722[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _iOldGreatWorkIndex$220729[ebp], ecx

; 3306 : 			if (iOldGreatWorkIndex != iGreatWorkIndex)

	mov	edx, DWORD PTR _iOldGreatWorkIndex$220729[ebp]
	cmp	edx, DWORD PTR _iGreatWorkIndex$[ebp]
	je	SHORT $LN4@SetBuildin@3

; 3307 : 			{
; 3308 : 				if (iGreatWorkIndex == -1)

	cmp	DWORD PTR _iGreatWorkIndex$[ebp], -1
	jne	SHORT $LN72@SetBuildin@3

; 3309 : 				{
; 3310 : 					m_aBuildingGreatWork.erase(it);

	mov	eax, DWORD PTR _it$220722[ebp]
	mov	DWORD PTR $T231116[ebp], eax
	mov	ecx, DWORD PTR $T231116[ebp]
	push	ecx
	lea	edx, DWORD PTR $T231117[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase

; 3311 : 				}
; 3312 : 				else

	jmp	SHORT $LN4@SetBuildin@3

; 3313 : 				{
; 3314 : 					(*it).iGreatWorkIndex = iGreatWorkIndex;

$LN72@SetBuildin@3:
	mov	eax, DWORD PTR _it$220722[ebp]
	mov	ecx, DWORD PTR _iGreatWorkIndex$[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN4@SetBuildin@3:

; 3315 : 				}
; 3316 : 			}
; 3317 : 
; 3318 : 			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T231305[ebp]
	mov	DWORD PTR tv147[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv147[ebp], eax
	push	1
	push	18					; 00000012H
	mov	ecx, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv147[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax

; 3319 : 			return;

	jmp	SHORT $LN9@SetBuildin@3
$LN5@SetBuildin@3:

; 3320 : 		}
; 3321 : 	}

	jmp	$LN7@SetBuildin@3
$LN6@SetBuildin@3:

; 3322 : 
; 3323 : 	if (iGreatWorkIndex != -1)

	cmp	DWORD PTR _iGreatWorkIndex$[ebp], -1
	je	SHORT $LN1@SetBuildin@3

; 3324 : 	{
; 3325 : 		BuildingGreatWork kWork;

	mov	DWORD PTR _kWork$220736[ebp], -1
	mov	DWORD PTR _kWork$220736[ebp+4], -1
	mov	DWORD PTR _kWork$220736[ebp+8], -1

; 3326 : 		kWork.eBuildingClass = eBuildingClass;

	mov	ecx, DWORD PTR _eBuildingClass$[ebp]
	mov	DWORD PTR _kWork$220736[ebp], ecx

; 3327 : 		kWork.iSlot = iSlot;

	mov	edx, DWORD PTR _iSlot$[ebp]
	mov	DWORD PTR _kWork$220736[ebp+4], edx

; 3328 : 		kWork.iGreatWorkIndex = iGreatWorkIndex;

	mov	eax, DWORD PTR _iGreatWorkIndex$[ebp]
	mov	DWORD PTR _kWork$220736[ebp+8], eax

; 3329 : 		m_aBuildingGreatWork.push_back(kWork);

	lea	ecx, DWORD PTR _kWork$220736[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back
$LN1@SetBuildin@3:

; 3330 : 	}
; 3331 : 
; 3332 : 	GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T231428[ebp]
	mov	DWORD PTR tv164[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv164[ebp], eax
	push	1
	push	18					; 00000012H
	mov	ecx, DWORD PTR tv164[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv164[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN9@SetBuildin@3:

; 3333 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetBuildingGreatWork@CvCityBuildings@@QAEXW4BuildingClassTypes@@HH@Z ENDP ; CvCityBuildings::SetBuildingGreatWork
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T231448 = -16						; size = 4
$T231436 = -12						; size = 4
$T231431 = -8						; size = 4
_it$220745 = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::IsHoldingGreatWork, COMDAT
; _this$ = ecx

; 3337 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3338 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231436[ebp], ecx
	mov	edx, DWORD PTR $T231436[ebp]
	mov	DWORD PTR _it$220745[ebp], edx
	jmp	SHORT $LN4@IsHoldingG
$LN3@IsHoldingG:
	mov	eax, DWORD PTR _it$220745[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _it$220745[ebp], eax
$LN4@IsHoldingG:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T231448[ebp], edx
	mov	eax, DWORD PTR $T231448[ebp]
	mov	DWORD PTR $T231431[ebp], eax
	mov	ecx, DWORD PTR _it$220745[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T231431[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsHoldingG

; 3339 : 	{
; 3340 : 		if((*it).eBuildingClass == eBuildingClass)

	mov	edx, DWORD PTR _it$220745[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eBuildingClass$[ebp]
	jne	SHORT $LN1@IsHoldingG

; 3341 : 		{
; 3342 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@IsHoldingG
$LN1@IsHoldingG:

; 3343 : 		}
; 3344 : 	}

	jmp	SHORT $LN3@IsHoldingG
$LN2@IsHoldingG:

; 3345 : 	return false;

	xor	al, al
$LN5@IsHoldingG:

; 3346 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsHoldingGreatWork@CvCityBuildings@@QBE_NW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::IsHoldingGreatWork
_TEXT	ENDS
PUBLIC	?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ; CvCityBuildings::GetNumGreatWorksInBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T231483 = -20						; size = 4
$T231471 = -16						; size = 4
$T231466 = -12						; size = 4
_it$220761 = -8						; size = 4
_iCount$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::GetNumGreatWorksInBuilding, COMDAT
; _this$ = ecx

; 3355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3356 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3357 : #endif
; 3358 : 	for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T231471[ebp], ecx
	mov	edx, DWORD PTR $T231471[ebp]
	mov	DWORD PTR _it$220761[ebp], edx
	jmp	SHORT $LN4@GetNumGrea
$LN3@GetNumGrea:
	mov	eax, DWORD PTR _it$220761[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _it$220761[ebp], eax
$LN4@GetNumGrea:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T231483[ebp], edx
	mov	eax, DWORD PTR $T231483[ebp]
	mov	DWORD PTR $T231466[ebp], eax
	mov	ecx, DWORD PTR _it$220761[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T231466[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetNumGrea

; 3359 : 	{
; 3360 : 		if((*it).eBuildingClass == eBuildingClass)

	mov	edx, DWORD PTR _it$220761[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _eBuildingClass$[ebp]
	jne	SHORT $LN1@GetNumGrea

; 3361 : 		{
; 3362 : 			iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN1@GetNumGrea:

; 3363 : 		}
; 3364 : 	}

	jmp	SHORT $LN3@GetNumGrea
$LN2@GetNumGrea:

; 3365 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3366 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::GetNumGreatWorksInBuilding
_TEXT	ENDS
PUBLIC	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot
PUBLIC	?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ ; CvCityBuildings::HasAnyAvailableGreatWorkSlot
; Function compile flags: /Odtp
;	COMDAT ?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iSlot$ = -8						; size = 4
_eBuildingClass$ = -4					; size = 4
?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ PROC ; CvCityBuildings::HasAnyAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3371 : 	BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below

	mov	DWORD PTR _eBuildingClass$[ebp], -1

; 3372 : #ifdef AUI_WARNING_FIXES
; 3373 : 	uint iSlot = MAX_UNSIGNED_INT;
; 3374 : #else
; 3375 : 	int iSlot = -1; // Passed by reference below

	mov	DWORD PTR _iSlot$[ebp], -1

; 3376 : #endif
; 3377 : 
; 3378 : 	return GetNextAvailableGreatWorkSlot (&eBuildingClass, &iSlot);

	lea	eax, DWORD PTR _iSlot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _eBuildingClass$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot

; 3379 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasAnyAvailableGreatWorkSlot@CvCityBuildings@@QBE_NXZ ENDP ; CvCityBuildings::HasAnyAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot
PUBLIC	?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z ; CvCityBuildings::HasAvailableGreatWorkSlot
; Function compile flags: /Odtp
;	COMDAT ?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iSlot$ = -8						; size = 4
_eBuildingClass$ = -4					; size = 4
_eSlotType$ = 8						; size = 4
?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z PROC ; CvCityBuildings::HasAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3384 : 	BuildingClassTypes eBuildingClass = NO_BUILDINGCLASS; // Passed by reference below

	mov	DWORD PTR _eBuildingClass$[ebp], -1

; 3385 : #ifdef AUI_WARNING_FIXES
; 3386 : 	uint iSlot = MAX_UNSIGNED_INT;
; 3387 : #else
; 3388 : 	int iSlot = -1; // Passed by reference below

	mov	DWORD PTR _iSlot$[ebp], -1

; 3389 : #endif
; 3390 : 
; 3391 : 	return GetNextAvailableGreatWorkSlot (eSlotType, &eBuildingClass, &iSlot);

	lea	eax, DWORD PTR _iSlot$[ebp]
	push	eax
	lea	ecx, DWORD PTR _eBuildingClass$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eSlotType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ; CvCityBuildings::GetNextAvailableGreatWorkSlot

; 3392 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@@Z ENDP ; CvCityBuildings::HasAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumAvailableGreatWorkSlots
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
; Function compile flags: /Odtp
;	COMDAT ?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
_iNumSlots$220797 = -32					; size = 4
_iNumOpenSlots$220798 = -28				; size = 4
_pkBuilding$220795 = -24				; size = 4
_eBuilding$220791 = -20					; size = 4
_pkCivInfo$220789 = -16					; size = 4
_eLoopBuildingClass$220787 = -12			; size = 4
_iI$220783 = -8						; size = 4
_iCount$ = -4						; size = 4
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetNumAvailableGreatWorkSlots, COMDAT
; _this$ = ecx

; 3403 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3404 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3405 : 
; 3406 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220783[ebp], 0
	jmp	SHORT $LN8@GetNumAvai
$LN7@GetNumAvai:
	mov	eax, DWORD PTR _iI$220783[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220783[ebp], eax
$LN8@GetNumAvai:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220783[ebp], eax
	jge	$LN6@GetNumAvai

; 3407 : #endif
; 3408 : 	{
; 3409 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220783[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220787[ebp], ecx

; 3410 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivInfo$220789[ebp], eax

; 3411 : 		if (pkCivInfo)

	cmp	DWORD PTR _pkCivInfo$220789[ebp], 0
	je	SHORT $LN5@GetNumAvai

; 3412 : 		{
; 3413 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220787[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCivInfo$220789[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220791[ebp], eax

; 3414 : 			if(NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220791[ebp], -1
	je	SHORT $LN5@GetNumAvai

; 3415 : 			{
; 3416 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220791[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN5@GetNumAvai

; 3417 : 				{
; 3418 : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$220791[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuilding$220795[ebp], eax

; 3419 : 					if (pkBuilding)

	cmp	DWORD PTR _pkBuilding$220795[ebp], 0
	je	SHORT $LN5@GetNumAvai

; 3420 : 					{
; 3421 : #ifdef AUI_WARNING_FIXES
; 3422 : 						uint iNumSlots = pkBuilding->GetGreatWorkCount();
; 3423 : 						uint iNumGreatWorksInBuilding = GetNumGreatWorksInBuilding(eLoopBuildingClass);
; 3424 : 						if (iNumSlots > iNumGreatWorksInBuilding)
; 3425 : 						{
; 3426 : 							iCount += iNumSlots - iNumGreatWorksInBuilding;
; 3427 : #else
; 3428 : 						int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, DWORD PTR _pkBuilding$220795[ebp]
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	DWORD PTR _iNumSlots$220797[ebp], eax

; 3429 : 						int iNumOpenSlots = iNumSlots - GetNumGreatWorksInBuilding(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220787[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ; CvCityBuildings::GetNumGreatWorksInBuilding
	mov	ecx, DWORD PTR _iNumSlots$220797[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iNumOpenSlots$220798[ebp], ecx

; 3430 : 						if(iNumOpenSlots > 0)

	cmp	DWORD PTR _iNumOpenSlots$220798[ebp], 0
	jle	SHORT $LN5@GetNumAvai

; 3431 : 						{
; 3432 : 							iCount += iNumOpenSlots;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, DWORD PTR _iNumOpenSlots$220798[ebp]
	mov	DWORD PTR _iCount$[ebp], edx
$LN5@GetNumAvai:

; 3433 : #endif
; 3434 : 						}
; 3435 : 					}
; 3436 : 				}
; 3437 : 			}
; 3438 : 		}
; 3439 : 	}

	jmp	$LN7@GetNumAvai
$LN6@GetNumAvai:

; 3440 : 
; 3441 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3442 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetNumAvailableGreatWorkSlots
_TEXT	ENDS
PUBLIC	?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumAvailableGreatWorkSlots
; Function compile flags: /Odtp
;	COMDAT ?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_iNumSlots$220820 = -32					; size = 4
_iNumOpenSlots$220821 = -28				; size = 4
_pkBuilding$220817 = -24				; size = 4
_eBuilding$220813 = -20					; size = 4
_pkCivInfo$220811 = -16					; size = 4
_eLoopBuildingClass$220809 = -12			; size = 4
_iI$220805 = -8						; size = 4
_iCount$ = -4						; size = 4
_eSlotType$ = 8						; size = 4
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z PROC ; CvCityBuildings::GetNumAvailableGreatWorkSlots, COMDAT
; _this$ = ecx

; 3453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 3454 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3455 : 
; 3456 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220805[ebp], 0
	jmp	SHORT $LN9@GetNumAvai@2
$LN8@GetNumAvai@2:
	mov	eax, DWORD PTR _iI$220805[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220805[ebp], eax
$LN9@GetNumAvai@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220805[ebp], eax
	jge	$LN7@GetNumAvai@2

; 3457 : #endif
; 3458 : 	{
; 3459 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220805[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220809[ebp], ecx

; 3460 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivInfo$220811[ebp], eax

; 3461 : 		if (pkCivInfo)

	cmp	DWORD PTR _pkCivInfo$220811[ebp], 0
	je	SHORT $LN6@GetNumAvai@2

; 3462 : 		{
; 3463 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220809[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCivInfo$220811[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220813[ebp], eax

; 3464 : 			if(NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220813[ebp], -1
	je	SHORT $LN6@GetNumAvai@2

; 3465 : 			{
; 3466 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220813[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN6@GetNumAvai@2

; 3467 : 				{
; 3468 : 					CvBuildingEntry *pkBuilding = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$220813[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuilding$220817[ebp], eax

; 3469 : 					if (pkBuilding)

	cmp	DWORD PTR _pkBuilding$220817[ebp], 0
	je	SHORT $LN6@GetNumAvai@2

; 3470 : 					{
; 3471 : 						if (pkBuilding->GetGreatWorkSlotType() == eSlotType)

	mov	ecx, DWORD PTR _pkBuilding$220817[ebp]
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	cmp	eax, DWORD PTR _eSlotType$[ebp]
	jne	SHORT $LN6@GetNumAvai@2

; 3472 : 						{
; 3473 : #ifdef AUI_WARNING_FIXES
; 3474 : 							uint iNumSlots = pkBuilding->GetGreatWorkCount();
; 3475 : 							uint iNumGreatWorksInBuilding = GetNumGreatWorksInBuilding(eLoopBuildingClass);
; 3476 : 							if (iNumSlots > iNumGreatWorksInBuilding)
; 3477 : 							{
; 3478 : 								iCount += iNumSlots - iNumGreatWorksInBuilding;
; 3479 : #else
; 3480 : 							int iNumSlots = pkBuilding->GetGreatWorkCount();

	mov	ecx, DWORD PTR _pkBuilding$220817[ebp]
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	DWORD PTR _iNumSlots$220820[ebp], eax

; 3481 : 							int iNumOpenSlots = iNumSlots - GetNumGreatWorksInBuilding(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220809[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumGreatWorksInBuilding@CvCityBuildings@@QBEHW4BuildingClassTypes@@@Z ; CvCityBuildings::GetNumGreatWorksInBuilding
	mov	ecx, DWORD PTR _iNumSlots$220820[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iNumOpenSlots$220821[ebp], ecx

; 3482 : 							if(iNumOpenSlots > 0)

	cmp	DWORD PTR _iNumOpenSlots$220821[ebp], 0
	jle	SHORT $LN6@GetNumAvai@2

; 3483 : 							{
; 3484 : 								iCount += iNumOpenSlots;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, DWORD PTR _iNumOpenSlots$220821[ebp]
	mov	DWORD PTR _iCount$[ebp], edx
$LN6@GetNumAvai@2:

; 3485 : #endif
; 3486 : 							}
; 3487 : 						}
; 3488 : 					}
; 3489 : 				}
; 3490 : 			}
; 3491 : 		}
; 3492 : 	}

	jmp	$LN8@GetNumAvai@2
$LN7@GetNumAvai@2:

; 3493 : 
; 3494 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3495 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumAvailableGreatWorkSlots@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ENDP ; CvCityBuildings::GetNumAvailableGreatWorkSlots
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_jJ$220840 = -20					; size = 4
_iNumSlots$220839 = -16					; size = 4
_eBuilding$220835 = -12					; size = 4
_eLoopBuildingClass$220833 = -8				; size = 4
_iI$220829 = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_iSlot$ = 12						; size = 4
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z PROC ; CvCityBuildings::GetNextAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3503 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3504 : 	if (eBuildingClass && iSlot)

	cmp	DWORD PTR _eBuildingClass$[ebp], 0
	je	$LN10@GetNextAva
	cmp	DWORD PTR _iSlot$[ebp], 0
	je	$LN10@GetNextAva

; 3505 : 	{
; 3506 : #ifdef AUI_WARNING_FIXES
; 3507 : 		CvBuildingEntry* pBuildingInfo;
; 3508 : 		CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3509 : 		if (!pCivInfo)
; 3510 : 			return false;
; 3511 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3512 : #else
; 3513 : 		for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220829[ebp], 0
	jmp	SHORT $LN9@GetNextAva
$LN8@GetNextAva:
	mov	eax, DWORD PTR _iI$220829[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220829[ebp], eax
$LN9@GetNextAva:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220829[ebp], eax
	jge	$LN10@GetNextAva

; 3514 : #endif
; 3515 : 		{
; 3516 : 			BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220829[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220833[ebp], ecx

; 3517 : #ifdef AUI_WARNING_FIXES
; 3518 : 			BuildingTypes eBuilding = (BuildingTypes)pCivInfo->getCivilizationBuildings(eLoopBuildingClass);
; 3519 : #else
; 3520 : 			BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(m_pCity->getCivilizationType())->getCivilizationBuildings(eLoopBuildingClass);

	mov	edx, DWORD PTR _eLoopBuildingClass$220833[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220835[ebp], eax

; 3521 : #endif
; 3522 : 			if(NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220835[ebp], -1
	je	SHORT $LN6@GetNextAva

; 3523 : 			{
; 3524 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220835[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN6@GetNextAva

; 3525 : 				{
; 3526 : #ifdef AUI_WARNING_FIXES
; 3527 : 					uint iNumSlots = 0;
; 3528 : 					pBuildingInfo = GC.getBuildingInfo(eBuilding);
; 3529 : 					if (pBuildingInfo)
; 3530 : 						iNumSlots = pBuildingInfo->GetGreatWorkCount();
; 3531 : 					for (uint jJ = 0; jJ < iNumSlots; jJ++)
; 3532 : #else
; 3533 : 					int iNumSlots = GC.getBuildingInfo(eBuilding)->GetGreatWorkCount();

	mov	edx, DWORD PTR _eBuilding$220835[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	DWORD PTR _iNumSlots$220839[ebp], eax

; 3534 : 					for (int jJ = 0; jJ < iNumSlots; jJ++)

	mov	DWORD PTR _jJ$220840[ebp], 0
	jmp	SHORT $LN4@GetNextAva
$LN3@GetNextAva:
	mov	eax, DWORD PTR _jJ$220840[ebp]
	add	eax, 1
	mov	DWORD PTR _jJ$220840[ebp], eax
$LN4@GetNextAva:
	mov	ecx, DWORD PTR _jJ$220840[ebp]
	cmp	ecx, DWORD PTR _iNumSlots$220839[ebp]
	jge	SHORT $LN6@GetNextAva

; 3535 : #endif
; 3536 : 					{
; 3537 : 						if (GetBuildingGreatWork (eLoopBuildingClass, jJ) == NO_GREAT_WORK)

	mov	edx, DWORD PTR _jJ$220840[ebp]
	push	edx
	mov	eax, DWORD PTR _eLoopBuildingClass$220833[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
	cmp	eax, -1
	jne	SHORT $LN1@GetNextAva

; 3538 : 						{
; 3539 : 							*eBuildingClass = eLoopBuildingClass;

	mov	ecx, DWORD PTR _eBuildingClass$[ebp]
	mov	edx, DWORD PTR _eLoopBuildingClass$220833[ebp]
	mov	DWORD PTR [ecx], edx

; 3540 : 							*iSlot = jJ;

	mov	eax, DWORD PTR _iSlot$[ebp]
	mov	ecx, DWORD PTR _jJ$220840[ebp]
	mov	DWORD PTR [eax], ecx

; 3541 : 							return true;

	mov	al, 1
	jmp	SHORT $LN11@GetNextAva
$LN1@GetNextAva:

; 3542 : 						}
; 3543 : 					}

	jmp	SHORT $LN3@GetNextAva
$LN6@GetNextAva:

; 3544 : 				}
; 3545 : 			}
; 3546 : 		}

	jmp	$LN8@GetNextAva
$LN10@GetNextAva:

; 3547 : 	}
; 3548 : 
; 3549 : 	return false;

	xor	al, al
$LN11@GetNextAva:

; 3550 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NPAW4BuildingClassTypes@@PAH@Z ENDP ; CvCityBuildings::GetNextAvailableGreatWorkSlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_jJ$220864 = -20					; size = 4
_iNumSlots$220863 = -16					; size = 4
_eBuilding$220858 = -12					; size = 4
_eLoopBuildingClass$220856 = -8				; size = 4
_iI$220852 = -4						; size = 4
_eGreatWorkSlot$ = 8					; size = 4
_eBuildingClass$ = 12					; size = 4
_iSlot$ = 16						; size = 4
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z PROC ; CvCityBuildings::GetNextAvailableGreatWorkSlot, COMDAT
; _this$ = ecx

; 3558 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3559 : 	if (eBuildingClass && iSlot)

	cmp	DWORD PTR _eBuildingClass$[ebp], 0
	je	$LN11@GetNextAva@2
	cmp	DWORD PTR _iSlot$[ebp], 0
	je	$LN11@GetNextAva@2

; 3560 : 	{
; 3561 : #ifdef AUI_WARNING_FIXES
; 3562 : 		CvBuildingEntry* pBuildingInfo;
; 3563 : 		CvCivilizationInfo* pCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());
; 3564 : 		if (!pCivInfo)
; 3565 : 			return false;
; 3566 : 		for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3567 : #else
; 3568 : 		for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220852[ebp], 0
	jmp	SHORT $LN10@GetNextAva@2
$LN9@GetNextAva@2:
	mov	eax, DWORD PTR _iI$220852[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220852[ebp], eax
$LN10@GetNextAva@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220852[ebp], eax
	jge	$LN11@GetNextAva@2

; 3569 : #endif
; 3570 : 		{
; 3571 : 			BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220852[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220856[ebp], ecx

; 3572 : #ifdef AUI_WARNING_FIXES
; 3573 : 			BuildingTypes eBuilding = (BuildingTypes)pCivInfo->getCivilizationBuildings(eLoopBuildingClass);
; 3574 : #else
; 3575 : 			BuildingTypes eBuilding = (BuildingTypes)GC.getCivilizationInfo(m_pCity->getCivilizationType())->getCivilizationBuildings(eLoopBuildingClass);

	mov	edx, DWORD PTR _eLoopBuildingClass$220856[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220858[ebp], eax

; 3576 : #endif
; 3577 : 			if(NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220858[ebp], -1
	je	$LN7@GetNextAva@2

; 3578 : 			{
; 3579 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220858[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN7@GetNextAva@2

; 3580 : 				{
; 3581 : #ifdef AUI_WARNING_FIXES
; 3582 : 					pBuildingInfo = GC.getBuildingInfo(eBuilding);
; 3583 : 					if (pBuildingInfo && pBuildingInfo->GetGreatWorkSlotType() == eGreatWorkSlot)
; 3584 : #else
; 3585 : 					if (GC.getBuildingInfo(eBuilding)->GetGreatWorkSlotType() == eGreatWorkSlot)

	mov	edx, DWORD PTR _eBuilding$220858[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	cmp	eax, DWORD PTR _eGreatWorkSlot$[ebp]
	jne	SHORT $LN7@GetNextAva@2

; 3586 : #endif
; 3587 : 					{
; 3588 : #ifdef AUI_WARNING_FIXES
; 3589 : 						uint iNumSlots = pBuildingInfo->GetGreatWorkCount();
; 3590 : 						for (uint jJ = 0; jJ < iNumSlots; jJ++)
; 3591 : #else
; 3592 : 						int iNumSlots = GC.getBuildingInfo(eBuilding)->GetGreatWorkCount();

	mov	eax, DWORD PTR _eBuilding$220858[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	ecx, eax
	call	?GetGreatWorkCount@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetGreatWorkCount
	mov	DWORD PTR _iNumSlots$220863[ebp], eax

; 3593 : 						for (int jJ = 0; jJ < iNumSlots; jJ++)

	mov	DWORD PTR _jJ$220864[ebp], 0
	jmp	SHORT $LN4@GetNextAva@2
$LN3@GetNextAva@2:
	mov	ecx, DWORD PTR _jJ$220864[ebp]
	add	ecx, 1
	mov	DWORD PTR _jJ$220864[ebp], ecx
$LN4@GetNextAva@2:
	mov	edx, DWORD PTR _jJ$220864[ebp]
	cmp	edx, DWORD PTR _iNumSlots$220863[ebp]
	jge	SHORT $LN7@GetNextAva@2

; 3594 : #endif
; 3595 : 						{
; 3596 : 							if (GetBuildingGreatWork (eLoopBuildingClass, jJ) == NO_GREAT_WORK)

	mov	eax, DWORD PTR _jJ$220864[ebp]
	push	eax
	mov	ecx, DWORD PTR _eLoopBuildingClass$220856[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildingGreatWork@CvCityBuildings@@QBEHW4BuildingClassTypes@@H@Z ; CvCityBuildings::GetBuildingGreatWork
	cmp	eax, -1
	jne	SHORT $LN1@GetNextAva@2

; 3597 : 							{
; 3598 : 								*eBuildingClass = eLoopBuildingClass;

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	mov	eax, DWORD PTR _eLoopBuildingClass$220856[ebp]
	mov	DWORD PTR [edx], eax

; 3599 : 								*iSlot = jJ;

	mov	ecx, DWORD PTR _iSlot$[ebp]
	mov	edx, DWORD PTR _jJ$220864[ebp]
	mov	DWORD PTR [ecx], edx

; 3600 : 								return true;

	mov	al, 1
	jmp	SHORT $LN12@GetNextAva@2
$LN1@GetNextAva@2:

; 3601 : 							}
; 3602 : 						}

	jmp	SHORT $LN3@GetNextAva@2
$LN7@GetNextAva@2:

; 3603 : 					}
; 3604 : 				}
; 3605 : 			}
; 3606 : 		}

	jmp	$LN9@GetNextAva@2
$LN11@GetNextAva@2:

; 3607 : 	}
; 3608 : 
; 3609 : 	return false;

	xor	al, al
$LN12@GetNextAva@2:

; 3610 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetNextAvailableGreatWorkSlot@CvCityBuildings@@QBE_NW4GreatWorkSlotType@@PAW4BuildingClassTypes@@PAH@Z ENDP ; CvCityBuildings::GetNextAvailableGreatWorkSlot
_TEXT	ENDS
PUBLIC	?GetThemingBonuses@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetThemingBonuses
PUBLIC	?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetCultureFromGreatWorks
EXTRN	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetGreatWorkYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T231532 = -20						; size = 4
$T231528 = -16						; size = 4
$T231524 = -12						; size = 4
_iRtnValue$ = -8					; size = 4
_iCulturePerWork$ = -4					; size = 4
?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetCultureFromGreatWorks, COMDAT
; _this$ = ecx

; 3614 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3615 : 	int iCulturePerWork = GC.getBASE_CULTURE_PER_GREAT_WORK();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8208
	mov	DWORD PTR _iCulturePerWork$[ebp], eax

; 3616 : 	iCulturePerWork += GET_PLAYER(m_pCity->getOwner()).GetGreatWorkYieldChange(YIELD_CULTURE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T231524[ebp], eax
	mov	ecx, DWORD PTR $T231524[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231528[ebp], ecx
	push	4
	mov	ecx, DWORD PTR $T231528[ebp]
	call	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetGreatWorkYieldChange
	add	eax, DWORD PTR _iCulturePerWork$[ebp]
	mov	DWORD PTR _iCulturePerWork$[ebp], eax

; 3617 : 
; 3618 : 	int iRtnValue = iCulturePerWork * m_aBuildingGreatWork.size();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T231532[ebp], edx
	mov	eax, DWORD PTR $T231532[ebp]
	mov	ecx, DWORD PTR $T231532[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, DWORD PTR _iCulturePerWork$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], eax

; 3619 : 	iRtnValue += GetThemingBonuses();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetThemingBonuses@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetThemingBonuses
	add	eax, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], eax

; 3620 : 
; 3621 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3622 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureFromGreatWorks@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetCultureFromGreatWorks
_TEXT	ENDS
PUBLIC	?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z ; CvCityBuildings::GetYieldFromGreatWorks
; Function compile flags: /Odtp
;	COMDAT ?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T231551 = -20						; size = 4
$T231547 = -16						; size = 4
$T231543 = -12						; size = 4
_iRtnValue$ = -8					; size = 4
_iYieldPerWork$ = -4					; size = 4
_eIndex$ = 8						; size = 4
?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z PROC ; CvCityBuildings::GetYieldFromGreatWorks, COMDAT
; _this$ = ecx

; 3627 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3628 : 	int iYieldPerWork = GET_PLAYER(m_pCity->getOwner()).GetGreatWorkYieldChange(eIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T231543[ebp], edx
	mov	eax, DWORD PTR $T231543[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231547[ebp], eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231547[ebp]
	call	?GetGreatWorkYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetGreatWorkYieldChange
	mov	DWORD PTR _iYieldPerWork$[ebp], eax

; 3629 : 	int iRtnValue = iYieldPerWork * m_aBuildingGreatWork.size();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T231551[ebp], edx
	mov	eax, DWORD PTR $T231551[ebp]
	mov	ecx, DWORD PTR $T231551[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, DWORD PTR _iYieldPerWork$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], eax

; 3630 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3631 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldFromGreatWorks@CvCityBuildings@@QBEHW4YieldTypes@@@Z ENDP ; CvCityBuildings::GetYieldFromGreatWorks
_TEXT	ENDS
PUBLIC	?GetNumGreatWorks@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetNumGreatWorks
; Function compile flags: /Odtp
;	COMDAT ?GetNumGreatWorks@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T231557 = -4						; size = 4
?GetNumGreatWorks@CvCityBuildings@@QBEHXZ PROC		; CvCityBuildings::GetNumGreatWorks, COMDAT
; _this$ = ecx

; 3639 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3640 : 	// Simple if want total of all types
; 3641 : 	return m_aBuildingGreatWork.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 92					; 0000005cH
	mov	DWORD PTR $T231557[ebp], eax
	mov	ecx, DWORD PTR $T231557[ebp]
	mov	edx, DWORD PTR $T231557[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 3642 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumGreatWorks@CvCityBuildings@@QBEHXZ ENDP		; CvCityBuildings::GetNumGreatWorks
_TEXT	ENDS
PUBLIC	?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ; CvCityBuildings::GetNumGreatWorks
; Function compile flags: /Odtp
;	COMDAT ?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T231577 = -40						; size = 4
$T231565 = -36						; size = 4
$T231560 = -32						; size = 4
_pkInfo$220905 = -28					; size = 4
_eBuilding$220903 = -24					; size = 4
_pkClassInfo$220901 = -20				; size = 4
_eBldgClass$220900 = -16				; size = 4
_it$220894 = -12					; size = 4
_iRtnValue$ = -8					; size = 4
_pkCivInfo$ = -4					; size = 4
_eGreatWorkSlot$ = 8					; size = 4
?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z PROC ; CvCityBuildings::GetNumGreatWorks, COMDAT
; _this$ = ecx

; 3651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 3652 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 3653 : #endif
; 3654 : 
; 3655 : 	CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivInfo$[ebp], eax

; 3656 : 	if (pkCivInfo)

	cmp	DWORD PTR _pkCivInfo$[ebp], 0
	je	$LN7@GetNumGrea@2

; 3657 : 	{
; 3658 : 		for(std::vector<BuildingGreatWork>::const_iterator it = m_aBuildingGreatWork.begin(); it != m_aBuildingGreatWork.end(); ++it)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T231565[ebp], edx
	mov	eax, DWORD PTR $T231565[ebp]
	mov	DWORD PTR _it$220894[ebp], eax
	jmp	SHORT $LN6@GetNumGrea@2
$LN5@GetNumGrea@2:
	mov	ecx, DWORD PTR _it$220894[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _it$220894[ebp], ecx
$LN6@GetNumGrea@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T231577[ebp], eax
	mov	ecx, DWORD PTR $T231577[ebp]
	mov	DWORD PTR $T231560[ebp], ecx
	mov	edx, DWORD PTR _it$220894[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T231560[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN7@GetNumGrea@2

; 3659 : 		{
; 3660 : 			BuildingClassTypes eBldgClass = (*it).eBuildingClass;

	mov	eax, DWORD PTR _it$220894[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _eBldgClass$220900[ebp], ecx

; 3661 : 			CvBuildingClassInfo *pkClassInfo = GC.getBuildingClassInfo(eBldgClass);

	mov	edx, DWORD PTR _eBldgClass$220900[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkClassInfo$220901[ebp], eax

; 3662 : 			if (pkClassInfo)

	cmp	DWORD PTR _pkClassInfo$220901[ebp], 0
	je	SHORT $LN3@GetNumGrea@2

; 3663 : 			{
; 3664 : 				BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eBldgClass);

	mov	eax, DWORD PTR _eBldgClass$220900[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCivInfo$[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220903[ebp], eax

; 3665 : 				CvBuildingEntry *pkInfo = GC.getBuildingInfo(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$220903[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkInfo$220905[ebp], eax

; 3666 : 				if (pkInfo)

	cmp	DWORD PTR _pkInfo$220905[ebp], 0
	je	SHORT $LN3@GetNumGrea@2

; 3667 : 				{
; 3668 : 					if (pkInfo->GetGreatWorkSlotType() == eGreatWorkSlot)

	mov	ecx, DWORD PTR _pkInfo$220905[ebp]
	call	?GetGreatWorkSlotType@CvBuildingEntry@@QBE?AW4GreatWorkSlotType@@XZ ; CvBuildingEntry::GetGreatWorkSlotType
	cmp	eax, DWORD PTR _eGreatWorkSlot$[ebp]
	jne	SHORT $LN3@GetNumGrea@2

; 3669 : 					{
; 3670 : 						iRtnValue++;

	mov	edx, DWORD PTR _iRtnValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _iRtnValue$[ebp], edx
$LN3@GetNumGrea@2:

; 3671 : 					}
; 3672 : 				}
; 3673 : 			}
; 3674 : 		}

	jmp	$LN5@GetNumGrea@2
$LN7@GetNumGrea@2:

; 3675 : 	}
; 3676 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3677 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumGreatWorks@CvCityBuildings@@QBEHW4GreatWorkSlotType@@@Z ENDP ; CvCityBuildings::GetNumGreatWorks
_TEXT	ENDS
PUBLIC	?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetLandmarksTourismPercent
; Function compile flags: /Odtp
;	COMDAT ?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetLandmarksTourismPercent, COMDAT
; _this$ = ecx

; 3681 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3682 : 	return m_iLandmarksTourismPercent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 3683 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandmarksTourismPercent@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetLandmarksTourismPercent
_TEXT	ENDS
PUBLIC	?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeLandmarksTourismPercent
; Function compile flags: /Odtp
;	COMDAT ?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeLandmarksTourismPercent, COMDAT
; _this$ = ecx

; 3687 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3688 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeLand

; 3689 : 	{
; 3690 : 		m_iLandmarksTourismPercent = (m_iLandmarksTourismPercent + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx
$LN2@ChangeLand:

; 3691 : 		CvAssert(m_iLandmarksTourismPercent >= 0);
; 3692 : 	}
; 3693 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeLandmarksTourismPercent@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeLandmarksTourismPercent
_TEXT	ENDS
PUBLIC	?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetGreatWorksTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetGreatWorksTourismModifier, COMDAT
; _this$ = ecx

; 3697 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3698 : 	return m_iGreatWorksTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 3699 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatWorksTourismModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetGreatWorksTourismModifier
_TEXT	ENDS
PUBLIC	?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeGreatWorksTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeGreatWorksTourismModifier, COMDAT
; _this$ = ecx

; 3703 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3704 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeGrea

; 3705 : 	{
; 3706 : 		m_iGreatWorksTourismModifier = (m_iGreatWorksTourismModifier + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN2@ChangeGrea:

; 3707 : 		CvAssert(m_iGreatWorksTourismModifier >= 0);
; 3708 : 	}
; 3709 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeGreatWorksTourismModifier@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeGreatWorksTourismModifier
_TEXT	ENDS
EXTRN	?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvCityCulture::GetThemingBonus
EXTRN	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ:PROC ; CvCity::GetCityCulture
; Function compile flags: /Odtp
;	COMDAT ?GetThemingBonuses@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_eBuilding$220936 = -20					; size = 4
_pkCivInfo$220934 = -16					; size = 4
_eLoopBuildingClass$220932 = -12			; size = 4
_iI$220928 = -8						; size = 4
_iBonus$ = -4						; size = 4
?GetThemingBonuses@CvCityBuildings@@QBEHXZ PROC		; CvCityBuildings::GetThemingBonuses, COMDAT
; _this$ = ecx

; 3713 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3714 : 	int iBonus = 0;

	mov	DWORD PTR _iBonus$[ebp], 0

; 3715 : 
; 3716 : #ifdef AUI_WARNING_FIXES
; 3717 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3718 : #else
; 3719 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220928[ebp], 0
	jmp	SHORT $LN6@GetTheming@2
$LN5@GetTheming@2:
	mov	eax, DWORD PTR _iI$220928[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220928[ebp], eax
$LN6@GetTheming@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220928[ebp], eax
	jge	SHORT $LN4@GetTheming@2

; 3720 : #endif
; 3721 : 	{
; 3722 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220928[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220932[ebp], ecx

; 3723 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivInfo$220934[ebp], eax

; 3724 : 		if (pkCivInfo)

	cmp	DWORD PTR _pkCivInfo$220934[ebp], 0
	je	SHORT $LN3@GetTheming@2

; 3725 : 		{
; 3726 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220932[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCivInfo$220934[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220936[ebp], eax

; 3727 : 			if(NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220936[ebp], -1
	je	SHORT $LN3@GetTheming@2

; 3728 : 			{
; 3729 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220936[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN3@GetTheming@2

; 3730 : 				{
; 3731 : 					iBonus += m_pCity->GetCityCulture()->GetThemingBonus(eLoopBuildingClass);

	mov	edx, DWORD PTR _eLoopBuildingClass$220932[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?GetCityCulture@CvCity@@QBEPAVCvCityCulture@@XZ ; CvCity::GetCityCulture
	mov	ecx, eax
	call	?GetThemingBonus@CvCityCulture@@QBEHW4BuildingClassTypes@@@Z ; CvCityCulture::GetThemingBonus
	add	eax, DWORD PTR _iBonus$[ebp]
	mov	DWORD PTR _iBonus$[ebp], eax
$LN3@GetTheming@2:

; 3732 : 				}
; 3733 : 			}
; 3734 : 		}
; 3735 : 	}

	jmp	SHORT $LN5@GetTheming@2
$LN4@GetTheming@2:

; 3736 : 
; 3737 : 	return iBonus;

	mov	eax, DWORD PTR _iBonus$[ebp]

; 3738 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetThemingBonuses@CvCityBuildings@@QBEHXZ ENDP		; CvCityBuildings::GetThemingBonuses
_TEXT	ENDS
PUBLIC	?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetNumBuildingsFromFaith
; Function compile flags: /Odtp
;	COMDAT ?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_pkEntry$220956 = -24					; size = 4
_eBuilding$220952 = -20					; size = 4
_pkCivInfo$220950 = -16					; size = 4
_eLoopBuildingClass$220948 = -12			; size = 4
_iI$220944 = -8						; size = 4
_iRtnValue$ = -4					; size = 4
?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetNumBuildingsFromFaith, COMDAT
; _this$ = ecx

; 3742 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 3743 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 3744 : 
; 3745 : #ifdef AUI_WARNING_FIXES
; 3746 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3747 : #else
; 3748 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220944[ebp], 0
	jmp	SHORT $LN8@GetNumBuil@2
$LN7@GetNumBuil@2:
	mov	eax, DWORD PTR _iI$220944[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220944[ebp], eax
$LN8@GetNumBuil@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220944[ebp], eax
	jge	$LN6@GetNumBuil@2

; 3749 : #endif
; 3750 : 	{
; 3751 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220944[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220948[ebp], ecx

; 3752 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivInfo$220950[ebp], eax

; 3753 : 		if (pkCivInfo)

	cmp	DWORD PTR _pkCivInfo$220950[ebp], 0
	je	SHORT $LN5@GetNumBuil@2

; 3754 : 		{
; 3755 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220948[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCivInfo$220950[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220952[ebp], eax

; 3756 : 			if (NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220952[ebp], -1
	je	SHORT $LN5@GetNumBuil@2

; 3757 : 			{
; 3758 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220952[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN5@GetNumBuil@2

; 3759 : 				{
; 3760 : 					CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$220952[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkEntry$220956[ebp], eax

; 3761 : 					if (pkEntry)

	cmp	DWORD PTR _pkEntry$220956[ebp], 0
	je	SHORT $LN5@GetNumBuil@2

; 3762 : 					{
; 3763 : 						if (pkEntry->GetFaithCost() > 0 && pkEntry->IsUnlockedByBelief() && pkEntry->GetProductionCost() == -1)

	mov	ecx, DWORD PTR _pkEntry$220956[ebp]
	call	?GetFaithCost@CvBuildingEntry@@QBEHXZ	; CvBuildingEntry::GetFaithCost
	test	eax, eax
	jle	SHORT $LN5@GetNumBuil@2
	mov	ecx, DWORD PTR _pkEntry$220956[ebp]
	call	?IsUnlockedByBelief@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsUnlockedByBelief
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@GetNumBuil@2
	mov	ecx, DWORD PTR _pkEntry$220956[ebp]
	call	?GetProductionCost@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetProductionCost
	cmp	eax, -1
	jne	SHORT $LN5@GetNumBuil@2

; 3764 : 						{
; 3765 : 							iRtnValue++;

	mov	ecx, DWORD PTR _iRtnValue$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRtnValue$[ebp], ecx
$LN5@GetNumBuil@2:

; 3766 : 						}
; 3767 : 					}
; 3768 : 				}
; 3769 : 			}
; 3770 : 		}
; 3771 : 	}

	jmp	$LN7@GetNumBuil@2
$LN6@GetNumBuil@2:

; 3772 : 
; 3773 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3774 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumBuildingsFromFaith@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetNumBuildingsFromFaith
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetCityStateTradeRouteProductionModifier
EXTRN	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ:PROC ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T231619 = -40						; size = 4
$T231615 = -36						; size = 4
_iProductionModifier$220977 = -32			; size = 4
_iCityStates$220978 = -28				; size = 4
_pkEntry$220975 = -24					; size = 4
_eBuilding$220971 = -20					; size = 4
_pkCivInfo$220969 = -16					; size = 4
_eLoopBuildingClass$220967 = -12			; size = 4
_iI$220963 = -8						; size = 4
_iRtnValue$ = -4					; size = 4
?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetCityStateTradeRouteProductionModifier, COMDAT
; _this$ = ecx

; 3778 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 3779 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 3780 : 
; 3781 : #ifdef AUI_WARNING_FIXES
; 3782 : 	for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 3783 : #else
; 3784 : 	for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220963[ebp], 0
	jmp	SHORT $LN8@GetCitySta
$LN7@GetCitySta:
	mov	eax, DWORD PTR _iI$220963[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220963[ebp], eax
$LN8@GetCitySta:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220963[ebp], eax
	jge	$LN6@GetCitySta

; 3785 : #endif
; 3786 : 	{
; 3787 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220963[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220967[ebp], ecx

; 3788 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivInfo$220969[ebp], eax

; 3789 : 		if (pkCivInfo)

	cmp	DWORD PTR _pkCivInfo$220969[ebp], 0
	je	$LN5@GetCitySta

; 3790 : 		{
; 3791 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220967[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCivInfo$220969[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220971[ebp], eax

; 3792 : 			if (NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220971[ebp], -1
	je	SHORT $LN5@GetCitySta

; 3793 : 			{
; 3794 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220971[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN5@GetCitySta

; 3795 : 				{
; 3796 : 					CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$220971[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkEntry$220975[ebp], eax

; 3797 : 					if (pkEntry)

	cmp	DWORD PTR _pkEntry$220975[ebp], 0
	je	SHORT $LN5@GetCitySta

; 3798 : 					{
; 3799 : 						int iProductionModifier = pkEntry->GetCityStateTradeRouteProductionModifier();

	mov	ecx, DWORD PTR _pkEntry$220975[ebp]
	call	?GetCityStateTradeRouteProductionModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityStateTradeRouteProductionModifier
	mov	DWORD PTR _iProductionModifier$220977[ebp], eax

; 3800 : 						int iCityStates = GET_PLAYER(m_pCity->getOwner()).GetTrade()->GetNumberOfCityStateTradeRoutes();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T231615[ebp], edx
	mov	eax, DWORD PTR $T231615[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231619[ebp], eax
	mov	ecx, DWORD PTR $T231619[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
	mov	DWORD PTR _iCityStates$220978[ebp], eax

; 3801 : 						if (iProductionModifier > 0  && iCityStates > 0)

	cmp	DWORD PTR _iProductionModifier$220977[ebp], 0
	jle	SHORT $LN5@GetCitySta
	cmp	DWORD PTR _iCityStates$220978[ebp], 0
	jle	SHORT $LN5@GetCitySta

; 3802 : 						{
; 3803 : 							iRtnValue = iProductionModifier * iCityStates;

	mov	ecx, DWORD PTR _iProductionModifier$220977[ebp]
	imul	ecx, DWORD PTR _iCityStates$220978[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], ecx
$LN5@GetCitySta:

; 3804 : 						}
; 3805 : 					}
; 3806 : 				}
; 3807 : 			}
; 3808 : 		}
; 3809 : 	}

	jmp	$LN7@GetCitySta
$LN6@GetCitySta:

; 3810 : 
; 3811 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3812 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateTradeRouteProductionModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetCityStateTradeRouteProductionModifier
_TEXT	ENDS
PUBLIC	?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetCityStateTradeRouteGoldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T231634 = -40						; size = 4
$T231630 = -36						; size = 4
_iGoldModifier$220998 = -32				; size = 4
_iCityStates$220999 = -28				; size = 4
_pkEntry$220996 = -24					; size = 4
_eBuilding$220992 = -20					; size = 4
_pkCivInfo$220990 = -16					; size = 4
_eLoopBuildingClass$220988 = -12			; size = 4
_iI$220984 = -8						; size = 4
_iRtnValue$ = -4					; size = 4
?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetCityStateTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 3817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 3818 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 3819 : 
; 3820 : 	for(uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$220984[ebp], 0
	jmp	SHORT $LN8@GetCitySta@2
$LN7@GetCitySta@2:
	mov	eax, DWORD PTR _iI$220984[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$220984[ebp], eax
$LN8@GetCitySta@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$220984[ebp], eax
	jae	$LN6@GetCitySta@2

; 3821 : 	{
; 3822 : 		BuildingClassTypes eLoopBuildingClass = (BuildingClassTypes) iI;

	mov	ecx, DWORD PTR _iI$220984[ebp]
	mov	DWORD PTR _eLoopBuildingClass$220988[ebp], ecx

; 3823 : 		CvCivilizationInfo *pkCivInfo = GC.getCivilizationInfo(m_pCity->getCivilizationType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+112]
	call	?getCivilizationType@CvCity@@QBE?AW4CivilizationTypes@@XZ ; CvCity::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkCivInfo$220990[ebp], eax

; 3824 : 		if (pkCivInfo)

	cmp	DWORD PTR _pkCivInfo$220990[ebp], 0
	je	$LN5@GetCitySta@2

; 3825 : 		{
; 3826 : 			BuildingTypes eBuilding = (BuildingTypes)pkCivInfo->getCivilizationBuildings(eLoopBuildingClass);

	mov	eax, DWORD PTR _eLoopBuildingClass$220988[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkCivInfo$220990[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$220992[ebp], eax

; 3827 : 			if (NO_BUILDING != eBuilding)

	cmp	DWORD PTR _eBuilding$220992[ebp], -1
	je	SHORT $LN5@GetCitySta@2

; 3828 : 			{
; 3829 : 				if (GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$220992[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN5@GetCitySta@2

; 3830 : 				{
; 3831 : 					CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	mov	edx, DWORD PTR _eBuilding$220992[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkEntry$220996[ebp], eax

; 3832 : 					if (pkEntry)

	cmp	DWORD PTR _pkEntry$220996[ebp], 0
	je	SHORT $LN5@GetCitySta@2

; 3833 : 					{
; 3834 : 						int iGoldModifier = pkEntry->GetCityStateTradeRouteGoldModifier();

	mov	ecx, DWORD PTR _pkEntry$220996[ebp]
	call	?GetCityStateTradeRouteGoldModifier@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetCityStateTradeRouteGoldModifier
	mov	DWORD PTR _iGoldModifier$220998[ebp], eax

; 3835 : 						int iCityStates = GET_PLAYER(m_pCity->getOwner()).GetTrade()->GetNumberOfCityStateTradeRoutes();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T231630[ebp], edx
	mov	eax, DWORD PTR $T231630[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231634[ebp], eax
	mov	ecx, DWORD PTR $T231634[ebp]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumberOfCityStateTradeRoutes@CvPlayerTrade@@QAEHXZ ; CvPlayerTrade::GetNumberOfCityStateTradeRoutes
	mov	DWORD PTR _iCityStates$220999[ebp], eax

; 3836 : 						if (iGoldModifier > 0  && iCityStates > 0)

	cmp	DWORD PTR _iGoldModifier$220998[ebp], 0
	jle	SHORT $LN5@GetCitySta@2
	cmp	DWORD PTR _iCityStates$220999[ebp], 0
	jle	SHORT $LN5@GetCitySta@2

; 3837 : 						{
; 3838 : 							iRtnValue = iGoldModifier * iCityStates;

	mov	ecx, DWORD PTR _iGoldModifier$220998[ebp]
	imul	ecx, DWORD PTR _iCityStates$220999[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], ecx
$LN5@GetCitySta@2:

; 3839 : 						}
; 3840 : 					}
; 3841 : 				}
; 3842 : 			}
; 3843 : 		}
; 3844 : 	}

	jmp	$LN7@GetCitySta@2
$LN6@GetCitySta@2:

; 3845 : 
; 3846 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3847 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateTradeRouteGoldModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetCityStateTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetBuildingProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetBuildingProductionModifier, COMDAT
; _this$ = ecx

; 3853 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3854 : 	return m_iBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 3855 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingProductionModifier@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeBuildingProductionModifier, COMDAT
; _this$ = ecx

; 3859 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3860 : 	m_iBuildingProductionModifier = (m_iBuildingProductionModifier + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 3861 : 	CvAssert(GetBuildingProductionModifier() >= 0);
; 3862 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeBuildingProductionModifier@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingDefense@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetBuildingDefense
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingDefense@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingDefense@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetBuildingDefense, COMDAT
; _this$ = ecx

; 3866 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3867 : 	return m_iBuildingDefense;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 3868 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingDefense@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetBuildingDefense
_TEXT	ENDS
PUBLIC	?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z	; CvCityBuildings::ChangeBuildingDefense
EXTRN	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::plotAction
EXTRN	?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z:PROC	; PUF_makeInfoBarDirty
; Function compile flags: /Odtp
;	COMDAT ?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z PROC	; CvCityBuildings::ChangeBuildingDefense, COMDAT
; _this$ = ecx

; 3872 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3873 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeBuil

; 3874 : 	{
; 3875 : 		m_iBuildingDefense = (m_iBuildingDefense + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 3876 : 		CvAssert(GetBuildingDefense() >= 0);
; 3877 : 
; 3878 : 		m_pCity->plot()->plotAction(PUF_makeInfoBarDirty);

	push	-1
	push	-1
	push	-1
	push	-1
	push	OFFSET ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ; PUF_makeInfoBarDirty
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
$LN2@ChangeBuil:

; 3879 : 	}
; 3880 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeBuildingDefense@CvCityBuildings@@QAEXH@Z ENDP	; CvCityBuildings::ChangeBuildingDefense
_TEXT	ENDS
PUBLIC	?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetBuildingDefensePerCitizen
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ PROC ; CvCityBuildings::GetBuildingDefensePerCitizen, COMDAT
; _this$ = ecx

; 3885 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3886 : 	return m_iBuildingDefensePerCitizen;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 3887 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingDefensePerCitizen@CvCityBuildings@@QBEHXZ ENDP ; CvCityBuildings::GetBuildingDefensePerCitizen
_TEXT	ENDS
PUBLIC	?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingDefensePerCitizen
; Function compile flags: /Odtp
;	COMDAT ?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeBuildingDefensePerCitizen, COMDAT
; _this$ = ecx

; 3891 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3892 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeBuil@2

; 3893 : 	{
; 3894 : 		m_iBuildingDefensePerCitizen = (m_iBuildingDefensePerCitizen + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 3895 : 		CvAssert(GetBuildingDefensePerCitizen() >= 0);
; 3896 : 
; 3897 : 		m_pCity->plot()->plotAction(PUF_makeInfoBarDirty);

	push	-1
	push	-1
	push	-1
	push	-1
	push	OFFSET ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ; PUF_makeInfoBarDirty
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
$LN2@ChangeBuil@2:

; 3898 : 	}
; 3899 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeBuildingDefensePerCitizen@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeBuildingDefensePerCitizen
_TEXT	ENDS
PUBLIC	?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ	; CvCityBuildings::GetBuildingDefenseMod
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetBuildingDefenseMod, COMDAT
; _this$ = ecx

; 3905 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3906 : 	return m_iBuildingDefenseMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 3907 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingDefenseMod@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetBuildingDefenseMod
_TEXT	ENDS
PUBLIC	?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeBuildingDefenseMod
; Function compile flags: /Odtp
;	COMDAT ?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z PROC	; CvCityBuildings::ChangeBuildingDefenseMod, COMDAT
; _this$ = ecx

; 3911 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3912 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeBuil@3

; 3913 : 	{
; 3914 : 		m_iBuildingDefenseMod = (m_iBuildingDefenseMod + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 3915 : 		CvAssert(m_iBuildingDefenseMod >= 0);
; 3916 : 
; 3917 : 		m_pCity->plot()->plotAction(PUF_makeInfoBarDirty);

	push	-1
	push	-1
	push	-1
	push	-1
	push	OFFSET ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ; PUF_makeInfoBarDirty
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, eax
	call	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
$LN2@ChangeBuil@3:

; 3918 : 	}
; 3919 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeBuildingDefenseMod@CvCityBuildings@@QAEXH@Z ENDP	; CvCityBuildings::ChangeBuildingDefenseMod
_TEXT	ENDS
PUBLIC	?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ ; CvCityBuildings::GetMissionaryExtraSpreads
; Function compile flags: /Odtp
;	COMDAT ?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ PROC	; CvCityBuildings::GetMissionaryExtraSpreads, COMDAT
; _this$ = ecx

; 3923 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3924 : 	return m_iMissionaryExtraSpreads;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 3925 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMissionaryExtraSpreads@CvCityBuildings@@QBEHXZ ENDP	; CvCityBuildings::GetMissionaryExtraSpreads
_TEXT	ENDS
PUBLIC	?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z ; CvCityBuildings::ChangeMissionaryExtraSpreads
; Function compile flags: /Odtp
;	COMDAT ?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z PROC ; CvCityBuildings::ChangeMissionaryExtraSpreads, COMDAT
; _this$ = ecx

; 3929 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3930 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@ChangeMiss

; 3931 : 	{
; 3932 : 		m_iMissionaryExtraSpreads = (m_iMissionaryExtraSpreads + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx
$LN2@ChangeMiss:

; 3933 : 		CvAssert(m_iMissionaryExtraSpreads >= 0);
; 3934 : 	}
; 3935 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeMissionaryExtraSpreads@CvCityBuildings@@QAEXH@Z ENDP ; CvCityBuildings::ChangeMissionaryExtraSpreads
_TEXT	ENDS
PUBLIC	?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForSevenAncientWondersBuilt
PUBLIC	?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForAllWondersBuilt
PUBLIC	??_C@_0CG@JCJLNGJK@BUILDINGCLASS_MAUSOLEUM_HALICARN@ ; `string'
PUBLIC	??_C@_0BN@PPEHPGEB@BUILDINGCLASS_TEMPLE_ARTEMIS?$AA@ ; `string'
PUBLIC	??_C@_0BK@EDJCDHEK@BUILDINGCLASS_STATUE_ZEUS?$AA@ ; `string'
PUBLIC	??_C@_0CB@KLDNKEBJ@BUILDINGCLASS_SYDNEY_OPERA_HOUSE@ ; `string'
PUBLIC	??_C@_0BN@LLBELFOG@BUILDINGCLASS_UNITED_NATIONS?$AA@ ; `string'
PUBLIC	??_C@_0BH@BICAGOLB@BUILDINGCLASS_PENTAGON?$AA@	; `string'
PUBLIC	??_C@_0BL@ODGFODOO@BUILDINGCLASS_EIFFEL_TOWER?$AA@ ; `string'
PUBLIC	??_C@_0BO@HFMLAKAF@BUILDINGCLASS_CRISTO_REDENTOR?$AA@ ; `string'
PUBLIC	??_C@_0CA@LOKMMGBF@BUILDINGCLASS_STATUE_OF_LIBERTY?$AA@ ; `string'
PUBLIC	??_C@_0BP@PIIDEHHH@BUILDINGCLASS_BRANDENBURG_GATE?$AA@ ; `string'
PUBLIC	??_C@_0BF@INPGMHCL@BUILDINGCLASS_LOUVRE?$AA@	; `string'
PUBLIC	??_C@_0BG@KHIGNMHK@BUILDINGCLASS_BIG_BEN?$AA@	; `string'
PUBLIC	??_C@_0BI@FMPBECFE@BUILDINGCLASS_TAJ_MAHAL?$AA@	; `string'
PUBLIC	??_C@_0BP@IHHKJLLK@BUILDINGCLASS_FORBIDDEN_PALACE?$AA@ ; `string'
PUBLIC	??_C@_0BG@GDDNOENL@BUILDINGCLASS_KREMLIN?$AA@	; `string'
PUBLIC	??_C@_0BN@PMDCMOMC@BUILDINGCLASS_SISTINE_CHAPEL?$AA@ ; `string'
PUBLIC	??_C@_0BM@LNKHGGDK@BUILDINGCLASS_HIMEJI_CASTLE?$AA@ ; `string'
PUBLIC	??_C@_0BO@FEBDGAMA@BUILDINGCLASS_PORCELAIN_TOWER?$AA@ ; `string'
PUBLIC	??_C@_0BJ@ICMCFFJL@BUILDINGCLASS_NOTRE_DAME?$AA@ ; `string'
PUBLIC	??_C@_0BK@EFGMFEAH@BUILDINGCLASS_MACHU_PICHU?$AA@ ; `string'
PUBLIC	??_C@_0BL@DPKCLIK@BUILDINGCLASS_CHICHEN_ITZA?$AA@ ; `string'
PUBLIC	??_C@_0BL@BBJGHBKH@BUILDINGCLASS_HAGIA_SOPHIA?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CICOKGOD@BUILDINGCLASS_ANGKOR_WAT?$AA@ ; `string'
PUBLIC	??_C@_0BJ@FELJKKOK@BUILDINGCLASS_GREAT_WALL?$AA@ ; `string'
PUBLIC	??_C@_0BN@OKOLACKI@BUILDINGCLASS_HANGING_GARDEN?$AA@ ; `string'
PUBLIC	??_C@_0BF@OHEJNEGG@BUILDINGCLASS_ORACLE?$AA@	; `string'
PUBLIC	??_C@_0BH@MJKFKBCM@BUILDINGCLASS_COLOSSUS?$AA@	; `string'
PUBLIC	??_C@_0BG@NJJLMNJB@BUILDINGCLASS_PYRAMID?$AA@	; `string'
PUBLIC	??_C@_0BM@JCCNACHL@BUILDINGCLASS_GREAT_LIBRARY?$AA@ ; `string'
PUBLIC	??_C@_0BJ@ELCINAJD@BUILDINGCLASS_STONEHENGE?$AA@ ; `string'
PUBLIC	??_C@_0BP@OPINPFPH@BUILDINGCLASS_GREAT_LIGHTHOUSE?$AA@ ; `string'
PUBLIC	??_C@_0BI@PIEGAHNC@BUILDINGCLASS_HERMITAGE?$AA@	; `string'
PUBLIC	??_C@_0CA@HDLCJCH@BUILDINGCLASS_OXFORD_UNIVERSITY?$AA@ ; `string'
PUBLIC	??_C@_0BI@HALBAMIJ@BUILDINGCLASS_IRONWORKS?$AA@	; `string'
PUBLIC	??_C@_0BM@JAHDLNMF@BUILDINGCLASS_NATIONAL_EPIC?$AA@ ; `string'
PUBLIC	??_C@_0BP@NOHGMPIA@BUILDINGCLASS_NATIONAL_COLLEGE?$AA@ ; `string'
PUBLIC	??_C@_0BK@CBCBHNBB@BUILDINGCLASS_HEROIC_EPIC?$AA@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CG@JCJLNGJK@BUILDINGCLASS_MAUSOLEUM_HALICARN@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CG@JCJLNGJK@BUILDINGCLASS_MAUSOLEUM_HALICARN@ DB 'BUILDINGCLASS_MA'
	DB	'USOLEUM_HALICARNASSUS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PPEHPGEB@BUILDINGCLASS_TEMPLE_ARTEMIS?$AA@
CONST	SEGMENT
??_C@_0BN@PPEHPGEB@BUILDINGCLASS_TEMPLE_ARTEMIS?$AA@ DB 'BUILDINGCLASS_TE'
	DB	'MPLE_ARTEMIS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EDJCDHEK@BUILDINGCLASS_STATUE_ZEUS?$AA@
CONST	SEGMENT
??_C@_0BK@EDJCDHEK@BUILDINGCLASS_STATUE_ZEUS?$AA@ DB 'BUILDINGCLASS_STATU'
	DB	'E_ZEUS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KLDNKEBJ@BUILDINGCLASS_SYDNEY_OPERA_HOUSE@
CONST	SEGMENT
??_C@_0CB@KLDNKEBJ@BUILDINGCLASS_SYDNEY_OPERA_HOUSE@ DB 'BUILDINGCLASS_SY'
	DB	'DNEY_OPERA_HOUSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LLBELFOG@BUILDINGCLASS_UNITED_NATIONS?$AA@
CONST	SEGMENT
??_C@_0BN@LLBELFOG@BUILDINGCLASS_UNITED_NATIONS?$AA@ DB 'BUILDINGCLASS_UN'
	DB	'ITED_NATIONS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BICAGOLB@BUILDINGCLASS_PENTAGON?$AA@
CONST	SEGMENT
??_C@_0BH@BICAGOLB@BUILDINGCLASS_PENTAGON?$AA@ DB 'BUILDINGCLASS_PENTAGON'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ODGFODOO@BUILDINGCLASS_EIFFEL_TOWER?$AA@
CONST	SEGMENT
??_C@_0BL@ODGFODOO@BUILDINGCLASS_EIFFEL_TOWER?$AA@ DB 'BUILDINGCLASS_EIFF'
	DB	'EL_TOWER', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HFMLAKAF@BUILDINGCLASS_CRISTO_REDENTOR?$AA@
CONST	SEGMENT
??_C@_0BO@HFMLAKAF@BUILDINGCLASS_CRISTO_REDENTOR?$AA@ DB 'BUILDINGCLASS_C'
	DB	'RISTO_REDENTOR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LOKMMGBF@BUILDINGCLASS_STATUE_OF_LIBERTY?$AA@
CONST	SEGMENT
??_C@_0CA@LOKMMGBF@BUILDINGCLASS_STATUE_OF_LIBERTY?$AA@ DB 'BUILDINGCLASS'
	DB	'_STATUE_OF_LIBERTY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PIIDEHHH@BUILDINGCLASS_BRANDENBURG_GATE?$AA@
CONST	SEGMENT
??_C@_0BP@PIIDEHHH@BUILDINGCLASS_BRANDENBURG_GATE?$AA@ DB 'BUILDINGCLASS_'
	DB	'BRANDENBURG_GATE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@INPGMHCL@BUILDINGCLASS_LOUVRE?$AA@
CONST	SEGMENT
??_C@_0BF@INPGMHCL@BUILDINGCLASS_LOUVRE?$AA@ DB 'BUILDINGCLASS_LOUVRE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KHIGNMHK@BUILDINGCLASS_BIG_BEN?$AA@
CONST	SEGMENT
??_C@_0BG@KHIGNMHK@BUILDINGCLASS_BIG_BEN?$AA@ DB 'BUILDINGCLASS_BIG_BEN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FMPBECFE@BUILDINGCLASS_TAJ_MAHAL?$AA@
CONST	SEGMENT
??_C@_0BI@FMPBECFE@BUILDINGCLASS_TAJ_MAHAL?$AA@ DB 'BUILDINGCLASS_TAJ_MAH'
	DB	'AL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IHHKJLLK@BUILDINGCLASS_FORBIDDEN_PALACE?$AA@
CONST	SEGMENT
??_C@_0BP@IHHKJLLK@BUILDINGCLASS_FORBIDDEN_PALACE?$AA@ DB 'BUILDINGCLASS_'
	DB	'FORBIDDEN_PALACE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GDDNOENL@BUILDINGCLASS_KREMLIN?$AA@
CONST	SEGMENT
??_C@_0BG@GDDNOENL@BUILDINGCLASS_KREMLIN?$AA@ DB 'BUILDINGCLASS_KREMLIN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PMDCMOMC@BUILDINGCLASS_SISTINE_CHAPEL?$AA@
CONST	SEGMENT
??_C@_0BN@PMDCMOMC@BUILDINGCLASS_SISTINE_CHAPEL?$AA@ DB 'BUILDINGCLASS_SI'
	DB	'STINE_CHAPEL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LNKHGGDK@BUILDINGCLASS_HIMEJI_CASTLE?$AA@
CONST	SEGMENT
??_C@_0BM@LNKHGGDK@BUILDINGCLASS_HIMEJI_CASTLE?$AA@ DB 'BUILDINGCLASS_HIM'
	DB	'EJI_CASTLE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FEBDGAMA@BUILDINGCLASS_PORCELAIN_TOWER?$AA@
CONST	SEGMENT
??_C@_0BO@FEBDGAMA@BUILDINGCLASS_PORCELAIN_TOWER?$AA@ DB 'BUILDINGCLASS_P'
	DB	'ORCELAIN_TOWER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ICMCFFJL@BUILDINGCLASS_NOTRE_DAME?$AA@
CONST	SEGMENT
??_C@_0BJ@ICMCFFJL@BUILDINGCLASS_NOTRE_DAME?$AA@ DB 'BUILDINGCLASS_NOTRE_'
	DB	'DAME', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EFGMFEAH@BUILDINGCLASS_MACHU_PICHU?$AA@
CONST	SEGMENT
??_C@_0BK@EFGMFEAH@BUILDINGCLASS_MACHU_PICHU?$AA@ DB 'BUILDINGCLASS_MACHU'
	DB	'_PICHU', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DPKCLIK@BUILDINGCLASS_CHICHEN_ITZA?$AA@
CONST	SEGMENT
??_C@_0BL@DPKCLIK@BUILDINGCLASS_CHICHEN_ITZA?$AA@ DB 'BUILDINGCLASS_CHICH'
	DB	'EN_ITZA', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BBJGHBKH@BUILDINGCLASS_HAGIA_SOPHIA?$AA@
CONST	SEGMENT
??_C@_0BL@BBJGHBKH@BUILDINGCLASS_HAGIA_SOPHIA?$AA@ DB 'BUILDINGCLASS_HAGI'
	DB	'A_SOPHIA', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CICOKGOD@BUILDINGCLASS_ANGKOR_WAT?$AA@
CONST	SEGMENT
??_C@_0BJ@CICOKGOD@BUILDINGCLASS_ANGKOR_WAT?$AA@ DB 'BUILDINGCLASS_ANGKOR'
	DB	'_WAT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FELJKKOK@BUILDINGCLASS_GREAT_WALL?$AA@
CONST	SEGMENT
??_C@_0BJ@FELJKKOK@BUILDINGCLASS_GREAT_WALL?$AA@ DB 'BUILDINGCLASS_GREAT_'
	DB	'WALL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OKOLACKI@BUILDINGCLASS_HANGING_GARDEN?$AA@
CONST	SEGMENT
??_C@_0BN@OKOLACKI@BUILDINGCLASS_HANGING_GARDEN?$AA@ DB 'BUILDINGCLASS_HA'
	DB	'NGING_GARDEN', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OHEJNEGG@BUILDINGCLASS_ORACLE?$AA@
CONST	SEGMENT
??_C@_0BF@OHEJNEGG@BUILDINGCLASS_ORACLE?$AA@ DB 'BUILDINGCLASS_ORACLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MJKFKBCM@BUILDINGCLASS_COLOSSUS?$AA@
CONST	SEGMENT
??_C@_0BH@MJKFKBCM@BUILDINGCLASS_COLOSSUS?$AA@ DB 'BUILDINGCLASS_COLOSSUS'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NJJLMNJB@BUILDINGCLASS_PYRAMID?$AA@
CONST	SEGMENT
??_C@_0BG@NJJLMNJB@BUILDINGCLASS_PYRAMID?$AA@ DB 'BUILDINGCLASS_PYRAMID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JCCNACHL@BUILDINGCLASS_GREAT_LIBRARY?$AA@
CONST	SEGMENT
??_C@_0BM@JCCNACHL@BUILDINGCLASS_GREAT_LIBRARY?$AA@ DB 'BUILDINGCLASS_GRE'
	DB	'AT_LIBRARY', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ELCINAJD@BUILDINGCLASS_STONEHENGE?$AA@
CONST	SEGMENT
??_C@_0BJ@ELCINAJD@BUILDINGCLASS_STONEHENGE?$AA@ DB 'BUILDINGCLASS_STONEH'
	DB	'ENGE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OPINPFPH@BUILDINGCLASS_GREAT_LIGHTHOUSE?$AA@
CONST	SEGMENT
??_C@_0BP@OPINPFPH@BUILDINGCLASS_GREAT_LIGHTHOUSE?$AA@ DB 'BUILDINGCLASS_'
	DB	'GREAT_LIGHTHOUSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PIEGAHNC@BUILDINGCLASS_HERMITAGE?$AA@
CONST	SEGMENT
??_C@_0BI@PIEGAHNC@BUILDINGCLASS_HERMITAGE?$AA@ DB 'BUILDINGCLASS_HERMITA'
	DB	'GE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HDLCJCH@BUILDINGCLASS_OXFORD_UNIVERSITY?$AA@
CONST	SEGMENT
??_C@_0CA@HDLCJCH@BUILDINGCLASS_OXFORD_UNIVERSITY?$AA@ DB 'BUILDINGCLASS_'
	DB	'OXFORD_UNIVERSITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HALBAMIJ@BUILDINGCLASS_IRONWORKS?$AA@
CONST	SEGMENT
??_C@_0BI@HALBAMIJ@BUILDINGCLASS_IRONWORKS?$AA@ DB 'BUILDINGCLASS_IRONWOR'
	DB	'KS', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JAHDLNMF@BUILDINGCLASS_NATIONAL_EPIC?$AA@
CONST	SEGMENT
??_C@_0BM@JAHDLNMF@BUILDINGCLASS_NATIONAL_EPIC?$AA@ DB 'BUILDINGCLASS_NAT'
	DB	'IONAL_EPIC', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NOHGMPIA@BUILDINGCLASS_NATIONAL_COLLEGE?$AA@
CONST	SEGMENT
??_C@_0BP@NOHGMPIA@BUILDINGCLASS_NATIONAL_COLLEGE?$AA@ DB 'BUILDINGCLASS_'
	DB	'NATIONAL_COLLEGE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CBCBHNBB@BUILDINGCLASS_HEROIC_EPIC?$AA@
CONST	SEGMENT
??_C@_0BK@CBCBHNBB@BUILDINGCLASS_HEROIC_EPIC?$AA@ DB 'BUILDINGCLASS_HEROI'
	DB	'C_EPIC', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z$0
__ehfuncinfo$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
tv908 = -376						; size = 4
tv893 = -372						; size = 4
tv878 = -368						; size = 4
tv858 = -364						; size = 4
tv838 = -360						; size = 4
tv818 = -356						; size = 4
tv798 = -352						; size = 4
tv778 = -348						; size = 4
tv726 = -344						; size = 4
tv706 = -340						; size = 4
tv686 = -336						; size = 4
tv666 = -332						; size = 4
tv646 = -328						; size = 4
tv626 = -324						; size = 4
tv606 = -320						; size = 4
tv586 = -316						; size = 4
tv566 = -312						; size = 4
tv546 = -308						; size = 4
tv526 = -304						; size = 4
tv506 = -300						; size = 4
tv486 = -296						; size = 4
tv466 = -292						; size = 4
tv446 = -288						; size = 4
tv426 = -284						; size = 4
tv406 = -280						; size = 4
tv386 = -276						; size = 4
tv366 = -272						; size = 4
tv346 = -268						; size = 4
tv326 = -264						; size = 4
tv306 = -260						; size = 4
tv286 = -256						; size = 4
tv266 = -252						; size = 4
tv246 = -248						; size = 4
tv226 = -244						; size = 4
tv206 = -240						; size = 4
tv186 = -236						; size = 4
tv166 = -232						; size = 4
tv146 = -228						; size = 4
tv94 = -224						; size = 4
tv926 = -220						; size = 4
_this$ = -216						; size = 4
$T231825 = -212						; size = 4
$T231821 = -208						; size = 4
$T231817 = -204						; size = 4
$T231813 = -200						; size = 4
$T231809 = -196						; size = 4
$T231805 = -192						; size = 4
$T231801 = -188						; size = 4
$T231797 = -184						; size = 4
$T231793 = -180						; size = 4
$T231789 = -176						; size = 4
$T231785 = -172						; size = 4
$T231781 = -168						; size = 4
$T231777 = -164						; size = 4
$T231773 = -160						; size = 4
$T231769 = -156						; size = 4
$T231765 = -152						; size = 4
$T231761 = -148						; size = 4
$T231757 = -144						; size = 4
$T231753 = -140						; size = 4
$T231749 = -136						; size = 4
$T231745 = -132						; size = 4
$T231741 = -128						; size = 4
$T231737 = -124						; size = 4
$T231733 = -120						; size = 4
$T231729 = -116						; size = 4
$T231725 = -112						; size = 4
$T231721 = -108						; size = 4
$T231717 = -104						; size = 4
$T231713 = -100						; size = 4
$T231709 = -96						; size = 4
$T231705 = -92						; size = 4
$T231701 = -88						; size = 4
$T231697 = -84						; size = 4
$T231693 = -80						; size = 4
$T231689 = -76						; size = 4
$T231685 = -72						; size = 4
$T231681 = -68						; size = 4
$T231677 = -64						; size = 4
$T231673 = -60						; size = 4
_szWonderType$ = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_szWonderTypeChar$ = -24				; size = 4
_pkBuildingClassInfo$ = -20				; size = 4
_bCheckForAncientWonders$ = -14				; size = 1
_bCheckForWonders$ = -13				; size = 1
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z PROC ; CvCityBuildings::IncrementWonderStats, COMDAT
; _this$ = ecx

; 3938 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3939 : 	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$[ebp], eax

; 3940 : 	if(pkBuildingClassInfo == NULL)

	cmp	DWORD PTR _pkBuildingClassInfo$[ebp], 0
	jne	SHORT $LN81@IncrementW

; 3941 : 		return;

	jmp	$LN78@IncrementW

; 3942 : 
; 3943 : 	const char* szWonderTypeChar = pkBuildingClassInfo->GetType();

$LN81@IncrementW:
	mov	ecx, DWORD PTR _pkBuildingClassInfo$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szWonderTypeChar$[ebp], eax

; 3944 : 	CvString szWonderType = szWonderTypeChar;

	cmp	DWORD PTR _szWonderTypeChar$[ebp], 0
	je	SHORT $LN85@IncrementW
	mov	ecx, DWORD PTR _szWonderTypeChar$[ebp]
	mov	DWORD PTR tv926[ebp], ecx
	jmp	SHORT $LN86@IncrementW
$LN85@IncrementW:
	mov	DWORD PTR tv926[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN86@IncrementW:
	mov	edx, DWORD PTR tv926[ebp]
	push	edx
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3945 : 
; 3946 : 	if(szWonderType == "BUILDINGCLASS_HEROIC_EPIC")

	push	OFFSET ??_C@_0BK@CBCBHNBB@BUILDINGCLASS_HEROIC_EPIC?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN76@IncrementW

; 3947 : 	{
; 3948 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HEROICEPIC);

	mov	edx, DWORD PTR $T231673[ebp]
	mov	DWORD PTR tv94[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv94[ebp], eax
	push	109					; 0000006dH
	mov	ecx, DWORD PTR tv94[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv94[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN76@IncrementW:

; 3949 : 	}
; 3950 : 	else if(szWonderType == "BUILDINGCLASS_NATIONAL_COLLEGE")

	push	OFFSET ??_C@_0BP@NOHGMPIA@BUILDINGCLASS_NATIONAL_COLLEGE?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN74@IncrementW

; 3951 : 	{
; 3952 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_NATIONALCOLLEGE);

	mov	eax, DWORD PTR $T231677[ebp]
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv146[ebp], ecx
	push	111					; 0000006fH
	mov	edx, DWORD PTR tv146[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv146[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN74@IncrementW:

; 3953 : 	}
; 3954 : 	else if(szWonderType == "BUILDINGCLASS_NATIONAL_EPIC")

	push	OFFSET ??_C@_0BM@JAHDLNMF@BUILDINGCLASS_NATIONAL_EPIC?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@IncrementW

; 3955 : 	{
; 3956 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_NATIONALEPIC);

	mov	edx, DWORD PTR $T231681[ebp]
	mov	DWORD PTR tv166[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv166[ebp], eax
	push	112					; 00000070H
	mov	ecx, DWORD PTR tv166[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv166[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN72@IncrementW:

; 3957 : 	}
; 3958 : 	else if(szWonderType == "BUILDINGCLASS_IRONWORKS")

	push	OFFSET ??_C@_0BI@HALBAMIJ@BUILDINGCLASS_IRONWORKS?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN70@IncrementW

; 3959 : 	{
; 3960 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_IRONWORKS);

	mov	eax, DWORD PTR $T231685[ebp]
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv186[ebp], ecx
	push	110					; 0000006eH
	mov	edx, DWORD PTR tv186[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv186[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN70@IncrementW:

; 3961 : 	}
; 3962 : 	else if(szWonderType == "BUILDINGCLASS_OXFORD_UNIVERSITY")

	push	OFFSET ??_C@_0CA@HDLCJCH@BUILDINGCLASS_OXFORD_UNIVERSITY?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN68@IncrementW

; 3963 : 	{
; 3964 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_OXFORDUNIVERSITY);

	mov	edx, DWORD PTR $T231689[ebp]
	mov	DWORD PTR tv206[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv206[ebp], eax
	push	113					; 00000071H
	mov	ecx, DWORD PTR tv206[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv206[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN68@IncrementW:

; 3965 : 	}
; 3966 : 	else if(szWonderType == "BUILDINGCLASS_HERMITAGE")

	push	OFFSET ??_C@_0BI@PIEGAHNC@BUILDINGCLASS_HERMITAGE?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN66@IncrementW

; 3967 : 	{
; 3968 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HERMITAGE);

	mov	eax, DWORD PTR $T231693[ebp]
	mov	DWORD PTR tv226[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv226[ebp], ecx
	push	108					; 0000006cH
	mov	edx, DWORD PTR tv226[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv226[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN66@IncrementW:

; 3969 : 	}
; 3970 : 	else if(szWonderType == "BUILDINGCLASS_GREAT_LIGHTHOUSE")

	push	OFFSET ??_C@_0BP@OPINPFPH@BUILDINGCLASS_GREAT_LIGHTHOUSE?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN64@IncrementW

; 3971 : 	{
; 3972 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATLIGHTHOUSE);

	mov	edx, DWORD PTR $T231697[ebp]
	mov	DWORD PTR tv246[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv246[ebp], eax
	push	98					; 00000062H
	mov	ecx, DWORD PTR tv246[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv246[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN64@IncrementW:

; 3973 : 	}
; 3974 : 	else if(szWonderType == "BUILDINGCLASS_STONEHENGE")

	push	OFFSET ??_C@_0BJ@ELCINAJD@BUILDINGCLASS_STONEHENGE?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN62@IncrementW

; 3975 : 	{
; 3976 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_STONEHENGE);

	mov	eax, DWORD PTR $T231701[ebp]
	mov	DWORD PTR tv266[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv266[ebp], ecx
	push	92					; 0000005cH
	mov	edx, DWORD PTR tv266[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv266[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN62@IncrementW:

; 3977 : 	}
; 3978 : 	else if(szWonderType == "BUILDINGCLASS_GREAT_LIBRARY")

	push	OFFSET ??_C@_0BM@JCCNACHL@BUILDINGCLASS_GREAT_LIBRARY?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN60@IncrementW

; 3979 : 	{
; 3980 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATLIBRARY);

	mov	edx, DWORD PTR $T231705[ebp]
	mov	DWORD PTR tv286[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv286[ebp], eax
	push	97					; 00000061H
	mov	ecx, DWORD PTR tv286[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv286[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN60@IncrementW:

; 3981 : 	}
; 3982 : 	else if(szWonderType == "BUILDINGCLASS_PYRAMID")

	push	OFFSET ??_C@_0BG@NJJLMNJB@BUILDINGCLASS_PYRAMID?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN58@IncrementW

; 3983 : 	{
; 3984 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_PYRAMIDS);

	mov	eax, DWORD PTR $T231709[ebp]
	mov	DWORD PTR tv306[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv306[ebp], ecx
	push	106					; 0000006aH
	mov	edx, DWORD PTR tv306[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv306[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN58@IncrementW:

; 3985 : 	}
; 3986 : 	else if(szWonderType == "BUILDINGCLASS_COLOSSUS")

	push	OFFSET ??_C@_0BH@MJKFKBCM@BUILDINGCLASS_COLOSSUS?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN56@IncrementW

; 3987 : 	{
; 3988 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_COLOSSUS);

	mov	edx, DWORD PTR $T231713[ebp]
	mov	DWORD PTR tv326[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv326[ebp], eax
	push	95					; 0000005fH
	mov	ecx, DWORD PTR tv326[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv326[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN56@IncrementW:

; 3989 : 	}
; 3990 : 	else if(szWonderType == "BUILDINGCLASS_ORACLE")

	push	OFFSET ??_C@_0BF@OHEJNEGG@BUILDINGCLASS_ORACLE?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN54@IncrementW

; 3991 : 	{
; 3992 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_ORACLE);

	mov	eax, DWORD PTR $T231717[ebp]
	mov	DWORD PTR tv346[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv346[ebp], ecx
	push	104					; 00000068H
	mov	edx, DWORD PTR tv346[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv346[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN54@IncrementW:

; 3993 : 	}
; 3994 : 	else if(szWonderType == "BUILDINGCLASS_HANGING_GARDEN")

	push	OFFSET ??_C@_0BN@OKOLACKI@BUILDINGCLASS_HANGING_GARDEN?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN52@IncrementW

; 3995 : 	{
; 3996 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HANGINGGARDENS);

	mov	edx, DWORD PTR $T231721[ebp]
	mov	DWORD PTR tv366[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv366[ebp], eax
	push	101					; 00000065H
	mov	ecx, DWORD PTR tv366[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv366[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN52@IncrementW:

; 3997 : 	}
; 3998 : 	else if(szWonderType == "BUILDINGCLASS_GREAT_WALL")

	push	OFFSET ??_C@_0BJ@FELJKKOK@BUILDINGCLASS_GREAT_WALL?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN50@IncrementW

; 3999 : 	{
; 4000 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_GREATWALL);

	mov	eax, DWORD PTR $T231725[ebp]
	mov	DWORD PTR tv386[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv386[ebp], ecx
	push	99					; 00000063H
	mov	edx, DWORD PTR tv386[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv386[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN50@IncrementW:

; 4001 : 	}
; 4002 : 	else if(szWonderType == "BUILDINGCLASS_ANGKOR_WAT")

	push	OFFSET ??_C@_0BJ@CICOKGOD@BUILDINGCLASS_ANGKOR_WAT?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN48@IncrementW

; 4003 : 	{
; 4004 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_ANGKORWAT);

	mov	edx, DWORD PTR $T231729[ebp]
	mov	DWORD PTR tv406[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv406[ebp], eax
	push	80					; 00000050H
	mov	ecx, DWORD PTR tv406[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv406[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN48@IncrementW:

; 4005 : 	}
; 4006 : 	else if(szWonderType == "BUILDINGCLASS_HAGIA_SOPHIA")

	push	OFFSET ??_C@_0BL@BBJGHBKH@BUILDINGCLASS_HAGIA_SOPHIA?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN46@IncrementW

; 4007 : 	{
; 4008 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HAGIASOPHIA);

	mov	eax, DWORD PTR $T231733[ebp]
	mov	DWORD PTR tv426[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv426[ebp], ecx
	push	100					; 00000064H
	mov	edx, DWORD PTR tv426[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv426[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN46@IncrementW:

; 4009 : 	}
; 4010 : 	else if(szWonderType == "BUILDINGCLASS_CHICHEN_ITZA")

	push	OFFSET ??_C@_0BL@DPKCLIK@BUILDINGCLASS_CHICHEN_ITZA?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@IncrementW

; 4011 : 	{
; 4012 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_CHICHENITZA);

	mov	edx, DWORD PTR $T231737[ebp]
	mov	DWORD PTR tv446[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv446[ebp], eax
	push	83					; 00000053H
	mov	ecx, DWORD PTR tv446[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv446[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN44@IncrementW:

; 4013 : 	}
; 4014 : 	else if(szWonderType == "BUILDINGCLASS_MACHU_PICHU")

	push	OFFSET ??_C@_0BK@EFGMFEAH@BUILDINGCLASS_MACHU_PICHU?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN42@IncrementW

; 4015 : 	{
; 4016 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_MACHUPICCHU);

	mov	eax, DWORD PTR $T231741[ebp]
	mov	DWORD PTR tv466[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv466[ebp], ecx
	push	87					; 00000057H
	mov	edx, DWORD PTR tv466[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv466[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN42@IncrementW:

; 4017 : 	}
; 4018 : 	else if(szWonderType == "BUILDINGCLASS_NOTRE_DAME")

	push	OFFSET ??_C@_0BJ@ICMCFFJL@BUILDINGCLASS_NOTRE_DAME?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN40@IncrementW

; 4019 : 	{
; 4020 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_NOTREDAME);

	mov	edx, DWORD PTR $T231745[ebp]
	mov	DWORD PTR tv486[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv486[ebp], eax
	push	88					; 00000058H
	mov	ecx, DWORD PTR tv486[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv486[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN40@IncrementW:

; 4021 : 	}
; 4022 : 	else if(szWonderType == "BUILDINGCLASS_PORCELAIN_TOWER")

	push	OFFSET ??_C@_0BO@FEBDGAMA@BUILDINGCLASS_PORCELAIN_TOWER?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN38@IncrementW

; 4023 : 	{
; 4024 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_PORCELAINTOWER);

	mov	eax, DWORD PTR $T231749[ebp]
	mov	DWORD PTR tv506[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv506[ebp], ecx
	push	105					; 00000069H
	mov	edx, DWORD PTR tv506[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv506[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN38@IncrementW:

; 4025 : 	}
; 4026 : 	else if(szWonderType == "BUILDINGCLASS_HIMEJI_CASTLE")

	push	OFFSET ??_C@_0BM@LNKHGGDK@BUILDINGCLASS_HIMEJI_CASTLE?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN36@IncrementW

; 4027 : 	{
; 4028 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_HIMEJICASTLE);

	mov	edx, DWORD PTR $T231753[ebp]
	mov	DWORD PTR tv526[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv526[ebp], eax
	push	86					; 00000056H
	mov	ecx, DWORD PTR tv526[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv526[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN36@IncrementW:

; 4029 : 	}
; 4030 : 	else if(szWonderType == "BUILDINGCLASS_SISTINE_CHAPEL")

	push	OFFSET ??_C@_0BN@PMDCMOMC@BUILDINGCLASS_SISTINE_CHAPEL?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@IncrementW

; 4031 : 	{
; 4032 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_SISTINECHAPEL);

	mov	eax, DWORD PTR $T231757[ebp]
	mov	DWORD PTR tv546[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv546[ebp], ecx
	push	90					; 0000005aH
	mov	edx, DWORD PTR tv546[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv546[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN34@IncrementW:

; 4033 : 	}
; 4034 : 	else if(szWonderType == "BUILDINGCLASS_KREMLIN")

	push	OFFSET ??_C@_0BG@GDDNOENL@BUILDINGCLASS_KREMLIN?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN32@IncrementW

; 4035 : 	{
; 4036 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_KREMLIN);

	mov	edx, DWORD PTR $T231761[ebp]
	mov	DWORD PTR tv566[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv566[ebp], eax
	push	102					; 00000066H
	mov	ecx, DWORD PTR tv566[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv566[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN32@IncrementW:

; 4037 : 	}
; 4038 : 	else if(szWonderType == "BUILDINGCLASS_FORBIDDEN_PALACE")

	push	OFFSET ??_C@_0BP@IHHKJLLK@BUILDINGCLASS_FORBIDDEN_PALACE?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN30@IncrementW

; 4039 : 	{
; 4040 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_FORBIDDENPALACE);

	mov	eax, DWORD PTR $T231765[ebp]
	mov	DWORD PTR tv586[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv586[ebp], ecx
	push	96					; 00000060H
	mov	edx, DWORD PTR tv586[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv586[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN30@IncrementW:

; 4041 : 	}
; 4042 : 	else if(szWonderType == "BUILDINGCLASS_TAJ_MAHAL")

	push	OFFSET ??_C@_0BI@FMPBECFE@BUILDINGCLASS_TAJ_MAHAL?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN28@IncrementW

; 4043 : 	{
; 4044 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_TAJMAHAL);

	mov	edx, DWORD PTR $T231769[ebp]
	mov	DWORD PTR tv606[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv606[ebp], eax
	push	94					; 0000005eH
	mov	ecx, DWORD PTR tv606[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv606[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN28@IncrementW:

; 4045 : 	}
; 4046 : 	else if(szWonderType == "BUILDINGCLASS_BIG_BEN")

	push	OFFSET ??_C@_0BG@KHIGNMHK@BUILDINGCLASS_BIG_BEN?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN26@IncrementW

; 4047 : 	{
; 4048 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_BIGBEN);

	mov	eax, DWORD PTR $T231773[ebp]
	mov	DWORD PTR tv626[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv626[ebp], ecx
	push	81					; 00000051H
	mov	edx, DWORD PTR tv626[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv626[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN26@IncrementW:

; 4049 : 	}
; 4050 : 	else if(szWonderType == "BUILDINGCLASS_LOUVRE")

	push	OFFSET ??_C@_0BF@INPGMHCL@BUILDINGCLASS_LOUVRE?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@IncrementW

; 4051 : 	{
; 4052 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_LOUVRE);

	mov	edx, DWORD PTR $T231777[ebp]
	mov	DWORD PTR tv646[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv646[ebp], eax
	push	103					; 00000067H
	mov	ecx, DWORD PTR tv646[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv646[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN24@IncrementW:

; 4053 : 	}
; 4054 : 	else if(szWonderType == "BUILDINGCLASS_BRANDENBURG_GATE")

	push	OFFSET ??_C@_0BP@PIIDEHHH@BUILDINGCLASS_BRANDENBURG_GATE?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@IncrementW

; 4055 : 	{
; 4056 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_BRANDENBURGGATE);

	mov	eax, DWORD PTR $T231781[ebp]
	mov	DWORD PTR tv666[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv666[ebp], ecx
	push	82					; 00000052H
	mov	edx, DWORD PTR tv666[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv666[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN22@IncrementW:

; 4057 : 	}
; 4058 : 	else if(szWonderType == "BUILDINGCLASS_STATUE_OF_LIBERTY")

	push	OFFSET ??_C@_0CA@LOKMMGBF@BUILDINGCLASS_STATUE_OF_LIBERTY?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@IncrementW

; 4059 : 	{
; 4060 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_STATUEOFLIBERTY);

	mov	edx, DWORD PTR $T231785[ebp]
	mov	DWORD PTR tv686[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv686[ebp], eax
	push	91					; 0000005bH
	mov	ecx, DWORD PTR tv686[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv686[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN20@IncrementW:

; 4061 : 	}
; 4062 : 	else if(szWonderType == "BUILDINGCLASS_CRISTO_REDENTOR")

	push	OFFSET ??_C@_0BO@HFMLAKAF@BUILDINGCLASS_CRISTO_REDENTOR?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@IncrementW

; 4063 : 	{
; 4064 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_CRISTOREDENTOR);

	mov	eax, DWORD PTR $T231789[ebp]
	mov	DWORD PTR tv706[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv706[ebp], ecx
	push	84					; 00000054H
	mov	edx, DWORD PTR tv706[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv706[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN18@IncrementW:

; 4065 : 	}
; 4066 : 	else if(szWonderType == "BUILDINGCLASS_EIFFEL_TOWER")

	push	OFFSET ??_C@_0BL@ODGFODOO@BUILDINGCLASS_EIFFEL_TOWER?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@IncrementW

; 4067 : 	{
; 4068 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_EIFFELTOWER);

	mov	edx, DWORD PTR $T231793[ebp]
	mov	DWORD PTR tv726[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv726[ebp], eax
	push	85					; 00000055H
	mov	ecx, DWORD PTR tv726[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv726[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN16@IncrementW:

; 4069 : 	}
; 4070 : 	else if(szWonderType == "BUILDINGCLASS_PENTAGON")

	push	OFFSET ??_C@_0BH@BICAGOLB@BUILDINGCLASS_PENTAGON?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@IncrementW

; 4071 : 	{
; 4072 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_PENTAGON);

	mov	eax, DWORD PTR $T231797[ebp]
	mov	DWORD PTR tv778[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv778[ebp], ecx
	push	89					; 00000059H
	mov	edx, DWORD PTR tv778[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv778[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN14@IncrementW:

; 4073 : 	}
; 4074 : 	else if(szWonderType == "BUILDINGCLASS_UNITED_NATIONS")

	push	OFFSET ??_C@_0BN@LLBELFOG@BUILDINGCLASS_UNITED_NATIONS?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@IncrementW

; 4075 : 	{
; 4076 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_UNITEDNATION);

	mov	edx, DWORD PTR $T231801[ebp]
	mov	DWORD PTR tv798[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv798[ebp], eax
	push	107					; 0000006bH
	mov	ecx, DWORD PTR tv798[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv798[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN12@IncrementW:

; 4077 : 	}
; 4078 : 	else if(szWonderType == "BUILDINGCLASS_SYDNEY_OPERA_HOUSE")

	push	OFFSET ??_C@_0CB@KLDNKEBJ@BUILDINGCLASS_SYDNEY_OPERA_HOUSE@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@IncrementW

; 4079 : 	{
; 4080 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_SYDNEYOPERAHOUSE);

	mov	eax, DWORD PTR $T231805[ebp]
	mov	DWORD PTR tv818[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv818[ebp], ecx
	push	93					; 0000005dH
	mov	edx, DWORD PTR tv818[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv818[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	$LN75@IncrementW
$LN10@IncrementW:

; 4081 : 	}
; 4082 : 	else if(szWonderType == "BUILDINGCLASS_STATUE_ZEUS")

	push	OFFSET ??_C@_0BK@EDJCDHEK@BUILDINGCLASS_STATUE_ZEUS?$AA@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@IncrementW

; 4083 : 	{
; 4084 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_STATUEOFZEUS);

	mov	edx, DWORD PTR $T231809[ebp]
	mov	DWORD PTR tv838[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv838[ebp], eax
	push	132					; 00000084H
	mov	ecx, DWORD PTR tv838[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv838[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
	jmp	$LN75@IncrementW
$LN8@IncrementW:

; 4085 : 	}
; 4086 : 	else if(szWonderType == "BUILDINGCLASS_TEMPLE_ARTEMIS")

	push	OFFSET ??_C@_0BN@PPEHPGEB@BUILDINGCLASS_TEMPLE_ARTEMIS?$AA@
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@IncrementW

; 4087 : 	{
; 4088 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_TEMPLEOFARTEMIS);

	mov	eax, DWORD PTR $T231813[ebp]
	mov	DWORD PTR tv858[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv858[ebp], ecx
	push	133					; 00000085H
	mov	edx, DWORD PTR tv858[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv858[ebp]
	mov	edx, DWORD PTR [eax+844]
	call	edx
	jmp	SHORT $LN75@IncrementW
$LN6@IncrementW:

; 4089 : 	}
; 4090 : 	else if(szWonderType == "BUILDINGCLASS_MAUSOLEUM_HALICARNASSUS")

	push	OFFSET ??_C@_0CG@JCJLNGJK@BUILDINGCLASS_MAUSOLEUM_HALICARN@
	lea	eax, DWORD PTR _szWonderType$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN75@IncrementW

; 4091 : 	{
; 4092 : 		gDLL->IncrementSteamStat(ESTEAMSTAT_MAUSOLEUMOFHALICARNASSUS);

	mov	edx, DWORD PTR $T231817[ebp]
	mov	DWORD PTR tv878[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv878[ebp], eax
	push	134					; 00000086H
	mov	ecx, DWORD PTR tv878[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv878[ebp]
	mov	eax, DWORD PTR [edx+844]
	call	eax
$LN75@IncrementW:

; 4093 : 	}
; 4094 : 	else
; 4095 : 	{
; 4096 : 		OutputDebugString("\nNo Stat for selected Wonder: ");
; 4097 : 		OutputDebugString(szWonderType);
; 4098 : 		OutputDebugString("\n");
; 4099 : 	}
; 4100 : 
; 4101 : 	bool bCheckForWonders = false;

	mov	BYTE PTR _bCheckForWonders$[ebp], 0

; 4102 : 	bCheckForWonders = CheckForAllWondersBuilt();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForAllWondersBuilt
	mov	BYTE PTR _bCheckForWonders$[ebp], al

; 4103 : 	if(bCheckForWonders)

	movzx	ecx, BYTE PTR _bCheckForWonders$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@IncrementW

; 4104 : 	{
; 4105 : 		gDLL->UnlockAchievement(ACHIEVEMENT_ALL_WONDERS);

	mov	edx, DWORD PTR $T231821[ebp]
	mov	DWORD PTR tv893[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv893[ebp], eax
	push	52					; 00000034H
	mov	ecx, DWORD PTR tv893[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv893[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN2@IncrementW:

; 4106 : 	}
; 4107 : 
; 4108 : 	//DLC_06
; 4109 : 	bool bCheckForAncientWonders = false;

	mov	BYTE PTR _bCheckForAncientWonders$[ebp], 0

; 4110 : 	bCheckForAncientWonders = CheckForSevenAncientWondersBuilt();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ ; CvCityBuildings::CheckForSevenAncientWondersBuilt
	mov	BYTE PTR _bCheckForAncientWonders$[ebp], al

; 4111 : 	if(bCheckForAncientWonders)

	movzx	ecx, BYTE PTR _bCheckForAncientWonders$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@IncrementW

; 4112 : 	{
; 4113 : 		gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_ANCIENT_WONDERS);

	mov	edx, DWORD PTR $T231825[ebp]
	mov	DWORD PTR tv908[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv908[ebp], eax
	push	177					; 000000b1H
	mov	ecx, DWORD PTR tv908[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv908[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN1@IncrementW:

; 4114 : 	}
; 4115 : 
; 4116 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN78@IncrementW:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z$0:
	lea	ecx, DWORD PTR _szWonderType$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?IncrementWonderStats@CvCityBuildings@@QAEXW4BuildingClassTypes@@@Z ENDP ; CvCityBuildings::IncrementWonderStats
; Function compile flags: /Odtp
;	COMDAT ?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ
_TEXT	SEGMENT
tv73 = -28						; size = 4
_this$ = -24						; size = 4
$T231841 = -20						; size = 4
_iEndStatWonder$ = -16					; size = 4
_iI$ = -12						; size = 4
_iStartStatWonder$ = -8					; size = 4
_nStat$ = -4						; size = 4
?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ PROC	; CvCityBuildings::CheckForAllWondersBuilt, COMDAT
; _this$ = ecx

; 4118 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4119 : 	int iI;
; 4120 : 	int iStartStatWonder = ESTEAMSTAT_ANGKORWAT;

	mov	DWORD PTR _iStartStatWonder$[ebp], 80	; 00000050H

; 4121 : 	int iEndStatWonder = ESTEAMSTAT_PYRAMIDS;		//Don't include the united nations because it was removed in BNW.

	mov	DWORD PTR _iEndStatWonder$[ebp], 106	; 0000006aH

; 4122 : 	int32 nStat;
; 4123 : 
; 4124 : 	for(iI = iStartStatWonder; iI < iEndStatWonder; iI++)

	mov	eax, DWORD PTR _iStartStatWonder$[ebp]
	mov	DWORD PTR _iI$[ebp], eax
	jmp	SHORT $LN5@CheckForAl
$LN4@CheckForAl:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@CheckForAl:
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iEndStatWonder$[ebp]
	jge	SHORT $LN3@CheckForAl

; 4125 : 	{
; 4126 : 		if(gDLL->GetSteamStat((ESteamStat)iI, &nStat))

	mov	eax, DWORD PTR $T231841[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv73[ebp], ecx
	lea	edx, DWORD PTR _nStat$[ebp]
	push	edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx+836]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@CheckForAl

; 4127 : 		{
; 4128 : 			if(nStat <= 0)

	cmp	DWORD PTR _nStat$[ebp], 0
	jg	SHORT $LN2@CheckForAl

; 4129 : 			{
; 4130 : 				return false;

	xor	al, al
	jmp	SHORT $LN6@CheckForAl
$LN2@CheckForAl:

; 4131 : 			}
; 4132 : 		}
; 4133 : 	}

	jmp	SHORT $LN4@CheckForAl
$LN3@CheckForAl:

; 4134 : 	return true;

	mov	al, 1
$LN6@CheckForAl:

; 4135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckForAllWondersBuilt@CvCityBuildings@@QAE_NXZ ENDP	; CvCityBuildings::CheckForAllWondersBuilt
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z:PROC	; ExtractGUID
; Function compile flags: /Odtp
;	COMDAT ?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ
_TEXT	SEGMENT
tv90 = -76						; size = 4
tv74 = -72						; size = 4
_this$ = -68						; size = 4
$T231852 = -64						; size = 4
$T231848 = -60						; size = 4
_iI$221183 = -56					; size = 4
_arrWonderStats$221181 = -52				; size = 28
_nStat$221182 = -24					; size = 4
_guid$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ PROC ; CvCityBuildings::CheckForSevenAncientWondersBuilt, COMDAT
; _this$ = ecx

; 4138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 4139 : 	GUID guid;
; 4140 : 	ExtractGUID(CIV5_DLC_06_PACKAGEID, guid);

	push	0
	lea	eax, DWORD PTR _guid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CIV5_DLC_06_PACKAGEID
	push	ecx
	call	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z	; ExtractGUID
	add	esp, 12					; 0000000cH

; 4141 : 
; 4142 : 	if(gDLL->IsDLCValid(guid))

	mov	edx, DWORD PTR $T231848[ebp]
	mov	DWORD PTR tv74[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv74[ebp], eax
	lea	ecx, DWORD PTR _guid$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv74[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR [eax+48]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	$LN7@CheckForSe

; 4143 : 	{
; 4144 : 		ESteamStat arrWonderStats[7] =
; 4145 : 		{
; 4146 : 			ESTEAMSTAT_COLOSSUS,

	mov	DWORD PTR _arrWonderStats$221181[ebp], 95 ; 0000005fH

; 4147 : 			ESTEAMSTAT_GREATLIGHTHOUSE,

	mov	DWORD PTR _arrWonderStats$221181[ebp+4], 98 ; 00000062H

; 4148 : 			ESTEAMSTAT_HANGINGGARDENS,

	mov	DWORD PTR _arrWonderStats$221181[ebp+8], 101 ; 00000065H

; 4149 : 			ESTEAMSTAT_PYRAMIDS,

	mov	DWORD PTR _arrWonderStats$221181[ebp+12], 106 ; 0000006aH

; 4150 : 			ESTEAMSTAT_STATUEOFZEUS,

	mov	DWORD PTR _arrWonderStats$221181[ebp+16], 132 ; 00000084H

; 4151 : 			ESTEAMSTAT_TEMPLEOFARTEMIS,

	mov	DWORD PTR _arrWonderStats$221181[ebp+20], 133 ; 00000085H

; 4152 : 			ESTEAMSTAT_MAUSOLEUMOFHALICARNASSUS
; 4153 : 		};

	mov	DWORD PTR _arrWonderStats$221181[ebp+24], 134 ; 00000086H

; 4154 : 		int32 nStat;
; 4155 : 		for(int iI = 0; iI < 7; iI++)

	mov	DWORD PTR _iI$221183[ebp], 0
	jmp	SHORT $LN6@CheckForSe
$LN5@CheckForSe:
	mov	ecx, DWORD PTR _iI$221183[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221183[ebp], ecx
$LN6@CheckForSe:
	cmp	DWORD PTR _iI$221183[ebp], 7
	jge	SHORT $LN4@CheckForSe

; 4156 : 		{
; 4157 : 			if(gDLL->GetSteamStat(arrWonderStats[iI], &nStat))

	mov	edx, DWORD PTR $T231852[ebp]
	mov	DWORD PTR tv90[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv90[ebp], eax
	lea	ecx, DWORD PTR _nStat$221182[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$221183[ebp]
	mov	eax, DWORD PTR _arrWonderStats$221181[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv90[ebp]
	mov	eax, DWORD PTR [edx+836]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@CheckForSe

; 4158 : 			{
; 4159 : 				if(nStat <= 0)

	cmp	DWORD PTR _nStat$221182[ebp], 0
	jg	SHORT $LN2@CheckForSe

; 4160 : 				{
; 4161 : 					return false;

	xor	al, al
	jmp	SHORT $LN8@CheckForSe
$LN2@CheckForSe:

; 4162 : 				}
; 4163 : 			}
; 4164 : 			else

	jmp	SHORT $LN1@CheckForSe
$LN3@CheckForSe:

; 4165 : 			{
; 4166 : 				// Couldn't get one of the SteamStats for some reason
; 4167 : 				return false;

	xor	al, al
	jmp	SHORT $LN8@CheckForSe
$LN1@CheckForSe:

; 4168 : 			}
; 4169 : 		}

	jmp	SHORT $LN5@CheckForSe
$LN4@CheckForSe:

; 4170 : 		return true;

	mov	al, 1
	jmp	SHORT $LN8@CheckForSe
$LN7@CheckForSe:

; 4171 : 	}
; 4172 : 	return false;

	xor	al, al
$LN8@CheckForSe:

; 4173 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckForSevenAncientWondersBuilt@CvCityBuildings@@QAE_NXZ ENDP ; CvCityBuildings::CheckForSevenAncientWondersBuilt
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z PROC ; CvCityBuildings::NotifyNewBuildingStarted, COMDAT
; _this$ = ecx

; 4177 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4178 : 	// JON: Disabling this notification
; 4179 : 	return;
; 4180 : 
; 4181 : 	// is this city starting a wonder? If so, send a notification
; 4182 : 	//CvBuildingEntry* buildingEntry = GC.getBuildingInfo(eIndex);
; 4183 : 	//if (isLimitedWonderClass((BuildingClassTypes)(buildingEntry->GetBuildingClassType())) && GetBuildingProductionTimes100(eIndex) == 0)
; 4184 : 	//{
; 4185 : 	//	Localization::String locString;
; 4186 : 	//	Localization::String locSummaryString;
; 4187 : 
; 4188 : 	//	for (uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)
; 4189 : 	//	{
; 4190 : 	//		PlayerTypes ePlayer = (PlayerTypes)ui;
; 4191 : 
; 4192 : 	//		if (ePlayer == m_pCity->getOwner() || !GET_PLAYER(ePlayer).isAlive())
; 4193 : 	//		{
; 4194 : 	//			continue;
; 4195 : 	//		}
; 4196 : 
; 4197 : 	//		int iX = -1;
; 4198 : 	//		int iY = -1;
; 4199 : 	//		int iPlayerID = -1;
; 4200 : 
; 4201 : 	//		if (GET_TEAM(m_pCity->getTeam()).isHasMet(GET_PLAYER(ePlayer).getTeam()))
; 4202 : 	//		{
; 4203 : 	//			if (m_pCity->isRevealed(GET_PLAYER(ePlayer).getTeam(), false))
; 4204 : 	//			{
; 4205 : 	//				locString = Localization::Lookup("TXT_KEY_NOTIFICATION_WONDER_STARTED");
; 4206 : 	//				locString << GET_PLAYER(m_pCity->getOwner()).getNameKey() << buildingEntry->GetTextKey() << m_pCity->getNameKey();
; 4207 : 	//			}
; 4208 : 	//			else
; 4209 : 	//			{
; 4210 : 	//				locString = Localization::Lookup("TXT_KEY_NOTIFICATION_WONDER_STARTED_UNKNOWN_LOCATION");
; 4211 : 	//				locString << GET_PLAYER(m_pCity->getOwner()).getNameKey() << buildingEntry->GetTextKey();
; 4212 : 	//			}
; 4213 : 
; 4214 : 
; 4215 : 	//			locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_WONDER_STARTED");
; 4216 : 	//			locSummaryString << GET_PLAYER(m_pCity->getOwner()).getNameKey() << buildingEntry->GetTextKey();
; 4217 : 
; 4218 : 	//		}
; 4219 : 	//		else
; 4220 : 	//		{
; 4221 : 	//			locString = Localization::Lookup("TXT_KEY_NOTIFICATION_WONDER_STARTED_UNMET");
; 4222 : 	//			locString << buildingEntry->GetTextKey();
; 4223 : 	//			locSummaryString = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_WONDER_STARTED_UNKNOWN");
; 4224 : 	//			locSummaryString << buildingEntry->GetTextKey();
; 4225 : 	//		}
; 4226 : 
; 4227 : 	//		CvNotifications* pNotifications = GET_PLAYER(ePlayer).GetNotifications();
; 4228 : 	//		if (pNotifications)
; 4229 : 	//		{
; 4230 : 	//			pNotifications->Add(NOTIFICATION_WONDER_STARTED, locString.toUTF8(), locSummaryString.toUTF8(), iX, iY, eIndex);
; 4231 : 	//		}
; 4232 : 	//	}
; 4233 : 	//}
; 4234 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NotifyNewBuildingStarted@CvCityBuildings@@AAEXW4BuildingTypes@@@Z ENDP ; CvCityBuildings::NotifyNewBuildingStarted
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
;	COMDAT ??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@ DB 'LOAD ERROR'
	DB	': Building Type not found', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0
__ehfuncinfo$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.cpp
xdata$x	ENDS
;	COMDAT ?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
_TEXT	SEGMENT
_iDummy$221211 = -64					; size = 4
_szError$221209 = -60					; size = 28
__$ArrayPad$ = -32					; size = 4
_bValid$221204 = -25					; size = 1
_iI$221200 = -24					; size = 4
_iType$ = -20						; size = 4
_iNumEntries$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
_paiBuildingArray$ = 12					; size = 4
?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z PROC ; BuildingArrayHelpers::Read, COMDAT

; 4238 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4239 : 	int iNumEntries;
; 4240 : 	int iType;
; 4241 : 
; 4242 : 	kStream >> iNumEntries;

	lea	eax, DWORD PTR _iNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4243 : 
; 4244 : 	for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$221200[ebp], 0
	jmp	SHORT $LN7@Read
$LN6@Read:
	mov	ecx, DWORD PTR _iI$221200[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221200[ebp], ecx
$LN7@Read:
	mov	edx, DWORD PTR _iI$221200[ebp]
	cmp	edx, DWORD PTR _iNumEntries$[ebp]
	jge	$LN8@Read

; 4245 : 	{
; 4246 : 		bool bValid = true;

	mov	BYTE PTR _bValid$221204[ebp], 1

; 4247 : 		iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$221204[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$[ebp], eax

; 4248 : 		if(iType != -1 || !bValid)

	cmp	DWORD PTR _iType$[ebp], -1
	jne	SHORT $LN3@Read
	movzx	edx, BYTE PTR _bValid$221204[ebp]
	test	edx, edx
	jne	SHORT $LN4@Read
$LN3@Read:

; 4249 : 		{
; 4250 : 			if(iType != -1)

	cmp	DWORD PTR _iType$[ebp], -1
	je	SHORT $LN2@Read

; 4251 : 			{
; 4252 : 				kStream >> paiBuildingArray[iType];

	mov	eax, DWORD PTR _iType$[ebp]
	mov	ecx, DWORD PTR _paiBuildingArray$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4253 : 			}
; 4254 : 			else

	jmp	SHORT $LN4@Read
$LN2@Read:

; 4255 : 			{
; 4256 : 				CvString szError;

	lea	ecx, DWORD PTR _szError$221209[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4257 : 				szError.Format("LOAD ERROR: Building Type not found");

	push	OFFSET ??_C@_0CE@MEGFIFOL@LOAD?5ERROR?3?5Building?5Type?5not?5fo@
	lea	eax, DWORD PTR _szError$221209[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 4258 : 				GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$221209[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 4259 : 				CvAssertMsg(false, szError);
; 4260 : 				int iDummy;
; 4261 : 				kStream >> iDummy; // Skip it.

	lea	ecx, DWORD PTR _iDummy$221211[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 4262 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szError$221209[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@Read:

; 4263 : 		}

	jmp	$LN6@Read
$LN8@Read:

; 4264 : 	}
; 4265 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z$0:
	lea	ecx, DWORD PTR _szError$221209[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@BuildingArrayHelpers@@YAXAAVFDataStream@@PAH@Z ENDP ; BuildingArrayHelpers::Read
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
;	COMDAT ?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
$T231887 = -16						; size = 4
_eBuilding$221221 = -12					; size = 4
_pkBuildingInfo$221223 = -8				; size = 4
_iI$221217 = -4						; size = 4
_kStream$ = 8						; size = 4
_paiBuildingArray$ = 12					; size = 4
_iArraySize$ = 16					; size = 4
?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z PROC ; BuildingArrayHelpers::Write, COMDAT

; 4269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4270 : 	kStream << iArraySize;

	lea	eax, DWORD PTR _iArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4271 : 
; 4272 : 	for(int iI = 0; iI < iArraySize; iI++)

	mov	DWORD PTR _iI$221217[ebp], 0
	jmp	SHORT $LN5@Write
$LN4@Write:
	mov	ecx, DWORD PTR _iI$221217[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221217[ebp], ecx
$LN5@Write:
	mov	edx, DWORD PTR _iI$221217[ebp]
	cmp	edx, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN6@Write

; 4273 : 	{
; 4274 : 		const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

	mov	eax, DWORD PTR _iI$221217[ebp]
	mov	DWORD PTR _eBuilding$221221[ebp], eax

; 4275 : 		CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$221221[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$221223[ebp], eax

; 4276 : 		if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$221223[ebp], 0
	je	SHORT $LN2@Write

; 4277 : 		{
; 4278 : 			CvInfosSerializationHelper::WriteHashed(kStream, pkBuildingInfo);;

	mov	edx, DWORD PTR _pkBuildingInfo$221223[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 4279 : 			kStream << paiBuildingArray[iI];

	mov	ecx, DWORD PTR _iI$221217[ebp]
	mov	edx, DWORD PTR _paiBuildingArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 4280 : 		}
; 4281 : 		else

	jmp	SHORT $LN1@Write
$LN2@Write:

; 4282 : 		{
; 4283 : 			kStream << (int)0;

	mov	DWORD PTR $T231887[ebp], 0
	lea	ecx, DWORD PTR $T231887[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@Write:

; 4284 : 		}

	jmp	SHORT $LN4@Write
$LN6@Write:

; 4285 : 	}
; 4286 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Write@BuildingArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ENDP ; BuildingArrayHelpers::Write
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T231900 = -2						; size = 1
$T231899 = -1						; size = 1
??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T231899[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231900[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >

; 104  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::~pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
PUBLIC	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$14
__ehfuncinfo$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
_TEXT	SEGMENT
tv172 = -188						; size = 4
tv185 = -184						; size = 4
_this$ = -180						; size = 4
$T232300 = -136						; size = 4
$T232139 = -92						; size = 4
$T232134 = -88						; size = 4
$T232063 = -68						; size = 4
$T232050 = -64						; size = 4
$T232034 = -60						; size = 4
$T232022 = -56						; size = 4
$T232021 = -52						; size = 4
$T232020 = -48						; size = 12
$T232019 = -36						; size = 16
$T232018 = -20						; size = 4
__Where$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z PROC ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound
	mov	DWORD PTR $T232034[ebp], eax
	mov	ecx, DWORD PTR $T232034[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T232050[ebp], eax
	mov	ecx, DWORD PTR $T232050[ebp]
	mov	DWORD PTR $T232018[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T232018[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@operator
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T232063[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T232063[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN182@operator
$LN1@operator:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T232021[ebp], edx
	lea	ecx, DWORD PTR $T232020[ebp]
	call	??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
	mov	DWORD PTR tv185[ebp], eax
	mov	eax, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T232139[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR __Keyval$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T232019[ebp], edx
	lea	eax, DWORD PTR $T232019[ebp+4]
	mov	DWORD PTR $T232134[ebp], eax
	mov	ecx, DWORD PTR $T232139[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232134[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	lea	edx, DWORD PTR $T232019[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv172[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232021[ebp]
	push	ecx
	lea	edx, DWORD PTR $T232022[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T232019[ebp+4]
	mov	DWORD PTR $T232300[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T232300[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T232020[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 174  : 		return ((*_Where).second);

$LN182@operator:
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 16					; 00000010H

; 175  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$0:
	lea	ecx, DWORD PTR $T232020[ebp]
	jmp	??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$1:
	lea	ecx, DWORD PTR $T232019[ebp]
	jmp	??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ
__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$8:
	mov	ecx, DWORD PTR $T232300[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__unwindfunclet$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z$14:
	lea	ecx, DWORD PTR $T232020[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-180]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$map@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@1@ABH@Z ENDP ; std::map<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > > >::operator[]
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv137 = -192						; size = 4
tv163 = -188						; size = 4
tv189 = -184						; size = 4
_this$ = -180						; size = 4
$T232559 = -46						; size = 1
$T232541 = -45						; size = 1
$T232530 = -44						; size = 4
$T232550 = -40						; size = 4
$T232523 = -36						; size = 4
$T232513 = -28						; size = 4
$T232499 = -21						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T232559[ebp]
	mov	DWORD PTR $T232513[ebp], eax
	lea	ecx, DWORD PTR $T232541[ebp]
	mov	DWORD PTR $T232523[ebp], ecx
	push	ecx
	mov	edx, esp
	mov	DWORD PTR $T232550[ebp], esp
	mov	DWORD PTR $T232530[ebp], edx
	lea	eax, DWORD PTR $T232499[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T233151 = -16						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233151[ebp], eax
	mov	ecx, DWORD PTR $T233151[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
tv93 = -48						; size = 4
_this$ = -44						; size = 4
$T233250 = -40						; size = 4
$T233229 = -36						; size = 4
$T233218 = -32						; size = 4
$T233209 = -28						; size = 4
$T233169 = -16						; size = 4
$T233167 = -12						; size = 4
$T233166 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound
	mov	DWORD PTR $T233209[ebp], eax
	mov	ecx, DWORD PTR $T233209[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233218[ebp], eax
	mov	ecx, DWORD PTR $T233218[ebp]
	mov	DWORD PTR $T233167[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T233167[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T233229[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T233229[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN4@find
$LN3@find:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T233250[ebp], ecx
	mov	edx, DWORD PTR $T233250[ebp]
	mov	DWORD PTR $T233169[ebp], edx
	lea	eax, DWORD PTR $T233169[ebp]
	mov	DWORD PTR tv93[ebp], eax
$LN4@find:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T233166[ebp], ecx
	mov	edx, DWORD PTR $T233166[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::find
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$1
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T233307 = -52						; size = 4
$T233306 = -48						; size = 4
__Tmp$233304 = -44					; size = 4
$T233300 = -40						; size = 4
$T233299 = -36						; size = 4
__Tmp$233297 = -32					; size = 4
__Tmp$221321 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN16@swap
	jmp	$LN5@swap

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())

$LN16@swap:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN31@swap

; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	mov	DWORD PTR $T233300[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T233299[ebp], ecx
	mov	edx, DWORD PTR $T233299[ebp]
	cmp	edx, DWORD PTR $T233300[ebp]
	je	SHORT $LN26@swap
	mov	eax, DWORD PTR $T233299[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$233297[ebp], ecx
	mov	edx, DWORD PTR $T233299[ebp]
	mov	eax, DWORD PTR $T233300[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T233300[ebp]
	mov	eax, DWORD PTR __Tmp$233297[ebp]
	mov	DWORD PTR [edx], eax
$LN26@swap:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T233307[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T233306[ebp], edx
	mov	eax, DWORD PTR $T233306[ebp]
	cmp	eax, DWORD PTR $T233307[ebp]
	je	SHORT $LN29@swap
	mov	ecx, DWORD PTR $T233306[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$233304[ebp], edx
	mov	eax, DWORD PTR $T233306[ebp]
	mov	ecx, DWORD PTR $T233307[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T233307[ebp]
	mov	ecx, DWORD PTR __Tmp$233304[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@swap:

; 1048 : 			}
; 1049 : 		else

	jmp	SHORT $LN5@swap

; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);

$LN31@swap:

; 1052 : 
; 1053 : 			_Myt _Tmp = *this;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$221321[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1054 : 
; 1055 : 			*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=

; 1056 : 			_Right = _Tmp;

	lea	ecx, DWORD PTR __Tmp$221321[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=

; 1057 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Tmp$221321[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN5@swap:

; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$0:
	lea	ecx, DWORD PTR __Tmp$221321[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z$1:
	lea	ecx, DWORD PTR __Tmp$221321[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >
PUBLIC	?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert
PUBLIC	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T234738 = -32						; size = 4
$T234728 = -28						; size = 4
$T234718 = -24						; size = 4
__Cat$234725 = -19					; size = 1
$T234722 = -18						; size = 1
$T234721 = -17						; size = 1
$T234695 = -16						; size = 4
$T234691 = -12						; size = 4
$T234690 = -8						; size = 4
$T234689 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T234695[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	edx, DWORD PTR $T234695[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234728[ebp], ecx
	mov	edx, DWORD PTR $T234728[ebp]
	mov	DWORD PTR $T234718[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T234721[ebp], al
	mov	cl, BYTE PTR __Cat$234725[ebp]
	mov	BYTE PTR $T234722[ebp], cl
	movzx	edx, BYTE PTR $T234721[ebp]
	push	edx
	movzx	eax, BYTE PTR $T234722[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T234718[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR $T234728[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234738[ebp], ecx
	mov	edx, DWORD PTR $T234738[ebp]
	mov	DWORD PTR $T234690[ebp], edx
	mov	eax, DWORD PTR $T234690[ebp]
	mov	DWORD PTR $T234689[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234689[ebp]
	push	edx
	lea	eax, DWORD PTR $T234691[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T234908 = -56						; size = 4
$T234907 = -52						; size = 4
$T234889 = -48						; size = 4
$T234888 = -44						; size = 4
$T234872 = -40						; size = 4
__Cat$234895 = -34					; size = 1
$T234892 = -33						; size = 1
$T234846 = -32						; size = 4
$T234845 = -28						; size = 4
$T234844 = -24						; size = 4
$T234827 = -18						; size = 1
$T234826 = -17						; size = 1
$T234825 = -16						; size = 4
$T234824 = -12						; size = 4
__Cat$234835 = -4					; size = 1
$T234832 = -3						; size = 1
$T234831 = -2						; size = 1
$T234830 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T234846[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T234845[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T234844[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T234830[ebp], cl
	mov	dl, BYTE PTR __Cat$234835[ebp]
	mov	BYTE PTR $T234831[ebp], dl
	mov	al, BYTE PTR $T234830[ebp]
	mov	BYTE PTR $T234827[ebp], al
	mov	cl, BYTE PTR $T234832[ebp]
	mov	BYTE PTR $T234826[ebp], cl
	mov	edx, DWORD PTR $T234846[ebp]
	mov	DWORD PTR $T234825[ebp], edx
	mov	eax, DWORD PTR $T234844[ebp]
	mov	DWORD PTR $T234824[ebp], eax
	jmp	SHORT $LN11@erase
$LN10@erase:
	mov	ecx, DWORD PTR $T234825[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T234825[ebp], ecx
	mov	edx, DWORD PTR $T234824[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T234824[ebp], edx
$LN11@erase:
	mov	eax, DWORD PTR $T234824[ebp]
	cmp	eax, DWORD PTR $T234845[ebp]
	je	SHORT $LN3@erase
	mov	ecx, DWORD PTR $T234824[ebp]
	mov	edx, DWORD PTR $T234825[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN10@erase
$LN3@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234908[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T234907[ebp], edx
	mov	eax, DWORD PTR $T234908[ebp]
	mov	DWORD PTR $T234889[ebp], eax
	mov	ecx, DWORD PTR $T234907[ebp]
	mov	DWORD PTR $T234888[ebp], ecx
	mov	dl, BYTE PTR __Cat$234895[ebp]
	mov	BYTE PTR $T234892[ebp], dl
	mov	eax, DWORD PTR $T234888[ebp]
	mov	DWORD PTR $T234872[ebp], eax
	jmp	SHORT $LN22@erase
$LN21@erase:
	mov	ecx, DWORD PTR $T234872[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T234872[ebp], ecx
$LN22@erase:
	mov	edx, DWORD PTR $T234872[ebp]
	cmp	edx, DWORD PTR $T234889[ebp]
	je	SHORT $LN14@erase
	jmp	SHORT $LN21@erase
$LN14@erase:

; 1021 : 		--_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
_TEXT	ENDS
PUBLIC	?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert
PUBLIC	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T234975 = -32						; size = 4
$T234965 = -28						; size = 4
$T234955 = -24						; size = 4
__Cat$234962 = -19					; size = 1
$T234959 = -18						; size = 1
$T234958 = -17						; size = 1
$T234932 = -16						; size = 4
$T234928 = -12						; size = 4
$T234927 = -8						; size = 4
$T234926 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T234932[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back@2
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@2:
	mov	edx, DWORD PTR $T234932[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234965[ebp], ecx
	mov	edx, DWORD PTR $T234965[ebp]
	mov	DWORD PTR $T234955[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T234958[ebp], al
	mov	cl, BYTE PTR __Cat$234962[ebp]
	mov	BYTE PTR $T234959[ebp], cl
	movzx	edx, BYTE PTR $T234958[ebp]
	push	edx
	movzx	eax, BYTE PTR $T234959[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T234955[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR $T234965[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234975[ebp], ecx
	mov	edx, DWORD PTR $T234975[ebp]
	mov	DWORD PTR $T234927[ebp], edx
	mov	eax, DWORD PTR $T234927[ebp]
	mov	DWORD PTR $T234926[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234926[ebp]
	push	edx
	lea	eax, DWORD PTR $T234928[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert
$LN3@push_back@2:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T235145 = -56						; size = 4
$T235144 = -52						; size = 4
$T235126 = -48						; size = 4
$T235125 = -44						; size = 4
$T235109 = -40						; size = 4
__Cat$235133 = -34					; size = 1
$T235130 = -33						; size = 1
$T235083 = -32						; size = 4
$T235082 = -28						; size = 4
$T235081 = -24						; size = 4
$T235064 = -18						; size = 1
$T235063 = -17						; size = 1
$T235062 = -16						; size = 4
$T235061 = -12						; size = 4
__Cat$235072 = -4					; size = 1
$T235069 = -3						; size = 1
$T235068 = -2						; size = 1
$T235067 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T235083[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T235082[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T235081[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T235067[ebp], cl
	mov	dl, BYTE PTR __Cat$235072[ebp]
	mov	BYTE PTR $T235068[ebp], dl
	mov	al, BYTE PTR $T235067[ebp]
	mov	BYTE PTR $T235064[ebp], al
	mov	cl, BYTE PTR $T235069[ebp]
	mov	BYTE PTR $T235063[ebp], cl
	mov	edx, DWORD PTR $T235083[ebp]
	mov	DWORD PTR $T235062[ebp], edx
	mov	eax, DWORD PTR $T235081[ebp]
	mov	DWORD PTR $T235061[ebp], eax
	jmp	SHORT $LN11@erase@2
$LN10@erase@2:
	mov	ecx, DWORD PTR $T235062[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T235062[ebp], ecx
	mov	edx, DWORD PTR $T235061[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T235061[ebp], edx
$LN11@erase@2:
	mov	eax, DWORD PTR $T235061[ebp]
	cmp	eax, DWORD PTR $T235082[ebp]
	je	SHORT $LN3@erase@2
	mov	ecx, DWORD PTR $T235061[ebp]
	mov	edx, DWORD PTR $T235062[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN10@erase@2
$LN3@erase@2:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T235145[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T235144[ebp], edx
	mov	eax, DWORD PTR $T235145[ebp]
	mov	DWORD PTR $T235126[ebp], eax
	mov	ecx, DWORD PTR $T235144[ebp]
	mov	DWORD PTR $T235125[ebp], ecx
	mov	dl, BYTE PTR __Cat$235133[ebp]
	mov	BYTE PTR $T235130[ebp], dl
	mov	eax, DWORD PTR $T235125[ebp]
	mov	DWORD PTR $T235109[ebp], eax
	jmp	SHORT $LN22@erase@2
$LN21@erase@2:
	mov	ecx, DWORD PTR $T235109[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T235109[ebp], ecx
$LN22@erase@2:
	mov	edx, DWORD PTR $T235109[ebp]
	cmp	edx, DWORD PTR $T235126[ebp]
	je	SHORT $LN14@erase@2
	jmp	SHORT $LN21@erase@2
$LN14@erase@2:

; 1021 : 		--_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T235240 = -48						; size = 4
$T235227 = -44						; size = 4
$T235211 = -40						; size = 4
$T235167 = -28						; size = 4
$T235166 = -24						; size = 4
$T235165 = -20						; size = 4
$T235164 = -16						; size = 8
$T235163 = -8						; size = 4
__Where$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
	mov	DWORD PTR $T235211[ebp], eax
	mov	ecx, DWORD PTR $T235211[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235227[ebp], eax
	mov	ecx, DWORD PTR $T235227[ebp]
	mov	DWORD PTR $T235163[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T235163[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@operator@2
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T235240[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T235240[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@operator@2
$LN1@operator@2:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	DWORD PTR $T235165[ebp], 0
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T235166[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235164[ebp], ecx
	mov	edx, DWORD PTR $T235165[ebp]
	mov	DWORD PTR $T235164[ebp+4], edx
	lea	eax, DWORD PTR $T235164[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235166[ebp]
	push	ecx
	lea	edx, DWORD PTR $T235167[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], eax

; 174  : 		return ((*_Where).second);

$LN55@operator@2:
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 16					; 00000010H

; 175  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAEAAHABH@Z ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::operator[]
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
tv93 = -48						; size = 4
_this$ = -44						; size = 4
$T235361 = -40						; size = 4
$T235340 = -36						; size = 4
$T235329 = -32						; size = 4
$T235320 = -28						; size = 4
$T235280 = -16						; size = 4
$T235278 = -12						; size = 4
$T235277 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
	mov	DWORD PTR $T235320[ebp], eax
	mov	ecx, DWORD PTR $T235320[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235329[ebp], eax
	mov	ecx, DWORD PTR $T235329[ebp]
	mov	DWORD PTR $T235278[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T235278[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find@2
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T235340[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T235340[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find@2
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN4@find@2
$LN3@find@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235361[ebp], ecx
	mov	edx, DWORD PTR $T235361[ebp]
	mov	DWORD PTR $T235280[ebp], edx
	lea	eax, DWORD PTR $T235280[ebp]
	mov	DWORD PTR tv93[ebp], eax
$LN4@find@2:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T235277[ebp], ecx
	mov	edx, DWORD PTR $T235277[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::find
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$235372 = -8					; size = 4
$T235368 = -4						; size = 4
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235368[ebp], ecx
	cmp	DWORD PTR $T235368[ebp], 0
	je	SHORT $LN1@auto_ptr
	mov	edx, DWORD PTR $T235368[ebp]
	mov	DWORD PTR _inst$235372[ebp], edx
	mov	eax, DWORD PTR _inst$235372[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$235372[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$235380 = -8					; size = 4
$T235376 = -4						; size = 4
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235376[ebp], ecx
	cmp	DWORD PTR $T235376[ebp], 0
	je	SHORT $LN1@auto_ptr@2
	mov	edx, DWORD PTR $T235376[ebp]
	mov	DWORD PTR _inst$235380[ebp], edx
	mov	eax, DWORD PTR _inst$235380[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$235380[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ$2
__ehfuncinfo$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T235932 = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ PROC ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::~pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T235932[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T235932[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T235932[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >::~pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::~_Tree_val<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::~_Vector_val<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >::~_Vector_val<BuildingYieldChange,std::allocator<BuildingYieldChange> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >::~_Vector_val<BuildingGreatWork,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T236075 = -47						; size = 1
$T236050 = -46						; size = 1
$T236032 = -45						; size = 1
$T236021 = -44						; size = 4
$T236064 = -40						; size = 4
$T236014 = -36						; size = 4
$T236007 = -28						; size = 4
$T236000 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T236075[ebp]
	mov	DWORD PTR $T236000[ebp], eax
	lea	ecx, DWORD PTR $T236050[ebp]
	mov	DWORD PTR $T236007[ebp], ecx
	lea	edx, DWORD PTR $T236032[ebp]
	mov	DWORD PTR $T236014[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T236064[ebp], esp
	mov	DWORD PTR $T236021[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T236152 = -32						; size = 4
$T236139 = -28						; size = 4
$T236127 = -24						; size = 4
$T236117 = -20						; size = 4
$T236116 = -16						; size = 4
$T236115 = -12						; size = 4
$T236114 = -8						; size = 4
$T236113 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@3

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236127[ebp], edx
	mov	eax, DWORD PTR $T236127[ebp]
	mov	DWORD PTR $T236114[ebp], eax
	mov	ecx, DWORD PTR $T236114[ebp]
	mov	DWORD PTR $T236113[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236139[ebp], eax
	mov	ecx, DWORD PTR $T236139[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T236152[ebp], edx
	mov	eax, DWORD PTR $T236152[ebp]
	mov	DWORD PTR $T236116[ebp], eax
	mov	ecx, DWORD PTR $T236116[ebp]
	mov	DWORD PTR $T236115[ebp], ecx
	mov	edx, DWORD PTR $T236113[ebp]
	push	edx
	mov	eax, DWORD PTR $T236115[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236117[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
$LN1@operator@3:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::operator=
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T236986 = -372						; size = 4
$T236963 = -368						; size = 4
$T236947 = -364						; size = 4
$T236921 = -360						; size = 4
$T236902 = -356						; size = 4
$T236882 = -352						; size = 4
$T236853 = -348						; size = 4
$T236838 = -344						; size = 4
$T236824 = -340						; size = 4
$T236803 = -336						; size = 4
$T236771 = -332						; size = 4
$T236754 = -328						; size = 4
$T236741 = -324						; size = 4
$T236723 = -320						; size = 4
$T236703 = -316						; size = 4
$T236684 = -312						; size = 4
$T236655 = -308						; size = 4
$T236639 = -304						; size = 4
$T236616 = -300						; size = 4
$T236593 = -296						; size = 4
$T236568 = -216						; size = 4
$T236554 = -212						; size = 4
$T236536 = -208						; size = 4
$T236503 = -128						; size = 4
$T236483 = -124						; size = 4
$T236470 = -120						; size = 4
$T236460 = -40						; size = 4
$T236453 = -36						; size = 8
$T236452 = -28						; size = 4
$T236451 = -24						; size = 4
$T236450 = -20						; size = 4
$T236449 = -16						; size = 4
$T236448 = -12						; size = 4
$T236447 = -8						; size = 4
__Next$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	mov	DWORD PTR __Next$[ebp], 0

; 672  : 
; 673  : 		if (size() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T236460[ebp], ecx
	cmp	DWORD PTR $T236460[ebp], 0
	jne	SHORT $LN32@insert

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
	jmp	$LN31@insert
$LN32@insert:

; 675  : 		else if (this->_Multi)

	xor	eax, eax
	je	$LN30@insert

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236470[ebp], edx
	mov	eax, DWORD PTR $T236470[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236483[ebp], ecx
	mov	edx, DWORD PTR $T236483[ebp]
	mov	DWORD PTR $T236447[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T236447[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN29@insert

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236503[ebp], eax
	mov	ecx, DWORD PTR $T236503[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN28@insert

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN28@insert:

; 682  : 				}

	jmp	$LN27@insert
$LN29@insert:

; 683  : 			else if (_Where == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236536[ebp], ecx
	mov	edx, DWORD PTR $T236536[ebp]
	mov	DWORD PTR $T236448[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T236448[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN151@insert

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	mov	DWORD PTR $T236554[ebp], ecx
	mov	edx, DWORD PTR $T236554[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T236568[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T236568[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN25@insert

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN25@insert:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

$LN151@insert:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236593[ebp], edx
	mov	eax, DWORD PTR $T236593[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN23@insert
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T236616[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T236616[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN23@insert

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T236639[ebp], eax
	mov	ecx, DWORD PTR $T236639[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	je	SHORT $LN185@insert

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 696  : 				else

	jmp	SHORT $LN21@insert

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN185@insert:
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN21@insert:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert
$LN23@insert:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236655[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T236655[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN27@insert
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236684[ebp], eax
	mov	ecx, DWORD PTR $T236684[ebp]
	mov	DWORD PTR $T236449[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
	mov	edx, DWORD PTR __Next$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T236449[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@insert
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T236703[ebp], edx
	mov	eax, DWORD PTR $T236703[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@insert
$LN18@insert:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236723[ebp], edx
	mov	eax, DWORD PTR $T236723[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN229@insert

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 707  : 				else

	jmp	SHORT $LN27@insert

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN229@insert:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN27@insert:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert
$LN30@insert:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236741[ebp], ecx
	mov	edx, DWORD PTR $T236741[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T236754[ebp], eax
	mov	ecx, DWORD PTR $T236754[ebp]
	mov	DWORD PTR $T236450[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T236450[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236771[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T236771[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@insert

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN13@insert:

; 718  : 				}

	jmp	$LN31@insert
$LN14@insert:

; 719  : 			else if (_Where == end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236803[ebp], eax
	mov	ecx, DWORD PTR $T236803[ebp]
	mov	DWORD PTR $T236451[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T236451[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	mov	DWORD PTR $T236824[ebp], eax
	mov	ecx, DWORD PTR $T236824[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T236838[ebp], edx
	mov	eax, DWORD PTR $T236838[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN10@insert:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert
$LN11@insert:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236853[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T236853[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN319@insert
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T236882[ebp], edx
	mov	eax, DWORD PTR $T236882[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN319@insert

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T236902[ebp], edx
	mov	eax, DWORD PTR $T236902[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN317@insert

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 732  : 				else

	jmp	SHORT $LN6@insert

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN317@insert:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN6@insert:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

$LN319@insert:
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236921[ebp], eax
	mov	ecx, DWORD PTR $T236921[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN31@insert
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T236947[ebp], edx
	mov	eax, DWORD PTR $T236947[ebp]
	mov	DWORD PTR $T236452[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Next$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T236452[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T236963[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T236963[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@insert
$LN3@insert:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236986[ebp], ecx
	mov	edx, DWORD PTR $T236986[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	je	SHORT $LN361@insert

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert

; 743  : 				else

	jmp	SHORT $LN31@insert

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN361@insert:
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert
$LN31@insert:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T236453[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T237116 = -40						; size = 4
$T237103 = -36						; size = 4
$T237082 = -32						; size = 4
$T237069 = -28						; size = 4
$T237064 = -24						; size = 4
$T237043 = -20						; size = 4
$T237031 = -16						; size = 4
$T237022 = -12						; size = 4
$T237018 = -8						; size = 4
$T237009 = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T237009[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T237018[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T237009[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
	mov	edx, DWORD PTR $T237018[ebp]
	mov	DWORD PTR [edx], eax

; 1064 : 		_Mysize = _Right.size();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T237022[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T237022[ebp]
	mov	DWORD PTR [edx+8], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T237031[ebp], edx
	mov	eax, DWORD PTR $T237031[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	jne	SHORT $LN2@Copy

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T237043[ebp], ecx
	mov	edx, DWORD PTR $T237043[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237064[ebp], eax
$LN31@Copy:
	mov	ecx, DWORD PTR $T237064[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN27@Copy
	mov	ecx, DWORD PTR $T237064[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237064[ebp], edx
	jmp	SHORT $LN31@Copy
$LN27@Copy:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237069[ebp], ecx
	mov	edx, DWORD PTR $T237069[ebp]
	mov	eax, DWORD PTR $T237064[ebp]
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T237082[ebp], edx
	mov	eax, DWORD PTR $T237082[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237103[ebp], ecx
$LN49@Copy:
	mov	edx, DWORD PTR $T237103[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	jne	SHORT $LN53@Copy
	mov	edx, DWORD PTR $T237103[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T237103[ebp], eax
	jmp	SHORT $LN49@Copy
$LN53@Copy:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T237103[ebp]
	mov	DWORD PTR [edx+8], eax

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237116[ebp], edx
	mov	eax, DWORD PTR $T237116[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN3@Copy:

; 1072 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z$3
__ehfuncinfo$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T237441 = -108						; size = 4
$T237424 = -104						; size = 4
__Pnode$221780 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$221780[ebp], eax
	jmp	SHORT $LN6@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$221780[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase:
	mov	edx, DWORD PTR __Pnode$221780[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$221780[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$221780[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$221780[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T237441[ebp], edx
	mov	eax, DWORD PTR $T237441[ebp]
	add	eax, 4
	mov	DWORD PTR $T237424[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T237424[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN12@Erase
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Erase:

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z$3:
	mov	ecx, DWORD PTR $T237424[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T237555 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+29], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237555[ebp], eax
	mov	ecx, DWORD PTR $T237555[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T237810 = -88						; size = 4
$T237776 = -84						; size = 4
$T237609 = -32						; size = 4
$T237596 = -28						; size = 4
$T237584 = -24						; size = 4
$T237574 = -20						; size = 4
$T237573 = -16						; size = 4
$T237572 = -12						; size = 4
$T237571 = -8						; size = 4
$T237570 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237584[ebp], ecx
	mov	edx, DWORD PTR $T237584[ebp]
	mov	DWORD PTR $T237571[ebp], edx
	mov	eax, DWORD PTR $T237571[ebp]
	mov	DWORD PTR $T237570[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237596[ebp], edx
	mov	eax, DWORD PTR $T237596[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237609[ebp], ecx
	mov	edx, DWORD PTR $T237609[ebp]
	mov	DWORD PTR $T237573[ebp], edx
	mov	eax, DWORD PTR $T237573[ebp]
	mov	DWORD PTR $T237572[ebp], eax
	mov	ecx, DWORD PTR $T237570[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237572[ebp]
	push	edx
	lea	eax, DWORD PTR $T237574[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237776[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237810[ebp], ecx
	mov	edx, DWORD PTR $T237810[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvBuildingEntry * *,CvBuildingEntry * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T237903 = -52						; size = 4
$T237892 = -48						; size = 4
$T237891 = -44						; size = 4
__Cat$237899 = -40					; size = 1
$T237896 = -39						; size = 1
__Ptr$221815 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvBuildingEntry * *,CvBuildingEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$221815[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237903[ebp], edx
	mov	eax, DWORD PTR $T237903[ebp]
	mov	DWORD PTR $T237892[ebp], eax
	mov	ecx, DWORD PTR __Ptr$221815[ebp]
	mov	DWORD PTR $T237891[ebp], ecx
	mov	dl, BYTE PTR __Cat$237899[ebp]
	mov	BYTE PTR $T237896[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$221815[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@2@0@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z ; std::_Allocate<CvBuildingEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$237921 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$237921[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$237921[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$237921[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z ; std::_Allocate<CvBuildingEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T237984 = -28						; size = 4
$T237983 = -24						; size = 4
$T237979 = -20						; size = 4
$T237978 = -16						; size = 4
$T237967 = -12						; size = 4
$T237966 = -8						; size = 4
__Cat$237974 = -2					; size = 1
$T237971 = -1						; size = 1
?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237979[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237978[ebp], ecx
	mov	edx, DWORD PTR $T237979[ebp]
	mov	DWORD PTR $T237967[ebp], edx
	mov	eax, DWORD PTR $T237978[ebp]
	mov	DWORD PTR $T237966[ebp], eax
	mov	cl, BYTE PTR __Cat$237974[ebp]
	mov	BYTE PTR $T237971[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T237984[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237983[ebp], eax
	mov	ecx, DWORD PTR $T237983[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T238126 = -64						; size = 4
$T238108 = -60						; size = 4
$T238107 = -56						; size = 4
$T238091 = -52						; size = 4
__Cat$238115 = -46					; size = 1
$T238112 = -45						; size = 1
$T238065 = -44						; size = 4
$T238064 = -40						; size = 4
$T238063 = -36						; size = 4
$T238046 = -30						; size = 1
$T238045 = -29						; size = 1
$T238044 = -28						; size = 4
$T238043 = -24						; size = 4
__Cat$238054 = -16					; size = 1
$T238051 = -15						; size = 1
$T238050 = -14						; size = 1
$T238049 = -13						; size = 1
__Ptr$221856 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238065[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238064[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T238063[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T238049[ebp], cl
	mov	dl, BYTE PTR __Cat$238054[ebp]
	mov	BYTE PTR $T238050[ebp], dl
	mov	al, BYTE PTR $T238049[ebp]
	mov	BYTE PTR $T238046[ebp], al
	mov	cl, BYTE PTR $T238051[ebp]
	mov	BYTE PTR $T238045[ebp], cl
	mov	edx, DWORD PTR $T238065[ebp]
	mov	DWORD PTR $T238044[ebp], edx
	mov	eax, DWORD PTR $T238063[ebp]
	mov	DWORD PTR $T238043[ebp], eax
	jmp	SHORT $LN28@erase@4
$LN27@erase@4:
	mov	ecx, DWORD PTR $T238044[ebp]
	add	ecx, 4
	mov	DWORD PTR $T238044[ebp], ecx
	mov	edx, DWORD PTR $T238043[ebp]
	add	edx, 4
	mov	DWORD PTR $T238043[ebp], edx
$LN28@erase@4:
	mov	eax, DWORD PTR $T238043[ebp]
	cmp	eax, DWORD PTR $T238064[ebp]
	je	SHORT $LN20@erase@4
	mov	ecx, DWORD PTR $T238044[ebp]
	mov	edx, DWORD PTR $T238043[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN27@erase@4
$LN20@erase@4:
	mov	ecx, DWORD PTR $T238044[ebp]
	mov	DWORD PTR __Ptr$221856[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T238126[ebp], eax
	mov	ecx, DWORD PTR $T238126[ebp]
	mov	DWORD PTR $T238108[ebp], ecx
	mov	edx, DWORD PTR __Ptr$221856[ebp]
	mov	DWORD PTR $T238107[ebp], edx
	mov	al, BYTE PTR __Cat$238115[ebp]
	mov	BYTE PTR $T238112[ebp], al
	mov	ecx, DWORD PTR $T238107[ebp]
	mov	DWORD PTR $T238091[ebp], ecx
	jmp	SHORT $LN39@erase@4
$LN38@erase@4:
	mov	edx, DWORD PTR $T238091[ebp]
	add	edx, 4
	mov	DWORD PTR $T238091[ebp], edx
$LN39@erase@4:
	mov	eax, DWORD PTR $T238091[ebp]
	cmp	eax, DWORD PTR $T238108[ebp]
	je	SHORT $LN31@erase@4
	jmp	SHORT $LN38@erase@4
$LN31@erase@4:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$221856[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@0@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
PUBLIC	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$238144 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$238144[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$238144[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$238144[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T238237 = -32						; size = 4
$T238236 = -28						; size = 4
$T238232 = -24						; size = 4
$T238231 = -20						; size = 4
$T238213 = -16						; size = 4
$T238212 = -12						; size = 4
$T238196 = -8						; size = 4
__Cat$238221 = -2					; size = 1
$T238218 = -1						; size = 1
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238232[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238231[ebp], ecx
	mov	edx, DWORD PTR $T238232[ebp]
	mov	DWORD PTR $T238213[ebp], edx
	mov	eax, DWORD PTR $T238231[ebp]
	mov	DWORD PTR $T238212[ebp], eax
	mov	cl, BYTE PTR __Cat$238221[ebp]
	mov	BYTE PTR $T238218[ebp], cl
	mov	edx, DWORD PTR $T238212[ebp]
	mov	DWORD PTR $T238196[ebp], edx
	jmp	SHORT $LN12@Tidy@2
$LN11@Tidy@2:
	mov	eax, DWORD PTR $T238196[ebp]
	add	eax, 4
	mov	DWORD PTR $T238196[ebp], eax
$LN12@Tidy@2:
	mov	ecx, DWORD PTR $T238196[ebp]
	cmp	ecx, DWORD PTR $T238213[ebp]
	je	SHORT $LN4@Tidy@2
	jmp	SHORT $LN11@Tidy@2
$LN4@Tidy@2:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T238237[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238236[ebp], eax
	mov	ecx, DWORD PTR $T238236[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$238292 = -24					; size = 4
$T238275 = -20						; size = 4
$T238256 = -16						; size = 4
$T238243 = -12						; size = 4
$T238240 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238256[ebp], eax
	mov	ecx, DWORD PTR $T238256[ebp]
	mov	DWORD PTR $T238240[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T238240[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238275[ebp], eax
	mov	ecx, DWORD PTR $T238275[ebp]
	mov	DWORD PTR $T238243[ebp], ecx
	mov	edx, DWORD PTR $T238243[ebp]
	mov	DWORD PTR __Tmp$238292[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Tmp$238292[ebp]
	mov	DWORD PTR __Tmp$238292[ebp], eax
	mov	ecx, DWORD PTR __Tmp$238292[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@ABUBuildingYieldChange@@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T238439 = -64						; size = 4
$T238421 = -60						; size = 4
$T238420 = -56						; size = 4
$T238404 = -52						; size = 4
__Cat$238428 = -46					; size = 1
$T238426 = -45						; size = 1
$T238378 = -44						; size = 4
$T238377 = -40						; size = 4
$T238376 = -36						; size = 4
$T238359 = -30						; size = 1
$T238358 = -29						; size = 1
$T238357 = -28						; size = 4
$T238356 = -24						; size = 4
__Cat$238367 = -16					; size = 1
$T238364 = -15						; size = 1
$T238363 = -14						; size = 1
$T238362 = -13						; size = 1
__Ptr$221905 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238378[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238377[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T238376[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T238362[ebp], cl
	mov	dl, BYTE PTR __Cat$238367[ebp]
	mov	BYTE PTR $T238363[ebp], dl
	mov	al, BYTE PTR $T238362[ebp]
	mov	BYTE PTR $T238359[ebp], al
	mov	cl, BYTE PTR $T238364[ebp]
	mov	BYTE PTR $T238358[ebp], cl
	mov	edx, DWORD PTR $T238378[ebp]
	mov	DWORD PTR $T238357[ebp], edx
	mov	eax, DWORD PTR $T238376[ebp]
	mov	DWORD PTR $T238356[ebp], eax
	jmp	SHORT $LN28@erase@5
$LN27@erase@5:
	mov	ecx, DWORD PTR $T238357[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T238357[ebp], ecx
	mov	edx, DWORD PTR $T238356[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T238356[ebp], edx
$LN28@erase@5:
	mov	eax, DWORD PTR $T238356[ebp]
	cmp	eax, DWORD PTR $T238377[ebp]
	je	SHORT $LN20@erase@5
	mov	ecx, DWORD PTR $T238356[ebp]
	mov	edx, DWORD PTR $T238357[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN27@erase@5
$LN20@erase@5:
	mov	edx, DWORD PTR $T238357[ebp]
	mov	DWORD PTR __Ptr$221905[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238439[ebp], ecx
	mov	edx, DWORD PTR $T238439[ebp]
	mov	DWORD PTR $T238421[ebp], edx
	mov	eax, DWORD PTR __Ptr$221905[ebp]
	mov	DWORD PTR $T238420[ebp], eax
	mov	cl, BYTE PTR __Cat$238428[ebp]
	mov	BYTE PTR $T238426[ebp], cl
	mov	edx, DWORD PTR $T238420[ebp]
	mov	DWORD PTR $T238404[ebp], edx
	jmp	SHORT $LN39@erase@5
$LN38@erase@5:
	mov	eax, DWORD PTR $T238404[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T238404[ebp], eax
$LN39@erase@5:
	mov	ecx, DWORD PTR $T238404[ebp]
	cmp	ecx, DWORD PTR $T238421[ebp]
	je	SHORT $LN31@erase@5
	jmp	SHORT $LN38@erase@5
$LN31@erase@5:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$221905[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ; std::_Allocate<BuildingYieldChange>
PUBLIC	?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$238454 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$238454[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$238454[ebp], 0
	jbe	SHORT $LN11@Buy@3
	mov	eax, DWORD PTR __Count$238454[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@3
$LN11@Buy@3:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@3:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ; std::_Allocate<BuildingYieldChange>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T238550 = -32						; size = 4
$T238549 = -28						; size = 4
$T238545 = -24						; size = 4
$T238544 = -20						; size = 4
$T238526 = -16						; size = 4
$T238525 = -12						; size = 4
$T238509 = -8						; size = 4
__Cat$238533 = -2					; size = 1
$T238531 = -1						; size = 1
?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238545[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238544[ebp], ecx
	mov	edx, DWORD PTR $T238545[ebp]
	mov	DWORD PTR $T238526[ebp], edx
	mov	eax, DWORD PTR $T238544[ebp]
	mov	DWORD PTR $T238525[ebp], eax
	mov	cl, BYTE PTR __Cat$238533[ebp]
	mov	BYTE PTR $T238531[ebp], cl
	mov	edx, DWORD PTR $T238525[ebp]
	mov	DWORD PTR $T238509[ebp], edx
	jmp	SHORT $LN12@Tidy@3
$LN11@Tidy@3:
	mov	eax, DWORD PTR $T238509[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T238509[ebp], eax
$LN12@Tidy@3:
	mov	ecx, DWORD PTR $T238509[ebp]
	cmp	ecx, DWORD PTR $T238526[ebp]
	je	SHORT $LN4@Tidy@3
	jmp	SHORT $LN11@Tidy@3
$LN4@Tidy@3:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T238550[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238549[ebp], eax
	mov	ecx, DWORD PTR $T238549[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$238610 = -24					; size = 4
$T238588 = -20						; size = 4
$T238569 = -16						; size = 4
$T238556 = -12						; size = 4
$T238553 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238569[ebp], eax
	mov	ecx, DWORD PTR $T238569[ebp]
	mov	DWORD PTR $T238553[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T238553[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238588[ebp], eax
	mov	ecx, DWORD PTR $T238588[ebp]
	mov	DWORD PTR $T238556[ebp], ecx
	mov	edx, DWORD PTR $T238556[ebp]
	mov	DWORD PTR __Tmp$238610[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Tmp$238610[ebp]
	mov	DWORD PTR __Tmp$238610[ebp], eax
	mov	ecx, DWORD PTR __Tmp$238610[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@ABUBuildingGreatWork@@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T238752 = -64						; size = 4
$T238734 = -60						; size = 4
$T238733 = -56						; size = 4
$T238717 = -52						; size = 4
__Cat$238740 = -46					; size = 1
$T238737 = -45						; size = 1
$T238691 = -44						; size = 4
$T238690 = -40						; size = 4
$T238689 = -36						; size = 4
$T238672 = -30						; size = 1
$T238671 = -29						; size = 1
$T238670 = -28						; size = 4
$T238669 = -24						; size = 4
__Cat$238679 = -16					; size = 1
$T238676 = -15						; size = 1
$T238675 = -14						; size = 1
$T238674 = -13						; size = 1
__Ptr$221965 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T238691[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238690[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T238689[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T238674[ebp], cl
	mov	dl, BYTE PTR __Cat$238679[ebp]
	mov	BYTE PTR $T238675[ebp], dl
	mov	al, BYTE PTR $T238674[ebp]
	mov	BYTE PTR $T238672[ebp], al
	mov	cl, BYTE PTR $T238676[ebp]
	mov	BYTE PTR $T238671[ebp], cl
	mov	edx, DWORD PTR $T238691[ebp]
	mov	DWORD PTR $T238670[ebp], edx
	mov	eax, DWORD PTR $T238689[ebp]
	mov	DWORD PTR $T238669[ebp], eax
	jmp	SHORT $LN28@erase@6
$LN27@erase@6:
	mov	ecx, DWORD PTR $T238670[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T238670[ebp], ecx
	mov	edx, DWORD PTR $T238669[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T238669[ebp], edx
$LN28@erase@6:
	mov	eax, DWORD PTR $T238669[ebp]
	cmp	eax, DWORD PTR $T238690[ebp]
	je	SHORT $LN20@erase@6
	mov	ecx, DWORD PTR $T238669[ebp]
	mov	edx, DWORD PTR $T238670[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN27@erase@6
$LN20@erase@6:
	mov	edx, DWORD PTR $T238670[ebp]
	mov	DWORD PTR __Ptr$221965[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238752[ebp], ecx
	mov	edx, DWORD PTR $T238752[ebp]
	mov	DWORD PTR $T238734[ebp], edx
	mov	eax, DWORD PTR __Ptr$221965[ebp]
	mov	DWORD PTR $T238733[ebp], eax
	mov	cl, BYTE PTR __Cat$238740[ebp]
	mov	BYTE PTR $T238737[ebp], cl
	mov	edx, DWORD PTR $T238733[ebp]
	mov	DWORD PTR $T238717[ebp], edx
	jmp	SHORT $LN39@erase@6
$LN38@erase@6:
	mov	eax, DWORD PTR $T238717[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T238717[ebp], eax
$LN39@erase@6:
	mov	ecx, DWORD PTR $T238717[ebp]
	cmp	ecx, DWORD PTR $T238734[ebp]
	je	SHORT $LN31@erase@6
	jmp	SHORT $LN38@erase@6
$LN31@erase@6:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$221965[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase@6:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ; std::_Allocate<BuildingGreatWork>
PUBLIC	?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$238769 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$238769[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$238769[ebp], 0
	jbe	SHORT $LN11@Buy@4
	mov	eax, DWORD PTR __Count$238769[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@4
$LN11@Buy@4:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@4:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@4:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ; std::_Allocate<BuildingGreatWork>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T238863 = -32						; size = 4
$T238862 = -28						; size = 4
$T238858 = -24						; size = 4
$T238857 = -20						; size = 4
$T238839 = -16						; size = 4
$T238838 = -12						; size = 4
$T238822 = -8						; size = 4
__Cat$238845 = -2					; size = 1
$T238842 = -1						; size = 1
?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238858[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238857[ebp], ecx
	mov	edx, DWORD PTR $T238858[ebp]
	mov	DWORD PTR $T238839[ebp], edx
	mov	eax, DWORD PTR $T238857[ebp]
	mov	DWORD PTR $T238838[ebp], eax
	mov	cl, BYTE PTR __Cat$238845[ebp]
	mov	BYTE PTR $T238842[ebp], cl
	mov	edx, DWORD PTR $T238838[ebp]
	mov	DWORD PTR $T238822[ebp], edx
	jmp	SHORT $LN12@Tidy@4
$LN11@Tidy@4:
	mov	eax, DWORD PTR $T238822[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T238822[ebp], eax
$LN12@Tidy@4:
	mov	ecx, DWORD PTR $T238822[ebp]
	cmp	ecx, DWORD PTR $T238839[ebp]
	je	SHORT $LN4@Tidy@4
	jmp	SHORT $LN11@Tidy@4
$LN4@Tidy@4:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T238863[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238862[ebp], eax
	mov	ecx, DWORD PTR $T238862[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T238867 = -2						; size = 1
$T238866 = -1						; size = 1
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T238866[ebp]
	push	eax
	lea	ecx, DWORD PTR $T238867[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >

; 104  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T239524 = -372						; size = 4
$T239501 = -368						; size = 4
$T239485 = -364						; size = 4
$T239459 = -360						; size = 4
$T239440 = -356						; size = 4
$T239420 = -352						; size = 4
$T239391 = -348						; size = 4
$T239376 = -344						; size = 4
$T239362 = -340						; size = 4
$T239341 = -336						; size = 4
$T239309 = -332						; size = 4
$T239292 = -328						; size = 4
$T239279 = -324						; size = 4
$T239261 = -320						; size = 4
$T239241 = -316						; size = 4
$T239222 = -312						; size = 4
$T239193 = -308						; size = 4
$T239177 = -304						; size = 4
$T239154 = -300						; size = 4
$T239131 = -296						; size = 4
$T239106 = -216						; size = 4
$T239092 = -212						; size = 4
$T239074 = -208						; size = 4
$T239041 = -128						; size = 4
$T239021 = -124						; size = 4
$T239008 = -120						; size = 4
$T238998 = -40						; size = 4
$T238991 = -36						; size = 8
$T238990 = -28						; size = 4
$T238989 = -24						; size = 4
$T238988 = -20						; size = 4
$T238987 = -16						; size = 4
$T238986 = -12						; size = 4
$T238985 = -8						; size = 4
__Next$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	mov	DWORD PTR __Next$[ebp], 0

; 672  : 
; 673  : 		if (size() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238998[ebp], ecx
	cmp	DWORD PTR $T238998[ebp], 0
	jne	SHORT $LN32@insert@4

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
	jmp	$LN31@insert@4
$LN32@insert@4:

; 675  : 		else if (this->_Multi)

	xor	eax, eax
	je	$LN30@insert@4

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239008[ebp], edx
	mov	eax, DWORD PTR $T239008[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T239021[ebp], ecx
	mov	edx, DWORD PTR $T239021[ebp]
	mov	DWORD PTR $T238985[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T238985[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN29@insert@4

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239041[ebp], eax
	mov	ecx, DWORD PTR $T239041[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN28@insert@4

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN28@insert@4:

; 682  : 				}

	jmp	$LN27@insert@4
$LN29@insert@4:

; 683  : 			else if (_Where == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239074[ebp], ecx
	mov	edx, DWORD PTR $T239074[ebp]
	mov	DWORD PTR $T238986[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T238986[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN151@insert@4

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	mov	DWORD PTR $T239092[ebp], ecx
	mov	edx, DWORD PTR $T239092[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T239106[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T239106[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN25@insert@4

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN25@insert@4:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@4

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

$LN151@insert@4:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239131[ebp], edx
	mov	eax, DWORD PTR $T239131[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN23@insert@4
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T239154[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T239154[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN23@insert@4

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T239177[ebp], eax
	mov	ecx, DWORD PTR $T239177[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN185@insert@4

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4

; 696  : 				else

	jmp	SHORT $LN21@insert@4

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN185@insert@4:
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN21@insert@4:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@4
$LN23@insert@4:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239193[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T239193[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN27@insert@4
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239222[ebp], eax
	mov	ecx, DWORD PTR $T239222[ebp]
	mov	DWORD PTR $T238987[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	edx, DWORD PTR __Next$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T238987[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@insert@4
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T239241[ebp], edx
	mov	eax, DWORD PTR $T239241[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@insert@4
$LN18@insert@4:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239261[ebp], edx
	mov	eax, DWORD PTR $T239261[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN229@insert@4

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4

; 707  : 				else

	jmp	SHORT $LN27@insert@4

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN229@insert@4:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN27@insert@4:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert@4
$LN30@insert@4:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239279[ebp], ecx
	mov	edx, DWORD PTR $T239279[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239292[ebp], eax
	mov	ecx, DWORD PTR $T239292[ebp]
	mov	DWORD PTR $T238988[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T238988[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert@4

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239309[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T239309[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@insert@4

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN13@insert@4:

; 718  : 				}

	jmp	$LN31@insert@4
$LN14@insert@4:

; 719  : 			else if (_Where == end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239341[ebp], eax
	mov	ecx, DWORD PTR $T239341[ebp]
	mov	DWORD PTR $T238989[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T238989[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert@4

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	mov	DWORD PTR $T239362[ebp], eax
	mov	ecx, DWORD PTR $T239362[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T239376[ebp], edx
	mov	eax, DWORD PTR $T239376[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert@4

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN10@insert@4:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@4
$LN11@insert@4:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239391[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T239391[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN319@insert@4
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T239420[ebp], edx
	mov	eax, DWORD PTR $T239420[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN319@insert@4

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T239440[ebp], edx
	mov	eax, DWORD PTR $T239440[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN317@insert@4

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4

; 732  : 				else

	jmp	SHORT $LN6@insert@4

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN317@insert@4:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN6@insert@4:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@4

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

$LN319@insert@4:
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239459[ebp], eax
	mov	ecx, DWORD PTR $T239459[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN31@insert@4
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239485[ebp], edx
	mov	eax, DWORD PTR $T239485[ebp]
	mov	DWORD PTR $T238990[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Next$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T238990[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@insert@4
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T239501[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T239501[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@insert@4
$LN3@insert@4:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T239524[ebp], ecx
	mov	edx, DWORD PTR $T239524[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN361@insert@4

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@4

; 743  : 				else

	jmp	SHORT $LN31@insert@4

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN361@insert@4:
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@4
$LN31@insert@4:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T238991[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert@4:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T239701 = -148						; size = 4
$T239681 = -144						; size = 4
$T239666 = -140						; size = 4
$T239649 = -136						; size = 4
$T239636 = -132						; size = 4
$T239622 = -128						; size = 4
$T239578 = -45						; size = 1
$T239577 = -44						; size = 4
$T239576 = -37						; size = 1
$T239575 = -36						; size = 4
$T239574 = -29						; size = 1
$T239573 = -28						; size = 4
$T239572 = -24						; size = 4
$T239571 = -17						; size = 1
__Where$222228 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@5:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN9@insert@5

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@5
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@5
$LN33@insert@5:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@5:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@5
$LN9@insert@5:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@5

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T239571[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239572[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	DWORD PTR $T239622[ebp], eax
	mov	edx, DWORD PTR $T239622[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T239571[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@5

; 644  : 		else

	jmp	$LN11@insert@5
$LN8@insert@5:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$222228[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@5
	jmp	$LN79@insert@5
$LN6@insert@5:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239636[ebp], ecx
	mov	edx, DWORD PTR $T239636[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239649[ebp], eax
	mov	ecx, DWORD PTR $T239649[ebp]
	mov	DWORD PTR $T239573[ebp], ecx
	mov	edx, DWORD PTR __Where$222228[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T239573[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@5

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T239574[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T239575[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	DWORD PTR $T239666[ebp], eax
	mov	edx, DWORD PTR $T239666[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T239574[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@5

; 651  : 			else

	jmp	SHORT $LN79@insert@5
$LN4@insert@5:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$222228[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@5:
	mov	ecx, DWORD PTR __Where$222228[ebp]
	mov	DWORD PTR $T239681[ebp], ecx
	mov	edx, DWORD PTR $T239681[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@5

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T239576[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239577[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
	mov	DWORD PTR $T239701[ebp], eax
	mov	edx, DWORD PTR $T239701[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T239576[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@5

; 657  : 			else

	jmp	SHORT $LN11@insert@5
$LN2@insert@5:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T239578[ebp], 0
	mov	ecx, DWORD PTR __Where$222228[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T239578[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@5:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T240098 = -80						; size = 4
$T240092 = -76						; size = 4
__Tmp$240080 = -56					; size = 4
$T240008 = -52						; size = 4
$T239995 = -48						; size = 4
$T239752 = -28						; size = 4
$T239729 = -24						; size = 4
$T239716 = -20						; size = 4
$T239710 = -16						; size = 4
$T239709 = -12						; size = 4
$T239708 = -8						; size = 4
$T239707 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239716[ebp], ecx
	mov	edx, DWORD PTR $T239716[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239729[ebp], eax
	mov	ecx, DWORD PTR $T239729[ebp]
	mov	DWORD PTR $T239707[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T239707[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN101@erase@7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239752[ebp], eax
	mov	ecx, DWORD PTR $T239752[ebp]
	mov	DWORD PTR $T239708[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T239708[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN101@erase@7

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239995[ebp], eax
	mov	ecx, DWORD PTR $T239995[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T240008[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T240008[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@7

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@7

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN101@erase@7:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@7

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$240080[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$240080[ebp]
	mov	DWORD PTR $T239709[ebp], ecx
	mov	edx, DWORD PTR $T239709[ebp]
	push	edx
	lea	eax, DWORD PTR $T239710[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
	jmp	SHORT $LN101@erase@7
$LN1@erase@7:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240098[ebp], ecx
	mov	edx, DWORD PTR $T240098[ebp]
	mov	DWORD PTR $T240092[ebp], edx
	mov	eax, DWORD PTR $T240092[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@7:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$10
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
tv167 = -88						; size = 4
tv153 = -84						; size = 4
_this$ = -80						; size = 4
__Pnode$222263 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	$LN3@Copy@2

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	movzx	edx, BYTE PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	DWORD PTR __Pnode$222263[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	je	SHORT $LN2@Copy@2

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$222263[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@2:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$222263[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
	mov	DWORD PTR tv153[ebp], eax
	mov	eax, DWORD PTR __Pnode$222263[ebp]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR [eax], ecx

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	edx, DWORD PTR __Pnode$222263[ebp]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
	mov	DWORD PTR tv167[ebp], eax
	mov	edx, DWORD PTR __Pnode$222263[ebp]
	mov	eax, DWORD PTR tv167[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN6@Copy@2
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	ecx, DWORD PTR __Newroot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@2
	ret	0
$LN6@Copy@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@2:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@2:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Copy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T240957 = -188						; size = 4
$T240869 = -172						; size = 4
$T240784 = -160						; size = 4
$T240768 = -156						; size = 4
$T240749 = -152						; size = 4
$T240745 = -148						; size = 4
$T240660 = -136						; size = 4
$T240559 = -120						; size = 4
$T240537 = -116						; size = 4
$T240530 = -112						; size = 4
$T240526 = -108						; size = 4
$T240487 = -104						; size = 4
$T240478 = -100						; size = 4
$T240458 = -96						; size = 4
__Count$240438 = -92					; size = 4
$T240424 = -88						; size = 28
$T240423 = -60						; size = 40
__Pnode$222280 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$240438[ebp], 268435455 ; 0fffffffH
	cmp	DWORD PTR __Count$240438[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$240438[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T240424[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T240424[ebp]
	push	eax
	lea	ecx, DWORD PTR $T240423[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T240423[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T240423[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T240424[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240458[ebp], edx
	mov	eax, DWORD PTR $T240458[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240478[ebp], eax
	mov	ecx, DWORD PTR $T240478[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240487[ebp], ecx
	mov	edx, DWORD PTR $T240487[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$222280[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+28]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T240526[ebp], edx
	mov	eax, DWORD PTR $T240526[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240530[ebp], ecx
	mov	edx, DWORD PTR __Pnode$222280[ebp]
	mov	eax, DWORD PTR $T240530[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$222280[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T240537[ebp], eax
	mov	ecx, DWORD PTR $T240537[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+28]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$222280[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+28], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+28], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$222280[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T240559[ebp], ecx
	mov	edx, DWORD PTR $T240559[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+28], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222280[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$222280[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$222280[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$222280[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+28], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$222280[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T240660[ebp], ecx
	mov	edx, DWORD PTR $T240660[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+28], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T240745[ebp], edx
	mov	eax, DWORD PTR $T240745[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240749[ebp], ecx
	mov	edx, DWORD PTR $T240749[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+28]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$222280[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+28], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+28], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$222280[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T240768[ebp], ecx
	mov	edx, DWORD PTR $T240768[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+28], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222280[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240784[ebp], edx
	mov	eax, DWORD PTR $T240784[ebp]
	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$222280[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222280[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$222280[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+28], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$222280[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T240869[ebp], edx
	mov	eax, DWORD PTR $T240869[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+28], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$222280[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T240957[ebp], eax
	mov	ecx, DWORD PTR $T240957[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+28], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T240424[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Insert
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN3@Lbound@2

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound@2

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound@2:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound@2
$LN3@Lbound@2:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T241141 = -80						; size = 4
__Vptr$241147 = -76					; size = 4
$T241112 = -72						; size = 4
__Vptr$241118 = -68					; size = 4
$T241083 = -64						; size = 4
__Vptr$241089 = -60					; size = 4
$T241046 = -36						; size = 4
$T241045 = -32						; size = 4
$T241044 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T241044[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$241089[ebp], eax
	mov	ecx, DWORD PTR __Vptr$241089[ebp]
	mov	DWORD PTR $T241083[ebp], ecx
	cmp	DWORD PTR $T241083[ebp], 0
	je	SHORT $LN23@Buynode
	mov	edx, DWORD PTR $T241083[ebp]
	mov	eax, DWORD PTR $T241044[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T241083[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode
$LN23@Buynode:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T241045[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$241118[ebp], eax
	mov	ecx, DWORD PTR __Vptr$241118[ebp]
	mov	DWORD PTR $T241112[ebp], ecx
	cmp	DWORD PTR $T241112[ebp], 0
	je	SHORT $LN33@Buynode
	mov	edx, DWORD PTR $T241112[ebp]
	mov	eax, DWORD PTR $T241045[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T241112[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode
$LN33@Buynode:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T241046[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$241147[ebp], eax
	mov	ecx, DWORD PTR __Vptr$241147[ebp]
	mov	DWORD PTR $T241141[ebp], ecx
	cmp	DWORD PTR $T241141[ebp], 0
	je	SHORT $LN43@Buynode
	mov	edx, DWORD PTR $T241141[ebp]
	mov	eax, DWORD PTR $T241046[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T241141[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode
$LN43@Buynode:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode:
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+28], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+29], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T241192 = -80						; size = 28
$T241191 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T241192[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T241191[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T241191[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T241192[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241191[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T241191[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T241191[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T241192[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T241192[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T241191[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvBuildingEntry@@V?$allocator@PAVCvBuildingEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvBuildingEntry *,std::allocator<CvBuildingEntry *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T241214 = -80						; size = 28
$T241213 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T241214[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T241213[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T241213[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T241214[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241213[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T241213[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T241213[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T241214[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T241214[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T241213[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
PUBLIC	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
PUBLIC	??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$2
__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$0
__unwindtable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
_TEXT	SEGMENT
tv84 = -440						; size = 4
tv304 = -436						; size = 4
tv290 = -432						; size = 4
tv282 = -428						; size = 4
_this$ = -424						; size = 4
$T241916 = -420						; size = 4
$T241908 = -416						; size = 4
$T241907 = -412						; size = 4
$T241884 = -406						; size = 1
$T241883 = -405						; size = 1
$T241882 = -404						; size = 4
$T241881 = -400						; size = 4
$T241869 = -393						; size = 1
$T241868 = -392						; size = 4
$T241867 = -388						; size = 4
$T241866 = -384						; size = 4
__Cat$241900 = -380					; size = 1
$T241897 = -379						; size = 1
$T241896 = -378						; size = 1
__Cat$241891 = -376					; size = 1
$T241888 = -375						; size = 1
$T241887 = -374						; size = 1
$T241886 = -373						; size = 1
$T241841 = -372						; size = 4
$T241822 = -368						; size = 4
$T241805 = -361						; size = 1
$T241804 = -360						; size = 4
$T241794 = -356						; size = 4
$T241793 = -352						; size = 4
__Cat$241838 = -346					; size = 1
$T241835 = -345						; size = 1
$T241834 = -344						; size = 1
__Cat$241829 = -343					; size = 1
$T241826 = -342						; size = 1
$T241825 = -341						; size = 1
$T241769 = -340						; size = 4
$T241761 = -336						; size = 4
$T241753 = -332						; size = 4
$T241735 = -328						; size = 4
$T241734 = -324						; size = 4
$T241718 = -320						; size = 4
__Cat$241741 = -314					; size = 1
$T241738 = -313						; size = 1
$T241692 = -312						; size = 4
$T241691 = -308						; size = 4
$T241681 = -304						; size = 4
__Cat$241688 = -299					; size = 1
$T241685 = -298						; size = 1
$T241684 = -297						; size = 1
$T241665 = -296						; size = 4
$T241646 = -292						; size = 4
$T241629 = -285						; size = 1
$T241628 = -284						; size = 4
$T241618 = -280						; size = 4
$T241617 = -276						; size = 4
__Cat$241663 = -270					; size = 1
$T241661 = -269						; size = 1
$T241660 = -268						; size = 1
__Cat$241654 = -267					; size = 1
$T241652 = -266						; size = 1
$T241651 = -265						; size = 1
$T241593 = -264						; size = 4
$T241592 = -260						; size = 4
$T241588 = -256						; size = 4
$T241587 = -252						; size = 4
$T241569 = -248						; size = 4
$T241568 = -244						; size = 4
$T241552 = -240						; size = 4
__Cat$241576 = -234					; size = 1
$T241574 = -233						; size = 1
$T241503 = -232						; size = 4
$T241502 = -228						; size = 4
$T241486 = -224						; size = 4
__Cat$241510 = -218					; size = 1
$T241508 = -217						; size = 1
$T241443 = -216						; size = 4
$T241442 = -212						; size = 4
$T241426 = -208						; size = 4
__Cat$241451 = -202					; size = 1
$T241448 = -201						; size = 1
$T241400 = -200						; size = 4
$T241388 = -196						; size = 4
$T241378 = -189						; size = 1
$T241377 = -188						; size = 4
__Cat$241396 = -183					; size = 1
$T241393 = -182						; size = 1
$T241392 = -181						; size = 1
$T241365 = -180						; size = 4
$T241353 = -176						; size = 4
$T241343 = -169						; size = 1
$T241342 = -168						; size = 4
__Cat$241361 = -163					; size = 1
$T241358 = -162						; size = 1
$T241357 = -161						; size = 1
$T241330 = -160						; size = 4
$T241320 = -156						; size = 4
__Cat$241328 = -151					; size = 1
$T241325 = -150						; size = 1
$T241324 = -149						; size = 1
__Count$241290 = -136					; size = 4
__Count$241264 = -64					; size = 4
__Tmp$222446 = -60					; size = 12
__Oldend$222447 = -48					; size = 4
__Tmp$222436 = -44					; size = 12
__Ncopied$222423 = -32					; size = 4
__Newvec$222421 = -28					; size = 4
__Whereoff$222422 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$241264[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$241264[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	eax, DWORD PTR __Count$241264[ebp]
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR tv290[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$241290[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$241290[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	edx, DWORD PTR __Count$241290[ebp]
	mov	DWORD PTR tv304[ebp], edx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv304[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ; std::_Allocate<BuildingYieldChange>
	add	esp, 8
	mov	DWORD PTR __Newvec$222421[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$222422[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$222423[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$222422[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$222421[ebp]
	mov	DWORD PTR $T241330[ebp], edx
	mov	eax, DWORD PTR $T241330[ebp]
	mov	DWORD PTR $T241320[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241324[ebp], cl
	mov	dl, BYTE PTR __Cat$241328[ebp]
	mov	BYTE PTR $T241325[ebp], dl
	movzx	eax, BYTE PTR $T241324[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T241325[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241320[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$222423[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$222423[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T241365[ebp], edx
	mov	eax, DWORD PTR __Newvec$222421[ebp]
	mov	DWORD PTR $T241353[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241357[ebp], cl
	mov	dl, BYTE PTR __Cat$241361[ebp]
	mov	BYTE PTR $T241358[ebp], dl
	mov	al, BYTE PTR $T241357[ebp]
	mov	BYTE PTR $T241343[ebp], al
	mov	ecx, DWORD PTR $T241353[ebp]
	mov	DWORD PTR $T241342[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T241342[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241365[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$222423[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$222423[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241400[ebp], edx
	mov	eax, DWORD PTR __Whereoff$222422[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$222421[ebp]
	mov	DWORD PTR $T241388[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241392[ebp], cl
	mov	dl, BYTE PTR __Cat$241396[ebp]
	mov	BYTE PTR $T241393[ebp], dl
	mov	al, BYTE PTR $T241392[ebp]
	mov	BYTE PTR $T241378[ebp], al
	mov	ecx, DWORD PTR $T241388[ebp]
	mov	DWORD PTR $T241377[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T241377[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241400[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$222423[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$222422[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$222421[ebp]
	mov	DWORD PTR $T241443[ebp], eax
	mov	ecx, DWORD PTR __Newvec$222421[ebp]
	mov	DWORD PTR $T241442[ebp], ecx
	mov	dl, BYTE PTR __Cat$241451[ebp]
	mov	BYTE PTR $T241448[ebp], dl
	mov	eax, DWORD PTR $T241442[ebp]
	mov	DWORD PTR $T241426[ebp], eax
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	ecx, DWORD PTR $T241426[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T241426[ebp], ecx
$LN91@Insert_n:
	mov	edx, DWORD PTR $T241426[ebp]
	cmp	edx, DWORD PTR $T241443[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$222423[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Whereoff$222422[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$222421[ebp]
	add	ecx, eax
	mov	DWORD PTR $T241503[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$222422[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$222421[ebp]
	mov	DWORD PTR $T241502[ebp], edx
	mov	al, BYTE PTR __Cat$241510[ebp]
	mov	BYTE PTR $T241508[ebp], al
	mov	ecx, DWORD PTR $T241502[ebp]
	mov	DWORD PTR $T241486[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T241486[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T241486[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T241486[ebp]
	cmp	eax, DWORD PTR $T241503[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$222421[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241588[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241587[ebp], eax
	mov	ecx, DWORD PTR $T241588[ebp]
	mov	DWORD PTR $T241569[ebp], ecx
	mov	edx, DWORD PTR $T241587[ebp]
	mov	DWORD PTR $T241568[ebp], edx
	mov	al, BYTE PTR __Cat$241576[ebp]
	mov	BYTE PTR $T241574[ebp], al
	mov	ecx, DWORD PTR $T241568[ebp]
	mov	DWORD PTR $T241552[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T241552[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T241552[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T241552[ebp]
	cmp	eax, DWORD PTR $T241569[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T241593[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241592[ebp], eax
	mov	ecx, DWORD PTR $T241592[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$222421[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$222421[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$222421[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$222436[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$222436[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$222436[ebp+8], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241665[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241646[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241651[ebp], al
	mov	cl, BYTE PTR __Cat$241654[ebp]
	mov	BYTE PTR $T241652[ebp], cl
	mov	dl, BYTE PTR $T241651[ebp]
	mov	BYTE PTR $T241629[ebp], dl
	mov	eax, DWORD PTR $T241646[ebp]
	mov	DWORD PTR $T241628[ebp], eax
	mov	ecx, DWORD PTR $T241628[ebp]
	mov	DWORD PTR $T241618[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241617[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241660[ebp], al
	mov	cl, BYTE PTR __Cat$241663[ebp]
	mov	BYTE PTR $T241661[ebp], cl
	movzx	edx, BYTE PTR $T241660[ebp]
	push	edx
	movzx	eax, BYTE PTR $T241661[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241618[ebp]
	push	edx
	mov	eax, DWORD PTR $T241665[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241617[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T241692[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241691[ebp], ecx
	mov	edx, DWORD PTR $T241691[ebp]
	mov	DWORD PTR $T241681[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241684[ebp], al
	mov	cl, BYTE PTR __Cat$241688[ebp]
	mov	BYTE PTR $T241685[ebp], cl
	movzx	edx, BYTE PTR $T241684[ebp]
	push	edx
	movzx	eax, BYTE PTR $T241685[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$222436[ebp]
	push	edx
	mov	eax, DWORD PTR $T241692[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241681[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241753[ebp], edx
	mov	ecx, DWORD PTR $T241753[ebp]
	mov	DWORD PTR $T241735[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241734[ebp], edx
	mov	al, BYTE PTR __Cat$241741[ebp]
	mov	BYTE PTR $T241738[ebp], al
	mov	ecx, DWORD PTR $T241734[ebp]
	mov	DWORD PTR $T241718[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T241718[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T241718[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T241718[ebp]
	cmp	eax, DWORD PTR $T241735[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T241769[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241761[ebp], ecx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	edx, DWORD PTR $T241761[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T241761[ebp], edx
$LN171@Insert_n:
	mov	eax, DWORD PTR $T241761[ebp]
	cmp	eax, DWORD PTR $T241769[ebp]
	je	SHORT $LN167@Insert_n
	mov	ecx, DWORD PTR $T241761[ebp]
	mov	edx, DWORD PTR __Tmp$222436[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$222436[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$222436[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$222446[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$222446[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$222446[ebp+8], eax

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$222447[ebp], edx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241841[ebp], ecx
	mov	edx, DWORD PTR $T241841[ebp]
	mov	DWORD PTR $T241822[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241825[ebp], al
	mov	cl, BYTE PTR __Cat$241829[ebp]
	mov	BYTE PTR $T241826[ebp], cl
	mov	dl, BYTE PTR $T241825[ebp]
	mov	BYTE PTR $T241805[ebp], dl
	mov	eax, DWORD PTR $T241822[ebp]
	mov	DWORD PTR $T241804[ebp], eax
	mov	ecx, DWORD PTR $T241804[ebp]
	mov	DWORD PTR $T241794[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR __Oldend$222447[ebp]
	sub	eax, edx
	mov	DWORD PTR $T241793[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241834[ebp], cl
	mov	dl, BYTE PTR __Cat$241838[ebp]
	mov	BYTE PTR $T241835[ebp], dl
	movzx	eax, BYTE PTR $T241834[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T241835[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T241794[ebp]
	push	eax
	mov	ecx, DWORD PTR __Oldend$222447[ebp]
	push	ecx
	mov	edx, DWORD PTR $T241793[ebp]
	push	edx
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$222447[ebp]
	mov	DWORD PTR $T241908[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241907[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241886[ebp], cl
	mov	dl, BYTE PTR __Cat$241891[ebp]
	mov	BYTE PTR $T241887[ebp], dl
	mov	al, BYTE PTR $T241886[ebp]
	mov	BYTE PTR $T241884[ebp], al
	mov	cl, BYTE PTR $T241888[ebp]
	mov	BYTE PTR $T241883[ebp], cl
	mov	edx, DWORD PTR $T241908[ebp]
	mov	DWORD PTR $T241882[ebp], edx
	mov	eax, DWORD PTR $T241907[ebp]
	mov	DWORD PTR $T241881[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241896[ebp], cl
	mov	dl, BYTE PTR __Cat$241900[ebp]
	mov	BYTE PTR $T241897[ebp], dl
	mov	al, BYTE PTR $T241896[ebp]
	mov	BYTE PTR $T241869[ebp], al
	mov	ecx, DWORD PTR $T241882[ebp]
	mov	DWORD PTR $T241868[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR __Oldend$222447[ebp]
	sub	eax, edx
	mov	DWORD PTR $T241867[ebp], eax
	mov	ecx, DWORD PTR $T241881[ebp]
	mov	DWORD PTR $T241866[ebp], ecx
$LN197@Insert_n:
	mov	edx, DWORD PTR $T241866[ebp]
	cmp	edx, DWORD PTR $T241867[ebp]
	je	SHORT $LN186@Insert_n
	mov	eax, DWORD PTR $T241867[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T241867[ebp], eax
	mov	ecx, DWORD PTR $T241868[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T241868[ebp], ecx
	mov	edx, DWORD PTR $T241867[ebp]
	mov	eax, DWORD PTR $T241868[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T241916[ebp], eax
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	ecx, DWORD PTR $T241916[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T241916[ebp], ecx
$LN204@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T241916[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T241916[ebp]
	mov	ecx, DWORD PTR __Tmp$222446[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$222446[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$222446[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-444]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@IABUBuildingYieldChange@@@Z ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T241938 = -80						; size = 28
$T241937 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ PROC ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T241938[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T241937[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T241937[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T241938[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241937[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T241937[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T241937[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T241938[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T241938[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T241937[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@KAXXZ ENDP ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::_Xlen
PUBLIC	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
PUBLIC	??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$2
__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$0
__unwindtable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
_TEXT	SEGMENT
tv84 = -440						; size = 4
tv304 = -436						; size = 4
tv290 = -432						; size = 4
tv282 = -428						; size = 4
_this$ = -424						; size = 4
$T242640 = -420						; size = 4
$T242632 = -416						; size = 4
$T242631 = -412						; size = 4
$T242608 = -406						; size = 1
$T242607 = -405						; size = 1
$T242606 = -404						; size = 4
$T242605 = -400						; size = 4
$T242593 = -393						; size = 1
$T242592 = -392						; size = 4
$T242591 = -388						; size = 4
$T242590 = -384						; size = 4
__Cat$242624 = -380					; size = 1
$T242622 = -379						; size = 1
$T242621 = -378						; size = 1
__Cat$242616 = -376					; size = 1
$T242613 = -375						; size = 1
$T242612 = -374						; size = 1
$T242611 = -373						; size = 1
$T242565 = -372						; size = 4
$T242546 = -368						; size = 4
$T242529 = -361						; size = 1
$T242528 = -360						; size = 4
$T242518 = -356						; size = 4
$T242517 = -352						; size = 4
__Cat$242562 = -346					; size = 1
$T242560 = -345						; size = 1
$T242559 = -344						; size = 1
__Cat$242554 = -343					; size = 1
$T242551 = -342						; size = 1
$T242550 = -341						; size = 1
$T242493 = -340						; size = 4
$T242485 = -336						; size = 4
$T242477 = -332						; size = 4
$T242459 = -328						; size = 4
$T242458 = -324						; size = 4
$T242442 = -320						; size = 4
__Cat$242466 = -314					; size = 1
$T242463 = -313						; size = 1
$T242416 = -312						; size = 4
$T242415 = -308						; size = 4
$T242405 = -304						; size = 4
__Cat$242413 = -299					; size = 1
$T242410 = -298						; size = 1
$T242409 = -297						; size = 1
$T242389 = -296						; size = 4
$T242370 = -292						; size = 4
$T242353 = -285						; size = 1
$T242352 = -284						; size = 4
$T242342 = -280						; size = 4
$T242341 = -276						; size = 4
__Cat$242387 = -270					; size = 1
$T242384 = -269						; size = 1
$T242383 = -268						; size = 1
__Cat$242378 = -267					; size = 1
$T242375 = -266						; size = 1
$T242374 = -265						; size = 1
$T242317 = -264						; size = 4
$T242316 = -260						; size = 4
$T242312 = -256						; size = 4
$T242311 = -252						; size = 4
$T242293 = -248						; size = 4
$T242292 = -244						; size = 4
$T242276 = -240						; size = 4
__Cat$242300 = -234					; size = 1
$T242297 = -233						; size = 1
$T242227 = -232						; size = 4
$T242226 = -228						; size = 4
$T242210 = -224						; size = 4
__Cat$242234 = -218					; size = 1
$T242231 = -217						; size = 1
$T242167 = -216						; size = 4
$T242166 = -212						; size = 4
$T242150 = -208						; size = 4
__Cat$242174 = -202					; size = 1
$T242170 = -201						; size = 1
$T242124 = -200						; size = 4
$T242112 = -196						; size = 4
$T242102 = -189						; size = 1
$T242101 = -188						; size = 4
__Cat$242119 = -183					; size = 1
$T242116 = -182						; size = 1
$T242115 = -181						; size = 1
$T242089 = -180						; size = 4
$T242077 = -176						; size = 4
$T242067 = -169						; size = 1
$T242066 = -168						; size = 4
__Cat$242084 = -163					; size = 1
$T242081 = -162						; size = 1
$T242080 = -161						; size = 1
$T242054 = -160						; size = 4
$T242044 = -156						; size = 4
__Cat$242051 = -151					; size = 1
$T242048 = -150						; size = 1
$T242047 = -149						; size = 1
__Count$242017 = -136					; size = 4
__Count$241991 = -64					; size = 4
__Tmp$222509 = -60					; size = 12
__Oldend$222510 = -48					; size = 4
__Tmp$222499 = -44					; size = 12
__Ncopied$222486 = -32					; size = 4
__Newvec$222484 = -28					; size = 4
__Whereoff$222485 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n@2:
	mov	edx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$241991[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$241991[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	eax, DWORD PTR __Count$241991[ebp]
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR tv290[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$242017[ebp], 357913941 ; 15555555H
	cmp	DWORD PTR __Count$242017[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	edx, DWORD PTR __Count$242017[ebp]
	mov	DWORD PTR tv304[ebp], edx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n@2:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv304[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ; std::_Allocate<BuildingGreatWork>
	add	esp, 8
	mov	DWORD PTR __Newvec$222484[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$222485[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$222486[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$222485[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$222484[ebp]
	mov	DWORD PTR $T242054[ebp], edx
	mov	eax, DWORD PTR $T242054[ebp]
	mov	DWORD PTR $T242044[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242047[ebp], cl
	mov	dl, BYTE PTR __Cat$242051[ebp]
	mov	BYTE PTR $T242048[ebp], dl
	movzx	eax, BYTE PTR $T242047[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T242048[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242044[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$222486[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$222486[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T242089[ebp], edx
	mov	eax, DWORD PTR __Newvec$222484[ebp]
	mov	DWORD PTR $T242077[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242080[ebp], cl
	mov	dl, BYTE PTR __Cat$242084[ebp]
	mov	BYTE PTR $T242081[ebp], dl
	mov	al, BYTE PTR $T242080[ebp]
	mov	BYTE PTR $T242067[ebp], al
	mov	ecx, DWORD PTR $T242077[ebp]
	mov	DWORD PTR $T242066[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242066[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242089[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$222486[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$222486[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242124[ebp], edx
	mov	eax, DWORD PTR __Whereoff$222485[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$222484[ebp]
	mov	DWORD PTR $T242112[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242115[ebp], cl
	mov	dl, BYTE PTR __Cat$242119[ebp]
	mov	BYTE PTR $T242116[ebp], dl
	mov	al, BYTE PTR $T242115[ebp]
	mov	BYTE PTR $T242102[ebp], al
	mov	ecx, DWORD PTR $T242112[ebp]
	mov	DWORD PTR $T242101[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242101[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242124[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$222486[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$222485[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$222484[ebp]
	mov	DWORD PTR $T242167[ebp], eax
	mov	ecx, DWORD PTR __Newvec$222484[ebp]
	mov	DWORD PTR $T242166[ebp], ecx
	mov	dl, BYTE PTR __Cat$242174[ebp]
	mov	BYTE PTR $T242170[ebp], dl
	mov	eax, DWORD PTR $T242166[ebp]
	mov	DWORD PTR $T242150[ebp], eax
	jmp	SHORT $LN91@Insert_n@2
$LN90@Insert_n@2:
	mov	ecx, DWORD PTR $T242150[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T242150[ebp], ecx
$LN91@Insert_n@2:
	mov	edx, DWORD PTR $T242150[ebp]
	cmp	edx, DWORD PTR $T242167[ebp]
	je	SHORT $LN7@Insert_n@2
	jmp	SHORT $LN90@Insert_n@2
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$222486[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Whereoff$222485[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$222484[ebp]
	add	ecx, eax
	mov	DWORD PTR $T242227[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$222485[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$222484[ebp]
	mov	DWORD PTR $T242226[ebp], edx
	mov	al, BYTE PTR __Cat$242234[ebp]
	mov	BYTE PTR $T242231[ebp], al
	mov	ecx, DWORD PTR $T242226[ebp]
	mov	DWORD PTR $T242210[ebp], ecx
	jmp	SHORT $LN106@Insert_n@2
$LN105@Insert_n@2:
	mov	edx, DWORD PTR $T242210[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T242210[ebp], edx
$LN106@Insert_n@2:
	mov	eax, DWORD PTR $T242210[ebp]
	cmp	eax, DWORD PTR $T242227[ebp]
	je	SHORT $LN6@Insert_n@2
	jmp	SHORT $LN105@Insert_n@2
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$222484[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242312[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242311[ebp], eax
	mov	ecx, DWORD PTR $T242312[ebp]
	mov	DWORD PTR $T242293[ebp], ecx
	mov	edx, DWORD PTR $T242311[ebp]
	mov	DWORD PTR $T242292[ebp], edx
	mov	al, BYTE PTR __Cat$242300[ebp]
	mov	BYTE PTR $T242297[ebp], al
	mov	ecx, DWORD PTR $T242292[ebp]
	mov	DWORD PTR $T242276[ebp], ecx
	jmp	SHORT $LN125@Insert_n@2
$LN124@Insert_n@2:
	mov	edx, DWORD PTR $T242276[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T242276[ebp], edx
$LN125@Insert_n@2:
	mov	eax, DWORD PTR $T242276[ebp]
	cmp	eax, DWORD PTR $T242293[ebp]
	je	SHORT $LN117@Insert_n@2
	jmp	SHORT $LN124@Insert_n@2
$LN117@Insert_n@2:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T242317[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242316[ebp], eax
	mov	ecx, DWORD PTR $T242316[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$222484[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$222484[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$222484[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$222499[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$222499[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$222499[ebp+8], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242389[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242370[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242374[ebp], al
	mov	cl, BYTE PTR __Cat$242378[ebp]
	mov	BYTE PTR $T242375[ebp], cl
	mov	dl, BYTE PTR $T242374[ebp]
	mov	BYTE PTR $T242353[ebp], dl
	mov	eax, DWORD PTR $T242370[ebp]
	mov	DWORD PTR $T242352[ebp], eax
	mov	ecx, DWORD PTR $T242352[ebp]
	mov	DWORD PTR $T242342[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242341[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242383[ebp], al
	mov	cl, BYTE PTR __Cat$242387[ebp]
	mov	BYTE PTR $T242384[ebp], cl
	movzx	edx, BYTE PTR $T242383[ebp]
	push	edx
	movzx	eax, BYTE PTR $T242384[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242342[ebp]
	push	edx
	mov	eax, DWORD PTR $T242389[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242341[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T242416[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242415[ebp], ecx
	mov	edx, DWORD PTR $T242415[ebp]
	mov	DWORD PTR $T242405[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242409[ebp], al
	mov	cl, BYTE PTR __Cat$242413[ebp]
	mov	BYTE PTR $T242410[ebp], cl
	movzx	edx, BYTE PTR $T242409[ebp]
	push	edx
	movzx	eax, BYTE PTR $T242410[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$222499[ebp]
	push	edx
	mov	eax, DWORD PTR $T242416[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242405[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242477[ebp], edx
	mov	ecx, DWORD PTR $T242477[ebp]
	mov	DWORD PTR $T242459[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242458[ebp], edx
	mov	al, BYTE PTR __Cat$242466[ebp]
	mov	BYTE PTR $T242463[ebp], al
	mov	ecx, DWORD PTR $T242458[ebp]
	mov	DWORD PTR $T242442[ebp], ecx
	jmp	SHORT $LN160@Insert_n@2
$LN159@Insert_n@2:
	mov	edx, DWORD PTR $T242442[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T242442[ebp], edx
$LN160@Insert_n@2:
	mov	eax, DWORD PTR $T242442[ebp]
	cmp	eax, DWORD PTR $T242459[ebp]
	je	SHORT $LN152@Insert_n@2
	jmp	SHORT $LN159@Insert_n@2
$LN152@Insert_n@2:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T242493[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242485[ebp], ecx
	jmp	SHORT $LN171@Insert_n@2
$LN170@Insert_n@2:
	mov	edx, DWORD PTR $T242485[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T242485[ebp], edx
$LN171@Insert_n@2:
	mov	eax, DWORD PTR $T242485[ebp]
	cmp	eax, DWORD PTR $T242493[ebp]
	je	SHORT $LN167@Insert_n@2
	mov	ecx, DWORD PTR $T242485[ebp]
	mov	edx, DWORD PTR __Tmp$222499[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$222499[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Tmp$222499[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN170@Insert_n@2
$LN167@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$222509[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$222509[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$222509[ebp+8], eax

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$222510[ebp], edx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242565[ebp], ecx
	mov	edx, DWORD PTR $T242565[ebp]
	mov	DWORD PTR $T242546[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242550[ebp], al
	mov	cl, BYTE PTR __Cat$242554[ebp]
	mov	BYTE PTR $T242551[ebp], cl
	mov	dl, BYTE PTR $T242550[ebp]
	mov	BYTE PTR $T242529[ebp], dl
	mov	eax, DWORD PTR $T242546[ebp]
	mov	DWORD PTR $T242528[ebp], eax
	mov	ecx, DWORD PTR $T242528[ebp]
	mov	DWORD PTR $T242518[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR __Oldend$222510[ebp]
	sub	eax, edx
	mov	DWORD PTR $T242517[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242559[ebp], cl
	mov	dl, BYTE PTR __Cat$242562[ebp]
	mov	BYTE PTR $T242560[ebp], dl
	movzx	eax, BYTE PTR $T242559[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T242560[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242518[ebp]
	push	eax
	mov	ecx, DWORD PTR __Oldend$222510[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242517[ebp]
	push	edx
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$222510[ebp]
	mov	DWORD PTR $T242632[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242631[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242611[ebp], cl
	mov	dl, BYTE PTR __Cat$242616[ebp]
	mov	BYTE PTR $T242612[ebp], dl
	mov	al, BYTE PTR $T242611[ebp]
	mov	BYTE PTR $T242608[ebp], al
	mov	cl, BYTE PTR $T242613[ebp]
	mov	BYTE PTR $T242607[ebp], cl
	mov	edx, DWORD PTR $T242632[ebp]
	mov	DWORD PTR $T242606[ebp], edx
	mov	eax, DWORD PTR $T242631[ebp]
	mov	DWORD PTR $T242605[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242621[ebp], cl
	mov	dl, BYTE PTR __Cat$242624[ebp]
	mov	BYTE PTR $T242622[ebp], dl
	mov	al, BYTE PTR $T242621[ebp]
	mov	BYTE PTR $T242593[ebp], al
	mov	ecx, DWORD PTR $T242606[ebp]
	mov	DWORD PTR $T242592[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR __Oldend$222510[ebp]
	sub	eax, edx
	mov	DWORD PTR $T242591[ebp], eax
	mov	ecx, DWORD PTR $T242605[ebp]
	mov	DWORD PTR $T242590[ebp], ecx
$LN197@Insert_n@2:
	mov	edx, DWORD PTR $T242590[ebp]
	cmp	edx, DWORD PTR $T242591[ebp]
	je	SHORT $LN186@Insert_n@2
	mov	eax, DWORD PTR $T242591[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T242591[ebp], eax
	mov	ecx, DWORD PTR $T242592[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T242592[ebp], ecx
	mov	edx, DWORD PTR $T242591[ebp]
	mov	eax, DWORD PTR $T242592[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN197@Insert_n@2
$LN186@Insert_n@2:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T242640[ebp], eax
	jmp	SHORT $LN204@Insert_n@2
$LN203@Insert_n@2:
	mov	ecx, DWORD PTR $T242640[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T242640[ebp], ecx
$LN204@Insert_n@2:
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T242640[ebp], edx
	je	SHORT $LN16@Insert_n@2
	mov	eax, DWORD PTR $T242640[ebp]
	mov	ecx, DWORD PTR __Tmp$222509[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$222509[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$222509[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN203@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-444]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@IAEXV?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@IABUBuildingGreatWork@@@Z ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T242662 = -80						; size = 28
$T242661 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ PROC ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T242662[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T242661[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T242661[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T242662[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242661[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T242661[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T242661[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T242662[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T242662[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T242661[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@KAXXZ ENDP ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T242773 = -47						; size = 1
$T242748 = -46						; size = 1
$T242730 = -45						; size = 1
$T242719 = -44						; size = 4
$T242761 = -40						; size = 4
$T242712 = -36						; size = 4
$T242705 = -28						; size = 4
$T242698 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T242773[ebp]
	mov	DWORD PTR $T242698[ebp], eax
	lea	ecx, DWORD PTR $T242748[ebp]
	mov	DWORD PTR $T242705[ebp], ecx
	lea	edx, DWORD PTR $T242730[ebp]
	mov	DWORD PTR $T242712[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T242761[ebp], esp
	mov	DWORD PTR $T242719[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv137 = -192						; size = 4
tv163 = -188						; size = 4
tv189 = -184						; size = 4
_this$ = -180						; size = 4
$T242872 = -46						; size = 1
$T242854 = -45						; size = 1
$T242843 = -44						; size = 4
$T242863 = -40						; size = 4
$T242836 = -36						; size = 4
$T242826 = -28						; size = 4
$T242812 = -21						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T242872[ebp]
	mov	DWORD PTR $T242826[ebp], eax
	lea	ecx, DWORD PTR $T242854[ebp]
	mov	DWORD PTR $T242836[ebp], ecx
	push	ecx
	mov	edx, esp
	mov	DWORD PTR $T242863[ebp], esp
	mov	DWORD PTR $T242843[ebp], edx
	lea	eax, DWORD PTR $T242812[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
	jmp	SHORT $LN4@Tree@2
__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree@2
	ret	0
$LN4@Tree@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree@2:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T243382 = -148						; size = 4
$T243362 = -144						; size = 4
$T243347 = -140						; size = 4
$T243330 = -136						; size = 4
$T243317 = -132						; size = 4
$T243303 = -128						; size = 4
$T243259 = -45						; size = 1
$T243258 = -44						; size = 4
$T243257 = -37						; size = 1
$T243256 = -36						; size = 4
$T243255 = -29						; size = 1
$T243254 = -28						; size = 4
$T243253 = -24						; size = 4
$T243252 = -17						; size = 1
__Where$222599 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@6:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN9@insert@6

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@6
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@6
$LN33@insert@6:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@6:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@6
$LN9@insert@6:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@6

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T243252[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T243253[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T243303[ebp], eax
	mov	edx, DWORD PTR $T243303[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T243252[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@6

; 644  : 		else

	jmp	$LN11@insert@6
$LN8@insert@6:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$222599[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@6
	jmp	$LN79@insert@6
$LN6@insert@6:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243317[ebp], ecx
	mov	edx, DWORD PTR $T243317[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T243330[ebp], eax
	mov	ecx, DWORD PTR $T243330[ebp]
	mov	DWORD PTR $T243254[ebp], ecx
	mov	edx, DWORD PTR __Where$222599[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T243254[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@6

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T243255[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T243256[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T243347[ebp], eax
	mov	edx, DWORD PTR $T243347[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T243255[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@6

; 651  : 			else

	jmp	SHORT $LN79@insert@6
$LN4@insert@6:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$222599[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@6:
	mov	ecx, DWORD PTR __Where$222599[ebp]
	mov	DWORD PTR $T243362[ebp], ecx
	mov	edx, DWORD PTR $T243362[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@6

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T243257[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T243258[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
	mov	DWORD PTR $T243382[ebp], eax
	mov	edx, DWORD PTR $T243382[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T243257[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@6

; 657  : 			else

	jmp	SHORT $LN11@insert@6
$LN2@insert@6:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T243259[ebp], 0
	mov	ecx, DWORD PTR __Where$222599[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T243259[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@6:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T243922 = -188						; size = 4
$T243834 = -172						; size = 4
$T243749 = -160						; size = 4
$T243733 = -156						; size = 4
$T243714 = -152						; size = 4
$T243710 = -148						; size = 4
$T243625 = -136						; size = 4
$T243524 = -120						; size = 4
$T243502 = -116						; size = 4
$T243495 = -112						; size = 4
$T243491 = -108						; size = 4
$T243452 = -104						; size = 4
$T243443 = -100						; size = 4
$T243423 = -96						; size = 4
__Count$243406 = -92					; size = 4
$T243389 = -88						; size = 28
$T243388 = -60						; size = 40
__Pnode$222630 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$243406[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$243406[ebp], 0
	jbe	SHORT $LN25@Insert@2
	mov	eax, DWORD PTR __Count$243406[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert@2
$LN25@Insert@2:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert@2:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert@2

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T243389[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T243389[ebp]
	push	eax
	lea	ecx, DWORD PTR $T243388[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T243388[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T243388[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T243389[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243423[ebp], edx
	mov	eax, DWORD PTR $T243423[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243443[ebp], eax
	mov	ecx, DWORD PTR $T243443[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243452[ebp], ecx
	mov	edx, DWORD PTR $T243452[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert@2:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert@2

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert@2:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert@2

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$222630[ebp], eax
$LN64@Insert@2:
	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+20]
	test	eax, eax
	jne	$LN360@Insert@2

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T243491[ebp], edx
	mov	eax, DWORD PTR $T243491[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T243495[ebp], ecx
	mov	edx, DWORD PTR __Pnode$222630[ebp]
	mov	eax, DWORD PTR $T243495[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$222630[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T243502[ebp], eax
	mov	ecx, DWORD PTR $T243502[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN100@Insert@2

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$222630[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$222630[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T243524[ebp], ecx
	mov	edx, DWORD PTR $T243524[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222630[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert@2

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert@2:
	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$222630[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$222630[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$222630[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert@2:
	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$222630[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T243625[ebp], ecx
	mov	edx, DWORD PTR $T243625[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
$LN6@Insert@2:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert@2

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert@2:
	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T243710[ebp], edx
	mov	eax, DWORD PTR $T243710[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T243714[ebp], ecx
	mov	edx, DWORD PTR $T243714[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN240@Insert@2

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$222630[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$222630[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T243733[ebp], ecx
	mov	edx, DWORD PTR $T243733[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222630[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert@2

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert@2:
	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243749[ebp], edx
	mov	eax, DWORD PTR $T243749[ebp]
	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$222630[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222630[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert@2:
	mov	edx, DWORD PTR __Pnode$222630[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+20], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$222630[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T243834[ebp], edx
	mov	eax, DWORD PTR $T243834[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$222630[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
$LN4@Insert@2:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert@2

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T243922[ebp], eax
	mov	ecx, DWORD PTR $T243922[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@2:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T243389[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound@3:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN3@Lbound@3

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound@3

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound@3
$LN2@Lbound@3:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound@3:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound@3
$LN3@Lbound@3:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T244217 = -88						; size = 4
$T244183 = -84						; size = 4
$T244016 = -32						; size = 4
$T244003 = -28						; size = 4
$T243991 = -24						; size = 4
$T243981 = -20						; size = 4
$T243980 = -16						; size = 4
$T243979 = -12						; size = 4
$T243978 = -8						; size = 4
$T243977 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T243991[ebp], ecx
	mov	edx, DWORD PTR $T243991[ebp]
	mov	DWORD PTR $T243978[ebp], edx
	mov	eax, DWORD PTR $T243978[ebp]
	mov	DWORD PTR $T243977[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244003[ebp], edx
	mov	eax, DWORD PTR $T244003[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T244016[ebp], ecx
	mov	edx, DWORD PTR $T244016[ebp]
	mov	DWORD PTR $T243980[ebp], edx
	mov	eax, DWORD PTR $T243980[ebp]
	mov	DWORD PTR $T243979[ebp], eax
	mov	ecx, DWORD PTR $T243977[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243979[ebp]
	push	edx
	lea	eax, DWORD PTR $T243981[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244183[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244217[ebp], ecx
	mov	edx, DWORD PTR $T244217[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$5
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -264						; size = 4
tv165 = -260						; size = 4
_this$ = -256						; size = 4
$T245340 = -252						; size = 4
$T245335 = -248						; size = 4
$T245232 = -244						; size = 4
$T245215 = -240						; size = 4
$T244477 = -136						; size = 4
$T244476 = -132						; size = 4
__Tmp$244475 = -125					; size = 1
$T244452 = -124						; size = 4
$T244445 = -120						; size = 4
$T244375 = -116						; size = 4
$T244339 = -112						; size = 4
$T244334 = -108						; size = 4
$T244306 = -104						; size = 4
$T244230 = -100						; size = 4
$T244221 = -96						; size = 28
$T244220 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244230[ebp], eax
	mov	ecx, DWORD PTR $T244230[ebp]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN55@erase@8

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T244221[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T244221[ebp]
	push	eax
	lea	ecx, DWORD PTR $T244220[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T244220[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T244220[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T244221[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@8:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	je	SHORT $LN67@erase@8

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@8

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@8:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN71@erase@8

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@8

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@8:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@8:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@8

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN81@erase@8

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@8

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@8

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@8:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@8

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@8

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@8:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@8:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244306[ebp], ecx
	mov	edx, DWORD PTR $T244306[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@8

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN43@erase@8
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@8
$LN43@erase@8:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T244334[ebp], ecx
$LN107@erase@8:
	mov	edx, DWORD PTR $T244334[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	jne	SHORT $LN103@erase@8
	mov	edx, DWORD PTR $T244334[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244334[ebp], eax
	jmp	SHORT $LN107@erase@8
$LN103@erase@8:
	mov	ecx, DWORD PTR $T244334[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@8:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244339[ebp], eax
	mov	ecx, DWORD PTR $T244339[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@8

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	je	SHORT $LN45@erase@8
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@8
$LN45@erase@8:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T244375[ebp], eax
$LN127@erase@8:
	mov	ecx, DWORD PTR $T244375[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN123@erase@8
	mov	ecx, DWORD PTR $T244375[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244375[ebp], edx
	jmp	SHORT $LN127@erase@8
$LN123@erase@8:
	mov	eax, DWORD PTR $T244375[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@8:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@8

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@8:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@8

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@8

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@8:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	jne	SHORT $LN151@erase@8

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@8:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@8

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@8

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@8:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244445[ebp], ecx
	mov	edx, DWORD PTR $T244445[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@8

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244452[ebp], edx
	mov	eax, DWORD PTR $T244452[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@8

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@8:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@8:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T244477[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR $T244476[ebp], eax
	mov	ecx, DWORD PTR $T244476[ebp]
	cmp	ecx, DWORD PTR $T244477[ebp]
	je	SHORT $LN192@erase@8
	mov	edx, DWORD PTR $T244476[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$244475[ebp], al
	mov	ecx, DWORD PTR $T244476[ebp]
	mov	edx, DWORD PTR $T244477[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T244477[ebp]
	mov	dl, BYTE PTR __Tmp$244475[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@8:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+28]
	cmp	ecx, 1
	jne	$LN595@erase@8

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@8
$LN194@erase@8:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@8
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+28]
	cmp	edx, 1
	jne	$LN586@erase@8

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@8

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+28]
	test	edx, edx
	jne	SHORT $LN263@erase@8

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+28], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+28], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@8:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	je	SHORT $LN267@erase@8

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@8

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@8:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+28]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@8
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+28]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@8

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+28], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@8

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@8:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+28]
	cmp	eax, 1
	jne	SHORT $LN338@erase@8

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+28], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+28], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@8:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+28]
	mov	BYTE PTR [ecx+28], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+28], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+28], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@8
$LN12@erase@8:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@8

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@8:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+28]
	test	edx, edx
	jne	SHORT $LN454@erase@8

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+28], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+28], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@8:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	je	SHORT $LN458@erase@8

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@8

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@8:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+28]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@8
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+28]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@8

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+28], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@8

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@8:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+28]
	cmp	eax, 1
	jne	SHORT $LN529@erase@8

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+28], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+28], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@8:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+28]
	mov	BYTE PTR [ecx+28], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+28], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+28], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@8
$LN8@erase@8:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@8

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@8:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+28], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN595@erase@8:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T245232[ebp], eax
	mov	ecx, DWORD PTR $T245232[ebp]
	add	ecx, 4
	mov	DWORD PTR $T245215[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T245215[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN588@erase@8
	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN588@erase@8:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jbe	SHORT $LN1@erase@8

; 928  : 			--_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@erase@8:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T245340[ebp], eax
	mov	ecx, DWORD PTR $T245340[ebp]
	mov	DWORD PTR $T245335[ebp], ecx
	mov	edx, DWORD PTR $T245335[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@8:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T244221[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$5:
	mov	ecx, DWORD PTR $T245215[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 134  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T245434 = -12						; size = 4
$T245427 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245427[ebp], eax
	mov	ecx, DWORD PTR $T245427[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245434[ebp], ecx
	mov	edx, DWORD PTR $T245434[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T245510 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245510[ebp], eax
	mov	ecx, DWORD PTR $T245510[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$6
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
_TEXT	SEGMENT
tv86 = -60						; size = 4
_this$ = -56						; size = 4
$T245553 = -52						; size = 4
$T245548 = -48						; size = 4
$T245520 = -28						; size = 4
$T245519 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T245520[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T245520[ebp], 0
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR $T245520[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T245520[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T245520[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T245520[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T245553[ebp], ecx
	mov	edx, DWORD PTR $T245553[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T245553[ebp]
	add	edx, 4
	mov	DWORD PTR $T245548[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR $T245548[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
	mov	ecx, DWORD PTR $T245520[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+28], dl
	mov	eax, DWORD PTR $T245520[ebp]
	mov	BYTE PTR [eax+29], 0
	mov	ecx, DWORD PTR $T245520[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T245519[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245520[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv145 = -28						; size = 4
_this$ = -24						; size = 4
$T245601 = -19						; size = 1
$T245600 = -18						; size = 1
$T245592 = -17						; size = 1
$T245588 = -16						; size = 4
$T245581 = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T245600[ebp]
	mov	DWORD PTR $T245581[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T245601[ebp], dl
	lea	eax, DWORD PTR $T245592[ebp]
	mov	DWORD PTR $T245588[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], edx

; 53   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T245833 = -72						; size = 4
$T245827 = -68						; size = 4
__Tmp$245815 = -48					; size = 4
$T245743 = -44						; size = 4
$T245730 = -40						; size = 4
$T245660 = -28						; size = 4
$T245637 = -24						; size = 4
$T245624 = -20						; size = 4
$T245618 = -16						; size = 4
$T245617 = -12						; size = 4
$T245616 = -8						; size = 4
$T245615 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245624[ebp], ecx
	mov	edx, DWORD PTR $T245624[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245637[ebp], eax
	mov	ecx, DWORD PTR $T245637[ebp]
	mov	DWORD PTR $T245615[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T245615[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@9
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245660[ebp], eax
	mov	ecx, DWORD PTR $T245660[ebp]
	mov	DWORD PTR $T245616[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T245616[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@9

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245730[ebp], eax
	mov	ecx, DWORD PTR $T245730[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T245743[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T245743[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@9

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@9

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN72@erase@9:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@9

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$245815[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$245815[ebp]
	mov	DWORD PTR $T245617[ebp], ecx
	mov	edx, DWORD PTR $T245617[ebp]
	push	edx
	lea	eax, DWORD PTR $T245618[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
	jmp	SHORT $LN72@erase@9
$LN1@erase@9:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245833[ebp], ecx
	mov	edx, DWORD PTR $T245833[ebp]
	mov	DWORD PTR $T245827[ebp], edx
	mov	eax, DWORD PTR $T245827[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@9:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T245951 = -40						; size = 4
$T245938 = -36						; size = 4
$T245917 = -32						; size = 4
$T245904 = -28						; size = 4
$T245899 = -24						; size = 4
$T245878 = -20						; size = 4
$T245866 = -16						; size = 4
$T245857 = -12						; size = 4
$T245853 = -8						; size = 4
$T245844 = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T245844[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T245853[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T245844[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
	mov	edx, DWORD PTR $T245853[ebp]
	mov	DWORD PTR [edx], eax

; 1064 : 		_Mysize = _Right.size();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T245857[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T245857[ebp]
	mov	DWORD PTR [edx+8], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T245866[ebp], edx
	mov	eax, DWORD PTR $T245866[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN2@Copy@3

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T245878[ebp], ecx
	mov	edx, DWORD PTR $T245878[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245899[ebp], eax
$LN31@Copy@3:
	mov	ecx, DWORD PTR $T245899[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN27@Copy@3
	mov	ecx, DWORD PTR $T245899[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T245899[ebp], edx
	jmp	SHORT $LN31@Copy@3
$LN27@Copy@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T245904[ebp], ecx
	mov	edx, DWORD PTR $T245904[ebp]
	mov	eax, DWORD PTR $T245899[ebp]
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T245917[ebp], edx
	mov	eax, DWORD PTR $T245917[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T245938[ebp], ecx
$LN49@Copy@3:
	mov	edx, DWORD PTR $T245938[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN53@Copy@3
	mov	edx, DWORD PTR $T245938[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T245938[ebp], eax
	jmp	SHORT $LN49@Copy@3
$LN53@Copy@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T245938[ebp]
	mov	DWORD PTR [edx+8], eax

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy@3
$LN2@Copy@3:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T245951[ebp], edx
	mov	eax, DWORD PTR $T245951[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN3@Copy@3:

; 1072 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T245981 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245981[ebp], eax
	mov	ecx, DWORD PTR $T245981[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T246052 = -12						; size = 4
$T246045 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate@2

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246045[ebp], eax
	mov	ecx, DWORD PTR $T246045[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246052[ebp], ecx
	mov	edx, DWORD PTR $T246052[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate@2

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate@2:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate@2:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T246128 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate@2

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate@2

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246128[ebp], eax
	mov	ecx, DWORD PTR $T246128[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate@2:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T246138 = -28						; size = 4
$T246137 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T246138[ebp], eax
	cmp	DWORD PTR $T246138[ebp], 0
	je	SHORT $LN4@Buynode@3
	mov	ecx, DWORD PTR $T246138[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T246138[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T246138[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T246138[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR $T246138[ebp]
	mov	al, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [edx+20], al
	mov	ecx, DWORD PTR $T246138[ebp]
	mov	BYTE PTR [ecx+21], 0
	mov	edx, DWORD PTR $T246138[ebp]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN5@Buynode@3
$LN4@Buynode@3:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@3:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T246137[ebp], eax
	jmp	SHORT $LN6@Buynode@3
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1
	ret	0
$LN6@Buynode@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@3:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246215 = -16						; size = 4
$T246194 = -12						; size = 4
$T246187 = -8						; size = 4
__Pnode$222911 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246187[ebp], edx
	mov	eax, DWORD PTR $T246187[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246194[ebp], ecx
	mov	edx, DWORD PTR $T246194[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246215[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T246215[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T246215[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246215[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T246215[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$222911[ebp], ecx
	mov	edx, DWORD PTR __Pnode$222911[ebp]
	movsx	eax, BYTE PTR [edx+29]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$222911[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$222911[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$222911[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246264 = -16						; size = 4
$T246243 = -12						; size = 4
$T246236 = -8						; size = 4
__Pnode$222923 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	je	SHORT $LN6@Inc
	jmp	$LN7@Inc
$LN6@Inc:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T246236[ebp], ecx
	mov	edx, DWORD PTR $T246236[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+29]
	test	ecx, ecx
	jne	SHORT $LN27@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T246243[ebp], eax
	mov	ecx, DWORD PTR $T246243[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246264[ebp], edx
$LN23@Inc:
	mov	eax, DWORD PTR $T246264[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	jne	SHORT $LN19@Inc
	mov	eax, DWORD PTR $T246264[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246264[ebp], ecx
	jmp	SHORT $LN23@Inc
$LN19@Inc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T246264[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222923[ebp], eax
	mov	ecx, DWORD PTR __Pnode$222923[ebp]
	movsx	edx, BYTE PTR [ecx+29]
	test	edx, edx
	jne	SHORT $LN1@Inc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$222923[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$222923[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$222923[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246316 = -16						; size = 4
$T246295 = -12						; size = 4
$T246288 = -8						; size = 4
__Pnode$222934 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN8@Dec@2

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec@2
$LN8@Dec@2:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec@2
$LN9@Dec@2:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246288[ebp], edx
	mov	eax, DWORD PTR $T246288[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN34@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246295[ebp], ecx
	mov	edx, DWORD PTR $T246295[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246316[ebp], eax
$LN30@Dec@2:
	mov	ecx, DWORD PTR $T246316[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN26@Dec@2
	mov	ecx, DWORD PTR $T246316[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246316[ebp], edx
	jmp	SHORT $LN30@Dec@2
$LN26@Dec@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T246316[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec@2

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$222934[ebp], ecx
	mov	edx, DWORD PTR __Pnode$222934[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN40@Dec@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$222934[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$222934[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec@2

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN2@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec@2

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec@2
$LN2@Dec@2:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$222934[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec@2:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T246365 = -16						; size = 4
$T246344 = -12						; size = 4
$T246337 = -8						; size = 4
__Pnode$222946 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN6@Inc@2
	jmp	$LN7@Inc@2
$LN6@Inc@2:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T246337[ebp], ecx
	mov	edx, DWORD PTR $T246337[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN27@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T246344[ebp], eax
	mov	ecx, DWORD PTR $T246344[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T246365[ebp], edx
$LN23@Inc@2:
	mov	eax, DWORD PTR $T246365[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN19@Inc@2
	mov	eax, DWORD PTR $T246365[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T246365[ebp], ecx
	jmp	SHORT $LN23@Inc@2
$LN19@Inc@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T246365[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc@2

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$222946[ebp], eax
	mov	ecx, DWORD PTR __Pnode$222946[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN1@Inc@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$222946[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$222946[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$222946[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc@2:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T246386 = -9						; size = 1
$T246382 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T246386[ebp]
	mov	DWORD PTR $T246382[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -216						; size = 4
tv165 = -212						; size = 4
_this$ = -208						; size = 4
$T247247 = -204						; size = 4
$T247241 = -200						; size = 4
$T246646 = -136						; size = 4
$T246645 = -132						; size = 4
__Tmp$246644 = -125					; size = 1
$T246621 = -124						; size = 4
$T246614 = -120						; size = 4
$T246544 = -116						; size = 4
$T246508 = -112						; size = 4
$T246503 = -108						; size = 4
$T246475 = -104						; size = 4
$T246399 = -100						; size = 4
$T246390 = -96						; size = 28
$T246389 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246399[ebp], eax
	mov	ecx, DWORD PTR $T246399[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN55@erase@10

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T246390[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T246390[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246389[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T246389[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T246389[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T246390[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@10:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN67@erase@10

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@10

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@10:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN71@erase@10

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@10

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@10:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@10:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@10

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN81@erase@10

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@10

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@10

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@10:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@10

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@10

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@10:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@10:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246475[ebp], ecx
	mov	edx, DWORD PTR $T246475[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@10

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN43@erase@10
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@10
$LN43@erase@10:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T246503[ebp], ecx
$LN107@erase@10:
	mov	edx, DWORD PTR $T246503[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN103@erase@10
	mov	edx, DWORD PTR $T246503[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T246503[ebp], eax
	jmp	SHORT $LN107@erase@10
$LN103@erase@10:
	mov	ecx, DWORD PTR $T246503[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@10:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246508[ebp], eax
	mov	ecx, DWORD PTR $T246508[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@10

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN45@erase@10
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@10
$LN45@erase@10:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T246544[ebp], eax
$LN127@erase@10:
	mov	ecx, DWORD PTR $T246544[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN123@erase@10
	mov	ecx, DWORD PTR $T246544[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246544[ebp], edx
	jmp	SHORT $LN127@erase@10
$LN123@erase@10:
	mov	eax, DWORD PTR $T246544[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@10:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@10:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@10

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@10:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@10

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@10

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@10:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN151@erase@10

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@10:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@10

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@10

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@10:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246614[ebp], ecx
	mov	edx, DWORD PTR $T246614[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@10

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246621[ebp], edx
	mov	eax, DWORD PTR $T246621[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@10

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@10:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@10:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T246646[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T246645[ebp], eax
	mov	ecx, DWORD PTR $T246645[ebp]
	cmp	ecx, DWORD PTR $T246646[ebp]
	je	SHORT $LN192@erase@10
	mov	edx, DWORD PTR $T246645[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$246644[ebp], al
	mov	ecx, DWORD PTR $T246645[ebp]
	mov	edx, DWORD PTR $T246646[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T246646[ebp]
	mov	dl, BYTE PTR __Tmp$246644[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@10:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	$LN588@erase@10

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@10
$LN194@erase@10:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@10:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@10
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	cmp	edx, 1
	jne	$LN586@erase@10

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@10

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN263@erase@10

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@10:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN267@erase@10

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@10

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@10:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@10
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@10

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@10

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@10:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN338@erase@10

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@10:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+20], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@10
$LN12@erase@10:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@10

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@10:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN454@erase@10

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@10:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN458@erase@10

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@10

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@10:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@10
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@10

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@10

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@10:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN529@erase@10

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+20], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@10:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@10
$LN8@erase@10:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@10

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@10:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN588@erase@10:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@10

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@10:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T247247[ebp], edx
	mov	eax, DWORD PTR $T247247[ebp]
	mov	DWORD PTR $T247241[ebp], eax
	mov	ecx, DWORD PTR $T247241[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@10:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T246390[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T247297 = -8						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T247297[ebp], eax
	mov	ecx, DWORD PTR $T247297[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::clear
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
tv141 = -40						; size = 4
tv153 = -36						; size = 4
_this$ = -32						; size = 4
__Pnode$223042 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	$LN3@Copy@4

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$223042[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN2@Copy@4

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$223042[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@4:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$223042[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
	mov	DWORD PTR tv153[ebp], eax
	mov	eax, DWORD PTR __Pnode$223042[ebp]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR [eax], ecx

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	edx, DWORD PTR __Pnode$223042[ebp]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR __Pnode$223042[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN6@Copy@4
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	ecx, DWORD PTR __Newroot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@4
	ret	0
$LN6@Copy@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@4:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@4:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Copy
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T247469 = -80						; size = 4
__Vptr$247475 = -76					; size = 4
$T247440 = -72						; size = 4
__Vptr$247446 = -68					; size = 4
$T247411 = -64						; size = 4
__Vptr$247417 = -60					; size = 4
$T247374 = -36						; size = 4
$T247373 = -32						; size = 4
$T247372 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T247372[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$247417[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247417[ebp]
	mov	DWORD PTR $T247411[ebp], ecx
	cmp	DWORD PTR $T247411[ebp], 0
	je	SHORT $LN23@Buynode@4
	mov	edx, DWORD PTR $T247411[ebp]
	mov	eax, DWORD PTR $T247372[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T247411[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode@4
$LN23@Buynode@4:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode@4:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T247373[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$247446[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247446[ebp]
	mov	DWORD PTR $T247440[ebp], ecx
	cmp	DWORD PTR $T247440[ebp], 0
	je	SHORT $LN33@Buynode@4
	mov	edx, DWORD PTR $T247440[ebp]
	mov	eax, DWORD PTR $T247373[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T247440[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode@4
$LN33@Buynode@4:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode@4:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T247374[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$247475[ebp], eax
	mov	ecx, DWORD PTR __Vptr$247475[ebp]
	mov	DWORD PTR $T247469[ebp], ecx
	cmp	DWORD PTR $T247469[ebp], 0
	je	SHORT $LN43@Buynode@4
	mov	edx, DWORD PTR $T247469[ebp]
	mov	eax, DWORD PTR $T247374[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T247469[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode@4
$LN43@Buynode@4:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode@4:
	jmp	SHORT $LN6@Buynode@4
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode@4
	ret	0
$LN6@Buynode@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode@4:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+21], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@4:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$223115 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$223115[ebp], eax
	jmp	SHORT $LN6@Erase@2
$LN2@Erase@2:
	mov	ecx, DWORD PTR __Pnode$223115[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase@2:
	mov	edx, DWORD PTR __Pnode$223115[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN4@Erase@2

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$223115[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$223115[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$223115[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase@2
$LN4@Erase@2:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv145 = -28						; size = 4
_this$ = -24						; size = 4
$T247574 = -19						; size = 1
$T247573 = -18						; size = 1
$T247565 = -17						; size = 1
$T247561 = -16						; size = 4
$T247554 = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T247573[ebp]
	mov	DWORD PTR $T247554[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T247574[ebp], dl
	lea	eax, DWORD PTR $T247565[ebp]
	mov	DWORD PTR $T247561[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], edx

; 53   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T247589 = -9						; size = 1
$T247585 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T247589[ebp]
	mov	DWORD PTR $T247585[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z PROC ; operator>><BuildingYieldChange>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ENDP ; operator>><BuildingYieldChange>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >
; Function compile flags: /Odtp
;	COMDAT ??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z PROC ; operator>><BuildingGreatWork>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ENDP ; operator>><BuildingGreatWork>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z
_TEXT	SEGMENT
$T247672 = -68						; size = 8
$T247671 = -60						; size = 4
$T247670 = -56						; size = 4
$T247652 = -52						; size = 4
__ChkFirst$247654 = -48					; size = 4
__ChkLast$247655 = -44					; size = 4
$T247629 = -40						; size = 4
$T247620 = -36						; size = 4
$T247608 = -32						; size = 4
$T247611 = -28						; size = 4
$T247599 = -24						; size = 8
$T247598 = -16						; size = 4
$T247597 = -12						; size = 4
$T247596 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z PROC ; operator<<<BuildingYieldChange>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T247596[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T247596[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T247611[ebp], eax
	mov	edx, DWORD PTR $T247596[ebp]
	mov	DWORD PTR $T247608[ebp], edx
	lea	eax, DWORD PTR $T247611[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247608[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T247620[ebp], edx
	mov	eax, DWORD PTR $T247620[ebp]
	mov	DWORD PTR $T247597[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247629[ebp], edx
	mov	eax, DWORD PTR $T247629[ebp]
	mov	DWORD PTR $T247598[ebp], eax
	mov	ecx, DWORD PTR $T247596[ebp]
	mov	DWORD PTR $T247672[ebp], ecx
	mov	edx, DWORD PTR $T247596[ebp+4]
	mov	DWORD PTR $T247672[ebp+4], edx
	mov	eax, DWORD PTR $T247597[ebp]
	mov	DWORD PTR $T247671[ebp], eax
	mov	ecx, DWORD PTR $T247598[ebp]
	mov	DWORD PTR $T247670[ebp], ecx
	mov	edx, DWORD PTR $T247670[ebp]
	mov	DWORD PTR __ChkFirst$247654[ebp], edx
	mov	eax, DWORD PTR $T247671[ebp]
	mov	DWORD PTR __ChkLast$247655[ebp], eax
	jmp	SHORT $LN24@operator@4
$LN18@operator@4:
	mov	ecx, DWORD PTR __ChkFirst$247654[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __ChkFirst$247654[ebp], ecx
$LN24@operator@4:
	mov	edx, DWORD PTR __ChkFirst$247654[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$247655[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@4
	mov	eax, DWORD PTR __ChkFirst$247654[ebp]
	mov	DWORD PTR $T247652[ebp], eax
	mov	ecx, DWORD PTR $T247652[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247672[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingYieldChange@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@4
$LN17@operator@4:
	mov	eax, DWORD PTR $T247672[ebp]
	mov	DWORD PTR $T247599[ebp], eax
	mov	ecx, DWORD PTR $T247672[ebp+4]
	mov	DWORD PTR $T247599[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6UBuildingYieldChange@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ENDP ; operator<<<BuildingYieldChange>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z:PROC ; operator<<
; Function compile flags: /Odtp
;	COMDAT ??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z
_TEXT	SEGMENT
$T247751 = -68						; size = 8
$T247750 = -60						; size = 4
$T247749 = -56						; size = 4
$T247731 = -52						; size = 4
__ChkFirst$247733 = -48					; size = 4
__ChkLast$247734 = -44					; size = 4
$T247708 = -40						; size = 4
$T247699 = -36						; size = 4
$T247687 = -32						; size = 4
$T247690 = -28						; size = 4
$T247678 = -24						; size = 8
$T247677 = -16						; size = 4
$T247676 = -12						; size = 4
$T247675 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z PROC ; operator<<<BuildingGreatWork>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T247675[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T247675[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR $T247690[ebp], eax
	mov	edx, DWORD PTR $T247675[ebp]
	mov	DWORD PTR $T247687[ebp], edx
	lea	eax, DWORD PTR $T247690[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247687[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T247699[ebp], edx
	mov	eax, DWORD PTR $T247699[ebp]
	mov	DWORD PTR $T247676[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247708[ebp], edx
	mov	eax, DWORD PTR $T247708[ebp]
	mov	DWORD PTR $T247677[ebp], eax
	mov	ecx, DWORD PTR $T247675[ebp]
	mov	DWORD PTR $T247751[ebp], ecx
	mov	edx, DWORD PTR $T247675[ebp+4]
	mov	DWORD PTR $T247751[ebp+4], edx
	mov	eax, DWORD PTR $T247676[ebp]
	mov	DWORD PTR $T247750[ebp], eax
	mov	ecx, DWORD PTR $T247677[ebp]
	mov	DWORD PTR $T247749[ebp], ecx
	mov	edx, DWORD PTR $T247749[ebp]
	mov	DWORD PTR __ChkFirst$247733[ebp], edx
	mov	eax, DWORD PTR $T247750[ebp]
	mov	DWORD PTR __ChkLast$247734[ebp], eax
	jmp	SHORT $LN24@operator@5
$LN18@operator@5:
	mov	ecx, DWORD PTR __ChkFirst$247733[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __ChkFirst$247733[ebp], ecx
$LN24@operator@5:
	mov	edx, DWORD PTR __ChkFirst$247733[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$247734[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@5
	mov	eax, DWORD PTR __ChkFirst$247733[ebp]
	mov	DWORD PTR $T247731[ebp], eax
	mov	ecx, DWORD PTR $T247731[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247751[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABUBuildingGreatWork@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@5
$LN17@operator@5:
	mov	eax, DWORD PTR $T247751[ebp]
	mov	DWORD PTR $T247678[ebp], eax
	mov	ecx, DWORD PTR $T247751[ebp+4]
	mov	DWORD PTR $T247678[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6UBuildingGreatWork@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ENDP ; operator<<<BuildingGreatWork>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T247779 = -26						; size = 1
$T247778 = -25						; size = 1
$T247777 = -24						; size = 4
$T247776 = -20						; size = 4
__Off$247772 = -16					; size = 4
__Result$247773 = -12					; size = 4
__Cat$247764 = -4					; size = 1
$T247761 = -3						; size = 1
$T247760 = -2						; size = 1
$T247759 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvBuildingEntry * *,CvBuildingEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T247759[ebp], al
	mov	cl, BYTE PTR __Cat$247764[ebp]
	mov	BYTE PTR $T247760[ebp], cl
	mov	dl, BYTE PTR $T247759[ebp]
	mov	BYTE PTR $T247779[ebp], dl
	mov	al, BYTE PTR $T247761[ebp]
	mov	BYTE PTR $T247778[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T247777[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247776[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T247776[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$247772[ebp], eax
	mov	ecx, DWORD PTR __Off$247772[ebp]
	mov	edx, DWORD PTR $T247777[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$247773[ebp], eax
	cmp	DWORD PTR __Off$247772[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$247772[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T247776[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$247772[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T247777[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$247773[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvBuildingEntry@@PAPAV1@@stdext@@YAPAPAVCvBuildingEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvBuildingEntry * *,CvBuildingEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T247786 = -16						; size = 4
$T247782 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvBuildingEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247786[ebp], 0
	lea	eax, DWORD PTR $T247786[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247782[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247782[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247782[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvBuildingEntry@@@std@@YAPAPAVCvBuildingEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvBuildingEntry *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T247800 = -16						; size = 4
$T247796 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z PROC ; std::_Allocate<enum BuildingTypes>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247800[ebp], 0
	lea	eax, DWORD PTR $T247800[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247796[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247796[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247796[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum BuildingTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z
_TEXT	SEGMENT
$T247807 = -16						; size = 4
$T247803 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z PROC ; std::_Allocate<BuildingYieldChange>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247807[ebp], 0
	lea	eax, DWORD PTR $T247807[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247803[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247803[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247803[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UBuildingYieldChange@@@std@@YAPAUBuildingYieldChange@@IPAU1@@Z ENDP ; std::_Allocate<BuildingYieldChange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z
_TEXT	SEGMENT
$T247814 = -16						; size = 4
$T247810 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z PROC ; std::_Allocate<BuildingGreatWork>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247814[ebp], 0
	lea	eax, DWORD PTR $T247814[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247810[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247810[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247810[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UBuildingGreatWork@@@std@@YAPAUBuildingGreatWork@@IPAU1@@Z ENDP ; std::_Allocate<BuildingGreatWork>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T247821 = -16						; size = 4
$T247817 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247821[ebp], 0
	lea	eax, DWORD PTR $T247821[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247817[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247817[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247817[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@U?$less@H@2@V?$allocator@U?$pair@$$CBHV?$map@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >,std::less<int>,std::allocator<std::pair<int const ,std::map<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > > > >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T247828 = -16						; size = 4
$T247824 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T247828[ebp], 0
	lea	eax, DWORD PTR $T247828[ebp]
	push	eax
	lea	ecx, DWORD PTR $T247824[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T247824[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T247824[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T247856 = -2092					; size = 4
$T247855 = -2088					; size = 4
$T247854 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T247854[ebp], eax
	mov	ecx, DWORD PTR $T247854[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T247855[ebp], eax
	mov	eax, DWORD PTR $T247855[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T247856[ebp], eax
	mov	ecx, DWORD PTR $T247856[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z
_TEXT	SEGMENT
$T247890 = -48						; size = 4
$T247874 = -44						; size = 4
$T248028 = -40						; size = 4
$T248027 = -36						; size = 4
$T248026 = -32						; size = 4
$T248025 = -28						; size = 4
$T248024 = -24						; size = 4
_v$223997 = -20						; size = 12
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T247874[ebp], ecx
	mov	edx, DWORD PTR $T247874[ebp]
	mov	DWORD PTR $T248025[ebp], edx
	mov	eax, DWORD PTR $T248025[ebp]
	mov	DWORD PTR $T248024[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T247890[ebp], edx
	mov	eax, DWORD PTR $T247890[ebp]
	mov	DWORD PTR $T248027[ebp], eax
	mov	ecx, DWORD PTR $T248027[ebp]
	mov	DWORD PTR $T248026[ebp], ecx
	mov	edx, DWORD PTR $T248024[ebp]
	push	edx
	mov	eax, DWORD PTR $T248026[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248028[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@V?$_Vector_const_iterator@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@2@0@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT

; 89   : 	{
; 90   : 		ElementType v;

	mov	DWORD PTR _v$223997[ebp], -1
	mov	DWORD PTR _v$223997[ebp+4], -1
	mov	DWORD PTR _v$223997[ebp+8], 0

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$223997[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAUBuildingYieldChange@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$223997[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@QAEXABUBuildingYieldChange@@@Z ; std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT
$LN4@SerializeT:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@UBuildingYieldChange@@V?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingYieldChange@@V?$allocator@UBuildingYieldChange@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<BuildingYieldChange,std::vector<BuildingYieldChange,std::allocator<BuildingYieldChange> > >
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z:PROC ; operator>>
; Function compile flags: /Odtp
;	COMDAT ??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z
_TEXT	SEGMENT
$T248197 = -48						; size = 4
$T248181 = -44						; size = 4
$T248336 = -40						; size = 4
$T248335 = -36						; size = 4
$T248334 = -32						; size = 4
$T248333 = -28						; size = 4
$T248332 = -24						; size = 4
_v$224007 = -20						; size = 12
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T248181[ebp], ecx
	mov	edx, DWORD PTR $T248181[ebp]
	mov	DWORD PTR $T248333[ebp], edx
	mov	eax, DWORD PTR $T248333[ebp]
	mov	DWORD PTR $T248332[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T248197[ebp], edx
	mov	eax, DWORD PTR $T248197[ebp]
	mov	DWORD PTR $T248335[ebp], eax
	mov	ecx, DWORD PTR $T248335[ebp]
	mov	DWORD PTR $T248334[ebp], ecx
	mov	edx, DWORD PTR $T248332[ebp]
	push	edx
	mov	eax, DWORD PTR $T248334[ebp]
	push	eax
	lea	ecx, DWORD PTR $T248336[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAE?AV?$_Vector_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@V?$_Vector_const_iterator@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@2@0@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@2
$LN2@SerializeT@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT@2:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@2

; 89   : 	{
; 90   : 		ElementType v;

	mov	DWORD PTR _v$224007[ebp], -1
	mov	DWORD PTR _v$224007[ebp+4], -1
	mov	DWORD PTR _v$224007[ebp+8], -1

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$224007[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAUBuildingGreatWork@@@Z ; operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$224007[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@QAEXABUBuildingGreatWork@@@Z ; std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT@2
$LN4@SerializeT@2:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@UBuildingGreatWork@@V?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UBuildingGreatWork@@V?$allocator@UBuildingGreatWork@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<BuildingGreatWork,std::vector<BuildingGreatWork,std::allocator<BuildingGreatWork> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T248497 = -28						; size = 4
__Vptr$248495 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$248495[ebp], eax
	mov	ecx, DWORD PTR __Vptr$248495[ebp]
	mov	DWORD PTR $T248497[ebp], ecx
	cmp	DWORD PTR $T248497[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T248497[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T248497[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUBuildingYieldChange@@IU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAXPAUBuildingYieldChange@@IABU1@AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<BuildingYieldChange *,unsigned int,BuildingYieldChange,std::allocator<BuildingYieldChange> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T248547 = -28						; size = 4
__Vptr$248545 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$248545[ebp], eax
	mov	ecx, DWORD PTR __Vptr$248545[ebp]
	mov	DWORD PTR $T248547[ebp], ecx
	cmp	DWORD PTR $T248547[ebp], 0
	je	SHORT $LN18@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T248547[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T248547[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil@2
$LN18@Uninit_fil@2:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil@2:
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUBuildingGreatWork@@IU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAXPAUBuildingGreatWork@@IABU1@AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<BuildingGreatWork *,unsigned int,BuildingGreatWork,std::allocator<BuildingGreatWork> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z
_TEXT	SEGMENT
__Cat$248576 = -3					; size = 1
$T248572 = -2						; size = 1
$T248571 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T248571[ebp], al
	mov	cl, BYTE PTR __Cat$248576[ebp]
	mov	BYTE PTR $T248572[ebp], cl
	movzx	edx, BYTE PTR $T248571[ebp]
	push	edx
	movzx	eax, BYTE PTR $T248572[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@stdext@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z
_TEXT	SEGMENT
__Cat$248584 = -3					; size = 1
$T248580 = -2						; size = 1
$T248579 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T248579[ebp], al
	mov	cl, BYTE PTR __Cat$248584[ebp]
	mov	BYTE PTR $T248580[ebp], cl
	movzx	edx, BYTE PTR $T248579[ebp]
	push	edx
	movzx	eax, BYTE PTR $T248580[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@stdext@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T248611 = -28						; size = 4
__Vptr$248609 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$248609[ebp], ecx
	mov	edx, DWORD PTR __Vptr$248609[ebp]
	mov	DWORD PTR $T248611[ebp], edx
	cmp	DWORD PTR $T248611[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T248611[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T248611[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUBuildingYieldChange@@PAU1@V?$allocator@UBuildingYieldChange@@@std@@@std@@YAPAUBuildingYieldChange@@PAU1@00AAV?$allocator@UBuildingYieldChange@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<BuildingYieldChange *,BuildingYieldChange *,std::allocator<BuildingYieldChange> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T248661 = -28						; size = 4
__Vptr$248659 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$248659[ebp], ecx
	mov	edx, DWORD PTR __Vptr$248659[ebp]
	mov	DWORD PTR $T248661[ebp], edx
	cmp	DWORD PTR $T248661[ebp], 0
	je	SHORT $LN18@Uninit_cop@2
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T248661[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T248661[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop@2
$LN18@Uninit_cop@2:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop@2:
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUBuildingGreatWork@@PAU1@V?$allocator@UBuildingGreatWork@@@std@@@std@@YAPAUBuildingGreatWork@@PAU1@00AAV?$allocator@UBuildingGreatWork@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<BuildingGreatWork *,BuildingGreatWork *,std::allocator<BuildingGreatWork> >
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
_TEXT	ENDS
;	COMDAT ??0CvThemingBonusInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T248695 = -4						; size = 4
??0CvThemingBonusInfo@@QAE@XZ PROC			; CvThemingBonusInfo::CvThemingBonusInfo, COMDAT
; _this$ = ecx

; 37   : 	  {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T248695[ebp], ecx
	mov	ecx, DWORD PTR $T248695[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+33], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+34], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+35], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+36], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+37], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+38], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+39], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+40], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 38   : 
; 39   : 	  };

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvThemingBonusInfo@@QAE@XZ ENDP			; CvThemingBonusInfo::CvThemingBonusInfo
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
