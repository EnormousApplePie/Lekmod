; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvCityManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear
PUBLIC	?Reset@CvCityManager@@SAXXZ			; CvCityManager::Reset
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
;	COMDAT ?Reset@CvCityManager@@SAXXZ
_TEXT	SEGMENT
?Reset@CvCityManager@@SAXXZ PROC			; CvCityManager::Reset, COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 22   : 	ms_kCityMap.clear();

	mov	ecx, OFFSET _ms_kCityMap
	call	?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear

; 23   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvCityManager@@SAXXZ ENDP			; CvCityManager::Reset
_TEXT	ENDS
PUBLIC	?Shutdown@CvCityManager@@SAXXZ			; CvCityManager::Shutdown
; Function compile flags: /Odtp
;	COMDAT ?Shutdown@CvCityManager@@SAXXZ
_TEXT	SEGMENT
?Shutdown@CvCityManager@@SAXXZ PROC			; CvCityManager::Shutdown, COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 28   : 	ms_kCityMap.clear();

	mov	ecx, OFFSET _ms_kCityMap
	call	?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear

; 29   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Shutdown@CvCityManager@@SAXXZ ENDP			; CvCityManager::Shutdown
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
PUBLIC	??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::~pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
PUBLIC	?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve
PUBLIC	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert
PUBLIC	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
PUBLIC	?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z	; CvCityManager::OnCityCreated
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z$3
__ehfuncinfo$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
xdata$x	ENDS
;	COMDAT ?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
_TEXT	SEGMENT
tv198 = -192						; size = 4
$T220821 = -188						; size = 4
$T220793 = -184						; size = 4
$T220780 = -180						; size = 4
$T220735 = -176						; size = 4
$T220578 = -100						; size = 4
$T220569 = -96						; size = 4
$T220501 = -92						; size = 4
$T220473 = -88						; size = 4
$T220460 = -84						; size = 4
$T220453 = -80						; size = 4
$T220452 = -76						; size = 20
$T220451 = -56						; size = 4
_pkCity$218425 = -52					; size = 4
_itr$218419 = -48					; size = 4
_kCityList$218376 = -44					; size = 4
_pkCity$218346 = -40					; size = 4
_itr$218340 = -36					; size = 4
_kResult$ = -32						; size = 8
_iFromY$ = -24						; size = 4
_iFromX$ = -20						; size = 4
_kCityList$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pkAddCity$ = 8						; size = 4
?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z PROC	; CvCityManager::OnCityCreated, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 64   : 	// First add it to all the other city lists
; 65   : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T220460[ebp], eax
	mov	ecx, DWORD PTR $T220460[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T220473[ebp], edx
	mov	eax, DWORD PTR $T220473[ebp]
	mov	DWORD PTR _itr$218340[ebp], eax
	jmp	SHORT $LN8@OnCityCrea
$LN7@OnCityCrea:
	lea	ecx, DWORD PTR _itr$218340[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
$LN8@OnCityCrea:
	mov	ecx, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T220501[ebp], ecx
	mov	edx, DWORD PTR $T220501[ebp]
	mov	DWORD PTR $T220451[ebp], edx
	mov	eax, DWORD PTR _itr$218340[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T220451[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN6@OnCityCrea

; 66   : 	{
; 67   : 		CvCity* pkCity = (*itr).first;

	mov	ecx, DWORD PTR _itr$218340[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _pkCity$218346[ebp], edx

; 68   : 		if ((*itr).first != pkAddCity)		// It should not be in there, but check anyhow

	mov	eax, DWORD PTR _itr$218340[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _pkAddCity$[ebp]
	je	SHORT $LN5@OnCityCrea

; 69   : 		{
; 70   : 			CityList &kCityList = (*itr).second;

	mov	edx, DWORD PTR _itr$218340[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _kCityList$218376[ebp], edx

; 71   : 
; 72   : 			AddToSortedList(kCityList, pkCity->getX(), pkCity->getY(), pkAddCity);

	mov	eax, DWORD PTR _pkCity$218346[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T220569[ebp], ecx
	mov	edx, DWORD PTR _pkCity$218346[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T220578[ebp], eax
	mov	ecx, DWORD PTR _pkAddCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220569[ebp]
	push	edx
	mov	eax, DWORD PTR $T220578[ebp]
	push	eax
	mov	ecx, DWORD PTR _kCityList$218376[ebp]
	push	ecx
	call	?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z ; AddToSortedList
	add	esp, 16					; 00000010H
$LN5@OnCityCrea:

; 73   : 		}
; 74   : 	}

	jmp	SHORT $LN7@OnCityCrea
$LN6@OnCityCrea:

; 75   : 
; 76   : 	// Then make a list for it
; 77   : 	std::pair<CityMap::iterator, bool> kResult = ms_kCityMap.insert(CityMap::value_type(pkAddCity, ms_kEmptyList));

	mov	edx, DWORD PTR _pkAddCity$[ebp]
	mov	DWORD PTR $T220452[ebp], edx
	push	OFFSET _ms_kEmptyList
	lea	ecx, DWORD PTR $T220452[ebp+4]
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	lea	eax, DWORD PTR $T220452[ebp]
	mov	DWORD PTR tv198[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv198[ebp]
	push	ecx
	lea	edx, DWORD PTR _kResult$[ebp]
	push	edx
	mov	ecx, OFFSET _ms_kCityMap
	call	?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	eax, DWORD PTR $T220452[ebp+4]
	mov	DWORD PTR $T220735[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T220735[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 78   : 
; 79   : 	CityList& kCityList = (*kResult.first).second;

	mov	ecx, DWORD PTR _kResult$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _kCityList$[ebp], ecx

; 80   : 	kCityList.reserve(256);		// Reserving an arbitrary number of cities.  Large games can probably have more than this, but this is a good middle ground.

	push	256					; 00000100H
	mov	ecx, DWORD PTR _kCityList$[ebp]
	call	?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve

; 81   : 
; 82   : 	// Instead of adding all the cities, then sorting the list, this will add them to their correctly sorted position one at a time.
; 83   : 	// This might be a tad slower, but city creation is not happening all the time and if we did the sort, the list would have to store the distance
; 84   : 	int iFromX = pkAddCity->getX();

	mov	edx, DWORD PTR _pkAddCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _iFromX$[ebp], eax

; 85   : 	int iFromY = pkAddCity->getY();

	mov	ecx, DWORD PTR _pkAddCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _iFromY$[ebp], edx

; 86   : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T220780[ebp], eax
	mov	ecx, DWORD PTR $T220780[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T220793[ebp], edx
	mov	eax, DWORD PTR $T220793[ebp]
	mov	DWORD PTR _itr$218419[ebp], eax
	jmp	SHORT $LN4@OnCityCrea
$LN3@OnCityCrea:
	lea	ecx, DWORD PTR _itr$218419[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
$LN4@OnCityCrea:
	mov	ecx, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T220821[ebp], ecx
	mov	edx, DWORD PTR $T220821[ebp]
	mov	DWORD PTR $T220453[ebp], edx
	mov	eax, DWORD PTR _itr$218419[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T220453[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN9@OnCityCrea

; 87   : 	{
; 88   : 		CvCity* pkCity = (*itr).first;

	mov	ecx, DWORD PTR _itr$218419[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _pkCity$218425[ebp], edx

; 89   : 		if ((*itr).first != pkAddCity)

	mov	eax, DWORD PTR _itr$218419[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _pkAddCity$[ebp]
	je	SHORT $LN1@OnCityCrea

; 90   : 		{
; 91   : 			AddToSortedList(kCityList, iFromX, iFromY, pkCity);

	mov	edx, DWORD PTR _pkCity$218425[ebp]
	push	edx
	mov	eax, DWORD PTR _iFromY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFromX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kCityList$[ebp]
	push	edx
	call	?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z ; AddToSortedList
	add	esp, 16					; 00000010H
$LN1@OnCityCrea:

; 92   : 		}

	jmp	SHORT $LN3@OnCityCrea
$LN9@OnCityCrea:

; 93   : 	}
; 94   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z$0:
	lea	ecx, DWORD PTR $T220452[ebp]
	jmp	??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z$3:
	mov	ecx, DWORD PTR $T220735[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-184]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?OnCityCreated@CvCityManager@@SAXPAVCvCity@@@Z ENDP	; CvCityManager::OnCityCreated
PUBLIC	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
; Function compile flags: /Odtp
;	COMDAT ?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z
_TEXT	SEGMENT
$T221048 = -124						; size = 4
$T221039 = -120						; size = 4
$T221008 = -116						; size = 4
$T220984 = -112						; size = 4
$T220937 = -64						; size = 4
$T220928 = -60						; size = 4
$T220881 = -32						; size = 4
$T220880 = -28						; size = 4
$T220879 = -24						; size = 4
_iDistance$218238 = -20					; size = 4
_pkNearbyCity$218237 = -16				; size = 4
_itrNearby$218231 = -12					; size = 4
_bAdded$218083 = -5					; size = 1
_iAddDistance$218082 = -4				; size = 4
_kCityList$ = 8						; size = 4
_iFromX$ = 12						; size = 4
_iFromY$ = 16						; size = 4
_pkAddCity$ = 20					; size = 4
?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z PROC ; AddToSortedList, COMDAT

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H

; 34   : 	if (kCityList.size() == 0)

	mov	eax, DWORD PTR _kCityList$[ebp]
	mov	ecx, DWORD PTR _kCityList$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN32@AddToSorte

; 35   : 	{
; 36   : 		// First one
; 37   : 		kCityList.push_back(pkAddCity);

	lea	eax, DWORD PTR _pkAddCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kCityList$[ebp]
	call	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back

; 38   : 	}
; 39   : 	else

	jmp	$LN8@AddToSorte

; 40   : 	{
; 41   : 		// Add to the pre-sorted list.
; 42   : 		int iAddDistance = plotDistance(iFromX, iFromY, pkAddCity->getX(), pkAddCity->getY());

$LN32@AddToSorte:
	mov	ecx, DWORD PTR _pkAddCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T220928[ebp], edx
	mov	eax, DWORD PTR _pkAddCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T220937[ebp], ecx
	mov	edx, DWORD PTR $T220928[ebp]
	push	edx
	mov	eax, DWORD PTR $T220937[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFromY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFromX$[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iAddDistance$218082[ebp], eax

; 43   : 		bool bAdded = false;

	mov	BYTE PTR _bAdded$218083[ebp], 0

; 44   : 		for (CvCityManager::CityList::iterator itrNearby = kCityList.begin(); itrNearby != kCityList.end(); ++itrNearby)

	mov	eax, DWORD PTR _kCityList$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220984[ebp], ecx
	mov	edx, DWORD PTR $T220984[ebp]
	mov	DWORD PTR _itrNearby$218231[ebp], edx
	jmp	SHORT $LN5@AddToSorte
$LN4@AddToSorte:
	mov	eax, DWORD PTR _itrNearby$218231[ebp]
	add	eax, 4
	mov	DWORD PTR _itrNearby$218231[ebp], eax
$LN5@AddToSorte:
	mov	ecx, DWORD PTR _kCityList$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221008[ebp], edx
	mov	eax, DWORD PTR $T221008[ebp]
	mov	DWORD PTR $T220879[ebp], eax
	mov	ecx, DWORD PTR _itrNearby$218231[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T220879[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@AddToSorte

; 45   : 		{
; 46   : 			CvCity* pkNearbyCity = (*itrNearby);

	mov	edx, DWORD PTR _itrNearby$218231[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pkNearbyCity$218237[ebp], eax

; 47   : 			int iDistance = plotDistance(iFromX, iFromY, pkNearbyCity->getX(), pkNearbyCity->getY());

	mov	ecx, DWORD PTR _pkNearbyCity$218237[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T221039[ebp], edx
	mov	eax, DWORD PTR _pkNearbyCity$218237[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T221048[ebp], ecx
	mov	edx, DWORD PTR $T221039[ebp]
	push	edx
	mov	eax, DWORD PTR $T221048[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFromY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFromX$[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$218238[ebp], eax

; 48   : 			if (iAddDistance <= iDistance)

	mov	eax, DWORD PTR _iAddDistance$218082[ebp]
	cmp	eax, DWORD PTR _iDistance$218238[ebp]
	jg	SHORT $LN2@AddToSorte

; 49   : 			{
; 50   : 				kCityList.insert(itrNearby, pkAddCity);

	mov	ecx, DWORD PTR _itrNearby$218231[ebp]
	mov	DWORD PTR $T220880[ebp], ecx
	lea	edx, DWORD PTR _pkAddCity$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220880[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220881[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kCityList$[ebp]
	call	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert

; 51   : 				bAdded = true;

	mov	BYTE PTR _bAdded$218083[ebp], 1

; 52   : 				break;

	jmp	SHORT $LN3@AddToSorte
$LN2@AddToSorte:

; 53   : 			}
; 54   : 		}

	jmp	$LN4@AddToSorte
$LN3@AddToSorte:

; 55   : 
; 56   : 		if (!bAdded)

	movzx	edx, BYTE PTR _bAdded$218083[ebp]
	test	edx, edx
	jne	SHORT $LN8@AddToSorte

; 57   : 			kCityList.push_back(pkAddCity);

	lea	eax, DWORD PTR _pkAddCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kCityList$[ebp]
	call	?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
$LN8@AddToSorte:

; 58   : 	}
; 59   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddToSortedList@@YAXAAV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@HHPAVCvCity@@@Z ENDP ; AddToSortedList
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T221393 = -80						; size = 4
$T221367 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T221367[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T221367[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T221367[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T221393[ebp], edx
	mov	eax, DWORD PTR $T221393[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T221417 = -16						; size = 4
$T221409 = -12						; size = 4
$T221405 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T221405[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T221409[ebp], ecx
	movzx	edx, BYTE PTR $T221405[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T221409[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T221409[ebp]
	mov	DWORD PTR $T221417[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T221409[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T221409[ebp]
	mov	DWORD PTR $T221417[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T221417[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T221417[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T221438 = -16						; size = 4
$T221430 = -12						; size = 4
$T221426 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T221426[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T221430[ebp], ecx
	movzx	edx, BYTE PTR $T221426[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T221430[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T221430[ebp]
	mov	DWORD PTR $T221438[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T221430[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T221430[ebp]
	mov	DWORD PTR $T221438[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T221438[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T221438[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T221497 = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ PROC ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::~pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T221497[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T221497[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR $T221497[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >::~pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find
PUBLIC	?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::erase
PUBLIC	?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z ; CvCityManager::OnCityDestroyed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
;	COMDAT ?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z
_TEXT	SEGMENT
$T221820 = -140						; size = 4
$T221637 = -64						; size = 4
$T221613 = -60						; size = 4
$T221559 = -56						; size = 4
$T221531 = -52						; size = 4
$T221518 = -48						; size = 4
$T221512 = -44						; size = 4
$T221511 = -40						; size = 4
$T221510 = -36						; size = 4
$T221509 = -32						; size = 4
$T221508 = -28						; size = 4
$T221507 = -24						; size = 4
$T221506 = -20						; size = 4
_itrNearby$218440 = -16					; size = 4
_kCityList$218439 = -12					; size = 4
_itr$218432 = -8					; size = 4
_itr$ = -4						; size = 4
_pkCity$ = 8						; size = 4
?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z PROC	; CvCityManager::OnCityDestroyed, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH

; 99   : 	// Remove it from all the other city lists
; 100  : 	for (CityMap::iterator itr = ms_kCityMap.begin(); itr != ms_kCityMap.end(); ++itr)

	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T221518[ebp], eax
	mov	ecx, DWORD PTR $T221518[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T221531[ebp], edx
	mov	eax, DWORD PTR $T221531[ebp]
	mov	DWORD PTR _itr$218432[ebp], eax
	jmp	SHORT $LN9@OnCityDest
$LN8@OnCityDest:
	lea	ecx, DWORD PTR _itr$218432[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
$LN9@OnCityDest:
	mov	ecx, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T221559[ebp], ecx
	mov	edx, DWORD PTR $T221559[ebp]
	mov	DWORD PTR $T221506[ebp], edx
	mov	eax, DWORD PTR _itr$218432[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T221506[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN7@OnCityDest

; 101  : 	{
; 102  : 		if ((*itr).first != pkCity)

	mov	ecx, DWORD PTR _itr$218432[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _pkCity$[ebp]
	je	SHORT $LN6@OnCityDest

; 103  : 		{
; 104  : 			CityList &kCityList = (*itr).second;

	mov	eax, DWORD PTR _itr$218432[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _kCityList$218439[ebp], eax

; 105  : 			for (CityList::iterator itrNearby = kCityList.begin(); itrNearby != kCityList.end(); ++itrNearby)

	mov	ecx, DWORD PTR _kCityList$218439[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221613[ebp], edx
	mov	eax, DWORD PTR $T221613[ebp]
	mov	DWORD PTR _itrNearby$218440[ebp], eax
	jmp	SHORT $LN5@OnCityDest
$LN4@OnCityDest:
	mov	ecx, DWORD PTR _itrNearby$218440[ebp]
	add	ecx, 4
	mov	DWORD PTR _itrNearby$218440[ebp], ecx
$LN5@OnCityDest:
	mov	edx, DWORD PTR _kCityList$218439[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T221637[ebp], eax
	mov	ecx, DWORD PTR $T221637[ebp]
	mov	DWORD PTR $T221507[ebp], ecx
	mov	edx, DWORD PTR _itrNearby$218440[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T221507[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN6@OnCityDest

; 106  : 			{
; 107  : 				if ((*itrNearby) == pkCity)

	mov	eax, DWORD PTR _itrNearby$218440[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pkCity$[ebp]
	jne	SHORT $LN2@OnCityDest

; 108  : 				{
; 109  : 					kCityList.erase(itrNearby);

	mov	edx, DWORD PTR _itrNearby$218440[ebp]
	mov	DWORD PTR $T221508[ebp], edx
	mov	eax, DWORD PTR $T221508[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221509[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kCityList$218439[ebp]
	call	?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::erase

; 110  : 					break;

	jmp	SHORT $LN6@OnCityDest
$LN2@OnCityDest:

; 111  : 				}
; 112  : 			}

	jmp	SHORT $LN4@OnCityDest
$LN6@OnCityDest:

; 113  : 		}
; 114  : 	}

	jmp	$LN8@OnCityDest
$LN7@OnCityDest:

; 115  : 
; 116  : 	// Then remove its list
; 117  : 	CityMap::iterator itr = ms_kCityMap.find(pkCity);

	lea	edx, DWORD PTR _pkCity$[ebp]
	push	edx
	lea	eax, DWORD PTR _itr$[ebp]
	push	eax
	mov	ecx, OFFSET _ms_kCityMap
	call	?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find

; 118  : 	if (itr != ms_kCityMap.end())

	mov	ecx, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T221820[ebp], ecx
	mov	edx, DWORD PTR $T221820[ebp]
	mov	DWORD PTR $T221510[ebp], edx
	mov	eax, DWORD PTR _itr$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T221510[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN10@OnCityDest

; 119  : 	{
; 120  : 		ms_kCityMap.erase(itr);

	mov	ecx, DWORD PTR _itr$[ebp]
	mov	DWORD PTR $T221511[ebp], ecx
	mov	edx, DWORD PTR $T221511[ebp]
	push	edx
	lea	eax, DWORD PTR $T221512[ebp]
	push	eax
	mov	ecx, OFFSET _ms_kCityMap
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
$LN10@OnCityDest:

; 121  : 	}
; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OnCityDestroyed@CvCityManager@@SAXPAVCvCity@@@Z ENDP	; CvCityManager::OnCityDestroyed
_TEXT	ENDS
PUBLIC	?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z ; CvCityManager::GetNearbyCities
; Function compile flags: /Odtp
;	COMDAT ?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T221925 = -48						; size = 4
$T221838 = -12						; size = 4
$T221837 = -8						; size = 4
_itr$218459 = -4					; size = 4
_pkCity$ = 8						; size = 4
?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z PROC ; CvCityManager::GetNearbyCities, COMDAT

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 127  : 	CvAssert(pkCity);
; 128  : 	if (pkCity)

	cmp	DWORD PTR _pkCity$[ebp], 0
	je	SHORT $LN2@GetNearbyC

; 129  : 	{
; 130  : 		CityMap::const_iterator itr = ms_kCityMap.find(pkCity);

	lea	eax, DWORD PTR _pkCity$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221837[ebp]
	push	ecx
	mov	ecx, OFFSET _ms_kCityMap
	call	?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _itr$218459[ebp], edx

; 131  : 
; 132  : 		CvAssert(itr != ms_kCityMap.end());
; 133  : 		if (itr != ms_kCityMap.end())

	mov	eax, DWORD PTR _ms_kCityMap+4
	mov	DWORD PTR $T221925[ebp], eax
	mov	ecx, DWORD PTR $T221925[ebp]
	mov	DWORD PTR $T221838[ebp], ecx
	mov	edx, DWORD PTR _itr$218459[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T221838[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@GetNearbyC

; 134  : 		{
; 135  : 			return (*itr).second;

	mov	eax, DWORD PTR _itr$218459[ebp]
	add	eax, 16					; 00000010H
	jmp	SHORT $LN3@GetNearbyC
$LN2@GetNearbyC:

; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 	// This should not happen, but I wont' assume.
; 140  : 	return ms_kEmptyList;

	mov	eax, OFFSET _ms_kEmptyList
$LN3@GetNearbyC:

; 141  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNearbyCities@CvCityManager@@SAABV?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAVCvCity@@@Z ENDP ; CvCityManager::GetNearbyCities
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T222083 = -148						; size = 4
$T222063 = -144						; size = 4
$T222048 = -140						; size = 4
$T222031 = -136						; size = 4
$T222018 = -132						; size = 4
$T222004 = -128						; size = 4
$T221959 = -45						; size = 1
$T221958 = -44						; size = 4
$T221957 = -37						; size = 1
$T221956 = -36						; size = 4
$T221955 = -29						; size = 1
$T221954 = -28						; size = 4
$T221953 = -24						; size = 4
$T221952 = -17						; size = 1
__Where$218491 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN9@insert

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert
$LN33@insert:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert
$LN9@insert:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T221952[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221953[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
	mov	DWORD PTR $T222004[ebp], eax
	mov	edx, DWORD PTR $T222004[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T221952[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 644  : 		else

	jmp	$LN11@insert
$LN8@insert:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$218491[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert
	jmp	$LN79@insert
$LN6@insert:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222018[ebp], ecx
	mov	edx, DWORD PTR $T222018[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222031[ebp], eax
	mov	ecx, DWORD PTR $T222031[ebp]
	mov	DWORD PTR $T221954[ebp], ecx
	mov	edx, DWORD PTR __Where$218491[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T221954[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T221955[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T221956[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
	mov	DWORD PTR $T222048[ebp], eax
	mov	edx, DWORD PTR $T222048[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T221955[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 651  : 			else

	jmp	SHORT $LN79@insert
$LN4@insert:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$218491[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert:
	mov	ecx, DWORD PTR __Where$218491[ebp]
	mov	DWORD PTR $T222063[ebp], ecx
	mov	edx, DWORD PTR $T222063[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T221957[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221958[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
	mov	DWORD PTR $T222083[ebp], eax
	mov	edx, DWORD PTR $T222083[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T221957[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert

; 657  : 			else

	jmp	SHORT $LN11@insert
$LN2@insert:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T221959[ebp], 0
	mov	ecx, DWORD PTR __Where$218491[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T221959[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@_N@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$4
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -252						; size = 4
tv165 = -248						; size = 4
_this$ = -244						; size = 4
$T223066 = -240						; size = 4
$T223061 = -236						; size = 4
$T222990 = -232						; size = 4
$T222981 = -228						; size = 4
$T222346 = -136						; size = 4
$T222345 = -132						; size = 4
__Tmp$222344 = -125					; size = 1
$T222321 = -124						; size = 4
$T222314 = -120						; size = 4
$T222244 = -116						; size = 4
$T222208 = -112						; size = 4
$T222203 = -108						; size = 4
$T222175 = -104						; size = 4
$T222099 = -100						; size = 4
$T222090 = -96						; size = 28
$T222089 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222099[ebp], eax
	mov	ecx, DWORD PTR $T222099[ebp]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN55@erase

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T222090[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T222090[ebp]
	push	eax
	lea	ecx, DWORD PTR $T222089[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T222089[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T222089[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T222090[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN67@erase

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN71@erase

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN81@erase

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222175[ebp], ecx
	mov	edx, DWORD PTR $T222175[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN43@erase
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase
$LN43@erase:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T222203[ebp], ecx
$LN107@erase:
	mov	edx, DWORD PTR $T222203[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN103@erase
	mov	edx, DWORD PTR $T222203[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222203[ebp], eax
	jmp	SHORT $LN107@erase
$LN103@erase:
	mov	ecx, DWORD PTR $T222203[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T222208[ebp], eax
	mov	ecx, DWORD PTR $T222208[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	je	SHORT $LN45@erase
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase
$LN45@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T222244[ebp], eax
$LN127@erase:
	mov	ecx, DWORD PTR $T222244[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN123@erase
	mov	ecx, DWORD PTR $T222244[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T222244[ebp], edx
	jmp	SHORT $LN127@erase
$LN123@erase:
	mov	eax, DWORD PTR $T222244[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN151@erase

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222314[ebp], ecx
	mov	edx, DWORD PTR $T222314[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T222321[ebp], edx
	mov	eax, DWORD PTR $T222321[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR $T222346[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T222345[ebp], eax
	mov	ecx, DWORD PTR $T222345[ebp]
	cmp	ecx, DWORD PTR $T222346[ebp]
	je	SHORT $LN192@erase
	mov	edx, DWORD PTR $T222345[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$222344[ebp], al
	mov	ecx, DWORD PTR $T222345[ebp]
	mov	edx, DWORD PTR $T222346[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T222346[ebp]
	mov	dl, BYTE PTR __Tmp$222344[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	$LN595@erase

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase
$LN194@erase:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	cmp	edx, 1
	jne	$LN586@erase

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN263@erase

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN267@erase

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN277@erase
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN277@erase

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+32], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+32]
	cmp	eax, 1
	jne	SHORT $LN338@erase

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+32], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+32]
	mov	BYTE PTR [ecx+32], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+32], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase
$LN12@erase:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN454@erase

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN458@erase

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN468@erase
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+32]
	cmp	ecx, 1
	jne	SHORT $LN468@erase

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+32], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+32]
	cmp	eax, 1
	jne	SHORT $LN529@erase

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+32], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+32], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+32]
	mov	BYTE PTR [ecx+32], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+32], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase
$LN8@erase:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+32], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN595@erase:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T222990[ebp], eax
	mov	ecx, DWORD PTR $T222990[ebp]
	add	ecx, 4
	mov	DWORD PTR $T222981[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T222981[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	edx, edx
	and	edx, 1
	je	SHORT $LN588@erase
	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN588@erase:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jbe	SHORT $LN1@erase

; 928  : 			--_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN1@erase:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T223066[ebp], eax
	mov	ecx, DWORD PTR $T223066[ebp]
	mov	DWORD PTR $T223061[ebp], ecx
	mov	edx, DWORD PTR $T223061[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T222090[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$4:
	mov	ecx, DWORD PTR $T222981[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T223235 = -44						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223235[ebp], eax
	mov	ecx, DWORD PTR $T223235[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lbound
; Function compile flags: /Odtp
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z
_TEXT	SEGMENT
tv137 = -48						; size = 4
_this$ = -44						; size = 4
$T223353 = -40						; size = 4
$T223327 = -36						; size = 4
$T223314 = -32						; size = 4
$T223298 = -28						; size = 4
$T223253 = -16						; size = 4
$T223251 = -12						; size = 4
$T223250 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find, COMDAT
; _this$ = ecx

; 977  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lbound
	mov	DWORD PTR $T223298[ebp], eax
	mov	ecx, DWORD PTR $T223298[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223314[ebp], eax
	mov	ecx, DWORD PTR $T223314[ebp]
	mov	DWORD PTR $T223251[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T223251[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T223327[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T223327[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	jmp	SHORT $LN4@find
$LN3@find:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223353[ebp], ecx
	mov	edx, DWORD PTR $T223353[ebp]
	mov	DWORD PTR $T223253[ebp], edx
	lea	eax, DWORD PTR $T223253[ebp]
	mov	DWORD PTR tv137[ebp], eax
$LN4@find:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T223250[ebp], ecx
	mov	edx, DWORD PTR $T223250[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@ABQAVCvCity@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::find
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
PUBLIC	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
PUBLIC	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$4
__ehfuncinfo$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv170 = -200						; size = 4
tv168 = -196						; size = 4
_this$ = -192						; size = 4
$T223551 = -188						; size = 4
$T223550 = -184						; size = 4
$T223546 = -180						; size = 4
$T223545 = -176						; size = 4
$T223534 = -172						; size = 4
$T223533 = -168						; size = 4
__Cat$223540 = -162					; size = 1
$T223538 = -161						; size = 1
$T223508 = -160						; size = 4
$T223507 = -156						; size = 4
$T223488 = -152						; size = 4
$T223471 = -145						; size = 1
$T223470 = -144						; size = 4
$T223460 = -140						; size = 4
$T223459 = -136						; size = 4
__Cat$223503 = -130					; size = 1
$T223500 = -129						; size = 1
$T223499 = -128						; size = 1
__Cat$223496 = -127					; size = 1
$T223493 = -126						; size = 1
$T223491 = -125						; size = 1
$T223429 = -124						; size = 4
$T223413 = -120						; size = 4
__Count$223382 = -36					; size = 4
$T223363 = -32						; size = 4
$T223362 = -28						; size = 4
__Size$218595 = -24					; size = 4
__Ptr$218586 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 184				; 000000b8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	DWORD PTR __Count$223382[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$223382[ebp], 0
	jbe	SHORT $LN16@reserve
	mov	eax, DWORD PTR __Count$223382[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN12@reserve
$LN16@reserve:
	mov	DWORD PTR tv168[ebp], 1
$LN12@reserve:
	mov	ecx, DWORD PTR tv168[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
	jmp	$LN7@reserve
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN26@reserve
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN24@reserve
$LN26@reserve:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR tv170[ebp], edx
$LN24@reserve:
	mov	eax, DWORD PTR tv170[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8
	mov	DWORD PTR __Ptr$218586[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T223413[ebp], eax
	mov	ecx, DWORD PTR $T223413[ebp]
	mov	DWORD PTR $T223362[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223429[ebp], eax
	mov	ecx, DWORD PTR $T223429[ebp]
	mov	DWORD PTR $T223363[ebp], ecx
	mov	edx, DWORD PTR $T223362[ebp]
	mov	DWORD PTR $T223508[ebp], edx
	mov	eax, DWORD PTR $T223363[ebp]
	mov	DWORD PTR $T223507[ebp], eax
	mov	ecx, DWORD PTR __Ptr$218586[ebp]
	mov	DWORD PTR $T223488[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T223491[ebp], dl
	mov	al, BYTE PTR __Cat$223496[ebp]
	mov	BYTE PTR $T223493[ebp], al
	mov	cl, BYTE PTR $T223491[ebp]
	mov	BYTE PTR $T223471[ebp], cl
	mov	edx, DWORD PTR $T223488[ebp]
	mov	DWORD PTR $T223470[ebp], edx
	mov	eax, DWORD PTR $T223470[ebp]
	mov	DWORD PTR $T223460[ebp], eax
	mov	ecx, DWORD PTR $T223507[ebp]
	mov	DWORD PTR $T223459[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T223499[ebp], dl
	mov	al, BYTE PTR __Cat$223503[ebp]
	mov	BYTE PTR $T223500[ebp], al
	movzx	ecx, BYTE PTR $T223499[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T223500[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223460[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223508[ebp]
	push	edx
	mov	eax, DWORD PTR $T223459[ebp]
	push	eax
	call	??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@reserve
__catch$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Ptr$218586[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@reserve
	ret	0
$LN8@reserve:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 615  : 
; 616  : 			size_type _Size = size();

$LN61@reserve:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR __Size$218595[ebp], ecx

; 617  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN1@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T223546[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223545[ebp], eax
	mov	ecx, DWORD PTR $T223546[ebp]
	mov	DWORD PTR $T223534[ebp], ecx
	mov	edx, DWORD PTR $T223545[ebp]
	mov	DWORD PTR $T223533[ebp], edx
	mov	al, BYTE PTR __Cat$223540[ebp]
	mov	BYTE PTR $T223538[ebp], al

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T223551[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T223550[ebp], edx
	mov	eax, DWORD PTR $T223550[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$218586[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 628  : 			_Mylast = _Ptr + _Size;

	mov	edx, DWORD PTR __Size$218595[ebp]
	mov	eax, DWORD PTR __Ptr$218586[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$218586[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-204]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::reserve
PUBLIC	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T223650 = -64						; size = 4
$T223640 = -60						; size = 4
$T223628 = -56						; size = 4
$T223618 = -49						; size = 1
$T223617 = -48						; size = 4
__Cat$223635 = -19					; size = 1
$T223633 = -18						; size = 1
$T223632 = -17						; size = 1
$T223569 = -16						; size = 4
$T223565 = -12						; size = 4
$T223564 = -8						; size = 4
$T223563 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T223569[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T223569[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T223640[ebp], eax
	mov	ecx, DWORD PTR $T223640[ebp]
	mov	DWORD PTR $T223628[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T223632[ebp], dl
	mov	al, BYTE PTR __Cat$223635[ebp]
	mov	BYTE PTR $T223633[ebp], al
	mov	cl, BYTE PTR $T223632[ebp]
	mov	BYTE PTR $T223618[ebp], cl
	mov	edx, DWORD PTR $T223628[ebp]
	mov	DWORD PTR $T223617[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T223617[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T223640[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223650[ebp], edx
	mov	eax, DWORD PTR $T223650[ebp]
	mov	DWORD PTR $T223564[ebp], eax
	mov	ecx, DWORD PTR $T223564[ebp]
	mov	DWORD PTR $T223563[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223563[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223565[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAEXABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$223775 = -24					; size = 4
$T223753 = -20						; size = 4
$T223734 = -16						; size = 4
$T223721 = -12						; size = 4
$T223718 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223734[ebp], ecx
	mov	edx, DWORD PTR $T223734[ebp]
	mov	DWORD PTR $T223718[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T223718[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T223753[ebp], edx
	mov	eax, DWORD PTR $T223753[ebp]
	mov	DWORD PTR $T223721[ebp], eax
	mov	ecx, DWORD PTR $T223721[ebp]
	mov	DWORD PTR __Tmp$223775[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$223775[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$223775[ebp], ecx
	mov	edx, DWORD PTR __Tmp$223775[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::insert
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCity * *,CvCity * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T223831 = -44						; size = 4
$T223830 = -40						; size = 4
$T223819 = -36						; size = 4
$T223818 = -32						; size = 4
__Cat$223825 = -28					; size = 1
$T223823 = -27						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 4
	push	eax
	call	??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::unchecked_copy<CvCity * *,CvCity * *>
	add	esp, 12					; 0000000cH

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223831[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 4
	mov	DWORD PTR $T223830[ebp], ecx
	mov	edx, DWORD PTR $T223831[ebp]
	mov	DWORD PTR $T223819[ebp], edx
	mov	eax, DWORD PTR $T223830[ebp]
	mov	DWORD PTR $T223818[ebp], eax
	mov	cl, BYTE PTR __Cat$223825[ebp]
	mov	BYTE PTR $T223823[ebp], cl

; 1021 : 		--_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1022 : 		return (_Make_iter(_Where));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvCity *,std::allocator<CvCity *> >::~_Vector_val<CvCity *,std::allocator<CvCity *> >
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z$2
__ehfuncinfo$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T223952 = -52						; size = 4
$T223943 = -48						; size = 4
__Pnode$218716 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$218716[ebp], eax
	jmp	SHORT $LN6@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$218716[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase:
	mov	edx, DWORD PTR __Pnode$218716[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$218716[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$218716[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$218716[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T223952[ebp], edx
	mov	eax, DWORD PTR $T223952[ebp]
	add	eax, 4
	mov	DWORD PTR $T223943[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T223943[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN12@Erase
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Erase:

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z$2:
	mov	ecx, DWORD PTR $T223943[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Erase
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T224553 = -188						; size = 4
$T224465 = -172						; size = 4
$T224380 = -160						; size = 4
$T224364 = -156						; size = 4
$T224345 = -152						; size = 4
$T224341 = -148						; size = 4
$T224256 = -136						; size = 4
$T224155 = -120						; size = 4
$T224133 = -116						; size = 4
$T224126 = -112						; size = 4
$T224122 = -108						; size = 4
$T224083 = -104						; size = 4
$T224074 = -100						; size = 4
$T224054 = -96						; size = 4
__Count$224036 = -92					; size = 4
$T224020 = -88						; size = 28
$T224019 = -60						; size = 40
__Pnode$218734 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$224036[ebp], 214748364 ; 0cccccccH
	cmp	DWORD PTR __Count$224036[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$224036[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T224020[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T224020[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224019[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T224019[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T224019[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T224020[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T224054[ebp], edx
	mov	eax, DWORD PTR $T224054[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224074[ebp], eax
	mov	ecx, DWORD PTR $T224074[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224083[ebp], ecx
	mov	edx, DWORD PTR $T224083[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$218734[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+32]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T224122[ebp], edx
	mov	eax, DWORD PTR $T224122[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224126[ebp], ecx
	mov	edx, DWORD PTR __Pnode$218734[ebp]
	mov	eax, DWORD PTR $T224126[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$218734[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T224133[ebp], eax
	mov	ecx, DWORD PTR $T224133[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$218734[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+32], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+32], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$218734[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T224155[ebp], ecx
	mov	edx, DWORD PTR $T224155[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$218734[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$218734[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$218734[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$218734[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+32], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$218734[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T224256[ebp], ecx
	mov	edx, DWORD PTR $T224256[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T224341[ebp], edx
	mov	eax, DWORD PTR $T224341[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224345[ebp], ecx
	mov	edx, DWORD PTR $T224345[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$218734[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+32], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+32], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$218734[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T224364[ebp], ecx
	mov	edx, DWORD PTR $T224364[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+32], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$218734[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T224380[ebp], edx
	mov	eax, DWORD PTR $T224380[ebp]
	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$218734[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$218734[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$218734[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+32], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$218734[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T224465[ebp], edx
	mov	eax, DWORD PTR $T224465[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+32], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$218734[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T224553[ebp], eax
	mov	ecx, DWORD PTR $T224553[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+32], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T224020[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Insert
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 134  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T224659 = -12						; size = 4
$T224652 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224652[ebp], eax
	mov	ecx, DWORD PTR $T224652[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224659[ebp], ecx
	mov	edx, DWORD PTR $T224659[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T224735 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224735[ebp], eax
	mov	ecx, DWORD PTR $T224735[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
PUBLIC	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -208						; size = 4
tv148 = -204						; size = 4
tv172 = -200						; size = 4
_this$ = -196						; size = 4
$T224856 = -164						; size = 4
$T224855 = -160						; size = 4
$T224854 = -156						; size = 4
$T224844 = -152						; size = 4
$T224843 = -148						; size = 4
__Cat$224852 = -143					; size = 1
$T224850 = -142						; size = 1
$T224849 = -141						; size = 1
$T224823 = -140						; size = 4
$T224814 = -136						; size = 4
$T224783 = -48						; size = 4
$T224779 = -42						; size = 1
$T224766 = -41						; size = 1
$T224762 = -40						; size = 4
$T224755 = -32						; size = 4
$T224746 = -28						; size = 4
$T224745 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T224779[ebp]
	mov	DWORD PTR $T224755[ebp], eax
	lea	ecx, DWORD PTR $T224766[ebp]
	mov	DWORD PTR $T224762[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T224783[ebp], eax
	mov	ecx, DWORD PTR $T224783[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN3@vector

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224814[ebp], ecx
	mov	edx, DWORD PTR $T224814[ebp]
	mov	DWORD PTR $T224745[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224823[ebp], ecx
	mov	edx, DWORD PTR $T224823[ebp]
	mov	DWORD PTR $T224746[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224856[ebp], ecx
	mov	edx, DWORD PTR $T224745[ebp]
	mov	DWORD PTR $T224855[ebp], edx
	mov	eax, DWORD PTR $T224746[ebp]
	mov	DWORD PTR $T224854[ebp], eax
	mov	ecx, DWORD PTR $T224856[ebp]
	mov	DWORD PTR $T224844[ebp], ecx
	mov	edx, DWORD PTR $T224854[ebp]
	mov	DWORD PTR $T224843[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T224849[ebp], al
	mov	cl, BYTE PTR __Cat$224852[ebp]
	mov	BYTE PTR $T224850[ebp], cl
	movzx	edx, BYTE PTR $T224849[ebp]
	push	edx
	movzx	eax, BYTE PTR $T224850[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224844[ebp]
	push	edx
	mov	eax, DWORD PTR $T224855[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224843[ebp]
	push	ecx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN5@vector
__catch$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$224920 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$224920[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$224920[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$224920[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T224984 = -28						; size = 4
$T224983 = -24						; size = 4
$T224979 = -20						; size = 4
$T224978 = -16						; size = 4
$T224967 = -12						; size = 4
$T224966 = -8						; size = 4
__Cat$224973 = -2					; size = 1
$T224971 = -1						; size = 1
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T224979[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224978[ebp], ecx
	mov	edx, DWORD PTR $T224979[ebp]
	mov	DWORD PTR $T224967[ebp], edx
	mov	eax, DWORD PTR $T224978[ebp]
	mov	DWORD PTR $T224966[ebp], eax
	mov	cl, BYTE PTR __Cat$224973[ebp]
	mov	BYTE PTR $T224971[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T224984[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224983[ebp], eax
	mov	ecx, DWORD PTR $T224983[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
PUBLIC	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
PUBLIC	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T225538 = -412						; size = 4
$T225486 = -368						; size = 4
$T225474 = -364						; size = 4
$T225464 = -357						; size = 1
$T225463 = -356						; size = 4
__Cat$225482 = -327					; size = 1
$T225479 = -326						; size = 1
$T225478 = -325						; size = 1
$T225435 = -324						; size = 4
$T225427 = -320						; size = 4
$T225419 = -316						; size = 4
$T225408 = -312						; size = 4
$T225407 = -308						; size = 4
__Cat$225415 = -302					; size = 1
$T225412 = -301						; size = 1
$T225336 = -276						; size = 4
$T225317 = -272						; size = 4
$T225300 = -265						; size = 1
$T225299 = -264						; size = 4
$T225289 = -260						; size = 4
$T225288 = -256						; size = 4
__Cat$225324 = -250					; size = 1
$T225322 = -249						; size = 1
$T225321 = -248						; size = 1
__Cat$225332 = -247					; size = 1
$T225330 = -246						; size = 1
$T225329 = -245						; size = 1
$T225264 = -244						; size = 4
$T225263 = -240						; size = 4
$T225259 = -236						; size = 4
$T225258 = -232						; size = 4
$T225247 = -228						; size = 4
$T225246 = -224						; size = 4
__Cat$225254 = -218					; size = 1
$T225252 = -217						; size = 1
$T225211 = -216						; size = 4
$T225210 = -212						; size = 4
__Cat$225218 = -206					; size = 1
$T225216 = -205						; size = 1
$T225181 = -204						; size = 4
$T225180 = -200						; size = 4
__Cat$225188 = -194					; size = 1
$T225186 = -193						; size = 1
$T225161 = -192						; size = 4
$T225149 = -188						; size = 4
$T225139 = -181						; size = 1
$T225138 = -180						; size = 4
__Cat$225157 = -175					; size = 1
$T225155 = -174						; size = 1
$T225154 = -173						; size = 1
$T225126 = -172						; size = 4
$T225114 = -168						; size = 4
$T225104 = -161						; size = 1
$T225103 = -160						; size = 4
__Cat$225122 = -155					; size = 1
$T225120 = -154						; size = 1
$T225119 = -153						; size = 1
$T225091 = -152						; size = 4
$T225079 = -148						; size = 4
$T225069 = -141						; size = 1
$T225068 = -140						; size = 4
__Cat$225087 = -135					; size = 1
$T225085 = -134						; size = 1
$T225084 = -133						; size = 1
__Count$225045 = -120					; size = 4
__Count$225019 = -48					; size = 4
__Tmp$218882 = -44					; size = 4
__Oldend$218883 = -40					; size = 4
__Tmp$218872 = -36					; size = 4
__Ncopied$218859 = -32					; size = 4
__Newvec$218857 = -28					; size = 4
__Whereoff$218858 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$225019[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$225019[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$225019[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$225045[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$225045[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$225045[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ; std::_Allocate<CvCity *>
	add	esp, 8
	mov	DWORD PTR __Newvec$218857[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$218858[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$218859[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$218858[ebp]
	mov	ecx, DWORD PTR __Newvec$218857[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T225091[ebp], edx
	mov	eax, DWORD PTR $T225091[ebp]
	mov	DWORD PTR $T225079[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225084[ebp], cl
	mov	dl, BYTE PTR __Cat$225087[ebp]
	mov	BYTE PTR $T225085[ebp], dl
	mov	al, BYTE PTR $T225084[ebp]
	mov	BYTE PTR $T225069[ebp], al
	mov	ecx, DWORD PTR $T225079[ebp]
	mov	DWORD PTR $T225068[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225068[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$218859[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$218859[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225126[ebp], ecx
	mov	edx, DWORD PTR __Newvec$218857[ebp]
	mov	DWORD PTR $T225114[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T225119[ebp], al
	mov	cl, BYTE PTR __Cat$225122[ebp]
	mov	BYTE PTR $T225120[ebp], cl
	mov	dl, BYTE PTR $T225119[ebp]
	mov	BYTE PTR $T225104[ebp], dl
	mov	eax, DWORD PTR $T225114[ebp]
	mov	DWORD PTR $T225103[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225103[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225126[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$218859[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$218859[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T225161[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$218858[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$218857[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T225149[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T225154[ebp], dl
	mov	al, BYTE PTR __Cat$225157[ebp]
	mov	BYTE PTR $T225155[ebp], al
	mov	cl, BYTE PTR $T225154[ebp]
	mov	BYTE PTR $T225139[ebp], cl
	mov	edx, DWORD PTR $T225149[ebp]
	mov	DWORD PTR $T225138[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225138[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225161[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$218859[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$218858[ebp]
	mov	edx, DWORD PTR __Newvec$218857[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T225181[ebp], eax
	mov	ecx, DWORD PTR __Newvec$218857[ebp]
	mov	DWORD PTR $T225180[ebp], ecx
	mov	dl, BYTE PTR __Cat$225188[ebp]
	mov	BYTE PTR $T225186[ebp], dl
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$218859[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$218858[ebp]
	mov	ecx, DWORD PTR __Newvec$218857[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T225211[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$218858[ebp]
	mov	eax, DWORD PTR __Newvec$218857[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T225210[ebp], ecx
	mov	dl, BYTE PTR __Cat$225218[ebp]
	mov	BYTE PTR $T225216[ebp], dl
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$218857[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T225259[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T225258[ebp], edx
	mov	eax, DWORD PTR $T225259[ebp]
	mov	DWORD PTR $T225247[ebp], eax
	mov	ecx, DWORD PTR $T225258[ebp]
	mov	DWORD PTR $T225246[ebp], ecx
	mov	dl, BYTE PTR __Cat$225254[ebp]
	mov	BYTE PTR $T225252[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T225264[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225263[ebp], ecx
	mov	edx, DWORD PTR $T225263[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$218857[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$218857[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$218857[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$218872[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T225336[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T225317[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225329[ebp], cl
	mov	dl, BYTE PTR __Cat$225332[ebp]
	mov	BYTE PTR $T225330[ebp], dl
	mov	al, BYTE PTR $T225329[ebp]
	mov	BYTE PTR $T225300[ebp], al
	mov	ecx, DWORD PTR $T225317[ebp]
	mov	DWORD PTR $T225299[ebp], ecx
	mov	edx, DWORD PTR $T225299[ebp]
	mov	DWORD PTR $T225289[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T225288[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225321[ebp], cl
	mov	dl, BYTE PTR __Cat$225324[ebp]
	mov	BYTE PTR $T225322[ebp], dl
	movzx	eax, BYTE PTR $T225321[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T225322[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T225289[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225336[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225288[ebp]
	push	edx
	call	??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$218872[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T225419[ebp], eax
	mov	ecx, DWORD PTR $T225419[ebp]
	mov	DWORD PTR $T225408[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T225407[ebp], ecx
	mov	dl, BYTE PTR __Cat$225415[ebp]
	mov	BYTE PTR $T225412[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T225435[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T225427[ebp], edx
	jmp	SHORT $LN151@Insert_n
$LN150@Insert_n:
	mov	eax, DWORD PTR $T225427[ebp]
	add	eax, 4
	mov	DWORD PTR $T225427[ebp], eax
$LN151@Insert_n:
	mov	ecx, DWORD PTR $T225427[ebp]
	cmp	ecx, DWORD PTR $T225435[ebp]
	je	SHORT $LN147@Insert_n
	mov	edx, DWORD PTR $T225427[ebp]
	mov	eax, DWORD PTR __Tmp$218872[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n
$LN147@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$218882[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$218883[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T225486[ebp], eax
	mov	ecx, DWORD PTR $T225486[ebp]
	mov	DWORD PTR $T225474[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T225478[ebp], dl
	mov	al, BYTE PTR __Cat$225482[ebp]
	mov	BYTE PTR $T225479[ebp], al
	mov	cl, BYTE PTR $T225478[ebp]
	mov	BYTE PTR $T225464[ebp], cl
	mov	edx, DWORD PTR $T225474[ebp]
	mov	DWORD PTR $T225463[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225463[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$218883[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$218883[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$218883[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$218883[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T225538[ebp], ecx
	jmp	SHORT $LN186@Insert_n
$LN185@Insert_n:
	mov	edx, DWORD PTR $T225538[ebp]
	add	edx, 4
	mov	DWORD PTR $T225538[ebp], edx
$LN186@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T225538[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T225538[ebp]
	mov	ecx, DWORD PTR __Tmp$218882[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@2@IABQAVCvCity@@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T225609 = -40						; size = 4
$T225599 = -33						; size = 1
$T225598 = -32						; size = 4
__Cat$225605 = -3					; size = 1
$T225603 = -2						; size = 1
$T225602 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T225609[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225602[ebp], cl
	mov	dl, BYTE PTR __Cat$225605[ebp]
	mov	BYTE PTR $T225603[ebp], dl
	mov	al, BYTE PTR $T225602[ebp]
	mov	BYTE PTR $T225599[ebp], al
	mov	ecx, DWORD PTR $T225609[ebp]
	mov	DWORD PTR $T225598[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225598[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEPAPAVCvCity@@PAPAV3@IABQAV3@@Z ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Ufill
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T225613 = -80						; size = 28
$T225612 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ PROC ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T225613[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T225612[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T225612[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T225613[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225612[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T225612[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T225612[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T225613[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T225613[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T225612[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@KAXXZ ENDP ; std::vector<CvCity *,std::allocator<CvCity *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN3@Lbound

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound
$LN3@Lbound:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@ABQAVCvCity@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$5
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
_TEXT	SEGMENT
tv86 = -56						; size = 4
_this$ = -52						; size = 4
$T225696 = -48						; size = 4
$T225670 = -28						; size = 4
$T225669 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T225670[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T225670[ebp], 0
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR $T225670[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T225670[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T225670[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T225670[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T225696[ebp], ecx
	mov	edx, DWORD PTR $T225696[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR $T225696[ebp]
	add	ecx, 4
	call	??0?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@ABV01@@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::vector<CvCity *,std::allocator<CvCity *> >
	mov	eax, DWORD PTR $T225670[ebp]
	mov	cl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [eax+32], cl
	mov	edx, DWORD PTR $T225670[ebp]
	mov	BYTE PTR [edx+33], 0
	mov	eax, DWORD PTR $T225670[ebp]
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode
$LN4@Buynode:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T225669[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225670[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@PAU342@00ABU?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T225751 = -16						; size = 4
$T225730 = -12						; size = 4
$T225723 = -8						; size = 4
__Pnode$219020 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN6@Inc
	jmp	$LN7@Inc
$LN6@Inc:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T225723[ebp], ecx
	mov	edx, DWORD PTR $T225723[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	jne	SHORT $LN27@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T225730[ebp], eax
	mov	ecx, DWORD PTR $T225730[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225751[ebp], edx
$LN23@Inc:
	mov	eax, DWORD PTR $T225751[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN19@Inc
	mov	eax, DWORD PTR $T225751[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225751[ebp], ecx
	jmp	SHORT $LN23@Inc
$LN19@Inc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T225751[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$219020[ebp], eax
	mov	ecx, DWORD PTR __Pnode$219020[ebp]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN1@Inc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$219020[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$219020[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$219020[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T225803 = -16						; size = 4
$T225782 = -12						; size = 4
$T225775 = -8						; size = 4
__Pnode$219069 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225775[ebp], edx
	mov	eax, DWORD PTR $T225775[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225782[ebp], ecx
	mov	edx, DWORD PTR $T225782[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225803[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T225803[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T225803[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T225803[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T225803[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$219069[ebp], ecx
	mov	edx, DWORD PTR __Pnode$219069[ebp]
	movsx	eax, BYTE PTR [edx+33]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$219069[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$219069[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$219069[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Dec
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
$T225838 = -26						; size = 1
$T225837 = -25						; size = 1
$T225836 = -24						; size = 4
$T225835 = -20						; size = 4
__Off$225831 = -16					; size = 4
__Result$225832 = -12					; size = 4
__Cat$225823 = -4					; size = 1
$T225820 = -3						; size = 1
$T225819 = -2						; size = 1
$T225818 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvCity * *,CvCity * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T225818[ebp], al
	mov	cl, BYTE PTR __Cat$225823[ebp]
	mov	BYTE PTR $T225819[ebp], cl
	mov	dl, BYTE PTR $T225818[ebp]
	mov	BYTE PTR $T225838[ebp], dl
	mov	al, BYTE PTR $T225820[ebp]
	mov	BYTE PTR $T225837[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T225836[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225835[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T225835[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$225831[ebp], eax
	mov	ecx, DWORD PTR __Off$225831[ebp]
	mov	edx, DWORD PTR $T225836[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$225832[ebp], eax
	cmp	DWORD PTR __Off$225831[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$225831[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T225835[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$225831[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T225836[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$225832[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvCity * *,CvCity * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z
_TEXT	SEGMENT
$T225845 = -16						; size = 4
$T225841 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z PROC ; std::_Allocate<CvCity *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T225845[ebp], 0
	lea	eax, DWORD PTR $T225845[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225841[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T225841[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T225841[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvCity@@@std@@YAPAPAVCvCity@@IPAPAV1@@Z ENDP ; std::_Allocate<CvCity *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z
_TEXT	SEGMENT
$T225897 = -38						; size = 1
$T225896 = -37						; size = 1
$T225895 = -36						; size = 4
$T225894 = -32						; size = 4
$T225881 = -25						; size = 1
$T225880 = -24						; size = 4
$T225879 = -20						; size = 4
__Off$225890 = -16					; size = 4
__Result$225891 = -12					; size = 4
__Cat$225887 = -8					; size = 1
$T225885 = -7						; size = 1
$T225884 = -6						; size = 1
__Cat$225860 = -4					; size = 1
$T225857 = -3						; size = 1
$T225856 = -2						; size = 1
$T225855 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T225855[ebp], al
	mov	cl, BYTE PTR __Cat$225860[ebp]
	mov	BYTE PTR $T225856[ebp], cl
	mov	dl, BYTE PTR $T225855[ebp]
	mov	BYTE PTR $T225897[ebp], dl
	mov	al, BYTE PTR $T225857[ebp]
	mov	BYTE PTR $T225896[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T225895[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225894[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T225884[ebp], al
	mov	cl, BYTE PTR __Cat$225887[ebp]
	mov	BYTE PTR $T225885[ebp], cl
	mov	dl, BYTE PTR $T225884[ebp]
	mov	BYTE PTR $T225881[ebp], dl
	mov	eax, DWORD PTR $T225895[ebp]
	mov	DWORD PTR $T225880[ebp], eax
	mov	ecx, DWORD PTR $T225894[ebp]
	mov	DWORD PTR $T225879[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T225879[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$225890[ebp], edx
	mov	eax, DWORD PTR __Off$225890[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T225880[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$225891[ebp], ecx
	cmp	DWORD PTR __Off$225890[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$225890[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T225879[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$225890[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$225891[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$225891[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVCvCity@@PAPAV1@@stdext@@YAPAPAVCvCity@@PAPAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvCity * *,CvCity * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T225904 = -16						; size = 4
$T225900 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 36					; 00000024H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T225904[ebp], 0
	lea	eax, DWORD PTR $T225904[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225900[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T225900[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T225900[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 36					; 00000024H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv94 = -36						; size = 4
$T225951 = -32						; size = 4
$T225946 = -28						; size = 4
__Vptr$225944 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225951[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$225944[ebp], edx
	mov	eax, DWORD PTR __Vptr$225944[ebp]
	mov	DWORD PTR $T225946[ebp], eax
	cmp	DWORD PTR $T225946[ebp], 0
	je	SHORT $LN26@Uninit_cop
	mov	ecx, DWORD PTR $T225946[ebp]
	mov	edx, DWORD PTR $T225951[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T225946[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN22@Uninit_cop
$LN26@Uninit_cop:
	mov	DWORD PTR tv94[ebp], 0
$LN22@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_const_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z
_TEXT	SEGMENT
$T225998 = -22						; size = 1
$T225997 = -21						; size = 1
$T225996 = -20						; size = 4
$T225987 = -13						; size = 1
$T225986 = -12						; size = 4
$T225985 = -8						; size = 4
$T225990 = -4						; size = 1
$T225972 = -2						; size = 1
$T225971 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z PROC ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T225971[ebp], al
	mov	cl, BYTE PTR $T225971[ebp]
	mov	BYTE PTR $T225998[ebp], cl
	mov	dl, BYTE PTR $T225972[ebp]
	mov	BYTE PTR $T225997[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225996[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225990[ebp], cl
	mov	dl, BYTE PTR $T225990[ebp]
	mov	BYTE PTR $T225987[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T225986[ebp], eax
	mov	ecx, DWORD PTR $T225996[ebp]
	mov	DWORD PTR $T225985[ebp], ecx
	jmp	SHORT $LN9@unchecked_@2
$LN8@unchecked_@2:
	mov	edx, DWORD PTR $T225986[ebp]
	sub	edx, 1
	mov	DWORD PTR $T225986[ebp], edx
	mov	eax, DWORD PTR $T225985[ebp]
	add	eax, 4
	mov	DWORD PTR $T225985[ebp], eax
$LN9@unchecked_@2:
	cmp	DWORD PTR $T225986[ebp], 0
	jbe	SHORT $LN1@unchecked_@2
	mov	ecx, DWORD PTR $T225985[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@2
$LN1@unchecked_@2:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVCvCity@@IPAV1@@stdext@@YAXPAPAVCvCity@@IABQAV1@@Z ENDP ; stdext::unchecked_fill_n<CvCity * *,unsigned int,CvCity *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z
_TEXT	SEGMENT
$T226015 = -21						; size = 1
$T226014 = -20						; size = 4
$T226013 = -16						; size = 4
__Result$226010 = -12					; size = 4
__Count$226009 = -8					; size = 4
__Cat$226005 = -3					; size = 1
$T226002 = -2						; size = 1
$T226001 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T226001[ebp], al
	mov	cl, BYTE PTR __Cat$226005[ebp]
	mov	BYTE PTR $T226002[ebp], cl
	mov	dl, BYTE PTR $T226001[ebp]
	mov	BYTE PTR $T226015[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226014[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226013[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T226013[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$226009[ebp], edx
	mov	eax, DWORD PTR __Count$226009[ebp]
	mov	ecx, DWORD PTR $T226014[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$226010[ebp], edx
	cmp	DWORD PTR __Count$226009[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$226009[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T226013[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$226009[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T226014[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$226010[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@stdext@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv143 = -36						; size = 4
$T226072 = -32						; size = 4
$T226067 = -28						; size = 4
__Vptr$226065 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN18@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN18@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226072[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$226065[ebp], edx
	mov	eax, DWORD PTR __Vptr$226065[ebp]
	mov	DWORD PTR $T226067[ebp], eax
	cmp	DWORD PTR $T226067[ebp], 0
	je	SHORT $LN30@Uninit_cop@2
	mov	ecx, DWORD PTR $T226067[ebp]
	mov	edx, DWORD PTR $T226072[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T226067[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	jmp	SHORT $LN26@Uninit_cop@2
$LN30@Uninit_cop@2:
	mov	DWORD PTR tv143[ebp], 0
$LN26@Uninit_cop@2:
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@PAPAVCvCity@@V?$allocator@PAVCvCity@@@2@@std@@YAPAPAVCvCity@@V?$_Vector_iterator@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@0@0PAPAV1@AAV?$allocator@PAVCvCity@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<CvCity *,std::allocator<CvCity *> >,CvCity * *,std::allocator<CvCity *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVCvCity@@PAPAV1@V?$allocator@PAVCvCity@@@std@@@std@@YAPAPAVCvCity@@PAPAV1@00AAV?$allocator@PAVCvCity@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvCity * *,CvCity * *,std::allocator<CvCity *> >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
EXTRN	_atexit:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
;	COMDAT ??__Ems_kCityMap@@YAXXZ
text$yc	SEGMENT
$T226257 = -2						; size = 1
$T226256 = -1						; size = 1
??__Ems_kCityMap@@YAXXZ PROC				; `dynamic initializer for 'ms_kCityMap'', COMDAT

; 15   : static CityMap ms_kCityMap;

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	lea	eax, DWORD PTR $T226256[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226257[ebp]
	push	ecx
	mov	ecx, OFFSET _ms_kCityMap
	call	??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
	push	OFFSET ??__Fms_kCityMap@@YAXXZ		; `dynamic atexit destructor for 'ms_kCityMap''
	call	_atexit
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
??__Ems_kCityMap@@YAXXZ ENDP				; `dynamic initializer for 'ms_kCityMap''
text$yc	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Init
PUBLIC	??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T226342 = -47						; size = 1
$T226317 = -46						; size = 1
$T226299 = -45						; size = 1
$T226288 = -44						; size = 4
$T226327 = -40						; size = 4
$T226281 = -36						; size = 4
$T226274 = -28						; size = 4
$T226267 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T226342[ebp]
	mov	DWORD PTR $T226267[ebp], eax
	lea	ecx, DWORD PTR $T226317[ebp]
	mov	DWORD PTR $T226274[ebp], ecx
	lea	edx, DWORD PTR $T226299[ebp]
	mov	DWORD PTR $T226281[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T226327[ebp], esp
	mov	DWORD PTR $T226288[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvCity@@@1@ABV?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::~_Tree_val<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T226425 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+33], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226425[ebp], eax
	mov	ecx, DWORD PTR $T226425[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Init
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T226539 = -80						; size = 4
__Vptr$226537 = -76					; size = 4
$T226508 = -72						; size = 4
__Vptr$226514 = -68					; size = 4
$T226479 = -64						; size = 4
__Vptr$226485 = -60					; size = 4
$T226442 = -36						; size = 4
$T226441 = -32						; size = 4
$T226440 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T226440[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$226485[ebp], eax
	mov	ecx, DWORD PTR __Vptr$226485[ebp]
	mov	DWORD PTR $T226479[ebp], ecx
	cmp	DWORD PTR $T226479[ebp], 0
	je	SHORT $LN23@Buynode@2
	mov	edx, DWORD PTR $T226479[ebp]
	mov	eax, DWORD PTR $T226440[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T226479[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode@2
$LN23@Buynode@2:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode@2:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T226441[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$226514[ebp], eax
	mov	ecx, DWORD PTR __Vptr$226514[ebp]
	mov	DWORD PTR $T226508[ebp], ecx
	cmp	DWORD PTR $T226508[ebp], 0
	je	SHORT $LN33@Buynode@2
	mov	edx, DWORD PTR $T226508[ebp]
	mov	eax, DWORD PTR $T226441[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T226508[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode@2
$LN33@Buynode@2:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode@2:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T226442[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$226537[ebp], eax
	mov	ecx, DWORD PTR __Vptr$226537[ebp]
	mov	DWORD PTR $T226539[ebp], ecx
	cmp	DWORD PTR $T226539[ebp], 0
	je	SHORT $LN43@Buynode@2
	mov	edx, DWORD PTR $T226539[ebp]
	mov	eax, DWORD PTR $T226442[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T226539[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode@2
$LN43@Buynode@2:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode@2:
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode@2
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode@2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+32], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+33], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@2:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Node>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T226604 = -9						; size = 1
$T226600 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T226604[ebp]
	mov	DWORD PTR $T226600[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@QAE@U?$less@PAVCvCity@@@1@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??__Ems_kEmptyList@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Ems_kEmptyList@@YAXXZ$0
__ehfuncinfo$??__Ems_kEmptyList@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Ems_kEmptyList@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvcitymanager.cpp
xdata$x	ENDS
;	COMDAT ??__Ems_kEmptyList@@YAXXZ
text$yc	SEGMENT
tv90 = -128						; size = 4
tv147 = -124						; size = 4
$T226637 = -30						; size = 1
$T226624 = -29						; size = 1
$T226620 = -28						; size = 4
$T226613 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??__Ems_kEmptyList@@YAXXZ PROC				; `dynamic initializer for 'ms_kEmptyList'', COMDAT

; 17   : static CvCityManager::CityList ms_kEmptyList;

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__Ems_kEmptyList@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	lea	eax, DWORD PTR $T226637[ebp]
	mov	DWORD PTR $T226613[ebp], eax
	lea	ecx, DWORD PTR $T226624[ebp]
	mov	DWORD PTR $T226620[ebp], ecx
	mov	DWORD PTR tv147[ebp], OFFSET _ms_kEmptyList
	mov	DWORD PTR tv90[ebp], OFFSET _ms_kEmptyList
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, OFFSET _ms_kEmptyList
	call	?_Buy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAE_NI@Z ; std::vector<CvCity *,std::allocator<CvCity *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	OFFSET ??__Fms_kEmptyList@@YAXXZ	; `dynamic atexit destructor for 'ms_kEmptyList''
	call	_atexit
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yc	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Ems_kEmptyList@@YAXXZ$0:
	mov	ecx, OFFSET _ms_kEmptyList
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??__Ems_kEmptyList@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__Ems_kEmptyList@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Ems_kEmptyList@@YAXXZ ENDP				; `dynamic initializer for 'ms_kEmptyList''
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fms_kCityMap@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Fms_kCityMap@@YAXXZ$1
__ehfuncinfo$??__Fms_kCityMap@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fms_kCityMap@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??__Fms_kCityMap@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fms_kCityMap@@YAXXZ PROC				; `dynamic atexit destructor for 'ms_kCityMap'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__Fms_kCityMap@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET _ms_kCityMap
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Fms_kCityMap@@YAXXZ$1:
	mov	ecx, OFFSET _ms_kCityMap
	jmp	??1?$_Tree_val@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??__Fms_kCityMap@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__Fms_kCityMap@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Fms_kCityMap@@YAXXZ ENDP				; `dynamic atexit destructor for 'ms_kCityMap''
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T227228 = -88						; size = 4
$T227194 = -84						; size = 4
$T227027 = -32						; size = 4
$T227014 = -28						; size = 4
$T227002 = -24						; size = 4
$T226992 = -20						; size = 4
$T226991 = -16						; size = 4
$T226990 = -12						; size = 4
$T226989 = -8						; size = 4
$T226988 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227002[ebp], ecx
	mov	edx, DWORD PTR $T227002[ebp]
	mov	DWORD PTR $T226989[ebp], edx
	mov	eax, DWORD PTR $T226989[ebp]
	mov	DWORD PTR $T226988[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T227014[ebp], edx
	mov	eax, DWORD PTR $T227014[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T227027[ebp], ecx
	mov	edx, DWORD PTR $T227027[ebp]
	mov	DWORD PTR $T226991[ebp], edx
	mov	eax, DWORD PTR $T226991[ebp]
	mov	DWORD PTR $T226990[ebp], eax
	mov	ecx, DWORD PTR $T226988[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226990[ebp]
	push	edx
	lea	eax, DWORD PTR $T226992[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T227194[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227228[ebp], ecx
	mov	edx, DWORD PTR $T227228[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T227530 = -80						; size = 4
$T227524 = -76						; size = 4
__Tmp$227512 = -56					; size = 4
$T227440 = -52						; size = 4
$T227427 = -48						; size = 4
$T227276 = -28						; size = 4
$T227253 = -24						; size = 4
$T227240 = -20						; size = 4
$T227234 = -16						; size = 4
$T227233 = -12						; size = 4
$T227232 = -8						; size = 4
$T227231 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227240[ebp], ecx
	mov	edx, DWORD PTR $T227240[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227253[ebp], eax
	mov	ecx, DWORD PTR $T227253[ebp]
	mov	DWORD PTR $T227231[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T227231[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN89@erase@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227276[ebp], eax
	mov	ecx, DWORD PTR $T227276[ebp]
	mov	DWORD PTR $T227232[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T227232[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN89@erase@2

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227427[ebp], eax
	mov	ecx, DWORD PTR $T227427[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T227440[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T227440[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@2

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@2

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN89@erase@2:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@2

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$227512[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$227512[ebp]
	mov	DWORD PTR $T227233[ebp], ecx
	mov	edx, DWORD PTR $T227233[ebp]
	push	edx
	lea	eax, DWORD PTR $T227234[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
	jmp	SHORT $LN89@erase@2
$LN1@erase@2:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227530[ebp], ecx
	mov	edx, DWORD PTR $T227530[ebp]
	mov	DWORD PTR $T227524[ebp], edx
	mov	eax, DWORD PTR $T227524[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@2:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@PAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@U?$less@PAVCvCity@@@3@V?$allocator@U?$pair@QAVCvCity@@V?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@@std@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<CvCity *,std::vector<CvCity *,std::allocator<CvCity *> >,std::less<CvCity *>,std::allocator<std::pair<CvCity * const,std::vector<CvCity *,std::allocator<CvCity *> > > >,0> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fms_kEmptyList@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Fms_kEmptyList@@YAXXZ$0
__ehfuncinfo$??__Fms_kEmptyList@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fms_kEmptyList@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??__Fms_kEmptyList@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fms_kEmptyList@@YAXXZ PROC				; `dynamic atexit destructor for 'ms_kEmptyList'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__Fms_kEmptyList@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET _ms_kEmptyList
	call	?_Tidy@?$vector@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@IAEXXZ ; std::vector<CvCity *,std::allocator<CvCity *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Fms_kEmptyList@@YAXXZ$0:
	mov	ecx, OFFSET _ms_kEmptyList
	jmp	??1?$_Vector_val@PAVCvCity@@V?$allocator@PAVCvCity@@@std@@@std@@QAE@XZ
__ehhandler$??__Fms_kEmptyList@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__Fms_kEmptyList@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Fms_kEmptyList@@YAXXZ ENDP				; `dynamic atexit destructor for 'ms_kEmptyList''
_BSS	SEGMENT
_ms_kEmptyList DB 010H DUP (?)
_ms_kCityMap DB	0cH DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_ms_kCityMap$initializer$ DD FLAT:??__Ems_kCityMap@@YAXXZ
_ms_kEmptyList$initializer$ DD FLAT:??__Ems_kEmptyList@@YAXXZ
CRT$XCU	ENDS
END
